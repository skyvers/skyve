/*
 * Isomorphic SmartClient
 * Version v11.0p_2016-03-31 (2016-03-31)
 * Copyright(c) 1998 and beyond Isomorphic Software, Inc. All rights reserved.
 * "SmartClient" is a trademark of Isomorphic Software, Inc.
 *
 * licensing@smartclient.com
 *
 * http://smartclient.com/license
 */
isc.defineClass("SelectionOrRollOverCanvas", "Canvas").addProperties({
    cssPointerEvents: "none"
});

//> @class  ListGrid
// A ListGrid is a +link{DataBoundComponent} that displays a list of objects in a grid, where
// each row represents one object and each cell in the row represents one property.
//
//  @implements DataBoundComponent
//  @treeLocation Client Reference/Grids
//  @visibility external
//<
// Make ListGrid a subclass of VLayout. This allows us to change the order of the sub-components
// - show summary row between header and body, etc.

isc.ClassFactory.defineClass("ListGrid", "VLayout", "DataBoundComponent");

isc.defer("isc.ListGrid.addProperties({ showRollOver: !isc.Browser.isTouch });");

// Synonym for backCompat.  NOTE: define an alias rather than make a subclass, otherwise, attempts
// to skin the class using the old name would only affect the subclass!
isc.addGlobal("ListViewer", isc.ListGrid);
// define groups for documentation purposes

    //> @groupDef data
    //<

    //> @groupDef databinding
    // DataBinding means the automatic, highly customizable process of 'binding' a UI component
    // to a DataSource, so that a UI component displays, edits and saves DataSource records
    // using appropriate formatters, editors, validation rules, and persistence logic.
    //
    // @see interface:DataBoundComponent
    // @title DataBinding
    //<

    //> @groupDef sorting
    //<

    //> @groupDef editing
    // Data being displayed by a grid may be edited within the grid, by showing editing
    // interfaces embedded inside the cells of the grid.
    // <P>
    // <b>Enabling editing</b>
    // <P>
    // Editing is enabled when +link{listGrid.canEdit,canEdit} is <code>true</code>.  When enabled,
    // the user can begin editing via the
    // +link{listGrid.editEvent,editEvent}, typically click or double-click.  Editing can also be triggered
    // programmatically by a call to +link{listGrid.startEditing,startEditing()} or
    // +link{listGrid.startEditingNew,startEditingNew()}.
    // <P>
    // <b>New record creation</b>
    // <P>
    // By default, editing is restricted to existing records.  Setting +link{listGrid.listEndEditAction} to
    // "next" allows the user to create new records by simply navigating off the end of the dataset
    // with the keyboard.  Editing of new records can also be initiated with
    // +link{listGrid.startEditingNew()}, for example, from a button outside the grid.  See the
    // +link{group:unsavedRecords,Unsaved Records Overview} for special concerns when dealing
    // with unsaved records.
    // <P>
    // <b>Saving changes</b>
    // <P>
    // Saving of changes is triggered automatically when the user navigates out of the row or cell
    // being edited (based on +link{listGrid.saveByCell}) or when the user ends editing.   For
    // a "mass update" interface, automatic saving of changes can be disabled entirely via
    // +link{listGrid.autoSaveEdits,autoSaveEdits:false}, in which case a manual call to
    // +link{listGrid.saveEdits,saveEdits()} or +link{listGrid.saveAllEdits,saveAllEdits()} is required
    // to trigger saving.
    // <P>
    // If a grid has no DataSource, saving means that the properties of the +link{ListGridRecord}s
    // in +link{listGrid.data,grid.data} are directly changed.
    // <P>
    // For a grid with a DataSource, saving will be accomplished by using DataSource "update"
    // operations for existing records, and DataSource "add" operations for new records.  If multiple
    // records have been edited and +link{listGrid.saveAllEdits,saveAllEdits()} is called,
    // +link{rpcManager.startQueue,request queuing} will be automatically used to enable all
    // edits to be saved in one HTTP turnaround (if using the SmartClient Server).
    // <P>
    // By default, a grid will send only updated fields and primaryKey fields as part of
    // +link{dsRequest.data} so that the server can discern which fields the user actually changed.
    // However, the grid always includes the original field values in the
    // dsRequest as +link{dsRequest.oldValues}.
    // <P>
    // Note that although it is possible to load DataSource data without actually declaring a
    // +link{dataSourceField.primaryKey,primaryKey field}, a primaryKey must be declared for
    // editing and saving.  The values of primaryKey fields is how SmartClient identifies the
    // changed record to the server.
    // <P>
    // <b>Validation</b>
    // <P>
    // Any time saving is attempted, validation is automatically triggered.  Values entered by the
    // user will be checked against the +link{listGridField.validators} and the
    // +link{dataSourceField.validators}. Any invalid values abort an attempted save.
    // <P>
    // Similar to editing and saving, validation can be done on row transitions or on cell
    // transitions by setting +link{listGrid.validateByCell,validateByCell}, or can be disabled entirely
    // via +link{listGrid.neverValidate,neverValidate:true}.
    // <P>
    // <b>Editability of cells</b>
    // <P>
    // Editors will either be shown for the complete row or for a single cell based on
    // +link{listGrid,editByCell,editByCell}.  Whether a cell can be edited can be controlled on a
    // per field basis by setting +link{listGridField.canEdit,field.canEdit}, or on a per-record basis
    // by setting +link{listGrid.recordEditProperty,recordEditProperty} on a
    // +link{ListGridRecord,record}, or can be controlled on an arbitrary, programmatic basis via
    // an override of +link{listGrid.canEditCell()}.
    // <P>
    // Cells which are not editable just display the cell's current value.
    // <P>
    // <b>Keyboard Navigation</b>
    // <P>
    // Full keyboard navigation is supported by default, including Tab and Shift-Tab to navigate
    // between cells in a row, and Up Arrow and Down Arrow to traverse rows.  Several properties
    // on both grids and fields, all named *EditAction, control navigation behavior of certain keys
    // (eg Enter).
    // <P>
    // You can use +link{listGrid.startEditing,startEditing(<i>rowNum</i>, <i>colNum</i>)} to
    // programmatically move editing to a particular cell, for example, during a
    // +link{listGridField.changed,field.changed()} event.
    // <P>
    // <b>editValues (unsaved changes)</b>
    // <P>
    // The term "editValues" means changes that the user has made to the dataset which have not
    // been saved.  The grid manages and stores editValues separately from the data itself in order
    // to allow the user to revert to original values, and in order to enable to grid to send only
    // updated fields to the server.
    // <P>
    // Because editValues are stored separately, if you directly access the dataset (eg via
    // <code>grid.getData().get()</code>) you will see the records without the user's unsaved changes.
    // Many APIs exist for retrieving and managing editValues (search for editValue).
    // For the common case of needing to access the record-as-edited, you can call
    // +link{listGrid.getEditedRecord,grid.getEditedRecord(rowNum)}.
    // <P>
    // When accessing and manipulating edited data, you should think carefully about whether
    // you want to be working with the original data or with the edited version.  Values entered
    // by the user may not have been validated yet, or may have failed validation, hence you may
    // find a String value in a field of type "date" or "int", which could cause naive formatters or
    // totaling functions to crash.
    // <P>
    // Setting editValues via APIs such as +link{listGrid.setEditValue()} is fully equivalent
    // to the user making changes to data via the editing UI.  If you <i>also</i> allow editing
    // external to the grid, setting editValues is one way to combine changes from external
    // editors into the grid's edits, so that you can do a single save.
    // <P>
    // <b>Customizing Cell Editors</b>
    // <P>
    // When a cell is being edited, the editor displayed in the cell will be a +link{class:FormItem}.
    // The editor type for the cell will be determined by +link{listGrid.getEditorType()} based on the
    // specified +link{ListGridField.editorType} or +link{ListGridField.type, data type} for the field in
    // question.
    // <P>
    // You can customize the editor by setting +link{listGridField.editorProperties} to a set of
    // properties that is valid for that FormItem type.  Custom FormItem classes are also allowed,
    // for example, you may use +link{formItem.icons} to create an icon that launches a separate
    // +link{Dialog} in order to provide an arbitrary interface that allows the user to select the
    // value for a field.
    // <P>
    // <b>Events</b>
    // <P>
    // Editing triggers several events which you can provide handlers for in order to customize
    // editing behavior.  Some of the most popular are +link{listGridField.change,field.change()},
    // +link{listGridField.changed,field.changed()} for detecting changes made by the user,
    // +link{listGrid.cellChanged()} for detecting changes that have been successfully saved,
    // and +link{listGrid.editorEnter,editorEnter} and +link{listGrid.editorExit,editorExit()}
    // for detecting user navigation during editing.
    // <P>
    // <smartclient>
    // You can also install event handlers directly on the FormItem-based editors used in the grid
    // via +link{listGridField.editorProperties,editorProperties} as mentioned above.  When handling
    // events on items, or which involve items, be aware that in addition to standard
    // +link{FormItem} APIs, editors have the following properties:
    // <P>
    // - <code>rowNum</code>: The rowNum of the record being edited.<br>
    // - <code>colNum</code>: The colNum of the cell being edited.<br>
    // - <code>grid</code>: A pointer back to the listGrid containing the record.
    // </smartclient>
    // <smartgwt>
    // <code>ListGridField.setEditorType()</code> can be used to customize the editors shown
    // for each field, including providing FormItem-specific event handlers.  However,
    // ListGrid-provided event APIs should be used wherever possible (for example, use
    // <code>EditorEnterEvent</code> rather than <code>FocusEvent</code>).  If, in a FormItem
    // event handler, you need access to the ListGrid, you can either declare the event handler
    // as a Java "inner class" in a scope where the ListGrid is available as a final variable,
    // or you can use <code>event.getItem().getContainerWidget()</code>.  Note the ListGrid APIs
    // +link{listGrid.getEditRow,getEditRow()} and +link{listGrid.getEditCol,getEditCol()}
    // indicate what cell is being edited.
    // <P>
    // For more dynamic editor customization, include changing the type of editor used on a
    // per-row basis, use +sgwtLink{listGrid.setEditorCustomizer()}.
    // <P>
    // <b>NOTE:</b> with both APIs, in effect several FormItems are generated from the
    // customized FormItem you provide - see the docs for
    // +link{DataSourceField.editorType()} for special coding patterns that apply in this
    // case.
    // </smartgwt>
    // <P>
    // <b>Binary Fields</b>
    // <P>
    // The ListGrid will automatically show "view" and "download" icon buttons for binary field
    // types (see +link{type:ListGridFieldType}).  However, you cannot use an upload control
    // embedded within a ListGrid row to upload files (regardless of whether you use FileItem or
    // UploadItem).  This is because, in the browser's security model, native HTML upload
    // controls cannot be re-created and populated with a chosen file, and the ListGrid needs
    // to be able to re-create editors at any time in order to handle loading data on scroll,
    // scrolling editors in and out of view, adding new rows, changing sort direction, and
    // other use cases.
    // <P>
    // However you <i>can</i> create an editor with a +link{formItem.icons,FormItem icon} that
    // pops up a separate Window containing a FileItem in a DynamicForm, so long as the form in
    // the Window saves the uploaded file immediately rather than trying to have the grid
    // perform the save.
    //
    // @title Grid Editing
    // @treeLocation Client Reference/Grids/ListGrid
    // @visibility external
    //<
    


    //> @groupDef unsavedRecords
    // APIs such as +link{listGrid.startEditingNew(),startEditingNew()} or
    // +link{listGrid.listEndEditAction,listEndEditAction:"next"} allow editing records that have not
    // been saved to the server.  These unsaved records are special in several ways:
    // <ul>
    // <li> there is no actual Record object in the dataset for them: <code>getRecord(rowNum)</code>
    // will return null, instead, <code>getEditValues(rowNum)</code> allows access to field values for
    // the unsaved record
    // <li> rows for editing these records always appear at the end of the grid and do not sort with
    // other rows
    // <li> because unsaved records lack an actual Record object and lack a
    // +link{dataSourceField.primaryKey} value, they have limited functionality: they cannot be
    // selected, and do not support +link{listGrid.showRecordComponents} and certain other features.
    // </ul>
    // <P>
    // If you need to work with unsaved records and have all ListGrid features apply to them, this is
    // usually a sign that you should re-think your UI for adding new records.  Consider the following
    // approaches - which works best will depend on the application:
    // <ul>
    // <li> actually save a new record to persistent storage, then start editing it.  This has the
    // advantage that the user will never lose data by exiting the application with unsaved
    // records, which can be important if there is a lot of data entry before the record is ready to
    // save (for example, a new issue report in an issue-tracking applications, or a new blog entry).
    // This is also a good approach if the user may want to get a unique ID for the new record
    // right away (again useful for a new issue report or blog entry).
    // <P>
    // If values for several fields are required before the record should be visible on other screens
    // or to other users, you can add a field to the record to flag it as incomplete so that it is not
    // shown on other screens.  Alternatively, require certain fields to be entered via an external
    // form or dialog before the record is added to the grid.
    // <P>
    // Saving a new record and editing it can be done via +link{DataSource.addData()} followed by a call to
    // +link{listGrid.startEditing()} once the record has been saved.
    // <li> edit new records via a separate +link{DynamicForm,form} instead, possibly in a modal
    // +link{Window} - then unsaved records never need to be shown in the grid.  Similar to the
    // approach above, this modal form might have only certain minimum fields to make a valid
    // new record, then further editing could continue in the grid.
    // <li> use a +link{dataSource.clientOnly,clientOnly DataSource} so that records can be saved
    // immediately without contacting the server.  This is a good approach if several unsaved records
    // need to be manipulated by multiple components before they are finally saved.
    // <li> use +link{DataSource.updateCaches()} with an "add" DSResponse to cause a new record to be
    // added to the grid due to +link{ResultSet,automatic cache synchronization}.  At this point the
    // grid will believe the record exists on the server and it will be treated like any other saved
    // record.  This means your server code will need to handle the fact that the ListGrid will submit
    // "update" DSRequests for any subsequent edits.
    // </ul>
    // <b>NOTE about validation:</b> by design, SmartClient assumes that any record that has been
    // saved is valid and does not validate field values that appear in records loaded from the
    // server.  This includes records added to a clientOnly DataSource via
    // +link{DataSource.setCacheData()} as well as records added due to a call to
    // +link{DataSource.updateCaches()}.
    // <P>
    // Usually the best approach is to avoid this situation by editing such records in a form or other
    // control until they are valid rather than showing invalid records in a grid.  However, if such
    // records need to be considered invalid, one approach is to take field values and add them as
    // editValues via +link{listGrid.setEditValues()}.  At this point the ListGrid will consider the
    // values as user edits and will validate them.
    //
    // @title Handling Unsaved Records
    // @visibility external
    //<

    //> @groupDef imageColumns
    // Columns that show images either as their only appearance or in addition to text.
    //<

    //> @groupDef formulaFields
    // Fields with values calculated from other fields in the grid.
    //<

isc.defineClass("GridBody", isc.GridRenderer).addProperties({
    // suppress adjustOverflow while pending a redraw so we can resize smaller without seeing
    // a scrollbar flash in and out of existence
    adjustOverflowWhileDirty:false,

    
    _redrawToFixIEFocusScrollArtifacts:isc.Browser.isIE && isc.Browser.version > 9,

    initWidget : function () {
        this.Super("initWidget", arguments);

        
        if (isc.screenReader) this._redrawToFixIEFocusScrollArtifacts = false;
    },

    fireSelectionUpdated : function () {
        this.grid.fireSelectionUpdated();
    },

    canSelectRecord : function(record) {
        return this.grid.canSelectRecord(record);
    },
    
    redrawForSelectionChanged : function () {
        this.grid._markBodyForRedraw("selection changed");
    },

    // adjustOverflow() - overridden to support 'autoFitData' behavior
    adjustOverflow : function (reason, a,b,c,d) {
        // If we get naively called while undrawn just call Super which will bail.
        if (!this.isDrawn()) return this.Super("adjustOverflow", arguments);
        // we call 'getDelta' from this method which can fall back through to 'adjustOverflow'
        // Avoid infinite looping if we hit this case.
        if (this._calculatingDelta) return;
        
        if (this.grid._updatingRecordComponents) {
            return this.Super("adjustOverflow", arguments);
        }

        
        var grid = this.grid;

        
        if (grid == null) return this.Super("adjustOverflow", arguments);

        // Invalidate cached scrollHeight / scrollWidth so any calls to getScrollWidth/Height will
        // pick up values reflecting the current rendered HTML
        if (this._scrollWidth != null) delete this._scrollWidth;
        if (this._scrollHeight != null) delete this._scrollHeight;

        
        var data = grid.data, isLoading = false;;

        if (isc.isA.ResultSet(data) && !data.lengthIsKnown()) {
            if (grid.emptyMessageHeight == null) {
                return this.invokeSuper(isc.GridBody, "adjustOverflow", reason,a,b,c,d);
            }
            isLoading = true;
        }

        var initialWidth = this.getWidth(), initialHeight = this.getHeight();
        var fitVertical = (this.autoFitData == "both"),
            fitHorizontal = fitVertical,
            frozen = grid && grid.frozenFields != null,
            isFrozenBody = frozen && grid && (grid.frozenBody == this);

        if (!fitVertical) fitVertical = (this.autoFitData == "vertical");
        if (!fitHorizontal) fitHorizontal = (this.autoFitData == "horizontal");
        // If we have frozen fields, the frozen body never shows scrollbars and always
        // gets sized to match the widths of the fields it contains (done as part of
        // setBodyFieldWidths). Don't worry about trying to run special auto-fit logic
        // on the frozen body.
        // - We do run auto-fit logic on the unfrozen body and take the size of the frozen
        //   body into account when doing so.
        // - We do still need to ensure the header layout is sized correctly when the frozen
        //   body is resized
        
        if (fitHorizontal || fitVertical) {
            var height, width, rowHeights, hscrollOn, vscrollOn, dX, dY;

            if (fitVertical) {
                var minHeight = this.grid.getAutoFitMinBodyHeight();
                height = minHeight;
                var totalRows = isLoading ? 0 : this.getTotalRows(),
                    rows = totalRows;

                rowHeights = 0;
                // ignore autoFitMaxRecords if set to zero - this means fit to all records!
                if (this.autoFitMaxRecords) {
                    rows = Math.min(rows, this.autoFitMaxRecords);
                }
                if (rows > 0) {
                    // We need to handle variable rowHeights so we're going to have to look at
                    // the table element to determine the heights - we already have a method to
                    // do that
                    var drawnRowHeights = this._getDrawnRowHeights();
                    // If we have any undrawn rows assume calculated sizes
                    
                    var firstDrawnRow = this._firstDrawnRow,
                        lastDrawnRow = this._lastDrawnRow;

                    

                    // fdr / ldr unset implies no drawn rows - set such that we calculate
                    // theoretical heights only
                    if (this._firstDrawnRow == null) {
                        firstDrawnRow = rows;
                        lastDrawnRow = rows;
                    }
                    // _isFrozenBody defined in GridRenderer
                    var isFrozenBody = this._isFrozenBody();

                    if (firstDrawnRow > 0) {
                        firstDrawnRow = Math.min(firstDrawnRow, rows);
                        for (var i = 0; i < firstDrawnRow; i++) {
                            rowHeights += this.getRowHeight ?
                                            this.getRowHeight(this.grid.getRecord(i), i, isFrozenBody)
                                            : this.cellHeight;
                        }
                    }
                    var lastLogicalRow = rows-1;
                    if (lastDrawnRow < lastLogicalRow) {
                        for (var i = lastDrawnRow+1; i < lastLogicalRow+1; i++) {
                            rowHeights += this.getRowHeight ?
                                            this.getRowHeight(this.grid.getRecord(i), i, isFrozenBody)
                                            : this.cellHeight;
                        }
                    }
                    // Measure the rendered rows and add up the heights.
                    // Note that getDrawnRowHeights() just returns an array of the heights of
                    // rendered rows so the first drawn row is the first entry in the array, not
                    // the _firstDrawnRow'th entry
                    lastDrawnRow = Math.min(lastDrawnRow, lastLogicalRow);
                    for (var i = 0; i <= lastDrawnRow-firstDrawnRow; i++) {
                        rowHeights += drawnRowHeights[i];
                    }
                    // If we are clipping off any rows we know we have a v-scrollbar
                    vscrollOn = totalRows > rows;

                    // Treat autoFitMaxHeight:0 as unspecified - resize as large as necessary
                    var autoFitMaxHeight = this.getAutoFitMaxHeight();
                    if (autoFitMaxHeight && rowHeights > autoFitMaxHeight) {
                        rowHeights = autoFitMaxHeight;
                        vscrollOn = true;
                    }
//                     this.logWarn("total rows to show:"+ rows +
//                      ", rendered:" + [this._firstDrawnRow,this._lastDrawnRow] +
//                      ", rowHeights total up to:"+ rowHeights +
//                      ", current height:" + this.getHeight() +
//                      ", body height based on ListGrid specified height:" + height);

                } else {
                    // The emptyMessage renders in the available space. If emptyMessageHeight
                    // is explicitly set, leave that much space for it.
                    
                    if (this.grid.emptyMessageHeight != null) {
                        rowHeights = this.grid.emptyMessageHeight;
                    }
                }
                

                // add some extra height if autoFitExtraRecords is set
                
                if (this.autoFitExtraRecords && this.autoFitExtraRecords > 0) {
                    var extraHeight = Math.round(this.autoFitExtraRecords * this.cellHeight);
                    rowHeights += extraHeight;
                }

            } else {
                vscrollOn = this.getScrollHeight() > this.getHeight();
            }

            if (fitHorizontal && !isFrozenBody) {
                var width = this.grid.getInnerWidth(),
                    frozenBodyWidth;
                if (frozen) {
                    var frozenWidths = this.grid.getFrozenSlots(this.grid._fieldWidths);
                    frozenBodyWidth = frozenWidths.sum();
                    width -= frozenBodyWidth;

                    // if the frozenWidths exceed the specified width for the grid as a whole,
                    // apply an arbitrary small positive min width for the unfrozen body
                }


                // Note that we're calling getColumnSizes on the GridRenderer
                // So if we the LG is frozen body this gives us the cols within the
                // appropriate body, not the total set of cols in the grid.
                var colSizes = this.getColumnSizes(),
                    contentWidth = colSizes.sum();
                if (this.autoFitMaxColumns) {
                    var maxCols = this.autoFitMaxColumns;
                    // bit of a hack - how to deal with maxCols specified as a number <= the
                    // number of frozen fields.
                    // For now we just enforce at least one unfrozen field
                    if (frozen) {
                        maxCols = Math.max(1, maxCols-this.grid.frozenFields.length);
                    }

                    if (maxCols < colSizes.length) {
                        colSizes = colSizes.slice(0, maxCols);
                    }
                }

                var colWidths = colSizes.sum();
                if (this.autoFitMaxWidth) {
                    var maxWidth = this.autoFitMaxWidth;
                    if (frozen) maxWidth = Math.max(20, maxWidth - frozenBodyWidth);
                    colWidths = Math.min(maxWidth, colWidths);
                }
                hscrollOn = (this.overflow == isc.Canvas.SCROLL) ? true :
                            (this.overflow == isc.Canvas.AUTO) ? (contentWidth > Math.max(width, colWidths)) :
                            false;

            } else {
                hscrollOn = this.overflow == isc.Canvas.SCROLL ? true :
                            this.overflow == isc.Canvas.AUTO  ? this.getScrollWidth() > this.getWidth() :
                            false;
            }
            // Now we know if we have an h-scrollbar, adjust height and width for scrollbars /
            // borders / margin if appropriate
            if (fitVertical && rowHeights != null) {
                rowHeights += this.getVBorderPad() + this.getVMarginSize();
                if (hscrollOn) {
                    rowHeights += this.getScrollbarSize();
                    var autoFitMaxHeight = this.getAutoFitMaxHeight()
                    if (autoFitMaxHeight && rowHeights > autoFitMaxHeight) {
                        rowHeights = autoFitMaxHeight;
                    }
                }
                // Resize vertically if rowHeights (+ border etc) > the auto fit min height
                // (which is derived from the ListGrid's specified height)
                if (rowHeights > height) {
                    height = rowHeights;
                    this._vAutoFit = true;
                } else {
                    if (this._vAutoFit) delete this._vAutoFit;
                }
            }
            if (fitHorizontal && !isFrozenBody && colWidths != null) {

                colWidths += this.getHBorderPad() + this.getHMarginSize();
                // If we're showing a vertical scrollbar
                // or we're leaving a scrollbar gap, ensure we autoFit wide enough to
                // accomodate that scrollbar/gap
                if (vscrollOn || this.alwaysShowVScrollbar || this.grid._shouldLeaveScrollbarGap(!!vscrollOn)) {
                    colWidths += this.getScrollbarSize();
                    if (this.autoFitMaxWidth) {
                        var maxWidth = this.autoFitMaxWidth;
                        if (frozen) maxWidth = Math.max(20, maxWidth - frozenBodyWidth);
                        colWidths = Math.min(maxWidth, colWidths);
                    }
                }
                // Resize horizontally if colWidths > width
                if (colWidths > width) {
                    width = colWidths;
                    this._hAutoFit = true;
                } else {
                    if (this._hAutoFit) delete this._hAutoFit;
                }
            }

            // Calculate the delta with our current size.
            this._calculatingDelta = true;            
            dY = this.getDelta(this._$height, height, this.getHeight());

            dX = this.getDelta(this._$width, width, this.getWidth());
            delete this._calculatingDelta;
            // If necessary resize to accommodate content!
            if (dY != null || dX != null) {
                this.resizeBy(dX, dY, null, null, true);
            }

            // if width change != null, resize header to match body
            // Note that if isFrozenBody is true we skipped the dX calculation so
            // always resize the headerLayout to match
            
            if (dX != null || (isFrozenBody && fitHorizontal)) {
                var lg = this.grid,
                    scrollbarSize = lg._shouldLeaveScrollbarGap() ? lg.body.getScrollbarSize() : 0,
                    headerWidth = width - scrollbarSize,
                    totalHeaderWidth = headerWidth;
                if (frozen && lg.headerLayout) {

                    if (isFrozenBody) {
                        totalHeaderWidth = this.getWidth() + lg.body.getWidth();
                        // If we go past the autoFitMaxWidth limit, run adjustOverflow on the body
                        // to force it to shrink/start scrolling
                        if (lg.autoFitMaxWidth != null &&
                            (totalHeaderWidth + lg.getHBorderPad() +
                                lg.getHMarginSize() > lg.autoFitMaxWidth))
                        {
                            // don't bother to go on and resize the header - we'll do that
                            // when the body adjust overflow method runs
                            return lg.body.adjustOverflow();
                        }
                        totalHeaderWidth -= scrollbarSize;

                    } else {
                        totalHeaderWidth = headerWidth + lg.frozenBody.getWidth();
                    }
                    lg.headerLayout.setWidth(totalHeaderWidth);
                }

                // We can skip resizing the frozen header - this is handled in setBodyFieldWidths
                if (!isFrozenBody) {
                    var header = lg.header;

                    if (header && header.isDrawn()) {
                        header.setWidth(headerWidth);
                    }
                }
            }

        // if autoFitData is null but we don't match our 'specified size', assume the property
        // has been modified and reset to specified size
        }

        // catch the case where autoFitData has been cleared in either direction and
        // reset to specified size.
        var verticalChanged = (!fitVertical && this._vAutoFit),
            horizontalChanged = (!fitHorizontal && this._hAutoFit);
        if (verticalChanged || horizontalChanged) {
            delete this._vAutoFit;
            delete this._hAutoFit;

            var standardHeight = verticalChanged ? this.grid.getAutoFitMinBodyHeight() : null,
                standardWidth = horizontalChanged ?
                                (!frozen ? this.grid.getInnerWidth() :
                                    (this.grid.getInnerWidth() - this.grid.frozenBody.getWidth()) )
                                                  : null;
            
            this.resizeTo(width,height);
            // reset field widths on the grid to resize the header to match the body
            this.grid._updateFieldWidths("autoFitData mode changed");
        }
        var returnVal = this.invokeSuper(isc.GridBody, "adjustOverflow", reason, a,b,c,d);
        // if size changed, refresh recordComponents to account for new draw area
        if ((fitVertical || fitHorizontal) &&
            (this.getWidth() != initialWidth || this.getHeight() != initialHeight))
        {
            this.grid.updateRecordComponents(true);
        }

        // Fire the "bodyOverflowed" observation. This updates frozen body end space and
        // summary row body right space to so these can keep in sync with body scrolling
        // even though the viewport sizes are different.
        if (!isFrozenBody) this.grid.bodyOverflowed();
        return returnVal;
    },

    getAutoFitMaxHeight : function () {
        return this.grid ? this.grid.getAutoFitMaxBodyHeight() : null;
    },
    
    // When determining auto-fit-field-widths (drawn size of columns) we render out an
    // offscreen tester containing tableHTML and look at the various cells' widths in a row.
    // If the grid is grouped, we need to choose a row which isn't the group header
    // since that contains col-spanning cells
    _getValidAutoFitRowNum : function () {
        var grid = this.grid;
        if (this.grid && this.grid.isGrouped) {
            var rowNum = 0;
            while (rowNum < this.grid.getTotalRows()) {
                var record = this.grid.getRecord(rowNum);
                if (record == null || !this.grid.isGroupNode(record)) {
                    return rowNum;
                }
                rowNum++;
            }
        }
        return 0;
    },


    resizeBy : function (deltaX, deltaY, animating, suppressHandleUpdate, autoFitSize) {

        // autoFitSize parameter: When autoFitData is true for this grid, we resize the
        // body to fit the data, and pass in the autoFitSize parameter to this method.
        // In the case of an explicit resize outside the autoFitData system, hang onto the
        // specified size so we can reset to it if the data shrinks, etc
        if (!autoFitSize) {
            this._specifiedWidth = this.getWidth() + (deltaX != null ? deltaX : 0);
        }

        // Note that return value of resizeBy indicates whether the size actually changed
        var returnVal = this.invokeSuper(isc.GridBody, "resizeBy",
                                deltaX, deltaY, animating, suppressHandleUpdate, autoFitSize);
        // we usually update _userWidth/_userHeight as part of layout.childResized to
        // store the explicit width, which then stops the member reacting to the layout's
        // subsequent resizes.
        // However, if we're autoFitting the (unfrozen) body to content, we want a
        // subsequent resize of the grid as a whole to still cause the body to expand
        // further.
        // Therefore yank out this _userSize flag in this case.
        if (autoFitSize && deltaX != null && !this.frozen) {
            delete this._userWidth;
        }
        return returnVal;
    },

    // context menus (NOTE: ListGrid-level handling is identical for cell vs row context click)
    cellContextClick : function (record, rowNum, colNum) {
        var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
        return this.grid._cellContextClick(record, rowNum, gridColNum);
    },

    // Override _rowClick: If a record is marked as disabled this suppresses all events, but
    // if the user clicks in the "remove" field of an already removed record we actually want
    // to react to this and unmarkAsRemoved()
    _rowClick : function (rowNum, colNum) {
        if (!this.grid) return;
        var returnVal;
        var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
        
        var rec = rowNum >= 0 ? this.grid.getRecord(rowNum) : null,
            field = gridColNum >= 0 ? this.grid.getField(gridColNum) : null,
            isRemoveClick = false
        ;
        
        if (!isc.isA.RecordEditor(this.grid) && field && field.isRemoveField) {
            // If the user clicks inside the remove field on a group or summary row, don't fire
            // the remove-click!
            isRemoveClick = !rec || !(rec._isGroup || rec.isGroupSummary || rec.isGridSummary);
        }
        
        if (isRemoveClick) {
            if (rowNum >= 0) {
                this.grid.removeRecordClick(rowNum,colNum);
                returnVal = false;
            }
        } else {
            returnVal = this.Super("_rowClick", arguments);
        }
        return returnVal;
    },
    
    getCellHoverDelay : function (rowNum, colNum) {
        if (!this.grid) return;
        var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
        return this.grid.getCellHoverDelay(this.grid.getCellRecord(rowNum,colNum), rowNum, colNum);
    },


    _getCellHoverComponent : function (record, rowNum, colNum) {
        if (this.grid && isc.isA.ListGrid(this.grid)) {
            var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
            return this.grid._getCellHoverComponent(record, rowNum, gridColNum);
        }
    },


    // this ensures that if we're not showing any records we can still scroll the header fields
    // into view.
    expandEmptyMessageToMatchFields:true,
    applyHSpaceToEmptyMessage:true,

    getInnerHTML : function () {
        // call bodyDrawing on the LG if we are the primary body
        this.grid.bodyDrawing(this);
        return this.Super("getInnerHTML", arguments);
    },
    
    // Override _canFocus to check for whether we have any data.
    _canFocus : function () {
        var canFocus = this.Super("_canFocus", arguments);
        if (canFocus && this.grid && !this.grid.canFocusInEmptyGrid && this.isEmpty()) {
            return false;
        }
        return canFocus;
    },

    // ------------------------------------------------------
    //
    // PrintHTML
    // This needs some tweaking to handle the following:
    // - printHTML can be generated asynchronously in 2 ways:
    //  - if number of rows exceeds printMaxRows we use timers to break up the HTML generation
    //  - if we have embeddedComponents fetching their printHTML may also be asynchronous
    //
    // In either case, 'getTableHTML()' will be fired more than once, asynchronously.
    // In the case of async embedded component printHTML generation, this is the standard
    // mechanism - see 'gotComponentPrintHTML' in GridRenderer.
    // In the case of splitting the printing into chunks, the _printingChunk
    // flag will be set and startRow/endRow will be shifted, then getTableHTML will be called
    // on a timer, repeatedly until all the rows' HTML is generated.
    //
    // We need to fire the 'prepareBodyForPrinting' and 'bodyDonePrinting' methods on the ListGrid
    // around each of these blocks - this is required as the ListGrid relies on the body to
    // handle generating header HTML and if there are frozen fields, HTML from the frozen
    // body, and does so by setting various flags on the GR body which'll be read by
    // getTableHTML()
    //
    
    
    getTablePrintHTML : function (context) {
        // context contains startRow, endRow, callback, printProperties, printWidths
        var startRow = context.startRow,
            endRow = context.endRow,
            totalRows = endRow != null ? (endRow - startRow) : this.getTotalRows(),
            maxRows = this.printMaxRows,
            printWidths = context.printWidths,
            printProps = context.printProps;

        var asyncPrintCallback = {
            target:this,
            methodName:"gotTablePrintHTML",
            printContext:context,
            printCallback:context.callback
        }

        context.callback = asyncPrintCallback;

        if (maxRows < totalRows) {
            this.logDebug("get table print html - breaking HTML into chunks", "printing");
            if (startRow == null) startRow = context.startRow = 0;
            if (endRow == null) endRow = context.endRow = this.getTotalRows();
            this.getPrintHTMLChunk(context);

            return null;
        }

        // No chunks - can only be asynchronous due to getTableHTML directly going async
        // to get embeddedComponentHTML
        var suspendPrintingContext = this.grid._prepareBodyForPrinting(printWidths, printProps);
        var printHTML = this.getTableHTML(null, startRow, endRow, null, asyncPrintCallback);

        // restore settings
        this.grid._bodyDonePrinting(suspendPrintingContext);
        return printHTML;
    },

    gotTablePrintHTML : function (HTML, asyncCallback) {
        var callback = asyncCallback.printCallback;
        if (callback) {
            this.fireCallback(callback, "HTML,callback", [HTML,callback]);
        }
    },

    // This is called repeatedly, asynchronously for each "chunk"
    // The first chunk may include fetches for component tableHTML so can also be asynchronous
    // itself.
    
    getPrintHTMLChunk : function (context, returnSynchronous) {

        var suspendPrintingContext = this.grid._prepareBodyForPrinting(context.printWidths);
        // printing chunk flag - used by the GR to avoid writing out the outer table tags for each
        // chunk.
        this._printingChunk = true;

        // Second flag to indicate we are printing chunks. This is used only by
        // gotComponentPrintHTML() to reset the _printingChunk flag before calling
        // getTableHTML
        this._gettingPrintChunkHTML = true;

        var startRow = context.startRow,
            endRow = context.endRow,
            maxRows = this.printMaxRows,
            callback = context.callback;

        this.currentPrintProperties = context.printProps;

        if (!context.html) context.html = [];

        var chunkEndRow = context.chunkEndRow = Math.min(endRow, (startRow + maxRows)),
            chunkHTML = this.getTableHTML(null, startRow, chunkEndRow, null,
                {target:this, methodName:"gotPrintChunkHTML",
                    printContext:context, printCallback:context.callback
                });

        // restore settings
        this.grid._bodyDonePrinting(suspendPrintingContext);
        this._printingChunk = false;

        // chunkHTML will only be null if getTableHTML went asynchronous - can happen on the
        // first chunk while retrieving embedded componentHTML
        if (chunkHTML != null) {
            delete this._gettingPrintChunkHTML;
            this.gotPrintChunkHTML(chunkHTML, {printContext:context});
            if (returnSynchronous) {
                return chunkHTML;
            }
        }
    },
    gotPrintChunkHTML : function (HTML, callback) {
        var context = callback.printContext,
            startRow = context.startRow,
            endRow = context.endRow,
            chunkEndRow = context.chunkEndRow,
            maxRows = this.printMaxRows,
            gotHTMLCallback = context.callback;

        context.html.add(HTML);

        if (chunkEndRow < endRow) {
            context.startRow = chunkEndRow;
            return this.delayCall("getPrintHTMLChunk", [context], 0);
        }

        if (gotHTMLCallback != null) {
            var html = context.html.join(isc.emptyString);
            this.fireCallback(gotHTMLCallback, "HTML,callback", [html,gotHTMLCallback]);
        }
    },

    // In GridRenderer.getTableHTML(), when printing, we generate all embedded components'
    // print HTML up front, then slot it into the actual HTML for the table.
    // component printHTML may be asynchronously generated in which case this callback is
    // fired when we have the component HTML - default implementation re-runs getTableHTML
    // which now recognizes it's got component HTML and continues to get the actual table
    // HTML then fire the async callback.
    // Overridden to call 'prepareBodyForPrinting()' on the grid and reset the '_printingChunk'
    // flag if necessary
    gotComponentPrintHTML : function (HTML, callback) {

        var asyncCallback = callback.context.asyncCallback,
            context = asyncCallback.printContext;

        var printWidths = context.printWidths;

        var suspendPrintingContext = this.grid._prepareBodyForPrinting(printWidths);
        if (this._gettingPrintChunkHTML) {
            this._printingChunk = true;
        }

        var HTML = this.Super("gotComponentPrintHTML", arguments);
        if (this._printingChunk) delete this._printingChunk;

        if (HTML != null) {
            delete this._gettingPrintChunkHTML;
        } else {
            this.grid._bodyDonePrinting(suspendPrintingContext);
        }

    },

    // override getPrintHeaders / getPrintFooters to return the
    // already calculated HTML set up by the calling grid.
    
    getPrintHeaders : function (startCol, endCol) {
        var HTML = this._printHeadersHTML;
        // Lazily clean up this attribute.
        
        delete this._printHeadersHTML;
        return HTML == null ? "" : HTML;
    },

    getPrintFooters : function (startCol, endCol) {
        var HTML = this._printFootersHTML;
        delete this._printFootersHTML;
        return HTML == null ? "" : HTML;
    },

    // Row Spanning Cells
    // ----------------------------

    


    refreshCellValue : function (rowNum, colNum) {
        var lg = this.grid;
        if (rowNum >= 0 && colNum >= 0 && lg && lg.allowRowSpanning && lg.useRowSpanStyling)
        {
            // If we're asked to refresh a logical cell that's not rendered
            // (actually spanned by another cell) we could either refuse or refresh the
            // spanning cell. Refresh the spanning cell in case its value is calculated
            // from the cell in question.
            var startRow = this.getCellStartRow(rowNum, colNum);
            if (startRow != rowNum) {
                rowNum = startRow;
            }
        }
        isc.GridRenderer._instancePrototype.refreshCellValue.call(this, rowNum, colNum);
    },


    // Cell Alignment
    // ---------------------------------------------------------------------------------------

    // cellAlignment - override to account for the fact that with frozen fields, body
    // colNum may be offset from ListGrid colNum
    getCellVAlign : function (record, field, rowNum, colNum) {
        if (this.grid && this.grid.getCellVAlign) {
            var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
            return this.grid.getCellVAlign(record, rowNum, gridColNum);
        }
    },
    getCellAlign : function (record, field, rowNum, colNum) {

        if (this.grid && this.grid.getCellAlign != null) {
            var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
            return this.grid.getCellAlign(record, rowNum, gridColNum);

        } else return field.cellAlign || field.align;
    },

    // Single Cell rows
    // ---------------------------------------------------------------------------------------

    // if this is removed, DONTCOMBINE directive no longer needed in GridRenderer.js
    _drawRecordAsSingleCell : function (rowNum, record,c) {
        var lg = this.grid;
        if (lg.showNewRecordRow && lg._isNewRecordRow(rowNum)) return true;
        
        return isc.GridRenderer._instancePrototype.
            _drawRecordAsSingleCell.call(this, rowNum,record,c);
        //return this.Super("_drawRecordAsSingleCell", arguments);
    },

    // showSingleCellCheckboxField()
    // If this record is showing a single cell value, should a checkbox field also show up next
    // to the record?
    showSingleCellCheckboxField : function (record) {
        var lg = this.grid;
        return lg && lg.showSingleCellCheckboxField(record);
    },

    // This method is called on records where _drawRecordAsSingleCell is true
    // returns the start/end col the single cell value should span.
    // Typically just spans all the cells we render out but if we're showing the
    // checkbox field we may want to NOT span over that field
    _getSingleCellSpan : function (record, rowNum, startCol, endCol) {
        // Span all columns if we're not showing a checkbox field
        
        if (rowNum == this._animatedShowStartRow ||
            !this.showSingleCellCheckboxField(record) ||
            (this.grid && this.grid.frozenBody != null && this.grid.frozenBody != this))
        {
            return [startCol,endCol];
        }

        
        return [Math.max(startCol, 1), endCol];
    },

    // Scrolling / Scroll Sync
    // ---------------------------------------------------------------------------------------

    // Have v-scrolling occur on the frozen body on mouseWheel
    // This essentially duplicates the mouseWheel handler at the Canvas level for
    // widgets with visible scrollbars.
    mouseWheel : function () {
        if (this.frozen && this.grid != null) {
            var wheelDelta = this.ns.EH.lastEvent.wheelDelta;
            var scrollTo = this.scrollTop + Math.round(wheelDelta * isc.Canvas.scrollWheelDelta);
            // Scroll the main body (we'll scroll in response to that) rather than
            // scrolling the frozen body directly.
            this.grid.body.scrollTo(null, scrollTo, "frozenMouseWheel");
            return false;
        }
        return this.Super("mouseWheel", arguments);
    },

    // Override _getDrawRows()
    // Have the frozen body rely on the unfrozen body to handle drawAhead / quickDrawAhead
    // etc and keep set of drawn rows in sync
    
    _getDrawRows : function () {
        if (this.frozen && this.grid) {
            var grid = this.grid;
            return grid.body._getDrawRows();
        }
        return this.Super("_getDrawRows", arguments);
    },

    // doneFastScrolling: ensure *both* bodies redraw without draw-ahead direction
    doneFastScrolling : function () {
        // we only expect to see this fire on the unfrozen body - the frozen body doesn't
        // show a scrollbar so won't get the thumb drag which initializes this method
        if (!this.frozen && this.grid != null && this.grid.frozenBody != null) {

            var redrawFrozenBody = this._appliedQuickDrawAhead;
            this.Super("doneFastScrolling", arguments);
            if (redrawFrozenBody) {
                this.grid.frozenBody._suppressDrawAheadDirection = true;
                this.grid.frozenBody.markForRedraw("Done fast scrolling on unfrozen body");
            }
        }
    },

    // observe the scroll routine of the body so we can sync up
    scrollTo : function (left, top, reason, animating) {
        if (isc._traceMarkers) arguments.__this = this;
        // Clamp the positions passed in to the edges of the viewport
        // (avoids the header from getting out of sync with the body.)
        
        if (left != null) {
            
            var maxScrollLeft = this.getScrollWidth() - this.getViewportWidth();
            left = Math.max(0, Math.min(maxScrollLeft, left));
        }
        if (top != null) {
            
            var maxScrollTop = this.getScrollHeight() - this.getViewportHeight();
            top = Math.max(0, Math.min(maxScrollTop, top));
        }
        var lg = this.grid;

        
        this.invokeSuper(isc.GridBody, "scrollTo", left,top,reason,animating);

        //this.logWarn("body.scrollTo: " + this.getStackTrace());
        // dontReport when we're being called in response to bodyScrolled
        // observation!
        var dontReport = this._noScrollObservation;
        if (!dontReport) lg.bodyScrolled(left, top, this.frozen);

        // If the body scrolled without forcing a redraw, ensure any visible edit form
        // items are notified that they have moved.
        
        if (!this.isDirty() && lg._editorShowing) {
            var form = lg._editRowForm,
                allItems = form.getItems(),
                items = [];
            for (var i = 0; i < allItems.length; i++) {
                if (allItems[i].isDrawn()) items.add(allItems[i]);
            }
            form.itemsMoved(items);
        }

    },

    // Embedded Components
    // ---------------------------------------------------------------------------------------

    // embedded components can be per row or per cell.
    // When per-cell the GR APIs act by colNum only, not by field name.
    // However for us to handle field reorder, show/hide, etc it's useful to hang fieldName
    // onto the embeddedComponents as well
    addEmbeddedComponent : function (component, record, rowNum, colNum, position) {
        var comp = this.invokeSuper(isc.GridBody, "addEmbeddedComponent", component, record,
                                    rowNum, colNum, position);
        if (component._currentColNum != null && component._currentColNum != -1 && this.grid) {
            var grid = this.grid,
                colNum = component._currentColNum,
                gridColNum = grid.getFieldNumFromLocal(colNum, this),
                fieldName = grid.getFieldName(gridColNum);

            component._currentFieldName = fieldName;

            // set up a map of embedded components per column (fieldName)
            // This will make lookup quicker.
            if (grid._columnComponentsMap == null) {
                grid._columnComponentsMap = {};
            }
            if (grid._columnComponentsMap[fieldName] == null) {
                grid._columnComponentsMap[fieldName] = {};
            }
            grid._columnComponentsMap[fieldName][component.getID()] = true;
            // skip "%" sized components since they should never expand a field.
            if (component._percent_width == null) {
                grid._fieldComponentWidthsChanged(fieldName);
            }
        }

        return component;
    },
    removeEmbeddedComponent : function (record, component, suppressRedraw) {
        var grid = this.grid;
        if (grid) {
            var fieldName = component._currentFieldName;
            if (fieldName != null) {
                if (grid._columnComponentsMap && grid._columnComponentsMap[fieldName]) {
                    delete grid._columnComponentsMap[fieldName][component.getID()];
                }
                if (component._percent_width == null) {
                    grid._fieldComponentWidthsChanged(fieldName);
                }
            }
            // Clear out the stored field name which is basically stale at this point.
            component._currentFieldName = null;
        }
        this.invokeSuper(isc.GridBody, "removeEmbeddedComponent", record, component, suppressRedraw);
    },


    // Override getMaxEmbeddedComponentHeight() / upateHeightForEmbeddedComponents to
    // respect listGrid.recordComponentHeight if specified, even if there are no
    // embedded components for this record.
    
    updateHeightForEmbeddedComponents : function (record, rowNum, height) {

        if (record && !this.grid._hasEmbeddedComponents(record) && this.grid.showRecordComponents
            && this.grid.recordComponentHeight != null)
        {
            // Reimplementing the superClass version, except that this logic is running even
            // when there are no embeddedComponents on the row.
            var details = this.getMaxEmbeddedComponentHeight(record, rowNum);
            if (details.allWithin) {
                height = Math.max(height,details.requiredHeight);
                //this.logWarn("in updateHeightForEmbeddedComponents ("+this.grid+"): details are "+isc.echoAll(details)+"\nheight is "+height);
            } else {
                height += details.requiredHeight;
                //this.logWarn("in updateHeightForEmbeddedComponents ("+this.grid+"): details are "+isc.echoAll(details)+"\nheight is "+height);
            }

            return height;
        }

        return this.invokeSuper(isc.GridBody, "updateHeightForEmbeddedComponents", record, rowNum, height);
    },

    getMaxEmbeddedComponentHeight : function (record, rowNum) {
        var heightConfig = this.invokeSuper(isc.GridBody, "getMaxEmbeddedComponentHeight",
                                        record, rowNum);
        if (this.grid.showRecordComponents && this.grid.recordComponentHeight != null) {
            heightConfig.requiredHeight = Math.max(heightConfig.requiredHeight,
                                            this.grid.recordComponentHeight);
        }
        return heightConfig;
    },
    _writeEmbeddedComponentSpacer : function (record) {
        if (record && this.grid && this.grid.showRecordComponents
            && this.grid.recordComponentHeight != null)
        {
            return true;
        }
        return this.invokeSuper(isc.GridBody, "_writeEmbeddedComponentSpacer", record);
    },

    _placeEmbeddedComponents : function () {
        
        if (this.grid && this.grid._autoFittingFields) {
            return;
        }
        return this.Super("_placeEmbeddedComponents", arguments);
    },

    getAvgRowHeight : function () {
        if (this.grid) return this.grid.getAvgRowHeight(this);
        return this.Super("getAvgRowHeight", arguments);
    },

    // override shouldShowAllColumns() - we can avoid showing all columns if row height
    // is variable *only* because of an expansion component expanding the entire row since
    // the heights won't vary per-cell.
    shouldShowAllColumns : function () {
        if (this.showAllColumns) {
            return true;
        }
        if (!this.fixedRowHeights && !this.showAllRows) {
            if (this.grid.canExpandRecords && this.grid._specifiedFixedRecordHeights) {
                return false;
            }
            return true;
        }
        if (this.overflow == isc.Canvas.VISIBLE) {
            return true;
        }
        return false;

    },

    // Editing
    // ---------------------------------------------------------------------------------------

    //> @method listGrid.markForRedraw()
    // @include canvas.markForRedraw
    // @visibility external
    //<

    // Redraw overridden:
    // - Update the editRow form items (we don't create more items than we need when
    //   rendering incrementally)
    // - Update the values in the edit row form.
    redraw : function (reason,b,c,d) {

        // since we're doing a full redraw, cancel pending refreshCell() calls
        if (this._pendingCellRefreshTimer) this.cancelPendingCellRefresh();

        // flag to note we're redrawing - this is used by getDrawnFields()
        this._redrawing = true;

        // If alwaysShowEditors is marked as true, but editorShowing is false it implies our
        // attempt to start editing on draw() failed - presumably there were no
        // editable cells in view.
        // See if we can start editing now in this case
        var lg = this.grid;
        if (lg.alwaysShowEditors && !lg._editorShowing) {
            lg.startEditing(null,null,true,null,true);
        }

        
        var editForm = lg._editRowForm,
            editing = lg._editorShowing,
            editColNum, editRowNum, editRecord,
            completeWidths,
            fieldsToRemove;

        // If the grid is showing inactive Editor HTML for any cells, we'll clear it
        // (and potentially regenerate it) as part of redraw(). Notify the grid so it can clear
        // up inactive contexts stored on the edit form items
        
        lg._clearingInactiveEditorHTML();

        // if body redraw came from data change, folder opening, or resizing of content,
        // it's likely to introduce a v-scrollbar.
        // If leaveScrollbarGap is false, call '_updateFieldWidths()' before the redraw occurs so
        // we leave a gap for the v-scrollbar, rather than redrawing with both V and H scrollbar,
        // then resizing the fields and redrawing without an H-scrollbar.
        if (!lg.leaveScrollbarGap && lg.predictScrollbarGap && (this.overflow == isc.Canvas.AUTO)) {
            var vScrollOn = this.vscrollOn,
                
                vScrollWillBeOn = !lg.isEmpty() &&
                                  (lg.getTotalRows() * lg.cellHeight)  > this.getInnerHeight();

            if (vScrollOn != vScrollWillBeOn) {
                // ensure we don't try to recalculate field widths a second time by clearing
                // the _fieldWidthsDirty flag
                delete this._fieldWidthsDirty;
                lg._updateFieldWidths("body redrawing with changed vertical scroll-state");

            }
        }

        var suppressRowElementFocus = false;

        if (editing) {
            this.logInfo("redraw with editors showing, editForm.hasFocus: " +
                         editForm.hasFocus, "gridEdit");
            editColNum = lg.getEditCol();

            // See comments near _storeFocusForRedraw() for how edit form item focus is handled
            // on redraw
            this._storeFocusForRedraw();

            // This will add the new edit items corresponding to the newly displayed fields
            // and return the items that need to be removed (after the body is actually redrawn,
            // which will hide them)
            // It also fires the "drawing()", "redrawing()", "clearing()" notifications so items
            // know they're about to be updated in the DOM
            fieldsToRemove = this._updateEditItems();
            
        // If we're not editing, but we have an editForm with drawn items, fire the 'clearing()' notification.
        // We fire the cleared notification below (after the DOM has been updated)
        } else if (editForm != null) {
            var items = editForm.getItems();
            for (var i = 0; i < items.length; i++) {
                if (items[i].isDrawn()) items[i].clearing(true);
            }
            
        } else if (isc.screenReader) {
            var focusCanvas = this.ns.EH.getFocusCanvas();
            // Suppress focusing the row element if some other widget is focused.
            suppressRowElementFocus = focusCanvas != null && focusCanvas !== this;
            
        }
        // refresh field widths if necessary
        if (this._fieldWidthsDirty != null) {
            
            var fwReason = this._fieldWidthsDirty;
            delete this._fieldWidthsDirty;
            
            lg._updateFieldWidths(fwReason);
        }
        // store the new drawArea
        var newDrawArea = this.getDrawArea();
        

        var grid = this.grid,
            drawArea = this._oldDrawArea;

        if (!drawArea) drawArea = this._oldDrawArea = [0,0,0,0];

        var grid = this.grid,
            firstRecord = grid._getCachedCellRecord(newDrawArea[0]),
            lastRecord = grid._getCachedCellRecord(newDrawArea[1]),
            dataPresent = (firstRecord != null && lastRecord != null);

        if (dataPresent && !drawArea.equals(newDrawArea)) {
            // the old and new drawAreas differ and the extents of the new data are present -
            // fire the notification method and update the stored _oldDrawArea
            
            if (!this.frozen) {
                grid._drawAreaChanged(drawArea[0], drawArea[1], drawArea[2], drawArea[3], this);
                this._oldDrawArea = newDrawArea;
            }
        }

        
        delete this._drawnEditItems;

        this.invokeSuper(isc.GridBody, "redraw", reason,b,c,d);

        // clear the "redrawing" flag since the HTML is now up to date
        delete this._redrawing;

        // Always update all recordComponents on redraw().
        // don't rely on the draw area changing since we may be showing the same set of
        // rowNum/colNums but having underlying data or field meaning changes.
        // Note: updateRecordComponents() updates components in frozen and unfrozen bodies.
        // If this is a redraw of the frozen body, don't call updateRecordComponents() if
        // the redraw was tripped by scrolling or data change as in this case we'll also
        // get a redraw of the unfrozen body which can handle updating the RC's.
        // (DO still call the method in other cases as it may imply the fields in the frozen
        // body have changed, etc).
        // NOTE 2014: do this *after* calling Super() so that the drawn rows match the 
        // data
        if (!(this.frozen && this._suppressRecordComponentsUpdate)) {
            grid.updateRecordComponents();
        }
        this._suppressRecordComponentsUpdate = false;

        if (editing) {
            // Remove the items that correspond to fields that are no longer rendered in the DOM
            if (fieldsToRemove != null && fieldsToRemove.length > 0) {
                editForm.removeItems(fieldsToRemove);
            }

            // Fire the method to notify form items that they have been drawn() / redrawn()
            // or cleared()
            
            lg._editItemsDrawingNotification(null, true, this);

            /*
            var itemColArray = [],
                items = lg._editRowForm.getItems();
            for (var i =0; i < items.length; i++) {
                itemColArray.add(items[i].colNum + " - " + items[i].name);
            }
            this.logWarn("After redraw - edit form covers these cols:" + itemColArray);
            */

            
            lg.updateEditRow(lg.getEditRow());

            // If the editRowForm is currently marked as having focus, or we took focus from it
            // before a redraw and no other widget has subsequently picked up focus, restore focus
            // to it
            // This catches both a simple redraw and the case where the user scrolls the edit item
            // out of view, it is cleared due to incremental rendering, then scrolls back into view
            // and it gets redrawn
            
            if (editForm.hasFocus ||
                (this._editorSelection && isc.EH.getFocusCanvas() == null))
            {
                this._restoreFocusAfterRedraw(editColNum);
            } else {
                delete this._editorSelection;
            }

        } else {
            if (editForm != null) {
                // notify the form that it's items have been cleared() (will no-op if they're
                // not currently drawn)
                lg._editItemsDrawingNotification(null, null, this);
            }

            // _nativeFocusRow was remembered last time putNativeFocusInRow was called
            
            if (isc.screenReader) {
                this._putNativeFocusInRow(this.getNativeFocusRow(), suppressRowElementFocus);
            }
        }

    },

    redrawOnScroll : function (immediate) {
        if (this.frozen) this._suppressRecordComponentsUpdate = true;
        return this.Super("redrawOnScroll", arguments);
    },

    
    _lockVirtualScrolling : function () {
        this.grid._virtualScrollingLocked = true;
    },
    _canStopVirtualScrolling : function () {
        return !this.grid._virtualScrollingLocked;
    },    

    // force redraw on setDisabled() if we're showing an edit form to ensure we
    // redraw the items in enabled/disabled state
    setHandleDisabled : function (disabled) {
        var lg = this.grid;
        if (this.isDrawn() && lg && lg._editorShowing) {
            this.markForRedraw("Grid body disabled while editing");
        }
        return this.Super("setHandleDisabled", arguments);
    },

    // Add edit items corresponding to newly displayed fields (displayed due to incremental
    // rendering)
    // If any fields are to be hidden, do not remove these here, but return them in an array so
    // they can be removed from the form after the redraw completes
    // Note that the order of items in the form will not match the order of fields necessarily -
    // acceptable since developers will be interacting with the items' colNum attribute rather than
    // index in the edit form fields array.
    
    _updateEditItems : function () {
        
        // We keep the set of items in the editForm in sync with the set of
        // visible columns for performance.
        // Determine which items need to be created or removed here.
        var lg = this.grid, editForm = lg.getEditForm(),
            fieldsToRemove = [],
            editItems = editForm.getItems();
        if (!lg.editByCell) {

            // set up the vars used in creating form items
            var editRowNum = lg.getEditRow(),
                editRecord = lg.getRecord(editRowNum),
                
                completeWidths = lg.getEditFormItemFieldWidths(editRecord);

            // Determine what fields are rendered into the body
            // If we have frozen columns, we will always be showing them, in addition to whatever
            // fields are visible
            var editItems = editForm.getItems(),
                itemNames = editItems.getProperty(this.fieldIdProperty),
                fields = lg.getDrawnFields(),
                fieldNames = fields.getProperty(this.fieldIdProperty);

            // minor optimization - if possible, avoid iterating through both arrays
            var lengthsMatch = editItems.length == fields.length,
                changed = false;
            
            // fields that are no longer drawn should be removed
            for (var i = 0; i < editItems.length; i++) {
                
                // don't actually remove the items until they have been removed from the DOM via
                // redraw
                var index = fieldNames.indexOf(itemNames[i]),
                    itemDrawn = editItems[i].isDrawn();

                if (index == -1) {
                    changed = true;
                    fieldsToRemove.add(editItems[i]);
                    if (itemDrawn){
                        editItems[i].clearing(true);
                    }
                } else {
                    var fieldName = itemNames[i],
                        // Check canEdit for each field - if it's canEdit:false we don't want to fire
                        // drawing notifications!
                        canEdit = lg.canEditCell(editRowNum, index);
                
                    if (canEdit) {

                        // If we're keeping the item, just update width, and notify the item we're
                        // about to redraw
                        editItems[i].width = completeWidths[editItems[i].colNum];
                        editItems[i]._size = null;

                        if (!itemDrawn) editItems[i].drawing(true);
                        else editItems[i].redrawing();
                    } else {
                        if (itemDrawn) editItems[i].clearing(true);
                    }
                }
            }

            // newly rendered fields should be added
            if (!lengthsMatch || changed) {
                var editedVals = lg.getEditedRecord(editRowNum, 0);
                for (var i = 0; i < fields.length; i++) {
                    if (!itemNames.contains(fieldNames[i])) {

                        var colNum = lg.fields.indexOf(fields[i]);
                        var item = lg.getEditItem(
                                        fields[i],
                                        editRecord, editedVals, editRowNum,
                                        colNum, completeWidths[colNum]
                                   );
                        editForm.addItem(item);
                        
                        // Notify the item we're about to draw (if the field is editable)
                        var canEdit = lg.canEditCell(editRowNum, colNum);
                        if (canEdit) {
                            editForm.getItem(fieldNames[i]).drawing(true);
                        }
                    }
                }
                // Keep the edit form items in the same order in the items array as
                // they are in the ListGrid.
                
                editForm.items.sortByProperty("colNum", Array.ASCENDING);
            }
        }
        // if editByCell is true this is not necessary - we consistently have the editForm contain
        // only the necessary cell
        return fieldsToRemove;
    },

    // _storeFocusForRedraw()
    // called when the edit form is showing and the body is being redrawn.
    // remember the current focus state / selection of the edit form so we can reset it after
    // redrawing the item in the DOM
    // blur the item (suppressing the handler if the item will be refocused after redraw)


    

    
    _storeFocusForRedraw : function () {

        var lg = this.grid,
            editForm = lg.getEditForm(),
            editColNum = lg.getEditCol();
        if (editForm.hasFocus) {
            var focusItem = editForm.getFocusSubItem();
            if (focusItem) {
                focusItem.updateValue();
                var origFocusItem = focusItem;

                // We may be focused in a sub item, in which case we need to use the
                // parentItem to get the field name wrt our fields array
                while (focusItem.parentItem != null) {
                    focusItem = focusItem.parentItem;
                }

                // blur the focus item before removing it from the DOM.
                // If canEditCell for the current focus item returns false, we will
                // not redisplay it at the end of this method, so allow it to fire the
                // standard blur-handler
                
                if (!lg.canEditCell(focusItem.rowNum, focusItem.colNum) ||
                    editColNum != focusItem.colNum) {
                    
                    editForm.blur();
                } else {
                    
                    if (focusItem.hasFocus) {
                        // remember the current selection, so we can reset it after the redraw
                        // and refocus. [will have no effect if the item is not a text-item]
                        focusItem.rememberSelection();
                        this._editorSelection =
                            [focusItem._lastSelectionStart, focusItem._lastSelectionEnd];
                    }
                    editForm._blurFocusItemWithoutHandler();

                }
                
            }
        }
        
        editForm._setValuesPending = true;
    },

    // If the editForm is visible during a body redraw() this method ensures that after the
    // redraw completes, and the form items are present in the DOM, focus / selection is restored
    // to whatever it was before the redraw
    _restoreFocusAfterRedraw : function (editColNum) {
        var lg = this.grid,
            editForm = lg.getEditForm(),
            editItem = editForm.getItem(lg.getEditorName(lg.getEditRow(), editColNum));
        if (editItem != null && editItem.isDrawn()) {
            var scrollLeft = lg.body.getScrollLeft(),
                scrollTop = lg.body.getScrollTop(),
                viewportWidth = lg.body.getViewportWidth(),
                viewportHeight = lg.body.getViewportHeight(),
                rect = editItem.getRect(),
                // If we are partially out of the viewport, don't put focus into item -
                // forces a native scroll which can interfere with user scrolling.
                // Note: partially out of viewport actually could be ok for text items
                // where focus will only cause a scroll if the actual text is offscreen.
                
                outOfViewport = rect[0] < scrollLeft ||
                                rect[1] < scrollTop ||
                                rect[0] + rect[2] > (scrollLeft + viewportWidth) ||
                                rect[1] + rect[3] > (scrollTop + viewportHeight);

            if (!outOfViewport) {
                // Avoid selecting the focused value - we don't want rapid keypresses
                // to kill what was previously entered
                editForm._focusInItemWithoutHandler(editItem);
                // Reset the selection / text insertion point to whatever was
                // remembered before the redraw.
                
                if (this._editorSelection && this._editorSelection[0] != null) {
                    editItem.setSelectionRange(this._editorSelection[0], this._editorSelection[1]);
                }
                // clear up the _editorSelection flag so we don't try to restore focus again on
                // scroll
                delete this._editorSelection;
            }
        }
    },
    // If programmatic 'focus' from "syntheticTabIndex" (IE - tab keypress when the clickMask is up)
    // is called on the ListGrid body and the editor is showing, it
    // makes sense to focus in the edit form.
    focusAtEnd : function (start) {
        var grid = this.grid,
            editForm = grid ? grid.getEditForm() : null;
        if (editForm) {
            editForm.focusAtEnd(start);
        } else {
            return this.Super("focusAtEnd", arguments);
        }
    },
    
    _suppressEventHandling : function (lastMouseEvent) {
        if (this.Super("_suppressEventHandling", arguments)) return true;
        // If an event occurred over an expansion component, don't react to it at the GridRenderer level
        
        if (lastMouseEvent) {
            var target = lastMouseEvent.target;
            while (target && target != this) {
                if (target.isExpansionComponent) return true;
                target = target.parentElement;
            }
        }
        return false;
    },
    
    // Override mouseOut to avoid clearing rollover styling when the user interacts with a
    // child of a CanvasItem editor
    
    mouseOut : function (a,b,c,d,e) {
        var grid = this.grid;
        if (grid.getEditRow() != null) {
            var editForm = grid.getEditForm();
            var target = isc.EH.getTarget();
            while (target && target.parentElement) {
                if (target.canvasItem != null && editForm.items.contains(target.canvasItem)) {
                    return;
                }
                if (target == this) break;
                target = target.parentElement;
            }
        }
        return this.invokeSuper(isc.GridBody, "mouseOut", a,b,c,d,e);
    },
    

    // Override cellMove: We need to be able to show validation error HTML
    cellMove : function (record,rowNum,colNum) {
        // If the event is bubbled from an embedded child widget no need to check for
        // icons
        if (isc.EH.lastEvent.target == this) {

            var nativeTarget = isc.EH.lastEvent ? isc.EH.lastEvent.nativeTarget : null;
            if (nativeTarget && nativeTarget.getAttribute != null &&
                (nativeTarget.getAttribute("isErrorIcon") == "true"))
            {
                // adjust for frozen fields
                colNum = this.grid.getFieldNumFromLocal(colNum, this);
                if (this.grid._overErrorIcon != null) {
                    var lastRow = this.grid._overErrorIcon[0],
                        lastCol = this.grid._overErrorIcon[1];
                    if (lastRow != rowNum || lastCol != colNum) {
                        this.grid._handleErrorIconOut();
                    }
                }

                if (this.grid._overErrorIcon == null) {
                    this.grid._handleErrorIconOver(rowNum,colNum);
                }
            } else {
                if (this.grid._overErrorIcon != null) {
                    this.grid._handleErrorIconOut();
                }
            }
        }
    },

    cellOut : function (record, rowNum, colNum) {
        if (this.grid._overErrorIcon != null) {
            this.grid._handleErrorIconOut();
        }
    },

    // Override shouldShowRollOver to avoid styling the current edit cell with the over
    // style.
    // This avoids the issue where if you roll over the edit form items, the rollover style
    // would flash off as the body receives a mouseout (looks very weird).
    // Also - support showing the rollOver styling for the current focus row even if 
    // showRollOver is false.
    // We'll still use the rollOver style name in this case, but it improves keyboard accessibility
    // without requiring the normal rollOver effects.
    shouldShowRollOver : function (rowNum, colNum,a,b) {

        //if (!this.invokeSuper(isc.GridBody, "shouldShowRollOver", rowNum,colNum,a,b)) return false;
        
        var hiliteOnFocus = this.grid.hiliteRowOnFocus;
        if (hiliteOnFocus == null) {
            hiliteOnFocus = this.grid.showRollOver;
        }

        var lg = this.grid;

        if ((!lg.showRollOver &&
             (!hiliteOnFocus || (this._lastHiliteRow != rowNum)))
            || this._rowAnimationInfo) 
        {
            return false;
        }

        var record = lg.getRecord(rowNum);

        // Don't show roll over if the record in question doesn't want it.
        if (record && record[lg.recordShowRollOverProperty] === false) {
            return false;
        }

        // don't show rollover for the edit row if editing the whole row
        if (lg._editorShowing && !lg.editByCell && rowNum == lg._editRowNum) {
            return false;
        }

        return true;
    },

    updateRollOver : function (rowNum, colNum, movingToNewCell) {
        var lg = this.grid;

        if (lg.showRollOverCanvas || lg.showRollUnderCanvas) {
            // movingToNewCell param passed when the user rolled off one cell and over another
            // and this method is being called to clear the first cell hilight.
            // we can no-op in this case since we'll update the rollOverCanvas on the subsequent
            // call to this method, and that will avoid a clear/draw cycle (and flash)
            
            if (!movingToNewCell) {
                var leaving = !(this.lastOverRow == rowNum && this.lastOverCol == colNum);
                var gridColNum = lg.getFieldNumFromLocal(colNum, this);
                lg.updateRollOverCanvas(rowNum, gridColNum, leaving);
            }
            // no support for frozen body / rollOverCanvas yet

        }

        this.setRowStyle(rowNum, null, this.canSelectCells || this.useCellRollOvers ?
                         colNum : null);

        // frozen fields: if there is another body, force its rollover row to match and
        // update it
        var otherBody = (this == lg.body ? lg.frozenBody : lg.body);
        if (otherBody && !this.useCellRollOvers) {
            otherBody.lastOverRow = this.lastOverRow;
            otherBody.lastOverCol = this.lastOverCol;
            otherBody.setRowStyle(rowNum, null, (this.useCellRollOvers ? colNum : null));
        }
    },

    _selectCellOnMouseDown : function (record, rowNum, colNum) {
        
        this.grid.clearLastHilite();

        // remember the last cell clicked (used for keyboard navigation)
        // (Note: we use the same cell used for selection rather than the actual position
        // of the event as that's where the user will see the visual indication)
        this._lastSelectedRow = rowNum;
        this._lastSelectedCol = colNum;

        this.grid._lastSelectedBody = this;

        //this.logWarn("mouseDown at: " + [rowNum, colNum]);

        if (this.useRowSpanStyling) {
            // rowSpan-sensitive selection
            var gridSelection = this.grid.selection;

            // selected cells are designed by the coordinates where spanning starts.
            // NOTE: this means that calling isSelected() with return false for any cell
            // coordinates where no cell exists in the DOM (because it was spanned over by a
            // rowSpanning cell in a previous row).  This is true even when the spanning cell
            // that eliminated that DOM cell is in facet selected.
            var startRow = this.getCellStartRow(rowNum, colNum);

            // for ctrl-click just select/deselect the clicked cell
            if (isc.EH.modifierKeyDown()) {
                var gridColumn = this.grid.getFieldNumFromLocal(colNum, this);
                gridSelection.selectOnMouseDown(this, startRow, gridColumn);
                return;
            }

            // deselect everything - shift modifiers, dragging or other cases not supported in
            // this mode
            gridSelection.deselectAll();

            // select all cells to the right that are partially or wholly spanned by the
            // clicked cell

            var gridBody, startCol, span,
                mode = this.rowSpanSelectionMode;

            if (mode == "forward" || mode == null) {
                // field num where the click landed, in terms of listGrid.fields
                startCol = this.grid.getFieldNumFromLocal(colNum, this);
                // cells spanned by the clicked cell
                span = this.getCellRowSpan(startRow, colNum);
            } else if (mode == "outerSpan") {
                // optionally, start the selection from the span of the first column, which
                // creates a selection behavior similar to the default row-level selection
                // behavior, based on the concept of the span in the first column defining the
                // "row"
                startCol = 0;
                gridBody = this.grid.getFieldBody(0);
                startRow = gridBody.getCellStartRow(rowNum, 0);
                span = gridBody.getCellRowSpan(startRow, 0);
            } else if (mode == "both") {
                // use the span of the clicked cell
                span = this.getCellRowSpan(startRow, colNum);
                // but go through all columns
                startCol = 0;
            } else {
                this.logWarn("unrecognized rowSpanSelectionMode: '" + mode + "'");
                return;
            }

            //this.logWarn("start cell: " + [startRow, startCol] +
            //             " spans: " + span);
            // for each column to the right of the starting column
            for (var column = startCol; column < this.grid.fields.length; column++) {
                // get the body that contains the field and the field's index within that body
                var bodyToSelect = this.grid.getFieldBody(column),
                    localFieldNum = this.grid.getLocalFieldNum(column);

                // for each row spanned by the starting cell
                for (var i = startRow; i < startRow+span; i++) {
                    // when selecting, select the coordinates of the beginning of the span
                    var cellStartRow = bodyToSelect.getCellStartRow(i, localFieldNum);
                    gridSelection.selectCell(cellStartRow, column);
                    // and skip past cells that were spanned over
                    i += (bodyToSelect.getCellRowSpan(cellStartRow, localFieldNum) - 1);
                }
            }
            return;
        }

        // if we're in the body, select rows or cells
        this.selection.selectOnMouseDown(this, rowNum, colNum);
    },

    // override selectOnMouseDown/Up to disable selection when a row is clicked anywhere
    // besides the checkbox when selectionAppearance is checkbox.
    selectOnMouseDown : function (record, rowNum, colNum, d,e,f) {
        
        var shouldSelect = true,
            selApp = this.grid.selectionAppearance,
            cbSel = (selApp == "checkbox");
        if (cbSel) {
            // if frozen fields are showing, the cb field will show up in the frozen body!
            if ((this.grid.frozenFields != null && this.grid.frozenBody != this) ||
                (this.grid.getCheckboxFieldPosition() != colNum))
            {
                shouldSelect = false;
            }
        }
        
        if (shouldSelect) {
            if (this.canSelectCells) this._selectCellOnMouseDown(record, rowNum, colNum);
            else this.invokeSuper(isc.GridBody, "selectOnMouseDown", record, rowNum, colNum, d,e,f);
        }

        if (isc.screenReader) {
            // In screen reader mode, if canSelectCells is enabled, we want to hilite the cell;
            // otherwise, we will want to hilite the entire row.
            // _putNativeFocusInRow() calls _hiliteRecord(), so we will need to clear this hilite.
            this._putNativeFocusInRow(rowNum);
            if (this.canSelectCells) {
                var lastRow = this.lastOverRow,
                    lastCol = this.lastOverCol;
                this.lastOverRow = null;
                this.lastOverCol = null;
                this.updateRollOver(lastRow, lastCol);
                this.grid._lastKeyboardHiliteBody = this;
                this.grid._hiliteCell(rowNum, colNum);
            }
        }
    },
    
    // When showing the edit clickMask, a mouseDown will clear the mask and end editing
    // before normal mouse-down processing.
    // Override _getMouseDownCell to ensure, even if this caused the row-height to change, 
    // we return the cell coords before the change of row-height.
    _getMouseDownCell : function () {
        if (this._maskedMouseDownCell != null) {
            var cell = this._maskedMouseDownCell;
            // clear the property so it doesn't impact future mouseDowns
            this._maskedMouseDownCell = null;
            return cell;
        }
        return this.Super("_getMouseDownCell", arguments);
    },

    // Override mouseUp.
    // If the mouseUp occurred over a CanvasItem, ignore it.
    
    mouseUp : function () {
        var target = isc.EH.getTarget();
        
        if (this.grid && target != null && target != this && this.grid._editorShowing) {
            var editForm = this.grid.getEditForm();
            while (target != this && target != null && target != editForm) {
                if (target.canvasItem && editForm.items.contains(target.canvasItem)) {
                    return;
                }
                target = isc.isA.FormItem(target) ? target.containerWidget : target.parentElement;
            }
        }
        return this.Super("mouseUp", arguments);
    },

    selectOnMouseUp : function (record, rowNum, colNum, d,e,f) {
        var cbColNum = this.grid.getCheckboxFieldPosition(),
            selApp = this.grid.selectionAppearance;
        if (selApp != "checkbox" || (selApp == "checkbox" && cbColNum == colNum)) {
            this.invokeSuper(isc.GridBody, "selectOnMouseUp", record, rowNum, colNum, d,e,f);
        }
    },

    // Override handleSelectionChanged() to fire our viewStateChanged method
    handleSelectionChanged : function (record,state) {
        if (this.grid.suppressSelectionChanged) return;
        var returnVal = this.Super("handleSelectionChanged", arguments);
        this.grid.handleViewStateChanged();
        return returnVal;
    },

    setSelection : function (selection) {
        this.clearSelection();
        this.Super("setSelection", arguments);
    },

    clearSelection : function () {
        var selection = this.selection;
        this.Super("clearSelection", arguments);
        // if selection not inherited from ListGrid, destroy it
        if (selection && selection.isA("DependentCellSelection")) {
            selection.destroy();
        }
    },

    _setSeparateCellSelection : function (selection, firstCol) {
        this.clearSelection();
        if (selection) {
            this.selection = selection.getDependentCellSelection(this.fields.length);
            this.selection._updateDependency(firstCol);
            this.observe(this.selection, "selectionChanged", function () {
                this._cellSelectionChanged(this.selection.changedCells);
            });
        }
    },

    // When refreshing cellStyle, notify our edit items that the underlying cell style changed
    // so they can update if necessary
    _updateCellStyle : function (record, rowNum, colNum, cell, className, a,b,c) {
        this.invokeSuper(isc.GridBody, "_updateCellStyle", record, rowNum,colNum,cell,className,a,b,c);
        var lg = this.grid;
        if (lg && lg.getEditRow() == rowNum) {
            var fieldName = lg.getFieldName(lg.getFieldNumFromLocal(colNum, this)),
                form = lg.getEditForm(),
                item = form ? form.getItem(fieldName) : null;
            if (item && item.gridCellStyleChanged) {
                if (className == null) className = this.getCellStyle(record,rowNum,colNum);
                item.gridCellStyleChanged(record, rowNum, colNum, className);
            }
        }

    },

    // hovers: override getHoverTarget to return a pointer to our grid - this allows
    // the developer to call 'updateHover' directly on the grid.
    getHoverTarget : function () {
        return this.grid;
    },

    // direct keyPresses to the ListGrid as a whole to implement arrow navigation,
    // selection, etc
    
    keyPress : function (event, eventInfo) {
        return this.grid.bodyKeyPress(event, eventInfo);
    },

    // getters for the current keyboard focus row for key-events.
    
    getFocusRow : function () {
        return this.grid.getFocusRow();
    },
    getFocusCol : function () {
        var colNum = this.grid._getKeyboardClickNum();
        return this.grid.getLocalFieldNum(colNum);
    },

    
    _restoreFocusForClickMaskHide : function () {
        this._suppressKeyboardNavHiliting = true;
        this.focus();
        delete this._suppressKeyboardNavHiliting;
    },

    // Override _focusChanged to implement 'editOnFocus' - start editing the first
    // editable cell if appropriate.
    // See comments in 'editOnFocus' jsdoc comment for details of how this should work.
    _focusChanged : function (hasFocus) {
        // use the Super implementation to set up this.hasFocus BEFORE we further
        // manipulate focus due to editing.
        var returnVal = this.Super("_focusChanged", arguments);

        var lastEvent = isc.EH.lastEvent;

        // if we're acquiring focus because we're in the middle of a click sequence on the body,
        // the mouse handlers will correctly start editing or place focus on whatever row was hit, and we
        // should do nothing
        if (lastEvent.target == this &&
              (lastEvent.eventType == isc.EH.MOUSE_DOWN ||
               lastEvent.eventType == isc.EH.MOUSE_UP ||
               lastEvent.eventType == isc.EH.CLICK ||
               lastEvent.eventType == isc.EH.DOUBLE_CLICK)) return returnVal;

        // otherwise, entering focus due to a key event (tab, shift-tab) or something else (programmatic
        // including re-focus due to clickMask blur).
        var editCell,
            parent = this.grid;
        if (hasFocus && parent.isEditable()) {

            // editOnFocus enabled, but not currently editing
            if (parent.editOnFocus && parent.isEditable() &&
                parent.getEditRow() == null)
            {
                if (this.logIsInfoEnabled("gridEdit")) {
                    this.logInfo("Editing on focus: eventType: " + lastEvent.eventType +
                                 ", lastTarget " + lastEvent.target, "gridEdit");
                }

                // If we're explicitly suppressing edit on focus, don't start editing.
                if (parent._suppressEditOnFocus) {
                    delete parent._suppressEditOnFocus;
                } else {
                    // this'll run through every cell in every record until it finds one that's
                    // editable
                    var editCell = parent.getFocusCell();
                    
                    var editCellValid = isc.isAn.Array(editCell) && editCell[0] != null &&
                            editCell[0] >= 0 && editCell[1] != null && editCell[1] >= 0 &&
                            parent.canEditCell(editCell[0], editCell[1]);
                    if (!editCellValid) {
                        editCell = parent.findNextEditCell(0,0,true,true);
                    }

                    if (editCell != null) {
                        parent.handleEditCellEvent(editCell[0], editCell[1], isc.ListGrid.FOCUS);
                    }
                }
            }
        }

        // In screenReader mode, if focus is moving into the grid but we're not going into editing mode,
        // put focus onto the row element rather than onto the GR body.
        
        var hiliteOnFocus = parent.hiliteRowOnFocus;
        if (hiliteOnFocus == null) hiliteOnFocus = parent.showRollOver;
        if (isc.screenReader) {
            if (hasFocus) {
                if (editCell == null) {
                    // find the last hilited row if there is one
                    var rowNum = this.getNativeFocusRow();

                    //this.logWarn("focus entering body - focusing in native row: " + rowNum +
                    //             ", focus row was: " + parent.getFocusRow());
                    this._putNativeFocusInRow(rowNum);
                }
            } else {
                parent.clearLastHilite();
            }
        // Even if we don't have screenReader mode enabled, hilite the current keyboard
        // target row on focus (but don't trigger a click or select it).
        // Also call clearLastHilite() on blur, so we don't show orphaned "over"
        // styling when the user takes focus from the grid
        } else if (hiliteOnFocus) {
            if (hasFocus) {
                // keyboard nav hiliting will be suppressed for focus due to hideClickMask()
                if (editCell == null && !this._suppressKeyboardNavHiliting) {
                    if (parent.canSelectCells) {
                        parent._navigateToNextCell(0, 1, true, true, "focus");
                    } else {
                        parent._navigateToNextRecord(1, true, "focus", true);
                    }
                }
            } else {
                // If the user mouseDowned on an embedded widget, such as a rollOverCanvas,
                // don't clear the hilight or we'll lose the roll-over canvas altogether.
                var mouseDownTarget = isc.EH.mouseDownTarget(),
                    eventType = isc.EH.lastEvent.eventType;
                if (eventType != isc.EH.MOUSE_DOWN || !this.contains(mouseDownTarget)) {
                    parent.clearLastHilite();
                }
            }

        }
        return returnVal;
    },

    // override putNativeFocusInRow to ensure we hilight the focus row
    _putNativeFocusInRow : function (rowNum, suppressFocus) {
        var parent = this.grid;
        // if suppressFocus is passed, we're not actually focusing into the row so don't
        // hilite the row.
        if (parent && parent.hiliteOnNativeRowFocus && !suppressFocus) parent._hiliteRecord(rowNum);
        return this.Super("_putNativeFocusInRow", arguments);
    },

    // override updateRowSelection to update selectionCanvas if necessary
    updateRowSelection : function (rowNum) {
        var lg = this.grid;
        if (!lg) return;

        

        if (lg.showSelectionCanvas || lg.showSelectionUnderCanvas) lg.updateSelectionCanvas();
        if (lg._dontRefreshSelection) {
            return;
        }

        this.invokeSuper(isc.GridBody, "updateRowSelection", rowNum);

        if (isc.Canvas.ariaEnabled() && lg.selection) {
            this.setRowAriaState(rowNum, "selected", lg.selection.isSelected(lg.getRecord(rowNum), true));
        }

        // with selectionAppearance:"checkbox", detect all rows selected and update checkbox in
        // header
        if (lg.getCurrentCheckboxField() != null) {
            var cellNum = lg.getCheckboxFieldPosition();
            if (lg) {
                lg.refreshCell(rowNum, cellNum);
                lg.updateCheckboxHeaderState();
            }

        } else if (lg.getTreeFieldNum && lg.selectionAppearance == "checkbox") {
            // in the TreeGrid, refresh the tree cell because that's where the checkbox is shown
            var treeCellNum = lg.getTreeFieldNum();
            lg.refreshCell(rowNum, treeCellNum);
        }
    },
    
    // Fired when selecting a list of entries (for every row)
    // Default implementation marks for redraw
    // Also set up to update SelectionCanvas when the thread completes.
    markForRowSelectionRefresh : function () {
        var lg = this.grid;
        if (!lg) return;
        if (lg.showSelectionCanvas || lg.showSelectionUnderCanvas) {
            lg.fireOnPause("updateSelectionCanvasFromRowRefresh", "updateSelectionCanvas");
        }
        if (lg.getCurrentCheckboxField() != null) {
            lg.fireOnPause("updateCheckboxHeaderFromRowRefresh", "updateCheckboxHeaderState");
        }

        if (lg._dontRefreshSelection) {
            return;
        }
        // This will mark the body for redraw (refreshing the actual styling / checkboxes)
        this.invokeSuper(isc.GridBody, "markForRowSelectionRefresh");
    },

    // ditto with _cellSelectionChanged
    _cellSelectionChanged : function (cellList,b,c,d) {
        var lg = this.grid;
        if (lg != null &&
            (lg.showSelectionCanvas || lg.showSelectionUnderCanvas))
        {
            lg.updateSelectionCanvas();
        }
        return this.invokeSuper(isc.GridBody, "_cellSelectionChanged", cellList, b,c,d);
    },

    // remove any dynamic references that point to us if we're being destroyed
    destroy : function () {
        var grid = this.grid;
        if (this == grid._lastSelectedBody)       grid._lastSelectedBody       = null;
        if (this == grid._lastKeyboardHiliteBody) grid._lastKeyboardHiliteBody = null;
        this.Super("destroy", arguments);
    },

    // Embedded components
    // -----------------------

    // animateShow selectionCanvas / rollOverCanvas if appropriate
    shouldAnimateEmbeddedComponent : function (component) {
        var grid = this.grid;
        if (component == grid.selectionCanvas) return grid.animateSelection;
        if (component == grid.selectionUnderCanvas) return grid.animateSelectionUnder;
        if (component == grid.rollOverCanvas) return grid.animateRollOver;
        if (component == grid.rollUnderCanvas) return grid.animateRollUnder;

        return false;
    },


    _handleEmbeddedComponentResize : function (component, deltaX, deltaY) {
        this.Super("_handleEmbeddedComponentResize", arguments);

        // Notify the grid - allows us to update the other body if we're showing
        // both a frozen and an unfrozen body
        this.grid._handleEmbeddedComponentResize(this, component, deltaX, deltaY);
    },

    // Override draw() to scroll to the appropriate cell if 'scrollCellIntoView' was called
    // before the body was drawn/created
    // Also update the edit form item rows if we're already editing.
    draw : function (a,b,c,d) {
        var lg = this.grid;

        if (lg.getEditRow() != null) {
            
            var rowNum = lg.getEditRow(),
                record = lg.getRecord(rowNum),
                fieldNum = lg.getEditCol(),
                form = lg._editRowForm,
                items = lg.getEditRowItems(record, rowNum, fieldNum, lg.editByCell),
                liveItems = form.getItems();

            var setItems = liveItems == null || items.length != liveItems.length;
            if (!setItems) {
                var liveItemNames = liveItems.getProperty("name");
                for (var i = 0; i < items.length; i++) {
                    if (!liveItemNames.contains(items[i].name)) {
                        setItems = true;
                        break;
                    }
                }
            }
            if (setItems) {
                this.logDebug("calling setItems on form from body draw","gridEdit");
                form.setItems(items);
            } else {
                this.logDebug("Skipping setItems() on form from body draw", "gridEdit");
            }

            
            form._setValuesPending = true;

        }

        
        delete this._drawnEditItems;

        this.invokeSuper(isc.GridBody, "draw", a,b,c,d);

        // If we are showing any edit form items, notify them that they have been written
        // into the DOM.
        
        if (lg._editRowForm) {
            lg._editItemsDrawingNotification(null, null, this);
        }
        // Tell the form to update its values (setItemValues())
        // (do this after the items have been notified that they're drawn to ensure items'
        // element values are set)
        lg.updateEditRow(lg.getEditRow());

        if (lg._scrollCell != null) {
            var scrollRowNum = isc.isAn.Array(lg._scrollCell) ? lg._scrollCell[0] : lg._scrollCell,
                scrollColNum = isc.isAn.Array(lg._scrollCell) ? lg._scrollCell[1] || 0 : 0,
                xPosition = isc.isAn.Array(lg._scrollCell) ? lg._scrollCell[2] : null,
                yPosition = isc.isAn.Array(lg._scrollCell) ? lg._scrollCell[3] : null
            ;
            lg.scrollToCell(scrollRowNum, scrollColNum, xPosition, yPosition);
            delete lg._scrollCell;
        }

        // Call 'updateRecordComponents()' on initial draw to set up recordComponents
        // If this is a ResultSet rather than an array, the updateRecordComponents method
        // will be able to skip all records and we'll render out the components on redraw.
        this.grid.updateRecordComponents();

        if (!this._updatingExpansionComponents) this.grid.updateExpansionComponents();
    },

    // rerun ListGrid-level layout if the body's scrolling state changes, to allow sizing
    // the header appropriately
    layoutChildren : function (reason,a,b,c) {
        this.invokeSuper(isc.GridBody, "layoutChildren", reason,a,b,c);
        // This method may be called with "scrolling state change" when a bodyLayout is
        // currently undrawn but drawing out its children - we've seen this in FF 3
        // In this case bail now since if _updateFieldWidths() is fired on an undrawn body it
        // bails, leaving the body mis sized
        
        if (!this.isDrawn() || (this.grid.frozenFields && !this.grid.bodyLayout.isDrawn())) {
            return;
        }
        var isScrollStateChanged = isc.startsWith(reason, "scrolling state changed"),
            isNewScrollbars = (reason == "introducing scrolling");
        if (isScrollStateChanged || isNewScrollbars) {
            
            if (this.isRTL() && !this._animatedShowStartRow) {
                this._placeEmbeddedComponents();
            }
        }

        if (isScrollStateChanged) {

            if (this._rowHeightAnimation == null) {
                this.grid.layoutChildren("body scroll changed");
                delete this._scrollbarChangeDuringAnimation;


            
            } else {
                this._scrollbarChangeDuringAnimation = true;
            }
        }
    },

    // Override rowAnimationComplete to call layoutChildren on the ListGrid if
    // scrollbars were introduced or cleared during animation.
    _rowAnimationComplete : function () {
        this.Super("_rowAnimationComplete", arguments);
        if (this._scrollbarChangeDuringAnimation) {
            this.grid.layoutChildren("body scroll changed during animation");
            delete this._scrollbarChangeDuringAnimation;
        }
    },


    // Override moved to notify any edit form items that they have moved.
    handleMoved : function (a,b,c,d) {
        this.invokeSuper(isc.GridBody, "handleMoved", a,b,c,d);
        this._notifyEditItemsOnMoved();
    },

    handleParentMoved : function (a,b,c,d) {
        this.invokeSuper(isc.GridBody, "handleParentMoved", a,b,c,d);
        this._notifyEditItemsOnMoved();
    },
    _notifyEditItemsOnMoved : function () {
        
        var lg = this.grid;
        if (lg._editorShowing) {
            var form = lg._editRowForm,
                allItems = form.getItems(),
                items = [];
            for (var i = 0; i < allItems.length; i++) {
                if (allItems[i].isDrawn()) items.add(allItems[i]);
            }
            form.itemsMoved(items);
        }
    },

    // Override show() / hide() / parentVisibilityChanged() / clear() to notify the Edit
    // form items that they have been shown / hidden.
    setVisibility : function (newVisibility,b,c,d) {
        this.invokeSuper(isc.GridBody, "setVisibility", newVisibility,b,c,d);
        var lg = this.grid;
        if (lg._editorShowing) lg._editRowForm.itemsVisibilityChanged();
        if (lg.fieldPickerWindow && newVisibility == "hidden") lg.fieldPickerWindow.hide();
    },

    parentVisibilityChanged : function (newVisibility,b,c,d) {
        this.invokeSuper(isc.GridBody, "parentVisibilityChanged", newVisibility,b,c,d);
        var lg = this.grid;
        if (lg._editorShowing) lg._editRowForm.itemsVisibilityChanged();
    },

    clear : function () {
        var lg = this.grid;
        lg._clearingInactiveEditorHTML();

        
        delete this._drawnEditItems;
        this.Super("clear", arguments);
        if (lg._editorShowing) {
            // If we're showing the editRow form, notify the items that they have
            // been removed from the DOM.
            lg._editItemsDrawingNotification(null, null, this);

            // Separate mechanism to notify the form that items are no longer visible.
            
            lg._editRowForm.itemsVisibilityChanged();
        }
    },

    // also notify the edit form items of z index change
    zIndexChanged : function () {
        this.Super("zIndexChanged", arguments);
        var lg = this.grid;
        // Note: setZIndex can be called at init time to convert "auto" to a numeric
        // zIndex - we therefore can't assume that we've been added to the ListGrid as
        // a child yet.
        if (lg && lg._editorShowing) lg._editRowForm.itemsZIndexChanged();

    },
    parentZIndexChanged : function (a,b,c,d) {
        this.invokeSuper(isc.GridBody, "zIndexChanged", a,b,c,d);
        var lg = this.grid;
        if (lg._editorShowing) lg._editRowForm.itemsZIndexChanged();
    },

    // Implement 'redrawFormItem()' - if one of the edit form items asks to redraw
    // we can simply refresh the cell rather than having the entire body redraw
    redrawFormItem : function (item, reason) {
        var lg = this.grid;
        if (lg && (item.form == lg._editRowForm)) {
            // determine which cell
            var row = lg.getEditRow(), col = lg.getColNum(item.getFieldName());

            // If the user has edited the cell, or setValue() has been called on the item
            // we don't want a call to redraw() on the item to drop that value
            if (lg.getEditCol() == col) {
                lg.storeUpdatedEditorValue();
            }

            if (row >= 0 && col >= 0) lg.refreshCell(row, col, false, true);

        } else
            return this.markForRedraw("Form Item Redraw " + (reason ? reason : isc.emptyString));
    },

    
    sizeFormItem : function (item) {
        var lg = this.grid;
        var width = item.width,
            finalWidth;

        if (isc.isA.String(width)) {
            var fieldWidths = lg.getEditFormItemFieldWidths(item.record),
                fieldWidth = fieldWidths[lg.getFieldNum(item.getFieldName())];
             if (width == "*") {
                finalWidth = fieldWidth;
             } else if (width.charAt(width.length - 1) == "%") {
                var percentWidth = parseInt(width);
                if (isc.isA.Number(percentWidth)) {
                    finalWidth = Math.floor(fieldWidth * (percentWidth / 100));
                }
            }
        }

        var height = item.height,
            finalHeight;
        if (isc.isA.String(height)) {
            var cellHeight = lg.cellHeight;
            if (width == "*") {
                finalHeight = cellHeight;
            } else if (height.charAt(height.length - 1) == "%") {
               var percentHeight = parseInt(height);
               if (isc.isA.Number(percentHeight)) {
                   finalHeight = Math.floor(cellHeight * (percentHeight / 100));
               }
            }
        }
        // Hang the calculated values on the _size attribute as we do when running
        // normal stretch-resize policy in form items.
        
        if (finalHeight != null || finalWidth != null) {
            item._size = [finalWidth == null ? item.width : finalWidth,
                          finalHeight == null ? item.height : finalHeight];
        }

    },

    //>Animation
    // Override startRowAnimation - if doing a delayed redraw to kick off a row animation
    // to close an open folder, we need to temporarily open the folder again to get the
    // appropriate HTML for the animation rows.
    startRowAnimation : function (show, startRow, endRow, callback, speed, duration,
                                  effect, slideIn, delayed)
    {
        this.finishRowAnimation();

        var shouldOpenFolder = (delayed && (this._openFolder != null)),
            tg = this.grid;

        if (shouldOpenFolder) {
            var wasSuppressed = tg._suppressFolderToggleRedraw;
            tg._suppressFolderToggleRedraw = true;
            tg.data.openFolder(this._openFolder);
            tg._suppressFolderToggleRedraw = wasSuppressed;
        }
        this.Super("startRowAnimation", arguments);
        if (shouldOpenFolder) {
            var wasSuppressed = tg._suppressFolderToggleRedraw;
            tg._suppressFolderToggleRedraw = true;
            tg.data.closeFolder(this._openFolder);
            tg._suppressFolderToggleRedraw = wasSuppressed;
        }
        delete this._openFolder;
    }
    //<Animation
});


isc.ListGrid.addClassProperties({
    

    //> @type SortArrow
    //          Do we display an arrow for the sorted field ?
    //          @group  sorting, appearance
    //  @value  "none"   Don't show a sort arrow at all.
    //  @value  "corner" Display sort arrow in the upper-right corner (above the scrollbar) only.
    CORNER:"corner",
    //  @value  "field"  Display sort arrow above each field header only.
    FIELD:"field",
    //  @value  "both"   Display sort arrow above each field header AND in corner above scrollbar.
    //BOTH:"both", // NOTE: Canvas establishes this constant
    // @visibility external
    //<
    // NOTE: Canvas established the constant NONE ( == "none")

    //> @type ReorderPosition
    //  Controls where a drag-item should be dropped in relation to the target row
    //  @group dragdrop
    //  @value  ListGrid.BEFORE  Drop the drag-item before the target-row
    BEFORE:"before",
    //  @value  ListGrid.AFTER   Drop the drag-item after the target-row
    AFTER:"after",
    //  @value  ListGrid.OVER    Drop the drag-item over (onto) the target-row
    OVER:"over",
    // @visibility external
    //<

        //> @type RecordDropAppearance
        // Controls how ListGrid record drop events report their
        // +link{listGrid.getRecordDropPosition(),dropPosition}, and where the drop indicator will be displayed
        // if appropriate.
        //
        // @value ListGrid.OVER When the user drops onto a record, dropPosition will always be "over"
        // @value ListGrid.BETWEEN When the user drops onto a record, dropPosition will be either
        //   "before" or "after" depending on whether the mouse was over the top or bottom of
        //   the target record
        BETWEEN: "between",
        // @value ListGrid.BOTH When the user drops onto a record, if the drop occurs centered over the
        //   record, the dropPosition will be reported as "over", otherwise it will be
        //   "before" or "after" depending on whether the mouse was over the top or bottom of the
        //   target record.
        // @value ListGrid.BODY No dropPosition will be reported
        BODY:"body",
        //
        // @visibility external
        //<

        //> @type RecordDropPosition
        // Position of a +link{listGrid.recordDrop} operation with respect to the target record.
        // @value ListGrid.OVER User dropped directly onto the record
        // @value ListGrid.BEFORE User dropped before the record
        // @value ListGrid.AFTER User dropped after the record
        // @value ListGrid.NONE Drop position is not over a record
        //
        // @visibility external
        //<

    //> @type RowEndEditAction
    //  While editing a ListGrid, what cell should we edit when the user attempts to navigate
    //  into a cell past the end of an editable row, via a Tab keypress, or a programmatic
    //  saveAndEditNextCell() call?
    //
    // @value   "same"   navigate to the first editable cell in the same record
    // @value   "next"   navigate to the first editable cell in the next record
    // @value   "done"   complete the edit.
    // @value   "stop"   Leave focus in the cell being edited (take no action)
    // @value   "none"   take no action
    //
    // @visibility external
    // @group editing
    // @see ListGrid.rowEndEditAction
    //
    //<

    //> @type EnterKeyEditAction
    // What to do when a user hits enter while editing a cell
    // @value "done" end editing (will save edit values if +link{listGrid.autoSaveEdits}
    //  is true).
    // @value "nextCell" edit the next editable cell in the record
    // @value "nextRow" edit the same field in the next editable record
    // @value "nextRowStart" edit the first editable cell in next editable record
    //
    // @group editing
    // @visibility external
    //<

    //> @type EscapeKeyEditAction
    // What to do if the user hits escape while editing a cell.
    // @value "cancel" cancels the current edit and discards edit values
    // @value "done" end editing (will save edit values if +link{listGrid.autoSaveEdits}
    //  is true).
    // @value "exit" exit the editor (edit values will be left intact but not saved).
    // @value "ignore" do nothing special when the Escape key is pressed (ie, just ignore it)
    //
    // @group editing
    // @visibility external
    //<

    //> @type EditCompletionEvent
    //          What event / user interaction type caused cell editing to complete.
    //          @visibility external
    //          @group  editing
    //
    //          @value  isc.ListGrid.CLICK_OUTSIDE  User clicked outside editor during edit.
    //          @value  isc.ListGrid.CLICK  User started editing another row by clicking on it
    //          @value  isc.ListGrid.DOUBLE_CLICK  User started editing another row by double
    //                               clicking
    //          @value  isc.ListGrid.ENTER_KEYPRESS Enter pressed.
    //          @value  isc.ListGrid.ESCAPE_KEYPRESS    User pressed Escape.
    //          @value  isc.ListGrid.UP_ARROW_KEYPRESS  Up arrow key pressed.
    //          @value  isc.ListGrid.DOWN_ARROW_KEYPRESS    down arrow key.
    //          @value  isc.ListGrid.TAB_KEYPRESS   User pressed Tab.
    //          @value  isc.ListGrid.SHIFT_TAB_KEYPRESS   User pressed Shift+Tab.
    //          @value  isc.ListGrid.EDIT_FIELD_CHANGE      Edit moved to a different field (same row)
    //          @value  isc.ListGrid.PROGRAMMATIC   Edit completed via explicit function call
    // @visibility external
    //<
    CLICK_OUTSIDE:"click_outside",
    CLICK:"click",
    DOUBLE_CLICK:"doubleClick",
    ENTER_KEYPRESS:"enter",
    ESCAPE_KEYPRESS:"escape",
    UP_ARROW_KEYPRESS:"arrow_up",
    DOWN_ARROW_KEYPRESS:"arrow_down",
    // left/right only used in conjunction with moveEditorOnArrow
    LEFT_ARROW_KEYPRESS:"arrow_left",
    RIGHT_ARROW_KEYPRESS:"arrow_right",
    TAB_KEYPRESS:"tab",
    SHIFT_TAB_KEYPRESS:"shift_tab",
    EDIT_FIELD_CHANGE:"field_change",
    EDIT_ROW_CHANGE:"row_change",
    PROGRAMMATIC:"programmatic",
    // Focus is not a valid edit completion event - focusing in the grid can start an edit
    // if editOnFocus is true but this should not kill an existing edit.
    FOCUS:"focus",

    // GridRenderer passthrough
    // --------------------------------------------------------------------------------------------

    // the following properties, when set on the ListGrid, are applied to the GridBody
    _gridPassthroughProperties : [
        // pass it a selection object (this enables selection behaviors)
        "selection",
        "selectionType",
        "canSelectCells",
        "canDragSelect",
        "canSelectOnRightMouse",
        "recordCanSelectProperty",
        "useNativeTouchScrolling",

        // D&D
        "canDrag",
        "canAcceptDrop",
        "canDrop",

        // table geometry
        "autoFit",
        "wrapCells",
        "cellSpacing",
        "cellPadding",
        "cellHeight",
        "enforceVClipping",
        // autoFitData behavior implemented on GridBody class, not GR class
        "autoFitData",
        "autoFitMaxRecords",
        "autoFitMaxWidth",
        "autoFitMaxColumns",
        "autoFitMaxHeight",
        "autoFitExtraRecords",

        "allowRowSpanning",

        // incremental rendering
        // "showAllRecords" -> showAllRows done elsewhere
        "showAllColumns",
        "drawAllMaxCells",
        "drawAheadRatio",
        "quickDrawAheadRatio",
        "instantScrollTrackRedraw",
        "scrollRedrawDelay",
        "scrollWheelRedrawDelay",
        "touchScrollRedrawDelay",

        // printing
        "printMaxRows",

        //>Animation
        // If we're doing a speed rather than duration based row animation allow the cap to
        // be specified on the ListGrid / TreeGrid
        // (Note that this is documented in the TreeGrid class).
        "animateRowsMaxTime",
        //<Animation

        // documented by default setting
        "fastCellUpdates",

        // rollover
        "showRollOver",
        "useCellRollOvers",

        // hover
        "canHover",
        "showHover",
        "showClippedValuesOnHover",
        "hoverDelay",
        "hoverWidth",
        "hoverHeight",
        "hoverAlign",
        "hoverVAlign",
        "hoverStyle",
        "hoverOpacity",
        "hoverMoveWithMouse",

        "hoverByCell",
        "keepHoverActive",
        "cellHoverOutset",

        // empty message
        "showEmptyMessage",
        "emptyMessageStyle",
        "emptyMessageTableStyle",

        // offline message
        "showOfflineMessage",
        "offlineMessageStyle",

        // special presentation of records
        "useCellRecords",
        "singleCellValueProperty",
        "isSeparatorProperty",

        // Focus things -- note no need to pass tabIndex through - layouts should auto-manage
        // their members' tab-orders correctly
        "accessKey",
        "canFocus",
        "_useNativeTabIndex",
        "tableStyle",
        "baseStyle",
        "recordCustomStyleProperty",
        "showSelectedStyle",

        // whether to use rowSpan-oriented cell styling behaviors
        "useRowSpanStyling",
        // selection mode when rowSpanning is active
        "rowSpanSelectionMode",

        "showFocusOutline"
    ],

    // the following methods, when called on the LV, will call the same-named method on the
    // GridRenderer (this.body).
    _lv2GridMethods : [
        // this makes it easier to override getCellStyle at the LV level, since you can call
        // these helpers as this.getCellStyleName()
        "getCellStyleName",
        "getCellStyleIndex",

        "_getShowClippedValuesOnHover",

        // setFastCellUpdates explicitly handled
        // in a method which keeps lg.fcu in sync with the
        // body property value
        //"setFastCellUpdates",

        // checking table geometry
        "getRowTop",
        "getRowPageTop",
        "getRowSize",
        "getDrawnRowHeight",

        // row span information
        "getCellStartRow",
        "getCellRowSpan",

        //> @method listGrid.getVisibleRows
        // @include gridRenderer.getVisibleRows()
        // @return (Array of Integer)
        // @visibility external
        //<
        "getVisibleRows",

        //> @method listGrid.getDrawnRows
        // @include gridRenderer.getDrawnRows()
        // @visibility external
        //<
        "getDrawnRows"
    ],

    // styling

    //> @method listGrid.getCellStyle()
    // @include gridRenderer.getCellStyle()
    // @see listGrid.getBaseStyle()
    //<

    //> @method listGrid.getCellCSSText()
    // @include gridRenderer.getCellCSSText()
    // @example addStyle
    //<

    // refresh
    //> @method listGrid.refreshCellStyle()
    //  @include    gridRenderer.refreshCellStyle()
    //<

    // events
    //> @method listGrid.cellOver()
    // @include gridRenderer.cellOver()
    //<
    //> @method listGrid.rowOver()
    // @include gridRenderer.rowOver()
    //<

    //> @method listGrid.cellOut()
    // @include gridRenderer.cellOut()
    //<
    //> @method listGrid.rowOut()
    // @include gridRenderer.rowOut()
    //<

    //> @method listGrid.cellHover()
    // @include gridRenderer.cellHover()
    //<
    //> @method listGrid.cellValueHover() ([A])
    // @include gridRenderer.cellValueHover()
    //<
    //> @method listGrid.rowHover()
    // @include gridRenderer.rowHover()
    //<
    //> @method listGrid.cellHoverHTML()
    // @include gridRenderer.cellHoverHTML()
    //<
    //> @method listGrid.cellValueHoverHTML()
    // @include gridRenderer.cellValueHoverHTML()
    //<

    //> @method listGrid.cellContextClick()
    // @include gridRenderer.cellContextClick()
    // @example cellClicks
    //<
    //> @method listGrid.rowContextClick()
    // @include gridRenderer.rowContextClick()
    // @example recordClicks
    //<

    //> @method listGrid.cellMouseDown()
    // @include gridRenderer.cellMouseDown()
    //<
    //> @method listGrid.rowMouseDown()
    // @include gridRenderer.rowMouseDown()
    //<

    //> @method listGrid.cellMouseUp()
    // @include gridRenderer.cellMouseUp()
    //<
    //> @method listGrid.rowMouseUp()
    // @include gridRenderer.rowMouseUp()
    //<

    //> @method listGrid.cellClick()
    // Called when a cell receives a click event.
    // <P>
    // Note that returning false from this method will not prevent any
    // specified +link{listGrid.rowClick} handler from firing.
    //
    // @group   events
    // @param   record  (ListGridRecord)    Record object returned from getCellRecord()
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number of the cell
    // @return  (boolean)   whether to cancel the event
    // @visibility external
    // @example cellClicks
    //<

    //> @method listGrid.cellDoubleClick()
    // @include gridRenderer.cellDoubleClick()
    // @example cellClicks
    //<

    // Geometry
    //> @method listGrid.getRowTop()
    // @include gridRenderer.getRowTop()
    // @visibility external
    //<

    //> @method listGrid.getRowPageTop()
    // @include gridRenderer.getRowPageTop()
    // @visibility external
    //<

    // ListGrid / GridBody passthroughs
    // ---------------------------------------------------------------------------------------

    // the following methods, when called on the GridRenderer used as LV.body, call the same-named
    // method on the ListGrid instance itself
    _grid2LVMethods : [

        "getTotalRows",
        "isEmpty",
        "cellIsEnabled",
        "willAcceptDrop",

        // passed scroll change notification through
        "scrolled",

        // native element naming
        "getTableElementId",
        "getRowElementId",
        "getCellElementId",

        // shouldFixRowHeight - enables us to override the ListGrid level 'fixedRecordHeights'
        // for individual rows
        "shouldFixRowHeight",

        "getEmptyMessage",
        "getCanHover",
        // bubble stopHover on the GR up to stopHover here.
        "stopHover",

        "updateEmbeddedComponentZIndex"

        // NOTE: These methods pick up their parameters from the stringMethodRegistry on the
        // GridRenderer class. If expanding this list ensure that any methods that take parameters
        // are registered as stringMethods on that class
    ],

    // used by _invokeKeyboardCopyPasteShortcut for copy/paste between ListGrids
    _cellClipboard : null
});

isc.ListGrid.addClassMethods({
    makeBodyMethods : function (methodNames) {
        var funcTemplate = this._funcTemplate;
        if (funcTemplate == null) {
            funcTemplate = this._funcTemplate = [
                ,
                
                
                "this.grid._passthroughBody = this;" +
                "var returnVal = this.grid.",,"(",,");" +
                "this.grid._passthroughBody=null;" +
                "return returnVal;"];
        }

        var methods = {};

        for (var i = 0; i < methodNames.length; i++) {
            var methodName = methodNames[i],
                argString = isc.GridRenderer.getArgString(methodName),

                
                isCellIsEnabled = (methodName == "cellIsEnabled");

            funcTemplate[0] = "var methodName = '" + methodName + "';\n";
                
            if (isc.contains(argString, "colNum")) {
                // if there's a colNum argument, map it to the field index in the master
                funcTemplate[0] += "if (this.fields[colNum]) colNum = this.fields[colNum].masterIndex;"

            } else if (isc.isAn.emptyString(argString)) {
                // if there are no arguments, pass the body itself as a means of identifying
                // the calling body
                argString = "body";
                funcTemplate[0] += "body = this;";
            }
            if (isCellIsEnabled) {
                var checkRecord = "if (record === undefined) record = this.grid.getCellRecord(" + argString + ");";
                funcTemplate[0] += checkRecord;
            }

            // create a function that routes a function call to the target object
            funcTemplate[2] = methodName;
            funcTemplate[4] = (isCellIsEnabled ? "record," + argString : argString);
            var functionText = funcTemplate.join(isc.emptyString);

            //this.logWarn("for method: " + methodName + " with argString :"  + argString +
            //             " function text is: " + functionText);

            var method = methods[methodName] = isc._makeFunction(
                (isCellIsEnabled ? argString + ",record" : argString), functionText);
            method._isPassthroughMethod = true;
        }

        return methods;
    },
    

    classInit : function () {
        // create functions to have methods on the ListGrid's body call methods on the ListGrid
        // itself.  This is partly legacy support: the way to customize body rendering used to
        // be to install functions that controlled body rendering directly on the ListGrid
        // itself.

        // make certain grid methods appear on the LV for convenience, so you don't have to go
        // this.body.someGridMethod()
        

        this.addMethods(isc.ClassFactory.makePassthroughMethods(
            this._lv2GridMethods, "body"));

        // ----------------------------------------------------------------------------------------
        // create methods that can be installed on the body to call methods on the LV itself, for:
        var passthroughMethods = {};

        // - handlers (like cellOver) and overrides (like getCellCSSText) that we allow to be
        //   defined on the LV but are really grid APIs
        var gridAPIs = isc.getKeys(isc.GridRenderer._gridAPIs),
            passthroughMethods = isc.ListGrid.makeBodyMethods(gridAPIs);

        // - methods the grid needs to fulfill as the drag/drop target, which are really implemented
        //   on the LV
        isc.addProperties(passthroughMethods,
                          isc.ListGrid.makeBodyMethods(this._grid2LVMethods));

        this._passthroughMethods = passthroughMethods;

        

        // create methods on the ListGrid to act as Super implementations for per-instance
        // overrides of methods where we want to call the original GridRenderer implementation
        // as Super.
        var passBackMethods = {},
            funcTemplate = [
                ,
                // _passthroughBody is set up by the body function that called back up the
                // the grid method - if present, we use it to ensure we call the original
                // implementation on the correct body.
                "var _passthroughBody = this._passthroughBody || this.body;" +
                " if (_passthroughBody == null) {" +
                    "return;" +
                "}" +
                "if(_passthroughBody.__orig_",,")return _passthroughBody.__orig_",,"(",,")"],
            origPrefix  = "__orig_",
            gridProto = isc.GridRenderer.getPrototype();
        for (var i = 0; i < gridAPIs.length; i++) {
            var methodName = gridAPIs[i],
                argString = isc.GridRenderer.getArgString(methodName);
            if (isc.ListGrid.getInstanceProperty(methodName) == null) {

                if (isc.contains(argString, "colNum")) {
                    // if there's a colNum argument, map it to the field index in the body
                    
                    funcTemplate[0] = "if (colNum != null && colNum >= 0) colNum = this.getLocalFieldNum(colNum);"
                } else {
                    funcTemplate[0] = null;
                }
                funcTemplate[2] = funcTemplate[4] = methodName;
                funcTemplate[6] = argString

                passBackMethods[methodName] = isc._makeFunction(argString,
                    funcTemplate.join(isc.emptyString));
                // XXX this would also work, but imposes another Super call penalty, and is
                // odd (call to Super from outside of the object)
                //"return this.body.Super('" + methodName + "', arguments);");
            }
            
            gridProto[origPrefix + methodName] = gridProto[methodName];
        }
        this._passBackMethods = passBackMethods;
        this.addMethods(passBackMethods);

    },

    // retrieve possibly sorted list of coordinates from a coordinate record
    _getCoordinateList : function (coordinateRecord, sortByCoordinate) {
        var list = [];
        for (var coordinate in coordinateRecord) {
            if (coordinateRecord.hasOwnProperty(coordinate)){
                list.add(parseInt(coordinate));
            }
        }
        if (sortByCoordinate) {
            list.sort(function (a, b) { return a - b; });
        }
        return list;
    }
});

// add default properties to the class
isc.ListGrid.addProperties( {

    //> @attr listGrid.styleName (CSSStyleName : "listGrid" : IRW)
    // Default CSS class for the ListGrid as a whole.
    // @group appearance
    // @visibility external
    //<
    styleName:"listGrid",

    //> @attr listGrid.data (List of ListGridRecord : null : IRW)
    // A list of ListGridRecord objects, specifying the data to be used to populate the
    // ListGrid.  In ListGrids, the data array specifies rows.
    // <p>
    // When using a +link{DataSource}, rather than directly providing <code>data</code>, you will
    // typically call +link{fetchData()} instead, which will automatically establish
    // <code>data</code> as a +link{class:ResultSet,ResultSet} (see the +link{fetchData()} docs for details).
    // <p>
    // If you call <code>fetchData</code>, any previously supplied <code>data</code> is
    // discarded.  Also, it is not necessary to call <code>setData()</code> after calling
    // +link{ListGrid.fetchData()}.
    // <p>
    // When calling <code>setData()</code><smartgwt>,
    // if <code>data</code> is provided as a RecordList or ResultSet</smartgwt>, direct changes
    // to the list using Framework APIs such as <smartclient>+link{list.add()} or 
    // +link{list.remove()}</smartclient><smartgwt>+link{RecordList.add()} or 
    // +link{RecordList.remove()}</smartgwt> will be automatically observed and the
    // ListGrid will redraw in response.  However, direct changes to individual Records will not
    // be automatically observed and require calls to +link{refreshCell()} or 
    // +link{refreshRow()} to cause the ListGrid to visually update.  Calling methods such as
    // +link{ListGrid.updateData()}, +link{removeData()} or +link{addData()} always causes
    // automatic visual refresh.
    // <smartclient><p>
    // Note that direct manipulation of the data object without using the +link{List} APIs (for
    // example by directly assigning a new Record object to some index or calling non-Framework
    // APIs such as pop(), shift(), etc.) will not be reflected in the grid automatically, but 
    // developers can call +link{list.dataChanged()} directly to notify the grid of changes.
    // </smartclient>
    //
    // @group data
    // @see ListGridRecord
    // @setter setData()
    // @visibility external
    // @example inlineData
    // @example localData
    //<

    // useCellRecords - Is our data model going to be one record per cell or one record per row?
    useCellRecords:false,

    //> @object ListGridRecord
    // A ListGridRecord is a JavaScript Object whose properties contain values for each
    // +link{ListGridField}.  A ListGridRecord may have additional properties which affect the
    // record's appearance or behavior, or which hold data for use by custom logic or other,
    // related components.
    // <p>
    // For example a ListGrid that defines the following fields:
    // <pre>
    // fields : [
    //     {name: "field1"},
    //     {name: "field2"}
    // ],
    // </pre>
    // Might have the following data:
    // <pre>
    // data : [
    //     {field1: "foo", field2: "bar", customProperty:5},
    //     {field1: "field1 value", field2: "field2 value", enabled:false}
    // ]
    // </pre>
    // Each line of code in the <code>data</code> array above creates one JavaScript Object via
    // JavaScript {type:ObjectLiteral,object literal} notation.  These JavaScript Objects are
    // used as ListGridRecords.
    // <P>
    // Both records shown above have properties whose names match the name property of a
    // ListGridField, as well as additional properties.  The second record will be disabled due to
    // <code>enabled:false</code>; the first record has a property "customProperty" which will
    // have no effect by default but which may be accessed by custom logic.
    // <P>
    // After a ListGrid is created and has loaded data, records may be accessed via
    // +link{listGrid.data}, for example, listGrid.data.get(0) retrieves the first record.
    // ListGridRecords are also passed to many events, such as
    // +link{ListGrid.cellClick,cellClick()}.
    // <P>
    // A ListGridRecord is always an ordinary JavaScript Object regardless of how the grid's
    // dataset is loaded (static data, java server, XML web service, etc), and so supports the
    // normal behaviors of JavaScript Objects, including accessing and assigning to properties
    // via dot notation:
    // <pre>
    //     var fieldValue = record.<i>fieldName</i>;
    //     record.<i>fieldName</i> = newValue;
    // </pre>
    // <P>
    // Note however that simply assigning a value to a record won't cause the display to be
    // automatically refreshed - +link{listGrid.refreshCell()} needs to be called.  Also,
    // consider +link{group:editing,editValues vs saved values} when directly modifying
    // ListGridRecords.
    // <P>
    // See the attributes in the API tab for the full list of special properties on
    // ListGridRecords that will affect the grid's behavior.
    //
    // @treeLocation Client Reference/Grids/ListGrid
    // @see ListGrid.data
    // @inheritsFrom Record
    // @visibility external
    //<
    


    //> @attr listGrid.recordEnabledProperty (string : "enabled" : IR)
    // Property name on a record that will be checked to determine whether a record is enabled.
    // <P>
    // Setting this property on a record will effect the visual style and interactivity of
    // the record.  If set to <code>false</code> the record (row in a +link{ListGrid} or
    // +link{TreeGrid}) will not highlight when the mouse moves over it, nor will it respond to
    // mouse clicks.
    //
    // @see listGridRecord.enabled
    // @example disabledRows
    // @visibility external
    //<
    
    recordEnabledProperty: "enabled",

    //> @attr listGridRecord.enabled (boolean : null : IR)
    //
    // Default property name denoting whether this record is enabled. Property name may be
    // modified for some grid via +link{listGrid.recordEnabledProperty}.
    //
    // @visibility external
    // @example disabledRows
    //<

    //> @attr listGrid.canExpandRecordProperty (string : "canExpand" : IR)
    // Property name on a record that will be checked to determine whether a record can be
    // expanded.
    //
    // @see listGridRecord.canExpand
    // @group expansionField
    // @visibility external
    //<
    canExpandRecordProperty: "canExpand",

    //> @attr listGridRecord.canExpand (boolean : null : IR)
    //
    // Default property name denoting whether this record can be expanded. Property name may be
    // modified for the grid via +link{listGrid.canExpandRecordProperty}.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.recordCanRemoveProperty (String : "_canRemove" : IRA)
    // If set to false on a record and +link{ListGrid.canRemoveRecords,canRemoveRecords} is
    // true, removal of that record is disallowed in the UI. The icon in the remove field
    // is not shown.
    // @group  editing
    // @visibility external
    //<
    recordCanRemoveProperty:"_canRemove",

    //> @attr listGridRecord._canRemove (boolean : null : IRW)
    //
    // Default property name denoting whether this record can be removed. Property name may be
    // modified for the grid via +link{listGrid.recordCanRemoveProperty}.
    //
    // @group  editing
    // @visibility external
    //<

    //> @attr listGridRecord.isSeparator (boolean : null : IR)
    //
    // Default property name denoting a separator row.<br>
    // When set to <code>true</code>, defines a horizontal separator in the listGrid
    // object. Typically this is specified as the only property of a record object, since a
    // record with <code>isSeparator:true</code> will not display any values.<br>
    // Note: this attribute name is governed by +link{ListGrid.isSeparatorProperty}.
    // @visibility external
    //<

    //> @attr listGridRecord.customStyle (CSSStyleName : null : IRW)
    // Name of a CSS style to use for all cells for this particular record.
    // <P>
    // Note that using this property assigns a single, fixed style to the record, so rollover
    // and selection styling are disabled.  To provide a series of stateful styles for a record
    // use +link{listGridRecord._baseStyle} instead.
    // <P>
    // See +link{listGrid.getCellStyle()} for an overview of various ways to customize styling,
    // both declarative and programmatic.
    // <P>
    // If this property is changed after draw(), to refresh the grid call
    // +link{listGrid.refreshRow()} (or +link{listGrid.markForRedraw()} if several rows are
    // being refreshed).
    // <P>
    // If your application's data uses the "customStyle" attribute for something else, the
    // property name can be changed via +link{listGrid.recordCustomStyleProperty}.
    //
    // @visibility external
    //<

    //> @attr listGridRecord._baseStyle (CSSStyleName : null : IRW)
    // Name of a CSS style to use as the +link{listGrid.baseStyle} for all cells for this
    // particular record.
    // <P>
    // The styleName specified with have suffixes appended to it as the record changes state
    // ("Over", "Selected" and so forth) as described by +link{listGrid.getCellStyle()}.  For a
    // single, fixed style for a record, use +link{listGridRecord.customStyle} instead.
    // <P>
    // See +link{listGrid.getCellStyle()} for an overview of various ways to customize styling,
    // both declarative and programmatic.
    // <P>
    // If this property is changed after draw(), to refresh the grid call
    // +link{listGrid.refreshRow()} (or +link{listGrid.markForRedraw()} if several rows are
    // being refreshed).
    // <P>
    // If your application's data uses the "_baseStyle" attribute for something else, the
    // property name can be changed via +link{listGrid.recordBaseStyleProperty}.
    //
    // @visibility external
    //<

    //> @attr listGridRecord.singleCellValue (HTML : null : IRW)
    // Default property name denoting the single value to display for all fields of this row.
    // If this property is set for some record, the record will be displayed as a single
    // cell spanning every column in the grid, with contents set to the value of this
    // property.<br>
    // Note: this attribute name is governed by +link{ListGrid.singleCellValueProperty}.
    // @visibility external
    //<


    //> @attr listGridRecord.canDrag (boolean : null : IR)
    //
    // When set to <code>false</code>, this record cannot be dragged. If canDrag is false for
    // any record in the current selection, none of the records will be draggable.
    //
    // @visibility external
    //<

    //> @attr listGridRecord.canAcceptDrop (boolean : null : IR)
    //
    // When set to <code>false</code>, other records cannot be dropped on (i.e., inserted
    // via drag and drop) immediately before this record.
    //
    // @visibility external
    //<

    //> @attr listGridRecord.linkText (string : null : IRW)
    //
    //  The HTML to display in this row for fields with fieldType set to link. This overrides
    //  +link{attr:listGridField.linkText}.
    //
    //  @see type:ListGridFieldType
    //  @see type:FieldType
    //  @see attr:listGridField.linkText
    //  @see attr:listGrid.linkTextProperty
    //  @group  display_values
    //  @visibility external
    //<

    // Animation
    // ---------------------------------------------------------------------------------------
    // These apply to ListGrid grouping, which basically makes the data model into a Tree where animation
    // is applied for folder open/close.

    //> @attr listGrid.animateFolders (Boolean : true : IRW)
    // If true, when folders are opened / closed children will be animated into view.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation
    //<
    animateFolders:true,

    //> @attr listGrid.animateFolderMaxRows (integer : null : IRW)
    // If +link{animateFolders} is true for this grid, this number can be set to designate
    // the maximum number of rows to animate at a time when opening / closing a folder.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @see treeGrid.getAnimateFolderMaxRows()
    // @group animation
    // @visibility external
    //<

    //> @attr listGrid.animateFolderTime (number : 100 : IRW)
    // When animating folder opening / closing, if +link{treeGrid.animateFolderSpeed} is not
    // set, this property designates the duration of the animation in ms.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation
    // @see listGrid.animateFolderSpeed
    //<
    animateFolderTime:100,

    //> @attr listGrid.animateFolderSpeed (number : 3000 : IRW)
    // When animating folder opening / closing, this property designates the speed of the
    // animation in pixels shown (or hidden) per second. Takes precedence over the
    // +link{treeGrid.animateFolderTime} property, which allows the developer to specify a
    // duration for the animation rather than a speed.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation
    // @see listGrid.animateFolderTime
    //<
    animateFolderSpeed:3000,

    //> @attr listGrid.animateFolderEffect (AnimationAcceleration : null : IRW)
    // When animating folder opening / closing, this property can be set to apply an
    // animated acceleration effect. This allows the animation speed to be "weighted", for
    // example expanding or collapsing at a faster rate toward the beginning of the animation
    // than at the end.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation
    //<

    //> @attr listGrid.animateRowsMaxTime (number : 1000 : IRW)
    // If animateFolderSpeed is specified as a pixels / second value, this property will cap
    // the duration of the animation.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation_advanced
    //<
    animateRowsMaxTime:1000,

    // external: doc'd on TreeGrid
    shouldAnimateFolder : function (folder) {
        if (!this.animateFolders || !this.isDrawn()) return false;
        
        if (this.autoFitData == "vertical" || this.autoFitData== "both") return false;

        var children;
        if (this.data.isFolder(folder)) {
            // Since we are only checking whether there are opened children, don't apply sorting
            // (the dontUseNormalizer parameter is true).
            children = this.data.getOpenList(folder, null, null, null, null, null, null, true);
        }

        // No children - bit arbitrary whether we "animate" or not!
        
        if (children == null || children.length <= 1) return false;
        return (children.length <= this.getAnimateFolderMaxRows());
    },

    // external: doc'd on TreeGrid
    getAnimateFolderMaxRows : function () {
        var maxRows = this.animateFolderMaxRows;
        if (maxRows == null) {
            var vfRs = this.body ? this.body._getViewportFillRows() : [0,0];
            maxRows = Math.min(75, (vfRs[1]-vfRs[0]) * 3);
        }
        return maxRows
    },


    // DataBinding
    // ----------------------------------------------------------------------------------------

    //> @attr listGrid.fields (Array of ListGridField : null : [IRW])
    // An array of field objects, specifying the order, layout, formatting, and
    // sorting behavior of each field in the listGrid object.  In ListGrids, the fields
    // array specifies columns.  Each field in the fields array is a ListGridField object.
    // Any listGrid that will display data should have at least one visible field.
    // <p>
    // If +link{ListGrid.dataSource} is also set, this value acts as a set of overrides as
    // explained in +link{attr:DataBoundComponent.fields}.
    //
    // @see    ListGridField
    // @see    setFields()
    // @group databinding
    // @visibility external
    // @example listGridFields
    // @example mergedFields
    //<

    //> @attr listGrid.defaultFields (Array of ListGridField Properties : null : IRA)
    // An array of listGrid field configuration objects.  When a listGrid is initialized, if this
    // property is set and there is no value for the <code>fields</code> attribute, this.fields will
    // be defaulted to a generated array of field objects duplicated from this array.
    // <P>
    // This property is useful for cases where a standard set of fields will be displayed
    // in multiple listGrids - for example a subclass of ListGrid intended to display a particular
    // type of data:<br>
    // In this example we would not assign a single +link{listGrid.fields} array directly to the
    // class via <code>addProperties()</code> as every generated instance of this class would
    // then point to the same fields array object. This would cause unexpected behavior such as
    // changes to the field order in one grid effecting other grids on the page.<br>
    // Instead we could use <code>addProperties()</code> on our new subclass to set
    // <code>defaultFields</code> to a standard array of fields to display. Each generated instance
    // of the subclass would then show up with default fields duplicated from this array.
    // @visibility external
    //<

    //> @attr   listGrid.dataSource     (DataSource or ID : null : IRW)
    // @include dataBoundComponent.dataSource
    //<

    //> @attr listGrid.autoFetchDisplayMap (Boolean : true : [IRW])
    // If true, for fields where +link{listGridField.optionDataSource} is specified,
    // a valueMap will be automatically created by making a +link{dataSource.fetchData()} call
    // against the specified dataSource and extracting a valueMap from the returned records
    // based on the displayField and valueField.
    // <P>
    // If set to false, valueMaps will not be automatically fetched.  In this case, setting
    // field.optionDataSource is effectively a shortcut for setting optionDataSource on
    // the editor via +link{listGridField.editorProperties}.
    // <P>
    // Can also be disabled on a per-field basis with +link{listGridField.autoFetchDisplayMap}.
    //
    // @group display_values
    // @see listGridField.autoFetchDisplayMap
    // @see listGridField.optionDataSource
    // @visibility external
    //<
    autoFetchDisplayMap:true,

    //> @attr listGrid.warnOnUnmappedValueFieldChange (Boolean : true : IRWA)
    // If a field has +link{listGridField.displayField} specified and has no
    // +link{listGridField.optionDataSource}, this field will display the value from the
    // <code>displayField</code> of each record by default (for more on this behavior
    // see +link{listGridField.optionDataSource}).
    // <P>
    // If such a field is editable, changing the edit value for the field on some record,
    // without updating the edit value for the associated display field on the same record
    // would mean the user would continue to see the unchanged display field value.
    // Developers can resolve this situation by programmatically setting an edit value for
    // the display field as well as the data field, or avoid it by specifying an optionDataSource
    // and ensuring +link{listGrid.autoFetchDisplayMap} is true, or setting an explicit valueMap
    // for the field.
    // <P>
    // By default, when the edit value on a field with a specified displayField and
    // no optionDataSource is set, we log a warning to notify the developer. This warning may
    // be disabled by setting <code>warnOnUnmappedValueFieldChange</code> to <code>false</code>.
    // <P>
    // Note: There are actually a couple of cases in which the system will automatically
    // derive a new display-field value and apply it to the record:
    // <ol><li>If the edit value was changed by a user actually editing the record
    // (rather than a programmatic call to setEditValue()), and the edit-item had
    // a valueMap or optionDataSource set, we automatically pick up the display value from
    // that item and store it as an edit-value for the displayField of the record</li>
    //     <li>If the listGrid has a loaded record in its data set whose valueField value matches
    // the edit value for the valueField, we automatically apply the displayField value from that
    // record as an edit value for the displayField on the newly edited record.</li></ol>
    // In either case, the display value for the record is updated automatically
    // (and the warning would not be logged).
    // @visibility external
    //<
    warnOnUnmappedValueFieldChange:true,

    //or <code>autoFetchDisplayMap</code> is false at
    // the +link{listGrid.autoFetchDisplayMap,listGrid}
    // or +link{listGridField.autoFetchDisplayMap,field} level, the field will display the
    // record value from the +link{

    //> @attr listGrid.saveLocally (boolean : null : IRA)
    // For grids with a specified +link{ListGrid.dataSource}, this property can be set to
    // <code>true</code> to cause the grid directly update its local data set instead of
    // performing an operation against it's configured DataSource.
    // <p>
    // When using this mode, data must be provided to the grid via +link{listGrid.setData()},
    // and must be provided as 
    // <smartclient>a simple Array of Records</smartclient>
    // <smartgwt>a RecordList</smartgwt>.  Setting <code>saveLocally</code> is invalid if
    // either +link{fetchData()} is called or if a +link{ResultSet} is provided as the data
    // model.
    // <p>
    // <code>saveLocally</code> mode includes changes made via 
    // +link{listGrid.canEdit,inline editing}, record removal via +link{canRemoveRecords}, as
    // well as programmatic calls to +link{listGrid.updateData()},
    // +link{listGrid.addData,addData()} and +link{listGrid.removeData,removeData()}.  This
    // also causes saves to be performed synchronously (unlike normal DataSource operations).
    // <p>
    // Note that using this mode also disables the automatic cache synchronization provided by
    // the DataSource system - changes made to this grid are saved only to this grid's data
    // set.
    // <P>
    // See also +link{listGrid.filterLocalData} to allow filtering, such as filtering performed
    // by the +link{filterEditor}, to also work only with the local data set.
    // 
    // @see useRemoteValidators
    // @visibility external
    // @group databinding
    //<
    

    //> @attr ListGrid.saveRequestProperties (DSRequest Properties : null : IRWA)
    // For editable grids with a specified +link{listGrid.dataSource}, where
    // +link{listGrid.saveLocally} is false, this attribute may be used to specify standard
    // DSRequest properties to apply to all save operations performed by this grid (whether
    // triggered by user interaction, or explicit saveEdits or saveAllEdits call).
    // <P>
    // An example usage would be to customize the prompt displayed while saving is in progress
    // if +link{listGrid.waitForSave} is true.
    // <P>
    // Note that for more advanced customization of save operations,
    // +link{dataBoundComponent.addOperation} and +link{dataBoundComponent.updateOperation}
    // are available to developers, allowing specification of an explicit +link{operationBinding}
    // for the add / update operation performed on save.
    //
    // @visibility external
    // @group dataBinding
    // @group editing
    //<

    //> @attr ListGrid.useRemoteValidators (boolean : null : IRWA)
    // If +link{listGrid.saveLocally} is specified, but this grid is bound to a DataSource which
    // includes remote field validators, by default edits will be saved synchronously and
    // these validators will not be executed.<br>
    // Set this property to <code>true</code> to ensure these remote validators are called when
    // saving edits in saveLocally mode. Note that since these remote validators need to run on
    // the server, saving with this property set is asynchronous, even though the data that
    // ultimately gets updated is already present on the client.
    // @visibility external
    // @group databinding
    //<

    //> @attr listGrid.useAllDataSourceFields (boolean : null : IRW)
    // @include dataBoundComponent.useAllDataSourceFields
    // @group databinding
    //<

    //> @attr listGrid.showDetailFields (Boolean : true : IR)
    // Whether to include fields marked <code>detail:true</code> from this component's
    // <code>DataSource</code>.
    // <P>
    // When this property is <code>true</code>, the <code>ListGrid</code> will include all
    // detail fields unless fields have been specifically declared using the
    // +link{listGrid.fields} array.
    // <P>
    // Any field which has been included directly in the <code>fields</code> array will be
    // included regardless of the fields <code>detail</code> attribute.
    // <p>
    // Detail fields included will initially be hidden but the user may show these fields via
    // the default header context menu (+link{listGrid.showHeaderContextMenu}).
    // <P>
    // The field's visibility can also be overridden programatically using the standard
    // +link{listGrid.showField()}, +link{listGrid.hideField()} and +link{listGridField.showIf}
    // APIs, for example, set showIf:"true" to show a detail field initially.
    // <P>
    // Setting this property to false will completely exclude all detail fields from the list
    // grid's fields array, such that they cannot be shown by the user or programmatically.
    //
    // @group databinding
    // @visibility external
    //<
    showDetailFields:true,

    //> @attr ListGrid.titleField (string : see below : IRW)
    // Best field to use for a user-visible title for an individual record from this grid.
    // If +link{ListGrid.dataSource} is non null, this property may be specified on the
    // dataSource instead.
    // <p>
    // If not explicitly set, titleField looks for fields named "title", "name", and "id"
    // in that order.  If a field exists with one of those names, it becomes the titleField.
    // If not, then the first field is designated as the titleField.
    //  @visibility external
    //<

    //> @attr listGrid.dataProperties (ResultSet : null :IRWA)
    // For databound ListGrids, this attribute can be used to customize the +link{ResultSet}
    // object created for this grid when data is fetched
    // @group databinding
    // @visibility external
    //<

    // Grouping
    // ---------------------------------------------------------------------------------------

    //> @object groupNode
    //
    // An auto-generated subclass of +link{TreeNode} representing the group nodes
    // in a grouped +link{ListGrid}.
    //
    // @see listGrid.groupBy()
    // @treeLocation Client Reference/Grids/ListGrid
    // @group grouping
    // @visibility external
    //<

    //> @attr groupNode.groupMembers (Array of ListGridRecord or GroupNode : see below : R)
    // Array of ListGridRecord that belong to this group, or, for multi-field grouping, array
    // of groupNodes of subgroups under this groupNode.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr groupNode.groupTitle (HTML : see below : R)
    // The computed title for the group, which results from +link{listGridField.getGroupTitle()}
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr groupNode.groupValue (any : see below : R)
    // The value from which groups are computed for a field,
    // which results from +link{listGridField.getGroupValue()}
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr listGrid.originalData (object : null : R)
    // When grouped, a copy of the original ungrouped data.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr listGrid.groupTree (AutoChild Tree : null : R)
    // The data tree that results from a call to  +link{listGrid.groupBy()}.
    // This will be a +link{ResultTree} if +link{listGrid.dataSource} is
    // present, otherwise it will be a +link{Tree}.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @type GroupStartOpen
    // Possible values for the state of ListGrid groups when groupBy is called
    //
    // @value "all" open all groups
    // @value "first" open the first group
    // @value "none" start with all groups closed
    // @visibility external
    //<

    //> @attr listGrid.groupStartOpen (GroupStartOpen | Array : "first" : IRW)
    // Describes the default state of ListGrid groups when groupBy is called.
    //
    // Possible values are:
    // <ul>
    // <li>"all": open all groups
    // <li>"first": open the first group
    // <li>"none": start with all groups closed
    // <li>Array of group values that should be opened
    // </ul>
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    groupStartOpen:"first",

    //> @attr listGrid.canCollapseGroup (Boolean : true : IR)
    // Can a group be collapsed/expanded? When true a collapse/expand icon is shown
    // (+link{groupIcon,groupIcon}) and the user can collapse or expand the group by
    // clicking either the row as a whole or the opener icon (see +link{collapseGroupOnRowClick});
    //
    // When false the group icon is not shown and clicking on the row does
    // not change group state. Additionally +link{groupStartOpen,groupStartOpen} is
    // initialized to "all".
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    
    canCollapseGroup:true,
    
    //> @attr listGrid.collapseGroupOnRowClick (boolean : true : IR)
    // If +link{canCollapseGroup} is true, will a click anywhere on the group row
    // toggle the group's expanded state? If false, the user must click the
    // +link{groupIcon} directly to toggle the group.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    collapseGroupOnRowClick:true,

    //> @attr listGrid.groupTitleField (String : null : IR)
    // When a list grid is +link{listGrid.groupBy(),grouped}, each group shows
    // under an auto generated header node. By default the title of the group will be
    // shown, with a hanging indent in this node, and will span all columns in the grid.
    // Setting this property causes the titles of auto-generated group nodes to appear as
    // though they were values of the designated field instead of spanning all columns
    // and record values in the designated groupTitleField will appear indented under
    // the group title in a manner similar to how a TreeGrid shows a Tree.
    // <P>
    // Note if +link{listGrid.showGroupSummaryInHeader} is true, the header nodes will not show
    // a single spanning title value by default - instead they will show the summary values for
    // each field. In this case, if groupTitleField is unset, a
    // +link{listGrid.showGroupTitleColumn,groupTitleColumn} can be automatically generated to
    // show the title for each group.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    
    getGroupTitleField : function () {
        return this.groupTitleField;
    },

    //> @attr listGrid.showGroupTitleColumn (Boolean : true : IR)
    // If this grid is +link{listGrid.groupBy(),grouped} and +link{listGrid.showGroupSummaryInHeader}
    // is true, instead of group header nodes showing up with a single cell value spanning the full
    // set of columns, summaries for each field will show up in the appropriate columns of the
    // header node.
    // <P>
    // In this case there are 2 options for where the group title will show up. Developers may
    // specify an existing field to put the title values into via +link{listGrid.groupTitleField}.
    // If no groupTitleField is specified, this property may be set to <code>true</code>
    // which causes a <code>groupTitleColumn</code> to be automatically generated.
    // Each group header will show the group title in this column (records within the group will
    // not show a value for this column). The column appears in the leftmost position within the
    // grid (unless +link{listGrid.showRowNumbers} is true, in which case this column shows up
    // in the second-leftmost position), and by default will auto-fit to its data.
    // <P>
    // To customize this field, developers may modify
    // +link{listGrid.groupTitleColumnProperties}
    // <smartclient>or
    // +link{listGrid.groupTitleColumnDefaults} at the class level.</smartclient>
    // @visibility external
    //<
    showGroupTitleColumn:true,

    //> @attr listGrid.groupTitleColumnProperties (ListGridField properties : null : IR)
    // Custom properties for the automatically generated <code>groupTitleColumn</code>.
    // <P>
    // See +link{listGrid.showGroupTitleColumn} for an overview of the groupTitleColumn.
    // @visibility external
    //<
    //groupTitleColumnProperties:null,

    //> @attr listGrid.groupTitleColumnDefaults (ListGridField properties : object : IR)
    // Default properties for the automatically generated <code>groupTitleColumn</code>.
    // Default object includes properties to enable autoFitWidth to group title values.
    // <P>
    // To modify the behavior or appearance of this column, developers may set
    // +link{listGrid.groupTitleColumnProperties} at the instance level, or override this
    // object at the class level. If overriding this object, we recommend using
    // +link{class.changeDefaults()} rather than replacing this object entirely.
    // <P>
    // See +link{listGrid.showGroupTitleColumn} for an overview of the groupTitleColumn.
    // @visibility external
    //<
    groupTitleColumnDefaults:{
        canEdit:false,
        canFilter:false,
        canHide:false,
        canReorder:false,
        showDefaultContextMenu:false,
        autoFreeze:true,

        sortNormalizer:function (recordObject,fieldName,context) {
            return recordObject.groupTitle;
        },

        autoFitWidth:true,
        autoFitWidthApproach:"value",
        title:"&nbsp;"
    },

    // We actually show the special group title column if
    // - we're showing the group summary in the header
    // - we have no explicitly specified group title field
    // - the showGroupTitleColumn flag is true
    showingGroupTitleColumn : function () {
        return (this.isGrouped && this.showGroupSummary && this.showGroupSummaryInHeader
                && this.showGroupTitleColumn && this.getGroupTitleField() == null);
    },

    // groupTitleColumnName: This could be modified to display an actual field within the
    // grid data, but the developer might as well use groupTitleField instead.
    // Leaving unexposed for now.
    groupTitleColumnName:"groupTitle",

    getGroupTitleColumn : function () {
        var grid = this;
        var groupTitleColumn = isc.addProperties(
            {   _isGroupTitleColumn:true,
                // 'grid' available through closure
                getAutoFreezePosition: function () { return grid.getGroupTitleColumnPosition() }
            },
            this.groupTitleColumnDefaults,
            this.groupTitleColumnProperties
        );

        if (groupTitleColumn.name == null) {
            groupTitleColumn.name = this.groupTitleColumnName;
        }
        return groupTitleColumn;
    },

    getGroupTitleColumnPosition : function () {
        // This is really just a sanity check - we don't expect to be calling this method when
        // we're not showing the special groupTitleColumn
        if (!this.showingGroupTitleColumn()) return -1;

        
        var pos = 0;
        if (this.shouldShowRowNumberField()) pos++;
        if (this.shouldShowCheckboxField()) pos++;
        if (this.shouldShowExpansionField()) pos++;
        return pos;
    },

    singleCellGroupHeaders : function () {
        return this._singleCellGroupHeaders(this.showGroupSummary, this.showGroupSummaryInHeader);
    },
    _singleCellGroupHeaders : function (showGroupSummary, showGroupSummaryInHeader) {
        if (this.getGroupTitleField() != null) return false;
        if (showGroupSummary && showGroupSummaryInHeader) return false;
        return true
    },

    //> @attr listGrid.showGroupSummaryInHeader (Boolean : false : IRW)
    // If this grid is +link{listGrid.groupBy(),grouped}, and +link{listGrid.showGroupSummary}
    // is true, setting this property causes field summary values for each group to be displayed
    // directly in the group header node, rather than showing up at the bottom of each
    // expanded group.
    // <P>
    // Note that this means the group header node will be showing multiple field values
    // rather than the default display of a single cell spanning all columns containing the
    // group title. Developers may specify an explicit +link{listGrid.groupTitleField}, or
    // rely on the automatically generated +link{listGrid.showGroupTitleColumn,groupTitleColumn}
    // to have group titles be visible as well as the summary values.
    // <P>
    // Also note that multi-line group summaries are not supported when showing
    // the group summary in the group header. If multiple
    // +link{listGridField.summaryFunction,field summary functions} are defined for some field
    // only the first will be displayed when this property is set to true.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    showGroupSummaryInHeader:false,

    //> @attr listGrid.showCollapsedGroupSummary (Boolean : false : IRW)
    // Should group summaries be visible when the group is collapsed?
    // <P>
    // This property only applies to +link{listGrid.groupBy(),grouped} grids showing
    // +link{listGrid.showGroupSummary,group summary rows}. When set to true, the
    // group summary row(s) for each group will show up under the group header nodes when
    // the group is collapsed, or at then end of the grouped set of data if the group
    // is expanded.
    // <P>
    // This property has no effect if +link{showGroupSummaryInHeader} is true.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    showCollapsedGroupSummary:false,

    //> @method listGridField.getGroupValue()
    // Return the value which records should be grouped by.
    // <P>
    // All records for which getGroupValue() returns the same value appear in the same
    // group.  Default is the result of +link{listGrid.getCellValue}.
    // <P>
    // While any type of value may be returned, avoiding the use of string values may
    // result in improved performance. In this case, +link{listGridField.getGroupTitle()}
    // may be implemented to map a numeric group value into a legible string.
    //
    // @param   value (any)   raw value for the cell, from the record for the row
    // @param   record (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter (see +link{listGrid.getEditValues()})
    // @param   field (Object)    Field object for which to get group value
    // @param   fieldName (String)    The name of the field
    // @param   grid (ListGrid) the ListGrid displaying the cell
    // @return (any) Group value to which this record belongs
    //
    // @see listGrid.groupBy()
    // @see listGridField.getGroupTitle()
    // @group grouping
    // @visibility external
    // @example customGrouping
    //<

    //> @method listGridField.getGroupTitle()
    // Return the title that should be shown to the user for the group with the
    // <code>groupValue</code> passed as a parameter.
    // <P>
    // Default title is the groupValue itself.
    //
    // @group grouping
    //
    // @param   groupValue (any)   the value from the group is created, the result of
    //  +link{listGridField.getGroupValue()}
    // @param   groupNode (groupNode) the node in the grid containing the group.
    // @param   field (Object)    Field object for which to get group value
    // @param   fieldName (String)    The name of the field
    // @param   grid (ListGrid) the ListGrid displaying the cell
    // @return (any) Group value to which this record belongs
    //
    // @see listGrid.groupBy()
    // @see listGridField.getGroupValue()
    // @visibility external
    // @example customGrouping
    //<

    //> @attr listGridField.groupingModes (ValueMap : null : IR)
    // If this field can be grouped, this attribute represents the set of grouping styles that 
    // are available.  For example, a "date" field might be able to be 
    // grouped by week or month, as well as by the date itself.
    // <P>
    // If <code>groupingModes</code> are present and
    // +link{listGrid.canGroupBy,grouping is enabled}, the menu for this field includes a
    // submenu of possible grouping modes generated from the <code>groupingModes</code> valueMap.
    // When the user selects a particular grouping mode,
    // +link{listGridField.groupingMode,field.groupingMode} is set to the user's chosen mode,
    // and this choice can be detected via the <code>field</code> parameter to
    // +link{listGridField.getGroupValue()} in order to provide different modes of grouping.
    // <P>
    // The user may also choose to group records without specifying a grouping mode, in this case,
    // the +link{listGridField.defaultGroupingMode} is used.
    // <P>
    // Note that <code>getGroupValue</code>, <code>groupingModes</code> et al can be specified on
    // +link{SimpleType} declarations.  See this list of
    // +link{group:builtinGroupingModes, builtin grouping modes} for more information.    
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.groupingMode (identifier : null : IR)
    // For a field that allows multiple +link{listGridField.groupingModes,grouping modes},
    // the current grouping mode.
    // <P>
    // This property is set when a user chooses a particular grouping mode, and may be set on
    // ListGrid creation to affect the initial grouping.
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.defaultGroupingMode (identifier : null : IR)
    // Default groupingMode used when the user does not specify a mode or grouping is triggered
    // programmatically and +link{listGridField.groupingMode,field.groupingMode} is unset.
    // See +link{listGridField.groupingModes,field.groupingModes}.
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.groupPrecision (integer : null : IR)
    // For fields of type:"float" or derived from float, number of digits after the decimal point
    // to consider when grouping.
    // <P>
    // For example, <code>groupPrecision:2</code> indicates that 45.238 and 45.231 group together,
    // but 45.22 and 45.27 are separate.
    // <P>
    // See also +link{listGridField.groupGranularity,groupGranularity} for grouping by broader
    // ranges.
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.groupGranularity (integer : null : IR)
    // Granularity of grouping for numeric fields.
    // <P>
    // Groups will be formed based on ranges of values of size <code>groupGranularity</code>.  For
    // example, if groupGranularity were 1000, groups would be 0-1000, 1000-2000, etc.
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.canHilite (boolean : null : IRW)
    // Determines whether this field can be hilited.  Set to false to prevent this
    // field from appearing in HiliteEditor.
    //
    // @visibility external
    //<

    //> @attr listGridField.showHilitesInGroupSummary (Boolean : null : IRW)
    // Determines whether hiliting for this field is shown in a group summary.
    // Set to false to prevent this field from showing hilite in a group summary.
    // <P>
    // All hilites in group summary rows can be controlled with the
    // +link{listGrid.showHilitesInGroupSummary} property.
    //
    // @visibility external
    //<

    //> @attr listGridField.canGroupBy (Boolean : true : IRW)
    // Determines whether this field will be groupable in the header context menu.
    //
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr listGridField.canSortClientOnly (Boolean : false : IRW)
    // When true, this field can only be used for sorting if the data is entirely client-side.
    //
    // @visibility external
    //<

    //> @attr listGridField.showDefaultContextMenu (Boolean : true : IRW)
    // When set to false, this field will not show a context menu in its header.
    //
    // @visibility external
    //<

    //> @attr listGridField.canExport (Boolean : null : IR)
    //  Dictates whether the data in this field be exported.  Explicitly set this
    //  to false to prevent exporting.  Has no effect if the underlying
    //  +link{dataSourceField.canExport, dataSourceField} is explicitly set to
    //  canExport: false.
    //
    // @visibility external
    //<

    //> @attr listGridField.exportRawValues (Boolean : null : IR)
    //  Dictates whether the data in this field should be exported raw by
    // +link{listGrid.exportClientData, exportClientData()}.  If set to true for a
    // field, the values in the field-formatters will not be executed for data in this field.
    // Decreases the time taken for large exports.
    //
    // @visibility external
    //<

    //> @attr listGridField.summaryValue (HTMLString : null : IRW)
    // The value to display for a ListGridField when it appears in the +link{listGrid.summaryRow,summaryRow}.  The
    // default for normal fields is null and for special fields, like the +link{listGrid.checkboxField,checkboxField},
    // the default is to show a blank value (a non-breaking space).
    // @visibility external
    //<

    //> @attr listGrid.groupNodeStyle (String : "groupNode" : IRW)
    // The CSS style that +link{listGrid.groupBy,group} rows will have.
    // <P>
    // Note that this is not a +link{listGrid.getBaseStyle(),base style}, so, if this
    // property is set, group nodes will not show stateful styling
    // (different styles for +link{listGrid.showRollOver},
    // +link{listGrid.alternateRecordStyles}, etc). To enable stateful styling for
    // groupNodes, set this property to <code>null</code> and specify a
    // +link{groupNodeBaseStyle}
    //
    // @group grouping
    // @see group:grouping
    // @visibility external
    //<
    groupNodeStyle: "groupNode",

    //> @attr listGrid.groupNodeBaseStyle (String : null : IRW)
    // +link{listGrid.getBaseStyle(),Base style} for +link{listGrid.groupBy,group} rows.
    // <P>
    // Note that this property has no effect if +link{listGrid.groupNodeStyle} is
    // non null.
    //
    // @group grouping
    // @see group:grouping
    // @visibility external
    //<
    groupNodeBaseStyle: null,

    //> @attr listGrid.groupIcon (SCImgURL : "[SKINIMG]/TreeGrid/opener.gif" : IRW)
    // The URL of the base icon for the group icons in this listGrid. Default value may 
    // be overridden by the +link{group:skinning,current skin}.
    //
    // @group grouping
    // @see group:grouping
    // @visibility external
    //<
    groupIcon: "[SKINIMG]/TreeGrid/opener.gif",

    //> @attr listGrid.groupIconSize (Number : 16 : IRW)
    // Default width and height of group icons for this ListGrid.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    groupIconSize: 16,

    //> @attr listGrid.groupIndentSize (Number : 20 : IRW)
    // Default number of pixels by which to indent subgroups relative to parent group.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @see listGrid.getGroupNodeHTML
    // @visibility external
    //<
    groupIndentSize: 20,

    //> @attr listGrid.groupLeadingIndent (Number : 10 : IRW)
    // Default number of pixels by which to indent all groups.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @see listGrid.getGroupNodeHTML
    // @visibility external
    //<
    groupLeadingIndent: 10,

    //> @attr listGrid.canGroupBy (Boolean : true : IRW)
    // If false, grouping via context menu will be disabled.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    canGroupBy: true,

    //> @attr listGrid.groupByMaxRecords (int : 1000 : IRW)
    // Maximum number of records to which a groupBy can be applied. If there are more records,
    // grouping will not be available via the default header context menu, and calls to
    // +link{listGrid.groupBy()} will be ignored.
    // <P>
    // The maximum exists because ListGrid grouping is performed in-browser, hence requires loading of
    // all records that match the current filter criteria before records can be grouped.  The default
    // maximum represents a number of records which are safe to load in legacy browsers such as Internet
    // Explorer 8 (modern browsers can handle far more), and is also a good upper limit from the
    // perspective of loading data from a database.
    // <P>
    // Going beyond this limit can cause "script running slowly" errors from legacy browsers (as well as
    // high database load).  To build an interface for grouping that handles arbitrary data volume, use
    // a TreeGrid with +link{treeGrid.loadDataOnDemand} with server-side grouping code.
    //
    // @group grouping
    // @see groupBy
    // @visibility external
    //<
    groupByMaxRecords: 1000,

    //> @attr listGrid.groupByAsyncThreshold (int : 50 : IRW)
    // When grouping is requested with this number of records or more, an asynchronous approach is
    // used to avoid the browser showing a "script is running slowly.." message prompting the
    // user to stop execution of JavaScript.
    // <p>
    // Note that +link{groupByMaxRecords} must be set at least as high as +link{groupByAsyncThreshold}
    // or asynchronous grouping will never be used.
    // <p>
    // During async grouping, interactivity is blocked and the +link{asynchGroupingPrompt} is shown
    // to the user, then hidden when grouping completes; +link{groupByComplete} then fires.
    // <p>
    // Note that this async processing covers grouping <b>only</b> - it does not cover whole grid or
    // per-group summaries, client-side sort or filter, or other operations that may cause the browser
    // to show the "script is running slowly" prompt when working with very large sets of records in a
    // grid.
    // <p>
    // At this time, there is no generally effective way to avoid this warning dialog appearing with very
    // large datasets in Microsoft's Internet Explorer (IE).  IE's severely flawed detection algorithm for
    // runaway scripts has been shown to interrupt computations after only 0.2 seconds elapsed time
    // even if the computation would have finished in 0.3 seconds.  Optimizations that reduce
    // execution time can sometimes trigger the "script running slowly" dialog sooner.  Since not
    // every operation can reasonably be made asynchronous, the current recommendation is to avoid
    // working with overly large datasets until the affected versions of IE are obsoleted.
    // @visibility external
    //<
    groupByAsyncThreshold: 50,

    //> @attr listGrid.showAsynchGroupingPrompt (Boolean : null : IR)
    // If set to false, do not show the +link{asynchGroupingPrompt} dialog during
    // +link{groupByAsyncThreshold,asynchronous grouping}.
    // @visibility external
    //<

    //> @attr listGrid.asynchGroupingPrompt (HTMLString : "${loadingImage}&nbsp;Grouping data..." : IR)
    // The prompt to display while interactivity is blocked during +link{groupByAsyncThreshold,asynchronous grouping}.
    // @group i18nMessages
    // @visibility external
    //<
    asynchGroupingPrompt: "${loadingImage}&nbsp;Grouping data...",

    //> @attr listGrid.isGrouped (boolean : false : R)
    // True if this listGrid is grouped, false otherwise
    //
    // @group grouping
    // @visibility external
    // @see     groupBy
    //<

    //> @attr listGrid.nullGroupTitle (String : '-none-' : IRW)
    // Default alias to use for groups with no value
    //
    // @group grouping
    // @visibility external
    // @see     groupBy
    //<
    nullGroupTitle: "-none-",

    //> @attr listGrid.groupByField (String | Array of String : see below : IR)
    // List of fields to group grid records. If only a single field is used, that field
    // may be specified as a string. After initialization, use +link{listGrid.groupBy()}
    // to update the grouping field list, instead of modifying groupByField directly.
    // @group grouping
    // @visibility external
    // @see groupBy
    // @example dynamicGrouping
    //<


    // ----------------------
    // Value icons
    // The valueIcons object is a mapping between values and image URLs - when specified
    // we show the valueIcon image either next to, or instead of the normal cell value.

    //> @attr listGridField.valueIcons (Map<String,String> : null : IRW)
    // This property is a mapping from data values for this field to +link{SCImgURL,urls} for
    // icons to display for those data values.  
    // <p>
    // For example, given a field named "status" with possible values
    // "Normal", "Slow", "Offline", the follow definition would show various icons for that
    // field:
    // <P>
    // <smartclient>
    // <pre>
    // fields : [
    //     { name:"status",
    //       valueIcons: {
    //           Normal : "greenIcon.png",
    //           Slow : "yellowIcon.png",
    //           Offline : "redIcon.png"
    //       }
    //     },
    //     ... other fields ...
    // ]
    // </pre>
    // </smartclient>
    // <smartgwt>
    // <pre>
    // ListGridField statusField = new ListGridField("status");
    // statusField.setValueIcons(new HashMap&lt;String, String>() {{
    //    put("Normal", "greenIcon.png");
    //    put("Slow", "yellowIcon.png");
    //    put("Offline", "redIcon.png");
    // }});
    // </pre>
    // </smartgwt>
    // <p>
    // If a simple value-to-URL mapping is not enough, you can override +link{ListGrid.getValueIcon()}
    // to customize the behavior.  You can even specify an empty <code>valueIcons</code> map
    // and use +link{ListGrid.getValueIcon()} to return arbitrary icons with no fixed mapping.
    // <p>
    // <code>valueIcons</code> can either be displayed alongside the normal value or can
    // replace the normal field value so that only the icon is shown.  See
    // +link{listGridField.showValueIconOnly}.  When placed alongside the value, use
    // +link{valueIconOrientation} to control left- vs right-side placement.
    // <P>
    // If inline editing is enabled for this field, editors displayed for this field will also
    // show valueIcons.  This may be overridden by explicitly setting
    // +link{listGridField.editorValueIcons}.
    // <P>
    // Note that the following attributes related to valueIcon styling will also be picked up
    // by the editor from the ListGridField object unless explicitly specified via the
    // equivalent <code>editor_</code> attributes:<br>
    // +link{listGridField.valueIconWidth}<br>
    // +link{listGridField.valueIconHeight}<br>
    // +link{listGridField.valueIconSize}<br>
    // +link{listGridField.valueIconLeftPadding}<br>
    // +link{listGridField.valueIconRightPadding}<br>
    // +link{listGridField.imageURLPrefix}<br>
    // +link{listGridField.imageURLSuffix}
    // <P>
    // If +link{listGridField.valueIconClick()} is defined for the field, a pointer
    // cursor will be shown when the user rolls over the valueIcon, and the valueIconClick
    // method will execute when the user clicks the icon.
    //
    // @group imageColumns
    // @visibility external
    //<
    
    //> @method listGridField.valueIconClick()
    //
    // Executed when the user clicks on a +link{listGridField.valueIcons,value icon} within
    // this field. Return false to suppress default behavior of firing +link{recordClick} 
    // handlers, etc.
    //
    // @param   viewer      (ListGrid)  the listGrid that contains the click event
    // @param   record      (ListGridRecord)    the record that was clicked on
    // @param   recordNum   (number)    number of the record clicked on in the current set of
    //                                  displayed records (starts with 0)
    // @param   field       (ListGridField) the field that was clicked on (field definition)
    // @param   rawValue    (any)   raw value of the cell (before valueMap, etc applied)
    // @param   editor      (FormItem) If this cell is being +link{listGrid.canEdit,edited}, 
    //  this method will fire when the user clicks the valueIcon on the edit item for the
    //  cell, passing in the editor item as the <code>editor</code> parameter. If the cell
    //  is not being edited, this value will be null.
    // @return  (boolean)   false to stop event bubbling
    //
    // @group   events
    //
    // @see attr:listGridField.valueIcons
    // @visibility external
    //<


    //> @attr listGrid.valueIconSize (number : 16 : IRW)
    // Default width and height of value icons for this ListGrid.
    // Can be overridden at the listGrid level via explicit +link{ListGrid.valueIconWidth} and
    // +link{ListGrid.valueIconHeight}, or at the field level via +link{ListGridField.valueIconSize},
    // +link{ListGridField.valueIconWidth} and {ListGridField.valueIconHeight}
    // @visibility external
    // @group imageColumns
    // @see ListGrid.valueIconWidth
    // @see ListGrid.valueIconHeight
    // @see ListGridField.valueIconSize
    //<
    valueIconSize:16,


    //> @attr listGrid.valueIconWidth (number : null : IRW)
    // Width for value icons for this listGrid.
    // Overrides +link{ListGrid.valueIconSize}.
    // Can be overridden at the field level
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGrid.valueIconHeight (number : null : IRW)
    // Height for value icons for this listGrid.
    // Overrides +link{ListGrid.valueIconSize}.
    // Can be overridden at the field level
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.valueIconSize (number : null : IRW)
    // Default width and height of value icons in this field.
    // Takes precedence over valueIconWidth, valueIconHeight and valueIconSize specified at
    // the ListGrid level.
    // Can be overridden via +link{ListGridField.valueIconWidth} and {ListGridField.valueIconHeight}
    // @visibility external
    // @group imageColumns
    // @see ListGrid.valueIconSize
    // @see ListGridField.valueIconWidth
    // @see ListGridField.valueIconHeight
    //<

    //> @attr listGridField.valueIconWidth (number : null : IRW)
    // Width for value icons for this listGrid field.
    // Overrides +link{ListGrid.valueIconSize}, +link{ListGrid.valueIconWidth}, and
    // +link{ListGridField.valueIconSize}.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.valueIconHeight (number : null : IRW)
    // Height for value icons for this listGrid field.
    // Overrides +link{ListGrid.valueIconSize}, +link{ListGrid.valueIconHeight}, and
    // +link{ListGridField.valueIconSize}.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr   listGridField.valueIconLeftPadding (number : null : IRW)
    // How much padding should there be on the left of valueIcons for this field
    // Overrides +link{listGrid.valueIconLeftPadding}
    // @group imageColumns
    // @see ListGridField.valueIcons
    // @visibility external
    //<

    //> @attr   listGridField.valueIconRightPadding (number : null : IRW)
    // How much padding should there be on the right of valueIcons for this field
    // Overrides +link{listGrid.valueIconRightPadding}
    // @group imageColumns
    // @see ListGridField.valueIcons
    // @visibility external
    //<

    //> @attr listGridField.editorValueIcons (Map<String,String> : null : IRW)
    // When some cell in this field is being edited, setting this property will specify the
    // value icons to display in the cell's editor. If unset, the editor's valueIcons
    // will be determined in the same way as it would be for a static cell.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.editorValueIconWidth (number : null : IRW)
    // When some cell in this field is being edited, setting this property will specify the
    // width for value icons in the cell's editor. If unset, the editor's valueIcon width and
    // height will be determined in the same way as it would be for a static cell.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.editorValueIconHeight (number : null : IRW)
    // When some cell in this field is being edited, setting this property will specify the
    // height for value icons in the cell's editor. If unset, the editor's valueIcon width and
    // height will be determined in the same way as it would be for a static cell.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.showValueIconOnly (boolean : null : IRW)
    // If this field has a valueIcons property specified, setting this property causes
    // the valueIcon for each value to be displayed in the cell without also showing the
    // record's value for the field.
    // <P>
    // If unset the default behavior is to show the icon only if an explicit valueMap is
    // specified as well in addition to a valueIcons map, otherwise show both the valueIcon and
    // value for the cell.
    // <P>
    // Note that if this field is editable +link{FormItem.showValueIconOnly} will be passed
    // through to editors displayed in this field.
    //
    // @group imageColumns
    // @see listGridField.valueIcons
    // @see listGridField.suppressValueIcon
    // @visibility external
    //<

    // NOTE: showValueIconOnly: the use cases are:
    // - represent a value as an icon only to minimize space
    // - show text, but add an icon as decoration, either to all values, or to emphasize some
    //   values for quicker scanning
    // The property 'showValueIconOnly' allows the developer to explicitly show the valueIcon
    // with or without text.  If showValueIconOnly is unset, we make the assumption that:
    // - if the field is *not* constrained to a fixed set of values (has no valueMap), there's
    //   no way to have icons for all the values, so the purpose of the icons is to add
    //   emphasis to certain values [so we show both text and images]
    // - otherwise the developer has an icon for every possible value, so there is no need for
    //   the value to also be displayed - we size the field large enough to accommodate the icon
    //   only, and suppress the text.

    //> @attr   listGridField.suppressValueIcon (boolean : null : IRW)
    // If this field has a valueIcons property specified, setting this property to true will
    // prevent the valueIcon being written out into this field's cells.
    // <P>
    // Note this property may also be set to false to avoid showing the standard
    // +link{listGrid.booleanTrueImage} and +link{listGrid.booleanFalseImage} for fields of type
    // <code>boolean</code>.
    //
    // @group imageColumns
    // @see listGridField.valueIcons
    // @see listGridField.showValueIconOnly
    // @visibility external
    //<

    //> @attr   listGridField.valueIconOrientation (string : null : IRW)
    // If we're showing a valueIcon for this field should it appear to the left or the right
    // of the text?  By default the icon will appear to the left of the textual value -
    // set this to "right" to show the icon on the right of the text.
    // Has no effect if +link{listGridField.showValueIconOnly} is true
    // @visibility external
    // @group imageColumns
    //<
    

    //> @attr   listGrid.valueIconLeftPadding (number : 2 : IRW)
    // How much padding should there be on the left of valueIcons by default
    // Can be overridden at the field level
    // @group imageColumns
    // @see ListGridField.valueIcons
    // @visibility external
    //<
    valueIconLeftPadding:2,

    //> @attr   listGrid.valueIconRightPadding (number : 2 : IRW)
    // How much padding should there be on the right of valueIcons by default
    // @group imageColumns
    // Can be overridden at the field level
    // @see ListGridField.valueIcons
    // @visibility external
    //<
    valueIconRightPadding:2,

    // ------------
    // Hilite Icons
    // ------------

    //> @attr listGrid.hiliteIcons (Array of String : ["[SKINIMG]/Dialog/notify.png", "[SKINIMG]/Dialog/warn.png", "[SKINIMG]/actions/approve.png"] : IR)
    // @include dataBoundComponent.hiliteIcons
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGrid.hiliteIconPosition (HiliteIconPosition : "before" : IR)
    // @include dataBoundComponent.hiliteIconPosition
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGrid.hiliteIconSize (number : 12 : IRW)
    // @include dataBoundComponent.hiliteIconSize
    // @group hiliting
    // @see hiliteIconWidth
    // @see hiliteIconHeight
    // @see ListGridField.hiliteIconSize
    // @visibility external
    //<

    //> @attr listGrid.hiliteIconWidth (number : null : IRW)
    // @include dataBoundComponent.hiliteIconWidth
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGrid.hiliteIconHeight (number : null : IRW)
    // @include dataBoundComponent.hiliteIconHeight
    // @group hiliting
    // @visibility external
    //<

    //> @attr   listGrid.hiliteIconLeftPadding (number : 2 : IRW)
    // @include dataBoundComponent.hiliteIconLeftPadding
    // @group hiliting
    // @visibility external
    //<

    //> @attr   listGrid.hiliteIconRightPadding (number : 2 : IRW)
    // @include dataBoundComponent.hiliteIconRightPadding
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGridField.hiliteIconPosition (HiliteIconPosition : null : IR)
    // When +link{listGrid.hiliteIcons} are present, where the hilite icon will be placed
    // relative to the field value.  See +link{type:HiliteIconPosition}.
    // Overrides +link{listGrid.hiliteIconPosition}.
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGridField.hiliteIconSize (number : null : IRW)
    // Default width and height of +link{listGrid.hiliteIcons, hilite icons} in this field.
    // Takes precedence over hiliteIconWidth, hiliteIconHeight and hiliteIconSize specified at
    // the component level.
    // Can be overridden via +link{ListGridField.hiliteIconWidth} and
    // +link{ListGridField.hiliteIconHeight}
    // @group hiliting
    // @see ListGrid.hiliteIconSize
    // @see ListGridField.hiliteIconWidth
    // @see ListGridField.hiliteIconHeight
    // @visibility external
    //<

    //> @attr listGridField.hiliteIconWidth (number : null : IRW)
    // Width for hilite icons for this field.
    // Overrides +link{listGrid.hiliteIconSize}, +link{listGrid.hiliteIconWidth}, and
    // +link{ListGridField.hiliteIconSize}.
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGridField.hiliteIconHeight (number : null : IRW)
    // Height for hilite icons for this field.
    // Overrides +link{listGrid.hiliteIconSize}, +link{listGrid.hiliteIconHeight}, and
    // +link{ListGridField.hiliteIconSize}.
    // @group hiliting
    // @visibility external
    //<

    //> @attr   listGridField.hiliteIconLeftPadding (number : null : IRW)
    // How much padding should there be on the left of +link{DataBoundComponent.hiliteIcons, hilite icons}
    // for this field?
    // Overrides +link{listGrid.hiliteIconLeftPadding}
    // @group hiliting
    // @visibility external
    //<

    //> @attr   listGridField.hiliteIconRightPadding (number : null : IRW)
    // How much padding should there be on the right of +link{DataBoundComponent.hiliteIcons, hilite icons}
    // for this field?
    // Overrides +link{listGrid.hiliteIconRightPadding}
    // @group hiliting
    // @visibility external
    //<


    

    //> @attr   ListGridField.imageURLPrefix (string : null : IRWA)
    // If this field has type [+link{type:ListGridFieldType}] set to <code>"image"</code>
    // and the URL for the image displayed is not absolute, the path of the URL will be relative
    // to this string<br>
    // Alternatively, if this field displays any valueIcons, this prefix will be applied to
    // the beginning of any +link{ListGridField.valueIcons} when determining the
    // URL for the image.
    // @group imageColumns
    // @visibility external
    // @example imageType
    //<

    //> @attr   ListGridField.imageURLSuffix (string : null : IRWA)
    // If any cells in this field are showing a value icon (see: +link{ListGridField.valueIcons})
    // or this is has +link{type:ListGridFieldType} set to <code>"image"</code>, this the value
    // of this property will be appended to the end of the URL for the icon displayed.<br>
    // Typical usage might be to append a file type such as <code>".gif"</code> to the
    // filename of the image.<br>
    // For editable fields, this property will also be passed through to any editors as
    // +link{FormItem.imageURLSuffix}.
    // @group imageColumns
    // @visibility external
    // @example imageType
    //<

    //> @attr   ListGridField.editorImageURLPrefix (string : null : IRWA)
    // When some cell in this field is being edited, this property can be used to apply
    // an explicit +link{FormItem.imageURLPrefix} to the editor in question.
    // This can be used to modify the valueIcons within the editor.<br>
    // If unset, but +link{ListGridField.imageURLPrefix} is specified, that will be used
    // instead.
    // @group editing
    // @visibility external
    //<

    //> @attr   ListGridField.editorImageURLSuffix (string : null : IRWA)
    // When some cell in this field is being edited, this property can be used to apply
    // an explicit +link{FormItem.imageURLSuffix} to the editor in question.
    // This can be used to modify the valueIcons within the editor.<br>
    // If unset, but +link{ListGridField.imageURLPrefix} is specified, that will be used
    // instead.
    // @group editing
    // @visibility external
    //<

    //> @attr   listGrid.imageSize (number : 16 : IRW)
    // Default size of thumbnails shown for fieldTypes image and imageFile.  Overrideable on a
    // per-field basis via +link{attr:ListGridField.imageSize} or
    // +link{attr:ListGridField.imageWidth}/+link{attr:ListGridField.imageHeight}
    //
    // @group imageColumns
    // @visibility external
    //<
    imageSize: 16,

    //> @attr   listGridField.imageSize (number : 16 : IRW)
    // Size of images shown for fieldTypes image and imageFile in this field.
    // This setting overrides the global ListGrid default +link{attr:ListGrid.imageSize}.
    // <P>
    // If set to a String, assumed to be a property on each record that specifies the image
    // height.  For example, if <code>field.imageSize</code> is "logoSize",
    // <code>record.logoSize</code> will control the size of the image.
    //
    // @see attr:ListGridField.imageWidth
    // @see attr:ListGridField.imageHeight
    //
    // @group imageColumns
    // @visibility external
    //<

    //> @attr   listGridField.imageWidth (number : 16 : IRW)
    // Width of images shown for fieldTypes image and imageFile in this field.
    // <P>
    // If set to a String, assumed to be a property on each record that specifies the image
    // width.  For example, if <code>field.imageWidth</code> is "logoWidth",
    // <code>record.logoWidth</code> will control the width of the image.
    //
    // @see attr:ListGrid.imageSize
    // @see attr:ListGridField.imageSize
    // @see attr:ListGridField.imageHeight
    //
    // @group imageColumns
    // @visibility external
    //<

    //> @attr   listGridField.imageHeight (number : 16 : IRW)
    // Height of image shown for fieldTypes image and imageFile in this field.
    // <P>
    // If set to a String, assumed to be a property on each record that specifies the image
    // height.  For example, if <code>field.imageHeight</code> is "logoHeight",
    // <code>record.logoHeight</code> will control the height of the image.
    //
    // @see attr:ListGrid.imageSize
    // @see attr:ListGridField.imageSize
    // @see attr:ListGridField.imageWidth
    //
    // @group imageColumns
    // @visibility external
    //<

    // ListGridField
    // ---------------------------------------------------------------------------------------

    //  -- Define the 'listGridField' pseudo class for doc

    //> @object ListGridField
    // An ordinary JavaScript object containing properties that configures the display of
    // and interaction with the columns of a +link{ListGrid}.
    //
    // @see ListGrid.fields
    // @see ListGrid.setFields
    // @treeLocation Client Reference/Grids/ListGrid
    // @visibility external
    //<

    //> @type ListGridFieldType
    // ListGrids format data for viewing and editing based on the <i>type</i> attribute of the
    // field.  This table describes how the ListGrid deals with the various built-in types.
    //
    // @value "text"    Simple text rendering for view.  For editing a text entry field is shown.
    // If the length of the field (as specified by the +link{attr:dataSourceField.length}
    // attribute) is larger than the value specified by +link{attr:listGrid.longTextEditorThreshold}, a
    // text input icon is shown that, when clicked on (or field is focused in) opens a larger
    // editor that expands outside the boundaries of the cell (textarea by default, but
    // overrideable via +link{ListGrid.longTextEditorType}).
    //
    // @value "boolean" For viewing and editing a checkbox is shown with a check mark for the
    // <code>true</code> value and no check mark for the <code>false</code> value. This behavior
    // may be suppressed by setting +link{listGridField.suppressValueIcon} for the field. See
    // +link{ListGrid.booleanTrueImage} for customization.
    //
    // @value "integer" Same as <code>text</code>.  Consider setting
    // +link{listGridField.editorType,editorType} to use a +link{SpinnerItem}.
    //
    // @value "float" Same as <code>text</code>.  Consider setting
    // +link{listGridField.editorType,editorType} to use a +link{SpinnerItem}.
    //
    // @value "date" Field value should be a <code>Date</code> instance representing a logical
    // date, with no time of day information.  See +link{group:dateFormatAndStorage} for
    // details of the logical date type and how it is represented and manipulated.
    // <P>
    // Dates will be formatted using +link{listGridField.dateFormatter,ListGridField.dateFormatter}
    // if specified, otherwise
    // +link{ListGrid.dateFormatter,ListGrid.dateFormatter}.
    // If both these attributes are unset, dates are formatted
    // using the standard +link{Date.setShortDisplayFormat(),short display format} for dates.
    // <P>
    // For editing, by default a +link{DateItem} is used with +link{DateItem.useTextField} set
    // to true, providing textual date entry plus a pop-up date picker. The
    // +link{DateItem.dateFormatter, dateFormatter} and +link{DateItem.inputFormat, inputFormat}
    // for the editor will be picked up from the ListGridField, if specified.
    //
    // @value "time" Field value should be a <code>Date</code> instance representing a logical
    // time, meaning time value that does not have a specific day and also has no timezone.  See
    // +link{group:dateFormatAndStorage} for details of the logical time type and how it is
    // represented and manipulated.
    // <P>
    // Times will be formatted using +link{listGridField.timeFormatter,ListGridField.timeFormatter}
    // if specified,
    // otherwise +link{ListGrid.timeFormatter,ListGrid.timeFormatter}.
    // <P>
    // If both these attributes are unset, times are formatted using the standard
    // +link{Time.shortDisplayFormat,short display format} for times.
    // <P>
    // For editing, by default a +link{TimeItem} is used. The
    // +link{TimeItem.timeFormatter, timeFormatter} for the editor will be picked up from
    // the ListGridField, if specified.
    //
    // @value "datetime" Field value should be a <code>Date</code> instance representing a
    // specific date and time value.  See +link{group:dateFormatAndStorage} for details of the
    // datetime type and how it is represented and manipulated.
    // <P>
    // Dates will be formatted using +link{listGridField.dateFormatter,ListGridField.dateFormatter}
    // if specified, otherwise
    // +link{ListGrid.datetimeFormatter,ListGrid.datetimeFormatter}.
    // If both these attributes are unset, dates are formatted
    // using the standard +link{Date.setShortDatetimeDisplayFormat(),short display format} for
    // datetime values.
    // <P>
    // For editing, by default a +link{DateTimeItem} is used, providing textual date entry plus
    // a pop-up date picker.  The +link{DateItem.dateFormatter, dateFormatter} and
    // +link{DateItem.inputFormat, inputFormat} for the editor will be picked up from the
    // ListGridField, if specified.
    //
    // @value "sequence" Same as <code>text</code>
    //
    // @value "link"     Renders a clickable html link (using an HTML anchor tag: &lt;A&gt;).
    // The target URL is the value of the field, which is also the default display value.  You
    // can override the display value by setting +link{attr:listGridRecord.linkText} or
    // +link{attr:listGridField.linkText}.
    // <P>
    // Clicking the link opens the URL in a new window by default.  To change this behavior,
    // you can set <code>field.target</code>, which works identically to the "target"
    // attribute on an HTML anchor (&lt;A&gt;) tag.  See +link{listGridField.target} for more
    // information.
    // <P>
    // In inline edit mode, this type works like a text field.
    // <P>
    // To create a link not covered by this feature, consider using
    // +link{listGridField.formatCellValue()} along with +link{Canvas.linkHTML()}, or simply
    // +link{listGrid.getCellStyle,styling the field} to look like a link, and providing
    // interactivity via +link{listGridField.recordClick,field.recordClick()}.
    //
    // @value "image"   Renders a different image in each row based on the value of the field.  If
    // this URL is not absolute, it is assumed to be relative to
    // +link{ListGridField.imageURLPrefix} if specified. The size of the image is controlled by
    // +link{attr:listGridField.imageSize}, +link{attr:listGridField.imageWidth},
    // +link{attr:listGridField.imageHeight} (and by the similarly-named global default
    // attributes on the ListGrid itself).
    // <P>
    // You can also specify the following attributes on the field: <code>activeAreaHTML</code>, and
    // <code>extraStuff</code> - these are passed to +link{method:canvas.imgHTML} to generate the
    // final URL.
    // <P>
    // Note if you want to display icons <b>in addition to</b> the normal cell value, you
    // can use +link{listGridField.valueIcons,valueIcons} instead.
    //
    // @value "icon" Shows +link{listGridField.icon,field.icon} in every cell, and also in the
    // header.  Useful for a field that is used as a button, for example, launches a detail
    // window or removes a row.  Implement a +link{listGridField.recordClick,field.recordClick}
    // to define a behavior for the button.
    // <P>
    // NOTE: for a field that shows different icons depending on the field value, see
    // +link{listGridField.valueIcons}.
    // <P>
    // <code>type:"icon"</code> also defaults to a small field width, accommodating just the icon
    // with padding, and to a blank header title, so that the header shows the icon only.
    // <P>
    // +link{listGridField.iconWidth,field.iconWidth} and related properties configure
    // the size of the icon both in the header and in body cells.
    // <P>
    // If you want the icon to appear only in body cells and not in the header, set
    // +link{listGridField.cellIcon,field.cellIcon} instead, leaving field.icon null.
    //
    // @value "binary"  For viewing, the grid renders a 'view' icon (looking glass) followed by a
    // 'download' icon and then the name of the file is displayed in text.  If the user clicks the
    // 'view' icon, a new browser window is opened and the file is streamed to that browser
    // instance, using +link{dataSource.viewFile()}.  For images and other file types with
    // known handlers, the content is typically displayed inline - otherwise the browser will
    // ask the user how to handle the content.  If the download icon is clicked,
    // +link{dataSource.downloadFile()} is used to cause the browser to show a "save" dialog.
    // There is no inline editing mode for this field type.
    //
    // @value "imageFile"   Same as <code>binary</code>
    //
    // @value "summary" Show a calculated summary based on other field values within the
    //  current record. See +link{listGridField.recordSummaryFunction} for more information
    //
    //
    // @see attr:listGridField.type
    // @see type:FieldType
    // @visibility external
    // @example gridsDataTypes
    //<

    //> @attr listGridField.type (ListGridFieldType : "text" : [IR])
    //  ListGrids picks a renderer for the view and edit mode of a field based on this attribute.
    //  See +link{ListGridFieldType} for a summary of how types are rendered.
    //
    //  @see type:ListGridFieldType
    //  @see type:FieldType
    //  @group  appearance
    //  @visibility external
    //<

    //> @attr listGridField.name (identifier : null : [IR])
    // Name of this field.  Must be unique within this ListGrid as well as a valid JavaScript identifier,
    // as specified by ECMA-262 Section 7.6 (the <smartclient>+link{String.isValidID()}</smartclient>
    // <smartgwt>StringUtil.isValidID()</smartgwt> function can be used to test whether
    // a name is a valid JavaScript identifier).
    // <P>
    // The name of field is also the property in each record which holds the value for that
    // field.
    // <P>
    // If a +link{listGrid.dataSource} is specified and the DataSource has a field with the
    // same name, the ListGridField and DataSourceField are merged so that properties on the
    // ListGridField
    //
    // @group data
    // @visibility external
    //<

    //> @attr listGridField.dataPath (string : null : [IRA])
    // dataPath for this field. This property allows the grid to display details of nested data
    // structures in a flat list of columns.
    // @group data
    // @visibility external
    //<

    //> @attr listGridField.title (string : null : [IRW])
    // A title for this field, to display in the header for the field and in other
    // contexts such as the +link{listGrid.canPickFields,menu for picking visible fields}.
    // <P>
    // Note: if you want to use HTML tags to affect the display of the header, you should do so
    // via +link{listGridField.headerTitle} instead so that other places where the title
    // appears in the UI are not affected.  For example, you might set <code>headerTitle</code>
    // to an empty string to suppress the header title on a narrow column, but you would retain
    // the normal title in the <code>title</code> property to avoid a blank menu item in the
    // field picker menu, +link{databoundComponent.editHilites,hilite editor} and other contexts.
    // <P>
    // Alternately you can specify a +link{getFieldTitle()} method on the field to return the
    // HTML for the field title.
    //
    // @group  appearance
    // @see method:listGridField.getFieldTitle()
    // @visibility external
    //<

    //> @attr listGridField.showTitle (boolean : null : [IRW])
    // This property may be set to <code>false</code> to explicitly suppress display of
    // the field title in the column header button for the field.
    // @visibility external
    //<

    //> @method listGridField.getFieldTitle()
    // If your derivation of the field title is more complex than specifying a static string,
    // you can specify a getFieldTitle() method on your field to return the title string.
    // Otherwise you can use the +link{title} attribute on the field to specify the title.
    // <P>
    // You can use +link{listGrid.setFieldProperties,setFieldProperties()} to dynamically
    // update the title.
    //
    // @param viewer (ListGrid) pointer back to the ListGrid
    // @param fieldNum (number) index of this field in the grid's fields array.
    // @return  (string) Field title.
    // @group appearance
    // @see attr:listGridField.title
    // @visibility external
    //<

    //> @attr listGridField.wrap (Boolean : null : [IRW])
    // Should the field title wrap if there is not enough space horizontally to 
    // accommodate it. (Note that this is a soft-wrap - if set the title will wrap
    // at word boundaries).
    // <P>
    // If unset, default behavior is derived from +link{listGrid.wrapHeaderTitles}.
    // <P>
    // Note that this feature is incompatible with +link{listGrid.clipHeaderTitles}, and
    // <code>clipHeaderTitles</code> will be disabled for wrapping fields.
    //
    // @visibility external
    //<

    //> @attr listGridField.hoverWrap (Boolean : null : IRW)
    // This property may be set to customize the <code>wrap</code> attribute for the
    // canvas shown when the mouse hovers over cells in this field. Note that this causes a 
    // soft-wrap - if set, the hover text will wrap at word boundaries.
    // <P>
    // If unset, default behavior is derived from +link{listGrid.headerHoverWrap}.
    // @visibility external
    //<

    //> @attr listGridField.hoverWidth (Integer : null : IRW)
    // Specifies the width of the canvas shown when the mouse hovers over cells in this field. 
    // <P>
    // If unset, default behavior is derived from +link{listGrid.headerHoverWidth}.
    // @visibility external
    //<

    //> @attr listGridField.target (string : "_blank" : IRW)
    // By default, clicking a link rendered by this item opens it in a new browser window.  You
    // can alter this behavior by setting this property.  The value of this property will be
    // passed as the value to the <code>target</code> attribute of the anchor tag used to render
    // the link.
    // <P>
    // If you set listGridField.target to "javascript", the default behavior is to catch and
    // consume mouse-clicks that would result in the link being followed.  Instead, the
    // +link{listGrid.cellClick()} event is fired for the containing cell.
    //
    // @visibility external
    //<

    //> @method listGridField.showIf()
    // An optional +link{group:stringMethods,stringMethod} which if provided, is evaluated to
    // conditionally determine whether this field should be displayed.
    // Evaluated on initial draw, then reevaluated on explicit
    // calls to <code>listGrid.refreshFields()</code> or <code>listGrid.setFields()</code>.
    // <P>
    // Use <code>+link{listGridField.hidden,hidden}:true</code> or <code>showIf:"false"</code>
    // to set a ListGrid field to initially hidden.<br>
    // The user will still be able to show the field via a context menu. 
    // This may be suppressed by setting +link{listGridField.canHide} to false, or by 
    // setting +link{listGrid.canPickFields} to false to suppress the
    // field-picker entirely.
    // <P>
    // Note that explicit calls to +link{listGrid.showField,grid.showField()} or hideField()
    // will wipe out the <code>showIf</code> expression, as will the end user showing and
    // hiding columns via the +link{listGrid.showHeaderContextMenu,header contextMenu}.
    // <P>
    // Also note that fields marked as +link{DataSourceField.detail,detail:true} will be hidden by
    // default even if +link{ListGrid.showDetailFields} is <code>true</code>. To show detail fields
    // inherited from a DataSource, include an explicit field definition for the field and
    // set this property to return <code>true</code>.
    //
    // @param list (ListGrid) A pointer to the listGrid containing the field
    // @param field (ListGridField) the ListGridField object
    // @param fieldNum (integer) the index of the field
    // @return (boolean) whether the field should be shown
    //
    // @group appearance
    // @see method:ListGrid.refreshFields
    // @visibility external
    //<

    //> @attr listGridField.hidden  (Boolean : null : IR)
    // Marks field as initially hidden.<br>
    // The user will still be able to show the field via a context menu. 
    // This may be suppressed by setting +link{listGridField.canHide} to false, or by 
    // setting +link{listGrid.canPickFields} to false to suppress the
    // field-picker entirely.
    // <p>
    // To mark a field as completely hidden (not shown to a user at all, in any component), set
    // +link{DataSourceField.hidden} instead.
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridField.frozen (boolean : null : IR)
    // Whether this field should be "frozen" for the purposes of horizontal scrolling.  See
    // +link{group:frozenFields}.
    // @group frozenFields
    // @visibility external
    //<

    //> @attr listGridField.canFreeze (boolean : null : IR)
    // Whether this field should display freezing/unfreezing options in its header context menu.
    // See +link{group:frozenFields}.
    // @see method:listGrid.getHeaderContextMenuItems()
    // @group frozenFields
    // @visibility external
    //<

    //> @attr listGridField.autoFreeze (boolean : null : IR)
    // Whether this field should be automatically frozen when other fields are frozen.  When
    // true, the field will be automatically frozen to the extreme of the grid.  The
    // automatically generated +link{listGrid.checkboxField, checkbox},
    // +link{listGrid.expansionField, expansion} and
    // +link{listGrid.rowNumberField, rowNumber} fields are examples of fields that specify
    // <code>autoFreeze: true</code>.
    // <P>
    // You can control the position of this field in the array of frozen fields by providing a
    // +link{listGridField.getAutoFreezePosition} implementation.
    // @group frozenFields
    // @visibility external
    //<

    //> @method listGridField.getAutoFreezePosition()
    // When a field has +link{listGridField.autoFreeze,autoFreeze} set to true, developers can
    // implement this method to indicate where in the frozen-fields array this field should
    // appear.
    // <P>
    // Some automatically generated fields, such as
    // +link{listGrid.rowNumberField, rowNumberField},
    // +link{listGrid.expansionField, expansionField} and
    // +link{listGrid.checkboxField, checkboxField}, provide default implementations of this
    // method.
    // @return (number) the index at which this autoFreeze field should appear in the frozen body
    // @group frozenFields
    // @visibility external
    //<

    //> @attr listGridField.canHide (boolean : null : IR)
    // If set to false, this field will be omitted from the column picker that appears in the
    // header context menu when +link{listGrid.canPickFields} is enabled.  This means that the
    // end user will not be able to hide it if it's currently shown, or show it if it's
    // currently hidden.
    // <P>
    // If this property is set to <code>false</code>, and the 
    // +link{listGrid.useAdvancedFieldPicker,advanced field picker} is shown, if the field
    // is +link{hidden}, the field will not show in the list of available fields. If the
    // field is visible, it will be displayed in the list of currently visible fields, but
    // the advanced field picker user interface will disallow hiding it.
    //
    // @see method:listGrid.getHeaderContextMenuItems()
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridField.canDragResize (boolean : null : IR)
    // Whether this field can be dragResized using the mouse.  If unset, the default behavior
    // is governed by +link{listGrid.canResizeFields}.
    // @visibility external
    //<

    //> @attr listGridField.canReorder (boolean : null : IR)
    // Whether this field can be reordered using the mouse.  If unset, the default behavior is
    // governed by +link{listGrid.canReorderFields}.  Note that setting this property to
    // <code>false</code> will lock this field from being moved - that is, the user is
    // prevented from moving this field directly by dragging with the mouse, or by dropping another
    // field onto this field.  However, unless this field is at the extreme edge of the grid,
    // or all fields between it and the extreme edge of the grid are also
    // <code>canReorder: false</code>, (ie, if there are unlocked fields on either side of this
    // field), then it is possible that this locked field may be
    // reordered automatically, as a result of the user dragging one unlocked field onto another
    // unlocked field.
    // @visibility external
    //<

    //> @attr listGridField.ignoreKeyboardClicks (boolean : null : IRW)
    // If the user is navigating through the grid using the keyboard, record click or double click
    // events may be generated via keyboard interactions (see +link{listGrid.generateClickOnSpace},
    // +link{listGrid.generateClickOnEnter}, +link{listGrid.generateDoubleClickOnSpace},
    // +link{listGrid.generateDoubleClickOnEnter} and +link{listGrid.arrowKeyAction}).
    // <P>
    // These synthetic events have both a target row and column.
    // Setting this flag to true ensures that this field will never be considered the target for
    // a keyboard click event.
    // @group events
    // @visibility external
    //<
    
    

    //> @attr listGridField.excludeFromState
    // @include dataSourceField.excludeFromState
    // @see ListGrid.getViewState()
    //<

    // Grid, Group and Record-level summaries
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.showGridSummary (Boolean : null : IR)
    // If +link{listGrid.showGridSummary} is true, should this field show a summary value.
    // If unset, this field will show a summary value in the summary row if an
    // explicit +link{listGridField.summaryFunction} is specified or if a
    // +link{SimpleType.getDefaultSummaryFunction(),default summary function} is defined
    // for the specified field type.
    // @visibility external
    //<

    //> @attr listGridField.showGroupSummary (boolean : null : IR)
    // If +link{listGrid.showGroupSummary} is true, should this field show a summary value
    // in a summary row when the grid is grouped?
    // If unset, this field will show a summary value in the summary row if an
    // explicit +link{listGridField.summaryFunction} is specified or if a
    // +link{SimpleType.getDefaultSummaryFunction(),default summary function} is defined
    // for the specified field type.
    // @visibility external
    //<

    //> @attr listGridField.summaryFunction (SummaryFunction  or Array of SummaryFunction : null : IR)
    // If +link{listGrid.showGridSummary} or +link{listGrid.showGroupSummary} is true,
    // this attribute can be used to specify
    // an explicit +link{type:SummaryFunction} for calculating the summary value to
    // display.
    // <P>
    // If an array of summaryFunctions is specified, they will be executed in turn and the
    // grid will show multiple summary rows at the grid or group level (or both)
    // containing the resulting values.
    // @visibility external
    //<

    //> @attr listGridField.summaryValueTitle (String : null : IR)
    // If +link{listGrid.showGridSummary} or +link{listGrid.showGroupSummary} is true and the
    // +link{listGridField.summaryFunction} is set to <code>"title"</code>, this attribute may be
    // set to a string to display in the group and/or grid summary. If unspecified the
    // +link{listGridField.title} will show up in the summary.
    // @visibility external
    //<

    //> @method listGridField.getGridSummary() [A]
    // If +link{listGrid.showGridSummary} is true, and this method is specified it will be
    // called to generate the summary value to be displayed in the grid summary row. Note that
    // this is called instead of making use of the +link{listGridField.summaryFunction}.
    // <P>
    // As with +link{listGrid.getGridSummary()} this method may return an array of results -
    // in this case each result will show up in a separate row in the +link{listGrid.summaryRow}
    // grid.
    // <P>
    // If this grid is grouped, and +link{listGrid.showGroupSummary} is true, this method
    // will be passed a third parameter - an array of group-level summaries.
    // @param records (Array of ListGridRecord) records for which a summary is being generated
    // @param field (ListGridField) pointer to the field for which summary value is being generated
    // @param [groupSummaries] (Array of objects) If this grid is grouped and
    //  +link{listGrid.showGridSummary} is specified, this parameter contains an array of already-
    //  calculated summary values for each group in the grid. Each element in this array will
    //  be an object containing calculated summary values for each field in the grid, as well as
    //  a specified groupValue and groupName, allowing the developer to determine which group this
    //  summary value comes from
    // @return (any) summary value to display.
    // @visibility external
    //<

    //> @attr listGridField.formatGridSummary (stringMethod : null : IR)
    // Optional stringMethod to format the summary value displayed
    // in the +link{listGrid.showGridSummary,grid summary}.
    // Takes a single parameter <code>value</code> and should return the formatted version
    // of that value. If specified this will be applied instead of any formatting logic applied
    // via +link{listGridField.formatCellValue()}, +link{listGrid.formatCellValue()}, etc.
    // <P>
    // Note that for fields with a specified summary function of "count", if no custom formatting
    // is applied, we default to formatting the count value by appending
    // <code>field.pluralTitle</code> if defined, otherwise <code>field.title</code> to the
    // numeric count value returned by the standard count function. To change this behavior for
    // such fields, specify an explicit 'formatGridSummary' and/or 'formatGroupSummary' method
    // @visibility external
    //<

    //> @method listGridField.getGroupSummary() [A]
    // If +link{listGrid.showGroupSummary} is true, and this method is specified it will be
    // called to generate the field summary value to be displayed for each group level summary row.
    // Note that this is called instead of making use of the +link{listGridField.summaryFunction}.
    // <P>
    // This method may return an array of results - in this case the group will show multiple summary
    // rows, with each entry in the array showing up in a different record.
    //
    // @param records (Array of ListGridRecord) records for which a summary is being generated
    //  (so all records in the group).
    // @param field (ListGridField) pointer to the field for which summary value is being generated
    // @param [groupNode] (object) object with specified groupValue and groupName for this group
    // @return (any) summary value to display
    // @visibility external
    //<

    //> @attr listGridField.formatGroupSummary (stringMethod : null : IR)
    // Optional stringMethod to format the group level summary values for this field displayed via
    // +link{listGrid.showGroupSummary}.
    // Takes a single parameter <code>value</code> and should return the formatted version
    // of that value.  If specified this will be applied instead of any formatting logic applied
    // via +link{listGridField.formatCellValue()}, +link{listGrid.formatCellValue()}, etc.
    // <P>
    // Note that for fields with a specified summary function of "count", if no custom formatting
    // is applied, we default to formatting the count value by appending
    // <code>field.pluralTitle</code> if defined, otherwise <code>field.title</code> to the
    // numeric count value returned by the standard count function. To change this behavior for
    // such fields, specify an explicit 'formatGridSummary' and/or 'formatGroupSummary' method
    // @visibility external
    //<

    //> @method listGridField.getRecordSummary() [A]
    // Only applies to +link{listGridFieldType,summary-type} fields. If specified, this
    // method will be called to generate the record summary value to be displayed for each row
    // in this field.  When this method is called, current values for other 
    // +link{listGridFieldType,summary-type} fields have not yet been stored on the record, but
    // are accessible via +link{listGrid.getRecordSummary()}.
    // <P>
    // Note that if specified, this is called instead of making use of the
    // +link{listGridField.recordSummaryFunction}.
    // <P>
    // If +link{listGrid.showGridSummary} or +link{listGrid.showGroupSummary} is true, this
    // field's value in the summary row[s] will still be calculated by calling this method.
    // In this case, the record object passed in will contain summary values for each field.
    // If custom handling is required for this case, it may be detected by checking the
    // record object's +link{listGridRecord.isGroupSummary} and +link{listGridRecord.isGridSummary}
    // attributes.
    // @param record (ListGridRecord) record for which a summary is being generated
    // @param field (ListGridField) this field
    // @param grid (ListGrid) the grid
    // @return (any) summary value to display
    // @visibility external
    //<

    //> @attr listGridField.recordSummaryFunction (RecordSummaryFunction : null : IR)
    // Only applies to fields of type <code>"summary"</code>.
    // Fields of this type will display a calculated value based on the other field values
    // within the current record.
    // <P>
    // This attribute specifies how the summary field value will be calculated. See
    // +link{type:RecordSummaryFunction} for valid options.
    // <P>
    // A subset of the ListGrid's fields will be passed to the RecordSummaryFunction.
    // Which fields to include is determined based on +link{listGridField.includeInRecordSummary}
    // <P>
    // If +link{listGrid.showGridSummary} or +link{listGrid.showGroupSummary} is true, this
    // field's value in the summary row[s] will still be calculated by calling this method.
    // In this case, the record object passed in will contain summary values for each field.
    // If custom handling is required for this case, it may be detected by checking the
    // record object's +link{listGridRecord.isGroupSummary} and +link{listGridRecord.isGridSummary}
    // attributes.
    // @visibility external
    //<

    //> @attr listGridField.partialSummary (boolean : null : IR)
    // Only applies to fields of type <code>"summary"</code>.
    // This attribute is set on a summary field, when calculating the summary value from
    // some record, the summary function will only be passed the fields before this summary field.
    // This may be useful for displaying running totals across a record.
    // <P>
    // Note that this feature would typically be used with
    // +link{listGrid.canReorderFields,canReorderFields:false}
    // @visibility external
    //<

    //> @attr listGridField.includeInRecordSummary (boolean : null : IR)
    // If a listGrid is showing a field of type summary, should this field be passed to the
    // recordSummaryFunction when calculating the summary value to display.
    // If unset, fields are included if they are of type "integer" or "float" only (since most
    // summary functions perform numeric calculations). See also
    // +link{listGridField.includeInRecordSummaryFields}.
    // @visibility external
    //<

    //> @attr listGridField.includeInRecordSummaryFields (array of fieldNames : null : IR)
    // If this listGrid has any fields of type <code>"summary"</code> and
    // this field will be +link{listGridField.includeInRecordSummary,included} in summary calculations
    // by default, this attribute provides an opportunity to explicitly specify which summary fields
    // the record should be displayed in.
    // <P>
    // Specified as an array of fieldNames. If set, this field value will only be included for
    // record summary value calculations for summary fields who's name is included in this array.
    // @visibility external
    //<

    //> @attr listGridField.applyAfterSummary (Boolean : null : IRW)
    // If +link{listGridField.userFormula} is set for this field, and this grid is showing
    // +link{listGrid.showGroupSummary,group summaries} or a
    // +link{listGrid.showGridSummary,grid summary}, this property determines what field value
    // should be present in those summary rows. Should the field apply the user-formula to the
    // calculated summary row, or should it apply a standard grid or group summary to the
    // user-formula values displayed in the grid?
    // <P>
    // Default behavior may be specified at the grid level via +link{listGrid.applyFormulaAfterSummary}
    // @visibility external
    //<

    // Header button icons
    // ---------------------------------------------------------------------------------------
    // Include all relevant docs from StatefulCanvas

    //> @attr listGridField.icon (SCImgURL: null : [IR])
    // Optional icon to show next to the title for this field.
    // Should be set to a URL to an image. Relative paths will be evaluated starting at
    // the imgDir of this component. This URL is partial - it may be updated to indicate
    // the current disabled (etc) state of the field.
    // <p>
    // If +link{listGridField.type,field.type} is set to "icon", this icon will also be shown
    // in every cell of this field - see also +link{listGridField.cellIcon,field.cellIcon}.
    // <p>
    // To change this property after fields have been passed to +link{listGrid.setFields()},
    // use +link{listGrid.setFieldIcon()}.
    //
    // @visibility external
    //<

    //> @attr listGridField.iconSize (integer : null : [IR])
    // If +link{listGridField.icon} is specified, this property can be used to specify the
    // size of the icon to be displayed in the ListGrid header button.
    // (See +link{StatefulCanvas.iconSize})
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.iconWidth (integer : null : [IR])
    // If +link{listGridField.icon} is specified, this property can be used to specify the
    // width of the icon to be displayed in the ListGrid header button.
    // (See +link{StatefulCanvas.iconWidth})<br>
    // If this field is editable, and +link{ListGridField.editorIconWidth} is unset, this
    // property will be passed onto the editors for this field as +link{FormItem.iconWidth},
    // which will effect the default size for +link{ListGridField.icons, icons} displayed
    // in the editor.
    // @see listGridField.icon
    // @see listGridField.icons
    // @visibility external
    //<

    //> @attr listGridField.iconHeight (integer : null : [IR])
    // If +link{listGridField.icon} is specified, this property can be used to specify the
    // height of the icon to be displayed in the ListGrid header button.
    // (See +link{StatefulCanvas.iconHeight})<br>
    // If this field is editable, and +link{ListGridField.editorIconHeight} is unset, this
    // property will be passed onto the editors for this field as +link{FormItem.iconWidth},
    // which will effect the default size for +link{ListGridField.icons, icons} displayed
    // in the editor.
    // @see listGridField.icon
    // @see listGridField.icons
    // @visibility external
    //<

    //> @attr listGridField.iconOrientation (string : "left" : [IR])
    // If this field is showing an icon, should it appear to the left or right of the title?<br>
    // Valid options are <code>"left"</code> or <code>"right"</code>
    // @see listGridField.icon
    // @visibility external
    //<
    // iconOrientation JS doc not included from statefulCanvas as that refers to
    // setIconOrientation(), and we don't have an exposed way to get at the ListGrid field
    // header button at runtime.

    //> @attr listGridField.iconSpacing (int : 6 : [IR])
    // @include statefulCanvas.iconSpacing
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showDisabledIcon (Boolean : true : [IR])
    // @include statefulCanvas.showDisabledIcon
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showRollOverIcon (Boolean : false : [IR])
    // @include statefulCanvas.showRollOverIcon
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showFocusedIcon (Boolean : false : [IR])
    // @include statefulCanvas.showFocusedIcon
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showDownIcon (Boolean : false : [IR])
    // @include statefulCanvas.showDownIcon
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showSelectedIcon (Boolean : false : [IR])
    // @include statefulCanvas.showSelectedIcon
    // @see listGridField.icon
    //  @visibility external
    //<

    //> @attr listGridField.cellIcon (SCImgURL : null : [IR])
    // For a field of type:"icon" only, set the icon that appears in body cells.  Unless
    // setting +link{listGridField.icon,field.icon}, setting field.cellIcon will not show an
    // icon in the header.
    // <p>
    // To change this property after fields have been passed to +link{listGrid.setFields()},
    // use +link{listGrid.setFieldCellIcon()}.
    //
    // @visibility external
    //<

    //> @attr listGridField.showFileInline (boolean : null : [IR])
    // For a field of type:"imageFile", indicates whether to stream the image and display it
    // inline or to display the View and Download icons.
    //
    // @visibility external
    //<

    //> @attr listGridField.format (FormatString : null : IR)
    // +link{FormatString} for numeric or date formatting.  See +link{dataSourceField.format}.
    // @group exportFormatting
    // @visibility external
    //<

    //> @attr listGridField.exportFormat (FormatString : null : IR)
    // +link{FormatString} used during exports for numeric or date formatting.  See
    // +link{dataSourceField.exportFormat}.
    // @group exportFormatting
    // @visibility external
    //<

    // FormItem icons
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.icons (Array of FormItemIcon Properties: null : [IRA])
    // If this field is editable, this property can be used to specify
    // +link{FormItem.icons, icons} to be displayed in the editors displayed for this field
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.editorIconWidth (number : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconWidth}.<br>
    // If this property unset, the iconWidth property from the editor can be picked up from
    // +link{listGridField.iconWidth} instead.
    // @see listGridField.icons
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.editorIconHeight (number : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconHeight}.<br>
    // If this property unset, the iconHeight property from the editor can be picked up from
    // +link{listGridField.iconHeight} instead.
    // @see listGridField.icons
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.defaultIconSrc (string : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.defaultIconSrc}.
    // @see listGridField.icons
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.iconPrompt (string : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconPrompt}.
    // @see listGridField.icons
    // @group editing
    // @visibility internal
    //<

    //> @attr listGridField.iconHSpace (string : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconHSpace}.
    // @see listGridField.icons
    // @group editing
    // @visibility internal
    //<

    //> @attr listGridField.iconVAlign (string : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconVAlign}.
    // @see listGridField.icons
    // @group editing
    // @visibility external
    //<

    // editor picker icon
    
    //> @attr listGridField.showPickerIcon (boolean : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.showPickerIcon}.
    // @group editing
    // @visibility pickerIcon
    //<

    //> @attr listGridField.pickerIconSrc (string : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.pickerIconSrc}.
    // @group editing
    // @visibility pickerIcon
    //<

    //> @attr listGridField.pickerIconWidth (integer : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.pickerIconWidth}.
    // @group editing
    // @visibility pickerIcon
    //<

    //> @attr listGridField.pickerIconHeight (integer : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.pickerIconHeight}.
    // @group editing
    // @visibility pickerIcon
    //<

    // Summary Title
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.summaryTitle (string : null : [IRWA])
    // Optional long summary title for this field, provided in addition to
    // +link{listGridField.title}. This gives the developer an option to use a very short,
    // or empty title for the ListGrid column (where space may be a factor), but have a longer
    // value available to be used elsewhere.
    // <p>
    // By default this value will be used for the title of the context-menu item
    // for showing/hiding the listGrid field when the user right-clicks on the ListGrid header.
    //
    // @group appearance
    // @see attr:listGridField.title
    // @deprecated Rather than customizing the summaryTitle developers should typically use
    //  the +link{listGridField.headerTitle} attribute to show a different
    //  title in the column header button than the title used elsewhere.
    // @visibility external
    //<

    //> @method listGridField.getSummaryTitle() [A]
    // Optional string method to return a long summary title for this field, if a dynamic
    // summary title is required for this field.
    //
    // @param viewer (listGrid) pointer back to the ListGrid
    // @param field (listGridField) pointer to the field object
    // @group appearance
    // @see attr:listGridField.summaryTitle
    // @see attr:listGridField.title
    // @deprecated Rather than customizing the summaryTitle developers should typically use
    //  the +link{listGridField.headerTitle} attribute to show a different
    //  title in the column header button than the title used elsewhere.
    // @visibility external
    //<

    // Header Appearance
    // ---------------------------------------------------------------------------------------

	//> @attr listGridField.width (Number or String : "*" : [IRW])
	// The width of this field, specified as either an absolute number of pixels,
	// a percentage of the remaining space like "25%", or "*" to split remaining space among
    // all fields which have "*". <P>
    // Caution: stretch sizes are currently ignored if the field is being autofitted
    // (see +link{listGrid.autoFitFieldWidths}), unless +link{listGrid.showHeader} is false.
    // <P>
    // Note: if autofitting is active for a field, the width will default to the numerical
    // autofit width for that field (so it will not be stretched larger to fill available
    // space).  Otherwise, if not autofitting, the width will default to "*" causing it to be
    // automatically stretched.
    // <P>
    // See also +link{listGrid.minFieldWidth} to ensure no field goes below a minimum size.
    // <P>
    // Use +link{listGrid.resizeField} to programmatically change field width after creation.
    // <P>
    // Use +link{listGrid.getFieldWidth} to access the rendered field width after
    // the ListGrid is drawn.
    //
    // @see ListGrid.autoFitFieldWidths
    // @see listGridField.minWidth
    // @see listGridField.maxWidth
	// @group appearance
	// @visibility external
	//<

	//> @attr listGridField.minWidth (Number : null : [IR])
	// When +link{listGrid.showHeader} is false and a field is subject to autofitting (see 
    // +link{listGrid.autoFitFieldWidths}), sets the minimum width of the field.  The actual
    // allowed minimum will be the maximum of:<ul>
    // <li> this property,
    // <li> +link{width} (if a number),
    // <li> the aufofit value determined by the widest value content in this field's column
    // <li> +link{listGrid.minFieldWidth}
    // </ul>
	// @group appearance
    // @see listGridField.width
	// @visibility external
	//<

	//> @attr listGridField.maxWidth (Number : null : [IR])
	// When +link{listGrid.showHeader} is false and a field is subject to autofitting (see
    // +link{listGrid.autoFitFieldWidths}), sets the maximum width of the field.  The actual
    // allowed minimum will be the larger of this property and +link{minWidth}.  (That is,
    // +link{minWidth} dominates this property.)
	// @group appearance
    // @see listGridField.width
	// @visibility external
	//<
    
    //> @attr   listGridField.align (Alignment : null : [IRW])
    // Horizontal alignment for field's column header: "left", "right"
    // or "center". Applied to the column header title and cells by default. A separate
    // alignment for cells can be specified via +link{listGridField.cellAlign}.<br>
    // If null, values are left-aligned. If this field is editable, the
    // alignment of cells in the body will also be reflected in any editors for the field.
    //  @group  appearance
    //  @visibility external
    //<

    //> @attr listGridField.headerBaseStyle (CSSClass : null : [IRW])
    // Custom base style to apply to this field's header button instead of
    // +link{listGrid.headerBaseStyle}.<br>
    // Note that depending on the header button constructor, you may have to override
    // +link{listGridField.headerTitleStyle} as well.
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridField.headerTitleStyle (CSSClass : null : [IRW])
    // Custom titleStyle to apply to this field's header button instead of
    // +link{listGrid.headerTitleStyle}.<br>
    // Note that this will typically only have an effect if
    // +link{listGrid.headerButtonConstructor} is set to +link{class:StretchImgButton} or a subclass
    // thereof.
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridField.headerTitle (string : null : IR)
    // Optional title for the header button for this field. If specified this will be
    // displayed in the header button instead of +link{listGridField.title} or
    // +link{listGridField.name}. Set to an empty string to suppress the title in the
    // header button entirely.
    // @group appearance
    // @see listGridField.title
    // @visibility external
    //<



    // Header Spans
    // ---------------------------------------------------------------------------------------
    // - known limitations
    //   - can't reorder a column to before or after a spanned set of columns, if the spanned
    //   columns are at the start or end of the visible fields.
    //   - several uses of this.Super(), instead of the faster this.invokeSuper() approach.
    //   Attempt to use invokeSuper() failed, likely because the header is not a discrete
    //   class, but an instance of Toolbar, and my guess (Alex) is that Class.invokeSuper()
    //   doesn't handle this particular case.


    //> @attr listGrid.headerSpans (Array of HeaderSpan : null : IRW)
    // Header spans are a second level of headers that appear above the normal ListGrid headers,
    // spanning one or more listGrid fields in a manner similar to a column-spanning cell in an
    // HTML table.
    // <P>
    // A header span can be created by simply naming the fields the header should span.  The
    // example below creates a headerSpan that spans the first two fields of the ListGrid.
    // <smartclient>
    // <pre>
    //    isc.ListGrid.create({
    //        headerHeight:40,
    //        fields : [
    //            { name:"field1" },
    //            { name:"field2" },
    //            { name:"field3" }
    //        ],
    //        headerSpans : [
    //            {
    //                fields: ["field1", "field2"],
    //                title: "Field 1 and 2"
    //            }
    //        ]
    //    });
    // </pre>
    // </smartclient>
    // <smartgwt>
    // <pre>
    //      ListGrid grid = new ListGrid();
    //      grid.setHeaderHeight(40);
    //      grid.setFields(new ListGridField[] {
    //          new ListGridField("field1"),
    //          new ListGridField("field2"),
    //          new ListGridField("field3")
    //      });
    //      grid.setHeaderSpans(new HeaderSpan[] {
    //          new HeaderSpan("Field 1 and 2", new String[] {"field1", "field2"})
    //      });
    // <pre>
    // </smartgwt>
    // Header spans can be nested, allowing fields to be grouped by multiple levels of
    // granularity. See +link{headerSpan.spans} for further information on nesting spans.
    // <P>
    // Header spans will automatically react to resizing of the headers they span, and will be
    // hidden automatically when all of the spanned fields are hidden.
    // <P>
    // Header spans appear in the +link{listGrid.header,header} area of the ListGrid, sharing space
    // with the existing headers, so it's typical to set +link{listGrid.headerHeight} to
    // approximately double its normal height when using headerSpans, or if using nested header
    // spans, the default header height multiplied by the number of levels of header spans to be
    // shown.
    // <P>
    // See +link{headerSpan} for many properties that allow the control of the appearance of
    // headerSpans.
    // <smartclient>
    // Note that headerSpans are created via the +link{AutoChild} pattern, hence
    // you can change the SmartClient component being used, or any of its properties.
    // </smartclient>
    // <P>
    // Neither headerSpans themselves nor the fields within them may be drag reordered, but other
    // unspanned headers may be.
    // <P>
    // A span can only span adjacent fields - if a span is defined and the spanned fields don't
    // sit next to each other in the specified fields array, the fields array will be automatically
    // reordered to match the order specified in the span's +link{headerSpan.fields} array.
    // <P>
    // Note that headerSpans primarily provide a visual cue for grouping multiple headers
    // together.  If you have an OLAP, data "cube" or multi-dimensional data model, the
    // +link{CubeGrid} component is the right choice.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr listGrid.headerSpanHeight (integer : null : IR)
    // Default height for a +link{listGrid.headerSpans,headerSpan} with no height specified.
    // <P>
    // If <code>headerSpanHeight</code> is not specified (the default), headerSpans will be 1/2
    // of +link{listGrid.headerHeight}.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr listGrid.headerSpanVAlign (vAlign : "center" : IR)
    // Default alignment for +link{listGrid.headerSpans,headerSpans} with no
    // +link{headerSpan.valign} specified.
    //
    // @group headerSpan
    // @visibility external
    //<
    headerSpanVAlign: "center",

    //> @attr listGrid.unspannedHeaderVAlign (vAlign : null : IR)
    // When +link{listGrid.headerSpans,headerSpans} are in use, this property sets the default
    // vertical alignment for for fields which do <b>not</b> have a headerSpan.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr listGrid.headerSpanConstructor (SCClassName : null : IR)
    // +link{SCClassName,SmartClient Class} to use for headerSpans.  Typically a +link{Button} or
    // +link{StretchImgButton} subclass.
    // <P>
    // If unset, headerSpans will be created using the +link{listGrid.headerButtonConstructor}.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr listGrid.headerSpan (MultiAutoChild StatefulCanvas : null : IR)
    // +link{listGrid.headerSpans,headerSpans} are created via the +link{AutoChild} pattern, hence
    // <code>headerSpanConstructor</code>, <code>headerSpanDefaults</code> and
    // <code>headerSpanProperties</code> are valid.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @object HeaderSpan
    // A header span appears as a second level of headers in a ListGrid, spanning one or more
    // ListGrid columns and their associated headers.
    // <P>
    // See +link{listGrid.headerSpans}.
    // <P>
    // In addition to the properties documented here, all other properties specified on the
    // headerSpan object will be passed to the +link{Class.create,create()} method of the
    // +link{listGrid.headerSpanConstructor}.  This allows you to set properties such as
    // +link{button.baseStyle} or +link{stretchImgButton.src} directly in a
    // <code>headerSpan</code>.
    //
    // @group headerSpan
    // @treeLocation Client Reference/Grids/ListGrid
    // @visibility external
    //<

    //> @attr headerSpan.name (identifier : null : IR)
    // Name for this headerSpan, for use in APIs like +link{listGrid.setHeaderSpanTitle()}.
    // <P>
    // Name is optional, but if specified, must be unique for this ListGrid (but not globally
    // unique) as well as a valid JavaScript identifier, as specified by ECMA-262 Section 7.6
    // (the <smartclient>+link{String.isValidID()}</smartclient><smartgwt>StringUtil.isValidID()</smartgwt>
    // function can be used to test whether a name is a valid JavaScript identifier).
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.fields (Array of String : null : IR)
    // List of fields that this header spans.  Fields should be identified by their value for
    // +link{listGridField.name}.
    // <P>
    // Developers may define multiple levels of header-spans by specifying +link{headerSpan.spans}
    // however a span cannot be specified with both <code>fields</code> and <code>spans</code>.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.spans (Array of HeaderSpan : null : IR)
    // This property allows developer to "nest" header spans, grouping fields together by
    // multiple layers of granularity.
    // <P>
    // For example a group of fields could be nested within two layers of header spans as follows:
    // <smartclient>
    // <pre>
    // { title:"Europe", spans:[
    //      {title:"France", fields:["Paris", "Lyon"]},
    //      {title:"UK", fields:["London", "Glasgow"]},
    //      {title:"Spain", fields:["Barcelona"]}
    //  ]
    // }
    // </pre>
    // </smartclient>
    // <smartgwt>
    // <pre>
    //      HeaderSpan france = new HeaderSpan("France", new String[] {"Paris", "Lyon"});
    //      HeaderSpan uk = new HeaderSpan("UK", new String[] {"London", "Glasgow"});
    //      HeaderSpan spain = new HeaderSpan("Spain", new String[] {"Barcelona"});
    //
    //      HeaderSpan europe = new HeaderSpan();
    //      europe.setTitle("Europe");
    //      europe.setSpans(france, uk, spain);
    // </pre>
    // </smartgwt>
    // Note that a span definition can not include both <code>spans</code>
    // and +link{headerSpan.fields,fields}.
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.title (String : null : IR)
    // A title for this headerSpan, to display in the headerSpan button for this headerSpan
    // and in other contexts such as the +link{listGrid.canPickFields,menu for picking visible fields}.
    //
    // Note: if you want to use HTML tags to affect the display of the header, you should do so
    // via +link{headerSpan.headerTitle} instead so that other places where the title
    // appears in the UI are not affected.  Refer to discussion at +link{listGridField.title}.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.headerTitle (String : null : IR)
    // Optional title for the headerSpan button for this headerSpan. If specified this will be
    // displayed in the headerSpan button instead of +link{headerSpan.title}. Set to an empty
    // string to suppress the title in the header button entirely.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.headerBaseStyle (CSSClass : null : [IRW])
    // Custom base style to apply to the header button created for this span instead
    // of +link{listGrid.headerBaseStyle}.
    // <P>
    // Note that depending on the header button constructor, you may have to specify
    // +link{headerSpan.headerTitleStyle} as well.
    // @group appearance
    // @visibility external
    //<

    //> @attr headerSpan.headerTitleStyle (CSSClass : null : [IRW])
    // Custom titleStyle to apply to the header button created for this span instead of
    // +link{listGrid.headerTitleStyle}.
    // <p>
    // Note that this will typically only have an effect if
    // +link{listGrid.headerButtonConstructor} is set to +link{class:StretchImgButton} or a subclass
    // thereof.
    // @see headerSpan.headerBaseStyle
    // @group appearance
    // @visibility external
    //<

    //> @attr headerSpan.height (integer : null : IR)
    // Height of this headerSpan.  Defaults to +link{listGrid.headerSpanHeight}.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.valign (VerticalAlignment: null : IR)
    // Vertical alignment of the title of this headerSpan.
    // <P>
    // Defaults to listGrid.headerSpanVAlign if unset.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.align (Alignment: "center" : IR)
    // Horizontal alignment of the title of this headerSpan.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr listGrid.showTreeColumnPicker (Boolean : true : IR)
    // When +link{listGrid.headerSpans} are in use, whether to show a hierarchical column picker
    // that includes both headerSpans and normal headers, with normal headers indented under
    // headerSpans similarly to how a +link{TreeGrid} displays a Tree.
    // <P>
    // If <code>showTreeColumnPicker</code> is false, no column picker will be shown on the
    // headerSpan itself, and the column picker for a clicked on a normal field header will include
    // only normal fields.
    //
    // @group headerSpan
    // @visibility external
    //<
    showTreeColumnPicker: true,


    // Cell Styling
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.cellAlign (Alignment : null : [IRW])
    // Horizontal alignment for cells in this field's column: "left", "right"
    // or "center".<br>
    // If null, alignment is derived from +link{ListGridField.align}. If this field is editable,
    // the alignment of cells in the body will also be reflected in any editors for the field.
    //  @group  appearance
    //  @visibility external
    //<

    //> @attr listGrid.reverseRTLAlign (Boolean : true : [IRW])
    // If a page is rendered in +link{isc.Page.isRTL(),RTL mode}, should
    // cell alignments specified +link{listGridField.cellAlign} be reversed (so
    // an <code>align:"right"</code> field will have content aligned on the left and
    // vice versa)?
    // <P>
    // This is true by default to match user expectation that text flows from
    // start-to end and is aligned with the start of text flow (left in LTR mode,
    // right in RTL mode) by default. May be set to false to have the specified
    // alignments be taken literally in RTL mode.
    // @group RTL
    // @visibility external
    //<
    reverseRTLAlign:true,


    //> @attr   listGridField.baseStyle (CSSClass : null : [IRW])
    //  Custom base style to apply to all cells in this field instead of +link{ListGrid.baseStyle}
    //  To override the baseStyle at the row level, use
    //  +link{ListGrid.recordBaseStyleProperty, record[listGrid.recordBaseStyleProperty]}
    //  instead.
    // @see ListGrid.recordBaseStyleProperty
    // @group appearance
    // @visibility external
    // @example gridCells
    //<

    // Sorting (per field)
    // ---------------------------------------------------------------------------------------

    //> @attr   listGridField.canSort (Boolean : true : [IRW])
    //  Enables or disables sorting by this column. If false, interactive
    //  sorting via header-clicks or menu-items will have no effect, but direct scripted calls
    //  to +link{ListGrid.sort, sort()} or +link{ListGrid.setSort, setSort()} will work as
    //  expected.
    //  @group  sorting
    //  @see    method:ListGrid.sort
    //  @see    attr:ListGrid.canSort
    //  @visibility external
    //<

    //> @attr listGridField.sortDirection (SortDirection : null : [IRW])
    // Specifies the default sorting direction for this column. If specified on the
    // +link{listGrid.sortField,default sort field} for the listGrid, sorting occurs
    // automatically, otherwise this will be the default direction when the user clicks the
    // field header, or calls +link{ListGrid.sort()} without specifying an explicit sort
    // direction.
    // <P>
    // Overrides ListGrid.sortDirection
    //  @group  sorting
    //  @see type:SortDirection
    //  @visibility external
    //<

    //> @method listGridField.sortNormalizer() (A)
    // Optional function to return the value that should be used when sorting this field.
    // <P>
    // Note that, if the dataset exceeds +link{ListGrid.dataPageSize} and hence paging is
    // introduced, the grid relies on the server to provide sorting, and the sortNormalizer
    // will no longer be called.
    // <P>
    // For custom sort orders that can be executed both client and server, consider
    // +link{dataSourceField.sortByField}.
    //
    // @param recordObject    (object)    record to normalize
    // @param fieldName       (string)    name of the field on which sorting occurred
    // @param context (ListGrid) A pointer back to the list grid displaying this field will
    //   be available as the <code>context</code> argument. Note that you can also get a pointer
    //   to the field definition object by calling <code>context.getField(fieldName)</code>
    //  @return (any)   normalized value for sorting
    //  @group  sorting
    //  @visibility external
    //  @example dataTypes
    //<

    // Editing (per field)
    // ----------------------------------------------------------------------------------------

    //> @attr listGridField.canEdit (boolean : null : [IRW])
    // Can this field be edited?  May be overridden by setting the 'canEdit' property at the
    // listGrid level. If not explicitly set and this grid is bound to a dataSource, the
    // +link{listGrid.canEditFieldAttribute} may be used to set default editability at the field level.
    // <p>
    // For more dynamic control over whether fields can be edited, see
    // +link{listGrid.canEditCell}.
    //
    // <smartgwt><P>Note that this property may validly be <code>null</code> as a distinct state
    // from <code>false</code>.  See +link{listGrid.fieldIsEditable()} for an API that will
    // always return <code>true</code> or <code>false</code> and give a definitive answer as to
    // whether editing is possible.</smartgwt>
    //
    // @group  editing
    // @see attr:listGrid.canEdit
    // @see attr:listGrid.recordEditProperty
    // @see method:listGrid.canEditCell
    // @visibility external
    // @example disableEditing
    //<


    //> @attr listGridField.alwaysShowEditors (boolean : null : [IRW])
    // When this attribute is set, editors will be rendered into every row of the grid for
    // this field, rather than showing up in a single record at a time.
    // This attribute is only valid when +link{listGrid.editByCell} is false
    // @group editing
    //<
    


    //> @attr listGridField.defaultValue (any : null : [IRW])
    // If this field +link{listGridField.canEdit, can be edited}, this property can be used to
    // specify a default value for this field's editor when adding new rows to the grid.
    // @see listGrid.startEditingNew()
    // @group editing
    // @visibility external
    //<

    //> @method listGridField.defaultDynamicValue()
    // If this field +link{listGridField.canEdit, can be edited}, this property can be used to
    // set a dynamic default value which will show up in editors for this field.
    // Will be applied to the editor for the field as +link{FormItem.defaultDynamicValue}
    //
    // @param   item    (FormItem)  The editor for the cell itself (also available as "this").
    //                              Note that in addition to the standard FormItem APIs available
    //                              on the editor, it also has:<br>
    //                              - a pointer back to the containing listGrid
    //                              [<code>item.grid</code>]<br>
    //                              - the colNum being edited [<code>item.colNum</code>]<br>
    //                              - the rowNum being edited [<code>item.rowNum</code>]
    // @param   form    (DynamicForm) the managing DynamicForm instance
    // @param   values  (Object)      the current set of values for the form as a whole
    // @group editing
    // @visibility external
    //<

    //> @attr   listGridField.enterKeyEditAction (EnterKeyEditAction : "done" : [IRW])
    // What to do when a user hits enter while editing this field?<br>
    // Overrides the <code>enterKeyEditAction</code> as specified at the listGrid level while
    // focus is in this field.
    //  @group  editing
    //  @visibility external
    //<

    //> @attr   listGridField.escapeKeyEditAction (EscapeKeyEditAction : "cancel" : [IRW])
    // What to do when a user hits escape while editing this field?<br>
    // Overrides the <code>escapeKeyEditAction</code> as specified at the listGrid level while
    // focus is in this field.
    //  @group  editing
    //  @visibility external
    //<

    
    //> @attr   listGridField.nextTabColNum (number : null : [IRWA])
    // If specified, when the user hits tab while editing this field, editing will move to the
    // specified colNum in the next row (or the first editable field after it), rather than the
    // next editable field in this row.
    //  @group  editing
    //  @visibility advancedInlineEdit
    //<

    //> @attr   listGridField.previousTabColNum (number : null : [IRWA])
    // If specified, when the user hits shift+tab while editing this field, editing will move
    // to the specified colNum in the previous row (or the first editable field before it),
    // rather than the previous editable field in this row.
    //  @group  editing
    //  @visibility advancedInlineEdit
    //<

    //> @attr   listGridField.editorType (FormItem className : null : [IRWA])
    //      Name of form item class to use for the form item created to edit this field.
    //      (Only used if this field is editable).<br>
    //      Note: If this is not specified, the edit-form item type may be derived from the
    //      <code>editorType</code> property, typically inherited from datasource fields, or
    //      from the <code>type</code> of the field (showing the appropriate form item for
    //      the data-type). See the +link{group:editing} overview for more on editing ListGrid
    //      fields.
    //  @group  editing
    //  @see attr:listGrid.canEdit
    //  @visibility external
    //  @example customEditors
    //<
    // link to editing group documentation included as that describes the additional
    // "rowNum", "colNum" and "grid" properties stored on the editor.
    
    //> @attr   listGridField.editorProperties (FormItem properties : null : [IRWA])
    // Properties to apply the the form item created to edit this field. (Only used if
    // this field is editable).
    // <P>
    // For example, if you have a field "shoeSize" with +link{dataSourceField.editorType} set
    // to "SpinnerItem" in order to use a SpinnerItem as your field editor, and you want to pass the
    // +link{spinnerItem.step} property to the created SpinnerItem:
    // <pre>
    //    fields : [
    //        { name:"shoeSize", editorType:"SpinnerItem",
    //          editorProperties : { step:0.5 } },
    //        ... other fields ...
    //    ]
    // </pre>
    //
    // @group editing
    // @visibility external
    // @example customEditors
    //<

    //> @attr listGridField.initialValue (any : null : IR)
    // In an editable ListGrid, initial value for this field when the user begins editing a new
    // record.
    // <p>
    // <code>initialValue</code> applies only if a new record is created by end user action (such
    // as navigating past the end of the data when +link{listGrid.listEndEditAction} is "next") or
    // by a call to +link{listGrid.startEditingNew()} that <i>does not specify the
    // <code>initialValues</code></i> argument.
    //
    // @group editing
    // @visibility external
    //<
    
	//> @attr   listGrid.modalEditing (boolean : null : [IRWA])
	//      If this property is true, any mouse click outside of the open cell editors
    //      will end editing mode, hiding the cell editors and saving any changes to those
    //      cell values.
    // @group  editing
    // @visibility external
    // @example modalEditing
    //<

    //> @method listGridField.editorEnter (A)
    // Callback fired when the user first starts editing a cell.
    // <P>
    // This callback is typically used to establish dynamic default values via
    // +link{listGrid.setEditValue()} or +link{listGrid.setEditValues()}.
    //
    // @param record (ListGridRecord) record for the cell being edited.  <b>Will be null</b>
    //                                for a new, unsaved record.
    // @param value (any) value for the cell being edited
    // @param rowNum (int)  row number for the cell
    // @param colNum (int)  column number of the cell
    // @param grid (ListGrid) ListGrid to which this field belongs
    // @group editing
    // @visibility external
    //<

    //> @method listGridField.editorExit (A)
    // Callback fired when the user attempts to navigate away from the current edit cell,
    // or complete the current edit.<br>
    // Return false from this method to cancel the default behavior (Saving / cancelling the
    // current edit / moving to the next edit cell)
    //
    // @param   editCompletionEvent (EditCompletionEvent)  What interaction triggered this
    //                                                          edit cell exit
    // @param   record     (ListGridRecord) record for the cell being edited
    // @param   newValue   (any)    new value for the cell being edited
    // @param   rowNum     (int)    row number for the cell
    // @param   colNum     (int)    column number of the cell
    // @param   grid    (ListGrid)  ListGrid to which this field belongs
    // @return  (boolean)   Returning false from this method will cancel the default behavior
    //                      (for example saving the row) and leave the editor visible and focus
    //                      in this edit cell.
    //  @group  editing
    //  @see listGrid.editorExit
    // @visibility external
    //<

    //> @method listGridField.cellChanged()
    // Callback fired when field changes value as the result of a cell edit.  Fired only on
    // successful save of edit, when the new value doesn't match the value before editing.<br>
    // <p>
    // Same signature as +link{method:listGrid.cellChanged()}, but defined on a per-field
    // basis.
    //
    // @param   record     (ListGridRecord) record for the cell being changed
    // @param   newValue   (any)    new value for the cell
    // @param   oldValue   (any)    old value for the cell
    // @param   rowNum     (number) row number for the cell
    // @param   colNum     (number) column number of the cell
    // @param   grid       (ListGrid)   grid where cell was changed.
    //
    // @group  editing
    // @see method:listGrid.cellChanged()
    // @visibility external
    //<

    //> @attr listGridField.validators (Array of Validator : null : [IRW])
    // Array of +link{class:Validator} objects for this field.  When the user edits cells in
    // this field, these validators will be applied to the edited value.<br>
    // Note: for databound listGrids, this property may be specified on the
    // +link{class:DataSourceField}, enabling both client and server side validation.
    // @see class:Validator
    // @see listGridField.required
    // @group gridValidation
    // @visibility external
    // @example dataValidation
    //<

    //> @attr listGridField.validateOnChange (boolean : null : [IRW])
    // If set to true, any +link{listGridField.validators} for this field will be run whenever
    // the value of the field is changed.
    // <P>
    // Analogous to the +link{FormItem.validateOnChange} property.
    // @group gridValidation
    // @visibility external
    //<

    //> @attr listGridField.required (Boolean : null : [IRW])
    // When the user edits cells in this field, is this value required to be non-empty
    // in order for validation to pass.<br>
    // Note: for databound listGrids, this property may be specified on the
    // +link{class:DataSourceField}, enabling both client and server side validation.
    //
    // @see listGridField.validators
    // @group gridValidation
    // @visibility external
    //<

    //> @attr listGridField.displayFormat (varies : null : [IRWA])
    // For fields of type <code>"date"</code>, set this property to a valid
    // +link{dateDisplayFormat} to specify how the date should be formatted.<br>
    // For fields of type <code>"time"</code>, set this property to a valid
    // +link{type:TimeDisplayFormat, TimeDisplayFormat} to specify how the time should be formatted.<br>
    // If unset, display format may be set at the listGrid level via +link{ListGrid.dateFormatter}
    // or +link{ListGrid.timeFormatter}.
    // <p>
    // If this field is editable the displayFormat will also be passed to the editor created
    // to edit this field.  For dates you may also need to set +link{listGridField.inputFormat}.
    //
    // @see listGridField.inputFormat
    // @see listGrid.dateFormatter
    // @see listGrid.timeFormatter
    // @deprecated Use +link{listGridField.dateFormatter} and +link{listGridField.timeFormatter}
    //  instead.
    // @visibility external
    //<

    //> @attr listGridField.dateFormatter (DateDisplayFormat : null : [IRW])
    // Display format to use for date type values within this field.
    // <P>
    // The +link{listGridField.timeFormatter} may also be used to format underlying Date values as
    // times (omitting the date part entirely). If both <code>dateFormatter</code> and
    // <code>timeFormatter</code> are specified on a field, for
    // fields specified as +link{listGridField.type,type "time"} the
    // <code>timeFormatter</code> will be used, otherwise the <code>dateFormatter</code>
    // <P>
    // If <code>field.dateFormatter</code> and <code>field.timeFormatter</code> is unspecified,
    // date display format may be defined at the component level via
    // +link{ListGrid.dateFormatter,ListGrid.dateFormatter}, or for fields of type <code>"datetime"</code>
    // +link{ListGrid.datetimeFormatter,ListGrid.datetimeFormatter}. Otherwise the
    // default is to use the system-wide default short date format, configured via
    // +link{Date.setShortDisplayFormat()}.  Specify any valid +link{type:DateDisplayFormat} to
    // change the format used by this item.
    // <P>
    // If this field is editable the dateFormatter will also be passed to the editor created
    // to edit this field. Note that you can also specify an explicit +link{listGridField.inputFormat}
    // which will be passed through to the editor as well, though this is not typically required
    // as the input format should be automatically derived by the SmartClient system
    // for standard DateDisplayFormats.
    //
    // @see listGrid.dateFormatter
    // @see listGrid.datetimeFormatter
    // @see listGridField.timeFormatter
    // @visibility external
    //<

    //> @attr listGridField.timeFormatter (TimeDisplayFormat : null : [IRWA])
    // Time-format to apply to date type values within this field.  If specified, any
    // dates displayed in this field will be formatted as times using the appropriate format.
    // This is most commonly only applied to fields specified as type <code>"time"</code> though
    // if no explicit +link{listGridField.dateFormatter} is specified it will be respected for other
    // fields as well.
    // <P>
    // If unspecified, a timeFormatter may be defined
    // +link{ListGrid.timeFormatter,at the component level} and will be respected by fields
    // of type <code>"time"</code>.
    // <P>
    // If this field is editable, the timeFormatter will also be passed to the editor created to
    // edit this field as +link{formItem.timeFormatter}.
    //
    // @group appearance
    // @visibility external
    //<
    //timeFormatter:null

    //> @attr listGridField.decimalPrecision (number : null : [IRW])
    // @include dataSourceField.decimalPrecision
    //
    // @group appearance
    // @serverDS allowed
    // @visibility external
    //<

    //> @attr listGridField.decimalPad (number : null : [IRW])
    // @include dataSourceField.decimalPad
    //
    // @group appearance
    // @serverDS allowed
    // @visibility external
    //<

    //> @attr listGridField.inputFormat (DateInputFormat : null : [IRWA])
    // For fields of type <code>"date"</code> or <code>"datetime"</code>, if this is an editable
    // listGrid, this property allows you to specify the +link{DateItem.inputFormat, inputFormat}
    // applied to the editor for this field.
    // @see listGridField.dateFormatter
    // @visibility external
    //<

    //> @attr listGridField.isRemoveField (boolean : null : [IRA])
    // If set to true and +link{listGrid.canRemoveRecords} is true, this field will be rendered
    // as the remove-field for this grid. In most common usage scenarios this field will essentially
    // be a placeholder indicating where the remove field should be rendered, meaning properties
    // other than <code>isRemoveField</code>, such as <code>name</code> or <code>title</code>, may
    // be left unset.
    // @see listGrid.canRemoveRecords
    // @visibility external
    //<

    //> @method listGridField.recordClick()
    //
    // Executed when this field is clicked on.  Note that if +link{ListGrid.recordClick()} is
    // also defined, it will be fired for fields that define a recordClick handler if the
    // field-level handler returns true. Return false to prevent the grid-level handler from firing.
    //
    // @param   viewer      (ListGrid)  the listGrid that contains the click event
    // @param   record      (ListGridRecord)    the record that was clicked on
    // @param   recordNum   (number)    number of the record clicked on in the current set of
    //                                  displayed records (starts with 0)
    // @param   field       (ListGridField) the field that was clicked on (field definition)
    // @param   fieldNum    (number)    number of the field clicked on in the listGrid.fields
    //                                  array
    // @param   value       (any)    value of the cell (after valueMap, etc. applied)
    // @param   rawValue    (any)   raw value of the cell (before valueMap, etc applied)
    // @return  (boolean)   false to stop event bubbling
    //
    // @group   events
    //
    // @see method:listGrid.recordClick()
    // @visibility external
    // @example recordClicks
    //<

    //> @method listGridField.recordDoubleClick()
    //
    // Executed when this field is double-clicked.  Note that if
    // +link{ListGrid.recordDoubleClick()} is also defined, it will be fired for fields that define
    // a recordDoubleClick handler if the field-level handler returns true. Return false to prevent
    // the grid-level handler from firing.
    //
    //
    // @param   viewer      (ListGrid)  the listGrid that contains doubleclick event
    // @param   record      (ListGridRecord)    the record that was double-clicked
    // @param   recordNum   (number)    number of the record clicked on in the current set of
    //                                  displayed records (starts with 0)
    // @param   field       (ListGridField) the field that was clicked on (field definition)
    // @param   fieldNum    (number)    number of the field clicked on in the listGrid.fields
    //                                  array
    // @param   value       (object)    value of the cell (after valueMap, etc. applied)
    // @param   rawValue    (object)    raw value of the cell (before valueMap, etc applied)
    // @return  (boolean)   false to stop event bubbling
    //
    // @group   events
    //
    // @see method:listGrid.recordClick()
    // @visibility external
    // @example recordClicks
    //<

    // Filtering
    // ---------------------------------------------------------------------------------------

    //> @attr   listGridField.canFilter (boolean : null : [IRW])
    //      If showing a filter row for this ListGrid, should the filter criteria for this
    //      field be editable
    //  @group  filterEditor
    //  @visibility external
    //  @example disableFilter
    //<

    //> @attr listGridField.filterEditorValueMap (Object : null : [IRW])
    //  If this listGrid is showing a filter row, this property can be used to specify a
    //  mapping of internal data to/from display values to be in the appropriate filter
    //  row form item.
    //  @visibility external
    //  @group filterEditor
    //<

    //> @attr   listGridField.filterEditorType (FormItem className : null : [IRWA])
    //      If this ListGrid is showing a filter row, this property can be used to
    //      specify the form item class to use for the filter form item associated with this
    //      field
    //      (Only used if this field is not canFilter:false).<br>
    //      Note: If this is not specified, the edit-form item type may be derived from the
    //      'editorType' property, typically inherited from datasource fields, or from the
    //      'type' of the field (showing the appropriate form item for the data-type).
    //  @group  filterEditor
    //  @visibility external
    //<

    //> @attr   listGridField.defaultFilterValue (any : null : [IRWA])
    // If this ListGrid is showing a filter row, this property can be used to apply a default
    // value to show in the filter editor for this field.
    // @group filterEditor
    // @visibility external
    //<
    

    //> @attr   listGridField.filterEditorProperties (FormItem properties : null : [IRWA])
    // If this ListGrid is showing a filter row
    // (+link{listGrid.showFilterEditor,showFilterEditor}:true), this property
    // can be used to specify properties for the appropriate filter form item.
    // @group filterEditor
    // @visibility external
    //<

    //> @attr     listGridField.filterOnKeypress (boolean : null : [IRWA])
    // If we're showing the filterEditor (listGrid.showFilterEditor is true), this property
    // determines whether this list should be filtered every time the user edits the value of
    // the filter editor for this field.
    // <P>
    // The +link{listGrid.fetchDelay} governs the delay in milliseconds between the user editing the
    // filter editor value, and the new filter being applied to the grid.
    // @group filterEditor
    // @visibility external
    //<

    //> @attr listGrid.fetchDelay (number : 300 : IRWA)
    // If we're showing the filterEditor (+link{listGrid.showFilterEditor} is true), and we're
    // re-filtering on every keypress (+link{listGrid.filterOnKeypress} is true), this
    // property is the delay in milliseconds between the user changing the filter and the
    // filter request being kicked off. If multiple changes are made to the filter
    // within this fetch delay, only the most recent will actually cause a re-filter
    // @group filterEditor
    // @visibility external
    //<
    fetchDelay:300,

    //> @attr listGridField.shouldPrint (boolean : null : IRW)
    // Whether this field should be included in the printable representation of the grid.
    //
    // @group printing
    // @visibility external
    //<

    // AutoComplete
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.autoComplete (AutoComplete : null : IRW)
    // Whether to allow browser autoComplete when editing this field.
    // <p>
    // If unset, defaults to listGrid.autoComplete
    //
    // @see listGrid.autoComplete
    // @visibility external
    //<

    //> @attr listGridField.uniqueMatch (boolean : null : IRW)
    // When autoComplete is enabled, whether to offer only unique matches to the user.
    // <p>
    // If unset, defaults to listGrid.uniqueMatch.
    //
    // @see listGrid.uniqueMatch
    // @visibility autoComplete
    //<
    uniqueMatch:true,


    // Formatting (per field)
    // --------------------------------------------------------------------------------------------

    //> @method listGridField.getCellValue()
    // A stringMethod which returns the cell value to display for this field for some record.
    // If defined, called by ListGrid.getCellValue().  Called in the scope of the field object.
    //
    // Deprecated as of Jan 12 05 in favor of +link{listGridField.formatCellValue()}, because 
    // 'getCellValue()' is a lower-level API which handles (for example) returning the HTML
    // for editors within the cell.
    //
    // @param  viewer  (ListGrid)  the ListGrid for which we're returning a cellValue
    // @param  record  (object)    the current record object
    // @param  recordNum   (number)    row-index of the current record
    // @param  field   (listGridField) current field object
    // @param  fieldNum    (number)    column-index of the current field
    // @param  value   (any)   unformatted value for this field, determined via
    //                          ListGrid.getRawCellValue()
    // @see    method:listGrid.getCellValue
    // @see method:listGridField.formatCellValue
    // @group  display_values
    // @visibility external
    // @return (any)   value to display in the ListGrid cell
    // @deprecated As of SmartClient 5.5, use +link{listGridField.formatCellValue}.
    //<

    // We provide separate formatters for the raw value displayed in a static cell, and the
    // value displayed in an editor.
    // This makes sense because:
    // - developers are likely to want to apply different formats - for example including some
    //   raw HTML in the static value, but not in the value displayed in a text based editor.
    // - the more common 'formatCellValue()' needs no parser to convert from the formatted value
    //   back to the raw value
    // If a developer wishes to apply the same formatter in both cases, the suggested approach
    // would be to write a single formatter function and have it be called from both methods.

    //> @method listGridField.formatCellValue()
    // Return the HTML to display in cells of this field.
    // <P>
    // Given the raw value for this field as taken from the record Formatter to apply to the
    // static values displayed in cells for this field.
    // <P>
    // <i>Example usage</i>: formatting a currency value stored in cents (so "100" to "$1.00")<br>
    // The value passed to this method is the raw value for the cell.<br>
    // Takes precedence over <code>formatCellValue</code> defined at the grid level for cells
    // in this field.
    // <P>
    // Note: this formatter will not be applied to the values displayed in cells being edited.
    // The +link{listGridField.formatEditorValue,formatEditorValue()} is provided for that purpose.
    //
    // @group display_values
    //
    // @param   value (any)   raw value for the cell, from the record for the row
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter (see +link{listGrid.getEditValues()})
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @param   grid    (ListGrid) the ListGrid displaying the cell
    // @return (HTMLString) HTML to display in the cell
    //
    // @see listGrid.formatCellValue()
    // @see listGridField.formatEditorValue()
    // @deprecated <smartgwt>Use +link{ListGridField.setCellFormatter()} or 
    // +link{ListGrid.setCellFormatter()} to install a +link{class:CellFormatter}.
    //  This method is not a valid override point for the default behavior.</smartgwt>
    // @visibility external
    // @example formatValues
    //<

    //> @attr listGridField.escapeHTML (boolean : null : IRW)
    // By default HTML values in ListGrid cells will be interpreted by the browser.
    // Setting this flag to true will causes HTML characters to be escaped, meaning the
    // raw value of the field (for example <code>"&lt;b&gt;AAA&lt;/b&gt;"</code>) is displayed
    // to the user rather than the interpreted HTML (for example <code>"<b>AAA</b>"</code>)
    // @visibility external
    //<

    //> @attr listGridField.linkText (String : null : IRW)
    // The HTML to display in cells of this field if the fieldType is set to link.
    // <P>
    // This property sets linkText that will be the same for all records.  You can set linkText
    // on a per-record basis via +link{attr:listGridRecord.linkText}.
    //
    //  @see type:ListGridFieldType
    //  @see type:FieldType
    //  @see attr:listGridRecord.linkText
    //  @see attr:listGrid.linkTextProperty
    //  @see attr:listGridField.linkTextProperty
    //  @group  display_values
    //  @visibility external
    //  @example linkImage
    //<

    //> @attr listGridField.linkTextProperty (string : null : IRW)
    // Name of the property in a ListGridRecord that holds the HTML to display in cells of this
    // field if the fieldType is set to "link".
    //
    //  @see type:ListGridFieldType
    //  @see type:FieldType
    //  @see attr:listGridRecord.linkText
    //  @see attr:listGridField.linkText
    //  @see attr:listGrid.linkTextProperty
    //  @group  display_values
    //  @visibility external
    //<

    //> @attr listGridField.linkURLPrefix (string : null : IRWA)
    // If this field has type [+link{type:ListGridFieldType}] set to <code>"link"</code>,
    // setting this property will apply a standard prefix to the link URL for cells in this field.
    // @visibility external
    //<


    //> @attr listGridField.linkURLSuffix (string : null : IRWA)
    // If this field has type [+link{type:ListGridFieldType}] set to <code>"link"</code>,
    // setting this property will apply a standard suffix to the link URL for cells in this field.
    // @visibility external
    //<

    // --------------------
    // Editing

    //> @method listGridField.formatEditorValue
    // Return the value to display in cells of this field which are being edited.
    // <P>
    // <i>Example usage</i>: converting a stored value in cents (100) to a dollar-and-cents
    // value in the editor (1.00)
    // <P>
    // The value passed to this method is the raw value for the cell.
    // <P>
    // <code>formatEditorValue</code> takes precedence over +link{listGrid.formatEditorValue()}
    // defined at the grid level for cells in this field.
    // <P>
    // To convert the formatted value displayed within an editor back to a raw value, implement
    // +link{listGridField.parseEditorValue} as well.
    //
    // @group editing
    //
    // @param   value (any)   raw value for the cell being edited
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter.
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @param   grid    (ListGrid instance) A pointer to the ListGrid displaying the cell
    // @return (any) formatted value to display in the editor
    //
    // @see listGridField.formatCellValue()
    // @see listGrid.formatEditorValue()
    // @see listGridField.parseEditorValue()
    //
    // @visibility external
    //<

    //> @method listGridField.parseEditorValue
    // Method used to convert the value displayed in an editor for some cell in this field into
    // a raw value for saving.<br>
    // Takes precedence over <code>parseEditorValue</code> defined at the grid level.
    //
    // @group editing
    //
    // @param   value (any)   value displayed in the editor for the cell
    // @param   record (object) record object for the row being edited. May be null if this
    //                          is a new row being added to the end of the list.
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @param   grid    (ListGrid instance) A pointer to the ListGrid displaying the cell
    // @return (any) raw value for the field derived from formatted value in editor
    // @see listGrid.parseEditorValue()
    // @see listGridField.formatEditorValue()
    // @visibility external
    //<

    //> @attr listGridField.valueMap (Object | Array of String : null : IRW)
    // Array of legal values for this field, or an Object where each property maps a stored
    // value to a user-displayable value.<br>
    // Note that if this field is editable (see +link{listGrid.canEdit},
    // +link{listGridField.canEdit}), editors displayed for this field will pick up their
    // valueMap either from this value or from +link{listGridField.editorValueMap}.
    // <P>
    // See also +link{dataSourceField.valueMap}.
    //
    // @group display_values
    // @see ListGrid.setValueMap()
    // @see ListGrid.getDisplayValue()
    // @visibility external
    // @example listType
    //<

    //> @attr listGridField.sortByMappedValue (boolean : null : IRW)
    // If +link{listGridField.valueMap} is set, and the grid is +link{listGrid.setSort(),sorted}
    // by this field, should the data be sorted by the underlying data value or the
    // mapped display value. If unset, will sort by display value. Set to <code>false</code>
    // to sort by underlying data value. Note that this has no effect if
    // a +link{listGridField.sortNormalizer} has been specified.
    // @visibility external
    //<

    //> @attr listGridField.multiple (Boolean : null : IR)
    // Indicates that this field should always be Array-valued. This property will be
    // passed through to the generated edit-item when editing the field - so if
    // +link{listGridField.valueMap} is set, the default editor will be a +link{SelectItem} with
    // +link{SelectItem.multiple} set to true.
    // <P>
    // Note that for databound grids it typically makes sense to set +link{DataSourceField.multiple}
    // rather than setting the property directly on the ListGridField object.
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.editorValueMap (Object : null : IRW)
    // A valueMap to use for editors shown for this field.  By default if this is not
    // specified +link{listGridField.valueMap,field.valueMap} will be used instead.
    // <P>
    // Dynamic valueMaps can be provided by implementing +link{listGrid.getEditorValueMap()}.
    //
    // @group editing
    // @visibility external
    // @see listGrid.getEditorValueMap()
    // @see listGrid.setEditorValueMap()
    //<

    //> @method listGridField.change()
    // If this field is editable, any +link{formItem.change, change} handler specified
    // on the ListGridField will be passed onto the editors for this field.
    // <P>
    // Note that if +link{listGridField.canToggle} is true, the user may change the value of
    // a boolean field without going into edit mode by single clicking on the field. In this
    // case the +link{listGridField.change()} and +link{listGridField.changed()} handlers will
    // fire but the <code>form</code> and <code>item</code> parameters will be null.
    //
    // @param   form    (DynamicForm) the managing DynamicForm instance
    // @param   item    (FormItem)    the editor (form item) itself (also available as "this").
    //                              Note that in addition to the standard FormItem APIs available
    //                              on the editor, it also has:<br>
    //                              - a pointer back to the containing listGrid
    //                              [<code>item.grid</code>]<br>
    //                              - the colNum being edited [<code>item.colNum</code>]<br>
    //                              - the rowNum being edited [<code>item.rowNum</code>]
    // @param   value   (any)         The new value of the form item
    // @param   oldValue    (any)     The previous value of the form item
    // @return (Boolean) The change may be cancelled <smartclient>by returning false</smartclient>
    // @see listGridField.changed()
    // @see listGrid.cellChanged()
    // @group editing
    // @visibility external
    //<

    //> @method listGridField.changed()
    // If this field is editable, any +link{formItem.changed, changed} handler specified
    // on the ListGridField will be passed onto the editors for this field.
    // Note that if +link{listGridField.canToggle} is true, the user may change the value of
    // a boolean field without going into edit mode by single clicking on the field. In this
    // case the +link{listGridField.change()} and +link{listGridField.changed()} handlers will
    // fire but the <code>form</code> and <code>item</code> parameters will be null.
    //
    // @param   form    (DynamicForm) the managing DynamicForm instance
    // @param   item    (FormItem)    the editor (form item) itself (also available as "this").
    //                              Note that in addition to the standard FormItem APIs available
    //                              on the editor, it also has:<br>
    //                              - a pointer back to the containing listGrid
    //                              [<code>item.grid</code>]<br>
    //                              - the colNum being edited [<code>item.colNum</code>]<br>
    //                              - the rowNum being edited [<code>item.rowNum</code>]
    // @param   value   (any)         The current value (after the change).
    // @see listGridField.change()
    // @see listGrid.cellChanged()
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.emptyCellValue (HTMLString : "&nbsp;" : IRW)
    // The value to display for a cell whose value is null or the empty string after
    // applying +link{listGridField.formatCellValue(),formatting} and valueMap (if any).
    // <p>
    // This is the field-specific attribute.  You may also set the emptyCellValue at the grid
    // level to define the emptyCellValue for all empty fields in the grid.
    //
    // @group display_values
    // @see listGrid.emptyCellValue
    // @visibility external
    // @example emptyValues
    //<

    // Field.optionDataSource
    // --------------------------------------------------------------------------------------------

    //> @attr listGridField.autoFetchDisplayMap (boolean : null : [IRW])
    // If true, automatically fetches records and derives a valueMap from
    // +link{listGridField.optionDataSource}.
    // <p>
    // Same as +link{listGrid.autoFetchDisplayMap}, but defined on a per-field basis.
    //
    // @group display_values
    // @see listGrid.autoFetchDisplayMap
    // @visibility external
    //<

    //> @attr listGridField.displayValueFromRecord (boolean : null : IRWA)
    // If a +link{listGridField.displayField} is set, should this field show record values from
    // the <code>displayField</code>?
    // <P>
    // If +link{listGridField.displayField} is specified, and there is no separate
    // +link{listGridField.optionDataSource}, by default we will show display-field values
    // from the same record. Setting this property to false would disable this behavior.
    // <P>
    // Alternatively, if there is a +link{listGridField.optionDataSource} (and
    // +link{listGridField.autoFetchDisplayMap} is false), the displayField would be ignored
    // for the field and the underlying +link{listGridField.name,record[fieldName] value} would
    // be displayed to the user. This property may be set to true to override this behavior and
    // pick up values from the <code>displayField</code> for display in this field even when there
    // is an optionDataSource set.
    // <P>
    // Note that this property has no effect on fields with an explicitly specified valueMap, or
    // with an optionDataSource where +link{listGridField.autoFetchDisplayMap} is true.
    // @visibility external
    //<

    //> @attr listGridField.optionTextMatchStyle (TextMatchStyle : null : [IR])
    // For fields with an +link{listGridField.optionDataSource}, where
    // +link{listGridField.autoFetchDisplayMap} is true, this property will govern
    // the <code>textMatchStyle</code> attribute of the +link{DSRequest} parameter passed to
    // +link{DataSource.fetchData()} when retrieving the remote data set to be used as
    // a basis for this field's valueMap.
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.optionFilterContext (DSRequest Properties : null : [IR])
    // If this field has an optionDataSource specified and
    // +link{listGridField.autoFetchDisplayMap,autoFetchDisplayMap} is set, this attribute
    // provides a way to customize the dataSource request issued to fetch the display map from
    // the option dataSource.  This provides, among other capabilities, a way to trigger the
    // server to return summary records.
    // @see group:serverSummaries
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.optionOperationId (string : null : [IR])
    // If this field has an optionDataSource specified and
    // +link{listGridField.autoFetchDisplayMap,autoFetchDisplayMap} is set, this attribute
    // provides a way to customize the +link{DSRequest.operationId} passed to
    // <code>dataSource.fetchData()</code> when retrieving the display map from the option
    // dataSource.
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.optionDataSource (String : null : [IRW])
    // Derive a +link{valueMap} by fetching records from another DataSource and extracting
    // the +link{listGridField.valueField,valueField} and
    // +link{listGridField.displayField,displayField} in the loaded records, to derive one
    // valueMap entry per record loaded from the optionDataSource.
    // <P>
    // Unlike the similar use of +link{pickList.optionDataSource} for +link{PickList,pickLists}
    // used during editing or filtering, <code>listGridField.optionDataSource</code> causes the
    // <b>entire set of records from the optionDataSource to be fetched</b>, without paging.
    // Hence listGridField.optionDataSource is appropriate only for smaller valueMaps.  For very
    // large valueMap situations, such as an accountId field that should be displayed as an
    // accountName where there are thousands of accounts, the correct approach is:
    // <ul>
    // <li> do not set listGridField.optionDataSource
    // <li> declare two fields in the DataSource, eg "accountId" and "accountName".
    // <li> Set the +link{ListGridField.displayField} attribute on the data field to the
    //      name of the display field.
    // <li> When fetching records for display in a grid, have your server send back values for
    //      both fields, but show only the data field ("accountId") in the grid.
    // </ul>
    // In this case the cells in the accountId field will show the record value from the
    // accountName field.  This approach means the valueMap will never be loaded in its
    // entirety, instead, each loaded record contains the valueMapping for that one record, as
    // a pair of fields within the record.
    // <p>
    // If you are using the SmartClient Server Framework with the SQL or JPA/Hibernate built-in
    // connectors, this entire approach can be achieved very easily using the
    // +link{dataSourceField.includeFrom} setting - see the
    // +link{dataSourceField.includeFrom,docs for includeFrom} for details.
    // <P>
    // Notes:
    // <ul>
    // <li>When using the above approach, it is key that the server return <b>both</b>
    // the underlying stored value <b>and</b> the display value, as suggested above.
    // This approach allows the +link{pickList.optionDataSource} property to be used to
    // provide paged valueMaps during inline editing and
    // +link{ListGrid.showFilterEditor,inline filtering}. This can be achieved by setting the
    // <code>optionDataSource</code> attribute on the form item used to edit the field
    // via +link{listGridField.editorProperties} (for editing) or
    // +link{listGridField.filterEditorProperties,field.filterEditorProperties} (for
    // filtering), without specifying an optionDataSource at the listGridField level.
    // Alternatively developers can use +link{listGridField.autoFetchDisplayMap} to
    // suppress the fetch against the optionDataSource at the listGrid level.</li>
    // <li>Setting <code>listGridField.optionDataSource</code> to the same dataSource as the
    // listGrid is not the same as omitting the optionDataSource setting entirely. Unless
    // +link{listGridField.autoFetchDisplayMap} has been set to explicitly disable fetching,
    // a fetch will be performed against the dataSource to build a valueMap which will be used
    // as the definitive mapping from data to display values, rather than picking up the display
    // values from the records themselves. This distinction is required to support cases where
    // the +link{listGridField.valueField} points to a different field in the grid (useful for
    // hierarchical relationships, for example), or where +link{listGridField.optionCriteria} or
    // +link{listGridField.optionOperationId} are specified and return different data from
    // the records displayed within the grid.</li>
    // <li>If a displayField is specified, with no associated optionDataSource, and the field is
    // editable, updating the edit value for the field may not automatically update the displayField
    // edit value, meaning the user may not realize the edit value has been modified.
    // If the new value came from the user editing the field, and the edit item has
    // a valueMap or optionDataSource specified, the display value is picked up automatically and
    // stored out on the displayField for the record. However if the value was set programmatically,
    // the developer should also set the edit value for the display field to ensure the displayed
    // value reflects the new edit value. Note that when this occurs, a warning will be logged
    // which can be disabled via +link{listGrid.warnOnUnmappedValueFieldChange}.</li>
    // <li>For very advanced usage a developer can use +link{listGridField.displayValueFromRecord}
    // to explicitly tell the grid whether or not to display the display field value for the record
    // in this field when a displayField is specified. See documentation on that property for more
    // information</li>
    // </ul>
    //
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.valueField (string : null : [IRW])
    // Specifies the +link{listGridField.optionDataSource} field used to retrieve the stored
    // values that are to be mapped to the display values (specified by
    // +link{listGridField.displayField}). Note that if this field is editable this will also
    // be applied to this field's editors.
    //
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.displayField (string : null : [IRW])
    // Specifies the +link{listGridField.optionDataSource} field used to retrieve the display
    // values that are to be mapped from the internal values specified by +link{valueField}.
    // <P>
    // If no <code>optionDataSource</code> is defined for the field, the cell will display
    // the displayField value for the current record instead of the underlying value for
    // this field.  This approach can be used for situations where field values need a stored
    // value to displayed value mapping, but the set of all possible values is too large to
    // load as a +link{ValueMap} - see +link{listGridField.optionDataSource} for more details
    // on this approach.  Note that if this field is editable this will also be applied to this
    // field's editors.  +explorerExample{largeValueMapSQL,This sample} illustrates this
    // approach achieved via a server-side SQL join.
    // <p>
    // The display value for a record with a specified <code>displayField</code> can be
    // picked up via +link{ListGrid.getDisplayValue()}.
    //
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.sortByDisplayField (boolean : null : [IRW])
    // For a field with <code>displayField</code> configured, should client-side sorting
    // be performed on the display field value? Unless explicitly set to <code>false</code>
    // the display field value is used.
    //
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.optionCriteria (Criteria : null : [IRW])
    // If +link{optionDataSource} is set for this ListGridField, criteria specified in this
    // attribute will be passed to the dataSource when performing the fetch operation to
    // determine data-value to display-value mappings
    // @group display_values
    // @visibility external
    //<


    // ---------

    //> @attr listGridField.includeFrom (String : null : [IR])
    // Indicates this field's values should be fetched from another, related DataSource.
    // The individual field will inherit settings such as +link{listGridField.type,field.type}
    // and +link{listGridField.title,field.title} from the related DataSource just like
    // fields from the primary DataSource.
    // <P>
    // When +link{listGrid.fetchData(),fechData()} is called, the automatically created +link{DSRequest} will
    // specify +link{dsRequest.additionalOutputs} requesting the field, and any +link{Criteria}
    // generated by the component will likewise refer to the field from the related DataSource.
    // <P>
    // It's an error to use this property if the ListGrid does not have a DataSource at all.
    // The related DataSource must be loaded or a warning will be logged and the field
    // definition ignored.
    // <P>
    // This value is expected to be set to the following format
    // <code>dataSourceID.fieldName</code> where <i>dataSourceID</i> is the ID of the
    // related dataSource and <i>fieldName</i> is the name of the field from that dataSource
    // from which you wish to retrieve values. Note that if this property is set and
    // +link{ListGridField.name,field.name} is not explicitly specified, this field's <code>name</code> will
    // default to the <i>fieldName</i> value from this property.
    // <p>
    // Note about automatic cache updates: "update" and "add" operations
    // submitted automatically by this ListGrid will include
    // <code>dsRequest.additionalOutputs</code> to ensure all data necessary
    // for cache updates is returned by the server.
    // <p>
    // If your grid shows data that can be edited elsewhere in the UI (not by
    // inline editing), to avoid problems with +link{ResultSet} automatic
    // cache synchronization, you may need to switch from using
    // <code>listGridField.includeFrom</code> to
    // <code>dataSourceField.includeFrom</code>.  This is because
    // server responses to "add" and "update" operations which are initiated
    // outside of this grid do not know about the
    // <code>listGridField.includeFrom</code> setting, and so will not
    // automatically return data for fields included in this way.  Switching
    // to <code>dataSourceField.includeFrom</code> ensures the field is
    // always included in server responses, avoiding the issue.
    //
    // @group display_values
    // @visibility crossDS
    //<

    // ----------------------------------------------------------------------------------------
    // Don't show scrollbars -- scrolling occurs in the body

    //> @attr listGrid.overflow (Overflow : Canvas.HIDDEN : IR)
    // Since +link{body} is configured with overflow: auto by default, no overflow
    // is expected for the +link{listGrid} itself so by default it has overflow: hidden.
    // @see layout.overflow
    // @visibility external
    //<
    overflow:isc.Canvas.HIDDEN,

    //> @attr   listGrid.backgroundColor        (string : "white" : IRW)
    //      @group  appearance
    //<
    backgroundColor:"white",

    //> @attr   listGrid.minHeight      (number : 50 : IRW)
    // Minimum height for the entire list (smaller than this doesn't tend to work very well).
    //      @group  sizing
    //<
    minHeight:50,

    defaultWidth:200,

    //> @attr listGrid.fieldIdProperty (string : "name" : IRA)
    //  Property to be used as field identifier on listGridField objects.
    //  The ID of the field is also the property in each record which holds the value
    //  for that field.
    //      @group  data
    //<
    // defaulted on Canvas
    

    // GridRenderer properties
    // ---------------------------------------------------------------------------------------

    //> @attr listGrid.showAllRecords (Boolean : false : [IRW])
    // @include gridRenderer.showAllRows
    // @example autofitRows
    //<
    //showAllRecords:false,

    //> @attr listGrid.showAllColumns (Boolean : false : IR)
    // @include gridRenderer.showAllColumns
    //<
    //showAllColumns:false,

    //> @attr listGrid.drawAllMaxCells (int : 250 : IRWA)
    // @include gridRenderer.drawAllMaxCells
    // @group performance
    // @visibility external
    //<
    drawAllMaxCells:250,


    //> @attr listGrid.drawAheadRatio (float : 1.3 : IRW)
    // @include gridRenderer.drawAheadRatio
    // @group performance
    // @example databoundFetch
    //<
    drawAheadRatio: isc.useHighPerformanceGridTimings ? 2.0 : 1.3,

    //> @attr listGrid.quickDrawAheadRatio (float : 1.0 : IRW)
    // @include gridRenderer.quickDrawAheadRatio
    // @group performance
    //<
    quickDrawAheadRatio: isc.useHighPerformanceGridTimings ? 2.0 : 1.0,

    //> @attr listGrid.instantScrollTrackRedraw (Boolean : true : IRW)
    // @include gridRenderer.instantScrollTrackRedraw
    // @group performance
    // @visibility external
    //<

    //> @attr listGrid.scrollRedrawDelay (int : 75 : IRW)
    // @include gridRenderer.scrollRedrawDelay
    // @group performance
    // @visibility external
    //<
    scrollRedrawDelay: isc.useHighPerformanceGridTimings ? 0 : 75,
    
    //> @attr listGrid.scrollWheelRedrawDelay (Integer : 250 : IRW)
    // While scrolling an incrementally rendered grid, using the mouseWheel, time in 
    // milliseconds to wait before redrawing, after the last mouseWheel movement by the user.  
    // If not specified +link{scrollRedrawDelay} will be used as a default for both
    // drag scrolling and mouseWheel scrolling.
    // <P>
    // Note that if specified, this value will typically be larger than 
    // +link{scrollRedrawDelay}. From experimentation, the default setting of 
    // <code>250</code> is typically enough time for a user to rapidly scroll through a
    // grid (rotating the scroll wheel with repeated flicks), without redrawing between
    // rotations, but this will differ depending on how long the redraw takes. A larger
    // delay may be warranted for grids with large numbers of columns, heavy custom 
    // formatting, etc.
    // <P>
    // See also
    // +link{gridRenderer.instantScrollTrackRedraw} for cases where this delay is skipped.
    //
    // @group performance
    // @visibility external
    //<
    scrollWheelRedrawDelay: isc.useHighPerformanceGridTimings ? 0 : 250,
    touchScrollRedrawDelay: isc.useHighPerformanceGridTimings ? 0 : 300,
    
    //> @attr listGrid.virtualScrolling (boolean : null : [IRA])
    // When incremental rendering is switched on and there are variable record heights, the virtual
    // scrolling mechanism manages the differences in scroll height calculations due to the
    // unknown sizes of un-rendered rows to make the scrollbar and viewport appear correctly.
    // <P>
    // When the <code>virtualScrolling</code> system is active, the last scroll position
    // scrolls the last record to the top of the viewport, leaving blank space underneath.
    // This is a necessary and unavoidable consequence of mapping the position of the scrollbar
    // thumb to an unknown amount of remaining space without being able to know the total
    // scrollable area in advance (since record heights vary).
    // <P>
    // virtualScrolling is switched on automatically when +link{fixedRecordHeights} is false and
    // also when
    // using the +link{listGrid.showRecordComponents,recordComponents subsystem}, as
    // recordComponents expand the rows that contain them. This flag should be manually enabled
    // when calling +link{listGrid.addEmbeddedComponent()} if embedded components can
    // cause record sizes to expand beyond specified cellHeight.
    // <P>
    // virtualScrolling is also automatically enabled when +link{listGrid.canExpandRecords} is true
    // to handle the fact that expanded rows may render at variable heights.
    //
    // @see recordComponentHeight
    // @visibility external
    //<

    //> @attr listGrid.dataPageSize (integer : null : IRW)
    // @include dataBoundComponent.dataPageSize
    // @group performance
    // @visibility external
    // @example databoundFetch
    //<

    //> @attr listGrid.dataFetchMode (FetchMode : "paged" : IR)
    // @include dataBoundComponent.dataFetchMode
    //<

    // configures ResultSet.fetchDelay, delay in MS before fetches are triggered
    
    // NOTE: setting this value to 0 causes filterData() to fire its callback twice - at least
    // in part because RS acts synchronously in this case and various LG/DBC logic expects to
    // markForRedraw() which acts on a timer.
    dataFetchDelay : isc.useHighPerformanceGridTimings ? 1 : 300,

    //> @attr listGrid.body (MultiAutoChild GridRenderer : null : R)
    // GridRenderer used to render the dataset.
    // <p>
    // Note that this is a multi-instance component when there are frozen fields because in
    // addition to the primary body AutoChild, a "frozen body" AutoChild is created to render
    // the frozen portion of the dataset.
    // @see ListGrid.getBody()
    // @visibility external
    //<
    body:null,

    bodyConstructor:"GridBody",

    //> @attr listGrid.bodyOverflow (Overflow : isc.Canvas.AUTO : [IRWA])
    // Overflow setting for the "body", that is, the area of the grid where data values are
    // rendered.
    // <P>
    // <b>This is a very advanced setting</b> which is typically only changed by subclasses
    // of ListGrid which never show a header.  To achieve auto-fitting, instead use properties
    // such as +link{listGrid.autoFitData}, +link{listGrid.autoFitFieldWidths} and
    // +link{listGrid.fixedRecordHeights}.
    //
    //      @visibility external
    //      @group  sizing
    //      @example autofitRows
    //<
    bodyOverflow:isc.Canvas.AUTO,
    

    //> @attr listGrid.bodyBackgroundColor (string : "white" : IRW)
    // Background color applied to the ListGrid body (that is, the area of the grid where
    // data values are rendered).<br>
    // Note that this will typically not be visible to the user unless there are few enough
    // rows that there is visible space in the body below the last row. To style data cells,
    // override +link{ListGrid.baseStyle} instead.
    //      @group  appearance
    // @visibility external
    //<
    bodyBackgroundColor:"white",

    //> @attr listGrid.bodyStyleName (CSSStyleName : null : IRW)
    // CSS style used for the body of this grid.  If applying a background-color to the body
    // via a CSS style applied using this property, be sure to set
    // +link{ListGrid.bodyBackgroundColor} to <code>null</code>.
    //      @group  appearance
    // @visibility external
    //<
    //bodyStyleName:null,

    // whether to allow the body and header to have different border sizes and automatically
    // adjust the body column sizes to compensate such that column boundaries line up.
    allowMismatchedHeaderBodyBorder : true,

    //> @attr listGrid.emptyCellValue (HTMLString : "&nbsp;" : IRW)
    // The value to display for cells whose value is null or the empty string after applying
    // +link{listGrid.formatCellValue(),formatting} and valueMap (if any).
    // <p>
    // This is the grid-wide attribute.  You may also set the emptyCellValue on a per-field basis.
    //
    // @group cellStyling
    // @see listGridField.emptyCellValue
    // @visibility external
    // @example emptyValues
    //<
    emptyCellValue:"&nbsp;",

    //> @attr listGrid.cellHeight (number : 20 : [IRW])
    // @include gridRenderer.cellHeight
    // @example multilineValues
    //<
    cellHeight:20,

    //> @attr listGrid.normalCellHeight (number : 20 : [IRWA])
    // If +link{listGrid.baseStyle} is unset, base style will be derived from
    // +link{listGrid.normalBaseStyle} if this grid has fixed row heights and
    // the specified +link{listGrid.cellHeight} matches this value. Otherwise
    // +link{listGrid.tallBaseStyle} will be used.
    // @visibility external
    //<
    normalCellHeight:20,

    //> @attr listGrid.fixedRecordHeights (Boolean : true : IRWA)
    // Should we vertically clip cell contents, or allow rows to expand vertically to show all
    // contents?
    // <P>
    // If we allow rows to expand, the row height as derived from
    // +link{gridRenderer.getRowHeight(),getRowHeight()} or the
    // default +link{cellHeight} is treated as a minimum.
    // <P>
    // Setting <code>fixedRecordHeights</code> to false enables the +link{virtualScrolling}
    // system.
    // <P>
    // <b>NOTE:</b><ul>
    // <li>Setting fixedRecordHeights to false for +link{CubeGrid} is not supported, though a
    // similar option for the row headers is available as +link{CubeGrid.autoSizeHeaders}.
    // <li>By default, for performance reasons, clipping is not enforced for
    // some kinds of content (such as images) on all browsers.  Set
    // +link{enforceVClipping,enforceVClipping:true} to enforce clipping for
    // all types of content on all browsers.
    // </ul>
    //
    // @include gridRenderer.fixedRowHeights
    // @example autofitValues
    //<
    fixedRecordHeights: true,

    //> @attr listGrid.enforceVClipping (Boolean : false : IRW)
    // For performance reasons, even when +link{fixedRecordHeights} is set, vertical clipping
    // is not enforced by default for some kinds of content (such as images) on all browsers.
    // Set +link{enforceVClipping,enforceVClipping:true} to enforce clipping for all types of
    // content on all browsers.
    // <P>
    // This additional setting is likely to be phased out as browsers improve.
    //
    // @visibility external
    //<
    

    //> @attr listGrid.fixedFieldWidths (Boolean : true : IRWA)
    // Should we horizontally clip cell contents, or allow columns to expand horizontally to
    // show all contents?
    // <P>
    // If we allow columns to expand, the column width is treated as a minimum.
    // <P>
    // NOTE: the header does not automatically respond to expanded field widths.
    // If your grid is showing a header we'd recommend developers consider
    // setting +link{listGrid.autoFitFieldWidths} rather than using this attribute.
    // @group cellStyling
    // @visibility external
    //<
    // NOTE: doc is duplicated here because in the ListGrid we need to discuss the header.
    fixedFieldWidths:true,

    // autoFit attributes

    //> @type Autofit 
    // Possible values to change the behavior of how data will fill the ListGrid.
    // @value "vertical" expand vertically to accommodate records.
    // @value "horizontal" expand horizontally to accommodate fields.
    // @value "both" expand horizontally and vertically to accommodate content.
    // @group autoFitData
    // @visibility external
    //<

    //> @attr listGrid.autoFitData (Autofit : null : IRW)
    // Should this ListGrid automatically expand to accommodate the size of records and fields?
    // <P>
    // Valid settings are
    // <ul><li><code>"vertical"</code>: expand vertically to accommodate records.</li>
    //     <li><code>"horizontal"</code>: expand horizontally to accommodate fields.</li>
    //     <li><code>"both"</code>: expand horizontally and vertically to accommodate content.</li>
    // </ul>
    // How far the ListGrid will expand may be limited via the following properties:
    // +link{ListGrid.autoFitMaxHeight}, +link{ListGrid.autoFitMaxRecords},
    // +link{ListGrid.autoFitMaxWidth}, +link{ListGrid.autoFitMaxColumns}.
    // <P>
    // Note that this property causes the grid as a whole to expand to fit records or fields.
    // To have the fields or records themselves expand to fit cell contents, see
    // +link{listGrid.autoFitFieldWidths} and +link{listGrid.fixedRecordHeights}.
    // @group autoFitData
    // @visibility external
    //<

    //> @attr listGrid.autoFitMaxHeight (number : null : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"vertical"</code> or <code>"both"</code> this
    // property provides an upper limit on how far the ListGrid will expand vertically to accommodate
    // its content. If content exceeds this height, scrollbars will be introduced as usual.
    // In addition to this property, +link{ListGrid.autoFitMaxRecords} allows you to limit vertical
    // expansion based on the number of rows to be rendered.
    // @group autoFitData
    // @visibility external
    //<

    //> @attr ListGrid.autoFitMaxRecords (number : 50 : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"vertical"</code> or <code>"both"</code> this
    // property provides the maximum number of records for which the ListGrid will expand. If more
    // records are present, scrolling will be introduced to reach them as normal.
    // If unset, by default the ListGrid will expand to accommodate as many records as are present.
    // @group autoFitData
    // @visibility external
    //<
    autoFitMaxRecords:50,

    //> @attr ListGrid.autoFitExtraRecords (number : null : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"vertical"</code> or <code>"both"</code>
    // this property specifies the number of additional records for which the grid
    // will expand. If more
    // records are present, scrolling will be introduced to reach them as normal.
    // @group autoFitData
    // @visibility external
    //<
//    autoFitExtraRecords:0,

    //> @attr listGrid.autoFitMaxWidth (number : null : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"horizontal"</code> or <code>"both"</code>
    // this property provides an upper limit on how far the ListGrid will expand horizontally to
    // accommodate its content.
    // If content exceeds this width, scrollbars will be introduced as usual.
    // In addition to this property, +link{ListGrid.autoFitMaxColumns} allows you to limit
    // horizontal expansion based on the number of columns to be rendered.
    // @group autoFitData
    // @visibility external
    //<

    //> @attr ListGrid.autoFitMaxColumns (number : 50 : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"horizontal"</code> or <code>"both"</code>
    // this property provides the maximum number of columns for which the ListGrid will expand.
    // If more columns are present, scrolling will be introduced to reach them as normal.
    // If unset the ListGrid will expand to accommodate as many columns as are defined for the
    // grid.
    // @group autoFitData
    // @visibility external
    //<
    autoFitMaxColumns:50,


    //> @attr listGrid.canAutoFitFields (Boolean : true : IRW)
    // Can the user perform one-time autofit for specific columns in this grid?
    // <P>
    // If set to true, the default header menu will include options to auto fit
    // +link{listGrid.autoFitAllText,all fields} such that they fit their
    // content or titles as specified via +link{listGridField.autoFitWidthApproach}.<br>
    // Autofitting of individual fields via a
    // +link{listGrid.autoFitFieldText,header context menu item}, or the
    // +link{listGrid.headerAutoFitEvent} will also be enabled when this
    // property is set unless +link{listGridField.canAutoFitWidth} is explicitly set to false
    // <P>
    // Note that the ability to perform one-time autofitting of fields via this 
    // subsystem is separate from the programmatic autofit behavior enabled 
    // via +link{listGrid.autoFitFieldWidths}.
    // <P>
    // This subsystem is requires canResizeFields be enabled and will be disabled if
    // that property is set to false
    // @visibility external
    // @group autoFitFields
    //<
    
    canAutoFitFields:true,
    

    //> @type AutoFitEvent
    // Event on a listGrid header to trigger auto-fit of the listgrid field.
    // @value "doubleClick" React to a double click on the listGrid header.
    // @value "click" React to a click on the listGrid header.
    // @value "none" No event will trigger auto-fit.
    // @group autoFitFields
    // @visibility external
    //<

    //> @attr listGrid.headerAutoFitEvent (AutoFitEvent : "doubleClick" : IR)
    // Event on a ListGrid header that triggers auto fitting to data and/or title.
    // <P>
    // Note that if sorting is enabled for the field and the headerAutoFitEvent is "click", both
    // sorting and autofit occur on a click.
    // <P>
    // Only has an impact when +link{listGrid.canAutoFitFields} or 
    // +link{listGridField.canAutoFitWidth} is set to <code>true</code>.
    //
    // @visibility external
    // @group autoFitFields
    //<
    headerAutoFitEvent:"doubleClick",

    //> @attr listGridField.canAutoFitWidth (Boolean : null : IR)
    // Should the user be allowed to perform one-time autofitting of this field via
    // a header context-menu option?
    // <P>
    // When enabled, the default header context menu for this field will
    // include an item to auto-fit the field and users will be able to autofit the field
    // via the +link{listGrid.headerAutoFitEvent}.
    // <P>
    // If unset, these behaviors are enabled when +link{listGrid.canAutoFitFields} is true.
    // <P>
    // If this property is set to false, and +link{listGrid.canAutoFitFields} is true,
    // this field will be ommitted from auto-fit when the user selects the header menu 
    // option to +link{listGrid.autoFitAllText,auto fit all fields}.
    // <P>
    // Note - this property governs user-initiated auto-fit only. It has no impact on
    // autoFit set up via +link{listGridField.autoFitWidth} and +link{listGrid.autoFitFieldWidths}.
    // <P>
    // Note that if +link{listGrid.showRecordComponents,showing record components}, per-cell record
    // components are not taken into account when determining the size for column auto fit.
    // The default +link{listGrid.getDefaultFieldWidth()} implementation looks at cell content
    // only. We typically recommend that, for fields showing record-components, 
    // +link{listGridField.autoFitWidth} and +link{listGrid.canAutoFitFields} be disabled, or if 
    // the record components are of a predictable size, a +link{listGridField.defaultWidth}
    // be specified.<br>
    // This is particularly pertinent where +link{listGrid.recordComponentPosition}
    // is set to "within", in which case cells' content is often empty or completely covered
    // by record-components.
    //
    // @visibility external
    //<

    //> @attr listGridField.autoFitWidth (Boolean : null : IR)
    // Should this listGrid field autofit its width to either titles or content?
    // <P>
    // This overrides the +link{listGrid.autoFitFieldWidths} attribute on a per-field basis.
    // <P>
    // Note that if +link{listGrid.showRecordComponents,showing record components}, per-cell record
    // components are not taken into account when determining the size for column auto fit.
    // The default +link{listGrid.getDefaultFieldWidth()} implementation looks at cell content
    // only. We typically recommend that, for fields showing record-components, 
    // +link{listGridField.autoFitWidth} and +link{listGridField.canAutoFitWidth} be disabled, or if 
    // the record components are of a predictable size, a +link{listGridField.defaultWidth}
    // be specified.<br>
    // This is particularly pertinent where +link{listGrid.recordComponentPosition}
    // is set to "within", in which case cells' content is often empty or completely covered
    // by record-components.        
    //
    // @visibility external
    // @group autoFitFields
    //<
    
    //> @attr listGridField.defaultWidth (Integer : null : IR)
    // Optional "default width" for this field. If set, this value will be returned by the
    // +link{listGrid.getDefaultFieldWidth()} method, and used as the autoFit size for
    // the field's content.
    //
    // @visibility external
    // @group autoFitFields
    //<

    //> @attr listGrid.autoFitFieldWidths (Boolean : null : IR)
    // Should ListGrid fields autofit their widths to titles or content?
    // This property may be overridden on a per-field basis via +link{listGridField.autoFitWidth}.
    // Developers may wish to consider disabling autoFit for fields known to have 
    // exceptionally long content as this can lead to large horizontal scrollbars and unwieldy UI.
    // <P>
    // The +link{listGrid.autoFitWidthApproach} controls whether fitting is to values, titles
    // or both. This property may also be overridden on a per field basis.
    // <P>
    // If +link{listGridField.width,field.width} is also set on the field, it will be taken as a minimum width.
    // +link{listGrid.minFieldWidth} will also be respected.
    // <P>
    // By default, the entire available width of the grid will still be used, by allocating any "extra"
    // space to specific columns - see +link{listGrid.autoFitFieldsFillViewport} for details on
    // controlling this behavior.
    // <P>
    // When this feature is enabled, autofitting is active on an ongoing basis.
    // Autofitting will be performed:
    // <ul>
    //  <li> whenever the dataset is completely changed or rows are added or removed
    //  <li> whenever a field which is autofitting is changed
    //  <li> on a manual call to +link{listGrid.autoFitField()} or
    //       +link{listGrid.autoFitFields()}
    // </ul>
    // Auto-fitting behavior continues until the user resizes the field manually, at which
    // point it stops. The user can also perform a one-time auto-fit of fields via
    // the header context menu if +link{listGrid.canAutoFitFields} is enabled.
    // <P>
    // When autofitting to column values, +link{listGrid.getDefaultFieldWidth()} will be
    // called to determine the space required for a field's values. This method
    // uses values from the rendered set of rows to calculate the required column width, which means the
    // field width may still be smaller than values from non-rendered rows.  See
    // +link{listGrid.showAllRecords} and +link{listGrid.drawAheadRatio}) to control incremental
    // rendering of rows.
    // <P>
    // Note that for <code>icon</code> type fields, the +link{listGrid.autoFitIconFields}
    // property setting may turn on auto-fit-width behavior for specific fields by default,
    // even if <code>autoFitFieldWidths</code> is false for the grid as a whole.
    // <P>
    // Using this feature has a performance penalty roughly comparable to always rendering
    // one additional field per field where autofitting is enabled.  Specifically, enabling it
    // for all fields would be comparable to <i>both</i> doubling the number of fields
    // <i>and</i> disabling +link{listGrid.showAllColumns,horizontal incremental rendering}.
    // In a grid where only half the fields are normally visible and hence only half are
    // normally rendered, this would be roughly 4 times slower overall.
    // <P>
    // This performance penalty is a result of +link{getDefaultFieldWidth()} having to
    // render out the data set offscreen and measure the rendered content - it does not apply
    // for cases where this method can return a simple fixed values (as with icon fields).
    // <P>
    // Which fields are currently autofitting is saved as part of the
    // +link{getViewState,view state} of the ListGrid.
    //
    // @visibility external
    // @group autoFitFields
    //<

    //> @attr listGrid.autoSizeHeaderSpans (Boolean : false : IR)
    // If this listGrid has specified +link{listGrid.headerSpans}, setting this
    // attribute to true will cause spans to expand to accommodate long titles if necessary.
    // @visibility external
    // @group headerSpan
    // @group autoFitFields
    //<
    autoSizeHeaderSpans:false,


    //> @attr listGrid.autoFitClipFields (Array of String : null : IR)
    // If +link{listGrid.autoFitFieldWidths} is enabled and the calculated field sizes
    // are wide enough that horizontal scrolling would be introduced, this attribute may be
    // set to an array of fieldNames, causing those fields to be clipped rather than
    // forcing horizontal scrollbars to appear.
    // <P>
    // Note: If any +link{ListGridField.frozen,frozen columns} are included in this list they
    // will not be clipped.
    // @group autoFitFields
    // @visibility external
    //<

    //> @attr listGrid.autoFitFieldsFillViewport (Boolean : true : IR)
    // If +link{listGrid.autoFitFieldWidths} is enabled, and extra space is available after
    // autofitting all fields, should the grid automatically expand one field to fill the extra
    // space.
    // <P>
    // When enabled, the field to expand may be specified via +link{autoFitExpandField}.
    // <P>
    // Note this logic will not expand a +link{ListGridField.frozen,frozen column}.
    //
    // @group autoFitFields
    // @visibility external
    //<
    autoFitFieldsFillViewport:true,

    //> @attr listGrid.autoFitExpandField (String : null : IR)
    // The field to expand if +link{listGrid.autoFitFieldWidths} and
    // +link{autoFitFieldsFillViewport} are enabled and
    // auto-fitting will not fill all available horizontal space.
    // <P>
    // If unset, will default to the text field with the longest
    // +link{dataSourceField.length} if length is set, otherwise, the first text
    // field with no width specified.
    // <P>
    // Note that expanding +link{ListGridField.frozen,frozen columns} is not supported.
    // @group autoFitFields
    // @visibility external
    //<

    //> @type AutoFitWidthApproach
    // How should field width be determined when +link{listGridField.autoFitWidth} is true?
    // @value "value" Size field to fit to the data value(s) contained in the field.
    // @value "title" Size field to fit the field title
    // @value "both" Size field to fit either the field title or the data values in the field
    //  (whichever requires more space).
    //
    // @group autoFitFields
    // @visibility external
    //<

    //> @attr listGrid.autoFitWidthApproach (AutoFitWidthApproach : "value" : [IRW])
    // When a user requests column autofitting via the
    // +link{getHeaderContextMenuItems,header context menu} or via a
    // +link{headerAutoFitEvent,mouse gesture}, what autofit approach is used.
    // @group autoFitFields
    // @visibility external
    //<
    autoFitWidthApproach:"value",

    // If we're autoFitting to values, and we're showing a grid summary, should the
    // grid summary values be taken into account when sizing columns?
    // By default they are - set this flag to false to disable this behavior.
    includeGridSummaryInAutoFitWidth:true,

    //> @attr listGridField.autoFitWidthApproach (AutoFitWidthApproach : null : [IRW])
    // When a user requests column autofitting via the
    // +link{listGrid.getHeaderContextMenuItems,header contextMenu} or via a
    // +link{listGrid.headerAutoFitEvent,mouse gesture}, what autofit approach is used. If set, this
    // setting overrides the autoFitWidthApproach specified at the ListGrid level.
    // @group autoFitFields
    // @visibility external
    //<

    //> @type AutoFitIconFieldType
    // How should fields of +link{listGridFieldType,type:"icon"} be sized by default?
    // @value "none" Apply no special sizing to icon fields - treat them like any other
    //   field in the grid
    // @value "iconWidth" size the field to accommodate the width of the icon
    // @value "title" size the field to accommodate the title (or the width of the icon if
    //   it exceeds the width of the title.
    //
    // @group autoFitFields
    // @visibility external
    //<

    //> @attr listGrid.autoFitIconFields (AutoFitIconFieldType : "title" : [IRW])
    // SmartClient listGrids have special logic to automatically size fields that
    // are displayed as an icon - that is fields with
    // +link{listGridFieldType,type:"icon"}, fields displaying only
    // +link{listGridField.showValueIconOnly,value icons}, and boolean fields (which
    // are rendered as a checkmark type icon by default.
    // <P>
    // This attribute controls this behavior - governing whether icon fields should
    // be sized to fit their content (icon), title, or whether to disable this
    // behavior. Setting this value to <code>"title"</code> or <code>"iconWidth"</code>
    // will cause +link{listGridField.autoFitWidth} to be enabled by default for all
    // icon fields with the +link{listGridField.autoFitWidthApproach} set to
    // <code>"value"</code> or <code>"both"</code> as appropriate. Note that the
    // width required for the icons is calculated by +link{listGrid.getDefaultFieldWidth()}
    // which performs a simple calculation based on the specified icon width for these
    // types of fields.
    // <P>
    // This setting governs default behavior for icon fields - for specific fields within
    // a grid, this default behavior can be overridden by setting an explicit
    // +link{listGridField.width} or
    // explicitly enabling +link{listGridField.autoFitWidth} and setting
    // +link{listGridField.autoFitWidthApproach} on the field in question.
    // @see listGrid.autoFitFieldWidths
    // @group autoFitFields
    // @visibility external
    //<
    autoFitIconFields:"title",

    //> @attr listGrid.leaveScrollbarGap (Boolean : true : IRW)
    // Whether to leave a gap for the vertical scrollbar, even when it's not present.
    // <P>
    // Note that if leaveScrollbarGap is false and vertical scrolling is introduced, fields
    // will be resized to fit the smaller body area if possible, in order to avoid horizontal
    // scrolling also being required.
    //
    // @group appearance
    // @visibility external
    // @example autofitRows
    //<
    
    leaveScrollbarGap:true,

    // leaveScrollbarGap has meaning at the Layout level. We don't expect to ever show a vscrollbar
    // at the actual ListGrid level so override 'getBreadth' to avoid leaving a gap outside the
    // actual component members (header, body etc).
    getBreadth : function () {
        return this.getInnerWidth();
    },

    // if leaveScrollbarGap is false, whether to resize fields when vscrolling is introduced
    resizeFieldsForScrollbar:true,

    //> @attr listGrid.autoFit (boolean : false : IRWA)
    // If true, make columns only wide enough to fit content, ignoring any widths specified.
    // Overrides fixedFieldWidths.
    // <P>
    // NOTE: the header does not automatically respond to expanded field widths
    //  @group  sizing
    //<
    
    //autoFit:false,

    //> @attr listGrid.wrapCells (Boolean : false : IRWA)
    // Should content within cells be allowed to wrap?
    // <P>
    // Even if content is allowed to wrap, if +link{fixedRecordHeights} is set, the content
    // will be clipped off at the cell boundary.  Either set a larger, fixed +link{cellHeight}
    // to reveal more content, or set +link{fixedRecordHeights} to false to allow auto-sizing.
    //
    // @example autofitValues
    // @visibility external
    //<
    //wrapCells:false,

    //> @attr listGrid.showClippedValuesOnHover (Boolean : null : IRA)
    // @include gridRenderer.showClippedValuesOnHover
    //<
    showClippedValuesOnHover:null,

    //> @attr listGrid.cellSpacing (number : 0 : [IRW])
    // @include gridRenderer.cellSpacing
    // @visibility internal
    //<
    
    cellSpacing:0,

    //> @attr listGrid.cellPadding (number : 2 : [IRW])
    // @include gridRenderer.cellPadding
    //<
    cellPadding:2,

    //> @attr listGrid.dateFormatter (DateDisplayFormat : null : [IRW])
    // How should Date type values be displayed in this ListGrid by default?
    // <P>
    // This property specifies the default DateDisplayFormat to apply to Date values
    // displayed in this grid for all fields except those of +link{listGridField.type,type "time"}
    // (See also +link{listGrid.timeFormatter}).<br>
    // If +link{listGrid.datetimeFormatter} is specified, that will be applied by default
    // to fields of type <code>"datetime"</code>.
    // <P>
    // Note that if +link{listGridField.dateFormatter} or +link{listGridField.timeFormatter} are
    // specified those properties will take precedence over the component level settings.
    // <P>
    // If unset, date values will be formatted according to the system wide
    // +link{Date.setShortDisplayFormat(),short display format} or
    // +link{Date.setShortDatetimeDisplayFormat(),short datetime display format} for datetime type
    // fields.
    // <P>
    // If this field is editable the dateFormatter will also be passed to the editor created
    // to edit this field as +link{DateItem.dateFormatter, dateFormatter}.
    // In this case you may also need to set +link{listGrid.dateInputFormat}.
    //
    // @visibility external
    //<
    //dateFormatter:null,

    //> @attr listGrid.datetimeFormatter (DateDisplayFormat : null : [IRW])
    // Display format to use for fields specified as type 'datetime'.  Default is to use the
    // system-wide default date time format, configured via
    // +link{Date.setShortDatetimeDisplayFormat()}.  Specify any
    // valid +link{type:DateDisplayFormat} to change the display format for datetimes used by this grid.
    // <smartclient>
    // May be specified as a function. If specified as  a function, this function will be executed in the scope of the Date
    // and should return the formatted string.
    // </smartclient>
    // <P>
    // May also be specified at the field level via
    // +link{listGridField.dateFormatter}
    // <P>
    // If this field is editable the dateFormatter will also be passed to the editor created
    // to edit this field as +link{DateItem.dateFormatter, dateFormatter}.
    // In this case you may also need to set +link{listGrid.dateInputFormat}.
    //
    // @see listGridField.dateFormatter
    // @group appearance
    // @visibility external
    //<

    //> @attr listGrid.dateInputFormat (DateInputFormat : null : [IRWA])
    // If this is an editable listGrid, this property will specify the
    // +link{DateItem.inputFormat, inputFormat} applied to editors for fields of type
    // <code>"date"</code>. May be overridden per field via +link{listGridField.inputFormat}.
    // @see listGrid.dateFormatter
    // @visibility external
    //<

    // function to call appropriate date formatter
    // Note: this is executed in the scope of a field object - see 'applyFieldDefaults'
    _formatDateCellValue : function (value, field, grid, record, rowNum, colNum) {

        if (isc.isA.Date(value)) {
            // A developer may force a "date" or "datetime" type field value to be displayed as time
            // by specifying a timeFormatter and no dateFormatter on the field.
            if (grid._formatAsTime(field)) {
                var formatter = grid._getTimeFormatter(field);
                var isLogicalTime = isc.SimpleType.inheritsFrom(field.type, "time");
                return isc.Time.toTime(value, formatter, isLogicalTime);
            }

            var isDatetime = field && isc.SimpleType.inheritsFrom(field.type, "datetime"),
                isLogicalDate = !isDatetime && isc.SimpleType.inheritsFrom(field.type, "date"),
                formatter = grid._getDateFormatter(field);

            // rely on date.toShortDateTime() / toShortDate() to handle applying the
            // custom formatter if specified, otherwise picking up the appropriate system-wide
            // default for the data type.
            // The second parameter to toShortDateTime() explicitly causes the date to be displayed
            // in the custom timezone set up in Time.setDefaultDisplayTimezone
            if (isDatetime) return value.toShortDateTime(formatter, true);
            return value.toShortDate(formatter, !isLogicalDate);
        }
        return value;
    },

    // Date formatting helpers:
    // Called from formatDateCellValue() / formatTimeCellValue() [which are type-specific formatters
    // applied to fields as part of field init], and also as a catch-all for
    // Date type values in fields of some other specified data-type.
    // We use a consistent pattern across DataBoundComponents:
    // - developer can specify explicit dateFormatter / timeFormatter per field and they'll be used.
    //   if both are specified dateFormatter takes precedence except in "time" type fields.
    // - developer can specify dateFormatter, datetimeFormatter and timeFormatter per component and
    //   they'll be used if no per-field settings are found.

    // If a field has a JS Date value, should we format it as a time? True for "time" type fields
    // or fields with an explicit time formatter only.
    _formatAsTime : function (field) {
        if (field == null) return false;

        // If at the field level the timeFormatter is defined *(and there's no date formatter)
        // respect it.
        if (field.timeFormatter != null && field.dateFormatter == null) return true;
        // timeFormatter null and dateFormatter non-null --> format as date
        
        if (field.dateFormatter != null && field.timeFormatter == null) return false;
        return isc.SimpleType.inheritsFrom(field.type, "time");
    },

    _getDateFormatter : function (field) {
        
        if (field == null) return this.dateFormatter;

        if (field.dateFormatter != null) return field.dateFormatter;
        // displayFormat is back-compat at this point - only applies to fields of type
        // date or datetime (or subtypes thereof)
        if (field.displayFormat != null && isc.SimpleType.inheritsFrom(field.type, "date")) {
            return field.displayFormat;
        }

        if (this.datetimeFormatter != null && isc.SimpleType.inheritsFrom(field.type, "datetime")) {
            return this.datetimeFormatter;
        }

        return this.dateFormatter;
    },

    // This picks up *explicit* dateInputFormat to pass through to the edit-item. No need to
    // include logic to derive from the display format if no explicit input format was specified,
    // that'll be handled by the FormItem code.
    _getDateInputFormat : function (field) {
        var inputFormat;
        if (field) inputFormat = field.inputFormat
        if (!inputFormat) inputFormat = this.dateInputFormat;
        return inputFormat;
    },

    // function to call appropriate number formatter
    // If no number formatter is defined, the default formatter will be used [standard 'toString']
    // is the default
    _formatNumberCellValue : function (value, field, grid, record, rowNum, colNum) {
        if (isc.isA.Number(value)) {
            if (isc.SimpleType.inheritsFrom(field.type, "float") &&
                (field.decimalPrecision != null || field.decimalPad != null))
            {
                return isc.Canvas.getFloatValueAsString(
                        value, field.decimalPrecision, field.decimalPad);
            } else if (field.precision != null) {
                return isc.Canvas.getNumberValueAsString(value, field.precision, field.type);
            } else {
                var formatter = (field.numberFormatter || field.formatter || grid.numberFormatter);
                return value.toFormattedString(formatter);
            }
        }

        // If passed a non-number just return it
        return value;
    },

    //> @attr listGrid.timeFormatter (TimeDisplayFormat : "toShortPaddedTime" : [IRW])
    // Display format to use for fields specified as type 'time'.  May also be specified at
    // the field level via +link{listGridField.timeFormatter}.<br>
    // If unset, time fields will be formatted based on the system wide
    // +link{Time.shortDisplayFormat}.<br>
    // If this field is editable, the timeFormatter will also be passed to the editor
    // created to edit any time type fields as +link{TimeItem.timeFormatter}
    // @group appearance
    // @visibility external
    //<
    timeFormatter:"toShortPaddedTime",

    _getTimeFormatter : function (field) {
        if (field != null) {
            if (field.timeFormatter != null) return field.timeFormatter;
            if (field.displayFormat != null && isc.SimpleType.inheritsFrom(field.type, "time")) {
                return field.displayFormat;
            }
        }
        return this.timeFormatter;
    },

    // function to call appropriate time formatter
    // Note: this is executed in the scope of a field object - see 'applyFieldDefaults'
    _formatTimeCellValue : function (value, field, grid, record, rowNum, colNum) {
        var time = value;
        if (isc.isA.String(time)) {
            // Pass in the 'validTime' param - If we're given a string which doesn't
            // parse to a time we don't want to display "12:00 am"
            time = isc.Time.parseInput(time, true);
        }
        if (isc.isA.Date(time)) {
            // If dateFormatter is set on the field, and timeFormatter is not, we respect it
            // even for fields of explicit type "time"
            if (!grid._formatAsTime(field)) {
                
                return time.toShortDate(grid._getDateFormatter(field), true);
            }
            var formatter = grid._getTimeFormatter(field);

            // If we're passed an invalid formatter
            return isc.Time.toTime(time, formatter, true);
        }
        return value;
    },

    _formatBinaryCellValue : function (value, field, grid, record, rowNum, colNum) {
        
        if (isc.isA.String(value)) return value;
        if (record == null) return null;

        var fieldName = field.name,
            ds = grid.getDataSource(),
            filenameField = (ds ? ds.getFilenameField(fieldName) : null) || fieldName + "_filename",
            fileName = record[filenameField],
            value
        ;

        if (field.type=="imageFile" && field.showFileInline == true) {
            var urlProperty = fieldName + "_imgURL";

            if (!record[urlProperty]) {
                var dimensions = isc.Canvas.getFieldImageDimensions(field, record),
                    image = grid.getDataSource().getFileURL(record, field.name);

                dimensions.width = dimensions.width || grid.imageSize;
                dimensions.height = dimensions.height || grid.imageSize;
                value = record[urlProperty] =
                    isc.Canvas.imgHTML(image, dimensions.width, dimensions.height,
                                       null, null, isc.Canvas._$allowRelativeSrc);
            } else
                value = record[urlProperty];
        } else {
            if (field.showFileInline == true) { // non-imageFile field
                this.logWarn("_formatBinaryCellValue(): Unsupported field-type for showFileInline: "+field.type);
            }

            
            if (!field.filenameSuppressed && (fileName == null || isc.isAn.emptyString(fileName))) {
                return this.emptyCellValue;
            }

            var viewAction = "'" + grid.getID() +".view",
                dlAction = "'" + grid.getID() +".download",
                completion = "";
            if (field && field.name) {
                completion = "Cell(" + rowNum + ", \"" + field.name + "\")'";
            } else {
                completion = "Row(" + rowNum + ")'";
            }
            var viewIconHTML = isc.Canvas.imgHTML({
                src: "[SKIN]actions/view.png",
                width: 16,
                height: 16,
                extraCSSText: "cursor:" + isc.Canvas.HAND,
                extraStuff: " onclick=" + viewAction + completion
            });
            var downloadIconHTML = isc.Canvas.imgHTML({
                src: "[SKIN]actions/download.png",
                width: 16,
                height: 16,
                extraCSSText: "cursor:" + isc.Canvas.HAND,
                extraStuff: " onclick=" + dlAction + completion
            });

            value = viewIconHTML + "&nbsp;" + downloadIconHTML +
                (fileName ? "&nbsp;" + fileName : "");
        }

        return value;
    },

    // value is rendered as an anchor - the href and name of the anchor is the value.  By default
    // opens in a new browser window - this can be overridden by setting the 'target' property on
    // the record.
    //
    // The name of the link can be overridden by setting the 'linkName' property on the record.  By
    // default we use the value.
    _$linkTemplate:[
        "<a href='",
        ,   // 1: HREF
        "' target='",
        ,   // 3: name of target window
        // onclick handler enables us to prevent popping a window if (EG) we're masked.
        //                      5: ID
        "' onclick='if(window.",     ,") return ",
                //  7:ID                         9:rowNum,     11:colNum
                         ,"._linkClicked(event,",        ,",",          ,");'>",
        ,   // 13: link text
        "</a>"
    ],
    _$doubleEscapedQuote:"\\'",
    _$_blank:"_blank",

    _formatLinkCellValue : function (value, field, grid, record, rowNum, colNum) {
        if (value == null || isc.is.emptyString(value)) return value;

        // target window
        var target = field.target ?
                        field.target.replaceAll(grid._$singleQuote, grid._$doubleEscapedQuote) :
                        grid._$_blank;
        // get the linkText property. If defined on the field, use that, otherwise
        // use the linkTextProperty from the grid.
        var linkTextProp = field.linkTextProperty ? field.linkTextProperty : grid.linkTextProperty;
        var linkText = (record && record[linkTextProp]) ? record[linkTextProp]
                                                            : field.linkText || value;

        // link URL
        var href = value;

        if (field.linkURLPrefix) href = field.linkURLPrefix + href;
        if (field.linkURLSuffix) href = href + field.linkURLSuffix;

        href = href.replaceAll(grid._$singleQuote, grid._$doubleEscapedQuote);

        if (target == "javascript") {
            // target is "javascript" - make the link inert and have the cellClick event fired
            // instead
            href = "javascript:void";
        }

        // combine
        var template = grid._$linkTemplate;
        template[1] = href;
        template[3] = target;
        var ID = grid.getID();
        template[5] = ID;
        template[7] = ID;
        template[9] = rowNum;
        template[11] = colNum;
        template[13] = linkText;

        return template.join(isc.emptyString);
    },

    _linkClicked : function (event, rowNum, colNum) {
        // don't allow the click if the cell should not be interactive.
        var record = this.getRecord(rowNum),
            mustCancel = (
                this.destroyed || !this.isDrawn() || !this.isVisible() ||
                isc.EH.targetIsMasked(this.body) ||
                !this.recordIsEnabled(record, rowNum, colNum)),
            field = this.getField(colNum);

        if (event.target == "javascript" || field.target == "javascript") {
            mustCancel=true;
            this.cellClick(record, rowNum, colNum);
        }

        if (mustCancel) {
            
            if (!isc.Browser.isIE) {
                event.preventDefault();
            }

            return false;
        }
        return true;
    },

    //> @attr listGrid.linkTextProperty (string : "linkText" : [IRW])
    // Property name on a record that will hold the link text for that record.
    // <P>
    // This property is configurable to avoid possible collision with data values in the
    // record.
    // <P>
    // Use +link{listGridField.linkTextProperty} if you have more than one link field and
    //
    // @see type:ListGridFieldType
    // @see type:FieldType
    // @see attr:listGridField.linkText
    // @see attr:listGridField.linkTextProperty
    // @group  display_values
    // @visibility external
    //<
    linkTextProperty : "linkText",

    // value is a URL to an image
    _formatImageCellValue : function (value, field, grid, record, rowNum, colNum) {
        // if no value is stored, just return an empty string so we don't render a broken image
        if (value == null || value == isc.emptyString) return isc.emptyString;

        // if any of field.imageWidth/Height/Size are set as strings, assume they are property
        // names on the record
        
        var dimensions = isc.Canvas.getFieldImageDimensions(field, record);

        dimensions.width = dimensions.width || grid.imageSize;
        dimensions.height = dimensions.height || grid.imageSize;

        
        var src = value,
            prefix = field.imageURLPrefix || field.baseURL || field.imgDir;

        // If imageURLSuffix is specified, apply it to the value
        if (field.imageURLSuffix != null) src += field.imageURLSuffix;

        

        return isc.Canvas.imgHTML(src, dimensions.width, dimensions.height, null, field.extraStuff,
                                  prefix, field.activeAreaHTML);
    },

    // show field.icon in the cell
    _formatIconCellValue : function (value, field, grid, record, rowNum, colNum) {
        // prevent an icon from being shown in the filter editor if the field has canFilter
        if (isc.isA.RecordEditor(grid) && grid.isAFilterEditor() && field.canFilter == false) return null;

        if (field._iconHTML) return field._iconHTML;

        field._iconHTML = isc.Canvas.imgHTML(field.cellIcon || field.icon,
                                             field.iconWidth || field.iconSize || grid.imageSize,
                                             field.iconHeight || field.iconSize || grid.imageSize);
        return field._iconHTML;
    },

    // CSS styles
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.fastCellUpdates (Boolean: true : I)
    // @include gridRenderer.fastCellUpdates
    // @group performance
    //<
    // explicitly set fastCellUpdates at the LG level
    // this will be passed through to our body and allows us to check
    // this.fastCellUpdates directly rather than looking at the attribute on the body
    
    fastCellUpdates:isc.Browser.isIE && !isc.Browser.isIE9,

    //> @method listGrid.setFastCellUpdates()
    // @include gridRenderer.setFastCellUpdates()
    // @visibility external
    //<
    // explicit implementation keeps this.fastCellUpdates in sync with the version in the
    // body so we can check it directly in this.getBaseStyle
    setFastCellUpdates : function (fcu) {
        if (this.body != null) {
            this.body.setFastCellUpdates(fcu);
            // if the body refused to set to the specified
            // value, respect that.
            fcu = this.body.fastCellUpdates;
        }
        if (this.frozenBody != null) {
            this.frozenBody.setFastCellUpdates(fcu);
        }
        this.fastCellUpdates = fcu;
    },

    //> @attr listGrid.baseStyle (CSSStyleName : null : [IR])
    // +link{gridRenderer.baseStyle,base cell style} for this listGrid.
    // If this property is unset, base style may be derived from +link{listGrid.normalBaseStyle}
    // or +link{listGrid.tallBaseStyle} as described in
    // +link{listGrid.getBaseStyle()}.
    // <P>
    // See +link{group:cellStyleSuffixes} for details on how stateful suffixes are combined
    // with the base style to generate stateful cell styles.
    //
    // @visibility external
    // @group appearance
    //<

    //> @attr listGrid.normalBaseStyle (CSSStyleName : "cell" : [IR])
    // "Normal" baseStyle for this listGrid. Only applies if +link{listGrid.baseStyle} is
    // set to null.
    // <P>
    // If <code>baseStyle</code> is unset, this
    // property will be used as a base cell style if the grid is showing fixed height rows, and
    // the specified cellHeight matches +link{listGrid.normalCellHeight} (and in Internet Explorer,
    // +link{listGrid.fastCellUpdates} is false). Otherwise +link{listGrid.tallBaseStyle} will
    // be used.
    // <P>
    // Having separate styles defined for fixed vs. variable height rows allows the developer
    // to specify css which is designed to render at a specific height (typically using
    // background images, which won't scale), without breaking support for styling rows
    // of variable height.
    // <P>
    // See +link{group:cellStyleSuffixes} for details on how stateful suffixes are combined
    // with the base style to generate stateful cell styles.
    //
    // @see listGrid.getBaseStyle()
    // @visibility external
    //<
    normalBaseStyle:"cell",

    //> @attr listGrid.tallBaseStyle (CSSStyleName : "cell" : [IR])
    // "Tall" baseStyle for this listGrid. Only applies if +link{listGrid.baseStyle} is
    // set to null.
    // <P>
    // If <code>baseStyle</code> is unset, this
    // property will be used as a base cell style unless the grid is showing fixed height
    // rows with a specified cellHeight that matches +link{listGrid.normalCellHeight}, in
    // which case +link{listGrid.normalBaseStyle} will be used. Note that in Internet Explorer
    // if +link{listGrid.fastCellUpdates} is true, <code>tallBaseStyle</code> will also be
    // used even if the cellHeight matches the specified <code>normalCellHeight</code> for the
    // grid.
    // <P>
    // See +link{group:cellStyleSuffixes} for details on how stateful suffixes are combined
    // with the base style to generate stateful cell styles.
    //
    // @see listGrid.getBaseStyle()
    // @visibility external
    //<
    tallBaseStyle:"cell",

    
    

    //> @attr listGrid.editFailedBaseStyle (CSSStyleName : null : [IRWA])
    //  A base name for the CSS class applied to cells when editing has failed.<br>
    //  If this listGrid is editable, this style will be applied to any edited cells for which
    //  validation failed.<br>
    //  As with the default 'baseStyle' property, this style will have "Dark", "Over", "Selected",
    //  or "Disabled" appended to it according to the state of the cell.<br>
    // If null, cells for which editing has failed will be rendered using the normal base style
    // classNames, but with custom CSSText applied as derived from <code>this.editFailedCSSText</code>
    // @visibility external
    // @group   appearance
    // @see baseStyle
    // @see editFailedCSSText
    //<
    editFailedBaseStyle:null,   //"cellEditFailed",

    //> @attr listGrid.editFailedCSSText (string : "color:red;border:1px solid red;" : [IRWA])
    //  Custom CSS text to be applied to cells when editing has failed.<br>
    //  If this listGrid is editable, this css text will be applied to any edited cells for which
    //  validation failed, on top of the base style for the cell.<br>
    // For further customization of styling for cells that failed editing validation, use
    // <code>this.editFailedBaseStyle</code> instead.
    // @visibility external
    // @group   appearance
    // @see editFailedBaseStyle
    //<
    editFailedCSSText:"color:red;border:1px solid red;",

    //> @attr listGrid.editPendingBaseStyle (CSSStyleName : null : [IRA])
    // A base name for the CSS class applied to cells containing pending (unsaved) edits<br>
    // As with the default 'baseStyle' property, this style will have "Dark", "Over", "Selected",
    // or "Disabled" appended to it according to the state of the cell.
    // <P>
    // If this property is null (the default setting), cells with pending edits will pick up
    // custom css text to be applied on top of the normal base style from
    // <code>this.editPendingCSSText</code>.
    //
    // @group appearance
    // @see baseStyle
    // @visibility external
    //<
    editPendingBaseStyle:null, //"cellEditPending",

    //> @attr listGrid.editPendingCSSText (string : "color:#0066CC;" : [IRWA])
    // Custom CSS text to be applied to cells with pending edits that have not yet been
    // submitted.<br>
    // For further customization of styling for cells with pending edits use
    // <code>this.editPendingBaseStyle</code> instead.
    // @group appearance
    // @see editFailedBaseStyle
    // @visibility external
    //<
    editPendingCSSText:"color:#0066CC;",

    //> @attr listGrid.recordCustomStyleProperty (String : "customStyle" : IRW)
    // @include GridRenderer.recordCustomStyleProperty
    // @visibility external
    // @see listGrid.getCellStyle()
    // @see listGrid.recordBaseStyleProperty
    //<
    recordCustomStyleProperty:"customStyle",

    //> @attr listGrid.recordBaseStyleProperty (string : "_baseStyle" : [IRWA])
    // This attribute allows custom base styles to be displayed on a per-record basis.
    // To specify a custom base-style for some record set
    // <code>record[listGrid.recordBaseStyleProperty]</code> to the desired base style name -
    // for example if <code>recordBaseStyleProperty</code> is <code>"_baseStyle"</code>, set
    // <code>record._baseStyle</code> to the custom base style name.
    //
    // @visibility external
    // @group appearance
    // @see listGrid.baseStyle
    //<
    recordBaseStyleProperty:"_baseStyle",

    //> @attr listGrid.frozenBaseStyle (string : null : [IRW])
    // If this listGrid contains any frozen fields, this property can be used to apply a custom
    // baseStyle to all cells in those frozen fields. If unset, the standard base style will be
    // used for both frozen and unfrozen cells.
    // @visibility external
    // @group appearance, frozenFields
    // @see listGrid.baseStyle
    // @see listGridField.frozen
    //<

    //> @attr listGrid.shrinkForFreeze (Boolean : false : IRWA)
    // If this list grid is showing any +link{listGridField.frozen,frozen} fields, and a horizontal
    // scrollbar is visible at the bottom of the liquid columns, should an equivalent scrollbar gap
    // be left visible below the frozen columns?<br>
    // Note that if set to <code>true</code> any backgroundColor or border applied to the ListGrid
    // will show up below the bottom row of the frozen column(s).
    // @group frozenFields
    // @visibility external
    //<
    shrinkForFreeze:false,

    //> @attr listGrid.alternateRecordStyles (Boolean : false : [IRW])
    // @include gridRenderer.alternateRowStyles
    // @group cellStyling
    // @example gridCells
    //<
    //alternateRecordStyles:false,

    //> @attr listGrid.alternateFieldStyles (boolean : false : [IRW])
    // @include gridRenderer.alternateColumnStyles
    // @visibility external
    // @group cellStyling
    //<
    //alternateFieldStyles:false,

    //> @attr listGrid.alternateFieldFrequency (number : 1 : [IRW])
    // @include gridRenderer.alternateColumnFrequency
    // @visibility external
    // @group cellStyling
    //<
    alternateFieldFrequency:1,

    //> @attr listGrid.alternateBodyStyleName (CSSStyleName : null : [IRWA])
    // Optional css style to apply to the body if +link{listGrid.alternateRecordStyles} is true
    // for this grid. If unset +link{listGrid.bodyStyleName} will be used to style the body
    // regardless of the +link{listGrid.alternateRecordStyles,alternateRecordStyles} setting.
    // @visibility external
    //<

    //> @attr listGrid.alternateRecordFrequency (number : 1 : [IRW])
    // @include gridRenderer.alternateRowFrequency
    // @group cellStyling
    //<
    alternateRecordFrequency:1,

    // property you can set per-record to add custom CSSText
    recordCSSTextProperty : "cssText",

    //> @attr listGrid.includeHilitesInSummaryFields
    // @include dataBoundComponent.includeHilitesInSummaryFields
    // @visibility external
    //<

    //> @method listGrid.shouldIncludeHiliteInSummaryField()
    // @include dataBoundComponent.shouldIncludeHiliteInSummaryField
    // @visibility external
    //<

    //> @attr listGrid.showHiliteInCells (boolean : false : IRWA)
    // When cell styling is being updated (updateCellStyle()), should the HTML content of the
    // cell also be updated?  If false, only the cell's CSS styling will be updated.
    //
    // You should turn this on if you've implemented 
    // +link{listGrid.formatCellValue(),formatting} that adds styling cues to a cell
    // (like an inline image), which need be updated as the cell switches states.
    // (eg, if you would use different HTML for a selected cell's contents).
    //      @group  hiliting, drawing
    //<
    //showHiliteInCells:false,

    //> @attr listGrid.showHilitesInGroupSummary (boolean : true : IRW)
    // Determines whether hiliting for any field in this grid is shown in a group summary.
    // This setting affects all fields of the grid.
    // <P>
    // To suppress hilites for a specific field see +link{listGridField.showHilitesInGroupSummary}.
    // <P>
    // Hiliting in summary fields (columns) can be enabled by setting
    // +link{listGrid.includeHilitesInSummaryFields,includeHiliteInSummaryField} to true.
    //
    // @visibility external
    //<
    showHilitesInGroupSummary:true,

    //> @attr listGrid.hiliteCanReplaceValue (boolean : null : IR)
    // If set, end users can create advanced hiliting rules that will use the
    // +link{hilite.replacementValue} feature to cause values in hilited cells
    // to be replaced with a user-entered value.  For example, a user could create a hilite rule
    // that replaces numeric values ranging from 0.5 to 1.0 with the text "LOW".
    // <p>
    // Specifically, when the "Add Advanced Rule" button is pressed and
    // <code>hiliteCanReplaceValue</code> is true, the user will see a text entry field titled
    // "Replace value with" (+link{hiliteReplaceValueFieldTitle}) and if they enter a value, that
    // value will appear in the grid cell in lieu of the cell's original value.
    //
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGrid.hiliteReplaceValueFieldTitle (string : "Replace value with" : IR)
    // Title used for the text box shown when +link{listGrid.hiliteCanReplaceValue} is set.
    // @group i18nMessages
    // @visibility external
    //<
    hiliteReplaceValueFieldTitle : "Replace value with",
    
    //> @attr listGrid.hiliteHTMLAfterFormat (boolean : true : IR)
    // If set to true, custom HTML applied as part of hiliting will be applied after
    // +link{listGrid.formatCellValue(),formatting} for each cell. If false, hilite
    // HTML will be applied before formatting.
    // <P>
    // This applies to the following hilite properties:
    // <ul>
    // <li>+link{Hilite.replacementValue}</li>
    // <li>+link{Hilite.htmlBefore}</li>
    // <li>+link{Hilite.htmlAfter}</li>
    // <li>+link{Hilite.htmlValue}</li>
    // </ul>
    // <P>
    // May be overridden per field via +link{listGridField.hiliteHTMLAfterFormat}
    //
    // @visibility external
    //<
    // Also the undocumented
    // <li>+link{Hilite.htmlOpposite}</li>
    hiliteHTMLAfterFormat:true,

    //> @attr listGridField.hiliteHTMLAfterFormat (Boolean : null : IR)
    // If set to true, custom HTML applied as part of hiliting will be applied after
    // +link{listGrid.formatCellValue(),formatting} for each cell in this column. If false, hilite
    // HTML will be applied before formatting.
    // <P>
    // This attribute overrides +link{listGrid.hiliteHTMLAfterFormat} as defined at the
    // component level.
    //
    // @visibility external
    //<

    //> @attr listGrid.showSelectedStyle (Boolean : true : IRW )
    // @include gridRenderer.showSelectedStyle
    //<
    showSelectedStyle : true,

    // Keyboard handling
    // ---------------------------------------------------------------------------------------

    //> @attr listGrid.generateClickOnSpace (Boolean : true : IRWA)
    // If true, when the user navigates to a cell using arrow keys and hits space,
    // the cell will respond to a click event.
    // @visibility external
    //<
    generateClickOnSpace : true,

    //> @attr listGrid.generateClickOnEnter (Boolean : false : IRWA)
    // If true, when the user navigates to a cell using arrow keys and hits Enter,
    // the cell will respond to a click event.
    // @visibility external
    //<
    //generateClickOnEnter : false,

    //> @attr listGrid.generateDoubleClickOnSpace (Boolean : false : IRWA)
    // If true, when the user navigates to a cell using arrow keys and hits Space,
    // the cell will respond to a double click event.
    // @visibility external
    //<
    // generateDoubleClickOnSpace : false,

    //> @attr listGrid.generateDoubleClickOnEnter (Boolean : true : IRWA)
    // If true, when the user navigates to a cell using arrow keys and hits Enter,
    // the cell will respond to a double click event.
    // @visibility external
    //<
    generateDoubleClickOnEnter : true,

    //> @attr listGrid.arrowKeyAction (string : null : IRWA)
    // Action to perform when the listGrid has keyboard focus (but not editing focus) and a user
    // presses the up or down arrow key. Possible values are:
    // <ul>
    // <li><code>"select"</code> : select the next row in the list (calls <code>recordClick</code> handler)</li>
    // <li><code>"focus"</code> : move focus to the next row in the list without changing the selection</li>
    // <li><code>"activate"</code> : select and activate the next row in the list (calls
    //  <code>recordDoubleClick</code> handler)</li>
    // <li><code>"none"</code> : no action</li>
    // <li> <code>null</code> : if +link{listGrid.selectionAppearance} is "checkbox", behaves as if set
    //  to "focus"; otherwise, behaves as if set to "select"</li>
    // </ul>
    // @group events
    // @visibility external
    //<
    arrowKeyAction: null,

    //> @attr ListGrid.hiliteRowOnFocus (Boolean : null : IRW)
    // When the grid body gets keyboard focus, should we highlight the current focus row,
    // using the rollover cell style?
    // <P>
    // This property may be explicitly set to control this behavior independently of
    // +link{showRollOver}.
    // Otherwise (if this property is null), we will show the roll-over styling for the
    // keyboard focus row if +link{showRollOver} is true.
    // @visibility external
    //<
//    hiliteRowOnFocus:null,

    //> @attr listGrid.showRecordComponents (boolean : null : IRWA)
    // When enabled, +link{createRecordComponent()} will be called when saved rows are being
    // rendered, and any returned component will be displayed embedded within the row or cell.
    // <P>
    // recordComponents are not created for newly added rows which have not yet been saved.  
    // See the +link{group:unsavedRecords, Handling Unsaved Records overview} for more
    // information.
    // <P>
    // Depending on the +link{showRecordComponentsByCell} setting,
    // <code>createRecordComponent()</code> will be called either once per row, or once for
    // every cell.
    // <P>
    // Depending on +link{recordComponentPosition}, components can either be placed underneath
    // normal record or cell content ("expand" setting) or placed so that they overlap normal
    // cell content ("within" setting).  For the "within" setting, the default is to fill the
    // row or cell, but the component can specify percent size or even use
    // +link{canvas.snapTo,snapTo-positioning} to place itself within the row or cell.
    // <p>
    // The "expand" setting is incompatible with +link{canFreezeFields,frozen columns}
    // <i>unless</i> all <code>recordComponents</code> are the same height and they are present
    // in every row, in which case the fixed height of all <code>recordComponents</code> can be
    // set via +link{recordComponentHeight} to re-enable frozen fields.
    // <p>
    // Using <code>recordComponents</code> potentially means creating one component for every
    // visible grid row or cell and so can impact performance.  Before using this subsystem:
    // <ul>
    // <li> consider using +link{listGridField.valueIcons} (possibly with a specified 
    //      +link{listGridField.valueIconClick()} handler) for icons based on field values
    //      which may be displayed alone in the cell or alongside standard content
    //      (see +link{listGridField.showValueIconOnly});
    // <li> for clickable icons representing actions that can be taken on a record, also 
    //      consider using +link{type:ListGridFieldType,a field of type "icon"}, or 
    //      multiple such fields
    // <li> for controls that only need to appear on rollover, consider
    //      +link{showRollOverCanvas,rollOver controls}
    // <li> if you are trying to customize the editor for a field, you can provide a custom
    //      control via +link{listGridField.editorType}, and +link{formItem.icons} are a common
    //      way to add clickable buttons.  You can also
    //      +link{getEditorType,provide different controls per record}.  These options are
    //      usually better that using <code>recordComponents</code> as custom editors, since
    //      you won't have to manage issues like making the <code>recordComponent</code> appear
    //      only when editing, having changes affect +link{group:editing,editValues},
    //      triggering saves and handling validation errors, etc.
    // </ul>
    // <P>
    // See +link{recordComponentPoolingMode} for an overview of how best to optimize use of
    // <code>recordComponents</code> for different data sets.
    // <p>
    // Regardless of the pooling mode, you can explicitly refresh record components via
    // +link{listGrid.invalidateRecordComponents()} and
    // +link{listGrid.refreshRecordComponent()}.
    // <P>
    // <i>Interaction with +link{listGrid.autoFitFieldWidths,column auto-fit}</i>: per-cell record
    // components are not taken into account when determining the size for column auto fit.
    // The default +link{listGrid.getDefaultFieldWidth()} implementation looks at cell content
    // only. We typically recommend that, for fields showing record-components, 
    // +link{listGridField.autoFitWidth} and +link{listGridField.canAutoFitWidth} be disabled, or if 
    // the record components are of a predictable size, a +link{listGridField.defaultWidth}
    // be specified.<br>
    // This is particularly pertinent where +link{listGrid.recordComponentPosition}
    // is set to "within", in which case cells' content is often empty or completely covered
    // by record-components.
    //
    // @see recordComponentPosition
    // @see showRecordComponentsByCell
    // @see recordComponentPoolingMode
    // @see showRecordComponent()
    // @see createRecordComponent()
    // @see updateRecordComponent()
    //
    // @visibility external
    //<

    //> @type EmbeddedPosition
    // How a component should be embedded within its record or cell
    // @value "expand" component should be placed underneath normal record or cell content,
    //        expanding the records.  Expanding records can result in variable height rows,
    //        in which case +link{listGrid.virtualScrolling,virtualScrolling} should be
    //        enabled.
    // @value "within" component should be placed within the normal area of the record or cell.
    //        Percentage sizes will be treated as percentages of the record and
    //        +link{Canvas.snapTo} positioning settings are also allowed and refer to the
    //        rectangle of the record or cell. Note that for components embedded within cells,
    //        cell align and vAlign will be used if snapTo is unset (so top / left alignment
    //        of cell content will map to snapTo of "TL", etc).
    // @visibility external
    //<

    //> @attr listGrid.recordComponentPosition (EmbeddedPosition : null : IRW)
    // if +link{listGrid.showRecordComponents} is true, how should the component appear within
    // the cell. Valid options are
    // <ul><li><code>"within"</code>: the component will be rendered inside the record / cell.
    //  +link{canvas.snapTo} may be set to specify where the component should render within
    //  the row or cell, and +link{canvas.snapOffsetTop} / +link{canvas.snapOffsetLeft} may
    //  be set to indent recordComponents within their parent cells.
    //  Note that if unset, the component will show up at the top/left edge
    //  for components embedded within an entire row, or for per-cell components, cell
    //  align and valign will be respected.  Note also that, when rendering components "within"
    //  cells, specified component heights will be respected and will change the height of the
    //  row.  However, if you want components to completely fill a cell at it's default height,
    //  set height: "100%" or rows will render at the default height of the component. </li>
    // <li><code>"expand"</code>: the component will be written into the cell below the
    //  normal cell content, causing the cell to expand vertically to accommodate it.
    // <li><code>null</code>: If this attribute is unset, we will default to showing
    //  recordComponents with position <code>"within"</code> if
    //  +link{showRecordComponentsByCell} is true, otherwise using <code>"expand"</code>
    //  logic.
    // </ul>
    // @see showRecordComponents
    // @visibility external
    //<
    
//    recordComponentPosition:"expand",


    //> @attr listGrid.showRecordComponentsByCell (boolean : null : IRWA)
    // If true, shows +link{listGrid.showRecordComponents, recordComponents} in cells, rather
    // than just in records.
    // @visibility external
    //<

    //> @type RecordComponentPoolingMode
    // The method of component-pooling to employ for +link{listGrid.showRecordComponents,recordComponents}.
    // <P>
    // @value "viewport" components are destroyed when the record is not being rendered.  Best
    //        for large datasets where embedded components differ greatly per record.
    // @value "data" components are +link{canvas.clear,clear()ed} when not in the viewport, but
    //        stay with a record until the record is dropped from cache.  Best for guaranteed
    //        small datasets.
    // @value "recycle" components are pooled and will be passed to
    //       +link{listGrid.updateRecordComponent,updateRecordComponent()} with the
    //       <code>recordChanged</code> parameter set to true.  Best for large datasets where
    //       embedded components are uniform across different records and can be efficiently
    //       reconfigured to work with a new record
    // @visibility external
    //<

    //> @attr listGrid.recordComponentPoolingMode (RecordComponentPoolingMode : "viewport" : IRWA)
    // The method of +link{type:RecordComponentPoolingMode, component-pooling} to employ for
    // +link{showRecordComponents,recordComponents}.
    // <P>
    // The default mode is "viewport", which means that recordComponents are destroyed as soon
    // their record is no longer being rendered (scrolled out of the viewport, eliminated by
    // search criteria, etc).
    // <P>
    // For a large or dynamic data set where the components shown on different rows are
    // similar, switch to "recycle" mode, which pools recordComponents by detaching them from
    // records that are not visible and re-using them in other records.  In this mode, you
    // should implement +link{updateRecordComponent()} to apply any changes to make reused
    // components applicable to the new record they appear in, if necessary.  For example, if
    // you have several controls in your <code>recordComponents</code>, and not all of the
    // controls apply to every record, your <code>updateRecordComponent()</code> implementation
    // could simply hide or disable inapplicable controls, and this would be much faster than
    // creating a whole new set of controls every time a given record is scrolled into view.
    // <p>
    // If you are using +link{showRecordComponentsByCell,per-cell recordComponents}, and you
    // have components of different types in different columns and still want to take
    // advantage of component recycling, you can set +link{listGrid.poolComponentsPerColumn} to
    // ensure that components intended for one column are not recycled for use in another
    // column that should have a different component.
    // <P>
    // Note that, if different records have distinctly different components embedded
    // in them, or multiple columns in each record embed different components, you should
    // leave the recordComponentPoolingMode at "viewport" if your dataset is very large or
    // use "data" otherwise.
    // @visibility external
    //<
    recordComponentPoolingMode:"viewport",

    //> @attr listGrid.poolComponentsPerColumn (Boolean : true : IRW)
    // Should recycled +link{listGrid.showRecordComponents,record components}, be pooled
    // per column or per record. Only applies if +link{listGrid.showRecordComponentsByCell} is true.
    // <P>
    // When +link{listGrid.recordComponentPoolingMode} is "recycle" and you have components of
    // different types in different columns, set this property to true to ensure that
    // components intended for one column are not recycled for use in another column that
    // should have a different component.
    // <P>
    // If no components applicable to a particular column are available in the pool, the system
    // calls +link{listGrid.createRecordComponent, createRecordComponent}.
    //
    // @visibility external
    //<
    
    poolComponentsPerColumn:true,

	// Rollover
	// --------------------------------------------------------------------------------------------
    //>	@attr listGrid.showRollOver (Boolean : true : IRW)
    // Should we show different styling for the cell the mouse is over?
    // <p>
    // If true, the cell style will have the suffix "Over" appended.
    // <p>
    // Can be overridden on a per-record basis via +link{listGridRecord.showRollOver}.
    //
    // @group appearance
    // @visibility external
    //<
    // showRollOver: null, // !isc.Browser.isTouch

    //> @attr listGrid.recordShowRollOverProperty (String : "showRollOver" : IR)
    // Name of the property that can be set on a per-record basis to disabled rollover for an
    // individual record when +link{listGrid.showRollOver} is true.
    //<
    recordShowRollOverProperty:"showRollOver",

    //> @attr listGridRecord.showRollOver (Boolean : null : IR)
    // Set to false to disable rollover for this individual record when +link{listGrid.showRollOver}
    // is true.
    // <p>
    // Note this property can be renamed to prevent collision with data members - see
    // +link{listGrid.recordShowRollOverProperty}.
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridRecord.embeddedComponent (Canvas : null : IR)
    // A component that should be rendered on top of this record, similar to a
    // +link{listGrid.showRecordComponents,record component} but statically defined on the record.
    // <p>
    // The embedded component will default to covering all fields of the record, but specific fields
    // can be specified via +link{embeddedComponentFields}.
    // <p>
    // By default, the embeddedComponent will fill the entire vertical and horizontal space of the
    // record (or of the specified fields).  +link{embeddedComponentPosition} can be set to control
    // exact sizing behavior.
    // <smartclient>
    // <p>
    // When creating a component to use as an embedded component the component will most likely
    // end up drawing before the record it is due to be embedded within, therefore it is recommended
    // to set +link{canvas.autoDraw,autoDraw} to false on the embedded component.
    // </smartclient>
    // <p>
    // When a record with an <code>embeddedComponent</code> is eliminated from view by filtering or
    // because it is not currently rendered due to +link{listGrid.showAllRecords,incremental rendering}, the
    // ListGrid may +link{canvas.hide()} or +link{canvas.clear()} it.
    // <p>
    // If the current dataset is completely replaced (by a call to +link{listGrid.setData()} or
    // +link{listGrid.setDataSource()}, for example), any embedded component is
    // +link{canvas.deparent(),deparented} (which implies being +link{canvas.clear(),clear()ed}).
    // <p>
    // When a ListGrid is +link{canvas.destroy(),destroyed}, it will destroy() all embedded components
    // regardless of whether they are currently visible.  Use a call to +link{listGrid.setData()} immediately
    // before destroying the ListGrid to avoid this effect when unwanted.
    // <p>
    // For more advanced control over the lifecycle of components displayed over records, including
    // deferred creation and pooling, use the +link{listGrid.showRecordComponents,record components}
    // subsystem.
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridRecord.embeddedComponentPosition (EmbeddedPosition : null : IR)
    // Sizing policy applied to the embedded component.  Default behavior if unspecified is the same
    // as +link{EmbeddedPosition} "within" (fill space allocated to the record, including the ability
    // use percentage sizing and snapTo offset).  Use "expand" to have the record expand to accomodate
    // the embedded components' specified sizes instead.
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridRecord.embeddedComponentFields (Array of String : null : IR)
    // Fields where the +link{embeddedComponent} will be displayed, if specified.
    // <p>
    // Regardless of the order of fields specified, the component will appear from whichever field is
    // earlier in the current visible order to whichever field is later, inclusive of the specified
    // fields.
    // <p>
    // To have the component appear in just one field, either specify a single-element Array or
    // specific a two element Array with both fields the same.
    // <p>
    // If either field is hidden or invalid (no such field), the component will occupy only a single
    // field.  If both fields are hidden, the component will be hidden until one or more of the fields
    // are shown.
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr listGrid.useCellRollOvers (Boolean : null : IRW)
    // Are rollovers cell-level or row-level?
    // @visibility external
    //<

    //> @attr listGrid.showRollOverCanvas (Boolean : null : IRWA)
    // When enabled, when the mouse moves over a row or cell (depending on
    // +link{useCellRollOvers}), an arbitrary Canvas can be shown layered on top of the row or
    // cell (the +link{listGrid.rollOverCanvas}), layered underneath the row or cell (the
    // +link{listGrid.rollUnderCanvas}), or both. 
    // <P>
    // This can be used to dynamically show controls or informational displays only on
    // rollover.  For example, controls to delete a row might appear only on rollover so they
    // do not clutter the static display, or a "rollunder" Canvas could be used to display
    // additional information that can appear behind normal cell values (like displaying
    // percent complete via as a bar of color that appears behind text values).
    // <p>
    // +link{canvas.snapTo,snapTo positioning} can be used to place the
    // rollOver/rollUnderCanvas.  With <code>useCellRollOvers</code>, positioning is relative
    // to the cell, for row-level rollOver, position is relative to the portion of the
    // row that is scrolled into view (this implies a row-level rollOver/UnderCanvas can never
    // be placed horizontally scrolled out of view, but this is possible for a cell-level
    // rollOver).  
    // <p>
    // <code>snapTo</code> positioning makes it easy to do something like place a button at the
    // right edge of the grid, next to the scrollbar: just set snapTo:"R" on the
    // <code>rollOverCanvas</code>.
    // <p>
    // The rollOver/rollUnder Canvas can be a single static component (the same for all
    // cells/rows) configured via the +link{AutoChild} system, or can instead be provided
    // dynamically by implementing +link{getRollOverCanvas()} and/or +link{getRollUnderCanvas()}.
    // <p>
    // With row-level rollOvers with +link{listGridField.frozen,frozen fields}, the 
    // <code>rollOverCanvas</code> and <code>rollUnderCanvas</code> appear only for non-frozen
    // fields.  This is usually not an issue for something like rollOver controls for row
    // deletion, but will prevent certain scenarios of using rollOverCanvas/rollUnderCanvas for
    // visual styling.
    // <p>
    // <code>showRollOverCanvas</code> has no effect if +link{showRollOver} is <code>false</code>.
    // @example gridRollOverReticleEffect
    // @example rolloverControls
    // @group rowEffects
    // @see ListGrid.showRollUnderCanvas
    // @visibility external
    //<
    //showRollOverCanvas:null,

    //> @attr listGrid.rollOverCanvas (AutoChild Canvas : null : RA)
    // AutoChild created and embedded in the grid if +link{ListGrid.showRollOver,showRollOver}
    // is <code>true</code> and +link{ListGrid.showRollOverCanvas,showRollOverCanvas} is
    // <code>true</code>. This component will be created and displayed above the current rollOver
    // row or cell.
    // <p>
    // The <code>rollOverCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the current roll over record object in the grid
    // @example gridRollOverReticleEffect
    // @example rolloverControls
    // @group rowEffects
    // @see ListGrid.rollUnderCanvas
    // @visibility external
    //<

    //> @attr listGrid.showRollUnderCanvas (Boolean : null : IRWA)
    // If roll overs are enabled, should the +link{ListGrid.rollUnderCanvas,rollUnderCanvas}
    // be displayed?
    // <p>
    // Use of the <code>showRollUnderCanvas</code> is enabled if +link{ListGrid.showRollOver,showRollOver}
    // is <code>true</code>, and either +link{ListGrid.showRollOverCanvas,showRollOverCanvas}
    // is <code>true</code> and <code>showRollUnderCanvas</code> is unset, or <code>showRollUnderCanvas</code>
    // is explicitly set to <code>true</code>.
    // @example gridAnimatedSelection
    // @see ListGrid.showRollOverCanvas
    // @visibility external
    //<
    //showRollUnderCanvas:null,

    //> @attr listGrid.rollUnderCanvas (AutoChild Canvas : null : RA)
    // AutoChild created and embedded in the grid if +link{ListGrid.showRollOver,showRollOver}
    // is <code>true</code>, and either +link{ListGrid.showRollOverCanvas,showRollOverCanvas}
    // is <code>true</code> and +link{ListGrid.showRollUnderCanvas,showRollUnderCanvas} is
    // unset, or <code>showRollUnderCanvas</code> is explicitly set to <code>true</code>.
    // This component will be created and displayed behind the current rollOver row or cell in the
    // page's z-order, meaning that it will only be visible if the cell styling is transparent.
    // <p>
    // The <code>rollUnderCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the current roll over record object in the grid
    // @example gridAnimatedSelection
    // @group rowEffects
    // @visibility external
    //<

    //>Animation

    //> @attr listGrid.animateRollOver (Boolean : false : IRWA)
    // If the +link{ListGrid.rollOverCanvas,rollOverCanvas} is enabled, setting this property
    // to <code>true</code> ensures that when the <code>rollOverCanvas</code> is displayed it
    // is animated into view via +link{Canvas.animateShow()}. Note that the animation effect
    // may be customized via +link{Canvas.animateShowEffect}, +link{Canvas.animateShowTime} and
    // +link{Canvas.animateShowAcceleration} set in <code>rollOverCanvasProperties</code>.
    // @group rowEffects
    // @visibility external
    //<
    animateRollOver: false,

    //> @attr listGrid.animateRollUnder (Boolean : false : IRWA)
    // If the +link{ListGrid.rollUnderCanvas,rollUnderCanvas} is enabled, setting this property
    // to <code>true</code> ensures that when the <code>rollUnderCanvas</code> is displayed it
    // is animated into view via +link{Canvas.animateShow()}. Note that the animation effect
    // may be customized via +link{Canvas.animateShowEffect}, +link{Canvas.animateShowTime} and
    // +link{Canvas.animateShowAcceleration} set in <code>rollUnderCanvasProperties</code>.
    // @example gridAnimatedSelection
    // @group rowEffects
    // @visibility external
    //<
    animateRollUnder: false,

    //<Animation

    //> @attr listGrid.showBackgroundComponents (Boolean : false : IRW)
    // If <code>true</code> this grid will create and show per-row backgroundComponents
    // as detailed +link{listGrid.backgroundComponent,here}.
    // @visibility external
    //<

    //> @attr listGrid.backgroundComponent (MultiAutoChild Canvas : null : IR)
    // Has no effect unless +link{listGrid.showBackgroundComponents} is <code>true</code>.
    // <P>
    // Canvas created and embedded in the body behind a given record.   When
    // +link{listGridRecord.backgroundComponent} is set, this autoChild canvas
    // will be constructed (if listGridRecord.backgroundComponent is not already a Canvas) and
    // its properties combined with those of listGridRecord.backgroundComponent and then
    // displayed behind a specific record in the page's z-order, meaning
    // it will only be visible if the cell styling is transparent.
    // @group rowEffects
    // @visibility external
    //<
    backgroundComponentDefaults: {
        snapTo:"TL",
        autoDraw: false,
        opacity: "50%"
    },

    // Hover
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.canHover (boolean : null : [IRW])
    // @include gridRenderer.canHover
    // @group hovers
    // @see attr:listGrid.showHover
    // @see attr:listGridField.showHover
    // @example valueHoverTips
    //<
    // are hover events and hover popups enabled?
    //canHover:false,

    //> @attr listGrid.showHover (Boolean : true : [IRW])
    // @include gridRenderer.showHover
    // @group hovers
    //<
    // if canHover:true, should we show hover popups?
    showHover: true,

    //> @attr listGrid.showClippedHeaderTitlesOnHover (boolean : true : [IRA])
    // If true and a header button's title is clipped, then a hover containing the full field
    // title is enabled.
    // @group hovers
    // @see ListGrid.headerTitleClipped()
    // @see ListGrid.headerHoverHTML()
    // @visibility external
    //<
    showClippedHeaderTitlesOnHover: true,

    //> @attr listGridField.showHover (boolean : null : IRW)
    // Whether to show hovers for this field.  The default hover will be the contents of the
    // cell the user is hovering over, and can be customized via
    // +link{listGridField.hoverHTML,field.hoverHTML()}.
    // <P>
    // +link{ListGrid.canHover} can be set to true to cause hovers to be shown for all fields
    // by default.  In this case, <code>field.showHover</code> can be set to false to suppress
    // hovers for an individual field.
    // <P>
    // All hovers can be disabled, regardless of other settings, by setting
    // +link{ListGrid.showHover} to false.
    // @visibility external
    // @example valueHoverTips
    //<

    // can be set to false to cause hover to be per-row instead of per-cell
    //hoverByCell:true,

    // if canHover:true, should an active hover remain active until we leave the listGrid?
    // default behavior is to clear/deactivate the hover on each cellOut/rowOut
    //keepHoverActive:false,

    // the space between the borders of the cell and the hover, in pixels
    cellHoverOutset:5,

    // Note: hoverWidth, hoverStyle, et al will be picked up by the grid renderer when showing
    // cell hovers (handled by GridRenderer class)

    //> @attr listGrid.hoverStyle (CSSStyleName : "gridHover" : [IRWA])
    // Style to apply to hovers shown over this grid.
    // @see listGrid.showHover
    // @group hovers
    // @visibility external
    //<
    hoverStyle:"gridHover",

    //> @attr listGridField.prompt (HTMLString : null : IR)
    // Causes a tooltip hover to appear on the header generated for this field (effectively
    // sets +link{canvas.prompt} for the header).
    //
    // @visibility external
    //<

    // Selection
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.selection (Selection : null : [RA])
    // The Selection object associated with the listGrid.
    // @group  selection
    // @visibility external
    //<

    //> @attr listGrid.selectionAppearance (SelectionAppearance : "rowStyle" : IRW)
    // How selection of rows should be presented to the user.
    // <P>
    // For <code>selectionAppearance:"checkbox"</code> with multiple selection
    // allowed, you would typically use +link{listGrid.selectionType}:"simple" (the default).  Because
    // <code>selectionType</code> and <code>selectionAppearance</code> are unrelated,
    // the combination of <code>selectionAppearance:"checkbox"</code> and
    // <code>selectionType:"multiple"</code> results in a grid where multiple selection can
    // only be achieved via shift-click or ctrl-click.
    // <P>
    // If using <code>"checkbox"</code> for a +link{listGrid}, see also
    // +link{listGrid.checkboxField} for customization APIs.
    // <P>
    // If using <code>"checkbox"</code> for a +link{treeGrid}, an extra icon,
    // +link{treeGrid.getExtraIcon} is not supported. Additionally only
    // +link{listGrid.selectionType}:"simple" and "single" are supported.
    // You can also toggle the display of a disabled checkbox on a treeGrid, displayed
    // when the node can't be selected, via +link{TreeGrid.showDisabledSelectionCheckbox}.
    // @group selection
    // @visibility external
    //<
    selectionAppearance: "rowStyle",

    //> @attr listGrid.canSelectAll (boolean : null : [IRW])
    // Controls whether a checkbox for selecting all records appears in the header with
    // +link{listGrid.selectionAppearance, selectionAppearance} set to "checkbox"
    //
    // @group selection
    // @visibility external
    //<
    
    //> @attr listGrid.canSelectGroups (boolean : false : [IRW])
    // Controls whether a checkbox for selecting +link{listGrid.groupBy(),groups} appears
    // in the group node if +link{selectionAppearance} is set to <code>"checkbox"</code>
    // @group selection
    // @visibility external
    //<
    
    //> @attr listGrid.showPartialSelection (Boolean : false : [IRW])
    // Should partially selected parents (in a Tree data set) be shown with special icon?
    // This has an impact in grouped grids where +link{canSelectGroups} is true. The
    // partial icon will show up for the group header node when a group is partially
    // selected.
    // @visibility external
    //<


    //> @attr listGrid.selectionType (SelectionStyle : null : [IRW])
    // Defines a listGrid's clickable-selection behavior.
    // <P>
    // The default selection appearance is governed by +link{listGrid.selectionAppearance}: if
    // selectionAppearance is "checkbox", this will be "simple", otherwise, this will be
    // "multiple".
    //
    // @group   selection, appearance
    // @see type:SelectionStyle
    //      @visibility external
    // @example multipleSelect
    //<
    selectionType:null,

    //> @attr listGrid.selectionProperty (string : null : IRA)
    // If specified, the selection object for this list will use this property to mark records
    // as selected.  In other words, if this attribute were set to <code>"isSelected"</code>
    // any records in the listGrid data where <code>"isSelected"</code> is <code>true</code>
    // will show up as selected in the grid. Similarly if records are selected within the grid
    // after the grid has been created, this property will be set to true on the selected
    // records.
    //
    // @group  selection, appearance
    // @visibility external
    //<
    //selectionProperty:null,

    //> @attr listGrid.reselectOnUpdate (boolean : true : IRA)
    // If true, when an update operation occurs on a selected record in a
    // +link{listGrid.dataSource,databound} listGrid, ensure the updated record is
    // re-selected when the operation completes.
    // The +link{listGrid.reselectOnUpdateNotifications} attributes governs whether
    // +link{listGrid.selectionUpdated()} and +link{listGrid.selectionChanged()} will fire
    // when this occurs.
    // @visibility external
    //<
    // This property is passed to the selection object in DBC.createSelectionModel()
    reselectOnUpdate:true,

    //> @type SelectionNotificationType
    // Enum to indicate selection change notification types. Used by
    // +link{listGrid.reselectOnUpdateNotifications}
    // @value "none" No selection change notification should fire
    // @value "selectionChanged" +link{listGrid.selectionChanged()} should fire but
    //  +link{listGrid.selectionUpdated()} should not fire.
    // @value "selectionUpdated" +link{listGrid.selectionChanged()} and
    //  +link{listGrid.selectionUpdated()} should both fire.
    // @visibility external
    //<

    //> @attr listGrid.reselectOnUpdateNotifications (SelectionNotificationType : "selectionChanged" : IRWA)
    // if +link{listGrid.reselectOnUpdate} is true, this property governs what
    // selection changed notifications should be triggered when a selected record
    // is edited then automatically reselected when the edited data is merged into
    // the data set.
    // @visibility external
    //<
    reselectOnUpdateNotifications:"selectionChanged",

    //> @attr listGrid.recordCanSelectProperty (String : "canSelect" : IRA)
    // If set to false on a record, selection of that record is disallowed.
    // @visibility external
    //<
    recordCanSelectProperty:"canSelect",

    //> @attr listGridRecord.canSelect (boolean : null : IR)
    //
    // Default property name denoting whether this record can be selected. Property name may be
    // modified for the grid via +link{listGrid.recordCanSelectProperty}.
    //
    // @visibility external
    //<

    //> @attr listGrid.canSelectCells (Boolean : false : IR)
    // Enables cell-level selection behavior as well as
    // +link{useCellRollOvers,cell-level rollover}.
    // <P>
    // To query and manipulate cell-level selections, use +link{getCellSelection()} to retrieve
    // the +link{CellSelection}.
    // <P>
    // Note that the ListGrid has a data model of one +link{Record} per row, unlike the
    // +link{CubeGrid} which supports one +link{CellRecord} per cell.  For this reason
    // record-oriented APIs that act on the selection will act on entire Records that have
    // <i>any</i> selected cells (examples include drag and drop and transferSelectedData()).
    // <P>
    // More generally, <code>canSelectCells</code> is primarily intended to enable developers
    // to build Excel-like interactions on local datasets, by using +link{setData()} plus
    // +link{saveLocally}:true rather than record-oriented DataSources and data binding.
    // <P>
    // The following keyboard selection behaviors are enabled with this property in
    // addition to standard single-selection Arrow Key navigation:
    // <P>
    // SHIFT +        [Arrow Key]:  begin or continue incremental selection
    // <P>
    // SHIFT + CTRL + [Arrow Key]:  incremental selection to the end of row or column
    // <P>
    // CTRL  + A: select all cells (enabled only with +link{listGrid.canSelectAll})
    // <P>
    // Incremental selection allows selection of rows and columns of cells via keyboard
    // or mouse provided the shift key is down.  Behavior is designed to match Excel.
    // Thus, if a previous selection has begun, cells will be selected from that origin.
    // <P>
    // Users may also navigate through cells using the <i>Tab</i> and <i>Shift+Tab</i>
    // keypresses if +link{listGrid.navigateOnTab} is true. When a user tabs to the
    // end of the row, the +link{listGrid.rowEndEditAction} is used to determine whether
    // to shift selection to the next row, return to the beginning of the same row, or
    // simply move on through the page's tab order.
    //
    // @visibility external
    //<
    //canSelectCells:false,

    //> @attr listGrid.navigateOnTab (boolean : true : IRW)
    // If +link{listGrid.canSelectCells} is true, this property allows the user
    // to navigate through the cells of a grid using Tab and Shift+Tab keypresses.
    // When a user tabs to the
    // end of the row, the +link{listGrid.rowEndEditAction} is used to determine whether
    // to shift selection to the next row, return to the beginning of the same row, or
    // simply move on through the page's tab order.
    // @visibility external
    //<
    navigateOnTab:true,
    shouldNavigateOnTab : function () {
        return this.canSelectCells && this.navigateOnTab;
    },
    // Undocumented corollary for arrowKeyAction for navigateOnTab
    tabKeyAction:"select",

    //> @attr listGrid.useCopyPasteShortcuts (Boolean : true : IRW)
    // Enables copy/paste shortcuts, provided +link{listGrid.canSelectCells} is true
    // <p>
    // The default setting of true means that the value of +link{listGrid.canSelectCells}
    // determines whether copy/paste shortcuts are enabled.  Setting this property to
    // false disables said shortcuts unconditionally.
    // <p>
    // Copying is done via copying to a SmartClient-wide "clipboard" - <b>not</b> the OS-level
    // clipboard, which is inaccessible on some browsers - via the methods
    // +link{getSelectedCellData()} and +link{applyCellData()}.  To copy data to and
    // from applications outside of the browser, use the technique shown in the
    // +explorerExample{gridToExcel,Grid to Excel} and
    // +explorerExample{excelToGrid,Excel to Grid} samples.
    // <p>
    // The following shortcuts are available:
    // <p>
    // CTRL + D: copy cell values from top row of selected cells down to all rows
    // <p>
    // CTRL + R: copy cell values from left column of selected cells right to all columns
    // <p>
    // CTRL + C: copy selected cell values into shared clipboard
    // <p>
    // CTRL + V: paste from shared clipboard into current selection
    //
    // @visibility external
    //<
    useCopyPasteShortcuts: true,

    //> @attr listGrid.originBaseStyle (CSSStyleName : null : IRW)
    // Name of a CSS Style to use as the +link{listGrid.baseStyle} for a cell that
    // is currently a selection origin for shifted incremental cell selection.
    // Only has an effect if +link{listGrid.canSelectCells} is true.
    // <P>
    // @visibility external
    //<
    //originBaseStyle: null,

    //> @attr listGrid.copyEmptyCells (boolean : true : IRW)
    // Determines whether empty cells (those with an undefined value) are present
    // in the records generated by +link{listGrid.getSelectedCellData}, If true, an
    // empty cell in the selection will be added to the record with a null value.
    // If false, an empty cell will not be represented in the record at all.
    //<
    copyEmptyCells: true,

    //> @attr listGrid.canDragSelect (Boolean : false : IRW)
    //  If this property is true, users can drag the mouse to select several rows or cells.
    //  This is mutually exclusive with rearranging rows or cells by dragging.
    // <p>
    // <strong>NOTE:</strong> If <code>canDragSelect</code> is initially enabled or might be
    // dynamically enabled after the grid is created, it may be desirable to disable
    // +link{Canvas.useTouchScrolling,touch scrolling} so that touch-dragging records/cells
    // selects them rather than starting a scroll. If +link{Canvas.disableTouchScrollingForDrag}
    // is set to <code>true</code>, then touch scrolling will be disabled automatically.
    // However, for +link{group:accessibility,accessibility} reasons, it is recommended to
    // leave touch scrolling enabled and provide an alternative set of controls that can be
    // used to perform drag-selection.
    //  @group  selection
    //  @visibility external
    //  @example dragListSelect
    //<
    //canDragSelect:false,

    //> @attr listGrid.canDragSelectText (Boolean : false : IRW)
    // If this property is true, users can drag the mouse to select text within grid rows.
    // This is mutually exclusive with
    // +link{canReorderRecords,rearranging rows or cells by dragging}, and with
    // +link{canDragSelect,drag selection of rows}.
    //
    // @group selection
    // @visibility external
    //<
    //canDragSelectText:false,

    //> @attr listGrid.canDropInEmptyArea (Boolean : true : IRW)
    // If set to false, dropping over an empty part of the grid body is disallowed and the
    // no-drop indicator is displayed.
    // @group dragdrop
    // @visibility external
    //<
    //canDropInEmptyArea: true,

    //> @attr listGrid.showSelectionCanvas (Boolean : null : IRWA)
    // If +link{ListGrid.selectionType,selectionType} is set to
    // <smartclient>"single",</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.SelectionStyle#SINGLE},</smartgwt>
    // setting this property to <code>true</code> means selection will be displayed to the
    // user with the +link{ListGrid.selectionCanvas,selectionCanvas} and/or
    // +link{ListGrid.selectionUnderCanvas,selectionUnderCanvas} rather than with CSS styling.
    // <p>
    // If <code>showSelectionCanvas</code> is set to <code>true</code>, then the
    // <code>selectionUnderCanvas</code> will automatically be enabled unless
    // +link{showSelectionUnderCanvas,showSelectionUnderCanvas} is set to <code>false</code>.
    // <p>
    // NOTE: It is recommended to use the <code>selectionUnderCanvas</code> rather than the
    // <code>selectionCanvas</code> if possible because the <code>selectionCanvas</code> is
    // stacked on top of the selected record and this may interfere with event handling in rare
    // cases. If no interactive components are shown in the <code>selectionCanvas</code> and it
    // simply provides custom styling, then the <code>selectionUnderCanvas</code> should be used
    // instead.
    // <p>
    // With +link{ListGrid.canFreezeFields,frozen fields}, the <code>selectionCanvas</code>
    // is displayed only over the non-frozen fields of the selected row.
    // @group rowEffects
    // @see ListGrid.showSelectionUnderCanvas
    // @visibility external
    //<
    //showSelectionCanvas:null,

    //> @attr listGrid.selectionCanvas (AutoChild Canvas : null : RA)
    // AutoChild created and embedded in the grid if +link{ListGrid.showSelectionCanvas,showSelectionCanvas}
    // is <code>true</code> and the +link{ListGrid.selectionType,selectionType} is
    // <smartclient>"single".</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.SelectionStyle#SINGLE}.</smartgwt>
    // This component will be created and displayed above the selected record whenever the
    // selection changes.
    // <p>
    // NOTE: It is recommended to use the +link{ListGrid.selectionUnderCanvas,selectionUnderCanvas}
    // rather than the <code>selectionCanvas</code> if possible because the <code>selectionCanvas</code>
    // is stacked on top of the selected record and this may interfere with event handling in rare
    // cases. If no interactive components are shown in the <code>selectionCanvas</code> and it
    // simply provides custom styling, then the <code>selectionUnderCanvas</code> should be used
    // instead.
    // <p>
    // The <code>selectionCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the currently selected record in the grid
    // @group rowEffects
    // @see ListGrid.selectionUnderCanvas
    // @visibility external
    //<

    //> @attr listGrid.showSelectionUnderCanvas (Boolean : null : IRWA)
    // If +link{ListGrid.selectionType,selectionType} is set to
    // <smartclient>"single",</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.SelectionStyle#SINGLE},</smartgwt>
    // and either +link{showSelectionCanvas,showSelectionCanvas} is <code>true</code> and
    // <code>showSelectionUnderCanvas</code> is unset, or <code>showSelectionUnderCanvas</code>
    // is explicitly set to <code>true</code>, then selection will be displayed to the
    // user with the +link{ListGrid.selectionCanvas,selectionCanvas} and/or
    // +link{ListGrid.selectionUnderCanvas,selectionUnderCanvas} rather than with CSS styling.
    // Setting <code>showSelectionUnderCanvas</code> to <code>false</code> will disable
    // the use of the <code>selectionUnderCanvas</code>.
    // <p>
    // With +link{ListGrid.canFreezeFields,frozen fields}, the <code>selectionUnderCanvas</code>
    // is displayed only behind the non-frozen fields of the selected row.
    // @example gridRoundedSelection
    // @group rowEffects
    // @see ListGrid.showSelectionCanvas
    // @visibility external
    //<
    
    //showSelectionUnderCanvas:null,

    //> @attr listGrid.selectionUnderCanvas (AutoChild Canvas : null : RA)
    // AutoChild created and embedded in the grid if +link{ListGrid.showSelectionCanvas,showSelectionCanvas}
    // is <code>true</code> and +link{ListGrid.showSelectionUnderCanvas,showSelectionUnderCanvas}
    // is unset, or <code>showSelectionUnderCanvas</code> is explicitly set to <code>true</code>,
    // and the +link{ListGrid.selectionType,selectionType} is
    // <smartclient>"single".</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.SelectionStyle#SINGLE}.</smartgwt>
    // This component will be created and displayed behind the selected record whenever the
    // selection changes.
    // <p>
    // The <code>selectionUnderCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the currently selected record object in the grid
    // @example gridRoundedSelection
    // @group rowEffects
    // @see ListGrid.selectionCanvas
    // @visibility external
    //<

    //>Animation

    //> @attr listGrid.animateSelection (Boolean : false : IRWA)
    // If the +link{ListGrid.selectionCanvas,selectionCanvas} is enabled, setting
    // this property to <code>true</code> ensures that when the <code>selectionCanvas</code>
    // is displayed it is animated into view via +link{Canvas.animateShow()}. Note that the
    // animation effect may be customized via +link{Canvas.animateShowEffect},
    // +link{Canvas.animateShowTime} and +link{Canvas.animateShowAcceleration} set in
    // <code>selectionCanvasProperties</code>.
    // @group rowEffects
    // @see ListGrid.animateSelectionUnder
    // @visibility external
    //<
    animateSelection: false,

    //> @attr listGrid.animateSelectionUnder (Boolean : false : IRWA)
    // If the +link{ListGrid.selectionUnderCanvas,selectionUnderCanvas} is enabled, setting
    // this property to <code>true</code> ensures that when the <code>selectionUnderCanvas</code>
    // is displayed it is animated into view via +link{Canvas.animateShow()}. Note that the
    // animation effect may be customized via +link{Canvas.animateShowEffect},
    // +link{Canvas.animateShowTime} and +link{Canvas.animateShowAcceleration} set in
    // <code>selectionUnderCanvasProperties</code>.
    // @example gridAnimatedSelection
    // @group rowEffects
    // @see ListGrid.animateSelection
    // @visibility external
    //<
    animateSelectionUnder: false,

    //<Animation

    //> @attr listGrid.checkboxField (AutoChild ListGridField : null : IR)
    // Returns the specially generated checkbox field used when +link{selectionAppearance} is
    // "checkbox".  Created via the +link{AutoChild} pattern so that
    // <code>checkboxFieldDefaults</code> and <code>checkboxFieldProperties</code> are available
    // for skinning purposes. Note that +link{listGridField.shouldPrint} is <code>false</code>
    // for the checkboxField by default - if you want this column to show up in the grid's print
    // view, use <code>checkboxFieldProperties</code> to set this property to true.
    // <P>
    // This field will render an icon to indicate the selected state of each row, which, when
    // clicked will toggle the selection state. The icon src may be configured using
    // +link{listGrid.checkboxFieldTrueImage} and +link{listGrid.checkboxFieldFalseImage}, as
    // well as +link{listGrid.checkboxFieldImageWidth} and +link{listGrid.checkboxFieldImageHeight}.
    // <P>
    // The checkboxField can be detected by calling +link{listGrid.isCheckboxField()} on any
    // ListGridField object.
    //
    // @group checkboxField
    // @visibility external
    //<

    //> @attr listGrid.checkboxFieldTrueImage (SCImgURL : null :IRWA)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // determines the image to display in the checkbox field for a selected row.
    // If unset, the +link{listGrid.booleanTrueImage} will be used. Note that the special
    // value "blank" means that no image will be shown.
    // @see ListGrid.checkboxFieldFalseImage
    // @see ListGrid.checkboxFieldImageWidth
    // @see ListGrid.checkboxFieldImageHeight
    // @see ListGrid.printCheckboxFieldTrueImage
    // @group checkboxField
    // @visibility external
    //<

    //> @attr listGrid.checkboxFieldFalseImage (SCImgURL : null :IRWA)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // determines the image to display in the checkbox field for an unselected row.
    // If unset, the +link{listGrid.booleanFalseImage} will be used. Note that the special
    // value "blank" means that no image will be shown.
    // @see ListGrid.checkboxFieldTrueImage
    // @see ListGrid.checkboxFieldImageWidth
    // @see ListGrid.checkboxFieldImageHeight
    // @see ListGrid.printCheckboxFieldFalseImage
    // @group checkboxField
    // @visibility external
    //<

    //> @attr listGrid.checkboxFieldPartialImage (SCImgURL : null :IRWA)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // determines the image to display in the checkbox field for a partially selected row.
    // If unset, the +link{listGrid.booleanPartialImage} will be used. Note that the special
    // value "blank" means that no image will be shown.
    // @see ListGrid.checkboxFieldTrueImage
    // @see ListGrid.checkboxFieldImageWidth
    // @see ListGrid.checkboxFieldImageHeight
    // @see ListGrid.printCheckboxFieldPartialImage
    // @group checkboxField
    // @group printing
    // @visibility external
    //<
    //printCheckboxFieldPartialImage:null,

    //> @attr listGrid.printCheckboxFieldTrueImage (SCImgURL : null :IRWA)
    // If set, the +link{ListGrid.checkboxFieldTrueImage} to use when +link{group:printing,printing}.
    // @see ListGrid.checkboxFieldTrueImage
    // @group checkboxField
    // @group printing
    // @visibility external
    //<
    //printCheckboxFieldTrueImage:null,

    //> @attr listGrid.printCheckboxFieldFalseImage (SCImgURL : null :IRWA)
    // If set, the +link{ListGrid.checkboxFieldFalseImage} to use when +link{group:printing,printing}.
    // @see ListGrid.checkboxFieldFalseImage
    // @group checkboxField
    // @group printing
    // @visibility external
    //<
    //printCheckboxFieldFalseImage:null,

    //> @attr listGrid.printCheckboxFieldPartialImage (SCImgURL : null :IRWA)
    // If set, the +link{ListGrid.checkboxFieldPartialImage} to use when +link{group:printing,printing}.
    // @see ListGrid.checkboxFieldPartialImage
    // @group checkboxField
    // @group printing
    // @visibility external
    //<
    //printCheckboxFieldPartialImage:null,

    //> @attr listGrid.checkboxFieldImageWidth (integer : null : IR)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // may be set to govern the width of the checkbox image displayed to indicate whether a row is
    // selected. If unset, the checkboxField image will be sized to match the
    // +link{listGrid.booleanImageWidth} for this grid.
    // @group checkboxField
    // @visibility external
    //<

    //> @attr listGrid.checkboxFieldImageHeight (integer : null : IR)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // may be set to govern the height of the checkbox image displayed to indicate whether a row is
    // selected. If unset, the checkboxField image will be sized to match the
    // +link{listGrid.booleanImageHeight} for this grid.
    // @group checkboxField
    // @visibility external
    //<

    // Empty and loading messages
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.showEmptyMessage (Boolean : true : [IRW])
    // @include gridRenderer.showEmptyMessage
    // @example emptyGrid
    //<
    showEmptyMessage:true,

    //> @attr listGrid.emptyMessage (HTMLString : "No items to show." : [IRW])
    // @include gridRenderer.emptyMessage
    // @example emptyGrid
    //<
    emptyMessage:"No items to show.",

    //> @attr listGrid.emptyMessageStyle (CSSStyleName : "emptyMessage" : [IRW])
    // The CSS style name applied to the +link{emptyMessage} if displayed.
    // @group emptyMessage
    // @visibility external
    //<
    emptyMessageStyle:"emptyMessage",

    //> @attr listGrid.filterButtonPrompt (String : "Filter" : [IR])
    // The prompt to show when the mouse hovers over the Filter button in the FilterEditor.
    // @group i18nMessages
    // @visibility external
    //<
    filterButtonPrompt : "Filter",


    //> @attr listGrid.loadingDataMessage (HTMLString : "${loadingImage}&nbsp;Loading data..." : IRW)
    // The string to display in the body of a listGrid while data is being loaded.
    // Use <code>"&#36;{loadingImage}"</code> to include +link{Canvas.loadingImageSrc,a loading image}.
    // @see loadingDataMessageStyle
    // @group emptyMessage, i18nMessages
    // @visibility external
    //<
    loadingDataMessage : "${loadingImage}&nbsp;Loading data...",

    //> @attr listGrid.loadingDataMessageStyle (CSSStyleName : "loadingDataMessage" : [IRW])
    // The CSS style name applied to the loadingDataMessage string if displayed.
    // @group emptyMessage
    // @visibility external
    //<
    loadingDataMessageStyle: "loadingDataMessage",

    //> @attr listGrid.loadingMessage (string : "&nbsp;" : IR)
    // If you have a databound listGrid and you scroll out of the currently loaded dataset, by
    // default you will see blank rows until the server returns the data for those rows.  The
    // loadingMessage attribute allows you to specify arbitrary html that will be shown in each
    // such "blank" record while the data for that record is loading.
    //
    // @group emptyMessage, i18nMessages
    // @visibility external
    //<
    loadingMessage:"&nbsp;",

    // Separator / Single Cell rows
    // ---------------------------------------------------------------------------------------

    //> @attr listGrid.singleCellValueProperty (string : "singleCellValue" : IRW)
    // If <code>record[this.singleCellValueProperty]</code> is set for some record, the
    // record will be displayed as a single cell spanning every column in the grid, with
    // contents set to the value of <code>record[this.singleCellValueProperty]</code>.
    // @visibility external
    //<
    singleCellValueProperty:"singleCellValue",

    //> @attr listGrid.isSeparatorProperty (string : "isSeparator" : IRW)
    // If <code>record[this.isSeparatorProperty]</code> is set for some record, the
    // record will be displayed as a simple separator row.
    // @visibility external
    //<
    isSeparatorProperty:"isSeparator",

    // Filter Editor (aka QBE)
    // ---------------------------------------------------------------------------------------

    //> @attr listGrid.showFilterEditor (boolean : false : IRW)
    // Should this listGrid display a filter row.  If true, this ListGrid
    // will be drawn with a single editable row, (separate from the body) with a filter button.
    // <P>
    // Values entered into this row are used as filter criteria to filter this List's data on
    // enter-keypress or filter button click. +link{listGrid.autoFetchTextMatchStyle} determines
    // the textMatchStyle for the request passed to +link{listGrid.fetchData()}.
    // <P>
    // The default +link{formItem.operator,search operator} for an item in the filterEditor can
    // be set via +link{listGridField.filterOperator}.   When <code>field.filterOperator</code> 
    // has been set calls to retrieve the criteria from the grid return +link{AdvancedCriteria}.  
    // See also +link{allowFilterOperators} for a UI that allows end users to change the search
    // operator on the fly
    // <P>
    // Note that if +link{listGrid.filterData()} or +link{listGrid.fetchData()} is called
    // directly while the filter editor is showing, the filter editor values will be updated to
    // reflect the new set of criteria. If you wish to retain the user entered filter criteria
    // and modify a subset of field values programmatically, this can be achieved by
    // copying the existing set of criteria and adding other changes - something
    // like this:
    // <smartclient>
    // <pre><code>
    //   var newCriteria = myListGrid.getFilterEditorCriteria();
    //   isc.DataSource.combineCriteria(newCriteria, {
    //      field1:"new value1",
    //      field2:"new value2"
    //   });
    //   myListGrid.setCriteria(newCriteria);
    // </code></pre>
    // </smartclient>
    // <smartgwt>
    // <pre><code>
    //   Criteria newCriteria = myListGrid.getFilterEditorCriteria();
    //   newCriteria = DataSource.combineCriteria(newCriteria,
    //      new Criteria("field1", "new value1")
    //   );
    //   myListGrid.setCriteria(newCriteria);
    // </code></pre>
    // </smartgwt>
    // In this example code we're using +link{listGrid.getFilterEditorCriteria()} rather than
    // +link{listGrid.getCriteria()} - this ensures that if the user has typed a new value into
    // the filter editor, but not yet clicked the filter button, we pick up the value the user
    // entered.  This sample code uses +link{dataSource.combineCriteria()} to combine the
    // existing filterEditorCriteria with some new custom criteria.  This technique is
    // applicable to both simple and advanced criteria.
    // <P>
    // If you call <code>filterData()</code> and pass in criteria for dataSource
    // fields that are not present in the ListGrid, these criteria will continue to be applied
    // along with the user-visible criteria.
    // <P>
    // <b>filterEditor and advanced criteria</b>: If a developer calls <code>filterData()</code>
    // on a ListGrid and passes in +link{AdvancedCriteria}, expected behavior of the filter
    // editor becomes ambiguous, since AdvancedCriteria has far more complex filter
    // expression support than the ordinary filterEditor can represent.
    // <P>
    // Default behavior for AdvancedCriteria will combine the AdvancedCriteria with the values
    // in the filter editor as follows:
    // <ul>
    // <li>If the top level criteria has operator of type "and":<br>
    //  Each field in the top level
    //  criteria array for which a 'canFilter' true field is shown in the listGrid will show up
    //  if the specified operator matches the default filter behavior
    //  (based on the +link{listGrid.autoFetchTextMatchStyle}).<br>
    //  If the user enters values in the filter editor, these will be combined with the
    //  existing AdvancedCriteria by either replacing or adding field level criteria at the top
    //  level.</li>
    // <li>If the top level criteria is a single field-criteria:<br>
    //  If the field shows up in the listGrid and is canFilter:true, it will be displayed to
    //  the user (if the operator matches the default filter behavior for the field).<br>
    //  If the user enters new filter criteria in the filterEditor, they will be combined with
    //  this existing criterion via a top level "and" operator, or if the user modifies the
    //  field for which the criterion already existed, it will be replaced.</li>
    // <li>Otherwise, if there are multiple top level criteria combined with an "or" operator,
    //  these will not be shown in the filter editor. Any filter parameters the user enters will
    //  be added to the existing criteria via an additional top level "and" operator, meaning
    //  the user will essentially filter a subset of the existing criteria</li>
    // </ul>
    //  @group filterEditor
    //  @visibility external
    //  @example filter
    //<
    
    //showFilterEditor:false

    //> @attr listGrid.filterEditor (RecordEditor AutoChild : null : R)
    // If +link{listGrid.showFilterEditor} is set to true, the <code>filterEditor</code>
    // is automatically created as an AutoChild.<br>
    // Developers may customize the AutoChild using +link{filterEditorProperties}.
    //
    // @visibility external
    //<

    //> @attr listGrid.filterEditorProperties (RecordEditor properties : null : IR)
    // Properties to apply to the automatically generated +link{listGrid.filterEditor}
    // if +link{listGrid.showFilterEditor} is true.
    // @visibility external
    //<
    filterEditorDefaults : { shouldPrint:false },


    //> @attr listGrid.filterButtonProperties (Button properties : null : IR)
    // If +link{listGrid.showFilterEditor} is true, this attribute may be used to customize the
    // filter button shown to the right of the filterEditor row.
    // @visibility external
    //<

    //> @attr listGrid.filterEditorHeight (number : 22 : IRW)
    // Height for the filterEditor, if shown.
    //
    //  @group filterEditor
    //  @visibility external
    //<
    filterEditorHeight:22,

    //> @attr listGrid.autoFetchAsFilter (boolean : null : IR)
    // Determines whether +link{filterData()} or +link{fetchData()} should be called when this
    // grid is initially filtered via +link{autoFetchData}, or filtered by the user via the
    // +link{showFilterEditor,filterEditor}.
    // @group dataBinding
    // @deprecated in favor of listGrid.autoFetchTextMatchStyle
    //<
    // Note: This was exposed in the 7.0 release candidate builds only.
    // Leaving supported (deprecated) but not publicly documented
    // If set, at init time, it will set textMatchStyle to exact or substring (handled in Canvas.js)

    //> @attr listGrid.autoFetchTextMatchStyle (TextMatchStyle : "substring" : IR)
    // When this grid is initially filtered via +link{autoFetchData}, or filtered by the user
    // via the +link{showFilterEditor,filterEditor}, this attribute can be used to set the
    // <code>textMatchStyle</code> on the dsRequest passed to <code>fetchData()</code>.
    // <P>
    // To use a mixture of textMatchStyles, set an appropriate
    // +link{formItem.operator, operator} on a field's
    // +link{listGridField.filterEditorProperties, filterEditorProperties}.
    // @group dataBinding
    // @visibility external
    //<
    // implemented in canvas.getInitialFetchContext() and recordEditor.performAction()
    autoFetchTextMatchStyle:"substring",

    
// Filter Operators

//> @attr listGrid.allowFilterOperators (Boolean : null : IR)
// Causes a menu item titled +link{filterUsingText,"Filter using"} to appear in the
// +link{showHeaderContextMenu,headerContextMenu} that allows the end user to pick an advanced
// +link{type:OperatorId,search operator} to use for this field.
// <p>
// Once an operator has been chosen, the active operator is indicated by an
// +link{operatorIcon} placed within the field (you can alternatively cause the
// icon to +link{alwaysShowOperatorIcon,always be present}).  The <code>operatorIcon</code> 
// shows the same textual representation of the search operator as is used by the
// +link{formItem.allowExpressions} feature.  Clicking on the icon provides a second way to 
// modify the search operator.  
// <p>
// This feature is enabled by default if +link{dataSource.supportsAdvancedCriteria()} is true, 
// for all fields where it is normally possible to filter by typing in a search string.  This 
// excludes field types such as "date" or "boolean" which show specialized filter controls.  
// Use +link{listGridField.allowFilterOperators} to disable this interface for individual 
// fields, or set +link{dataSourceField.canFilter} to false to disallow filtering entirely for 
// a field.
// <p>
// Note that this feature is similar to +link{listGrid.allowFilterExpressions}, which allows 
// the end users to directly type in characters such as "&gt;" to control filtering.
// <code>allowFilterOperators</code> is easier to use and more discoverable than
// <code>allowFilterExpressions</code>, and also avoids the drawback where special characters 
// like "&gt;" cannot be used in filter values.  However, <code>allowFilterExpressions</code> 
// allows users to use make of certain operators that <code>allowFilterOperators</code> does 
// not support, such as using the "betweenInclusive" operator by typing "5...10".
//
// @visibility external
//<

// the default value of allowFilterOperators is null, on both ListGrid and ListGridField - at
// runtime, calculate an appropriate value for it, first checking the field, then the grid,
// and finally allowing filterOperators if the DS supports advancedCriteria
shouldAllowFilterOperators : function (field) {
    if (this.showFilterEditor == false || this.allowFilterOperators == false) return false;
    if (this.allowFilterExpressions) return false;
    
    if (!this.dataSource) return false;
    if (field) {
        if (isc.isA.String(field)) field = this.getFieldByName(field);
        if (!field) {
            // there's no field matching the fieldName we were passed
        } else {
            var editorClass = isc.FormItemFactory.getItemClass(this.getFilterEditorType(field));
            if (!isc.isA.TextItem(editorClass)) return false;
            // support an undocumented flag, SimpleType.allowFilterOperators - if this is false,
            // return false - for now, deal with date and boolean here as well
            var type = field._simpleType,
                ST = isc.SimpleType
            ;
            if (type) {
                if (ST.inheritsFrom(type.type, "date") || ST.inheritsFrom(type.type, "datetime") ||
                    ST.inheritsFrom(type.type, "boolean")) return false;
                if (type.allowFilterOperators == false) return false;
            }

            // if the field specifies canFilter:false, return false
            if (field.canFilter == false) return false;
            // if the field specifies a value for allowFilterOperators, return it
            if (field.allowFilterOperators != null) return field.allowFilterOperators;
        }
    }
    // if the grid specifies canFilter:false, return false
    if (this.canFilter == false) return false;
    // if the grid specifies a value for allowFilterOperators, return it
    if (this.allowFilterOperators != null) return this.allowFilterOperators;
    // if there's a DS, return the result of supportsAdvancedCriteria()
    var ds = this.getDataSource();
    if (ds) return ds.supportsAdvancedCriteria();
    // otherwise, return false
    return false;
},

//> @attr listGrid.alwaysShowOperatorIcon (Boolean : null : IR)
// When +link{allowFilterOperators} is enabled, whether to show the +link{operatorIcon} for all
// filterable fields, or only for fields where the user has explicitly chosen a search operator
// different from the default operator for the field.
// <p>
// The default operator for a field is determined by +link{autoFetchTextMatchStyle} or by
// setting +link{listGridField.filterOperator} for a specific field.
// @visibility external
//<

shouldAlwaysShowOperatorIcon : function (field, item) {
    if (field) {
        if (isc.isA.String(field)) field = this.getFieldByName(field);
        if (field.alwaysShowOperatorIcon != null) return field.alwaysShowOperatorIcon;
        var filterEditor = this.getFilterEditor();
        if (!item && filterEditor) item = filterEditor.editor.getEditForm().getItem(field.name)
        if (item && item.alwaysShowOperatorIcon != null) return item.alwaysShowOperatorIcon;
    }
    if (this.alwaysShowOperatorIcon != null) return this.alwaysShowOperatorIcon;
    return false;
},

//> @attr listGrid.operatorIcon (MultiAutoChild FormItemIcon : null : I)
// Inline icon shown inside +link{listGrid.showFilterEditor,filter editor} fields when
// +link{allowFilterOperators} is enabled.
// @visibility external
//<

//> @attr listGrid.filterUsingText (String : "Filter using" : IR)
// Text for the menu item shown in the +link{showHeaderContextMenu,headerContextMenu} when
// +link{allowFilterOperators} is enabled.
// @group i18nMessages
// @visibility external
//<
filterUsingText: "Filter using",

//> @attr listGrid.defaultFilterOperatorSuffix (String : "(default)" : IR)
// Text to show after the name of the default filterOperator in the 
// +link{showHeaderContextMenu,headerContextMenu} when +link{allowFilterOperators} is enabled.
// @group i18nMessages
// @visibility external
//<
defaultFilterOperatorSuffix: "(default)",

// and some APis on ListGridField

//> @attr listGridField.allowFilterOperators (Boolean : null : IR)
// Per-field setting for +link{listGrid.allowFilterOperators}.  Can be used to enable
// the filter operators UI for a particular field if the ListGrid-level setting is not
// enabled, or to disable filter operators for a particular field if the ListGrid-level setting
// is enabled.
// @visibility external
//<

//> @attr listGridField.alwaysShowOperatorIcon (Boolean : null : IR)
// Per-field setting for +link{ListGrid.alwaysShowOperatorIcon}. Can be used to force a particular
// field to always show it's +link{ListGrid.operatorIcon, operatorIcon}, even if it has no 
// filter-value, or is using the default +link{listGridField.filterOperator, search operator}.
// @visibility external
//<

//> @attr listGridField.filterOperator (OperatorId : null : IR)
// With the +link{listGrid.showFilterEditor,FilterEditor} showing, the +link{Operator} to
// use when matching values for this field.
// <P>
// Note that you can set all FilterEditor fields to default to either substring or exact
// match via +link{listGrid.autoFetchTextMatchStyle,autoFetchTextMatchStyle}, but if you 
// want a mix of exact vs substring match on different fields, you need to use this 
// property, and your ListGrid will produce +link{AdvancedCriteria} rather than the 
// simpler +link{Criteria} format.  This is automatically and transparently handled by the 
// SmartClient Server's SQLDataSource and HibernateDataSource in Power Edition or above, 
// but if you have your own filtering implementation, it will need to be able to handle 
// AdvancedCriteria.
// @visibility external
//<


	// Editing
	// --------------------------------------------------------------------------------------------
	//> @attr listGrid.canEdit (Boolean : null : [IRW])
	//      Can the user edit cells in this listGrid? Can be set for the listGrid, and overridden for
	//      individual fields.<br>
	//      If 'canEdit' is false at the listGrid level, fields can never be edited - in this case
	//      the canEdit property on individual fields will be ignored.<br>
	//      If 'canEdit' is set to true at the listGrid level, setting the 'canEdit' property to
	//      false at the field level will prevent the field from being edited inline.<br>
	//      If 'canEdit' is not set at the listGrid level, setting 'canEdit' to true at the field
	//      level enables the field to be edited inline.
	//      @visibility external
	//      @group  editing
	//      @see    startEditing()
    //      @see listGridField.canEdit
    //      @see listGrid.recordEditProperty
    //      @see listGrid.canEditCell()
	//      @see    fields
    //      @example editByRow
	//<
	//canEdit:null,

    //> @attr listGrid.canEditNew (Boolean : null : [IRW])
    //  Can the user add new rows?
    //  @group  editing
    //  @see attr:listGrid.canEdit
    //  @see attr:listGrid.recordEditProperty
    //  @visibility internal
    //<
    canEditNew: false,

    //> @attr listGrid.recordEditProperty (string : "_canEdit" : [IRWA])
    // Property name on a record that should be checked to determine whether the record may be
    // edited.
    // <br>
    // This property is configurable to avoid possible collision with data values in record.
    // With the default setting of "_canEdit", a record can be set non-editable by ensuring
    // record._canEdit == false.
    // <br>
    // For controlling editability for the entire grid or for a field, set grid.canEdit or
    // field.canEdit.
    //
    //  @group  editing
    //  @see attr:listGrid.canEdit
    //  @see attr:listGridField.canEdit
    //  @see method:listGrid.canEditCell
    //  @visibility external
    //<
    recordEditProperty:"_canEdit",

    //> @attr listGridRecord._canEdit (boolean : null : IR)
    //
    // Default property name denoting whether this record can be edited. Property name may be
    // modified for the grid via +link{listGrid.recordEditProperty}.
    //
    // @group  editing
    // @visibility external
    //<

    // Name for property used by internal '_testRowEditData' method to track whether
    // records have been compared to edit-data in order to map rowNums to edit values.
    // Customizable, in case of collision with record data - but unlikely to be overridden.
    editValuesTestedProperty:"_editValuesTested",

    //> @attr listGrid.alwaysShowEditors (boolean : null : [IR])
    // When this attribute is set, editors will be rendered into every row of the grid rather than
    // showing up in a single record at a time.
    // This attribute is only valid when +link{listGrid.editByCell} is false
    // @group editing
    // @visibility external
    //<

    //> @attr listGrid.editByCell (boolean : null : [IRW])
    // Determines whether when the user edits a cell in this listGrid the entire row becomes
    // editable, or just the cell that received the edit event.
    // <P>
    // No effect if this.canEdit is false or null.
    //
    // @group editing
    // @see listGrid.canEdit
    // @example editByCell
    // @visibility external
    //<

    //> @attr listGrid.saveByCell (boolean : null : [IRW])
    // Whether edits should be saved whenever the user moves between cells in the current edit
    // row.
    // <P>
    // If unset, defaults to +link{editByCell,this.editByCell}.
    // <P>
    // To avoid automatic saving entirely, set +link{autoSaveEdits}:false.
    //
    //  @group  editing
    //  @visibility external
    //  @see listGrid.editByCell
    //<

    //> @attr listGrid.validateByCell (boolean : null : [IRW])
    // Whether client-side validation checks should be performed when the user moves between
    // cells in the current edit row.  If unset, defaults to +link{listGrid.editByCell}.
    // <P>
    // Note that validation always occurs when a row is to be saved, so setting
    // +link{saveByCell}:true forces validation on cell transitions.  To completely disable
    // automatic validation, set +link{neverValidate}:true.
    //
    // @group gridValidation
    // @visibility external
    // @see group:editing
    //<
    

    // autoValidate will disable validation on row-transitions, so validation will only
    // occur on save attempts.  Not currently exposed.
    autoValidate:true,

    //> @attr listGrid.validateOnChange (boolean : null : [IRW])
    // If true, validation will be performed on each edited cell when each editor's
    // "change" handler is fired.
    //
    // @see ListGridField.validateOnChange
    // @group gridValidation
    // @visibility external
    //<
    //validateOnChange:null

    //> @attr listGrid.neverValidate (boolean : null : [IRWA])
    // If true, validation will not occur as a result of cell editing for this grid.
    //  @group  gridValidation
    // @visibility external
    //<
    //neverValidate:null,


    //> @attr listGrid.canRemoveRecords (Boolean : false : IR)
    // If set, provide UI for the user to remove records from the grid as an additional field
    // showing the +link{listGrid.removeIcon}, which, when clicked, will call
    // +link{listGrid.removeRecordClick()} which removes the row from the data set (or if
    // +link{deferRemoval} is true changes the +link{listGrid.markRecordRemoved()} status
    // for the record). Individual records can be marked to prevent removal - see
    // +link{listGrid.recordCanRemoveProperty}.
    // <P>
    // To add a confirmation dialog before a record is removed, set
    // +link{listGrid.warnOnRemoval}.
    // <P>
    // If deferring removal, the record will appear marked with the +link{removedCSSText}
    // until the removal is committed via a call to +link{saveEdits()}.
    // Otherwise, the record will disappear from view. If +link{listGrid.animateRemoveRecord}
    // is true, the removed record will appear to shrink out of view when it is removed.
    // <P>
    // By default the field will display the +link{listGrid.removeIcon} next to each record, and
    // will be rendered as the rightmost column. Two mechanisms exist to further modify this field:
    // <ul>
    // <li>To change the position of the remove-field, include an explicitly specified field with
    //     the attribute +link{listGridField.isRemoveField,isRemoveField:true} set. This will then
    //     be used as the remove field instead of adding a field to the beginning of the set of
    //     columns.</li>
    // <li>Additional direct configuration of the remove field may be achieved by modifying
    //     +link{listGrid.removeFieldProperties}.</li>
    // </ul>
    // If +link{deferRemoval} is true, when a record is marked as removed, the the icon will
    // change to display the +link{listGrid.unremoveIcon} for this row. Clicking on this icon
    // will call +link{listGrid.unmarkRecordRemoved()} to mark the record as no longer pending
    // deletion.
    // @group databinding
    // @visibility external
    //<

    //> @attr listGrid.warnOnRemoval (Boolean : false : IRW)
    // If +link{listGrid.canRemoveRecords} is true, when the user clicks the remove icon
    // for some record, should we show a warning message
    // (defined as +link{listGrid.warnOnRemovalMessage}) and allow the user to cancel removal?
    // @visibility external
    //<
    warnOnRemoval:false,
    //> @attr listGrid.warnOnRemovalMessage (string : "Are you sure you want to delete this record?" : IRW)
    // Warning message to show the user on a click on the 'remove' icon
    // if +link{listGrid.canRemoveRecords} is true and
    // +link{listGrid.warnOnRemoval} is true.
    // @visibility external
    // @group i18nMessages
    //<
    warnOnRemovalMessage:"Are you sure you want to delete this record?",

    shouldShowRemoveField : function () {
        if (this.fieldSourceGrid != null) return this.fieldSourceGrid.shouldShowRemoveField();
        return this.canRemoveRecords;
    },

    //> @attr listGrid.recordRemovedProperty (string : "_removed" : IR)
    // Property name used as an edit-value on a record that has been marked for removal via
    // +link{listGrid.markRecordRemoved()}.
    //
    // @see listGridRecord.removed
    // @visibility internal
    //<
    // This property is internal - the "_removed" flag is obfuscated and unlikely to collide
    // with real world data but could be configured to be something different if this became an issue.
    recordRemovedProperty: "_removed",

    //> @method listGrid.markRecordRemoved()
    // Marks a record deleted such that a later call to +link{saveEdits()} or +link{saveAllEdits()}
    // will cause a "remove" +link{DSRequest} to be submitted.
    // <P>
    // A removed record is disabled and non-editable, and uses +link{removedCSSText} for its CSS
    // style, which by default will show strikethrough text.
    // <P>
    // Contrast this method with removeSelectedData(), which immediately submits a DSRequest to
    // remove the selected records from the dataset.
    // <P>
    // Records that have been marked for removal using this method may be 'unmarked' via a call to
    // +link{listGrid.unmarkRecordRemoved()}, or by discarding edit values (+link{discardEdits()}).
    //
    // @param rowNum (number) row number for the record to mark
    //
    // @group editing
    // @visibility external
    //<
    markRecordRemoved : function (rowNum, suppressRefresh) {
        if (!isc.isA.Number(rowNum)) rowNum = this.findRowNum(rowNum);
        // hide the edit form if we're mid-edit.
        if (this.getEditRow() == rowNum) this.hideInlineEditor();
        // deselect if we're selected.
        if (this.canSelectCells) {
            this.selection.deselectRow(rowNum);
        } else {
            var record= this.getRecord(rowNum);
            this.selection.deselect(record);
        }
        this.setEditValue(rowNum, this.recordRemovedProperty, true,
                          suppressRefresh, false, suppressRefresh);
        if (!suppressRefresh) this.refreshRow(rowNum);
    },

    //> @method listGrid.markRecordsRemoved()
    // Marks an array of records deleted such that a later call to +link{saveEdits()} or 
    // +link{saveAllEdits()} will cause a "remove" +link{DSRequest} to be submitted.
    // <P>
    // This method is similar to +link{listGrid.markRecordRemoved} but should be more efficient
    // in avoiding unneeded duplicate refreshes due to the multiple records getting marked.
    //
    // @param records (Array of ListGridRecord or number) records or indices to mark removed
    //   
    // @see listGrid.markRecordRemoved
    // @group editing
    // @visibility external
    //<
    markRecordsRemoved : function (records) {
        if (records == null) return;
        if (!isc.isAn.Array(records)) records = [records];
        for (var i = 0; i < records.length; i++) {
            this.markRecordRemoved(records[i], true);
        }
    },

    //> @method listGrid.recordMarkedAsRemoved()
    // Returns true if the specified record is marked as removed via a call to
    // +link{markRecordRemoved()}
    // @param rowNum (int) index of row to verify
    // @return (Boolean) true if the specified record has been marked for removal
    // @visibility external
    // @group editing
    //<
    recordMarkedAsRemoved : function (rowNum) {
        if (rowNum == null) return false;
        if (!isc.isA.Number(rowNum)) {
            
            rowNum = this.getEditSessionRowNum(rowNum);
            if (rowNum == null) return false;
        }
        return (this.getEditValue(rowNum, this.recordRemovedProperty) == true);
    },

    //> @method listGrid.unmarkRecordRemoved()
    // Reverses a previous call to +link{markRecordRemoved()}.
    // <P>
    // Note that a record that is marked for removal and then un-marked retains any uncommitted
    // edits from before it was marked for removal.  These can be discarded with
    // +link{discardEdits()}.
    // @param rowNum (int) index of record to clear the 'removed'
    // @group editing
    // @visibility external
    //<
    unmarkRecordRemoved : function (rowNum, suppressRefresh) {
        if (!isc.isA.Number(rowNum)) rowNum = this.findRowNum(rowNum);
        this.clearEditValue(rowNum, this.recordRemovedProperty);
        if (!suppressRefresh) this.refreshRow(rowNum);
    },

    

    //> @attr listGrid.removedCSSText (string : "text-decoration:line-through;" : [IRWA])
    //  Custom CSS text to be applied to records that have been
    // +link{listGrid.markRecordRemoved(),marked for removal}.
    // <P>
    // This CSS text will be applied on top of standard disabled styling for the cell.
    //
    // @visibility external
    // @group   appearance
    //<
    removedCSSText:"text-decoration:line-through;",

    //> @method listGrid.markSelectionRemoved()
    // Marks the currently selected records as removed, as though +link{markRecordRemoved()} had
    // been called.
    //
    // @group editing
    // @visibility external
    //<
    markSelectionRemoved : function () {
        var records = this.getSelectedRecords(),
            recordsLength = records.length;
        for (var i = 0; i < recordsLength; ++i) {
            // We can pass the record object into markRecordRemoved even though it's doc'd
            // as taking just rowNum
            this.markRecordRemoved(records[i], true);
        }
        this.markForRedraw();
    },

    //> @attr listGrid.deferRemoval (boolean : null : IR)
    // When enabled, the field shown by +link{listGrid.canRemoveRecords} causes records to be
    // marked for future removal via +link{markRecordRemoved()} instead of immediately being
    // removed.
    // <P>
    // When a record has been marked for removal, an icon in the
    // <code>canRemoveRecords</code> field allowing it to be unmarked will be displayed.
    // <P>
    // If not explicitly specified by this property, removal of records will be deferred if
    // +link{autoSaveEdits} is false for the grid.
    // @group editing
    // @visibility external
    //<

    shouldDeferRemoval : function () {
        if (this.deferRemoval != null) return this.deferRemoval;
        return !this.autoSaveEdits;
    },

    //> @attr listGrid.removeIcon (SCImgURL : "[SKIN]/actions/remove.png" : IR)
    // When +link{ListGrid.canRemoveRecords} is enabled, default icon to show in
    // the auto-generated field that allows removing records.
    // @visibility external
    //<
    removeIcon:"[SKIN]/actions/remove.png",

    //> @attr listGrid.unremoveIcon (SCImgURL : "[SKIN]/actions/undo.png" : IR)
    // When +link{ListGrid.canRemoveRecords} is enabled, this icon will be shown in the
    // auto generated field fro removing records if the record has been marked as removed via
    // +link{listGrid.markRecordRemoved()}. At this point, clicking on the icon will
    // unmark the record as removed.
    // @visibility external
    //<
    unremoveIcon:"[SKIN]/actions/undo.png",

    //> @attr listGrid.removeIconSize (Number : 16 : IRW)
    // Default width and height of +link{removeIcon,remove icons} for this ListGrid.
    //
    // @visibility external
    //<
    removeIconSize: 16,

    //> @attr listGrid.animateRemoveRecord (Boolean : true : IRW)
    // When +link{ListGrid.canRemoveRecords} is enabled, should records be animated out of view
    // when they are removed by the user?
    // @visibility external
    //<
    // When showing alternate records styles, the styles will essentially be reassigned after the
    // animation completes which means we finish our smooth animation with what looks a little like
    // a jump - not clear how to avoid this, but we could warn about this in the attribute
    // description.
    animateRemoveRecord:true,

    //> @attr listGrid.animateRemoveTime (number : 100 : IRW)
    // When animating record removal
    // +link{listGrid.animateRemoveRecord,(see animateRemoveRecord)}, if
    // +link{listGrid.animateRemoveSpeed} is not
    // set, this property designates the duration of the animation in ms.
    // @group animation
    // @visibility animation
    // @see listGrid.animateRemoveRecord
    //<
    animateRemoveTime:100,

    //> @attr listGrid.animateRemoveSpeed (number : 200 : IRW)
    // When +link{listGrid.animateRemoveRecord, animating record removal}, this property
    // designates the speed of the animation in pixels per second. Takes precedence over the
    // +link{listGrid.animateRemoveTime} property, which allows the developer to specify a
    // duration for the animation rather than a speed.
    // @group animation
    // @visibility animation
    // @see listGrid.animateRemoveRecord
    //<
    animateRemoveSpeed:200,

    //> @attr listGrid.removeFieldTitle (String : "&nbsp;" : IRWA)
    // The title to use for the +link{listGrid.removeFieldDefaults, remove field}.
    // <P>
    // By default this title is not displayed in the remove column header button as the
    // +link{listGrid.removeFieldDefaults} sets +link{listGridField.showTitle} to <code>false</code>.
    // @visibility external
    //<
    removeFieldTitle: isc.nbsp,

    //> @attr listGrid.removeFieldDefaults (ListGridField properties : {...} : IR)
    // Default configuration properties for the "remove field"
    // displayed when +link{ListGrid.canRemoveRecords} is enabled.
    // +link{classMethod:class.changeDefaults()} should be used when modifying this object.
    // <P>
    // The default configuration includes a +link{listGridField.recordClick()} handler which
    // calls +link{listGrid.removeData()} to actually perform the data removal.
    // @visibility external
    //<
    removeFieldDefaults:{
        type:"icon",
        width:24,
        showDefaultContextMenu:false,
        canEdit:false,
        canHide:false,
        canSort:false,
        canGroupBy:false,
        canFilter:false,
        autoFitWidth:true,
        showTitle:false,
        canExport: false,
        ignoreKeyboardClicks:true,
        showGridSummary: false,
        showGroupSummary: false,
        summaryValue: "&nbsp;",
        // disable this from ever being assigned as the treeField
            treeField:false

        // No need for a recordClick handler.
        // We explicitly override '_rowClick()' on the gridBody class to fire the removeRecordClick
        // event. This handles the case where the icon is marked for removal already, therefore
        // disabled, so we wouldn't get a field.recordClick notification.

        // In setFields() we override 'formatCellValue' to return the appropriate icon
        // (removeIcon / unremoveIcon).

    },

    //> @attr listGrid.removeFieldProperties (ListGridField properties : null : IR)
    // Configuration properties for the "remove field" displayed when
    // +link{ListGrid.canRemoveRecords} is enabled.
    // <smartclient>These configuration settings will be overlaid
    // on top of the +link{listGrid.removeFieldDefaults}.</smartclient>
    // @visibility external
    //<

    //> @attr listGrid.filterByCell (boolean : null : [IRWA])
    // If we're showing the filterEditor (this.showFilterEditor is true), this property
    // determines whether this list should be filtered every time the user puts focus in
    // a different field in the filter editor.
    // @group filterEditor
    // @visibility external
    //<

    //> @attr listGrid.filterOnKeypress (boolean : null : [IRWA])
    // If we're showing the filterEditor (this.showFilterEditor is true), this property
    // determines whether this list should be filtered every time the user modifies the value
    // in a field of the filter-editor. Can also be set at the field level.
    // @group filterEditor
    // @visibility external
    //<

    //> @attr listGrid.waitForSave (Boolean : false : [IRWA])
    // If this is an editable listGrid, this property determines whether the user will be
    // able to dismiss the edit form, or navigate to another cell while the save is in
    // process (before the asynchronous server response returns).
    //  @group  editing
    // @visibility external
    //<
    //waitForSave:false,

    //> @attr listGrid.stopOnErrors (Boolean : false : [IRWA])
    // If this is an editable listGrid, this property determines how failure to save due to
    // validation errors should be displayed to the user.
    // <P>
    // If this property is true, when validation errors occur the errors will be displayed
    // to the user in an alert, and focus will be returned to the first cell to fail validation.
    // <P>
    // If false, the cells that failed validation will be silently styled with the
    // editFailedBaseStyle.
    // <p>
    // <b>Note:</b> stopOnErrors being set to true implies that 'waitForSave' is also true.
    // We will not dismiss the editor until save has completed if stopOnErrors is true.
    //
    // @group editing
    // @see waitForSave
    // @visibility external
    //<
    //stopOnErrors:false,

    //> @attr listGrid.autoSaveEdits (Boolean : true : [IRWA])
    // If this ListGrid is editable, should edits be saved out when the user finishes editing
    // a row (or a cell if +link{ListGrid.saveByCell} is true).
    // <P>
    // The default of <code>true</code> indicates that edits will be
    // +link{saveByCell,automatically saved} as the
    // user navigates through the grid and/or +link{enterKeyEditAction,hits 'Enter'} to end
    // editing.  See the +link{group:editing,Grid Editing} overview for details.
    // <P>
    // Setting <code>autoSaveEdits</code> false creates a "mass update" / "mass delete"
    // interaction where edits will be retained for all edited cells (across rows if
    // appropriate) until +link{saveEdits()} is called to save a particular row, or
    // +link{saveAllEdits()} is called to save all changes in a batch.
    // <P>
    // <b>Note:</b> when +link{listGrid.groupByField,listGrid grouping} is enabled, or when
    // working with hierarchical data in a +link{treeGrid}, users have the option to hide
    // records from view by collapsing the parent folder or group. This, in conjunction with
    // <code>autoSaveEdits</code> being set to <code>false</code> can lead to a case where
    // a user is unable to save edits due to validation errors on hidden rows. Therefore we
    // recommend developers consider having validators in place such that errors are caught
    // and displayed to the user on change or editor exit rather than being caught only when
    // saving is attempted. If it's not possible for all validation to be performed immediately 
    // on row exit, we recommend that a different UI design be used that does not involve
    // <code>autoSaveEdits</code> being set to <code>false</code>.
    //
    // @group editing
    // @visibility external
    //<
    autoSaveEdits:true,

    // ListGrid validation error icon. Very similar API to the FormItem class validation error
    // icon.

    //> @attr ListGrid.showErrorIcons (boolean : true : IRW)
    //  If this grid is editable, and an edit has caused validation failure for some cell,
    //  should we show an icon to indicate validation failure?
    //  @group  errorIcon
    //  @visibility external
    //<
    showErrorIcons : true,

    //> @attr ListGrid.errorIconHeight (integer : 16 : IRW)
    //      Height of the error icon, if we're showing icons when validation errors occur.
    //  @group  errorIcon
    //  @visibility external
    //<
    errorIconHeight : 16,

    //> @attr ListGrid.errorIconWidth (integer : 16 : IRW)
    //      Height of the error icon, if we're showing icons when validation errors occur.
    //  @group  errorIcon
    //  @visibility external
    //<
    errorIconWidth : 16,

    //> @attr ListGrid.errorIconSrc (SCImgURL : "[SKIN]/ListGrid/validation_error_icon.png" : IRW)
    //      Src of the image to show as an error icon, if we're showing icons when validation
    //      errors occur.
    //  @group  errorIcon
    //  @visibility external
    //<
    errorIconSrc : "[SKIN]/validation_error_icon.png",

    //> @attr listGrid.confirmCancelEditing (Boolean : false : [IRW])
    // If this is an editable listGrid, when the user attempts to cancel an edit, should we
    // display a confirmation prompt before discarding the edited values for the record?
    //
    //  @visibility external
    //  @group  editing
    //<
    //confirmCancelEditing:false,

    //> @attr listGrid.cancelEditingConfirmationMessage (string : Cancelling this edit will discard unsaved changes for this record. Continue? : [IRW])
    // If this is an editable listGrid, and <code>this.confirmCancelEditing</code> is true
    // this property is used as the message to display in the confirmation dismissal prompt.
    //
    //  @visibility external
    //  @group  editing, i18nMessages
    //<
    cancelEditingConfirmationMessage:"Cancelling this edit will discard unsaved changes for this record. Continue?",

    //> @attr listGrid.confirmDiscardEdits (Boolean : true : [IRW])
    // For editable listGrids, outstanding unsaved edits when the user performs a new filter
    // or sort will be discarded. This flag determines whether we should display a confirmation
    // dialog with options to save or discard the edits, or cancel the action in this case.
    //
    //  @visibility external
    //  @group  editing
    //<
    confirmDiscardEdits:true,

    //> @attr listGrid.autoConfirmSaveEdits (Boolean : false : [IRW])
    // For editable listGrids, outstanding unsaved edits when the user performs a new filter
    // or sort will be discarded by default. This flag determines whether we should save such
    // edits automatically in this case.  See also +link{listGrid.confirmDiscardEdits}, which 
    // allows the user to choose whether to save or discard the unsaved edits.
    //  @visibility external
    //  @group  editing
    //<
    autoConfirmSaveEdits:false,

    //> @attr listGrid.confirmDiscardEditsMessage (string : "This action will discard unsaved changes for this list.": [IRW])
    // If <code>this.confirmDiscardEdits</code> is true, this property can be used to customize the
    // error message string displayed to the user in a dialog with options to
    // cancel the action, or save or discard pending edits in response to sort/filter actions
    // that would otherwise drop unsaved edit values.
    // @visibility external
    // @group editing, i18nMessages
    //<
    confirmDiscardEditsMessage:"This action will discard all unsaved changes for this list.",

    //> @attr listGrid.discardEditsSaveButtonTitle (string :"Save" : IRW)
    // If +link{listGrid.confirmDiscardEdits} is true this is the title for the save button
    // appearing in the lost edits confirmation dialog. Override this for localization if necessary.
    // @visibility external
    // @group editing, i18nMessages
    //<
    discardEditsSaveButtonTitle:"Save",

    //> @attr listGrid.addNewBeforeEditing (boolean : false : IRWA)
    // When creating a new edit record via 'startEditingNew()' [or tabbing beyond the end
    // of the last editable field in a list], should we contact the server to create a
    // server-side record before editing begins?
    // @group   editing
    // @visibility advancedInlineEdit
    //<
    //addNewBeforeEditing:false,

    //> @attr listGrid.rowEndEditAction (RowEndEditAction : null : IRW)
    // If the user is editing a record in this listGrid, and attempts to navigate to a field
    // beyond the end of the row, via tab (or shift-tab off the first editable field), this
    // property determines what action to take:<ul>
    // <li>"next": start editing the next (or previous) record in the list
    // <li>"same": put focus back into the first editable field of the same record.
    // <li>"done": hide the editor
    // <li>"stop": leave focus in the cell being edited
    // <li>"none": no action
    // </ul>
    // @group editing
    // @visibility external
    //<
    //rowEndEditAction:"next",

    //> @attr listGrid.listEndEditAction (RowEndEditAction : null : IRW)
    // If the user is editing the last record in this listGrid, and attempts to navigate
    // beyond the last row either by tabbing off the last editable field, or using the down
    // arrow key, this property determines what action to take:<ul>
    // <li>"next": start editing a new record at the end of the list.
    // <li>"done": hide the editor
    // <li>"stop": leave focus in the cell being edited
    // <li>"none": no action
    // </ul>
    // <P>
    // See the +link{group:editing,Grid Editing overview} and also the
    // +link{group:unsavedRecords,Editing Unsaved Records overview} for context about how newly
    // added records behave.
    //
    // @group editing
    // @visibility external
    // @example enterNewRows
    //<
    
    //listEndEditAction:"stop",

    //> @attr listGrid.showNewRecordRow (boolean    : null  : [IRW])
    // If this is an editable ListGrid, this property determines whether an extra row should
    // be displayed below the last record, which can be used to add a new record to the dataset
    //<

    //> @attr listGrid.newRecordRowMessage (string : "-- Add New Row --" : IR)
    // If this listGrid is showing the 'newRecordRow' (used for adding new rows to the end
    // of the data), this property determines what message should be displayed in this row.
    // @group editing, i18nMessages
    //<
    newRecordRowMessage:"-- Add New Row --",

    //> @attr listGrid.enterKeyEditAction (EnterKeyEditAction : "done" : IRW)
    // What to do when a user hits enter while editing a cell:
    // <ul>
    // <li>"nextCell": start editing the next editable cell in this record (or the first
    //     editable cell in the next record if focus is in the last editable cell in the row)
    // <li>"nextRow": start editing the same field in the next row (skipping any rows where
    //      that would be a non-editable cell.
    // <li>"nextRowStart": start editing the first editable cell in the next row.
    // <li>"done": hide the editor (editing is complete)
    // </ul>
    // Note that if this.autoSaveEdits is true, this may cause a save of the current edit values
    // @group   editing
    // @visibility external
    //<
    enterKeyEditAction:"done",

    //> @attr listGrid.escapeKeyEditAction (EscapeKeyEditAction : "cancel" : IRW)
    // What to do when a user hits escape while editing a cell:<ul>
    // <li>"cancel": close the editor and discard the current set of edit values
    // <li>"done": just close the editor (the edit is complete, but the edited values are retained).
    // </ul>
    // Note that if +link{autoSaveEdits} is true, this may cause a save of the current edit values
    // @group editing
    // @visibility external
    //<
    escapeKeyEditAction:"cancel",

    //> @type ListGridEditEvent
    // Event that will trigger inline editing.
    //
    // @value "click"       A single mouse click triggers inline editing
    // @value "doubleClick" A double click triggers inline editing
    // @value "none"        No mouse event will trigger editing.  Editing must be
    //                      programmatically started via +link{listGrid.startEditing()}
    //                      (perhaps from an external button) or may be triggered by
    //                      keyboard navigation if +link{listGrid.editOnFocus} is set.
    //
    // @group editing
    // @visibility external
    //<

    //> @attr listGrid.editEvent (ListGridEditEvent : "doubleClick" : IRW)
    // Event that will trigger inline editing, see +link{type:ListGridEditEvent} for options.
    // <P>
    // Note this setting has no effect unless +link{canEdit} has been set to enable editing.
    // <P>
    // See also +link{editOnFocus} and +link{startEditing}.
    //
    // @group editing
    // @visibility external
    // @example editByRow
    //<
    editEvent:isc.EH.DOUBLE_CLICK,

    //> @attr listGrid.editOnFocus (boolean : null : [IRWA])
    // Should we start editing when this widget receives focus (if this ListGrid supports
    // editing)?
    // <P>
    // Note that this property being set to true will cause editing to occur on a single
    // click, even if +link{editEvent} is <code>"doubleClick"</code>, because single clicking
    // the grid will place keyboard focus there automatically.
    // <P>
    // If this property is set together with +link{listEndEditAction} being set to "next", 
    // users can create a new edit row in an empty grid by simply tabbing into the grid.
    //
    // @group editing
    // @visibility external
    //<
    // Note that +link{canFocusInEmptyGrid} must be set to <code>true</code> for this
    // to be supported.
    // Note - editOnFocus behavior is slightly more complicated than might be imagined. Actual
    // behavior:
    // - focus must go to the body (not the header) to start editing.
    // - if we are currently editing, getting focus will not trigger a new edit.
    // - if the focus is a result of clicking on the listGrid body, we will only start editing
    //   if the user clicked on an editable cell -- this is the same behavior as with
    //   editEvent:"click"
    // - otherwise when this widget receives focus, the first editable row will become editable.

    //> @attr listGrid.editOnF2Keypress (Boolean : true : [IRWA])
    // Should we start editing when the widget has focus and the user presses the "f2" key
    // (if this ListGrid supports editing)?
    // <P>
    // Note that if +link{listGrid.editEvent} is set to <code>"click"</code> or
    // <code>"doubleClick"</code>, the <code>Space</code> or <code>Enter</code> key may
    // also be used to start editing, depending on the value for +link{generateClickOnSpace},
    // +link{generateDoubleClickOnSpace}, +link{generateClickOnEnter} and
    // +link{generateDoubleClickOnEnter}.
    // <P>
    // If +link{listGrid.canEdit} is false, or +link{listGrid.editEvent} is set to "none" this
    // property has no effect.
    //
    // @group editing
    // @visibility external
    //<
    // Tested on:
    // FF 4.0.1 (Mac)
    // Chrome 11.0.696.77 (Mac)
    // Safari 5.0.5 (Mac)
    // IE 8 (XP)
    editOnF2Keypress:true,

    
    //> @attr listGrid.editOnKeyPress (boolean : null : [IRWA])
    // If set to true, when this grid has focus, if the user starts typing character keys
    // we'll start editing the focused cell.
    // @group editing
    // @visibility internal
    //<

    //> @attr listGrid.moveEditorOnArrow (boolean : null : [IRWA])
    // If +link{listGrid.editOnKeyPress, editOnKeyPress} is true, once the user starts editing
    // a cell by typing while focused in it, should left / right arrow keys cause the
    // edit cell to shift horizontally?
    // @group editing
    // @visibility internal
    //<
    

    //> @attr listGrid.selectOnEdit (Boolean : true : [IRWA])
    //  When the user starts editing a row, should the row also be selected?
    //  <P>
    //  Note that  when this attribute is set to <code>true</code>, other all other rows in the grid
    //  will be deselected when a record is selected due to editing.
    // @group editing
    // @visibility external
    //<
    selectOnEdit : true,

    //> @attr listGridField.canToggle (Boolean : varies : IRWA)
    // Allows a boolean or +link{valueMap,valueMapped} field to be edited without going into
    // edit mode. When this attribute is set, clicking on the field will change the value - for
    // boolean fields toggling between <code>true</code> and <code>false</code>, and for valueMapped
    // fields, advancing the value to the next option in the valueMap.
    // <P>
    // To enable this feature, +link{listGrid.canEdit} must be set to true.
    // For boolean type fields <code>canToggle</code> is true by default, meaning setting
    // <code>canEdit</code> to true implies the user can toggle the value via a single click
    // without going into edit mode. You can disable this by explicitly setting
    // <code>canToggle</code> to false for a boolean field.<br>
    // Note that you can enable toggling only (without allowing the user to edit other fields)
    // by just setting +link{listGrid.editEvent,grid.editEvent:"none"}.
    // <P>
    // If +link{listGrid.editEvent} is set to "click", when the user clicks on the field,
    // the value will be toggled, and inline editing will be triggered as usual.
    // Otherwise the toggled value will be saved immediately to the server, or if
    // +link{listGrid.autoSaveEdits} has been set to false, will be stored as an edit value
    // for the record.
    //
    // @group editing
    // @visibility external
    //<

    //> @attr listGrid.enumCriteriaAsInitialValues (Boolean : true : IR)
    // In a ListGrid that has a DataSource and has filter criteria that include values for
    // fields declared as +link{type:FieldType,type "enum"} in the DataSource, by default a newly
    // edited row will use those filter criteria as initial values.
    // <P>
    // For example, if a ListGrid is showing all Accounts that have status:"Active" and a new row
    // is created, the new row will default to status:"Active" unless this flag is set to false.
    //
    // @group editing
    // @visibility external
    //<
    enumCriteriaAsInitialValues:true,

    //> @attr listGrid.application (application : null : IRW)
    //      Application to use when saving edited values in a databound ListGrid
    //  @group  editing
    //<

    //> @attr listGrid.autoComplete (AutoComplete : null : IRW)
    // Whether to do inline autoComplete in text fields during inline editing<br>
    // Overridden by +link{ListGridField.autoComplete} if specified.
    // If unset picks up the default from the appropriate editor class (subclass of FormItem).
    //
    // @see listGridField.autoComplete
    // @group autoComplete
    // @visibility external
    //<
    //autoComplete:null,

    //> @attr listGrid.uniqueMatch (boolean : true : IRW)
    // When SmartClient autoComplete is enabled, whether to offer only unique matches to the
    // user.
    // <p>
    // Can be individually enabled per TextItem, or if set for the grid as a whole, can
    // be set differently for individual fields.
    //
    // @see listGridField.uniqueMatch
    // @group autoComplete
    // @visibility autoComplete
    //<

    // autoSelectEditors - if true when the user starts editing a cell always select the content
    // of the cell
    autoSelectEditors:true,
    // defaults for the form used for inline editing
    editFormDefaults: {
        
        canSelectText:true,
        autoDraw:false,

        // show error icons on the left by default
        errorOrientation:"left",
        showErrorText:false,
        showErrorStyle:false,

        itemKeyPress:function (item, keyName, characterValue) {
            return this.grid.editorKeyPress(item, keyName, characterValue);
        }
    },

    //> @attr listGrid.longTextEditorThreshold (int : 255 : IRW)
    // When the length of the field specified by +link{attr:dataSourceField.length} exceeds this
    // value, the ListGrid shows an edit field of type +link{attr:listGrid.longTextEditorType}
    // rather than the standard text field when the field enters inline edit mode.
    //
    // @group editing
    // @visibility external
    //<
    longTextEditorThreshold : 255,

    //> @attr listGrid.longTextEditorType (string : "PopUpTextAreaItem" : IRW)
    // When the length of the field specified by +link{attr:dataSourceField.length} exceeds
    // <code>this.longTextEditorThreshold</code> show an edit field of this type
    // rather than the standard text field when the field enters inline edit mode.
    //
    // @group editing
    // @visibility external
    //<
    longTextEditorType : "PopUpTextAreaItem",

    // functions installed into FormItems used for inline editing.
    // Note - these will be executed in the scope of the form item (not in the scope of the
    // ListGrid).
    //
    // Set up keyboard handling on form items to handle user navigation via "Enter", "Escape",
    // "Tab" keypresses, etc.
    //
    // NOTE: in Moz, if the user is holding down tab and we are cancelling the field change
    // *while logging to an open Log window*, we'll be stuck in the field indefinitely.  This
    // is probably a non-bug but can look like a freeze.
    //
    // row editing: Cancel tab to prevent focus cycling through the visible form items, since
    // for the first/last editable or visible item, we want to place focus in newly drawn
    // editors (on next/previous row, or just in newly drawn area that we scrolled into)
    editorKeyDown : function (item, keyName) {
        
        if (isc.Browser.isMoz && item && item.multiple &&
            isc.isA.NativeSelectItem(item) && keyName == "Enter")
        {
            item._selectedOnEnterKeydown = item.getValue();
        }
    },

    editorKeyPress : function (item, keyName, characterValue) {

        // We will return false to cancel native behavior on any key event for the keys
        // used for navigating around the edit cells (arrow keys, tab, etc.)
        var EH = isc.EH,
            returnValue,
            editEvent;

        var isMultiLineEditor =  //>PopUpTextAreaItem
                    isc.isA.PopUpTextAreaItem(item) ||     //<PopUpTextAreaItem
                    (isc.RichTextItem && isc.isA.RichTextItem(item)) ||
                    isc.isA.TextAreaItem(item);

        if (keyName == "Tab") {

            // Always cancel the native event that would take focus from this item.
            // This is appropriate as we will always focus in the next item programmatically,
            // even if we are currently showing the entire edit row.
            
            var shift = EH.shiftKeyDown();

            // If this is a container item, with sub items, or has a number of focusable
            // icons, we may be moving focus within the item, rather than going to another
            // edit cell.  This is handled by _moveFocusWithinItem().
            if (this.ns.isA.ContainerItem(item) ||
                (item.icons != null && item.icons.length > 0
                    // If the event occurred on a PopUpTextAreaItem, native focus is either
                    // on the icon, or within the TextArea in another form.
                    // In this case we always navigate to the next cell
                    && !this.ns.isA.PopUpTextAreaItem(item))
               )
            {
                if (!this._moveFocusWithinItem(item, shift)) {
                    return false;
                }
            }

            editEvent = shift ? isc.ListGrid.SHIFT_TAB_KEYPRESS
                                            : isc.ListGrid.TAB_KEYPRESS;
            returnValue = false;

        } else if (keyName == "Enter") {
            // If the event occurred over an icon, we don't want to interfere with it, as
            // enter will activate the link (for accessibility)
            if (item.getFocusIconIndex() != null) return;

            // allow enter to work normally for text areas.  Alt + Enter overrides.
            if (isMultiLineEditor && isc.EH.altKeyDown() == false) {
                return returnValue;
            }
            if (item._selectedOnEnterKeydown != null) {
                var oldVal = item._selectedOnEnterKeydown;
                delete item._selectedOnEnterKeydown;
                item.setValue(oldVal);
            }
            editEvent = isc.ListGrid.ENTER_KEYPRESS;
            returnValue = false;

        } else if (keyName == "Escape") {
            editEvent = isc.ListGrid.ESCAPE_KEYPRESS;
            returnValue = false;

        // By default move to a new row in response to
        //  - arrow keypress (up / down)
        //  - ctrl + arrow keypress (up / down), but not if the shift key is also down
        // Exceptions:
        //  - Text area use alt+arrowKeypress only
        //  - explicitly avoid row change on alt+arrow key in SelectItem, where this is used
        //    to show / hide the pickList
        //
        
        } else if (keyName == "Arrow_Up") {
            var textArea = isMultiLineEditor;
            if (textArea && !isc.EH.altKeyDown()) return returnValue;

            if (isc.isA.SpinnerItem(item) && !isc.EH.altKeyDown()) return returnValue;

            if (isc.isA.SelectItem(item) && !isc.EH.ctrlKeyDown()) return returnValue;

            if (isc.isA.PresetCriteriaItem(item) && !isc.EH.ctrlKeyDown()) return returnValue;

            if (isc.EH.ctrlKeyDown() && isc.EH.shiftKeyDown()) return returnValue;
            editEvent = isc.ListGrid.UP_ARROW_KEYPRESS;
            returnValue = false;

        } else if (keyName == "Arrow_Down") {

            var textArea =  isMultiLineEditor;
            if (textArea && !isc.EH.altKeyDown()) return returnValue;

            if (isc.isA.SpinnerItem(item) && !isc.EH.altKeyDown()) return returnValue;

            if (isc.isA.SelectItem(item) && !isc.EH.ctrlKeyDown()) return returnValue;

            if (isc.isA.PresetCriteriaItem(item) && !isc.EH.ctrlKeyDown()) return returnValue;

            if (isc.EH.ctrlKeyDown && isc.EH.shiftKeyDown()) return returnValue;
            editEvent = isc.ListGrid.DOWN_ARROW_KEYPRESS;
            returnValue = false;

        // if the user started editing via editOnKeyPress and the 'moveEditorOnArrow' flag is true
        // we shift cells on left/right arrow
        } else if (this.moveEditorOnArrow && this._editSessionFromKeyPress) {
            if (keyName == "Arrow_Left") {
                editEvent = isc.ListGrid.LEFT_ARROW_KEYPRESS;
                returnValue = false;
            } else if (keyName == "Arrow_Right") {
                editEvent = isc.ListGrid.RIGHT_ARROW_KEYPRESS;
                returnValue = false;
            }
        }

        if (editEvent != null) {
            
            if (isc.EH.clickMaskUp()) {
                isc.EH.setMaskedFocusCanvas(null, isc.EH.clickMaskRegistry.last());
            }

            // Fire cellEditEnd to handle saving out the value / moving to the next cell as
            // appropriate
            this.cellEditEnd(editEvent);
        }

        return returnValue;
    },

    // _moveFocusWithinItem() Helper method fired when the user hits tab / shift+tab while
    // focused in some edit item. This will move focus to the appropriate icon or sub item
    // if necessary.  A return value of false indicates focus was moved within the item, so
    // should not move to another edit cell.
    _moveFocusWithinItem : function (item, shift) {
        
        if (!item) return true;
        return (!item._moveFocusWithinItem(!shift));
    },

    // Override elementFocus on the form items:
    // If we're editing the whole row, and the user clicks in a new field to focus in it,
    // call 'editCellEnd' method to perform validation / saving on the previous
    // edit field (if required).
    
    _editFormItem_elementFocus : function (suppressHandlers) {
        var cell = this._setLGEditCellForFocus(suppressHandlers);
        this.Super("elementFocus", arguments);
        this._fireLGEditorEnter(cell[0], cell[1]);
    },
    _editFormItem_setLGEditCellForFocus : function (suppressHandlers) {

        

        var form = this.form,
            lg = form.grid;
        
        
        var rowNum, colNum, fieldName, fieldChanged;
        if (lg._editorShowing) {
            rowNum = lg._editRowNum;
            if (!lg.editByCell) {
                rowNum = lg._editRowNum;
                fieldName = this.getFieldName();
                colNum = lg.fields.findIndex(lg.fieldIdProperty, fieldName);

                if (!suppressHandlers) {
                    fieldChanged = (lg._editColNum != colNum);
                    // If the user has clicked in another field in the edit form,
                    // fire editField on the appropriate field
                    if (fieldChanged) {
                    // store the new edit cell
                        lg.setNewEditCell(rowNum, colNum);
                    // fire 'cellEditEnd' to save / validate before moving to the new cell
                        lg.cellEditEnd(isc.ListGrid.EDIT_FIELD_CHANGE);

                    // Note - if we could cancel the focus here, it might make sense, as the
                    // cellEditEnd callback method will re-focus in the new focus cell, but we can't
                    // cancel the focus by simply returning false from this method.
                    // Therefore allow the focus to proceed, and fall through to the super
                    // implementation of this method which will fire focus handlers, show any
                    // 'showOnFocus' icons, etc.
                    }
                }
            } else {
                colNum = lg._editColNum;
            }
        }
        return [rowNum, colNum];
    },
    _editFormItem_fireLGEditorEnter : function (rowNum, colNum) {
        var form = this.form,
            lg = form.grid;

        if (lg._editorShowing) {
            // If this is the current edit field, and hasn't yet fired its 'editorEnter' handlers
            // fire them now.
            var rowEnter = this._rowEnterOnFocus,
                cellEnter = this._cellEnterOnFocus;
            // Note: we're clearing out the flags before we fire the handlers. If the
            // handler trips a change of edit row, etc., we want editorExit to fire.
            delete this._rowEnterOnFocus;
            delete this._cellEnterOnFocus;

            
            var editVals = isc.addProperties(
                {},
                lg.getCellRecord(rowNum,colNum),
                lg._getEditValues(rowNum,colNum)
            );

            if (cellEnter) {
                var fieldName = lg.getFieldName(colNum);
                lg._handleEditorEnter(this, rowNum, colNum, editVals[fieldName]);
            }
            if (rowEnter) lg._handleRowEditorEnter(this, rowNum, editVals);

        } else {
            lg.logWarn("suppressing editorEnter handlers on focus as listGrid._editorShowing is null");
        }
    },


    // Header
    // ----------------------------------------------------------------------------------------

    //> @groupDef gridHeader
    // Properties and methods related to the ListGrid header. ListGrid headers are implemented
    // as a +link{class:Toolbar} of buttons shown at the top of the ListGrid
    // (one button per column).<br>
    // The toolbar header provides UI for interacting with the ListGrid fields directly (sorting,
    // resizing, reordering columns, etc).
    // @visibility external
    //<

    //> @attr listGrid.header (AutoChild Layout : null : R)
    // A Toolbar used to manager the headers shown for each column of the grid.
    // @group gridHeader
    // @visibility external
    //<

    //> @attr listGrid.headerContextMenu (AutoChild Canvas : null : R)
    // The context menu displayed for column headers.
    // @group gridHeader
    // @visibility external
    //<

    //> @attr listGrid.cellContextMenu (AutoChild Layout : null : R)
    // The menu displayed when a cell is right clicked on.
    // @visibility external
    //<

    //> @attr listGrid.spanContextMenu (AutoChild Layout : null : R)
    // The menu displayed when a cell is right clicked on.
    // @group gridHeader
    // @visibility external
    //<

    //> @attr listGrid.canTabToHeader (boolean : null : IR)
    // Should the header be included in the tab-order for the page? If not explicitly specified,
    // the header will be included in the tab order for the page if +link{isc.setScreenReaderMode,isc.setScreenReaderMode()} is
    // called.
    // @group accessibility
    // @visibility external
    //<
    //canTabToHeader:null,

    //> @attr listGrid.headerHeight (number : 22 : [IRW])
    //          The height of this listGrid's header, in pixels.
    //      @setter setHeaderHeight()
    //      @visibility external
    //      @group  gridHeader, sizing
    //<
    // Note: we treat a headerHeight of zero as an equivalent of showHeader:false
    headerHeight:22,

    //> @attr listGrid.minFieldWidth (int : 15 : IRW)
    // Minimum size, in pixels, for ListGrid headers.
    // @visibility external
    //<
    minFieldWidth:15,

    //> @attr listGrid.showHeader (Boolean: true : [IRW])
    // Should we show the header for this ListGrid?
    // @group gridHeader, appearance
    // @visibility external
    //<
    showHeader:true,

    //> @attr listGrid.headerBarStyle (CSSStyleName : null : IR)
    // Set the CSS style used for the header as a whole.
    // @group   gridHeader, appearance
    // @visibility external
    //<
    //headerBarStyle:null,

    //> @attr listGrid.headerBackgroundColor (Color: "#CCCCCC" : IRW)
    // BackgroundColor for the header toolbar. Typically this is set to match the color
    // of the header buttons.
    //      @group  gridHeader, appearance
    // @visibility external
    //<
    headerBackgroundColor:"#CCCCCC",

    headerDefaults : {

        // immediately reposition headers during drag resizing, don't delay
        instantRelayout:true,
        // when the user resizes buttons, don't try to fit them into the available space -
        // allow the user to introduce hscrolling
        enforcePolicy:false,
        
        // force createButtonsOnInit to false in case a dev sets it to true globally
        createButtonsOnInit: false,

        // when the header is clicked, have it call headerClick() on us
        itemClick : function (button, buttonNum) {
            this.Super("itemClick",arguments);
            this.grid._headerClick(buttonNum, this);
        },

        itemDoubleClick : function (button, buttonNum) {
            this.Super("itemDoubleClick", arguments);
            this.grid._headerDoubleClick(buttonNum, this);
        },

        showContextMenu : function () {
            return this.grid.headerBarContextClick(this);
        },

        backgroundRepeat:isc.Canvas.NO_REPEAT,

        // don't print the header, we handle this as part of the body instead, to ensure column
        // alignment
        shouldPrint:false
    },

    //> @attr listGrid.headerButtonConstructor (Class : null : IR)
    // Widget class for this ListGrid's header buttons. If unset, constructor will be
    // picked up directly from the standard +link{class:Toolbar} button constructor.
    // @group   gridHeader, appearance
    // @visibility external
    //<

    //> @attr listGrid.headerBaseStyle (CSSStyleName : null : IR)
    // +link{Button.baseStyle} to apply to the buttons in the header, and the sorter, for
    // this ListGrid.
    // Note that, depending on the +link{listGrid.headerButtonConstructor, Class} of the header
    // buttons, you may also need to set +link{listGrid.headerTitleStyle}.
    // @group   gridHeader, appearance
    // @visibility external
    //<

    //> @attr listGrid.headerTitleStyle (CSSStyleName : null : IR)
    // +link{StretchImgButton.titleStyle} to apply to the buttons in the header, and the sorter,
    // for this ListGrid.
    // Note that this will typically only have an effect if
    // +link{listGrid.headerButtonConstructor} is set to +link{class:StretchImgButton} or a subclass
    // thereof.
    // @group   gridHeader, appearance
    // @visibility external
    //<

    //> @attr listGrid.frozenHeaderBaseStyle (CSSStyleName : null : IR)
    // If this listGrid contains any frozen fields, this property can be used to apply a custom
    // headerBaseStyle to the frozen set of fields. If unset, the standard headerBaseStyle
    // will be used for both frozen and unfrozen cells.
    // @visibility external
    // @group gridHeader, appearance, frozenFields
    // @see listGrid.headerBaseStyle
    // @see listGridField.frozen
    //<

    //> @attr listGrid.frozenHeaderTitleStyle (CSSStyleName : null : IR)
    // If this listGrid contains any frozen fields, this property can be used to apply a custom
    // headerTitleStyle to the frozen set of fields. If unset, the standard headerTitleStyle
    // will be used for both frozen and unfrozen cells.
    // @visibility external
    // @group gridHeader, appearance, frozenFields
    // @see listGrid.headerTitleStyle
    // @see listGridField.frozen
    //<


    //> @attr listGrid.headerButtonDefaults (Button Properties: {...} : IRA)
    // Defaults to apply to all header buttons. To modify this object,
    // use +link{class.changeDefaults(), ListGrid.changeDefaults()}
    // rather than replacing with an entirely new object.
    // @group   gridHeader, appearance
    // @visibility external
    //<
    headerButtonDefaults:{
        clipTitle: true,

        // override getCurrentCursor to show default (non pointer) for canSort:false fields
        getCurrentCursor : function () {
            var grid = this.parentElement ? this.parentElement.grid : null;
            var currentCursor = isc.Canvas.DEFAULT;
            if (grid && this.masterIndex != null) {
                var field = grid.getField(this.masterIndex),
                    canSort = grid._canSort(field) != false;
                if (canSort) currentCursor = isc.Canvas.HAND;
            } else {
                if (this.isSorterButton) {
                    if (!grid && isc.isA.ListGrid(this.parentElement)) grid = this.parentElement;
                    if (grid) {
                        var canSort = grid._canSort(grid._getSortFieldNum()) != false;
                        if (canSort) currentCursor = isc.Canvas.HAND;
                    }
                } else {
                    currentCursor = this.getClass().getPrototype().cursor;
                }
            }
            this.cursor = currentCursor;
            return this.Super("getCurrentCursor", arguments);
        },

        dragScrollType:"parentsOnly",
        minWidth:20,
        hoverDelay:500
    },

    //> @attr listGrid.headerButtonProperties (Button Properties: null : IRA)
    // Properties to apply to all header buttons.
    // Overrides defaults applied via  +link{ListGrid.headerButtonDefaults}.
    // @group   gridHeader, appearance
    // @visibility external
    //<

    //> @attr listGrid.clipHeaderTitles (Boolean : varies : IRA)
    // Whether the ListGrid should manage the clipping of titles of header buttons, showing
    // ellipses if the title is clipped, and potentially showing the full title
    // on +link{listGrid.showClippedHeaderTitlesOnHover,hover}.
    // <p>
    // In some cases this may be preferable to the button component's default clipping behavior
    // because if a +link{ListGrid.showSortArrow,sort arrow} or sort numeral is displayed for
    // a header, then the button's default clipping behavior may clip the sort arrow/numeral
    // whereas ListGrid-managed title clipping utilizes special HTML which keeps the sort
    // arrow/numeral visible.
    // <p>
    // This feature is automatically enabled if supported by the browser. The only supported
    // use of this attribute is to <em>disable</em> the feature by setting clipHeaderTitles
    // to false.
    // <P>
    // Note that this feature is incompatible with +link{listGridField.wrap}, and will
    // automatically be disabled for wrapping fields.
    // 
    // @group gridHeader, appearance
    // @visibility external
    //<
    
    
    clipHeaderTitles: (!isc.Browser.isIE ||
                       (isc.Browser.version > 6 && isc.Browser.isStrict) ||
                       isc.Browser.version >= 10),

    //> @attr listGrid.wrapHeaderTitles (Boolean : null : IR)
    // If +link{listGridField.wrap} is not explicitly set, should fields wrap?
    // 
    // @visibility external
    //<
    

    //> @attr listGrid.sorterConstructor (Class : Button : IR)
    // Widget class for the corner sort button, if showing.  This button displays the current
    // sort direction of the primary sort field (either the only sorted field or the first in a
    // +link{listGrid.canMultiSort, multi-sort} grid) and reverses the direction of that field
    // when clicked.  For consistent appearance, this
    // is usually set to match +link{listGrid.headerButtonConstructor}
    // @group gridHeader, appearance
    // @visibility external
    //<
    sorterConstructor:isc.Button,
    

    //> @attr listGrid.sorterButtonTitle (string : "corner menu" : IR)
    // The title for the corner sort button.  The title will only
    // +link{Class.changeDefaults(), ListGrid.changeDefaults()} rather than replacing with an
    // entirely new object.
    // @group i18nMessages, gridHeader, appearance
    // @visibility external
    //<
    sorterButtonTitle: "corner menu",

    //> @attr listGrid.sorterDefaults (object : {...} : IRA)
    // Defaults to apply to the corner sort button. To modify this object, use
    // +link{Class.changeDefaults(), ListGrid.changeDefaults()} rather than replacing with an
    // entirely new object.
    // @group gridHeader, appearance
    // @visibility external
    //<
    sorterDefaults:{
        _redrawWithParent:false,
        getTitle : function () {
            if (this.creator.loadingData && !this.creator.isEmpty()) {
                return isc.Canvas.imgHTML(isc.Canvas.loadingImageSrc);
            } else {
                return this.creator.getSortArrowImage();
            }
        },
        click : function () { return this.creator._sorterClick() },
        showContextMenu : function() { return this.creator._sorterContextClick() },
        isSorterButton: true,
        allowFilterOperators: false,
        align: "center"
    },

    //> @attr listGrid.sorterProperties (Button Properties: null : IRA)
    // Properties to apply to the sorter button. Overrides defaults applied via
    // +link{ListGrid.sorterDefaults}.
    // @group gridHeader, appearance
    // @visibility external
    //<

    // Sorting
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.sortByGroupFirst (Boolean : null : [IRW]) 
    // If set, whenever grouping is performed by an end user or by a programmatic call to 
    // +link{groupBy()}, data is implicitly sorted by all of the grouped columns, in the order 
    // they were passed to groupBy. Any user-configured sorting is applied after sorting by 
    // grouped columns.
    // <p>
    // Sorting by grouped fields will be in ascending or descending order according to whether 
    // the grid is currently sorted (by any field) in ascending or descending order, defaulting 
    // to ascending if the grid is not sorted. Implicit sorting by group can be forced to be 
    // always ascending or always descending by setting +link{groupSortDirection}.
    // <p>
    // The sorting is "implicit" in the sense that the sorting is not shown in the ListGrid 
    // headers, and not shown in the +link{multiSortDialog} if enabled.  An end user cannot 
    // currently remove the implicit sorting themselves (except by removing the grouping), 
    // though it is possible to override it by providing an explicit sort on the group's column.
    // Clicking on the grouped field's header reveals the usual sort indicators with all
    // the same semantics.
    // <p>
    // The correct way to remove implicit sorting programmatically is to call 
    // +link{setSortByGroupFirst(),setSortByGroupFirst(false)}.
    // <p>
    // Programmatic calls to +link{getSort()} will not include the implicit sort in 
    // the list of return sort specifiers, and calls to +link{setSort()} will implicitly add 
    // the sorting by grouped columns before the specified sort.
    // <p>
    // Note that directly calling ResultSet.getSort() will include the implicit sort 
    // information.
    // 
    // @group sorting, grouping
    // @visibility external
    //<

    //> @attr listGrid.groupSortDirection (SortDirection : null : [IRW]) 
    // When +link{sortByGroupFirst} is active, the sorting direction applied for implicit 
    // sorting by the field(s) used for grouping. Default of null means that sort direction 
    // is based on the current direction of user-configured sort, or is "ascending" if the 
    // user has not sorted the data.
    //
    // @group sorting, grouping
    // @visibility external
    //<
    
    //> @attr listGrid.sortBinaryByFileName (boolean : true : [IRW])
    // For any fields of +link{FieldType,type "binary"}, should sorting be performed
    // against the fileName of the value for the field? For SmartClient server backed
    // dataSources, this is applied to the record automatically as described in the
    // +link{group:binaryFields} overview.
    // <P>
    // If set to false, binary fields will be sorted against the record value for the
    // field in question. Client-side sorting does not support this, so developers who
    // actually want to support a sort against the binary itself would typically set
    // +link{resultSet.useClientSorting} to false on the +link{dataProperties} block for
    // this grid.
    // <P>
    // Note that this setting will have no effect if +link{dataSourceField.sortByField} is
    // specified
    // @group sorting
    // @visibility external
    //<
    sortBinaryByFileName:true,    
    
    //> @attr listGrid.canSort (Boolean : true : [IRW])
    // Enables or disables interactive sorting behavior for this listGrid. Does not
    // affect sorting by direct calls to the +link{listGrid.sort, sort} or
    // +link{listGrid.setSort, setSort} methods.
    //
    // @group sorting
    // @visibility external
    //<
    canSort:true,

    //> @attr listGrid.canUnsort (boolean : false : [IRW])
    // When set to true, the third click on a column header removes the sort indicator
    // from the field.
    //
    // @group sorting
    // @visibility internal
    //<
    canUnsort:false,

    //> @attr listGrid.invalidateCacheOnUnsort (boolean : false : [IRW])
    // If true, and +link{listGrid.canUnsort} is also true and the grid is databound to a
    // +link{ResultSet}, then unsort causes the grid to drop the current client-side
    // data cache and refetch the current range of records from the server.
    //
    // @group sorting
    // @visibility internal
    //<
    invalidateCacheOnUnsort: false,

    //> @attr listGrid.selectHeaderOnSort (Boolean : true : [IRW])
    // If true, show the field-header for the sorted field (or the first field in a
    // +link{listGrid.canMultiSort, multi-sort} grid) in the selected state.
    //
    // @group sorting
    // @visibility external
    //<
    selectHeaderOnSort: true,

    //> @attr listGrid.sortFieldNum (number : null : [IRW])
    // Specifies the number of the field by which to sort this listGrid. Column numbers
    // start at 0 for the left-most column.
    // @group sorting
    // @example sort
    // @visibility external
    // @deprecated as of version 7.0 in favor of +link{listGrid.sortField}
    //<
    //sortFieldNum:null,

    //> @attr listGrid.sortField (String | int : null : IR)
    // Specifies the field by which this grid should be initially sorted. Can be set to either a
    // +link{listGridField.name,field name} or the index of the field in the fields Array.
    // <P>
    // ListGrids also support being initialized with multiple-field sort via
    // +link{listGrid.initialSort}. If initialSort is specified, it will be used in preference
    // to this property.
    // <P>
    // To sort the grid after it has been initialized, use +link{ListGrid.sort()} or
    // +link{listGrid.setSort()}. Details about the current sort of a live grid can be
    // retrieved by calling +link{listGrid.getSortField()} or +link{listGrid.getSort()}
    //
    // @group sorting
    // @example sort
    // @visibility external
    //<

    //> @attr listGrid.keyboardClickField (string|number : null : [IRW])
    // When simulating click events listGrid rows as a result of keyboard events
    // (navigating using the arrow keys, space, enter for doubleClick), which column
    // should the event be generated upon?
    // Should be set to the name or index of the desired column.
    // If null, defaults to the first column where +link{listGridField.ignoreKeyboardClicks}
    // is not false.
    // @group  events
    //<

    //> @attr listGrid.sortDirection (SortDirection : "ascending" : [IRW])
    // Sorting direction of this ListGrid. If specified when the ListGrid is initialized,
    // this property will be the default sorting direction for the +link{listGrid.sortField}.
    // May be overridden by specifying +link{ListGridField.sortDirection}.
    // <P>
    // After initialization, this property will be updated on +link{ListGrid.sort()} or
    // +link{ListGrid.setSort()} to reflect the current sort direction of the grid. When
    // this grid is sorted by multiple fields, the grid's sortDirection reflects the
    // sort direction of the primary sort field.
    // @group  sorting
    // @see type:SortDirection
    // @example sort
    // @setter sort()
    // @visibility external
    //<
    
    sortDirection: "ascending",

    //> @attr listGrid.showSortArrow (SortArrow : null : [IRW])
    // Indicates whether a sorting arrow should appear for the listGrid, and its
    // location. See +link{SortArrow} for details.
    // <P>
    // Clicking the sort arrow reverses the direction of sorting for the current sort
    // column (if any), or sorts the listGrid by its first sortable column. The arrow
    // image on the button indicates the current direction of sorting.
    // If undefined, the sort arrow will show up in the sorted field, and the
    // corner sort button will be displayed if a vertical scrollbar is being displayed
    //
    // @group sorting, appearance
    // @visibility external
    //<
    
    //showSortArrow:null,

    //> @attr listGrid.canPickFields (Boolean : true : [IRW])
    // Indicates whether the field picker item and submenu should be present in the header
    // context menu. This menu allows the user to hide visible fields and show hidden fields.
    // <p>
    // By default only fields explicitly included in the +link{listGrid.fields} array will
    // be available in this menu, unless +link{listGrid.canPickOmittedFields} is set to true for
    // a databound grid.
    // <p>
    // A specific field can be omitted from the column picker via +link{listGridField.canHide}.
    //
    // @visibility external
    //<
    canPickFields: true,

    //> @attr listGrid.canPickOmittedFields (Boolean : false : [IR])
    // If this grid has a specified +link{listGrid.dataSource}, and
    // +link{listGrid.useAllDataSourceFields} is false, setting this property to true
    // will cause all dataSource fields not included in the specified set of fields to
    // show up in the +link{listGrid.canPickFields,field picker menu item}.
    // <P>
    // Has no effect if +link{listGrid.fields} is unset (as in this case all dataSource fields
    // will be displayed by default), or if +link{listGrid.canPickFields} is false.
    // @visibility external
    //<
    canPickOmittedFields:false,

    // Frozen Fields (aka Frozen Columns)
    // ---------------------------------------------------------------------------------------

    //> @groupDef frozenFields
    // Frozen fields are fields that do not scroll horizontally with other fields, remaining on
    // the screen while other fields may be scrolled off.  This feature is typically used to
    // allow basic identifying information (like an "accountId") to remain on screen while the
    // user scrolls through a large number of related fields.
    // <P>
    // Fields can be programmatically frozen via setting
    // +link{listGridField.frozen,field.frozen} to true when the grid is created, or
    // dynamically frozen and unfrozen via +link{listGrid.freezeField,freezeField()} and
    // +link{listGrid.unfreezeField,unfreezeField()}.
    // The setting +link{listGrid.canFreezeFields,canFreezeFields} enables a user interface to
    // allow end users to dynamically freeze and unfreeze fields.
    // <P>
    // The frozen fields feature is not compatible with the following features:
    // <ul>
    // <li> variable height auto-sizing records
    //      (+link{listGrid.fixedRecordHeights,fixedRecordHeights:false})
    // <li> +link{autoFitData}:"horizontal", as well as headers that autoFit to titles
    //      (normally enabled via <code>field.overflow:"visible"</code>)
    // <li> the +link{CubeGrid} subclass of ListGrid
    // <li> nested grids
    // </ul>
    // The frozen fields feature <b>is</b> compatible with column resize and reorder, selection
    // and multi-selection, loading data on demand, inline editing, drag and drop and reorder
    // of records, the +link{TreeGrid} subclass of ListGrid, and all dynamic styling-related and
    // formatting-related features.
    //
    // @title Frozen Fields
    // @visibility external
    //<

    //> @attr listGrid.canFreezeFields (boolean : null : IRW)
    // Whether an interface should be shown to allow user is allowed to dynamically "freeze" or
    // "unfreeze" columns with respect to horizontally scrolling. If unset, this property defaults
    // to <code>true</code> unless:<ul>
    // <li>+link{listGrid.fixedRecordHeights,this.fixedRecordHeights} is <code>false</code></li>
    // <li>+link{listGrid.bodyOverflow,this.bodyOverflow} is <code>"visible"</code></li>
    // <li>+link{listGrid.autoFitData,this.autoFitData} is set to <code>"horizontal"</code> or
    // <code>"both"</code></li>
    // <li>Any field has overflow set to <code>"visible"</code></li></ul>
    // <P>
    // Note that the <code>canFreezeFields</code> setting enables or disables the user
    // interface for freezing and unfreezing fields only.  Fields can be programmatically
    // frozen via setting +link{listGridField.frozen,field.frozen} to true when the grid is
    // created, or dynamically frozen and unfrozen via +link{freezeField()} and
    // +link{unfreezeField()}.
    //
    // @group frozenFields
    // @visibility external
    //<
    // Note that fixedColumnWidths:false will also disable canFreezeFields but this
    // is not currently public.

    // -------------------------
    // Formula / summary fields (picked up from databoundcomponent)
    
    //> @attr listGrid.badFormulaResultValue        (String : "." : IRW)
    // @include dataBoundComponent.badFormulaResultValue
    //<
    
    //> @attr listGrid.missingSummaryFieldValue     (String : "-" : IRW)
    // @include dataBoundComponent.missingSummaryFieldValue
    //<
    
    //> @attr listGrid.missingFormulaFieldValue (String : "-" : IRW)
    // @include dataBoundComponent.missingFormulaFieldValue
    //<

    //> @attr listGrid.canAddFormulaFields (boolean : false : IRW)
    // @include dataBoundComponent.canAddFormulaFields
    // @visibility external
    //<

    //> @method listGrid.getFormulaFieldValue()
    // @include dataBoundComponent.getFormulaFieldValue()
    // @param field (ListGridField) field that has a formula
    // @param record (Record) record to use to compute formula value
    // @return (Double or String) formula result if a valid number or
    // +link{dataBoundComponent.badFormulaResultValue} if invalid
    // @visibility external
    //<

    //> @attr listGrid.canAddSummaryFields (boolean : false : IRW)
    // @include dataBoundComponent.canAddSummaryFields
    // @visibility external
    //<

    //> @method listGrid.getSummaryFieldValue()
    // @include dataBoundComponent.getSummaryFieldValue()
    // @param field (ListGridField) field that has a summary format
    // @param record (Record) record to use to compute formula value
    // @return (String) formula result
    // @visibility external
    //<


    //> @attr listGrid.canEditHilites (boolean : false : IRW)
    // @include dataBoundComponent.canEditHilites
    // @visibility external
    //<

    // Context Menus
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.showCellContextMenus (Boolean : false : [IRW])
    // Whether to show a context menu with standard items for all context clicks on rows in the
    // body.
    // @visibility external
    //<
    //showCellContextMenus:false,

    //> @attr listGrid.openRecordEditorContextMenuItemTitle (string : "Edit" : [IRW])
    // If +link{listGrid.canOpenRecordEditor} is true and +link{listGrid.showCellContextMenus}
    // is true, this property specifies the title for the context menu item shown allowing the
    // user to perform editing on a row via an embedded form.
    // @group i18nMessages
    // @visibility nextedGrid
    //<
    openRecordEditorContextMenuItemTitle:"Edit",

    //> @attr listGrid.dismissEmbeddedComponentContextMenuItemTitle (string : "Dismiss" : IRW)
    // If +link{listGrid.showCellContextMenus} is true, and we are currently showing either
    // an embedded editor (see +link{listGrid.canOpenRecordEditor}) or an embedded
    // detail grid (see +link{listGrid.canOpenRecordDetailGrid}, this property
    // specifies the title for the context menu item shown allowing the user to dismiss the
    // embedded component.
    // @group i18nMessages
    // @visibility nextedGrid
    //<
    dismissEmbeddedComponentContextMenuItemTitle:"Dismiss",

    //> @attr listGrid.deleteRecordContextMenuItemTitle (string : "Delete" : IRW)
    // If +link{listGrid.showCellContextMenus} is true, this property
    // specifies the title for the context menu item shown allowing the user to delete the
    // record on which the contextMenu was shown.
    // @group i18nMessages
    // @visibility experimental
    //<
    deleteRecordContextMenuItemTitle:"Delete",


    //> @attr listGrid.canOpenRecordDetailGrid (boolean : true : [IRW])
    // Whether context menu items will be shown for viewing records from related DataSources in
    // grids embedded in the record.
    // <P>
    // Valid only when <code>showCellContextMenus</code> is true.
    // @visibility nestedGrid
    //<
    canOpenRecordDetailGrid:true,

    //> @attr listGrid.recordDetailGridProperties (Object : null : [IR])
    // Properties for detail grids shown embedded inside rows.
    // @visibility nestedGrid
    //<

    //> @attr listGrid.canOpenRecordEditor (boolean : true : [IRW])
    // Whether a context menu item will be shown for editing records with a form embedded in
    // the record.
    // <P>
    // Valid only when <code>showCellContextMenus</code> is true.
    // @visibility nestedGrid
    //<
    canOpenRecordEditor:true,

    //> @attr listGrid.recordEditorProperties (Object : null : [IR])
    // Properties for editor forms shown embedded inside rows.
    // @see listGrid.canOpenRecordEditor
    // @visibility nestedGrid
    //<

    //> @attr listGrid.recordEditorSaveButtonTitle (string : "Save" : [IRW])
    // Title for the Save button shown in the editor form embedded inside rows if
    // +link{listGrid.canOpenRecordEditor} is true.
    // @see listGrid.canOpenRecordEditor
    // @group i18nMessages
    // @visibility nestedGrid
    //<
    recordEditorSaveButtonTitle:"Save",

    //> @attr listGrid.recordEditorCancelButtonTitle (string : "Cancel" : [IRW])
    // Title for the Cancel button shown in the editor form embedded inside rows if
    // +link{listGrid.canOpenRecordEditor} is true.
    // @see listGrid.canOpenRecordEditor
    // @group i18nMessages
    // @visibility nestedGrid
    //<
    recordEditorCancelButtonTitle:"Cancel",


    //>!BackCompat 2007.02.02
    // showCornerContextMenu was never externally documented and we have no in-code comments
    // about having ever exposed this property, so it may be safe to get rid of this
    // back-compat

    //> @attr listGrid.showCornerContextMenu (boolean : null : [IR])
    // Whether to allow a context menu on the sorter with standard items for showing and hiding
    // fields.
    // @deprecated as of 5.6 in favor of +link{attr:listGrid.showHeaderContextMenu}
    //<
    //<!BackCompat

    //> @attr listGrid.showHeaderContextMenu (Boolean : true : [IR])
    // Whether to show a context menu on the header with standard items for showing and hiding
    // fields.  Not supported for +link{cubeGrid}.
    // @group gridHeader
    // @see method:listGrid.displayHeaderContextMenu()
    // @see method:listGrid.getHeaderContextMenuItems()
    // @visibility external
    //<
    // NOTE: avoid crashing if Menu class isn't loaded by defaulting to false.
    // when we load the Menu class, we override this default.
    //showHeaderContextMenu:false,

    // headerMenuButton
    // ----------------------------
    //> @attr listGrid.showHeaderMenuButton (Boolean : true : [IR])
    // If set to true and +link{listGrid.showHeaderContextMenu,showHeaderContextMenu} is true, the
    // +link{listGrid.headerMenuButton} will be displayed when the user rolls
    // over the header buttons in this grid.  Not supported for +link{cubeGrid}.
    // @group headerMenuButton
    // @visibility external
    //<
    // As with showHeaderContextMenu, this default should not be set to true until we know
    // for sure that Menu has been loaded (see Menu.js)
    //showHeaderMenuButton:true,

    //> @attr listGrid.leaveHeaderMenuButtonSpace (boolean : null : [IWA])
    // If +link{listGrid.showHeaderMenuButton} is true, when auto-fitting fields to
    // the title width via +link{listGrid.autoFitFieldWidths} or +link{listGridField.autoFitWidth},
    // should the button be sized such that there is enough space for the header menu button to
    // show without covering the field title?
    // <P>
    // May be explicitly specified at the +link{listGridField.leaveHeaderMenuButtonSpace,field level}
    // or at the +link{listGrid.leaveHeaderMenuButtonSpace,grid level}. If not explicitly
    // specified space will be left for fields with
    // +link{listGridField.align} set to <code>"left"</code> or <code>"right"</code>, but not for
    // fields with align set to <code>"center"</code>.
    //
    // @group headerMenuButton
    // @visibility external
    //<
    leaveHeaderMenuButtonSpace:null,

    //> @attr listGridField.leaveHeaderMenuButtonSpace (boolean : null : [IWA])
    // If +link{listGrid.showHeaderMenuButton} is true, when auto-fitting fields to
    // the title width via +link{listGrid.autoFitFieldWidths} or +link{listGridField.autoFitWidth},
    // should the button be sized such that there is enough space for the header menu button to
    // show without covering the field title?
    // <P>
    // May be explicitly specified at the +link{listGridField.leaveHeaderMenuButtonSpace,field level}
    // or at the +link{listGrid.leaveHeaderMenuButtonSpace,grid level}. If not explicitly
    // specified space will be left for fields with
    // +link{listGridField.align} set to <code>"left"</code> or <code>"right"</code>, but not for
    // fields with align set to <code>"center"</code>.
    //
    // @group headerMenuButton
    // @visibility external
    //<

    //> @attr listGrid.headerMenuButtonConstructor (className : null : [IRA])
    // Constructor for the  +link{listGrid.headerMenuButton}. If unset a standard "Button" will
    // be rendered out. Note that this property may be overridden by different skins.
    // @group headerMenuButton
    // @visibility external
    //<
    //headerMenuButtonConstructor: "StretchImgButton",

    //> @attr listGrid.headerMenuButton (AutoChild StatefulCanvas : null : [RA])
    // If +link{showHeaderMenuButton} is true, when the user rolls over the header buttons in this
    // grid the headerMenuButton will be shown over the header button in question. When clicked
    // this button will display the standard header context menu (see
    // +link{listGrid.displayHeaderContextMenu}).
    // <P>
    // +link{group:headerMenuButton,Several properties} exist to customize the appearance of the
    // headerMenuButton. Also see the +link{type:AutoChild} documentation for information on how
    // to make free-form modifications to autoChild widgets
    // @group headerMenuButton
    // @visibility external
    //<

    //> @attr listGrid.headerMenuButtonIcon (URL : "[SKIN]/ListGrid/headerMenuButton_icon.gif" : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the icon shown on the
    // auto-generated <code>headerMenuButton</code>
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonIcon:"[SKIN]/ListGrid/headerMenuButton_icon.gif",

    //> @attr listGrid.headerMenuButtonIconWidth (number : 7 : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the width of the icon
    // shown on the auto-generated <code>headerMenuButton</code>
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonIconWidth:7,

    //> @attr listGrid.headerMenuButtonIconHeight (number : 7 : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the height of the icon
    // shown on the auto-generated <code>headerMenuButton</code>
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonIconHeight:7,

    //> @attr listGrid.headerMenuButtonWidth (number : 16 : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the width of the
    // auto-generated <code>headerMenuButton</code>
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonWidth:16,

    //> @attr listGrid.headerMenuButtonHeight (measure : "100%" : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the height of the
    // auto-generated <code>headerMenuButton</code>
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonHeight:"100%",


    // Drag Resize / Reorder / Drag and Drop
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.canDragRecordsOut (Boolean : false : [IRW])
    // Indicates whether records can be dragged from this listGrid and dropped elsewhere.
    // <p>
    // <strong>NOTE:</strong> If <code>canDragRecordsOut</code> is initially enabled or might be
    // dynamically enabled after the grid is created, it may be desirable to disable
    // +link{Canvas.useTouchScrolling,touch scrolling} so that touch-dragging a record starts
    // a drag operation rather than a scroll. If +link{Canvas.disableTouchScrollingForDrag}
    // is set to <code>true</code>, then touch scrolling will be disabled automatically. However,
    // for +link{group:accessibility,accessibility} reasons, it is recommended to leave touch
    // scrolling enabled and provide an alternative set of controls that can be used to perform
    // drag and drop of records out of the grid.
    // @visibility external
    // @group  dragging
    // @see ListGridRecord.canDrag
    // @see ListGridRecord.canAcceptDrop
    // @example dragListMove
    // @example recordsAcrossWindows
    //<
    canDragRecordsOut:false,

    //> @attr listGrid.canAcceptDroppedRecords (Boolean : false : [IRW])
    // Indicates whether records can be dropped into this listGrid.
    // @visibility external
    // @group  dragging
    // @see ListGridRecord.canDrag
    // @see ListGridRecord.canAcceptDrop
    // @example dragListMove
    //<
    //canAcceptDroppedRecords:false,

    //> @attr listGrid.canReorderRecords (Boolean : false : [IRW])
    // Indicates whether records can be reordered by dragging within this <code>ListGrid</code>.
    // <p>
    // <strong>NOTE:</strong> If <code>canReorderRecords</code> is initially enabled or might be
    // +link{ListGrid.setCanReorderRecords(),dynamically enabled} after the grid is created,
    // it may be desirable to disable +link{Canvas.useTouchScrolling,touch scrolling}
    // so that touch-dragging a record starts a reorder operation rather than a scroll. If
    // +link{Canvas.disableTouchScrollingForDrag} is set to <code>true</code>, then touch
    // scrolling will be disabled automatically. However, for +link{group:accessibility,accessibility}
    // reasons, it is recommended to leave touch scrolling enabled and provide an alternative
    // set of controls that can be used to perform drag-reordering of records.
    // @group  dragging
    // @see ListGridRecord.canDrag
    // @see ListGridRecord.canAcceptDrop
    // @example dragListMove
    // @example gridsDragReorder
    // @visibility external
    //<
    //canReorderRecords:false,

    //> @attr listGrid.canReorderFields (Boolean : true : [IRW])
    // Indicates whether fields in this listGrid can be reordered by dragging and
    // dropping header fields.
    // @visibility external
    // @group  dragging
    // @example columnOrder
    //<
    canReorderFields:true,

    //> @attr listGrid.canResizeFields (Boolean : true : [IRW])
    // Indicates whether fields in this listGrid can be resized by dragging header
    // fields.
    // @visibility external
    // @group  dragging
    // @example columnSize
    //<
    canResizeFields:true,

    // for dragging records out, use the drag tracker
    dragAppearance:isc.EH.TRACKER,

    // if you set canDragResize to true on the grid show an outline rather than the tracker!
    dragResizeAppearance:isc.EH.OUTLINE,

    //> @type DragTrackerMode
    // When records are being dragged from within a ListGrid, what sort of drag-tracker
    // should be displayed?
    // @value "none" Don't display a drag tracker at all
    // @value "icon" Display an icon to represent the record(s) being dragged. Icon src is
    //              derived from +link{ListGrid.getDragTrackerIcon()}
    // @value "title" Display a title for the record being dragged. Title derived from
    //              +link{ListGrid.getDragTrackerTitle()}
    // @value "record" Display the entire record being dragged
    // @group dragTracker
    // @visibility external
    //<

    //> @attr listGrid.dragTrackerMode (DragTrackerMode : "icon" : [IRA])
    // When records are being dragged from within a ListGrid, what sort of drag-tracker
    // should be displayed?<br>
    // Note that if multiple records are being dragged the displayed tracker will be
    // based on the first selected record.
    // @group dragTracker
    // @visibility external
    //<
    dragTrackerMode:"title",
    

    //> @attr listGrid.resizeFieldsInRealTime (boolean : see below : IRWA)
    // If <code>true</code>, the grid contents are redrawn in real time as fields are resized.
    // This can be slow with a large grid and/or on some platforms. By default, this is enabled
    // in modern desktop browsers. This is automatically switched off in mobile browsers.
    //
    // @group dragging
    // @visibility external
    //<
    resizeFieldsInRealTime: ((isc.Browser.isIE && isc.Browser.isWin)
                            || (isc.Browser.isFirefox && isc.Browser.geckoVersion >= 20080529)
                            // Safari 3.0+, Google Chrome
                            || (isc.Browser.isSafari && isc.Browser.safariVersion >= 500)),

    //> @attr listGrid.dragDataAction
    // @include dataBoundComponent.dragDataAction
    //<

    // Embedded Components
    // --------------------------------------------------------------------------------------------
    embeddedComponentIndent: 25,

    // Nested Master-Detail
    // --------------------------------------------------------------------------------------------
    nestedGridDefaults : {
        height:150
    },

    // Skinning
    // --------------------------------------------------------------------------------------------
    //> @attr listGrid.skinImgDir (URL : "images/ListGrid/" : IRWA)
    // Where do 'skin' images (those provided with the class) live?
    // @group appearance, images
    // @visibility external
    //<
    skinImgDir:"images/ListGrid/",

    //> @attr listGrid.sortAscendingImage (ImgProperties : {...} : IRWA)
    // Image to show when sorting ascending. See +link{class:ImgProperties} for format.
    // @group appearance
    // @visibility external
    //<
    sortAscendingImage:{src:"[SKIN]sort_ascending.gif", width:7, height:7},

    //> @attr listGrid.sortDescendingImage (ImgProperties : {...} : IRWA)
    // Image to show when sorting descending. See +link{class:ImgProperties} for format.
    // @group appearance
    // @visibility external
    //<
    sortDescendingImage:{src:"[SKIN]sort_descending.gif", width:7, height:7},

    //> @attr listGrid.trackerImage (ImgProperties : {...} : IRWA)
    // Default image to use for the dragTracker when things are dragged within or out of this
    // list. See +link{class:ImgProperties} for format.
    //
    // @group dragTracker
    // @see listGrid.dragTrackerMode
    // @see listGrid.getDragTrackerIcon()
    // @visibility external
    //<
    trackerImage:{src:"[SKIN]tracker.gif", width:16, height:16},

    //> @attr listGrid.booleanBaseStyle (CSSStyleName : null : IRA)
    // An optional CSS style to apply to the checkbox image. If supplied, and the checkbox is
    // enabled, the base style is suffixed with "True", "False", or "Partial" if the checkbox
    // is selected, unselected, or partially selected; if the checkbox is disabled, the suffix
    // is "TrueDisabled", "FalseDisabled", or "PartialDisabled".
    // <p>
    // <b>NOTE:</b> This attribute is not supported by +link{TreeGrid}.
    // @group imageColumns
    // @see ListGrid.printBooleanBaseStyle
    // @visibility external
    //<

    //> @attr listGrid.printBooleanBaseStyle (CSSStyleName : null : IRA)
    // If set, the +link{ListGrid.booleanBaseStyle,booleanBaseStyle} to use when +link{group:printing,printing}.
    // @group imageColumns
    // @group printing
    // @see ListGrid.booleanBaseStyle
    // @visibility external
    //<

    //> @attr listGrid.booleanTrueImage (SCImgURL : null : IRWA)
    // Image to display for a true value in a boolean field. The special value "blank" means
    // that no image will be shown.
    // <P>
    // To turn this off explicitly set +link{listGridField.suppressValueIcon} to true.
    // <P>
    // If this, +link{listGrid.booleanFalseImage} and +link{listGrid.booleanPartialImage}
    // are unset, this will be set to the default +link{CheckboxItem.checkedImage}.
    // <P>
    // When +link{group:skinning,spriting} is enabled, this property will not 
    // be used to locate an image, instead, the image is drawn via CSS based on the 
    // +link{ListGrid.booleanBaseStyle} property.
    // @see ListGrid.booleanFalseImage
    // @see ListGrid.booleanPartialImage
    // @see ListGrid.printBooleanTrueImage
    // @group imageColumns
    // @visibility external
    //<
    booleanTrueImage:null,

    //> @attr listGrid.booleanFalseImage (SCImgURL : null : IRWA)
    // Image to display for a false value in a boolean field. Default <code>null</code> value
    // or the special value "blank" means no image will be displayed.
    // <P>
    // To turn this off explicitly set +link{listGridField.suppressValueIcon} to true
    // <P>
    // If this, +link{listGrid.booleanTrueImage} and +link{listGrid.booleanPartialImage}
    // are unset, this will be set to the default +link{CheckboxItem.uncheckedImage}.
    // <P>
    // When +link{group:skinning,spriting} is enabled, this property will not 
    // be used to locate an image, instead, the image is drawn via CSS based on the 
    // +link{ListGrid.booleanBaseStyle} property.
    // @group imageColumns
    // @see ListGrid.booleanTrueImage
    // @see ListGrid.booleanPartialImage
    // @see ListGrid.printBooleanFalseImage
    // @visibility external
    //<
    booleanFalseImage:null,

    //> @attr listGrid.booleanPartialImage (SCImgURL : null : IRWA)
    // Image to display for a partially true value in a boolean field (typically selection).
    // The special value "blank" means that no image will be shown.
    // <P>
    // To turn this off explicitly set +link{listGridField.suppressValueIcon} to true.
    // <P>
    // If this, +link{listGrid.booleanTrueImage} and +link{listGrid.booleanFalseImage}
    // are unset, this will be set to the default +link{CheckboxItem.partialSelectedImage}.
    // <P>
    // When +link{group:skinning,spriting} is enabled, this property will not 
    // be used to locate an image, instead, the image is drawn via CSS based on the 
    // +link{ListGrid.booleanBaseStyle} property.
    // @see ListGrid.booleanTrueImage
    // @see ListGrid.booleanFalseImage
    // @see ListGrid.printBooleanPartialImage
    // @group imageColumns
    // @visibility external
    //<
    booleanPartialImage:null,

    //> @attr listGrid.printBooleanTrueImage (SCImgURL : null : IRWA)
    // If set, the +link{ListGrid.booleanTrueImage} to use when +link{group:printing,printing}.
    // <p>
    // If this, +link{listGrid.printBooleanFalseImage} and +link{listGrid.printBooleanPartialImage}
    // are unset, this will be set to the default +link{CheckboxItem.printCheckedImage}.
    // @group imageColumns
    // @group printing
    // @see ListGrid.booleanTrueImage
    // @visibility external
    //<
    printBooleanTrueImage:null,

    //> @attr listGrid.printBooleanFalseImage (SCImgURL : null : IRWA)
    // If set, the +link{ListGrid.booleanFalseImage} to use when +link{group:printing,printing}.
    // <p>
    // If this, +link{listGrid.printBooleanTrueImage} and +link{listGrid.printBooleanPartialImage}
    // are unset, this will be set to the default +link{CheckboxItem.printUncheckedImage}.
    // @group imageColumns
    // @group printing
    // @see ListGrid.booleanFalseImage
    // @visibility external
    //<
    printBooleanFalseImage:null,

    //> @attr listGrid.printBooleanPartialImage (SCImgURL : null : IRWA)
    // If set, the +link{ListGrid.booleanPartialImage} to use when +link{group:printing,printing}.
    // <p>
    // If this, +link{listGrid.printBooleanTrueImage} and +link{listGrid.printBooleanFalseImage}
    // are unset, this will be set to the default +link{CheckboxItem.printPartialSelectedImage}.
    // @group imageColumns
    // @group printing
    // @see ListGrid.booleanPartialImage
    // @visibility external
    //<
    printBooleanPartialImage:null,

    //> @attr listGrid.booleanImageWidth (number : 16 : IRWA)
    // Width for the +link{listGrid.booleanTrueImage}, +link{listGrid.booleanFalseImage}
    // and +link{listGrid.booleanPartialImage}.
    // Note: If +link{listGrid.booleanTrueImage} is unset, the +link{checkboxItem.checkedImage}
    // will be used to indicate a true value in a boolean field. In this case this property is
    // ignored in favor of +link{checkboxItem.valueIconWidth}.
    // @group imageColumns
    // @visibility external
    //<
    
    booleanImageWidth:16,

    //> @attr listGrid.booleanImageHeight (number : 16 : IRWA)
    // Height for the +link{listGrid.booleanTrueImage}, +link{listGrid.booleanFalseImage}
    // and +link{listGrid.booleanPartialImage}.
    // Note: If +link{listGrid.booleanTrueImage} is unset, the +link{checkboxItem.checkedImage}
    // will be used to indicate a true value in a boolean field. In this case this property is
    // ignored in favor of +link{checkboxItem.valueIconHeight}.
    // @group imageColumns
    // @visibility external
    //<
    booleanImageHeight:16,

    
    //> @attr listGrid.mozBodyOutlineColor (string : "white" : IRWA)
    // If we're in Moz Firefox 1.5 or above, and showing a header, what color should the
    // dotted focus outline show around the body. Must be a color that contrasts with the
    // header of the ListGrid.
    // @visibility internal
    //<
    mozBodyOutlineColor:"white",
    //> @attr listGrid.mozBodyNoHeaderOutlineColor (string : "red" : IRWA)
    // If we're in Moz Firefox 1.5 or above, and we're not showing a header, what color
    // should the dotted focus outline show around the body. Must be a color that contrasts
    // with the header of the ListGrid.
    // @visibility internal
    //<
    mozBodyNoHeaderOutlineColor:"red",



// -----------------------------------------------------------------------------------------
// row numbers
//

    //> @attr listGrid.showRowNumbers (boolean : null : IRWA)
    // When set to true, shows an additional field at the beginning of the field-list
    // (respecting RTL) that displays the current rowNum for each record.
    // @group rowNumberField
    // @visibility external
    //<

    //> @attr listGrid.rowNumberStyle (CSSStyleName : "specialCol" : IRWA)
    // The CSS Style name for the +link{listGrid.rowNumberField}.
    // @group rowNumberField
    // @visibility external
    //<
    rowNumberStyle: "specialCol",
    
    //> @attr listGrid.applyRowNumberStyle (boolean : true : IRWA)
    // If +link{showRowNumbers} is true, should we apply the +link{rowNumberStyle} to
    // the +link{listGrid.rowNumberField}
    // @group rowNumberField
    // @visibility external
    //<
    applyRowNumberStyle:true,

    //> @attr listGrid.rowNumberStart (number : 1 : IRWA)
    // The number to start the row-count from - default value is 1.
    // @group rowNumberField
    // @visibility external
    //<
    rowNumberStart: 1,

    //> @attr listGrid.rowNumberField (AutoChild ListGridField : null : IRWA)
    // An automatically generated field that displays the current row number when
    // +link{listGrid.showRowNumbers, showRowNumbers} is true.
    // @group rowNumberField
    // @visibility external
    //<
    rowNumberFieldDefaults: {
        name: "_rowNumberField",
        excludeFromState:true,
        canEdit: false,
        canFilter:false,
        canGroupBy: false,
        canSort: false,
        canExport: false,
        canHide: false,
        canReorder: false,
        canDragResize: false,
        // make this special field canHilite false so we don't see it in HiliteEditors by default
        canHilite: false,
        showAlternateStyle: false,
        _isRowNumberField: true,
        showDefaultContextMenu: false,
        keyboardFiresRecordClick: false,
        showGroupSummary:false,
        showGridSummary:false,
        summaryValue: "&nbsp;",
        formatCellValue : function (value, record, rowNum, colNum, grid) {
            if (grid.isGrouped) {
                if (record == null || record._isGroup) return "&nbsp;";
                
                var groupedRowNum = grid.getGroupedRecordIndex(record);
                // skip any records we can't find in the group tree (EG summary rows)
                if (groupedRowNum == -1) return null;
                return (grid.rowNumberStart + groupedRowNum);
            } else {
                return this.rowNumberStart + rowNum;
            }
        },
        autoFreeze: true,
        // disable this from ever being assigned as the treeField
        treeField:false

    },

    // helper method to get index of the group in which a record exists
    getParentGroupIndex : function (record) {
        // bail if we're not grouped (return group 0)
        if (!this.isGrouped) return 0;

        // find out which group this record is in
        var tree = this.groupTree,
            parentNode = tree.getParent(record),
            rootChildren = tree.getChildren(tree.getParent(parentNode)),
            groupCount = 0;

        if (!isc.isA.ResultSet(rootChildren) || rootChildren.lengthIsKnown()) {
            for (var i = 0, length = rootChildren.getLength(); i < length; ++i) {
                var child = rootChildren.getCachedRow(i);
                if (child != null && child.groupValue == parentNode.groupValue) {
                    groupCount = i;
                    break;
                }
            }
        }

        return groupCount;
    },

    // helper method to get the true row-number for a grouped record, whether or not prior groups are closed
    getGroupedRecordIndex : function (record) {
        // bail if we're not grouped
        if (!this.isGrouped) return -1;
        // find the true index of this record in a grouped grid - indexOf doesn't cater for
        // closed groups
        var tree = this.groupTree,
            
            parentNode = tree == null ? null : tree.getParent(record);

        // Checking for parentNode == null allows us to skip group-summary nodes which
        // shouldn't be counted anyway.
        if (parentNode == null) return -1;

        var rootChildren = tree.getChildren(tree.getParent(parentNode)),
            groupCount = 0,
            trueIndex = 0;

        if (!isc.isA.ResultSet(rootChildren) || rootChildren.lengthIsKnown()) {
            for (var i = 0, rootChildrenLength = rootChildren.getLength(); i < rootChildrenLength; ++i) {
                var child = rootChildren.getCachedRow(i);
                if (child != null) {
                    if (child.groupValue == parentNode.groupValue) {
                        var siblings = tree.getChildren(child);
                        if (!isc.isA.ResultSet(siblings) || siblings.lengthIsKnown()) {
                            for (var j = 0, siblingsLength = siblings.getLength(); j < siblingsLength; ++j) {
                                var sibling = siblings.getCachedRow(j);
                                if (sibling != null && this.objectsAreEqual(sibling, record)) {
                                    return trueIndex + j;
                                }
                            }
                        }
                    }
                    var prevSiblings = tree.getChildren(child);
                    if (!isc.isA.ResultSet(prevSiblings) || prevSiblings.lengthIsKnown()) {
                        var length = prevSiblings.getLength();
                        // Don't count group summary rows - these show up at the end of the
                        // group [and we support an arbitrary number of them]
                        if (this.showGroupSummary && !this.showGroupSummaryInHeader) {
                            for (var ii = length - 1; ii >=0; --ii) {
                                var prevSibling = prevSiblings.getCachedRow(ii);
                                if (prevSibling != null) {
                                    if (prevSibling[this.groupSummaryRecordProperty]) --length;
                                    else break;
                                }
                            }
                        }
                        trueIndex += length;
                    }
                }
            }
        }

        return trueIndex;
    },

    // helper method to compare the properties on two objects
    objectsAreEqual : function (object1, object2) {
        for (var key in object1) {
            if (object1[key] != object2[key]) return false;
        }
        return true;
    },

    _rowNumberFieldWidth: 30,
    getRowNumberField : function () {
        var grid = this,
            rnField = {
                // default the width
                width:this._rowNumberFieldWidth,
                rowNumberStart: this.rowNumberStart,
                getAutoFreezePosition: function () { return grid.getRowNumberFieldPosition() }
            }
        ;
        if (this.applyRowNumberStyle) rnField.baseStyle = this.rowNumberStyle;
        isc.addProperties(rnField, this.rowNumberFieldDefaults, this.rowNumberFieldProperties);

        rnField.title = isc.nbsp;

        return rnField;
    },

    getCurrentRowNumberField : function () {
        var fields = this.completeFields || this.fields,
            rnFields = fields.find(this.fieldIdProperty, "_rowNumberField");
        return !rnFields ? null : isc.isAn.Array(rnFields) ? rnFields[0] : rnFields;
    },

    //> @method listGrid.isRowNumberField()
    // Identifies whether the passed-in field is the specially generated
    // +link{listGrid.rowNumberField, rowNumberField} used when +link{showRowNumbers} is
    // true.  Use this method in your custom event handlers to avoid inappropriately
    // performing actions when the rowNumberField is clicked on.
    //
    // @param field (ListGridField) field to test
    // @return (Boolean) whether the provided field is the rowNumberField
    // @group rowNumberField
    // @visibility external
    //<
    isRowNumberField : function (field) {
        if (!field || !field._isRowNumberField) return false;
        else return true;
    },

    // helper function to get the rowNumber field position
    // Appears at the far left of the grid, to the left of the other special fields which are
    // - group summary title field
    // - expansion component icon field
    // - checkbox selection field
    getRowNumberFieldPosition : function () {
        if (this.fieldSourceGrid) return this.fieldSourceGrid.getRowNumberFieldPosition();
        if (!this.shouldShowRowNumberField()) return -1;
        return 0;
    },

    shouldShowRowNumberField : function () {
        // fieldSourceGrid: for cases like the summaryRow / filterEditor where we
        // share field objects across grids (and don't necessarily percolate settings like
        // 'showRowNumbers').
        return this.fieldSourceGrid ? this.fieldSourceGrid.shouldShowRowNumberField()
                                    : (this.showRowNumbers == true);
    },

    //> @attr listGrid.exportRawValues (Boolean : null : IR)
    // Dictates whether the data in this grid should be exported raw by
    // +link{listGrid.exportClientData, exportClientData()}.  If set to true,
    // data will not be processed by field-formatters during exports.
    // Decreases the time taken for large exports.  This property can also be set at the
    // +link{listGridField.exportRawValues, field level}.
    //
    // @visibility external
    //<

// -----------------------------------------------------------------------------------------
// Expando Rows
//

    //> @type ExpansionComponentPoolingMode
    // The method of pooling to employ for +link{listGrid.canExpandRecords,expansionComponents}.
    // <P>
    // @value "destroy" auto-created, built-in components are destroyed when record are
    //        +link{listGrid.collapseRecord,collapsed}.
    // @value "none" all expansion components are deparented from the grid when a record is
    //        +link{listGrid.collapseRecord,collapsed} but are not destroyed.  It is the responsibility
    //        of the developer to handle component destruction
    // @visibility external
    //<

    //> @attr listGrid.expansionComponentPoolingMode (ExpansionComponentPoolingMode : "destroy" : IRWA)
    // The method of +link{type:RecordComponentPoolingMode, component-pooling} to employ for
    // +link{canExpandRecords,expansionComponents}.
    // <P>
    // The default mode is "destroy", which means that automatically created expansionComponents
    // are destroyed when rows are collapsed.
    //
    // @visibility external
    //<
    expansionComponentPoolingMode: "destroy",

    
    destroyCustomExpansionComponents: false,

    //> @attr listGrid.canExpandRecords (Boolean : false : IRWA)
    // When set to true, shows an additional field at the beginning of the field-list
    // (respecting RTL) to allow users to expand and collapse individual records.
    // See +link{listGrid.expandRecord()} and +link{listGrid.expansionMode} for details
    // on record expansion.
    // <P>
    // +link{listGrid.virtualScrolling} is automatically enabled when canExpandRecords is
    // set to true.
    // <P>
    // Note that expanded records are not currently supported in conjunction
    // with +link{listGridField.frozen,frozen fields}.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.canExpandMultipleRecords (Boolean : true : IRWA)
    // When +link{listGrid.canExpandRecords} is true, this property indicates whether multiple
    // records can be expanded simultaneously.  If set to false, expanding a record will
    // automatically collapse any record which is already expanded.  The default value is
    // <code>true</code>.
    //
    // @group expansionField
    // @visibility external
    //<
    canExpandMultipleRecords: true,

    //> @attr listGrid.maxExpandedRecords (integer : null : IRWA)
    // When +link{listGrid.canExpandRecords} and +link{listGrid.canExpandMultipleRecords} are
    // both true, this property dictates the number of
    // records which can be expanded simultaneously.  If the expanded record count hits the
    // value of this property, further attempts to expand records will result in a popup
    // warning (see +link{listGrid.maxExpandedRecordsPrompt}) and expansion will be cancelled.
    // <P>
    // The default value is null, meaning there is no limit on the number of expanded records.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.maxExpandedRecordsPrompt (HTMLString : "This grid is limited to ${count} simultaneously expanded records.  Please collapse some expanded records and retry." : IR)
    // This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code
    // when the message is displayed. Note that the local variable <code>count</code> will be
    // available and set to this.maxExpandedRecords. The string will be executed in the scope of the
    // ListGrid so <code>this</code> may also be used to determine other information about this grid.
    // <P>
    // Default value returns <P>
    // <code>
    // <i>This grid is limited to <code>[+link{listGrid.maxExpandedRecords}]</code> simultaneously
    // expanded records.  Please collapse some expanded records and retry.</i>
    // </code>
    // @visibility external
    // @group i18nMessages
    //<
    maxExpandedRecordsPrompt: "This grid is limited to ${count} simultaneously expanded records.  Please collapse some expanded records and retry.",

    //> @type ExpansionMode
    // When +link{ListGrid.canExpandRecords, canExpandRecords} is true, ExpansionMode
    // dictates the type of UI to be displayed in the expanded portion of the row.
    // <P>
    // There are a number of builtin ExpansionModes and you can override
    // +link{listGrid.getExpansionComponent, getExpansionComponent()} to create your own
    // expansion behaviors.
    //
    //  @value  "detailField"  Show a single field's value in an +link{class:HtmlFlow}. Field
    //      to use is +link{listGrid.detailField}.
    //  @value  "details"   Show a +link{class:DetailViewer} displaying those fields from the
    //      record which are not already displayed in the grid.
    //  @value  "related"    Show a separate +link{class:ListGrid} containing related-records.
    //      See +link{ListGridRecord.detailDS} and +link{ListGrid.recordDetailDSProperty} for
    //      more information.
    //  @value  "editor"    Show a +link{class:DynamicForm} to edit those fields from the
    //      record which are not already present in the grid.  If the record is collapsed with
    //      unsaved changes and +link{listGrid.expansionEditorShowSaveDialog} is not set, Edits
    //      will be saved automatically, or stored as +link{group:editing,editValues} if
    //      +link{listGrid.autoSaveEdits} is false.  Otherwise, a confirmation dialog is
    //      displayed.  Can optionally show a
    //      +link{listGrid.showExpansionEditorSaveButton,save button} and
    //      +link{listGrid.expansionEditorCollapseOnSave,auto-collapse} when save is pressed.
    //      If a record fails validation on save and the field in question is not visible in
    //      the grid, the record is automatically expanded and validated to show the errors.
    //  @value  "detailRelated"    Show a +link{class:DetailViewer} displaying those fields
    //      from the record not already displayed in the grid, together with a separate
    //      +link{class:ListGrid} containing related-records.
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.detailField (String : null : IRWA)
    // The field whose contents to show in the expanded portion of a record when
    // +link{listGrid.canExpandRecords, canExpandRecords} is <code>true</code> and
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>detailField</code>.
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.expansionMode (ExpansionMode : null : IRWA)
    // The +link{ExpansionMode} for records in this grid.
    // Default <code>null</code> value means no expansion.
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.expansionField (AutoChild ListGridField : null : IRWA)
    // The field providing the facility to expand and collapse rows.
    // @group expansionField
    // @visibility external
    //<
    expansionFieldDefaults: {
        name: "_expansionField",
        canEdit: false,
        canFilter:false,
        canGroupBy: false,
        canSort: false,
        canExport: false,
        canHide: false,
        canReorder: false,
        canDragResize: false,
        // make this special field canHilite false so we don't see it in HiliteEditors
        canHilite: false,
        _isExpansionField: true,
        showDefaultContextMenu: false,
        keyboardFiresRecordClick: false,
        cellAlign: "center",
        summaryValue: "&nbsp;",
        recordClick: function (viewer, record, recordNum, field, fieldNum, value, rawValue) {
            if (!viewer.canExpandRecords || !field._isExpansionField) return;
            if (!viewer._canExpandRecord(record, recordNum)) return;
            if (viewer.isExpanded(record)) viewer.collapseRecord(record);
            else viewer.expandRecord(record);
        },
        formatCellValue : function (value, record, rowNum, colNum, grid) {
            // This ensures that if we're looking at an edit row for a new record we
            // don't show the expansion icon
            record = grid.getCellRecord(rowNum, colNum);
            if (record == null || record._isGroup) return null;
            if (!grid._canExpandRecord(record, rowNum)) return null;
            var src = grid.isExpanded(record) ? grid.expansionFieldTrueImage : grid.expansionFieldFalseImage
            if (grid.expansionFieldImageShowRTL && grid.isRTL()) {
                src = isc.Img.urlForState(src, null, null, null, null, "rtl");
            }
            return grid.getValueIconHTML(src, this);
        },
        autoFreeze: true,
        // disable this from ever being assigned as the treeField
        treeField:false

    },

    // Helper method - should this grid show the special expansion field when canExpandRecords is true
    shouldShowExpansionField : function () {
        return this.fieldSourceGrid ? this.fieldSourceGrid.shouldShowExpansionField()
                                    : this.canExpandRecords;
    },

    //> @attr listGrid.expansionFieldTrueImage (SCImgURL : null :IRWA)
    // If +link{listGrid.canExpandRecords} is set to <code>true</code>, this property
    // determines the image to display in the expansion field for expanded rows.
    // If unset, the +link{listGrid.booleanTrueImage} will be used.
    // @see listGrid.expansionFieldFalseImage
    // @see listGrid.expansionFieldImageWidth
    // @see listGrid.expansionFieldImageHeight
    // @group expansionField
    // @visibility external
    //<
    expansionFieldTrueImage: "[SKINIMG]/ListGrid/group_opened.gif",

    //> @attr listGrid.expansionFieldFalseImage (SCImgURL : null :IRWA)
    // If +link{listGrid.canExpandRecords} is set to <code>true</code>, this property
    // determines the image to display in the expansion field for collapsed rows.
    // If unset, the +link{listGrid.booleanFalseImage} will be used.
    // @see listGrid.expansionFieldTrueImage
    // @see listGrid.expansionFieldImageWidth
    // @see listGrid.expansionFieldImageHeight
    // @group expansionField
    // @visibility external
    //<
    expansionFieldFalseImage: "[SKINIMG]/ListGrid/group_opening.gif",

    //> @attr listGrid.expansionFieldImageShowRTL (boolean : false : IRA)
    // If this grid is in RTL mode, should an "_rtl" suffix be added to the +link{expansionFieldTrueImage,expansionFieldTrueImage}
    // and +link{expansionFieldFalseImage,expansionFieldFalseImage} image URLs? This should only
    // be enabled if RTL media for the true and false expansion field images are available.
    // @group RTL
    // @group expansionField
    // @visibility internal
    //<
    expansionFieldImageShowRTL: false,

    //> @attr listGrid.expansionFieldImageWidth (integer : null : IR)
    // If +link{listGrid.canExpandRecords} is set to <code>true</code>, this property
    // may be set to govern the width of the expansion image displayed to indicate whether a row
    // is expanded. If unset, the expansionField image will be sized to match the
    // +link{listGrid.booleanImageWidth} for this grid.
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.expansionFieldImageHeight (integer : null : IR)
    // If +link{listGrid.canExpandRecords} is set to <code>true</code>, this property
    // may be set to govern the height of the expansion image displayed to indicate whether a
    // row is expanded. If unset, the expansionField image will be sized to match the
    // +link{listGrid.booleanImageHeight} for this grid.
    // @group expansionField
    // @visibility external
    //<

    //> @method listGrid.getExpansionField()
    // Returns the specially generated expansion field used when +link{canExpandRecords} is
    // true.
    // <P>
    // Called during +link{setFields()}, this method can be overridden to add advanced dynamic
    // defaults to the expansion field (call Super, modify the default field returned by Super,
    // return the modified field).  Normal customization can be handled by just setting
    // +link{AutoChild} properties, as mentioned under the docs for +link{listGrid.expansionField}.
    //
    // @return (ListGridField)
    // @group expansionField
    // @visibility external
    //<
    // the amount to add to the icon width to get the expansion field width
    expansionFieldExtraWidth: 16,
    getExpansionField : function () {
        var grid = this,
            expField = {
                excludeFromState:true,
                // default the width to the width of the icon plus an arbitrary buffer
                width: this._getExpansionFieldImageWidth() + this.expansionFieldExtraWidth,
                getAutoFreezePosition: function () { return grid.getExpansionFieldPosition() }
            }
        ;

        // if expansionFieldImageWidth/Height are set on this grid, pass them through to the field
        expField.valueIconWidth = this._getExpansionFieldImageWidth();
        expField.valueIconHeight = this._getExpansionFieldImageHeight();

        // combine the properties for the field using the autoChild pattern
        isc.addProperties(expField, this.expansionFieldDefaults, this.expansionFieldProperties);

        expField.title = isc.nbsp;

        return expField;
    },

    getCurrentExpansionField : function () {
        var fields = this.completeFields || this.fields,
            expFields = fields.find(this.fieldIdProperty, "_expansionField");
        return !expFields ? null : isc.isAn.Array(expFields) ? expFields[0] : expFields;
    },

    _getExpansionFieldImageWidth : function () {
        return this.expansionFieldImageWidth || this.booleanImageWidth ||
                (isc.CheckboxItem ? isc.CheckboxItem.getInstanceProperty("valueIconWidth") : null);
    },
    _getExpansionFieldImageHeight : function () {
        return this.expansionFieldImageHeight || this.booleanImageHeight ||
                (isc.CheckboxItem ? isc.CheckboxItem.getInstanceProperty("valueIconHeight") : null);
    },

    //> @method listGrid.isExpansionField()
    // Identifies whether the passed-in field is the specially generated
    // +link{listGrid.expansionField,expansionField} used when +link{canExpandRecords} is
    // true.  Use this method in your custom event handlers to avoid inappropriately
    // performing actions when the expansionField is clicked on.
    //
    // @param field (ListGridField) field to test
    // @return (Boolean) whether the provided field is the expansion field
    // @group expansionField
    // @visibility external
    //<
    isExpansionField : function (field) {
        if (!field) return false;
        var fieldObj = this.getField(field);
        if (fieldObj && fieldObj._isExpansionField) return true;
        return false;
    },

    // helper function to get the expansion field position
    // This is one of the fields that appears "stuck" to the left of the grid - these are
    // - row number field
    // - group summary title field
    // - expansion field
    // - checkbox selection field
    getExpansionFieldPosition : function () {
        if (this.fieldSourceGrid != null) return this.fieldSourceGrid.getExpansionFieldPosition();

        if (!this.shouldShowExpansionField()) return -1;
        
        var pos = 0;
        if (this.shouldShowRowNumberField()) pos++;
        if (this.shouldShowCheckboxField()) pos++;
        return pos;
    },

    _canExpandRecord : function (record,rowNum) {
        if (record == null) record = this.getRecord(rowNum);
        if (record == null) return false;
        return this.canExpandRecord(record,rowNum);
    },
    //> @method listGrid.canExpandRecord()
    // Indicates whether a given record or rowNum can be expanded.  The default implementation
    // checks the value of +link{listGrid.canExpandRecords} and
    // <code>record[+link{listGrid.canExpandRecordProperty}]</code>.
    // <P>
    // Override this method for more specific control over individual record expansion.
    // <P>
    // <b>Note:</b> Rows with no underlying record in the data array - for example newly
    // added edit rows that have not yet been saved - cannot be expanded.
    //
    // @param record (ListGridRecord) record to work with
    // @param rowNum (Number) rowNum of the record to work with
    // @return (boolean) true if the record can be expanded
    // @group expansionField
    // @visibility external
    //<
    canExpandRecord : function (record, rowNum) {
        return record[this.canExpandRecordProperty] == false ? false :
            true && (this.canExpandRecords != false);
    },

    //> @method listGrid.setCanExpandRecords()
    // Setter for +link{listGrid.canExpandRecords}
    // @param canExpand (boolean) new value for listGrid.canExpandRecords.
    // @visibility external
    //<
    setCanExpandRecords : function (canExpand) {
        if (this.canExpandRecords == canExpand) return;
        if (!canExpand) {
            var data = this.data;
            if (data) {
                var expandedRows = this._getExpandedRows();
                if (expandedRows != null) {
                    for (var i = 0; i < expandedRows.length; i++) {
                        this.collapseRecord(expandedRows[i]);
                    }
                }
            }
        }
        this.canExpandRecords = canExpand;
        this.refreshFields();
    },

    //> @method listGrid.expandRecord()
    // Expands a given +link{ListGridRecord, record} by creating a subcomponent and inserting it
    // in to the record's grid-row.  A number of built-in +link{ExpansionMode, expansionModes}
    // are supported by the default implementation of
    // +link{listGrid.getExpansionComponent, getExpansionComponent()} and you can override
    // that method to provide your own expansion behavior.
    // <P>
    // Once a record has been expanded, the currently visible expansion component may be
    // retrieved via +link{getCurrentExpansionComponent()}.
    //
    // @param record (ListGridRecord) record to expand
    // @group expansionField
    // @visibility external
    //<
    _expandedRecordCount: 0,
    expandRecord : function (record, shouldRedraw) {
        if (!this.body) {
            // called before draw - add the record to an internal array, this method
            // will be called again with this record after the grid has drawn
            if (!this._recordsToExpand) this._recordsToExpand = [];
            this._recordsToExpand.add(record);
            return;
        }

        var result = false,
            component
        ;

        if (!this.isExpanded(record)) {

            // notification method / cancellation point
            
            if (this.onExpandRecord != null && !this.onExpandRecord(record)) return false;

            if (!this.canExpandMultipleRecords) {
                // can only expand one record - if one's expanded already, collapse it now
                if (this._currentExpandedRecord)
                    this.collapseRecord(this._currentExpandedRecord);
                this._currentExpandedRecord = record;
            } else if (this.maxExpandedRecords != null) {
                // limited number of expanded records allowed - if we've hit that number, show the
                // maxExpandedRecordsPrompt and return
                if (this._expandedRecordCount >= this.maxExpandedRecords) {
                    var message = this.maxExpandedRecordsPrompt.evalDynamicString(this, {
                        count: this.maxExpandedRecords
                    });
                    isc.say(message);
                    return false;
                }
            }

            // create an appropriate subcomponent and bind it
            component = this.getExpansionComponent(record);
            var isRTL = this.isRTL(),
                layout = this.createAutoChild("expansionLayout",
                {
                    layoutLeftMargin: isRTL ? 0 : this.embeddedComponentIndent,
                    layoutRightMargin: isRTL ? this.embeddedComponentIndent : 0,
                    members: [ component ]
                }
            );
            layout.isExpansionComponent = true;
            layout.removeOnHideField = true;
            this.addEmbeddedComponent(layout, record, this.data.indexOf(record));
            this._setExpanded(record, true);
            this._setExpansionComponent(record, true);
            this._expandedRecordCount++;
            if (!this.canExpandMultipleRecords) this._currentExpandedRecord = record;
            // only return true if the record was actually expanded as a result of this call 
            result = true;
        }

        if (shouldRedraw != false) {
            this.delayCall("markForRedraw", ["Expanded Record"]);
        }

        return result;
    },
    
    //> @method listGrid.expandRecords()
    // Expands the passed list of +link{ListGridRecord, records} by creating a subcomponent for
    // each record and inserting them it in to the record's grid-row.  Calls
    // +link{listGrid.expandRecord, expandRecord} for each passed record, but only marks the
    // grid for redraw once, after all expansions are complete.
    // 
    // @param records (Array of ListGridRecord) records to expand
    // @group expansionField
    // @visibility external
    //<
    expandRecords : function (records) {
        if (!records || records.length == 0) return;
        var len = records.length;
        for (var i=0; i<len; i++) {
            var isLast = (i == len - 1);
            this.expandRecord(records[i], isLast);
        }
    },

    //> @method listGrid.collapseRecord()
    // Collapses a given +link{ListGridRecord, record} which has been previously expanded using
    // +link{listGrid.expandRecord}.
    // <P>
    // Depending on the +link{listGrid.expansionComponentPoolingMode, pooling mode},
    // this method may automatically destroy expansionComponents.  By default, components
    // created automatically by the ListGrid will be auto-destroyed.  This
    // behavior can be changed by setting a different pooling mode.
    // <P>
    // Note that components created via an override to +link{listGrid.getExpansionComponent}
    // will *not* be auto-destroyed - developers should override collapseRecord to take care of
    // clean-up for such components.
    //
    // @param record (ListGridRecord) record to collapse
    // @group expansionField
    // @visibility external
    //<
    collapseRecord : function (record, shouldRedraw) {
        var component =
                (record && this._hasEmbeddedComponents(record)) ?
                        this._getEmbeddedComponents(record).find("isExpansionComponent", true) : null
        ;

        // set this flag here because collapse can be interactive (and can be cancelled)
        this._redrawOnCollapseRecord = shouldRedraw;

        if (isc.isA.Layout(component)) {
            var member = component.getMember(0);
            if (member) {
                if (!isc.isA.DynamicForm(member)) member = member.formMember;
                if (isc.isA.DynamicForm(member) && member.valuesHaveChanged()) {
                    this.saveAndCollapseRecord(member, component, record, true, true);
                    return;
                }
            }
        }

        this._collapseRecord(record, component);
    },

    //> @method listGrid.collapseRecords()
    // Collapses the passed list of expanded +link{ListGridRecord, records}.  Calls
    // +link{listGrid.collapseRecord, collapseRecord} for each passed record, but only marks
    // the grid for redraw once, after all records have been collapsed.
    // 
    // @param records (Array of ListGridRecord) records to collapse
    // @group expansionField
    // @visibility external
    //<
    collapseRecords : function (records) {
        if (!records || records.length == 0) return;
        var len = records.length;
        for (var i=0; i<len; i++) {
            var isLast = (i == len - 1);
            this.collapseRecord(records[i], isLast);
        }
    },

    saveAndCollapseRecord : function (member, component, record, shouldShowSaveDialog, shouldCollapse) {
        if (this.autoSaveEdits == true) {
            var _this = this;

            if (this.expansionEditorShowSaveDialog && shouldShowSaveDialog) {
                isc.confirm(this.expansionEditorSaveDialogPrompt,
                    function (yes) {
                        if (yes) {
                            _this.saveExpansionDetail(member, component, record, shouldCollapse);
                        } else {
                            if (shouldCollapse) _this._collapseRecord(record, component);
                        }
                    }
                );
            } else {
                this.saveExpansionDetail(member, component, record, shouldCollapse);
            }
            return;
        } else {
            var _values = member.getChangedValues(),
                rowNum = this.getRecordIndex(record),
                _this = this
            ;

            if (this.expansionEditorShowSaveDialog && shouldShowSaveDialog) {
                isc.confirm("You have unsaved changes - do you want to save them now?",
                    function (yes) {
                        if (yes) {
                            _this._saveExpansionEditorValues(rowNum, _values);
                        }
                        if (shouldCollapse) _this._collapseRecord(record, component);
                    }
                );
                return;
            } else {
                _this._saveExpansionEditorValues(rowNum, _values);
                if (shouldCollapse) this._collapseRecord(record, component);
                return;
            }
        }
    },

    
    _saveExpansionEditorValues : function (rowNum, values) {
        for (var key in values) {
            this.setEditValue(rowNum, key, values[key]);
        }
    },

    saveExpansionDetail : function (member, component, record, shouldCollapse) {
        var _this = this;
        member.saveData(
            function (dsResponse, data, dsRequest) {
                if (data) {
                    record = data;
                    if (shouldCollapse) _this._collapseRecord(record, component);
                    else member.editRecord(record);
                }
            }, { showPrompt: true, promptStyle: "cursor" }
        );
    },

    _collapseRecord : function (record, component) {
        component = component ||
            (record && this._hasEmbeddedComponents(record) ?
                    this._getEmbeddedComponents(record).find("isExpansionComponent", true) : null);

        if (this.isExpanded(record)) {
            // notification method / cancellation point
            
            if (this.onCollapseRecord != null && !this.onCollapseRecord(record)) return;

            if (this._currentExpandedRecord && this._currentExpandedRecord == record)
                delete this._currentExpandedRecord;

            this.removeEmbeddedComponent(record, component ? component : this.frozenFields ? this.frozenFields.length : 0);
            this._expandedRecordCount--;
        }
        this._setExpanded(record, false);

        if (this._redrawOnCollapseRecord != false) {
            // only markForRedraw if shouldRedraw:false wasn't passed to collapseRecord
            this.markForRedraw();
        }
    },

    

    _$expandedPrefix:"_expanded_",

    //> @method listGrid.isExpanded()
    // Whether a given +link{ListGridRecord, record} is expanded or collapsed.
    //
    // @param record (ListGridRecord) record in question
    // @group expansionField
    // @return  (Boolean)           true if the node is expanded
    // @visibility external
    //<
    isExpanded : function (record) {
        return (!record ? false : !!record[this._$expandedPrefix + this.ID]);
    },

    //> @method listGrid.getExpandedRecords()
    // Returns the list of +link{ListGridRecord, records} from this ListGrid that are
    // +link{listGrid.expandRecord(),expanded}
    //
    // @group expansionField
    // @return  (Array of ListGridRecord) All expanded records in the grid
    // @visibility external
    //<
    getExpandedRecords : function () {
        return this._getExpandedRows();
    },

    _setExpanded : function (record, value) {
        record[this._$expandedPrefix + this.ID] = value;
    },
    _getExpandedRows : function () {
        return this.data.findAll(this._$expandedPrefix + this.ID, true);
    },

    _$hasExpansionComponentPrefix:"_hasExpansionComponent_",
    _hasExpansionComponent : function (record) {
        return record[this._$hasExpansionComponentPrefix + this.ID];
    },
    _setExpansionComponent : function (record, value) {
        record[this._$hasExpansionComponentPrefix + this.ID] = value;
    },

    
    _$embeddedComponentsPrefix:"_embeddedComponents_",

    _hasEmbeddedComponents : function (record) {
        var ids = record[this._$embeddedComponentsPrefix + this.ID];
        return (ids != null && ids.length > 0);
    },
    _getEmbeddedComponents : function (record) {
        // Convert array of IDs into an array of component references
        var ids = record[this._$embeddedComponentsPrefix + this.ID],
            components = []
        ;
        if (!ids) return null;
        for (var i = 0; i < ids.length; i++) {
            components[i] = isc.Canvas.getById(ids[i]);
        }
        return components;
    },
    _setEmbeddedComponents : function (record, value) {
        record[this._$embeddedComponentsPrefix + this.ID] = value;
    },

    _addEmbeddedComponent : function (record, component) {
        if(!record[this._$embeddedComponentsPrefix + this.ID]) {
            record[this._$embeddedComponentsPrefix + this.ID] = [];
        }
        if (!record[this._$embeddedComponentsPrefix + this.ID].contains(component.getID())) {
            record[this._$embeddedComponentsPrefix + this.ID].add(component.getID());
        }
    },
    _removeEmbeddedComponent : function (record, component) {

        var ids = record[this._$embeddedComponentsPrefix + this.ID];
        if (ids == null) return;
        if (ids.length == 0) {
            record[this._$embeddedComponentsPrefix + this.ID] = null;
            return;
        }
        ids.remove(component.getID());
        if (ids.length == 0) {
            record[this._$embeddedComponentsPrefix + this.ID] = null;
        }
    },

    _deleteEmbeddedComponents : function (record, value) {
        delete record[this._$embeddedComponentsPrefix + this.ID];
    },

    
    _$recordComponentsPrefix:"_recordComponents_",
    _hasRecordComponents : function (record) {
        return (record && record[this._$recordComponentsPrefix + this.ID] != null);
    },
    _getRecordComponents : function (record) {
        if (!record) return null;

        // Convert array of IDs into an array of component references
        var ids = record[this._$recordComponentsPrefix + this.ID],
            components = {}
        ;
        if (ids) {
            for (var key in ids) {
                if (ids[key].isNullMarker) {
                    components[key] = ids[key];
                } else {
                    components[key] = isc.Canvas.getById(ids[key]);
                }
            }
        }
        return components;
    },
    _addRecordComponent : function (record, fieldName, component) {
        if(!record[this._$recordComponentsPrefix + this.ID]) {
            record[this._$recordComponentsPrefix + this.ID] = {};
        }
        if (component.isNullMarker) {
            record[this._$recordComponentsPrefix + this.ID][fieldName] = component;
        } else {
            record[this._$recordComponentsPrefix + this.ID][fieldName] = component.getID();
        }
    },
    _deleteRecordComponent : function (record, fieldName) {
        var ids = record[this._$recordComponentsPrefix + this.ID];
        if (ids == null) return;
        if (isc.isAn.emptyObject(ids)) {
            record[this._$recordComponentsPrefix + this.ID] = null;
            return;
        }
        // Not per-cell - just use the special "no field" fieldName
        if (fieldName == null) fieldName = this._$noFieldString;

        delete ids[fieldName];
        if (isc.isAn.emptyObject(ids)) {
            record[this._$recordComponentsPrefix + this.ID] = null;
        }
    },

    //> @attr listGrid.expansionDetailField (MultiAutoChild HTMLFlow : null : RA)
    // Automatically generated +link{class:HTMLFlow} for displaying the contents of
    // +link{listGrid.detailField, a specified field} in a record's expanded section when
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>detailField</code>.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionDetailFieldProperties</code> and
    // <code>listGrid.expansionDetailFieldDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionDetailFieldDefaults: {
        _constructor: isc.HTMLFlow,
        autoDraw: false,
        width: "100%",
        height: "100%"
    },
    //> @attr listGrid.expansionDetails (MultiAutoChild DetailViewer : null : RA)
    // Automatically generated +link{class:DetailViewer} for displaying the details of a record
    // in its expanded section when
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>details</code>.  Note that
    // only those fields
    // which do not already appear in the grid are displayed in the expanded section.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionDetailsProperties</code> and
    // <code>listGrid.expansionDetailsDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionDetailsDefaults: {
        _constructor: isc.DetailViewer,
        autoDraw: false,
        width: "100%"
    },
    //> @attr listGrid.expansionRelated (MultiAutoChild ListGrid : null : RA)
    // Automatically generated +link{class:ListGrid} for displaying data related to a record
    // in its expanded section when
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>related</code>.
    // The +link{class:DataSource} containing the related data is provided by
    // +link{listGrid.getRelatedDataSource, getRelatedDataSource()} which, by default,
    // returns the DataSource referred to in +link{listGridRecord.detailDS}.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionRelatedProperties</code> and
    // <code>listGrid.expansionRelatedDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionRelatedDefaults: {
        _constructor: isc.ListGrid,
        autoDraw: false,
        width: "100%",
        autoFitData: "vertical",
        autoFitMaxRecords: 4
    },

    //> @attr listGrid.expansionEditor (MultiAutoChild DynamicForm : null : RA)
    // Automatically generated +link{class:DynamicForm} for editing the details of a record
    // in its expanded section when
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>editor</code>.  Note that only
    // those fields which do not already appear in the grid will appear in the expanded section.
    // <P>
    // According to the value of +link{showExpansionEditorSaveButton}, a save button is shown
    // beneath the editor.  You can save the values in the editor by clicking this button
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionEditorProperties</code> and
    // <code>listGrid.expansionEditorDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionEditorDefaults: {
        _constructor: "DynamicForm",
        autoDraw: false,
        numCols: 4,
        colWidths: ["*", "*", "*", "*"],
        width: "100%",
        saveOperationType: "update"
    },

    //> @attr listGrid.expansionEditorShowSaveDialog (boolean : null : IR)
    // When +link{listGrid.canExpandRecords, canExpandRecords} is true and
    // +link{listGrid.expansionMode, expansionMode} is <i>editor</i>, whether a dialog should be
    // displayed when an expanded row is collapsed while it's nested editor has changed values.
    //
    // @group expansionField
    // @visibility external
    //<
    //expansionEditorShowSaveDialog: null,

    //> @attr listGrid.expansionEditorSaveDialogPrompt (string : "You have unsaved changes - do you want to save them now?" : IR)
    // When +link{listGrid.canExpandRecords, canExpandRecords} is true and
    // +link{listGrid.expansionMode, expansionMode} is <i>editor</i>, the prompt to display
    // in a dialog when an expanded row is collapsed while it's nested editor has changed values.
    //
    // @group expansionField,i18nMessages
    // @visibility external
    //<
    expansionEditorSaveDialogPrompt: "You have unsaved changes - do you want to save them now?",

    //> @attr listGrid.expansionEditorCollapseOnSave (Boolean : true : RW)
    // When +link{expansionMode} is <i>editor</i>, should the row be collapsed following a
    // save initiated by the expansion-component's +link{expansionEditorSaveButton, save button}.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionEditorCollapseOnSave: true,

    //> @attr listGrid.showExpansionEditorSaveButton (Boolean : true : RW)
    // When +link{expansionMode} is <i>editor</i>, should a Save button be shown below the
    // the expanded editor?
    // <P>
    // Note that if an expanded-row containing an editor is collapsed while changes are
    // outstanding, changes will be either be automatically updated to the grid, or will first
    // show a confirmation dialog, according to the value of
    // +link{expansionEditorShowSaveDialog}.
    //
    // @group expansionField
    // @visibility external
    //<
    showExpansionEditorSaveButton: true,

    //> @attr listGrid.expansionEditorSaveButton (MultiAutoChild IButton : null : RA)
    // Automatically generated +link{class:IButton} for saving the values in the expanded
    // portion of a ListGrid row.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionEditorSaveButtonProperties</code> and
    // <code>listGrid.expansionEditorSaveButtonDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionEditorSaveButtonDefaults: {
        _constructor: "IButton",
        autoFit: true,
        layoutAlign: "center",
        click : function () {
            if (!this.grid || !this.form) return;
            var grid = this.grid,
                component =
                (this.record && grid._hasEmbeddedComponents(this.record)) ?
                    grid._getEmbeddedComponents(this.record).find("isExpansionComponent", true) :
                    null
            ;

            this.grid.saveAndCollapseRecord(this.form, component, this.record, false,
                this.grid.expansionEditorCollapseOnSave
            );
        }
    },

    //> @attr listGrid.expansionEditorSaveButtonTitle (String : "Save" : RWA)
    // The title for the +link{expansionEditorSaveButton}.
    //
    // @group expansionField,i18nMessages
    // @visibility external
    //<
    expansionEditorSaveButtonTitle: "Save",

    //> @attr listGrid.expansionDetailRelated (MultiAutoChild HLayout : null : RA)
    // Automatically generated +link{class:HLayout} appearing in a record's expanded section
    // when +link{type:ExpansionMode, listGrid.expansionMode} is <code>detailRelated</code>.
    // This component contains two other autoChild components,
    // a +link{class:DetailViewer} for viewing fields from the record which are not already
    // present in the grid and a separate embedded +link{class:ListGrid} for displaying other
    // data related to this record via record.detailDS.  See +link{listGrid.expansionDetails}
    // and +link{listGrid.expansionRelated} for more information.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionDetailRelatedProperties</code> and
    // <code>listGrid.expansionDetailRelatedDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionDetailRelatedDefaults: {
        _constructor: isc.HLayout,
        autoDraw: false,
        width: "100%",
        height: "100%"
    },

    //> @attr listGrid.expansionLayout (MultiAutoChild VLayout : null : RA)
    // Automatically generated +link{class:VLayout} which fills a record's expanded section
    // and contains other builtin +link{ExpansionMode, expansion-components}.  You can also
    // override +link{listGrid.getExpansionComponent, getExpansionComponent()} to provide
    // components of your own specification.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionLayoutProperties</code> and
    // <code>listGrid.expansionLayoutDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionLayoutDefaults: {
        _constructor: isc.VLayout,
        autoDraw: false,
        width: "100%",
        height: 10,
        overflow: "visible"
    },

    //> @method listGrid.getCurrentExpansionComponent()
    // Returns the expansion component derived from +link{listGrid.getExpansionComponent()}
    // currently visible in some record, or null if the specified record is not showing
    // an expansion component.
    //
    // @param record (Integer | ListGridRecord) rowNum or record to get the expansionComponent for
    // @return (Canvas) the currently visible expansion component for the expanded row.
    // @group expansionField
    // @visibility external
    //<
    getCurrentExpansionComponent : function (record) {
        if (isc.isA.Number(record)) record = this.getRecord(record);

        if (!this._hasExpansionComponent(record)) return null;

        // we actually hang 'isExpansionComponent' onto the layout containing the generated
        // expansion component so return its (only) member.
        var component = this._hasEmbeddedComponents(record) ?
                    this._getEmbeddedComponents(record).find("isExpansionComponent", true) : null;
        if (component) {
            return component.members[0];
        }
        return null;
    },

    //> @method listGrid.getExpansionComponent()
    // Gets the embedded-component to show as a given record's expansionComponent.  This
    // component is then housed in +link{listGrid.expansionLayout, a VLayout} and embedded
    // into a record's row.
    // <P>
    // By default, this method returns one of a set of built-in components, according to the
    // value of +link{type:ExpansionMode, listGrid.expansionMode}.  You can override this method
    // to return any component you wish to provide as an expansionComponent.
    // <P>
    // As long as the record is expanded, this component may be retrieved via a call to
    // +link{getCurrentExpansionComponent()}.
    // <P>
    // When an expanded record is collapsed, the component is disassociated from the record and
    // may or may not be automatically destroyed.  By default, built-in components
    // will be destroyed on unembed.  Custom expansion components, created via an override of
    // getExpansionComponents(), may not be auto-destroyed, according to the
    // +link{ExpansionComponentPoolingMode, pooling mode} being used.
    //
    // @param record (ListGridRecord) record to get the expansionComponent for
    // @return (Canvas | Canvas Properties) the component to embed
    // @group expansionField
    // @visibility external
    //<
    getExpansionComponent : function (record) {
        return this._getStockEmbeddedComponent(record, true, false, this.getRecordIndex(record), 0);
    },

    //> @attr listGridRecord.backgroundComponent (Canvas : null : IR)
    // Has no effect unless +link{listGrid.showBackgroundComponents} is <code>true</code>.
    // <P>
    // Canvas created and embedded in the body behind a given record.   When set, either as
    // a Canvas or Canvas Properties, will be constructed if necessary, combined with the
    // autoChild properties specified for +link{listGrid.backgroundComponent} and displayed
    // behind this record in the page's z-order, meaning
    // it will only be visible if the cell styling is transparent.
    // @group rowEffects
    // @visibility external
    //<

// Expando Rows - Record implementation

    //> @attr listGrid.detailDS (String : null : IRWA)
    // If +link{canExpandRecords} is true and +link{type:ExpansionMode,listGrid.expansionMode}
    // is <code>"related"</code>, this property specifies the dataSource for the
    // related records grid to be shown embedded in expanded records.
    // <P>
    // This property may also be specified on a per-record basis - see
    // +link{recordDetailDSProperty}
    // @visibility external
    //<

    //> @attr listGrid.recordDetailDSProperty (String : "detailDS" : IRWA)
    // The name of the ListGridRecord property that specifies the DataSource to use when
    // +link{type:ExpansionMode, listGrid.expansionMode} is "related".  The default is
    // +link{ListGridRecord.detailDS}. Note that you can set the +link{detailDS} at the
    // grid level instead if the same dataSource is to be used for all records.
    //
    // @visibility external
    //<
    recordDetailDSProperty: "detailDS",

    //> @attr listGridRecord.detailDS (DataSource : null : IRWA)
    // The default value of +link{listGrid.recordDetailDSProperty}.
    //
    // @visibility external
    //<

    //> @method listGrid.getRelatedDataSource()
    // Returns the +link{class:DataSource} containing data related to the passed record.  Used
    // when +link{ListGrid.canExpandRecords} is true and +link{ExpansionMode} is "related". The
    // default implementation returns the DataSource specified in
    // +link{listGridRecord.detailDS} if set, otherwise +link{listGrid.detailDS}.
    //
    // @param   record  (ListGridRecord)    The record to get the Related dataSource for.
    // @return (DataSource) The related DataSource for the "record" param
    //
    // @visibility external
    //<
    getRelatedDataSource : function (record) {
        return isc.DS.getDataSource(record[this.recordDetailDSProperty]) ||
                    isc.DS.get(this.detailDS);
    }

    //> @attr listGrid.childExpansionMode (ExpansionMode : null : IRWA)
    // For +link{ExpansionMode, expansionModes} that show another grid or tree, what the
    // child's expansionMode should be.
    // <P>Default value <code>null</code> means no further expansion.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.expansionCanEdit (Boolean : null : IRWA)
    // For +link{ExpansionMode, expansionModes} that show another grid or tree, is that
    // component editable?
    // <P>The default value for this property is <code>false</code>.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.filterLocalData (boolean : null : IRA)
    // Causes filtering to be performed against the local data set, even when a
    // +link{listGrid.dataSource} is provided.
    // <p>
    // When using this mode, data must be provided to the grid via +link{listGrid.setData()},
    // and must be provided as 
    // <smartclient>a simple Array of Records</smartclient>
    // <smartgwt>a RecordList</smartgwt>.  
    // <p>
    // Note that a +link{listGrid.dataSource} must be provided for filtering to occur
    // even when filtering locally.
    // <P>
    // If this property is set to true, the supplied data is applied as the 
    // +link{resultSet.allRows, complete dataset} of a +link{class:ResultSet}, which is then 
    // filtered according to the specified criteria, and the results displayed. If false, a 
    // normal databound fetch will occur, retrieving records that match the specified criteria 
    // from this component's +link{listGrid.dataSource}.
    // <p>
    // <code>filterLocalData</code> includes both calls to +link{listGrid.fetchData()} and
    // +link{listGrid.filterData()} as well as automatic filtering when the
    // +link{listGrid.filterEditor} is enabled.
    // <p>
    // If this property is not explicitly set, default behavior will filter against the
    // dataSource unless the grid has a specified +link{DataPath, dataPath}, in which case
    // filtering will occur locally.
    // <p>
    // See also +link{listGrid.saveLocally} to cause saves to ignore the DataSource and affect
    // the local data set only.
    //
    // @visibility external
    //<

    //> @attr listGrid.recordDropAppearance (RecordDropAppearance : isc.ListGrid.BETWEEN : [IRW])
    // If +link{canAcceptDroppedRecords} is true for this listGrid, this property governs
    // whether the user can drop between, or over records within the grid.
    // This controls what +link{type:RecordDropPosition} is passed to the +link{recordDrop()}
    // event handler.
    //
    // @visibility external
    //<
    , recordDropAppearance: isc.ListGrid.BETWEEN
});



isc.ListGrid.addMethods({

// warnOnReusedFields -- will log a warning at init time if this.fields is set to an array of
// field objects which are already displayed as fields in another grid.
// Internal - we only disable this for a couple of special cases where we really do want to share
// field objects across grids, like the record editor
warnOnReusedFields:true,


init : function () {
    if (this.disableTouchScrollingForDrag &&
        (this.canDragRecordsOut || this.canDragSelect || this.canReorderRecords) &&
        this.useTouchScrolling == null)
    {
        this.logInfo("Automatically disabling touch scrolling", "scrolling");
        this.useTouchScrolling = false;
    }
    this.Super("init", arguments);
},

//> @method ListGrid.initWidget() (A)
// Initialize the canvas and call listGrid.setData().
// @param [all arguments] (object) objects with properties to override from default
//<
initWidget : function () {
    // set a flag that prevents sortChanged() from firing during initialization
    this._initializing = true;

    
    this.Super("initWidget", arguments);

    // Disable `resizeFieldsInRealTime' in mobile browsers.
    if (isc.Browser.isMobile) this.resizeFieldsInRealTime = false;

    // call the setter on 'showRecordComponents()' - this disables the
    // drawAllMaxCells logic for the grid.
    if (this.showRecordComponents) {
        delete this.showRecordComponents;
        this.setShowRecordComponents(true);
    }

    // we want to avoid a fields array object getting re-used across multiple ListGrids.
    // This can happen if the developer does something like assigning a fields object to the
    // instance prototype.
    // To handle this we have another attribute 'defaultFields' which may be set on the instance
    // prototype and differs only from initializing with a fields block in that array will be
    // shallow cloned and assigned to this.fields rather than sharing the same object across
    // ListGrid instances
    
    if (this.fields == null && this.defaultFields != null) {
        this.fields = isc.shallowClone(this.defaultFields);
        //this.logWarn("fields picked up from this.defaultFields -- now set to:" + this.fields);
    } else if (this.warnOnReusedFields && this.fields != null) {
        if (this.fields._initializedFieldsArray) {
            this.logWarn("ListGrid initialized with this.fields attribute set to an array " +
                "which is already being displayed in another ListGrid instance. To reuse " +
                "standard field configuration across multiple ListGrids, use " +
                "listGrid.defaultFields rather than assigning directly to listGrid.fields.");

        // Also catch the case where the developer re-uses individual fields within separate
        // arrays across grids
        } else {

            var dupedFields;
            if (isc.isAn.Array(this.fields)) {
                dupedFields = this.fields.findIndex("_initializedFieldObject", true) != -1;
            } else if (isc.isAn.Object(this.fields)) {
                for (var fieldName in this.fields) {
                    var field = this.fields[fieldName];
                    if (field && field._initializedFieldObject) {
                        dupedFields = true;
                        break;
                    }
                }
            }
            if (dupedFields) {
                 this.logWarn("ListGrid initialized with this.fields attribute set to an array " +
                "containing fields which are already being displayed in another ListGrid " +
                "instance. To reuse standard field configuration across multiple ListGrids, use " +
                "listGrid.defaultFields rather than assigning directly to listGrid.fields.");
            }
        }

        // Set a flag on the array and the individual field objects - this allows us catch the case
        // where a developer reuses a standard fields array across multiple grids rather than using
        // the defaultFields attribute
        // 
        // Also use this opportunity to check for null slots in the fields array
        
        this.fields._initializedFieldsArray = true;
        if (isc.isAn.Array(this.fields)) {
            var offset = 0;
            for (var i = 0; i < this.fields.length; i++) {
                if (this.fields[i] == null) {
                    offset++;
                    this.logWarn("ListGrid initialization: Specified fields array includes null entry. Removing.");
                    continue;
                }
                if (offset > 0) {
                    this.fields[i-offset] = this.fields[i];
                }
                this.fields[i]._initializedFieldObject = true;
            }
            if (offset > 0) this.fields.length = this.fields.length - offset;
            
        } else if (isc.isAn.Object(this.fields)) {
            for (var fieldName in this.fields) {
                var field = this.fields[fieldName];
                if (field) {
                    field._initializedFieldObject = true;
                }
            }
        }
    }

    if (this.canEditNew) this.listEndEditAction = this.rowEndEditAction = "next";

    if (this.alwaysShowEditors) {
        this.editByCell = false;

        // disable selection
        
        this.selectionType = "none";
        this.selectOnEdit = false;

        if (this.canGroup != false) {
            this.logInfo("grouping functionality is not supported when alwaysShowEditors is true." +
                    " Explicitly disabling this.canGroup", "inactiveEditorHTML");
            this.canGroup = false;
        }
        if (this.modalEditing) {
            this.logInfo("modalEditing is not supported when alwaysShowEditors is true." +
                " Explicitly setting this.modalEditing to false", "inactiveEditorHTML");
            this.modalEditing = false;
        }

        // enforce editEvent:"click" - this means that if the user clicks on a cell which
        // isn't showing an inactive editor (for example where showEditorPlaceholder is true),
        // we still start editing that row/cell
        this.editEvent = "click";

        // If canEdit is unset, and we have no fields explicitly marked as canEdit:true,
        // flip the default to true.
        // This gives us the most intuitive behavior - if the developer specifies per-field
        // editability we'll respect it, otherwise we'll default to canEdit true
        if (!this.isEditable()) {
            this.logInfo("alwaysShowEditors has been set for this grid but canEdit is unset and " +
              "no fields are explicitly marked as editable. Defaulting this.canEdit to true. " +
              "Note that to avoid this override developers can explicitly specify canEdit " +
              "at the grid or field level", "inactiveEditorHTML");
            this.canEdit = true;
        }

    }

    // if we have variable record heights and virtualScrolling is unset, switch it on
    
    if (this.canExpandRecords ||
        (this.fixedRecordHeights == false && this.virtualScrolling == null))
    {
        // the _specifiedFixedRecordHeights flag is used by shouldShowAllColumns - we know
        // that even though a row may exceed its cell height this isn't due to any cell's content
        // in the row, so we don't need to render out every column to get correctly sized rows.
        if (this.fixedRecordHeights) this._specifiedFixedRecordHeights = this.fixedRecordHeights;
        this.fixedRecordHeights = false;
        this.virtualScrolling = true;
    }

    // disable canAddFormulaField if the required component isn't present
    if (this.canAddFormulaFields && isc.FormulaBuilder == null) {
        this.logInfo("Required modules for adding formula fields not present - setting " +
                    "canAddFormulaFields to false.");
        this.canAddFormulaFields = false;
    }
    if (this.canAddSummaryFields && isc.SummaryBuilder == null) {
        this.logInfo("Required modules for adding summary fields not present - setting " +
                    "canAddSummaryFields to false.");
        this.canAddSummaryFields = false;
    }

    // default to canSelectCells mode if we're using rowSpan-sensitive styling
    if (this.useRowSpanStyling && this.canSelectCells == null) this.canSelectCells = true;

    // default cell-level roll overs to the value of canSelectCells
    if (this.useCellRollOvers == null) this.useCellRollOvers = this.canSelectCells;

    // force loading rows to contain at least &nbsp; otherwise row height may be reported as less
    // than the actual height.
    if (this.loadingMessage == null || this.loadingMessage == isc.emptyString)
        this.loadingMessage = "&nbsp;";

    // default our overflow to "visible" if autoFitData is set
    if (this.autoFitData != null) {
        this._specifiedOverflow = this.overflow;
        this.setOverflow("visible");
    }

    // default our groupStartOpen to "all" if canCollapseGroup is false
    if (this.canCollapseGroup == false) this.groupStartOpen = "all";

    // force sortDirection to a SortDirection (it could have been a boolean in the past)
    this.sortDirection = Array.shouldSortAscending(this.sortDirection) ? "ascending" : "descending";
    // store off the initial sortDirection - we'll revert to this when unsorting
    this._baseSortDirection = Array.shouldSortAscending(this.sortDirection) ? "ascending" : "descending";

    // Hilite state takes precedence over hilites because it is likely applied
    // from a user-saved location whereas hilites is the default.
    if (this.hiliteState) this.setHiliteState(this.hiliteState);

    // initialize the data object, setting it to an empty array if it hasn't been defined
    
    this.setData(this.data ? null : this.getDefaultData());

    // set up selectionType dynamic default
    this.setSelectionAppearance(this.selectionAppearance, true);

    this._setUpDragProperties();

    if(!this.canResizeFields) this.canAutoFitFields=false;
    
    // For back-compat, if headerButtonProperties.wrap is set, and wrapHeaderTitles is
    // null, respect headerButtonProperties.wrap.
    if (this.wrapHeaderTitles == null) {
        var wrap = this.headerButtonProperties != null ? this.headerButtonProperties.wrap : null;
        if (wrap == null) {
            wrap = this.headerButtonDefaults != null ? this.headerButtonDefaults.wrap : null;
        }
        if (wrap == null) wrap = false;
        this.wrapHeaderTitles = wrap;
    }

    // Remember the initial groupState.
    // This allows us to avoid unnecessary calls to groupStateChanged when
    // regroup runs, but the groupBy fields are unaltered
    this.currentGroupState = this.getGroupState();

    
    // clear out the flag that prevents sortChanged() from firing during initialization
    delete this._initializing;
},

_storeDragProperties : function () {
    if (!this._initialDragProperties) {
        var iDP = this._initialDragProperties = {};
        iDP.canDrag = this.canDrag;
        iDP.canDrop = this.canDrop;
        iDP.canAcceptDrop = this.canAcceptDrop;
    }
},
_restoreDragProperties : function () {
    var iDP = this._initialDragProperties;
    if (iDP) {
        this.canDrag = iDP.canDrag;
        this.canDrop = iDP.canDrop;
        this.canAcceptDrop = iDP.canAcceptDrop;
    }
},
_setUpDragProperties : function () {
    if (!this._initialDragProperties) {
        // store the original dragProperties
        this._storeDragProperties();
    }
    // set up our specific drag-and-drop properties

    this.canDrag = !this.canDragSelectText &&
                    (this.canDrag || this.canDragRecordsOut || this.canReorderRecords ||
                    this.canDragSelect);
    this.canDrop = (this.canDrop || this.canDragRecordsOut || this.canReorderRecords);
    this.canAcceptDrop = (this.canAcceptDrop || this.canAcceptDroppedRecords ||
                    this.canReorderRecords);

},

//> @method listGrid.setCanReorderRecords()
// Setter for the +link{listGrid.canReorderRecords} attribute.
// @param canReorderRecords (boolean) new value for <code>this.canReorderRecords</code>
// @visibility external
//<
setCanReorderRecords : function (canReorderRecords) {
    if (canReorderRecords != this.canReorderRecords) {
        this.canReorderRecords = canReorderRecords;
        this._restoreDragProperties();
        this._setUpDragProperties();
        this.redraw();
    }
},

getEmptyMessage : function () {
    if (isc.ResultSet && isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown()) {
        if (isc.Offline && isc.Offline.isOffline()) {
            return this.offlineMessage;
        }
        return this.loadingDataMessage == null ? "&nbsp;" :
            this.loadingDataMessage.evalDynamicString(this, {
                loadingImage: this.imgHTML(isc.Canvas.loadingImageSrc,
                                           isc.Canvas.loadingImageSize,
                                           isc.Canvas.loadingImageSize)
            });
    }
    if (this.isOffline()) {
        return this.offlineMessage;
    }
    return this.emptyMessage == null ? "&nbsp;" : this.emptyMessage.evalDynamicString(this, {
        loadingImage: this.imgHTML(isc.Canvas.loadingImageSrc,
                                   isc.Canvas.loadingImageSize,
                                   isc.Canvas.loadingImageSize)
    });
},

isEmpty : function () {
    if (!this.data) return true;

    // treat having no fields as being empty so we don't attempt to write out and manipulate
    // an empty table
    if (!this.fields || this.fields.length == 0) return true;

    
    if (isc.ResultSet && isc.isA.ResultSet(this.data)) {

        if (this.data.isPaged()) {
            if (!this.data.isEmpty()) return false;

            
            var editRows = this.getAllEditRows();
            if (editRows && editRows.length > 0) {
                for (var i = 0; i < editRows.length; i++) {
                    if (editRows[i] >= 0) return false;
                }
            }
            return true;
        } else {
            // If our length is not known we must be in the process of loading, so return the
            // loading message.
            return (!this.data.lengthIsKnown() || this.getTotalRows() == 0);
        }
    } else {
        return (this.getTotalRows() == 0);
    }
},

//> @attr listGrid.preserveEditsOnSetData (boolean : null : IRWA)
// By default any edit values in an editable ListGrid are dropped when 'setData()' is called,
// as previous edits are almost certainly obsoleted by the new data-set.
// This flag allows the developer to suppress this default behavior.
// @visibility internal
// @group data
//<
// Leave this internal for now - no known use cases for it, but seems like something that
// could come up.
//preserveEditsOnSetData : null,

//> @method listGrid.setData()
// Provides a new data set to the ListGrid after the grid has been created or drawn.
// The ListGrid will redraw to show the new data automatically.
// @param newData (List of ListGridRecord) data to show in the list
// @group data
// @visibility external
//<
setData : function (newData, clearGroupBy) {
    // if the current data and the newData are the same, bail
    //  (this also handles the case that both are null)
    if (this.data == newData) return;

    this.dataSetChanged();

    if (!this.preserveEditsOnSetData) this.discardAllEdits();

    // drop "lastHiliteRow" -no sense in hanging onto it
    this.clearLastHilite();

    // if we are currently pointing to data, stop observing it
    if (this.data) {
        this._ignoreData(this.data);
        // if the data was autoCreated, destroy it to clean up RS<->DS links
        if (this.data._autoCreated && isc.isA.Function(this.data.destroy))
            this.data.destroy();
    }

    // if newData was passed in, remember it
    if (newData) this.data = newData;

    // if data is not set, bail
    if (!this.data) return;

    // create a new selection if we don't have one or if we receive new data
    
    if (!this._isGrouped && !this.isGrouped && 
        (!this.selection || (this.data != this.selection.data))) 
    {
        this.createSelectionModel();
    }

    // observe the data so we will update automatically when it changes
    this._observeData(this.data);

    var sortFromData, sortSpecifiers;
    // if data is a resultSet, and it already has both data and sortSpecifiers, apply the
    // sortSpecifiers from the ResultSet to this grid, replacing those already on the grid
    if (isc.isA.ResultSet(this.data) && !(clearGroupBy && this.sortByGroupFirst) && 
        (sortFromData = this.data.getSort()) && this.data.lengthIsKnown())
    {
        sortSpecifiers = sortFromData;
    } else {
        sortSpecifiers = this.getSort();
    }
    if (sortSpecifiers) {
        if (this.fields) this.setSort(sortSpecifiers);
        else {
            // if there are no fields, run setSort() later from setFields() 
            this.initialSort = sortSpecifiers;
            this._pendingSort = true;
        }
    }

    // Call this._remapEditRows() if we're hanging onto edit values
    // as we know they're now out of date.
    
    if (this.preserveEditsOnSetData) this._remapEditRows();

    // if we can regroup, do so.
    
    this.regroup(true);

    // Don't redraw / refresh grid summary - this happens explicitly later.
    this.calculateRecordSummaries(null, null, null, true, true);

    // if this.alwaysShowEditors is set, and we have data, and we're not currently showing
    // editors, show them now.
    
    var fetching = isc.ResultSet && isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown();
    if (!fetching && this._alwaysShowEditors() && !this._editorShowing) {
        this.startEditing(null,null,true,null,true);
    }

    if (this.hilites) this.applyHilites();

    
    if (isc.ResultSet && isc.isA.ResultSet(this.data) &&
        !(this.data.allRows && this.data.neverDropCache) &&
        this.body && this.body.overflow == "visible")
    {
        this.body.showAllRows = false;
    }

    // clear out the current expanded row count, along with the current expanded record,
    // if there is one, since the expansionComponents have been dropped, along with the
    // records they were in
    this._expandedRecordCount=0;
    if (!this.canExpandMultipleRecords && this._currentExpandedRecord)
        delete this._currentExpandedRecord;

    if (this._lastStoredSelectedState) {
        this.setSelectedState(this._lastStoredSelectedState);
        delete this._lastStoredSelectedState;
    }

    // if any fields are marked as autoFitWidth, recalculate their sizes
    
    if (this.isEmpty() && ((isc.ResultSet && isc.isA.ResultSet(this.data)) || 
                    (isc.ResultTree && isc.isA.ResultTree(this.data))) )
    {
        this._updateFieldWidthsOnDataArrived = true;
    } else {
        this.updateFieldWidthsForAutoFitValue("setData called.");
    }

    // mark us as dirty so we'll be redrawn if necessary
    this._markBodyForRedraw("setData");

    this.updateBodyCanFocusForData();
},


// Determine which field to expand when autoFitFieldWidths is true and the
// fields don't take up the full set of space available.
// If +link{listGrid.autoFitExpandField} is explicitly set use it.
// Otherwise, basically we want to find the first field that will not look odd to expand
// Implementation:
// - if a field is not of type text, ignore (don't want to expand images, dates, booleans, numbers)
// - If field has showValueIconsOnly set, ignore (even though it has text content it shouldn't
//   expand beyond the value icons width)
// - field.length:
//      - if all fields have field.length specified, expand the largest one
//      - if no fields have this property set, just expand the first text field
//      - if *some* fields have field.length set - the length may indicate a small field
//        (say 2 characters) which we don't want to expand.
//        Expand fields with no specified length in preference to those with
//        a small specified length.
autoFitExpandLengthThreshold : 10,
getAutoFitExpandField : function () {
    if (!this.autoFitFieldsFillViewport) return null;

    if (this.autoFitExpandField != null) {
        var field = this.getField(this.autoFitExpandField);
        // We don't support auto-expanding a frozen field at this time
        
        if (field != null && this.fields && this.fields.contains(field) &&
            (!this.frozenFields || !this.frozenFields.contains(field)))
        {
            return field;
        }
    }
    var fields = [], lengthFields = [];

    if (this.fields) {
        for (var i = 0; i < this.fields.length; i++) {
            var field = this.fields[i];
            if (!field.showValueIconOnly &&
               (field.type == null ||
                (isc.SimpleType.inheritsFrom(field.type, "text") && 
                 !isc.SimpleType.inheritsFrom(field.type, "image"))
               ))
            {
                if (!this._suppressedFrozenFields && field.frozen) continue;
                fields.add(field);
                
                if (field != null && field.length != null && field.maxWidth == null) {
                   lengthFields.add(field);
                }

            }
        }
    }

    if (lengthFields.length > 0) {
        lengthFields.sortByProperty("length", Array.DESCENDING);
        if (lengthFields.last().length >= this.autoFitExpandLengthThreshold ||
            lengthFields.length == fields.length)
        {
            return lengthFields[0];
        }
    }
    if (fields.length > 0) {
        
        if (fields.filter(function (field) {return field.maxWidth != null;}).length > 0) {
            fields.sortByProperty("minWidth", Array.DESCENDING, function (field) {
                return field.maxWidth || Infinity;
            });
        }
        var i = 0;
            field = fields[i]
        // Note: This conditional contains cases where we should *not* auto expand the field
        while (field != null &&
                // Respect explicitly specified pixel width
                ((field.width != null && field.width != "*") ||
                // Explicit length less than the min "expand" number of characters
                 (field.length != null &&
                    field.length < this.autoFitExpandLengthThreshold))
              )
        {
            i++;
            field = fields[i];
        }
        return field;
    }

    // Note that this could still return null - no text fields etc.
    return null;
},

// updateFieldWidthsForAutoFitValue()
// If this.autoFitWidthApproach means we size to
// column data and any fields are marked as autoFitWidth:true,
// this method will set the _fieldWidthsDirty flag on the gridRenderer, causing
// _updateFieldWidths() to be called on the next body redraw,
// Calling code should call this before causing a body redraw.
updateFieldWidthsForAutoFitValue : function (reason) {
    if (!this.body || this.body._fieldWidthsDirty) return;

    var fields = this.fields || [];
    for (var i = 0; i < fields.length; i++) {
        var shouldAutoFit = this.shouldAutoFitField(fields[i]);
        if (!shouldAutoFit) continue;
        var approach = this.getAutoFitWidthApproach(fields[i]);

        if (approach == "value" || approach == "both") {
            this.fields._appliedInitialAutoFitWidth = false;
            this.body._fieldWidthsDirty = "Updating field widths for field auto-fit" +
                                      (reason ? (":" + reason) : ".");
            break;
        }
    }
},

invalidateCache : function () {
    this.dataSetChanged();

    // make sure that header checkbox is unchecked after refreshing cache
    if (this.getCheckboxFieldPosition() != -1) {
        this.deselectAllRecords();
        this._setCheckboxHeaderState(false);
    }

    // if we have a stored drawArea, delete it now so that the
    // redraw recalculates it and reapplies recordComponents
    if (this.body && this.body._oldDrawArea) delete this.body._oldDrawArea;

    return this.Super("invalidateCache", arguments);
},

dataSetChanged : function () {
    
    delete this._virtualScrollingLocked;
},

// use this rather than field.canSort to handle canSortClientOnly fields
_canSort : function (field) {
    if (!isc.isAn.Object(field)) {
        field = this.getSpecifiedField(field);
    }
    if (field == null) return false;

    var canSort = (field.canSort == false) ? false : this.canSort == false ? false : true;
    canSort = canSort && this._canSortData(field);

    return canSort;
},

_canSortData : function (fieldName) {
    
    var field = isc.isAn.Object(fieldName) ? fieldName : this.getSpecifiedField(fieldName);
    if (field == null) return false;

    if (isc.isAn.Array(this.data)) return true;
    if (field.canSortClientOnly == true) {
        if (isc.isA.ResultSet(this.data)) {
            if (!this.data.lengthIsKnown() || !this.data.canSortOnClient()) {
                return false;
            }
        }
    }

    return true;
},

// helper to determine whether this grid can be sorted on multiple fields - returns false if
// either canMultiSort or canSort are false, or if the data itself doesn't support multiSort
_canMultiSort : function () {
    var canMultiSort = (this.canMultiSort != false) && this.canSort && this._canMultiSortData();
    return canMultiSort;
},

// helper to determine whether this grid's data supports sorting on multiple fields
_canMultiSortData : function () {
    var canMultiSort = this.canMultiSort;

    // if data doesn't support setSort (resultSet and Array do), disable multiSort
    if (!this.data.setSort) {
        canMultiSort = false;
    } else if (this.getDataSource() && canMultiSort != false) {
        canMultiSort = this.getDataSource().canMultiSort && this.canSort;
    }

    return canMultiSort;
},

// helper method to get an appropriate sortDirection for a field
_getFieldSortDirection : function (field) {
    var field = isc.isAn.Object(field) ? field : this.getSpecifiedField(field),
        direction;

    var fieldDir = field ? field.sortDirection : null;
    if (fieldDir != null) {
        direction = Array.shouldSortAscending(fieldDir) ? "ascending" : "descending";
    } else if (this.sortDirection != null) {
        direction = Array.shouldSortAscending(this.sortDirection) ? "ascending" : "descending";
    } else {
        direction = Array.shouldSortAscending(this._baseSortDirection) ? "ascending" : "descending";
    }

    return direction;
},

// Override createSelectionModel, from DataBoundComponent, to set the body's selection object
// with our selection object. Our body GridRenderer will then observe selection.setSelected.
createSelectionModel : function () {
    this.invokeSuper(isc.ListGrid, "createSelectionModel", arguments);
    if (isc.isA.Canvas(this.body)) {
        this.body.setSelection(this.selection);
        if (this.frozenBody) {
            this.frozenBody.setSelection(this.selection);
            // create separate selection objects for body/frozenBody
            this._separateDependentSelections();
        }
    }
},

destroySelectionModel : function () {
    if (this.body) this.body.clearSelection();
    if (this.frozenBody) this.frozenBody.clearSelection();
    return this.Super("destroySelectionModel", arguments);
},

// Method tripped to reselect a selected record that was updated in the DataSource
performReselectOnUpdate : function (updatedRecord) {
   if (this.reselectOnUpdateNotifications == "none") {
        this.suppressSelectionChanged = true;
    }
    this.selection.select(updatedRecord);
    if (this.reselectOnUpdateNotifications == "selectionUpdated") {
        this.fireSelectionUpdated();
    }
    delete this.suppressSelectionChanged;
},

//> @method listGrid.setSelectionType() [A]
// Changes selectionType on the fly.
// @param   selectionType (SelectionStyle)  New selection style.
// @visibility external
//<
setSelectionType : function (selectionType, ignoreCheckbox) {
    // NOTE: this is sufficient because the Selection object dynamically inspects this property
    // on it's grid
    this.selectionType = selectionType;
    if (this.body) this.body.selectionType = selectionType;
},

//> @method listGrid.setSelectionAppearance()
// Changes selectionAppearance on the fly.
// @param   selectionAppearance (String)    new selection appearance
// @visibility external
//<
setSelectionAppearance : function (selectionAppearance, isInit) {
    if (this.selectionAppearance == selectionAppearance && !isInit) return;

    if (selectionAppearance == "checkbox" && this.canSelectCells) {
        this.logWarn("ignoring selectionAppearance:'checkbox' since canSelectCells is set");
        selectionAppearance = "rowStyle";
    }

    this.selectionAppearance = selectionAppearance;

    // at initialization time, if selectionType wasn't explicitly set, default selectionType to
    // "simple" for "checkbox" appearance, otherwise "multiple"
    if (isInit && this.selectionType == null && !this.canSelectCells) {
        this.selectionType = (selectionAppearance == "checkbox" ? isc.Selection.SIMPLE :
                                                                  isc.Selection.MULTIPLE);
    }

    // If this.completeFields is set (IE setFields has run already), we need to either add or
    // remove the checkboxField
    // Call setFields() with a duplicate of the current set of fields, less the
    // checkboxField (if there was one)
    // This will create a new checkboxField if necessary otherwise just clear the existing one
    if (this.completeFields != null) {
        var completeFields = [];
        for (var i = 0; i < this.completeFields.length; i++) {
            var field = this.completeFields[i];
            if (this.isCheckboxField(field)) continue;
            completeFields.add(field);
        }
        this.setFields(completeFields);
    }
},

//> @method listGrid.setBodyOverflow()  ([A])
// Update the +link{listGrid.bodyOverflow, bodyOverflow} for this listGrid.
// @param overflow (Overflow) new overflow setting for the body
// @visibility external
//<
setBodyOverflow : function (newOverflow) {
    this.bodyOverflow = newOverflow;
    if (this.body) this.body.setOverflow(this.bodyOverflow);
},

//> @method listGrid.setBodyStyleName()
// Update the +link{listGrid.bodyStyleName,bodyStyleName} for this listGrid.
// @param styleName (CSSStyleName) new body style name
// @visibility external
//<
setBodyStyleName : function (styleName) {
    this.bodyStyleName = styleName;
    if (this.body && (!this.alternateBodyStyleName || !this.alternateRecordStyles)) {
        this.body.setStyleName(styleName);
    }
},

//> @method listGrid.setAlternateBodyStyleName()
// Update the +link{listGrid.alternateBodyStyleName,alternateBodyStyleName} for this listGrid.
// @param styleName (CSSStyleName) new body style name when showing alternateRecordStyles
// @visibility external
//<
setAlternateBodyStyleName : function (styleName) {
    this.alternateBodyStyleName = styleName;
    if (this.body && this.alternateRecordStyles) {
        // if passed 'null', reset to this.bodyStyleName
        this.body.setStyleName(styleName || this.bodyStyleName);
    }
},

//> @method listGrid.setAlternateRecordStyles()
// Setter for +link{listGrid.alternateRecordStyles}
// @param alternateStyles (boolean) New value for <code>this.alternateRecordStyles</code>
// @visibility external
//<
setAlternateRecordStyles : function (alternateStyles) {
    if (this.alternateRecordStyles == alternateStyles) return;
    this.alternateRecordStyles = alternateStyles;

    if (this.body && (this.alternateBodyStyleName != null)) {
        if (alternateStyles) this.body.setStyleName(this.alternateBodyStyleName);
        else this.body.setStyleName(this.bodyStyleName);
    }

},

// Override hasInherentHeight / width: If we're autoFitting to our data, advertise inherent height
// This means that a layout will not expand us to fit the available space.

hasInherentHeight : function (a,b,c,d) {
    if (this.inherentHeight != null) return this.inherentHeight;
    if (this.autoFitData == isc.Canvas.VERTICAL || this.autoFitData == isc.Canvas.BOTH) {
        return true;
    }
    return this.invokeSuper(isc.ListGrid, "hasInherentHeight", a,b,c,d);
},

hasInherentWidth : function (a,b,c,d) {
    if (this.inherentWidth != null) return this.inherentWidth;
    if (this.autoFitData == isc.Canvas.HORIZONTAL || this.autoFitData == isc.Canvas.BOTH) {
        return true;
    }
    return this.invokeSuper(isc.ListGrid, "hasInherentWidth", a,b,c,d);
},

//> @method listGrid.setAutoFitData()
// Setter for +link{listGrid.autoFitData}.
// @param autoFitData (string) One of <code>"vertical"</code>, <code>"horizontal"</code>
//  or <code>"both"</code>. To disable auto fit behavior, pass in <code>null</code>.
// @group autoFitData
// @visibility external
//<
setAutoFitData : function (autoFitData) {
    this.autoFitData = autoFitData;

    if (this._autoDerivedCanFreeze && (autoFitData == "both" || autoFitData == "horizontal"
                                 
                                       || autoFitData == "vertical")) {
        delete this._autoDerivedCanFreeze;
        delete this.canFreezeFields;
    }
    if (autoFitData == null && this._specifiedOverflow) {
        this.setOverflow(this._specifiedOverflow);
    } else if (this.overflow != "visible") {
        this._specifiedOverflow = this.overflow;
        this.setOverflow("visible");
    }
    if (this.body) {
        this.body.autoFitData = this.autoFitData;
        this.body.adjustOverflow();
    }
},

//> @method listGrid.setAutoFitExtraRecords()
// Setter for +link{listGrid.autoFitExtraRecords}.
// @param extraRecords (integer) Number of extra rows beyond the data-size we'll expand to
// accommodate if +link{listGrid.autoFitData,auto fit} is enabled vertically.
// @group autoFitData
// @visibility external
//<
setAutoFitExtraRecords : function (extraRecords) {
    this.autoFitExtraRecords = extraRecords;
    if (this.body) {
        this.body.autoFitExtraRecords = extraRecords;
        this.body.adjustOverflow();
    }
},


//> @method listGrid.setAutoFitMaxRecords()
// Setter for +link{listGrid.autoFitMaxRecords}.
// @param maxRecords (integer) Maximum number of rows we'll expand to accommodate if
// +link{listGrid.autoFitData,auto fit} is enabled vertically.
// @group autoFitData
// @visibility external
//<
setAutoFitMaxRecords : function (maxRecords) {
    this.autoFitMaxRecords = maxRecords;
    if (this.body) {
        this.body.autoFitMaxRecords = maxRecords;
        this.body.adjustOverflow();
        if (this.frozenBody) {
            this.frozenBody.autoFitMaxRecords = maxRecords;
            this.frozenBody.redraw();
        }
    }
},

//> @method listGrid.setAutoFitMaxHeight()
// Setter for +link{listGrid.autoFitMaxHeight}.
// @param height (integer) Maximum height in px we'll expand to accommodate if
// +link{listGrid.autoFitData,auto fit} is enabled vertically.
// @group autoFitData
// @visibility external
//<
setAutoFitMaxHeight : function (height) {
    this.autoFitMaxHeight = height;
    if (this.body) {
        this.body.adjustOverflow();
        if (this.frozenBody) this.frozenBody.redraw();
    }
},
getAutoFitMaxBodyHeight : function () {
    if (this.autoFitMaxHeight == null) return null;
    var offset = this.getVBorderPad();
    if (this.showHeader) offset += this.getHeaderHeight();
    if (this.showFilterEditor) offset += this.filterEditorHeight;
    if (this.showGridSummary) offset += this.summaryRowHeight;
    return this.autoFitMaxHeight - offset;

},

// When auto-fitting vertically, specified height for the grid acts as a minimum
getAutoFitMinBodyHeight : function () {
    var minHeight = this.getHeight(),
        offset = this.getVBorderPad();
    
    var members = this.getGridMembers(),
        body = this.bodyLayout || this.body;
        
    for (var i = 0; i < members.length; i++) {
        if (members[i] == body) continue;
        offset += members[i].getVisibleHeight();
    }

    return (minHeight - offset);
},

//> @method listGrid.setAutoFitMaxColumns()
// Setter for +link{listGrid.autoFitMaxColumns}.
// @param maxColumns (integer) Maximum number of fields we'll expand to accommodate if
// +link{listGrid.autoFitData,auto fit} is enabled horizontally.
// @group autoFitData
// @visibility external
//<
setAutoFitMaxColumns : function (maxColumns) {
    this.autoFitMaxColumns = maxColumns;
    if (this.body) {
        this.body.autoFitMaxColumns = maxColumns;
        this.body.adjustOverflow();
    }
},

//> @method listGrid.setAutoFitMaxWidth()
// Setter for +link{listGrid.autoFitMaxWidth}.
// @param width (integer) Width in px we'll expand to accommodate if
// +link{listGrid.autoFitData,auto fit} is enabled horizontally.
// @group autoFitData
// @visibility external
//<
setAutoFitMaxWidth : function (width) {
    this.autoFitMaxWidth = width;
    if (this.body) {
        this.body.autoFitMaxWidth = width;
        this.body.adjustOverflow();
    }
},

// --------------------------------
// AutoFitFields

//> @method listGrid.autoFitField()
// Programmatically cause a field to auto-fit horizontally to it's contents or title.
// <P>
// Does not establish permanent auto-fitting - use +link{listGrid.setAutoFitWidth()} or
// +link{setAutoFitFieldWidths()} to do so.
// <P>
// Note that unlike the ongoing autoFit set up by +link{listGrid.autoFitFieldWidths} or
// +link{listGridField.autoFitWidth}, any specified +link{listGridField.width} will not be
// taken as a minimum width - the field may shrink below the current specified width when
// this method is run.
// <P>
// As with +link{listGrid.autoFitFieldWidths}, the auto-fit sizing is determined via the
// +link{listGrid.autoFitWidthApproach}.
//
// @param fieldName (string)
// @return (int) new width in pixels
//
// @group autoFitFields
// @visibility external
//<
autoFitField : function (fieldName, scrollIntoView) {
    var field = this.getField(fieldName),
        fieldNum = this.getFieldNum(field);
    // avoid attempting to autofit hidden fields, or fields where
    // autoFitWidth is already set (should just happen dynamically!)
    if (field == null || fieldNum == -1) return;

    var widths = this.getFieldAutoFitWidths([field]);
    
    if (widths == null || widths[0] == null) return;
    
    // Set a flag noting that we're auto-fitting this field.
    // We'll use this to suppress normal reflow in reaction to the 'headerButtonResized' notification.
    // Treat this somewhat similarly to a drag-resize.
    this._autoFittingField = field;
    
    var width = widths[0];
    // resize the field (as if the user drag-resized to the auto-fit size)
    var dontStoreWidth = this.shouldAutoFitField(field);
    if (this._fieldWidths && width != this._fieldWidths[fieldNum]) {
        this.resizeField(fieldName, width, !dontStoreWidth);
    } else if (!dontStoreWidth) field.width = width;
    if (this._fieldWidths && dontStoreWidth) field._calculatedAutoFitWidth = this._fieldWidths[fieldNum];

    if (scrollIntoView) this.scrollToColumn(fieldNum, "left");

    // When a field is auto-fit, if the headerMenuButton is showing for the field, then we
    // will want to reposition the HMB if this is a touch device (on which the HMB is always
    // shown if the header is selected) or if the mouse is still within the the header button.
    // Otherwise, hide the HMB.
    if (this.headerMenuButton != null && this.headerMenuButton.masterIndex == fieldNum) {
        // getFieldHeader / getLocalFieldNum will account for frozen fields
        var header = this.getFieldHeader(fieldNum),
            headerButton = header.getMember(this.getLocalFieldNum(fieldNum));

        var EH = this.ns.EH;
        if (isc.Browser.isTouch ||
            headerButton.containsPoint(EH.getX(), EH.getY()))
        {
            // Refresh the cached scrollWidth of the header button. This is needed for the
            // case where the header button is marked for redraw, but getHeaderMenuButton()
            // needs the new scrollWidth of the just-resized header button.
            headerButton.getScrollWidth(true);

            this.getHeaderMenuButton(headerButton);

        } else {
            this.headerMenuButton.hide();
        }
    }
    
    delete this._autoFittingField;

    return width;
},

//> @method listGrid.autoFitFields()
// Perform a one-time horizontal auto-fit of the fields passed. Fields will be sized
// to match their contents or title (as specified in +link{listGrid.autoFitWidthApproach})
// Does not establish permanent auto-fitting - use +link{listGrid.setAutoFitWidth()} to do so.
// <P>
// Note that unlike the ongoing autoFit set up by +link{listGrid.autoFitFieldWidths} or
// +link{listGridField.autoFitWidth}, any specified +link{listGridField.width} will not be
// taken as a minimum width - the field(s) may shrink below the current specified width when
// this method is run.
//    
// @param [fields] (Array of ListGridField) Array of fields to auto fit. If this parameter
//  is not passed, autoFitting will occur on all visible fields.
//
// @group autoFitFields
// @visibility external
//<
autoFitFields : function (fields) {
    
    // We don't support one-time autofit while undrawn.
    if (!this.isDrawn()) {
        this.logWarn("autoFitFields() called on undrawn grid. This will have no effect. " +
                     "For one-time auto-fit to drawn sizes, call this method after draw. " +
                     "To establish permanent auto-fit, use listGrid.autoFiedFieldWidths instead.");
        return;
    }
    

    if (this.body) this.body._fieldWidthsDirty = true;

    this.autoSizeHeaderSpans = false;
    if (fields == null) fields = this.getAllCanAutoFitFields();

    this._autoFittingFields = true;
    var finalFields = [];
    for (var i = 0; i < fields.length; i++) {
        var field = this.getField(fields[i]);
        if (field != null) {
            delete fields[i].width;
            delete fields[i]._calculatedAutoFitWidth;
            finalFields[finalFields.length] = field;
        }
    }
    // we've removed any hidden fields here.
    fields = finalFields;
    
    var widths = this.getFieldAutoFitWidths(fields, this.autoFitFieldsFillViewport);
    
    var fieldNums = [], resizeWidths = [], storeWidths = [];
    for (var i = 0; i < fields.length; i++) {

        if (widths[i] == null) continue;
        var width = widths[i],
            field = fields[i],
            fieldNum = this.getFieldNum(fields[i]),
            fieldName = fields[i].name;
        // resize the field (as if the user drag-resized to the auto-fit size)
        var dontStoreWidth = this.shouldAutoFitField(field);
        if (this._fieldWidths && width != this._fieldWidths[fieldNum]) {

            fieldNums[fieldNums.length] = fieldNum;
            resizeWidths[resizeWidths.length] = width;
            storeWidths[storeWidths.length] = !dontStoreWidth;

        } else if (!dontStoreWidth) field.width = width;
    }
    
    this._resizeFields(fieldNums, resizeWidths, storeWidths);
    for (var i = 0; i < fieldNums.length; i ++) {
        if (!storeWidths[i]) {
            var fieldNum = fieldNums[i];
            this.getField(fieldNum)._calculatedAutoFitWidth = this._fieldWidths[fieldNum];
        }
    }

    this._autoFittingFields = false;

    // we suppressed placeEmbeddedComponents() during the field resizes, so
    // run it now to ensure any embedded components are correctly positioned and sized.
    if (this.frozenBody) this.frozenBody._placeEmbeddedComponents()
    if (this.body) this.body._placeEmbeddedComponents();
    // Normally we do this in resizeField() but we don't want a bunch of unnecessary
    // reflows so we delay until resize of fields is complete
    if (this.header && this.autoFitHeaderHeights) {
        this.dropCachedHeaderButtonHeights();
        this._updateHeaderHeight();
    }

    this.getFieldWidths();
    // This will adjust header heights if necessary to account for differently wrapped
    // content
    if (this.header) this.header._sizeSpans();

    
    this.markForRedraw();
},

// Helper to get all (visible) fields where canAutoFitWidth != false
// these are the fields which will be resized by a call to autoFitFields with no arguments
// (and by the auto-fit-all menu option)
getAllCanAutoFitFields : function () {
    var fields = this.fields;
    if (fields == null || fields.length == 0) {
        return fields;
    }
    
    var canAutoFitFieldArray = [];
    for (var i = 0; i < fields.length; i++) {
        if (fields[i].canAutoFitWidth == false) continue;
        canAutoFitFieldArray.add(fields[i]);
    }
    return canAutoFitFieldArray;
},


shouldAutoFitField : function (field) {
    if (field.autoFitWidth != null) return field.autoFitWidth;
    return this.autoFitFieldWidths;
},

// This method is called directly as part of resizeFields() and acts as a minimum, disallowing
// resizing below the min field width.

getMinFieldWidth : function (field, ignoreFieldWidth) {
    var minWidth = this.minFieldWidth || 1;
    if (!ignoreFieldWidth) {
        
        var fieldWidth = field.width;
        if (isc.isA.Number(fieldWidth)) {
            minWidth = Math.max(minWidth, field.width);
        }
    }
    // this is also enforced by Canvas.applyStretchResizePolicy() if any of the
    // fields are operating as stretch-sized members of the header Layout
    if (field.minWidth != null) {
        minWidth = Math.max(minWidth, field.minWidth);
    }
    var fieldName = field.name;
    // If we have embeddedComponents for the field we should treat that as a minimum
    if (!this.clipRecordComponents &&
            (this._columnComponentsMap && this._columnComponentsMap[fieldName]))
    {
        var componentMaxWidth = this._getFieldComponentMaxWidth(fieldName);
        if (componentMaxWidth > minWidth) {
            minWidth = componentMaxWidth;
        }
    }

    return minWidth;
},
clipRecordComponents: true,

_$within:"within",
_getFieldComponentMaxWidth : function (fieldName) {
    var field = this.getField(fieldName);
    if (field == null) return 0;

    if (field._maxComponentWidth != null) return field._maxComponentWidth;

    var components = this._columnComponentsMap[fieldName];
    var maxWidth = 0;
    for (var compID in components) {
        var component = window[compID];
//         this.logWarn("For field:" + fieldName + " contemplating:" + component +
//             " which has width:" + component.getVisibleWidth());
        // skip "expand" components - these are always sized to fit the field.
        if (component && (component.embeddedPosition == this._$within) &&
            (component.getVisibleWidth() > maxWidth) )
        {
            maxWidth = component.getVisibleWidth();
        }
    }
    field._maxComponentWidth = maxWidth;
    return maxWidth;
},

// This method fires when we have embedded components which may overflow the
// specified field width horizontally, so we need to expand to fit.
_fieldComponentWidthsChanged : function (fieldName, newWidth) {
    var field = this.getField(fieldName);
    if (field) {
        // If we happen to know we just increased the size, we can update
        // the max-width without having to query sizes of all drawn components.
        // Otherwise just clear the cached value and we'll lazily recalculate.
        if (newWidth) field._maxComponentWidth = newWidth;
        else delete field._maxComponentWidth;

        // Use "fireOnPause" to actually resize the field to fit the components on a delay
        
        if (this._staleComponentWidthFields == null) {
            this._staleComponentWidthFields = {};
        }
        this._staleComponentWidthFields[fieldName] = true;
        this.fireOnPause(
            "checkFieldComponentOverflow",
            {target:this,methodName:"_checkFieldComponentOverflow"}, 0
        );
    }

},
_checkFieldComponentOverflow : function () {
    if (this.fields == null) return;

    
     
    var currentWidths = this._fieldWidths || this.getFieldWidths(),
        overflowedFields = [],
        newWidths = [],
        storeWidths = [],
        overflowed = false;
    for (var i = 0; i < this.fields.length; i++) {
        var name = this.fields[i].name;
        if (!this._staleComponentWidthFields[name]) continue;
        this._staleComponentWidthFields[name] = null;

        var minWidth = this.getMinFieldWidth(this.fields[i]);
        if (minWidth > currentWidths[i]) {
            overflowedFields.add(i);
            newWidths.add(minWidth);
            // We don't want to store any of these widths. If autoFitFieldWidths
            // is true, if the component is hidden etc we want to be able to resize
            // smaller again if _updateFieldWidthsForAutoFitValue() gets re-run.
            storeWidths.add(false);
        }
    }
    // Embedded components in some cell overflowed the available width - resize
    // the field to accommodate it.
    
    if (overflowedFields.length > 0) {
        this._resizeFields(overflowedFields, newWidths, storeWidths);
    }
},

getFieldAutoFitWidths : function (fields, fillViewport) {
    if (this.body == null || fields == null) return;
    if (!isc.isA.Array(fields)) {
        fields = [fields]
    }
    var widths = [],
        colNums = [],
        minWidths = [];

    var headers = [],
        bodyFields = [];

    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            colNum = this.getColNum(field),
            approach = this.getAutoFitWidthApproach(field, true),
            checkHeader = approach != "value",
            checkBody = approach != "title";

        // we'll use the colNums outside this loop when we pick up the body col widths
        colNums[i] = colNum;
        widths[i] = minWidths[i] = this.getMinFieldWidth(fields[i], true);

        if (checkHeader) {
            var header = this.getFieldHeaderButton(colNum);
            
            if (header != null) headers[i] = header;
        }

        if (checkBody) {
            bodyFields.add(field);
        }

    }

    
    if (headers.length > 0) {
        //var startTime = isc.timeStamp();
        var headerWidths = this.getAutoFitTitleWidths(headers);
        //this.logWarn("Time to get header title widths:" + (isc.timeStamp() - startTime));
        for (var i = 0; i < headerWidths.length; i++) {
        
            
            if (headerWidths[i] == null) continue;
            widths[i] = Math.max(widths[i],headerWidths[i]);
        }
    }

    // for efficiency, pass all the body fields to getAutoFitValueWidths() at once.
    
    if (bodyFields.length > 0) {
        var bodyColWidthArr = this.getAutoFitValueWidths(bodyFields);
        for (var i = 0; i < fields.length; i++) {
            if (colNums[i] != null) {
                var colNum = colNums[i],
                    bodyColWidth = bodyColWidthArr ? bodyColWidthArr[colNum] : null;
                if (bodyColWidth != null) {
                    if (widths[i] == null || bodyColWidth > widths[i]) {
                        widths[i] = bodyColWidth;
                    }
                }
            }
        }
    }
    
    // If passed the fillViewport flag, and there is extra space, expand the
    // appropriate field by the delta such that we do indeed fill the viewport.
    
    if (fillViewport) {
        var frozenSize = 0,
            unfrozenSize = 0,
            unfrozenSpace,
            expandField = this.getAutoFitExpandField(),
            expandFieldIndex = this.fields.indexOf(expandField),
            requiresExpansion = colNums.contains(expandFieldIndex);

        if (requiresExpansion) {

            for (var i = 0; i < this.fields.length; i++) {
                var colWidth,
                    index = colNums.indexOf(i);
                if (index >= 0) {
                    colWidth = widths[index];
                } else {
                    colWidth = this._fieldWidths[i];
                    if (colWidth == null) {
                        
                        requiresExpansion = false;
                        break;
                    }
                }
                if (this.fields[i].frozen) {
                    frozenSize += colWidth;
                } else {
                    unfrozenSize += colWidth;
                }
            }
            
            if (requiresExpansion) {
                unfrozenSpace = this.getAvailableFieldWidth(true) - frozenSize;
                requiresExpansion = unfrozenSize < unfrozenSpace;
            }
            if (requiresExpansion) {
                widths[expandFieldIndex] += (unfrozenSpace - unfrozenSize);
            }
        }
    }

    // limit the returned widths by the maxWidth value of each field
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            maxWidth = field.maxWidth;
        if (maxWidth == null) continue;
        // don't ever lower the width below the minimum reported by getMinFieldWidth()
        if (widths[i] > maxWidth) widths[i] = Math.max(minWidths[i], maxWidth);
    }

    return widths;
},

getAutoFitTitleWidths : function (headers) {

    var testHTML = "",
        missingHeaders = {};
    for (var i = 0; i < headers.length; i ++) {
        
        if (headers[i] == null) {
            missingHeaders[i] = true;
            continue;
        }
        var header = headers[i],
            titleStyle = header.titleStyle;
        if (titleStyle == null) titleStyle = header.getStateName();
        
        
        testHTML += header._getSizeTestHTML(this.getHeaderButtonTitle(header, false));
    }
    if (this.logIsDebugEnabled("autoFitFieldWidths")) {
        this.logDebug("Auto Fit Title test HTML:\n" + testHTML, "autoFitFieldWidths");
    }

    if (isc.ListGrid.headerWidthsTester == null) {
        isc.ListGrid.headerWidthsTester = isc.Canvas.create({
            top:-100,
            
            width: 1,
            autoDraw:true,
            overflow:"hidden",
            contents:testHTML,
            
            ariaState: {
                hidden: true
            }
        });

    } else {
        isc.ListGrid.headerWidthsTester.setContents(testHTML);
    }
    
    if (!isc.ListGrid.headerWidthsTester.isDrawn()) {
        isc.ListGrid.headerWidthsTester.draw();
    }
    if (isc.ListGrid.headerWidthsTester.isDirty()) {
        isc.ListGrid.headerWidthsTester.redraw();
    }

    var handle = isc.ListGrid.headerWidthsTester.getHandle(),
        childNodes = handle.childNodes;

    var widths = [];
    for (var i = 0, j=0; i < headers.length; i ++) {
        if (missingHeaders[i]) {
            widths[i] = null;
            continue;
        }

        var titleDiv = childNodes[j];
        
        if (isc.Browser.isChrome || isc.Browser.isMoz || isc.Browser.isIE9) {
            var titleBCR = titleDiv.getBoundingClientRect();
            if (!isc.Browser.isIE || isc.Browser.isIE10) {
                widths[i] = Math.ceil(titleBCR.width);
            } else {
                widths[i] = (titleBCR.width + 1) << 0;
            }
        } else {
            widths[i] = Math.ceil(titleDiv.offsetWidth);
        }
        j++;
    }

    if (widths.length != headers.length) {
        this.logWarn("getAutoFitTitleWidths(): Mismatch between " +
            "headers passed in and calculated widths", "autoFitFieldWidths");
    }
    return widths;
},

//> @method listGrid.setAutoFitWidth()
// Setter for +link{listGridField.autoFitWidth}. Enables or disables dynamic autoFitWidth behavior
// on the specified field. Note if the field is currently autoFitWidth:true, and this method is
// disabling autoFit, the field will not be resized by default - if you wish to resize to an
// explicit width, use +link{listGrid.resizeField()}.
//
// @param fieldName (string) field to auto-fit
// @param autoFit (boolean) Should autoFitWidth be enabled or disabled?
// @group autoFitFields
// @visibility external
//<
setAutoFitWidth : function (fieldName, autoFit) {
    var field = this.getField(fieldName);
    if (field == null) return;
    if (field.autoFitWidth == autoFit) return;

    field.autoFitWidth = autoFit;

    if (autoFit) this.autoFitField(field);
    // If we're turning off auto-fit, don't bother to resize
},

//> @method listGrid.setAutoFitFieldWidths()
// Setter for +link{listGrid.autoFitFieldWidths}. Modifies the default auto-fit-width behavior
// for fields in this grid. Note that this may be overridden at the field level via
// +link{listGridField.autoFitWidth}.
// @param autoFit (boolean) New value for autoFitFieldWidths
// @param [dontResetWidths] (boolean) If autoFitFieldWidths was true, and is being set to false,
//  should fields be resized to their originally specified size?
//  Pass in this parameter to suppress this behavior.
// @visibility external
//<
setAutoFitFieldWidths : function (autoFit, dontResetWidths) {
    if (autoFit == this.autoFitFieldWidths) return;
    this.autoFitFieldWidths = autoFit
    if (autoFit) {
        this._updateFieldWidths("autoFitFieldWidths enabled");
    } else if (!dontResetWidths) {
        // If we're showing a header, we use it to handle converting specified
        // field widths into real sizes - running updateHeader will rebuild it and
        // perform this initial calculation for us.
        if (this.showHeader && this.headerHeight > 0) this.updateHeader();
        // Clear the flag indicating we've run through auto-fit logic and re-run
        // _updateFieldWidths() to revert the fields to specified sizes.
        this.fields._appliedInitialAutoFitWidth = false;
        this._updateFieldWidths("autoFitFieldWidths disabled");
    }
},

//> @method listGrid.setAutoFitWidthApproach()
// Setter for the +link{listGrid.autoFitWidthApproach}.
// @param approach (AutoFitWidthApproach) new AutoFitWidth approach
// @visibility external
//<
setAutoFitWidthApproach : function (approach) {
    if (this.autoFitWidthApproach == approach) return;
    this.autoFitWidthApproach = approach;

    // If we're showing a header, we use it to handle converting specified
    // field widths into real sizes - running updateHeader will rebuild it and
    // perform this initial calculation for us.
    
    if (this.showHeader && this.headerHeight > 0) this.updateHeader();
    // Clear the flag indicating we've run through auto-fit logic and re-run
    // _updateFieldWidths() to revert the fields to specified sizes.
    this.fields._appliedInitialAutoFitWidth = false;
    this._updateFieldWidths("autoFitFieldWidthApproach changed");
},

// mark the body for redraw, or if the body doesn't exist, the widget as a whole
_markBodyForRedraw : function (reason) {
    if (this.bodies) {
        this.bodies.map("markForRedraw", reason);
    } else if (this.body) {
        this.markForRedraw(reason);
    }
},

redraw : function (a, b, c, d) {
    if (this.body) {
        
        if (this.body._scrollbarChangeDuringAnimation) {
            this._updateFieldWidths("scrollbar change during animation");
            delete this.body._scrollbarChangeDuringAnimation;
        }
    }

    this.invokeSuper(isc.ListGrid, "redraw", a, b, c, d);

},

//> @method listGrid._observeData() (A)
//      observe methods on the data so we redraw automatically when data changes
//      called automatically by setData
//  @param  data    (object)        new data to be observed
//<
_observeData : function (data) {
    // redraw if the data changed
    var isRS = isc.ResultSet && isc.isA.ResultSet(data);
    if (!this.isObserving(data, "dataChanged")) {
        if (isRS) {
            this.observe(data, "dataChanged", function (operationType, originalRecord, rowNum, updateData, filterChanged, dataFromCache) {
                this.dataChanged(operationType, originalRecord, rowNum, updateData, filterChanged, dataFromCache);
            });
        } else {
            this.observe(data, "dataChanged", function () {
                this.dataChanged();
            });
        }
    }

    if (!this.isObserving(data, "dataArrived")) {
        if (isRS) {
            this.observe(data, "dataArrived", function (startRow, endRow, dataFromCache) {
                this._dataArrived(startRow, endRow, dataFromCache);
            });
        } else if (isc.ResultTree && isc.isA.ResultTree(data)) {
            this.observe(data, "dataArrived", function (parentNode) {
                this._dataArrived(parentNode);
            });
        }
    }

    // Note - we must check for data being a tree as if it is not defined, the inherited
    // ListGrid.init() code will set it to an empty array, in which case this observation will
    // fail.
    if (isc.isA.Tree(data)) {
        // update view in response to folders opening / closing
        this.observe(data, "changeDataVisibility", function (node, newState) {
            this._folderToggleObservation(node, newState);
        });
    }
},
//> @method listGrid.groupTreeChanged()
// Callback fired from group tree +link{listGrid.groupTree} dataChanged().
// <p>
// Handles remapping edit rows and forcing a redraw if necessary.
// @group grouping
//<
// The groupTree may be a ResultTree or a Tree object.
// When a listGrid is grouped we still observe dataChanged on the underlying data object and react
// to it by updating or rebuilding the groupTree as required, and marking for redraw etc.
// Therefore if this method is fired from standard dataChanged() we typically need to take no
// action.
// Note that we explicitly disable databound cache-sync for the ResultTree and instead manage
// updating the ResultTree cache directly as part of ListGrid.dataChanged. This is appropriate since
// The ResultTree code for cache sync is organized around node ids and parent ids whereas the
// groupTree is a dynamic grouping based on records have the same values for a field.
//
// This will actually fire in response to listGrid sort or direct manipulation of the groupTree
//
// Note that this method is only fired when an existing groupTree changes - not when regroup()
// is run, creating a new groupTree.
_$dataChanged:"dataChanged",
groupTreeChanged : function () {
    // If the groupTree was updated from underlying data change, no need to
    // redraw etc (already handled in dataChanged())
    if (this._handlingDataChanged) return;

    if (!this._savingEdits && !this.suppressEditRowRemap) this._remapEditRows();
    var lastRow = this.getTotalRows()-1;
    if (this.body) {
        
        if (this.body.lastOverRow > lastRow) delete this.body.lastOverRow;
        if (this.body.lastMouseOverRow > lastRow) delete this.body.lastMouseOverRow;
        if (this.body._lastHiliteRow > lastRow) delete this.body._lastHiliteRow;
    }
    if (this._lastRecordClicked > lastRow) delete this._lastRecordClicked;

    if (this.hilites) this.applyHilites();
    if (!this._suppressRedrawOnDataChanged) this.redrawForDataChanged();

},
    
//> @method listGrid._observeGroupData() (A)
//      observe methods on the group tree object, so that changes to the group layout
//      can be detected
//  @param  data    (object)        new group tree to be observed
//  @visibility internal
//<
_observeGroupData : function (data) {
    // redraw if the data changed
    this.observe(data, "dataChanged", function () {
        this.groupTreeChanged();
    });
    this.observe(data, "changeDataVisibility", function (node, newState) {
        this._folderToggleObservation(node, newState);
    });
},

// METHODS MOVED FROM TREEGRID
// The following methods were moved from treegrid to allow the listgrid to support the tree
// as a data model for grouping. They will continue to be doc'd on treegrid for now

// Helper method - fired when folders open/close within the tree
_folderToggleObservation : function (node, newState) {
    // If we're loaded, reapply hilites, but pass in the flag to suppress marking for redraw
    // We need to do this since we won't get a dataChanged notification from the
    // children loading.
    // No need to redraw here since we will redraw (below) in response to the folder toggling.
    if (node != null && this.hilites && newState) {
        var loadState = this.data.getLoadState(node);
        if (loadState == isc.Tree.LOADED || loadState == isc.Tree.LOADED_PARTIAL_CHILDREN) {
            this.applyHilites(true);
        }
    }
    //>Animation
    // During animated folder open/close we suppress redraw in response to the folder toggling
    
    if (this._suppressFolderToggleRedraw) {
        this._remapEditRows();

        // Re run auto fit logic expand our cols to fit the revealed content
        
        this.updateFieldWidthsForAutoFitValue("Folder Toggled");

        return;
    }

    // Cut short any currently running animated folder open / close
    // Just call finishAnimation - this will no op if no animation is running
    
    if (this.body) this.body.finishRowAnimation();
    //<Animation

    // Length changes so we need to remap edit rows.
    this._remapEditRows();

    // Re run auto fit logic expand our cols to fit the revealed content
    this.updateFieldWidthsForAutoFitValue("Folder Toggled");

    // redraw to display the updated folder
    this._markBodyForRedraw('folderToggled');
},

//> @method treeGrid.toggleFolder()   ([])
// Opens the folder specified by node if it's closed, and closes it if it's open.
// TreeGrid will redraw if there's a change in the folder's open/closed state.
//
// @visibility external
// @param node (TreeNode) node to toggle
//<
toggleFolder : function (node) {
    if (this.data.isOpen(node)) {
        this.closeFolder(node);
    } else {
        this.openFolder(node);

        
        var loadState = this.data.getLoadState(node);
        if (loadState == isc.Tree.LOADING) {
            var nodeIndex = this.getRecordIndex(node);
            if (nodeIndex >= 0) this.refreshCell(nodeIndex, this._treeFieldNum);
        }

        
        if (this.frozenBody) this.frozenBody.markForRedraw();
    }
},

//> @method treeGrid.openFolder() ([A])
// Opens a folder.
// <p>
// Executed when a folder node receives a 'doubleClick' event.
// <smartclient>If you override this method, the single parameter passed will be
// a reference to the relevant folder node in the tree's data.</smartclient>
// <p>
// See the ListGrid Widget Class for inherited recordClick and recordDoubleClick events.
//
// @param   node        (TreeNode)      node to open
// @see closeFolder()
// @see folderOpened()
// @see class:ListGrid
// @visibility external
//<
openFolder : function (node) {
    // CALLBACK API:  available variables:  "node"
    // Convert a string callback to a function
    if (this.folderOpened != null) {
        this.convertToMethod("folderOpened");
        if (this.folderOpened(node) == false) return false;
    }

    
    if (this.animateFolders) {
        this.animateOpen(node);
    } else {
        this.data.openFolder(node);
    }

},

//> @method treeGrid.animateOpen()
// Animates a folder opening to display its children (which grow into view).
// Automatically triggered from <code>treeGrid.folderOpen()</code> if
// <code>this.animateFolders</code> is true.
// @group animation
// @param folder (node) node to open
// @visibility animation_advanced
//<
animateOpen : function (folder) {
    var data = this.data;
    if (data.isOpen(folder)) return;

    // Open the data, but don't redraw with the new data visible (we'll handle redrawing
    // when the animation completes).
    this._suppressFolderToggleRedraw = true;
    data.openFolder(folder);
    delete this._suppressFolderToggleRedraw;

    // parent may be null if we're looking at the root node
    var parent = data.getParent(folder);
    if (parent && !data.isOpen(parent)) return;

    var loadState = data.getLoadState(folder);
    if (loadState != isc.Tree.LOADED && loadState != isc.Tree.LOADED_PARTIAL_CHILDREN) {
        //this.logWarn("animation for LOD folder");
        // wait for dataChanged() to fire
        this._pendingFolderAnim = folder;
        return;
    }

    this._startFolderAnimation(folder);
},

//> @method treeGrid.closeFolder()
// Closes a folder.
//
// @param   node        (TreeNode)      node to close
// @see openFolder()
// @see folderClosed()
// @visibility external
//<
closeFolder : function (node) {
    // CALLBACK API:  available variables:  "node"
    // Convert a string callback to a function
    if (this.folderClosed != null) {
        this.convertToMethod("folderClosed");
        if (this.folderClosed(node) == false) return false;
    }

    // cancel editing of any nodes under this one
    if (this.getEditRow() != null) {
        var editRecord = this.getRecord(this.getEditRow());
        if (this.data.isDescendantOf(editRecord, node)) this.endEditing();
    }
    // now tell the data to close the folder
    if (this.shouldAnimateFolder(node))
        this.animateClose(node);
    else
        this.data.closeFolder(node);
},

//> @method treeGrid.animateClose()
// Animates a folder closing to hide its children (which shrink out of view).
// Automatically triggered from <code>treeGrid.folderOpen()</code> if
// <code>this.animateFolders</code> is true.
// @param folder (node) node to open
// @group animation
// @visibility animation_advanced
//<
animateClose : function (folder) {
    if (!this.data.isOpen(folder)) return;

    var parent = this.data.getParent(folder);
    if (parent && !this.data.isOpen(parent)) {
        return this.closeFolder(folder);
    }

    var data = this.data,
        folderIndex = data.indexOf(folder),
        numChildren = data.getOpenList(folder).getLength()-1;


    
    this.startRowAnimation( false,
                            folderIndex+1,
                            folderIndex + numChildren + 1,
                            {target:this, methodName:"redraw", args:["close folder animation complete"]},
                            this.animateFolderSpeed,
                            this.animateFolderTime,
                            this.animateFolderEffect,
                            true
                          );
    var wasSuppressed = this._suppressFolderToggleRedraw;
    this._suppressFolderToggleRedraw = true;
    this.data.closeFolder(folder);
    this._suppressFolderToggleRedraw = wasSuppressed;

    if (this.body && this.body._delayedRowAnimation != null) {
        this.body._openFolder = folder;
    }
    if (this.frozenBody && this.frozenBody._delayedRowAnimation != null) {
        this.frozenBody._openFolder = folder;
    }

},

_startFolderAnimation : function (folder) {
    // At this point we know we have all the children for the folder loaded - verify
    // that we actually should animate the folder into view - if we have too many children
    // we may not want to -- in this case just redraw.
    if (!this.shouldAnimateFolder(folder)) {
        this.markForRedraw();
        return;
    }
    var data = this.data,
        folderIndex = data.indexOf(folder),
        numChildren = data.getOpenList(folder).getLength()-1;

    // don't try to animate empty folders
    if (folderIndex < 0 || numChildren <= 0) return;

    this.startRowAnimation( true,
                            folderIndex+1,
                            (folderIndex + numChildren+1),
                            {target:(this.bodyLayout || this.body), methodName:"redraw", args:["open folder animation complete"]},
                            this.animateFolderSpeed,
                            this.animateFolderTime,
                            this.animateFolderEffect,
                            true
                          );
},

// Used to store open folder state in the groupTree
// (Also used by TreeGrid.getOpenState())

_addNodeToOpenState : function (tree, node, openState, isGroupTree) {
    if (!tree.isOpen(node) || !tree.isLoaded(node)) return false;
    var children = tree.getFolders(node),
        hasOpenChildren = false;
    if (children != null) {
        for (var i = 0; i < children.length; i++) {
            hasOpenChildren = this._addNodeToOpenState(tree, children[i], openState, isGroupTree)
                              || hasOpenChildren;
        }
    }
    if (isGroupTree) {
        var folderInfo = {};
        folderInfo[node.groupName] = node.groupValue;
        openState.add(folderInfo);
    } else {
        openState[openState.length] = tree.getPath(node);
    }
    return true;
},

// END METHODS MOVED FROM TREEGRID

// These parameters essentially match the 
// type, originalRecord and rowNum from ResultSet.dataChanged [not publicly exposed].

_getDataChangedRecord : function (originalRecord, rowNum, type) {
    // Sanity check - obviously this would imply we have no information at all.
    if (originalRecord == null && rowNum == null) return;
    if (type == "remove") return null;

    var currData = this.data;
    if (this.data.isGroupedOutput && this.originalData) currData = this.originalData;

    // updatedRecord does not exist (was deleted)
    var newRecord =  currData.get(rowNum);
    if (newRecord == null) return null;

    if (originalRecord != null) {
        var pks = this.dataSource != null ? this.getDataSource().getPrimaryKeyFieldNames() : [];
        var pkMismatch = false;
        for (var i = 0; i < pks.length; ++i) {

            if (originalRecord[pks[i]] != newRecord[pks[i]]) {
                pkMismatch = true;
                break;
            }
        }
        
        // if primary keys differ, the record was deleted via filtering, *or*
        // the data set is sorted, such that the rowNum refers to the
        // old, not the new position.
        // See if we can find the record by PKs
        if (pkMismatch) {
            newRecord = null;
            if (type == "update") {
                rowNum = currData.indexOf(originalRecord);
                if (rowNum != -1) {
                    // Assertion - this shouldn't cause a fetch since indexOf only
                    // queries loaded rows.
                    newRecord = currData.get(rowNum);
                }
            }
        }
    }
    return newRecord;
},


dataChanged : function (type, originalRecord, rowNum, updateData, filterChanged, dataFromCache) {
    if (isc._traceMarkers) arguments.__this = this;
    // set a flag so we know we're handling dataChanged
    // This prevents us from causing unnecessary additional redraws from dataChanged on the
    // groupTree if we're currently grouped by any field(s)
    this._handlingDataChanged = true;

    // DataChanged fires in some cases where we don't want to reset autoFieldWidths
    // For example, scrolling through a paged resultset where the columns resizing on scroll
    // would be ugly.
    // Use ResultSet parameters to test for cases to react to:
    // - crud operations which will affect the data displayed
    // - filter changing (including invalidateCache calls)
    // Note that we have equivalent logic inline in removeData, cellChanged to handle
    // non-databound grids' data being changed through standard grid APIs
    var resetAutoFitWidths = isc.isAn.Array(this.getOriginalData()) || 
                    (filterChanged || type == "add" || type == "remove");
    if (!resetAutoFitWidths && type == "replace") {
        if (originalRecord == null || rowNum == null) resetAutoFitWidths = true;
        else {
            var updatedRecord = this.getOriginalData().get(rowNum);
            if (updatedRecord == null) resetAutoFitWidths = true;
            else {
                for (var i = 0; i < this.fields.length; i++) {
                    if (this.shouldAutoFitField(this.fields[i])) {
                        var fieldName = this.getFieldName(this.fields[i]);
                        if (updatedRecord[fieldName] != updateData[fieldName]) {
                            resetAutoFitWidths = true;
                            break;
                        }
                    }
                }
            }
        }
    }

    var updatedGroupSummaries = false;

    // if a change was made to the groupBy field of a record, regroup
    var groupByFields = (this._groupByFields || this.getGroupByFields());
    if (groupByFields != null && !this._markForRegroup) {
        var markForRegroup = false;

        // fully regroup for add/remove, or for an update where dataChanged is not passed the
        // originalRecord to figure out if the groupField was changed
        var isAdd = type == "add",
            isRemove = !isAdd && (type == "remove"),
            isUpdate = !isAdd && !isRemove && (type == "update");

        var updatedRecord;
        
        // "remove" type operation but we don't know what was removed - full regroup
        
        if (isRemove) {    
            if (originalRecord == null) markForRegroup = true;
            
        } else if (isAdd || isUpdate) {
            // "update" operation with no previous record - implies 
            // an update record now matches our criteria and previously didn't.
            // Treat as an add.
            if (originalRecord == null) isAdd = true;
            
            updatedRecord = this._getDataChangedRecord(originalRecord, rowNum, type);

            if (updatedRecord == null) {
                // "update" operation and we don't have the record in our
                // originalData ResultSet. Implies it was lost from cache, probably
                // due to a change which made it no longer match criteria.
                // Treat as a remove.
                if (!isAdd) {
                    isRemove = true;
                } else {
                    
                    markForRegroup = true;
                }
            } 

        // Full regroup on filterChanged
        
        } else if (type == "replace" || filterChanged || !this.groupTree) {
            markForRegroup = true;
        }

        // If we're not doing a full regroup, update the group-tree directly
        if ((isAdd || isRemove || isUpdate) && !markForRegroup) {
            this.calculateRecordSummaries(updatedRecord, null, false, false);

            var pks = this.getDataSource().getPrimaryKeyFieldNames(),
                keyCriteria = {};
            this.logInfo("dataChanged(): Attempting incremental regroup for operation type:"
                         + type + " will be treated as a[n] " + 
                            (isAdd ? "add" : isRemove ? "remove" : "update"), "grouping");

            if (isAdd) {
                // Add - no existing node, so just add a node to the groupTree
                this._incrementalRegroup(updatedRecord, null);
                
            } else {
                // Remove or update
                // Finde the node within our tree which was effected
                
                // The "originalRecord" should have primary keys on it.
                // find the equivalent node in our groupTree
                for (var i = 0; i < pks.length; i++) {
                    keyCriteria[pks[i]] = (isRemove ? originalRecord[pks[i]] : updatedRecord[pks[i]]);
                }
                // NOTE: In general, we explicitly do not support composite primaryKeys with
                // Trees and TreeGrids.  However, ListGrid grouping is implemented by use of
                // a Tree - "this.data" in the below call is a Tree, not the List or ResultSet
                // holding the grid's real data.  Fortunately, Tree supports a criteria search
                // of its nodes, so we make use of that with a criteria object that happens to
                // contain only primary keys
                var nodes = this.data.findAll(keyCriteria);
                
                if (nodes != null) {
                    nodes.removeWhere("_isGroup", true);
                }

                
                if (!nodes || nodes.length != 1) {
                    
                    markForRegroup = true;
                    
                } else {

                    var node = nodes[0];

                    // remove: "incrementalRegroup" will remove the node from the group-tree
                    if (isRemove) {
                        this._incrementalRegroup(null, node);
                    } else {

                        // Update - potentially change the category of the edited record,
                        // (_incrementalRegroup) - otherwise just update it in situ.
                        var fieldNames = this.getDataSource().getFieldNames();
                        fieldNames.addList(this.getCacheableFields().getProperty("name"));

                        var node = nodes[0];
                        for (var i = 0; i < groupByFields.length; i++) {
                            var undef, fieldName = groupByFields[i];
                            if (originalRecord[fieldName] === undef) continue;

                            var field = this.getUnderlyingField(fieldName),
                                newValue = this._getGroupValue(updatedRecord[fieldName],
                                                               updatedRecord, field, fieldName),
                                oldValue = this._getGroupValue(originalRecord[fieldName],
                                                               originalRecord, field, fieldName);
                            if (newValue != oldValue) {
                                this._remapEditRows();
                                
                                this._incrementalRegroup(updatedRecord, node, updateData);
                                updatedGroupSummaries = true;
                                this._ignoreRegroup = true;
                                break;
                            }
                        }

                        // apply all modified fields to the node.
                        
                        if (node != updatedRecord) {
                            for (var i = 0; i < fieldNames.length; i++) {
                                node[fieldNames[i]] = updatedRecord[fieldNames[i]];
                            }
                            node["_cache_" + this.ID] = updatedRecord["_cache_" + this.ID];
                        }
                        // refresh the group(s) that contain the updated record
                        if (!updatedGroupSummaries) {
                            updatedGroupSummaries = true;
                            this.refreshGroupSummary(node);
                        }
                        
                        // Refresh the sort on the groupTree if we have one.
                        // This ensures a change to the sort field will cause the
                        // record to jump into its new position.
                        var currentSort = this.data.getSort();
                        if (currentSort != null) {
                            this.data.setSort(currentSort);
                        }
                    }
                }
            }
        }
        if (markForRegroup) {
            this._setMarkForRegroup(true, false, false, false, true, groupByFields);
        }
    }
    // if a change was made to a value of a sort field, the result set should update a partial
    // cache, and the result set has a partial cache (allMatchingRowsCached() is false), then
    // unsort the grid. This is done because when a result set has updatePartialCache:true and
    // a partial cache, "updated rows will remain in their current position.  No attempt will
    // be made to sort them into a new position even if the sort field was updated."
    var sortSpecifiers = this._sortSpecifiers;
    if (sortSpecifiers != null && sortSpecifiers.length > 0) {
        var origData = this.getOriginalData();
        if (isc.isA.ResultSet(origData) &&
            ((origData.shouldUpdatePartialCache() && !origData.allMatchingRowsCached()) ||
             !origData.canSortOnClient()) &&
            (type == "replace" || type == "update"))
        {
            var unsort = false;
            if (originalRecord == null || rowNum == null) {
                unsort = true;
            } else {
                var updatedRecord = this._getDataChangedRecord(originalRecord, rowNum, type);
                if (updatedRecord == null) unsort = true;
                else {
                    for (var i = 0, numSortSpecifiers = sortSpecifiers.length; i < numSortSpecifiers; ++i) {
                        var sortSpecifier = sortSpecifiers[i],
                            property = sortSpecifier.property,
                            undef;
                        
                        if (originalRecord[property] !== undef &&
                            !this.fieldValuesAreEqual(property,
                                                      originalRecord[property],
                                                      updatedRecord[property]))
                        {
                            unsort = true;
                        }
                    }
                }
            }

            if (unsort) this.unsort();
        } else {
            if (this.filterLocalData && !this.data._resorting && this.data.resort) this.data.resort();
        }
    }

    if (this.filterLocalData && !this._filteringLocalDataFromDataChanged) {
        var baseData = this.getOriginalData();
        if (baseData.filterLocalData) {
            this._filteringLocalDataFromDataChanged = true;
            baseData.filterLocalData();
            delete this._filteringLocalDataFromDataChanged;
        }
    }

    
    if (this._markForRegroup && (!this.isGrouped || !this._savingEdits) &&
        // Skip attempting to regroup / reset selection if our resultSet is in mid-fetch
        (!isc.isA.ResultSet(this.data) || this.data.lengthIsKnown()))
    {
        this._lastStoredSelectedState = this.getSelectedState(true);
        this.regroup();
    
    } else if (this._asyncRegroupInProgress) {
        var baton = this._asyncRegroupBaton,
            fields;
        if (baton) {
            fields = baton.gropuByFields || baton.groupByField;
        } else {
            fields = this.groupByFields || this._groupByFields;
        }
        
        this.logInfo("dataChanged() occurred while asynchronous regrouping in progress. " +
                     "Restarting grouping with fields:" + fields, "grouping");
        // no need to clear the timer for the asynch-regroup that's currently in progress - that's
        // already handled by 'groupBy'
        this.groupBy(fields);
    }

    //>Animation
    // Call finishRowAnimation - will kill any show/hide row animations.
    // These animations assume the data remains constant for the duration
    // of the animation.
    // (No-ops if appropriate)
    if (this.body) this.body.finishRowAnimation();
    //<Animation

    // Call _remapEditRows() to ensure that editValues are associated with the (possibly
    // modified) rowNumbers using pointers between record primary key and edit values
    
    if (!this._savingEdits) {
        if (!this.suppressEditRowRemap) this._remapEditRows();
        // If we're actually showing the editor and the current edit-row has changed
        // roll the new values into the edit form for any unedited fields
        if (this._editorShowing) {
            var editForm = this.getEditForm(),
                editRowNum = this.getEditRow(),
                record = this.getRecord(editRowNum),
                showInEditor = {};
            
            // Clean off any tree metadata, etc
            if (isc.isA.Tree(this.data)) {
                record = this.data.getCleanNodeData(record, false);
            }            

            if (editForm && record != null) {
                for (var fieldName in record) {
                    // If we have an edit value, don't allow the new
                    // record value to override it
                    if (this._getEditValue(editRowNum, fieldName, true) != null) continue;
                    // If we have a live edit item, and it has a modified value
                    // (IE the user has changed it, or app code has called setValue()
                    // diretly on the form), skip that too.
                    
                    var item = editForm.getItem(fieldName),
                        currentVal = item ? item.getValue() : null;
                    if (item && 
                        !item.compareValues(currentVal, record[fieldName]) &&
                        !item.compareValues(item._getOldValue(), currentVal)) 
                    {
                        continue;
                    }

                    showInEditor[fieldName] = record[fieldName];
                }
                // no need to call 'setEditValue()' - displaynewEditValues already
                // handles picking up the display value from the record value.
                
                this._displayNewEditValues(editRowNum, this.getEditCol(), showInEditor);
                var oldVals = editForm._oldValues;
                // We didn't use 'setValues()' but we need to remember these
                // particular field values so if this method runs again we don't
                // treat these values as user-edited.
                // use DBC._duplicateValues to ensure we duplicate dates, objects, handle 
                // GWT objects, etc (we used to use clone(), but it fails in the presence
                // of pointer loops, which can happen with the records in grouped lists)
                var dup = {};
                isc.DynamicForm._duplicateValues(editForm, showInEditor, dup);
                for (var fieldName in showInEditor) {
                    oldVals[fieldName] = dup[fieldName];
                }
                
            }
        }
    }

    // re-associate embeddedComponents with records which were not previously present in the
    // cache but are now - set grid._shouldRetainEmbeddedComponents to false to have components
    // removed when their associated records are no longer in the cache.
    if (!isc.isA.ResultSet(this.data) || this.data.lengthIsKnown()) {
        this._remapEmbeddedComponents();
    }

    // if this.alwaysShowEditors is set, and we have data, and we're not currently showing
    // editors, show them now.
    // This handles us getting new data (from a fetch for example)
    if (this._alwaysShowEditors() && !this._editorShowing) {
        this.startEditing(null,null,true,null,true);
    }

    
    var lastRow = this.getTotalRows()-1;
    if (this.body) {
        if (this.body.lastOverRow > lastRow) delete this.body.lastOverRow;
        if (this.body.lastMouseOverRow > lastRow) delete this.body.lastMouseOverRow;
        if (this.body._lastHiliteRow > lastRow) delete this.body._lastHiliteRow;
    }
    if (this._lastRecordClicked > lastRow) delete this._lastRecordClicked;

    
    var changedRecords = null;
    if (type != "update" && type != "remove") {
        changedRecords = this._getDataChangedRecord(originalRecord, rowNum, type);
    }

    if (updatedGroupSummaries) {
        
        if (this.summaryRow && this.showGridSummary) this.summaryRow._recalculateSummaries();
    } else {
        this.calculateRecordSummaries(changedRecords, null, null, true, true, type == "remove",
                                      type != null && type != "update");
    }

    if (this.hilites) this.applyHilites();

    
    if (!this._suppressRedrawOnDataChanged) {
        // recalculate autoFitWidth field widths to fit the new data
        if (resetAutoFitWidths) this.updateFieldWidthsForAutoFitValue(this._$dataChanged);

        this.redrawForDataChanged();
    }

    // Note - a regroup may require a re-selection of the prior-to-regroup selection
    // range.
    // We rely on code in the _regroupFinish flow to handle resetting selection

    // clear the _handlingDataChanged flag
    delete this._handlingDataChanged;

    this.updateBodyCanFocusForData();
    
},


_setMarkForRegroup : function (
        markForRegroup,
        calledFromGroupBy, calledFromRegroup, calledFromClearGroupBy, calledFromDataChanged,
        fields, groupByFields)
{
    
    var markForRegroup0 = this._markForRegroup;
    if (calledFromGroupBy) {
        
        this._groupByCompleteFieldsBeforeRegroup = fields;
        this._isGrouped = true;
        this._groupByFields = groupByFields;
    } else if (calledFromRegroup) {
        if (markForRegroup0 && !markForRegroup) {
            
            this._groupByCompleteFieldsAfterRegroup = this._groupByCompleteFieldsBeforeRegroup;
            delete this._groupByCompleteFieldsBeforeRegroup;
            delete this._isGrouped;
            delete this._groupByFields;
        }
    } else if (calledFromClearGroupBy) {
        

        // clean up temporary grouping state
        
        delete this._isGrouped;
        delete this._groupByFields;

        delete this._groupByCompleteFieldsBeforeRegroup;
        delete this._groupByCompleteFieldsAfterRegroup;
    }
    

    
    this._markForRegroup = markForRegroup;
},

redrawForDataChanged : function () {
    if (this.frozenBody) this.frozenBody._suppressRecordComponentsUpdate = true;
    this._markBodyForRedraw(this._$dataChanged);
},
    

// Ensure that when body redraw runs, we do a full field-widths refresh, including
// calculating auto-fit size
_forceUpdateFieldWidths : function (reason) {
    if (this.body && this.fields) {
        this.body._fieldWidthsDirty = reason == null ? true : reason;
        // Ensure we actually calculate new field widths based on data values.
        delete this.fields._appliedInitialAutoFitWidth;
    }

},

// wrap the call out to the dataArrived override point and handle sorter according to
// canSortClientOnly value and current data-state
_dataArrived : function (startRow, endRow) {
    
    var sortField = this._getSortFieldNum();
    
    
    if (this._updateFieldWidthsOnDataArrived || startRow == 0) {
        this._updateFieldWidthsOnDataArrived = false;
        this._forceUpdateFieldWidths("New dataset loaded");
    }
    if (sortField != null && sortField != -1) {
        var fieldNum = this.getFieldNum(sortField),
            field = this.getField(fieldNum)
        ;

        if (field && field.canSortClientOnly && !this._canSortData(field)) {
            this._setSortFieldNum(null);

            // tell that toolbar button to unselect / get rid of sort arrow
            if (sortField != null && this.header && isc.isA.Toolbar(this.header)) {
                this.header.deselectButton(sortField);
                var button = this.header.getButton(sortField);
                if (button) button.setTitle(this.getHeaderButtonTitle(button));
            }

            // Get rid of the sort arrow in the sorter
            if (this.sorter && this.sorter.setTitle) this.sorter.setTitle(this.sorter.getTitle());
        }
    }

    if (!(this.canSelectAll == false) && this.getCurrentCheckboxField()) {
        var cbPos = this.getCheckboxFieldPosition(),
            field = this.getField(cbPos);
        // if we are showing a checkbox select-all header, and we don't have
        // a full cache, disable the checkbox header and show a hover prompt
        if (isc.ResultSet && isc.isA.ResultSet(this.data)
            && !this.data.allMatchingRowsCached())
        {
            var props = {
                disabled: true,
                showHover: true,
                prompt: this.selection.selectionRangeNotLoadedMessage,
                title: (this.selectionType == "single") ? isc.nbsp :
                        this._getCheckboxValueIconHTML(false, false, true, true, field)
            }
        // if we now have a full cache, enable the checkbox selectAll header
        } else {
            var props = {
                disabled: false,
                showHover: false,
                prompt: null,
                title: (this.selectionType == "single") ? isc.nbsp :
                        this._getCheckboxValueIconHTML(false, false, true, false, field)
            }
        }
        this.setFieldProperties(cbPos, props);
    }

    
    if (isc.screenReader && this.body != null) {
        if (isc.isA.Tree(this.data)) {
            // in this case we're passed a single param, the parent node.
            var node = startRow;
            if (this.data.isOpen(node) && this.data.hasChildren(node)) {
                var children = this.data.getChildren(node);
                if (children && !children.isEmpty()) node = children.first();
            }
            var rowNum = this.data.indexOf(node);
            // If we don't currently have focus, just remember the native focus row - this means
            // if we're showing a modal prompt / redrawing we should refocus on the right native
            // element...
            this.body._putNativeFocusInRow(rowNum, !this.hasFocus);
        }
    }

    // we only want to run auto-sizing code if the data has already arrived
    if (this._autoSizeOnDataArrived) {
        this._headerDoubleClick(this._autoSizeHeaderFieldNum, this._autoSizeHeader);
        this._autoSizeHeaderFieldNum = null;
        this._autoSizeHeader = null;
        this._autoSizeOnDataArrived = false;
    }

    this._markBodyForRedraw();

    this._fromDataArrived = true;
    this.dataArrived(startRow, endRow);
    delete this._fromDataArrived;
    
    this.updateBodyCanFocusForData();
    
},
    
updateBodyCanFocusForData : function () {
    if (this.body && !this.canFocusInEmptyGrid) {
        var isEmpty = this.isEmpty();
        if (isEmpty != this._wasEmptyForCanFocus) {
            this.body._updateCanFocus();
            if (this.frozenBody != null) this.frozenBody._updateCanFocus();
            this._wasEmptyForCanFocus = isEmpty;
        }
    }
},


// doc'd in registerStringMethods block
dataArrived : function (startRow, endRow) {},

//> @method listGrid._ignoreData() (A)
//      stop observing methods on data when it goes out of scope
//      called automatically by setData
//  @param  data    (object)        old data to be ignored
//<
_ignoreData : function (data, destroying) {
    //>Animation
    // Call finishRowAnimation - will kill any show/hide row animations
    // These animations assume the data remains constant for the duration
    // of the animation.
    // (No-ops if appropriate)
    if (this.body) this.body.finishRowAnimation();
    //<Animation

    if (isc.isA.Tree(this.data)) this.ignore(data, "changeDataVisibility");

    this.ignore(data, "dataChanged");

    if (this.isObserving(data, "dataArrived")) {
        this.ignore(data, "dataArrived");
    }


    // If we're destroying, no need to call deslectAll, as we'll continue to
    // destroySelectionModel() anyway, and calling deselectAll can cause
    // selectionChanged notifications to fire which is likely to lead to 
    // application level crashes since the grid is in an invalid state
    if (!destroying && this.selection) this.selection.deselectAll();
    // NOTE: we don't ignore this.selection.setSelected because
    //          we're re-using the same selection object
    
},

//> @method listGrid.applyFieldDefaults()
//      @group  data
//         Derive default field sizes and formatters where possible, based on schema information.
//<
_generatedFieldNameCount:0,
applyFieldDefaults : function (fields) {
    if (fields == null) return;
    
    var thisID = this.getID();

    // apply ListGrid-specific defaults, like using toShortDate() for Date fields
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];

        if (field == null) continue;
        
        
        if (field._componentID == null) field._componentID = thisID;

        // In general we can support un-named fields in dataBoundComponents if there is a dataPath
        if (!this.allowNamelessFields && field[this.fieldIdProperty] == null) {
            if (field.dataPath == null) {
                this.logWarn("unable to process field with no name / dataPath:" +
                             this.echo(field));
                continue;
            }
            // apply an arbitrary name - this gives us a straightforward way to map the
            // field object any generated editor item, etc.
            
            field[this.fieldIdProperty] = "field" + this._generatedFieldNameCount++;
        }
        // default the alignment of each field to left if not specified
        // In RTL mode default to right alignment (so text flows from start of value
        // outward as you'd expect). This means setting the property to "left" if
        // reverseRTLAlign is set, otherwise to "right".
        var defaultAlign = (this.isRTL() && !this.reverseRTLAlign) ? isc.Canvas.RIGHT
                                                                   : isc.Canvas.LEFT;

        // "type" is used for align and default formatting. If we have a display field
        // we're pulling display-values from, use the type specified there rather than
        // on the underlying data values the display values represent.
        var type = this.getFieldDisplayType(field);
        var baseType = (type != null ? isc.SimpleType.getBaseType(type) : null);
        

        // note: needs to be first, as "image" type technically inherits from text
        if (isc.SimpleType.inheritsFrom(type, "image")) {
            field._typeFormatter = this._formatImageCellValue;

        // Attempt to size columns to fit their content
        } else if (baseType == this._$text) {

            if (field.width == null && field.length != null) {
                if (field.length < 15 && !field.valueMap) {
                    // use minimal space for small text fields with no value map
                    field.width = field.length * 7;
                }
            }

        } else if (baseType == "integer" || baseType == "float") {
            // align numbers right by default to line up decimal places
            // Exception: If there's a valueMap attached we don't want to right-align
            // (Example - mapping error codes to display strings).
            
            var hasObjValueMap = field.valueMap != null && !isc.isAn.Array(field.valueMap),
                reverseAlign = (this.isRTL() && !this.reverseRTLAlign);
            defaultAlign = hasObjValueMap ?
                            (reverseAlign ? isc.Canvas.RIGHT : isc.Canvas.LEFT) :
                            (reverseAlign ? isc.Canvas.LEFT : isc.Canvas.RIGHT);
            field._typeFormatter = this._formatNumberCellValue;

        // by default size date columns fields to match the default shortDate format applied
        // to date fields
        
        } else if (baseType == "date") {
            var canEdit = (this.canEdit == true && field.canEdit != false) ||
                          (this.canEdit != false && field.canEdit == true);
            // If the field has unspecified size, size to accommodate formatted date
            // (or editor if the field is editable)
            field.width = field.width || (canEdit ? 100 : 80);
            // right alignment lines up years if day/month values are numeric and not padded
            defaultAlign = (this.isRTL() && !this.reverseRTLAlign)  ? isc.Canvas.LEFT
                                                                    : isc.Canvas.RIGHT;
            field._typeFormatter = this._formatDateCellValue;

        // by default size time columns fields to match the default format applied to time
        // fields
        } else if (baseType == "time") {
            field.width = field.width || 80;
            field._typeFormatter = this._formatTimeCellValue;
            defaultAlign = (this.isRTL() && !this.reverseRTLAlign)  ? isc.Canvas.LEFT
                                                                    : isc.Canvas.RIGHT;

        } else if (type == "binary" || type == "blob" || type == "upload" || type == "imageFile") {
            field._typeFormatter = this._formatBinaryCellValue;
        } else if (type == "link") {
            field._typeFormatter = this._formatLinkCellValue;
        } else if (type == "icon") {
            if (field.width == null && field.autoFitWidth == null) {
                if (this.autoFitIconFields != "none") {
                    field.autoFitWidth = true;
                    field.autoFitWidthApproach =
                        (this.autoFitIconFields == "title") ? "both" : "value";
                }
            }

            // check autoFitIconFields -- if set, set min width to accommodate the
            // icons and set autoFitWidth:true / autoFitWidthApproach such that
            // it'll expand to accommodate the title if appropriate
            if (field.width == null && field.autoFitWidth == null) {
                if (this.autoFitIconFields != "none") {
                    field.autoFitWidth = true;
                    field.autoFitWidthApproach =
                        (this.autoFitIconFields == "title") ? "both" : "value";
                    // set the default width (min width) to the
                    // calculated default width
                    
                    field.width = this.getDefaultFieldWidth(field);
                }
            }
            field.align = field.align || "center";

            // install a formatter that will put button.icon into the cell
            field._typeFormatter = this._formatIconCellValue;

            // default title so that icon appears alone (otherwise would default to field name
            // if title was unset)
            field.title = field.title || isc.nbsp;

        // turn on 'canToggle' for all boolean fields.
        // If 'canEdit' is also set to true these fields will be editable via a single
        // click
        } else if (type == "boolean" || type== "checkbox") {
            if (field.canToggle == null) field.canToggle = true;
        }

        // For boolean fields we show checkbox images by default
        // this is handled via the valueIcon system - see getValueIcon(), getValueIconWidth() and
        // showValueIconOnly()
        

        // If formatCellValue was passed to us as a string, convert it to a method
        if (field.formatCellValue != null && !isc.isA.Function(field.formatCellValue))
            isc.Func.replaceWithMethod(field, "formatCellValue", "value,record,rowNum,colNum,grid");

        if (this.showValueIconOnly(field)) {
            defaultAlign = isc.Canvas.CENTER;

            
            field.iconSpacing = 0;

            // apply the "icon" field logic to fields that show valueIcons -
            // respect autoFitIconFields here too
            if (field.width == null && field.autoFitWidth == null) {
                if (this.autoFitIconFields != "none") {
                    field.autoFitWidth = true;
                    field.autoFitWidthApproach =
                        (this.autoFitIconFields == "title") ? "both" : "value";
                    // set the default width (min width) to the
                    // calculated default width
                    field.width = this.getDefaultFieldWidth(field);
                }
            }
        } else if (field.icon != null && field.showTitle == false) {
            
            field.iconSpacing = 0;
        }
        
        // TODO: numeric quantities with range validators could be given specific sizes
        if (!field.align) field.align = defaultAlign;

        // For fields marked as multiple:true, set the "validateEachItem" flag.
        // This ensures that when validators run in an editable grid we will
        // validate each selected value
        if (field.multiple && field.validateEachItem == null) field.validateEachItem = true;

        // If field is marked as initially hidden, use showIf:"false"
        if (field.hidden) field.showIf = "false";
    }
},

// If this field has a specified display field, pick up the underlying display field object
// (from the optionDataSource if appropriate, otherwise from the grid itself, or the
// underlying DS the grid is bound to).
getDisplayField : function (field) {
    var displayField = field.displayField;
    if (displayField != null) {
        var ods = field.optionDataSource ? isc.DataSource.get(field.optionDataSource) : null;
        if (ods != null) displayField = ods.getField(displayField);
        else {
            displayField = this.getField(displayField);
            if (displayField == null && this.dataSource != null) {
                displayField = this.getDataSource().getField(field.displayField);
            }
        }
    }
    return displayField;
},

// Returns the specified type of the field's displayField, if there is one, otherwise of the
// field itself.
getFieldDisplayType : function (field) {
    var displayField = this.getDisplayField(field),
        type;
    if (displayField != null) type = displayField.type;
    if (type == null) type = field.type;
    return type;
},

// Helper method called on boolean fields to determine whether we should use the
// booleanTrueImage/booleanFalseImage and related settings, or fall back to the general
// valueIcons system, which may show a combination of text and icons
_$boolean:"boolean",
_formatBooleanFieldAsImages : function (field) {
    // If booleanTrue/FalseImage have been set null, always back off to showing text / valueIcons
    if (this.booleanTrueImage == null && this.booleanFalseImage == null) return false;

    var type = this.getFieldDisplayType(field),
        baseType = (type != null ? isc.SimpleType.getBaseType(type) : null);
    if (baseType != this._$boolean) return false;

    // read as: user has not tried to set valueIcon-specific flags.
    // Also note: it's commonly necessary to set a valueMap with a boolean field in order to
    // allow stored values like YES/NO/null to be mapped to boolean true/false, so a valueMap
    // doesn't indicate an intent to use valueIcons.  If you have a valueMap and there are more
    // values than true/false/unset, you shouldn't declare the field boolean, it should be
    // enum.
    return (!field.suppressValueIcon && field.showValueIconOnly == null &&
             field.valueIcons == null && field.formatCellValue == null);
},


//> @method listGrid.setFieldProperties()
// Dynamically set properties for a particular field. This method will update the fields
// header-button without having to explicitly reset the fields in the grid.  <smartgwt>
// The passed-in +link{ListGridField} should contain just the minimal properties you want to
// change; do not take the original ListGridField, modify it, and just pass that to this
// function.</smartgwt>
// <P> 
// NOTE: Where explicit setters exist for field properties (such as
// +link{resizeField()}, +link{setFieldTitle()}, +link{setFieldIcon()}, etc.) these should be
// used instead.
//
// @param   fieldNum (number | String) name of the field, or index.
// @param   properties (ListGridField Properties) properties to apply to the header
// @visibility external
//<
// NOTE: little testing has been done on which properties can actually be set this way
setFieldProperties : function (fieldNum, properties) {
    var field, allFields = this.getAllFields();
    var origField = fieldNum;
    if (isc.isA.Number(fieldNum)) {
        // if an index was passed, use the visible fields
        field = this.getField(fieldNum);
    } else {
        // if a key was passed, use the complete fields to handle hidden columns
        var globalFieldNum = isc.Class.getArrayItemIndex(
                                fieldNum, allFields, this.fieldIdProperty);
        field = allFields[globalFieldNum];
        // map back to the fieldNum within this.fields (not within this.completeFields)
        fieldNum = this.getFieldNum(field);
    }
    if (!field) return;
    isc.addProperties(field, properties);

    if (this.header != null && this.header.isDrawn()) {
        // getFieldHeader / getLocalFieldNum will account for frozen fields
        var header = this.getFieldHeader(fieldNum),
            headerButton = header.getMember(this.getLocalFieldNum(fieldNum));
        if (headerButton) headerButton.setProperties(properties);
    }
},

//> @method listGrid.setFieldTitle()
// Change the title of a field after the grid is created.
//
// @param fieldNum (int | String) name of the field, or index.
// @param title (String) new title
// @visibility external
//<
setFieldTitle : function (fieldNum, title) {
    this.setFieldProperties(fieldNum, {title:title});
},

//> @method listGrid.setFieldHeaderBaseStyle()
// Update the +link{listGridField.headerBaseStyle} for a field within the grid at runtime.
// @param name (String) name of the field.
// @param newStyle (CSSClass) new baseStyle for the field header
// @visibility external
//<
setFieldHeaderBaseStyle : function (name, baseStyle) {
    var field = this.getField(name);
    if (field == null) {
        this.logWarn("setFieldHeaderBaseStyle() unable to find field:" + name);
        return;
    }
    field.headerBaseStyle = baseStyle;
    var button = this.getFieldHeaderButton(this.getFieldNum(field));
    if (button != null) {

        // Treat being passed null as an attempt to revert to default base style.
        if (baseStyle == null) {
            var buttonProperties = this.getHeaderButtonProperties();
            if (field.frozen && buttonProperties.frozenBaseStyle) {
                baseStyle = buttonProperties.frozenBaseStyle;
            } else if (buttonProperties.baseStyle) {
                baseStyle = buttonProperties.baseStyle;
            }
        }
        if (baseStyle == null) {
            baseStyle = button.getClass().getPrototype().baseStyle;
        }
        button.setBaseStyle(baseStyle);
    }
},

//> @method listGrid.setFieldHeaderTitleStyle()
// Update the +link{listGridField.headerTitleStyle} for a field within the grid at runtime.
// @param name (String) name of the field.
// @param newStyle (CSSClass) new titleTyle for the field header
// @visibility external
//<
setFieldHeaderTitleStyle : function (name, titleStyle) {
    var field = this.getField(name);
    if (field == null) {
        this.logWarn("setFieldHeaderTitleStyle() unable to find field:" + name);
        return;
    }
    field.headerTitleStyle = titleStyle;
    var button = this.getFieldHeaderButton(this.getFieldNum(field));
    if (button != null) {
        if (titleStyle == null) {

            var buttonProperties = this.getHeaderButtonProperties();
            if (field.frozen && buttonProperties.frozenTitleStyle) {
                titleStyle = buttonProperties.frozenTitleStyle;
            } else if (buttonProperties.titleStyle) {
                titleStyle = buttonProperties.titleStyle;
            }
        }
        if (titleStyle == null) {
            titleStyle = button.getClass().getPrototype().titleStyle;
        }
        button.setTitleStyle(titleStyle);
    }
},

//> @method listGrid.setFieldIcon()
// Change the +link{listGridField.icon} for a field after the grid is created
// @param fieldName (String) field to update
// @param icon (SCImgURL) icon for the field
// @visibility external
//<
setFieldIcon : function (fieldName, icon) {
    var field = this.getField(fieldName);
    this.setFieldProperties(fieldName, {icon:icon});
    if (field && field.type == "icon" && field.cellIcon == null) {
        delete field._iconHTML
        this.body.markForRedraw("Field icon changed");
    }
},

//> @method listGrid.setFieldCellIcon()
// Change the +link{listGridField.cellIcon} for a field after the grid is created
// @param fieldName (String) field to update
// @param cellIcon (SCImgURL) new cellIcon for the field
// @visibility external
//<
setFieldCellIcon : function (fieldName, icon) {
    this.setFieldProperties(fieldName, {cellIcon:icon});
    var field = this.getField(fieldName);
    if (field && field.type == "icon") {
        delete field._iconHTML
        this.body.markForRedraw("Field cell icon changed");
    }
},


// AutoComplete
// --------------------------------------------------------------------------------------------

//> @method listGrid.setAutoComplete()
// Change the autoCompletion mode for the grid as a whole.
//
// @param   newSetting (AutoComplete)  new setting
// @group autoComplete
// @visibility autoComplete
//<

setAutoComplete : function (newSetting) {
    this.autoComplete = newSetting;
},

//> @method listGrid.setFieldAutoComplete()
// Change the autoCompletion mode for an individual field.
//
// @param   newSetting (AutoComplete)  new setting
// @group autoComplete
// @visibility autoComplete
//<

setFieldAutoComplete : function (field, newSetting) {
    field = this.getField(field);
    if (field) field.autoComplete = newSetting;
},

// --------------------------------------------------------------------------------------------

//> @method listGrid.showFields()
// Force an array of fields to be shown. This method does not add new fields to the grid,
// it simply changes field visibility. If a field.showIf expression exists, it will be
// destroyed.
// <P>
// Note: for showing multiple fields it is more efficient to call this method than to call
// +link{showField()} repeatedly.
//
// @param   field           (Array of String | Array of ListGridField)  Fields to show.
// @param   [suppressRelayout] (boolean) If passed, don't resize non-explicitly sized columns
//                                       to fill the available space.
// @visibility external
// @example columnOrder
//<
// Actually this is a synonym for showField() - separated for ease of documentation
showFields : function (fields, suppressRelayout) {
    return this.showField(fields,suppressRelayout);
},

//> @method listGrid.showField()
// Force a field to be shown. This method does not add new fields to the grid,
// it simply changes field visibility. If a field.showIf expression exists, it will be
// destroyed.
// <P>
// Note: for showing multiple fields it is more efficient to call +link{showFields()} than
// to call this method repeatedly.
//
// @param field (String | ListGridField) field to show
// @param [suppressRelayout] (boolean) If passed, don't resize non-explicitly sized columns
//                                       to fill the available space.
// @visibility external
// @example columnOrder
//<
showField : function (fields, suppressRelayout) {

    arguments.__this = this;

    // if setFields() hasn't been run, run it now, then call ourselves again
    if (this.completeFields == null) {
        this.setFields(this.completeFields || this.fields);
        return this.showField(fields, suppressRelayout);
    }

    if (!isc.isAn.Array(fields)) {
        fields = [fields];
    }

    var noFields = true,
        allVisible = true;

    var mustSetFields = this.frozenFields || this._suppressedFrozenFields;

    for (var i = 0; i < fields.length; i++) {

        var field = fields[i],
            fieldObj = field;

        // Use getSpecifiedField() to retrieve the fieldObject from the fields / completeFields
        // array.
        // Note that this returns null for an invalid field object / ID
        fieldObj = this.getSpecifiedField(fieldObj);

        if (fieldObj == null) {
            fields[i] = null;
            this.logWarn("showField(): unable to find field object for field: " + field
                         + ". Taking no action. Call setFields() to add new fields.")
            continue;
        }

        noFields = false;

        // Update initialization property to match new field state
        fieldObj.hidden = false;

        // -- We always want to clear out any showIf property on the field, as even if the field is
        //    currently being shown, we want the field to continue to be shown from this point on
        //    regardless of any conditions in a showIf property
        
        if (fieldObj.detail) {
            fieldObj.showIf = "true";
        } else {
            if (fieldObj.showIf != null) fieldObj.showIf = null;
        }

        // need to call setFields if the field is frozen or if it was already visible at a 
        // different masterIndex
        if (fieldObj.frozen || fieldObj.masterIndex != null && fieldObj.masterIndex != i) {
            mustSetFields = true;
        }

        // if this field is in a headerSpan, we need to call setFields() to rebuild it
        if (this.spanMap && this.spanMap[fieldObj.name] != null) mustSetFields = true;

        if (mustSetFields) continue;

        // If this.fields contains the object, we can assume it's already visible if we're drawn
        // and will show up when we get drawn otherwise.
        if (this.fields.contains(fieldObj)) {
            fields[i] = null;
            continue;
        }

        // At this point we know we have at least one field that needs to be added
        // to the fields array (was previously hidden)
        allVisible = false;
        // hang onto the "live" fieldObj in the array
        fields[i] = fieldObj;
    }

    if (mustSetFields) {
        // Frozen fields: with frozen fields, the partial rebuild attempted below doesn't work.
        // This hasn't been looked into in detail yet.
        this.setFields(this.completeFields || this.fields);
        if (this.selectHeaderOnSort && this._sortSpecifiers) this.selectSortFieldHeaderButton();
        this.handleFieldStateChanged();
        return;
    }

    if (noFields || allVisible) return;

    // update this.fields
    this.deriveVisibleFields();

    // Empty slots may be present due to already visible fields
    fields.removeEmpty();

    var shownFieldNums = [],
        foundFields = 0;

    // Determine the position of the newly shown fields in our fields array.
    for (var i = 0; i < this.fields.length; i++) {
        var index = fields.indexOf(this.fields[i]);
        if (index != -1) {
            shownFieldNums[index] = i;

            foundFields++;
            // stop when we've figured out the position of all fields passed in.
            if (foundFields == fields.length) break;
        }
    }

    var header = this.header;
    // Update any UI to display the new field, if necessary
    

    // create the header button for the new column
    if (header != null) {
        if (!suppressRelayout) this.header.hPolicy = "fill";
        // undocumented feature - addButtons handles being passed an array of field indices
        // as well as an array of buttons
        
        this._suppressAutoFitToTitle = true;
        this.header.addButtons(fields.duplicate(), shownFieldNums);
        delete this._suppressAutoFitToTitle;
    }

    // tell the body about the new field
    if (this.body) {

        // If we're showing an editor in the new field we need to
        // - create the form items for it and slot it into the edit form
        // - shift the colNum on other items, and the _editColNum of the grid as a whole.
        if (this._editorShowing) {

            var editRowNum = this.getEditRow(),
                record = this.getRecord(editRowNum),

                
                editedRecord = this.getEditedRecord(editRowNum),

                adjustedEditColNum = false,
                items = this.getEditForm().items,
                liveItemIndex = items.length-1,
                liveItem = items[liveItemIndex],
                itemColNum = liveItem.colNum;

            // sort the shownFieldNums
            // this allows us to update the live edit item colNum values easily.
            // Note that it means the shownFieldNums will no longer match up to the fields
            // entries in the shown fields array.
            shownFieldNums.sort();

            for (var i = shownFieldNums.length-1; i >= 0; i--) {
                var offset = i+1,
                    fieldNum = shownFieldNums[i],
                    threshold = (fieldNum - i);

                if (!adjustedEditColNum && this._editColNum >= fieldNum) {
                    this._editColNum += offset;
                }

                // Update the edit form
                var fieldObj = this.fields[fieldNum],
                    width = this.getEditFormItemFieldWidths(record)[fieldNum],
                    item;

                while (liveItem != null && itemColNum >= threshold) {
                    liveItem.colNum += offset;

                    liveItemIndex --;
                    liveItem = (liveItemIndex >= 0) ? items[liveItemIndex] : null;
                    itemColNum = (liveItem != null) ? liveItem.colNum : null;
                }

                // at this point we've updated any items with a colNum >= ours
                // Create an item for the newly shown field and slot it into the edit form
                //
                // liveItemIndex will now be set to the slot before the one we're interested in
                // (index of the item that previously matched our colNum, minus 1)
                //
                // Note if we're editing by cell this won't apply since if we're showing an editor
                // the field its showing on must already be visible.
                var drawnRange = this.body.getDrawArea();
                if (!this.editByCell && fieldNum >= drawnRange[2] && fieldNum <= drawnRange[3]) {
                    item = this.getEditItem(fieldObj, record, editedRecord, editRowNum, fieldNum, width);
                }
                if (item != null) {
                    this._editRowForm.addItems([item], liveItemIndex+1);
                }
            }
        }

        this.body.fields = this.normalFields || this.fields;
        this.setBodyFieldWidths(this.getFieldWidths());

        this._remapEmbeddedComponentColumns(this.body);

        // instant redraw rather than markForRedraw because we have to avoid dropping
        // values
        if (this.body.isDrawn()) this.body.redraw("show field");
    }

    // If we're auto-fitting vertically, allow the header to shrink or grow vertically
    // as appropriate
    
    if (this.header && this.autoFitHeaderHeights) {
        this.dropCachedHeaderButtonHeights();
        this._updateHeaderHeight();
    }


    // reset the sortFieldNum - we may have added or repositioned the primary sort field
    if (this.sortField != null) {
        this.sortFieldNum = null;
        this.sortFieldNum = this._getSortFieldNum();
        if (this.selectHeaderOnSort) this.selectSortFieldHeaderButton();
    }

    // If we have a filterEditor showing, update its fields too
    if (this.filterEditor != null) this.filterEditor.showField(fields, suppressRelayout);

    // update recordSummaries as well as grid/group ones
    this.recalculateSummaries(null, fields);
    if (this.summaryRow != null && this.showGridSummary) {
        this.summaryRow.showField(fields, suppressRelayout);
    }

    // reapply hilites - we don't store hilite information on hidden fields so if
    // hidden fields are displayed we'll need to reapply.
    if (this.hilites) this.applyHilites()

    this.markForRedraw("showField");

    this.handleFieldStateChanged();
    this._clearFieldDependencyTable();
    
},

selectSortFieldHeaderButton : function () {
    // reselect the sortField
    var sort = this.getSort();
    if (sort && sort.length > 0) {
        var fieldNum = this.getFieldNum(sort[0].property);
        if (fieldNum>=0) {
            // select the appropriate button
            var sortHeader = this.getFieldHeader(fieldNum),
                sortButton = this.getFieldHeaderButton(fieldNum)
            ;

            if (sortButton) {
                sortHeader.selectButton(sortButton);
                if (isc.Browser.isTouch && this.shouldShowHeaderMenuButton(sortButton, true)) {
                    this._showHeaderMenuButton(sortButton);
                }
            }
        }
    }
},

//> @method listGrid.hideFields()
// Force an array of fields to be hidden.
// <P>
// NOTE: If a field.showIf expression exists, it will be destroyed.
// <P>
// When hiding multiple fields, this method should be called rather than
// calling +link{listGrid.hideField()} repeatedly for each field to hide.
//
// @param fields (Array of String | Array of ListGridField) fields to hide
// @param [suppressRelayout] (boolean) if passed, don't relayout non-explicit sized fields
//                                      to fit the available space
// @visibility external
//<
hideFields : function (fields, suppressRelayout) {
    return this.hideField(fields, suppressRelayout);
},

//> @attr listGrid.discardEditsOnHideField (boolean : true : IRW)
// If a user is editing a +link{listGrid.canEdit,canEdit:true} listGrid, and they hide
// a field while the editor is showing, should we discard any edits in the edit row for
// the field being hidden?
// <P>
// Default behavior is to discard the edits - set this flag to false to preserve edits
// @visibility external
//<
// The intention here is to avoid confusion. If the user is editing a field in an
// auto-save-edits:true grid, it is rare for there to be pending editor values outside the
// edit-form. Most commonly this will occur only for validation failure.
// In this case, if the edits a field and hides it and then a save fails due to a validation
// failure on the hidden field, there's no user-visible feedback indicating what happened.
// Developers who choose to do so can set this flag to false and handle this case via 
// validation failure handling code at the grid level of course.
// We also disable this for the filterEditor where we want to retain filter criteria which
// are not reflected in the visible set of fields.
discardEditsOnHideField:true,

//> @method listGrid.hideField()
// Force a field to be hidden.<br><br>
//
// NOTE: If a field.showIf expression exists, it will be destroyed.
// <P>
// Note also that if multiple fields are to be hidden it is more efficient to
// call +link{hideFields()} passing in the array of fields to hide rather than to call
// this method repeatedly.
//
// @param field (String | ListGridField) field to hide
// @param [suppressRelayout] (boolean) if passed, don't relayout non-explicit sized fields
//                                      to fit the available space
// @visibility external
// @example columnOrder
//<
hideField : function (fields, suppressRelayout) {
    arguments.__this = this;

    // if setFields() hasn't been run, run it now, then call ourselves again
    if (this.completeFields == null) {
        this.setFields(this.completeFields || this.fields);
        return this.hideField(fields, suppressRelayout);
    }

    var noFields = true,
        allHidden = true;

    if (!isc.isAn.Array(fields)) {
        fields = [fields];
    }
    // we shuffle some stored colNums around on edit items - store out the index of each field
    // being hidden in an array to make this easier.
    var hiddenFieldNums = [];

    if (fields.length == this.getFields().length) {
        // can't hide the last bunch of fields
        this.logWarn("Attempt to hide all fields in one call - disallowed.");
        return;
    }

    // If we need to update the UI, it's more efficient to do it here directly than
    // just calling setFields().
    // However if setFields has never been called we will have to call it
    //
    // Frozen fields: with frozen fields, the partial rebuild attempted below doesn't work.
    // This hasn't been looked into in detail yet.
    

    var mustSetFields = this.frozenFields;
    // If we're showing an editor we need to make certain changes to get rid of the
    // form item, etc.
    var editorShowing = this._editorShowing,
        editRow = editorShowing ? this.getEditRow() : null,
        editCol = editorShowing ? this.getEditCol() : null,
        hidEditCell = false;
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            fieldObj = field;

        // Use getSpecifiedField() to pick up the field object from the completeFields array
        // (or if setFields has never been called, from the fields array).
        // Note - if we're passed an invalid field object, this method returns null.
        fieldObj = this.getSpecifiedField(fieldObj);
        if (fieldObj == null) {
            this.logWarn("hideField(): unable to find field object for field: " + field
                         + ". Taking no action. To add this field use the setFields() method.");
            fields[i] = null;
            continue;
        }
        noFields = false;

        // -- Set showIf to always evaluate to false.
        fieldObj.showIf = this._$false;

        // If the field is not currently present in this.fields, we can safely assume it's already
        // hidden. No need to proceed in this case
        if (!this.fields.contains(fieldObj)) {
            fields[i] = null;
            continue;
        }
        allHidden = false;

        // Update initialization property to match new field state
        fieldObj.hidden = true;

        // If we're going to call setFields, we're done - we'll just call that
        // method outside this for-loop to update the completeFields array, edit values, etc.
        if (mustSetFields) continue;

        var fieldNum = this.fields.indexOf(fieldObj),
            fieldName = this.getFieldName(fieldNum);

        hiddenFieldNums.add(fieldNum);

        if (editorShowing) {
            if (editCol == fieldNum) hidEditCell = true;

            // If the user has modified the edit value and not yet stored the change
            // (IE it isn't yet part of our 'pending edit values' for the row), discard
            // the unsaved edits.
            
            // By default we're going to clear the edit value from the cell being hidden
            // pass the additional 3rd parameter to avoid re-displaying the record's value
            // in the (about to be cleared) cell.
            var focusItem = this.getEditFormItem(fieldName);
            // (Item may not exist due to incremental rendering, non editable fields, editByCell)
            if (focusItem && focusItem.hasFocus) focusItem.blurItem();
            
            if (this.discardEditsOnHideField) {
                this.clearEditValue(editRow, fieldNum, true);
            }
        }
    }
    // If we were passed an empty array, or an array containing already hidden fields
    // we can bail here.
    if (noFields || allHidden) return;

    // if we have to call setFields, simply call it and allow that method to do the work
    // of updating the fields array etc.
    if (mustSetFields) {
        this.setFields(this.completeFields || this.fields);
        if (this.selectHeaderOnSort && this._sortSpecifiers) this.selectSortFieldHeaderButton();
        this.handleFieldStateChanged();
        return;
    }

    fields.removeEmpty();
    if (editorShowing) {
        if (hidEditCell) {
            // If we're editing by cell, and hiding the current edit cell just kill the edit.
            if (this.editByCell) {
                this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
                editorShowing = false;
            } else {
                // If possible we want to shift edit focus to an adjacent field
                // findNextEditCell() is unaware of the cells we've just hidden so
                // reimplement the relevant part of this method to find the next editable and
                // still visible field. Check for closest field to the left first, then to the right
                var newEditCol = editCol-1,
                    foundEditCol = false;
                while (newEditCol >= 0) {
                    if (!hiddenFieldNums.contains(newEditCol) &&
                        this.canEditCell(editRow, newEditCol) &&
                        this._canFocusInEditor(editRow, newEditCol))
                    {
                        foundEditCol = true;
                        break;
                    }
                    newEditCol--;
                }
                if (!foundEditCol) {
                    newEditCol = editCol +1;
                    while (newEditCol < this.fields.length) {
                        if (!hiddenFieldNums.contains(newEditCol) &&
                            this.canEditCell(editRow, newEditCol) &&
                            this._canFocusInEditor(editRow, newEditCol))
                        {
                            foundEditCol = true;
                            break;
                        }
                        newEditCol++;
                    }
                }

                // If we don't have any other editable cells in the row, just cancel the edit
                if (!foundEditCol) {
                    this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
                    editorShowing = false;
                } else {
                    // focus in the adjacent field.
                    
                    this._startEditing(editRow, newEditCol,
                                            !this.getEditForm().hasFocus);
                }
            }
        }
    }
    // update this.fields
    this.deriveVisibleFields();
    // destroy the header button
    var header = this.header;
    if (header != null) {
        // Setting the hPolicy to "fill" will cause the header to relay it's buttons out to
        // fill the available space.
        if (!suppressRelayout) this.header.hPolicy = "fill";
        var buttons = [];
        for (var i = 0; i < hiddenFieldNums.length; i++) {
            var fieldNum = hiddenFieldNums[i];

            var button = this.header.getButton(fieldNum);
            buttons[buttons.length] = button;
            if (this.headerMenuButton && this.headerMenuButton.masterElement == button) {
                this.headerMenuButton.depeer();
            }
        }
        // removeButtons actually effects the display passed in, so duplicate it
        this.header.removeButtons(buttons.duplicate());
        buttons.map("destroy");

        // If we're auto-fitting vertically, allow the header to shrink or grow vertically
        // as appropriate
        if (this.autoFitHeaderHeights) {
            this.dropCachedHeaderButtonHeights();
            this._updateHeaderHeight();
        }
    }
    // If we're currently showing any edit form items for subsequent columns,
    // we must decrement their 'colNum' properties.
    // do this *before* we redraw the body, as the body redraw relies on these values being
    // accurate to create new items for fields that get shifted into view.
    // Also update the _editColNum if necessary.

    
    var itemsToClear = [];
    if (editorShowing) {
        hiddenFieldNums.sort();

        var form = this._editRowForm,
            items = form.getItems(),

            itemIndex = items.length-1,
            item = items[itemIndex],
            itemColNum = item.colNum,

            adjustedEditColNum = false;

        for (var i = hiddenFieldNums.length-1; i >= 0; i--) {

            var offset = i+1,
                threshold = hiddenFieldNums[i];

            if (!adjustedEditColNum && this._editColNum > threshold) {
                this._editColNum -= offset;
                adjustedEditColNum = true;
            }

            while (item != null && itemColNum >= threshold) {
                if (itemColNum == threshold) itemsToClear.add(item);
                else item.colNum -= offset;

                itemIndex --;
                item = (itemIndex >= 0) ? items[itemIndex] : null;
                itemColNum = (item != null) ? item.colNum : null;
            }
        }
    }
    // tell the body about the removed fields
    if (this.body) {
        this.body.fields = this.normalFields || this.fields;
        this.setBodyFieldWidths(this.getFieldWidths());

        this._remapEmbeddedComponentColumns(this.body);
        // instant redraw rather than markForRedraw because we have to avoid dropping
        // values
        if (this.body.isDrawn()) this.body.redraw("hide field");
    }

    if (editorShowing && itemsToClear.length > 0) {
        // If we're currently showing an edit form item for this field, remove it now (already
        // been cleared from the DOM), and had the edit values cleared.
        for (var i = 0; i < itemsToClear.length; i++) {
            // Hide the actual item if there is one.
            var item = itemsToClear[i];
            // Note that we may already have updated the items as part of redraw so
            // don't attempt to remove an already destroyed item from the form
            if (item.destroyed) continue;
            this._editRowForm.removeItems([item]);
        }
    }
    // reset the sortFieldNum - we may have removed or repositioned the primary sort field
    if (this.sortField != null) {
        this.sortFieldNum = null;
        this.sortFieldNum = this._getSortFieldNum();
        if (this.selectHeaderOnSort && this.header) this.selectSortFieldHeaderButton();
    }

    // If we have a filterEditor showing, update its fields too
    if (this.filterEditor != null) this.filterEditor.hideField(fields, suppressRelayout);
    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow._recalculateSummaries();
        this.summaryRow.hideField(fields, suppressRelayout);
    }
    
    //this._remapEmbeddedComponents();
    this.handleFieldStateChanged();
    this._clearFieldDependencyTable();
},

//> @method listGrid.fieldIsVisible()
// Check whether a field is currently visible
//
// @param   field (String | ListGridField)  field to be checked
// @return (boolean) true if the field is currently visible, false otherwise.
// @visibility external
//<
fieldIsVisible : function (field, optimize) {
    var fieldObj = field;
    // If passed a field ID, look for it in the completeFields array rather than the fieldsArray
    // as it is may be defined, but not visible
    if (!isc.isAn.Object(fieldObj)) fieldObj = this.getSpecifiedField(field);

    // avoid a linear lookup across visible fields
    if (optimize) {
        if      (fieldObj.showIf == "false") return false;
        else if (fieldObj.showIf ==  null)   return true;
    }

    return this.fields.contains(fieldObj);
},

// ----------------------------------------------------------------------------
// panelHeader related methods

showActionInPanel : function (action) {
    // specifically add the "editNew" action, which is not added by default
    if (action.name == "editNew") return true;
    return this.Super("showActionInPanel", arguments);
},

//> @method listGrid.getTitleField()
// @include dataBoundComponent.getTitleField()
//<

//> @method listGrid.setFields()  ([A])
// Sets the fields array and/or field widths to newFields and sizes, respectively.<br><br>
//
// If newFields is specified, it is assumed that the new fields may have nothing in common with
// the old fields, and the component is substantially rebuilt.  Furthermore, it's invalid to
// modify any of the existing +link{ListGridField}s after they've been passed to this function.
// Consider the following methods for more efficient, more incremental changes:
// +link{resizeField()}, +link{reorderField()}, +link{showField()}, +link{hideField()}, or
// +link{setFieldProperties()}.
//
// @visibility external
//
// @param   [newFields]     (Array of ListGridField)    array of fields to draw
//<
_$setFields:"set fields",
setFields : function (newFields) {
    if (isc._traceMarkers) arguments.__this = this;
    
    var recalculateSummaries = false;
    // If called with new fields (more than just an update of existing field state), reset
    // the flag indicating that we've used specified width as a minimum for autoFitWidth fields
    if (newFields != null && this.fields != null &&
        this.fields != newFields && this.completeFields != newFields)
    {
        delete this.fields._appliedInitialAutoFitWidth;
    }
    // Iterate through supplied fields:
    // - warn and remove any null slots
    // - Check for any userFormulae / summary fields - we may have to "recalculateSummaries"
    if (isc.isAn.Array(newFields)) {
        var offset = 0;
        for (var i = 0; i < newFields.length; i++) {
            // If we hit a null slot, shunt subsequent fields earlier in the list so they fill
            // the slot.
            if (newFields[i] == null) {
                this.logWarn("listGrid.setFields : null entry in new fields array - removing the entry");
                offset += 1;
                continue;
            }
            if (offset > 0) newFields[i-offset] = newFields[i];
            
            if (newFields[i] && (newFields[i].userFormula || newFields[i][this._$summary])) {
                recalculateSummaries = true;
            }
        }
        if (offset > 0) newFields.length = newFields.length - offset;
    }

    if (!newFields && this.getDataSource() && !this.getDataSource().hasFields()) {
        this.logWarn("ListGrid.setFields() : neither this ListGrid nor its dataSource have fields");
    }
    // set boolean images to default checkboxItem images if unset
    if (!this.booleanFalseImage && !this.booleanTrueImage && !this.booleanPartialImage) {
        this.booleanTrueImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("checkedImage") : null;
        this.booleanFalseImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("uncheckedImage") : null;
        this.booleanPartialImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("partialSelectedImage") : null;
        // set imageWidth from checkboxItem.valueIconWidth to avoid images having different sizes
        // when editing and not editing
        
        this.booleanImageWidth = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("valueIconWidth") : null;
        this.booleanImageHeight = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("valueIconHeight") : null;

    }
    if (!this.printBooleanFalseImage && !this.printBooleanTrueImage && !this.printBooleanPartialImage) {
        this.printBooleanTrueImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("printCheckedImage") : null;
        this.printBooleanFalseImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("printUncheckedImage") : null;
        this.printBooleanPartialImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("printPartialSelectedImage") : null;
    }

    // if there is a sortFieldNum set, get a pointer to that field
    // we'll check later to reset the sort if we need to
    var sortFieldNum = this._getSortFieldNum(),
        oldSortField = (sortFieldNum != null && this.fields
                        ? this.fields[sortFieldNum] : null);

    // Interaction of setFields() with editing:
    // - If we have editValues for any row(s) [Pending unsaved edits], it is possible that
    //   some of the fields for which we have edit values will go away - in this case we need
    //   to drop those edit values, and any validation errors for those fields.
    // - If we are currently showing an editor for some row, we may also need to update the
    //   fields in the edit form.
    // * We'll drop the removed fields' edit values silently, [log at info level only] - this
    //   is expected / acceptable behavior when fields are removed.
    var editorShowing = this._editorShowing,
        editRowNum = this.getEditRow(),
        editColNum = this.getEditCol(),
        editForm = this._editRowForm,
        oldEditFieldName = this.fields ? this.getEditFieldName() : null
    ;

    // listGrid.completeFields and listGrid.fields are set to arrays which contain pointers
    // to the same set of "field" objects.
    // - Any fields with a showIf property that evaluates to false will be removed from
    //   this.fields, making it an array of only the list of *visible* fields.
    // - on a reorder or similar manipulation of the set of fields, you should manipulate
    //   this.completeFields and pass the result to setFields().  Otherwise, you will lose any
    //   fields that aren't visible at the time.
    

    

    // on the first setFields() ever, create a new array for the visible fields
    if (this.completeFields == null) this.fields = [];
    // bind the passed-in fields to the DataSource and store
    // canPickOmittedFields - if true we'll pick up all dataSource fields but have them
    // marked as showIf:false if useAllDataSourceFields is false
    
    if (!this._suppressBindToDS) {
        this.completeFields = this.bindToDataSource(newFields, this.canPickOmittedFields);
    }
    if (this.completeFields == null) this.completeFields = [];

    // rowNumberField displaying the current rowNum of each record
    if (this.shouldShowRowNumberField()) {
        var rnField = this.getCurrentRowNumberField(),
            rnPos = this.getRowNumberFieldPosition(),
            shouldAdd = !rnField
        ;

        // Exception: If the completeFields passed in (the new fields) contains the
        // special field already, no need to add it.
        
        if (shouldAdd &&
            newFields && newFields.find(this.fieldIdProperty, "_rowNumberField") != null)
        {
            shouldAdd = false;
        }

        if (shouldAdd) rnField = this.getRowNumberField();

        if (shouldAdd) this.completeFields.addAt(rnField, rnPos);
        else this.completeFields.slideList([rnField], rnPos);
    } else {
        var rnField = this.getCurrentRowNumberField();
        if (rnField) this.completeFields.remove(rnField);
    }
    
    // checkboxField for selection
    if (this.shouldShowCheckboxField()) {
        var cbField = this.getCurrentCheckboxField(),
            cbPos = this.getCheckboxFieldPosition(),
            shouldAdd = !cbField
        ;
        if (shouldAdd && newFields && newFields.find(this.fieldIdProperty, "_checkboxField")) {
            shouldAdd = false;
        }

        if (shouldAdd) cbField = this.getCheckboxField();
        // make checkboxField frozen if we have any other frozen fields - note autoFreeze: true does this now

        // avoid adding the checkbox field at position 1 when there's nothing at position 0
        // (eg, when showingGroupTitleColumn() returns true, but groupBy() hasn't yet been called)
        if (cbPos > this.completeFields.length) cbPos = this.completeFields.length;

        if (shouldAdd) this.completeFields.addAt(cbField, cbPos);
        else this.completeFields.slideList([cbField], cbPos);
    } else {
        var cbField = this.getCurrentCheckboxField();
        if (cbField) this.completeFields.remove(cbField);
    }

    // expansionField for selection
    if (this.shouldShowExpansionField()) {
        var expField = this.getCurrentExpansionField(),
            expPos = this.getExpansionFieldPosition(),
            shouldAdd = !expField
        ;
        if (shouldAdd) expField = this.getExpansionField();
        // make expansionField frozen if we have any frozen fields - note autoFreeze: true does this now

        if (shouldAdd) this.completeFields.addAt(expField, expPos);
        else this.completeFields.slideList([expField], expPos);
    } else {
        var expField = this.getCurrentExpansionField();
        if (expField) this.completeFields.remove(expField);
    }

    // Add / update the removeField if this.canRemoveRecords is true
    if (this.shouldShowRemoveField()) {
        var removeFieldNum = this.completeFields.findIndex("isRemoveField", true),
            removeField = (removeFieldNum >= 0) ? this.completeFields[removeFieldNum]
                                                : {excludeFromState:true, isRemoveField:true};

        if (removeFieldNum == -1 && newFields) {
            removeFieldNum = newFields.findIndex("isRemoveField", true);
        }
        if (!removeField._removeFieldInitialized) {

            isc.addProperties(removeField, this.removeFieldDefaults, this.removeFieldProperties);
            if (removeField.name == null) removeField.name = "_removeField";
            if (removeField.title == null) removeField.title = this.removeFieldTitle;

            // show removeIcon / unremoveIcon by default.
            // if cellIcon or formatCellValue are explicitly specified on the field
            // don't override those.
            if (removeField.cellIcon == null && removeField.formatCellValue == null) {
                removeField.formatCellValue = function (value, record, rowNum, colNum, grid) {
                    // If this record is explicitly marked to not allow removal show no icon
                    if (grid.recordCanRemoveProperty && record && record[grid.recordCanRemoveProperty] === false) return "&nbsp;";

                    if (!this.removeIconHTML) {
                        this.removeIconHTML = isc.Canvas.imgHTML({
                            src: grid.removeIcon,
                            width: grid.removeIconSize,
                            height: grid.removeIconSize,
                            extraCSSText: "cursor:" + isc.Canvas.HAND
                        });
                        this.unremoveIconHTML = isc.Canvas.imgHTML({
                            src: grid.unremoveIcon,
                            width: grid.removeIconSize,
                            height: grid.removeIconSize,
                            extraCSSText: "cursor:" + isc.Canvas.HAND
                        });
                    }
                    if (grid.recordMarkedAsRemoved(rowNum)) {
                        return this.unremoveIconHTML;
                    } else {
                        return this.removeIconHTML;
                    }
                }
                // Store out the iconSize - this makes autoFit more efficient
                removeField.iconSize = this.removeIconSize;
            }
            if (removeFieldNum == -1) {
                this.completeFields.add(removeField);
            }

            removeField._removeFieldInitialized = true;
        }
    }

    // If we have headerSpans ensure the order of fields works with the set of spans
    if (this.headerSpans) {

        // header spans can span fields that aren't next to each other in the fields array.
        // If this happens we'll need to render them next to each other for the spans to work of course
        this.reorderFieldsForHeaderSpans();

        this.spanMap = this.buildSpanMap();
    }

    // set field state if necessary
    var fieldStateAlreadySet = false;
    if (this.fieldState != null) {
        this.setFieldState();
        fieldStateAlreadySet = true;
    }

    // set group state if necessary
    var groupStateAlreadySet = false;
    if (this.groupState != null) {
        this.setGroupState(this.groupState);
        groupStateAlreadySet = true;
    }

    // determine which fields should be shown, and add them to the visible fields array
    // (this.fields)
    // Need to derive the visible fields array before calling applyFieldDefaults() because
    // some field defaults depend on whether a field is the last visible non-frozen field.
    this.deriveVisibleFields();

    // apply various type-based defaults
    this.applyFieldDefaults(this.completeFields);

    this._clearFieldDependencyTable();

    // sets things up to look up display maps when LG is drawn
    
    if (isc.DataSource) this._setOptionDataSources();

    // warn about all fields being hidden.  Note it's valid to have no fields if you've created
    // a grid that will be bound to a DataSource or provided fields later.
    if (this.fields.length == 0 && this.completeFields.length > 0) {
        this.logWarn("All specified fields for this component are hidden. Note that fields " +
                     "may be hidden via 'showIf' or 'detail' attribute values. " +
                     "In order to display data this grid must have some visible fields.");
    }

    // wipe out the cached fieldWidths, if any
    this._fieldWidths = null;

    var newEditColNum, editFieldStillPresent, hadFocus;
    
    if (editorShowing) {
        // make sure we get the latest value of the field being edited
        // (Not relevant if we're not drawn since the user can't have updated)
        this.storeUpdatedEditorValue();

        // assume we should continue editing at the field with the same id
        newEditColNum = this.fields.findIndex(this.fieldIdProperty, oldEditFieldName);
        if (newEditColNum != -1 && !this.canEditCell(editRowNum, newEditColNum))
            newEditColNum = -1;

        // if the field with same id isn't editable, find the next editable cell
        if (newEditColNum == -1) {
            var newEditCell;
            // extra param to suppress checking past this row
            if (!this.editByCell) newEditCell = this.findNextEditCell(editRowNum, 0, 1,
                                                                      true,true, false, true);
            if (newEditCell != null && newEditCell[0] == editRowNum) {
                newEditColNum = newEditCell[1];
            }

            // Kill the edit if we're editing by cell, or can't find another editable field
            // in the edit row.
            if (newEditColNum == -1) {
                this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
                editorShowing = false;
            }
        } else {
            // field with the same name present and editable: blur and refocus after redraw
            var item = editForm.getItem(oldEditFieldName);
            if (item) {
                hadFocus = item.hasFocus;
                if (hadFocus) editForm._blurFocusItemWithoutHandler();
            }
            editFieldStillPresent = true;
        }

        // Hide the editor if still editing.
        // Note that this will fire a blur handler unless we have already blurred without
        // the handler
        
        if (editorShowing) this.hideInlineEditor(false, true);
    }

    var autoCanFreeze = (this.canFreezeFields == null || this._autoDerivedCanFreeze) &&
                        this.fixedRecordHeights != false && this.fixedFieldWidths != false &&
                        this.autoFitData != "horizontal" && this.autoFitData != "both" &&
                        this.bodyOverflow != "visible";
    if (autoCanFreeze) {
        if (this.completeFields.getProperty("overflow").contains("visible")) autoCanFreeze = false;
    }
    if (autoCanFreeze) {
        this._autoDerivedCanFreeze = true;
        this.canFreezeFields = true;
    } else if (this._autoDerivedCanFreeze) {
        delete this._autoDerivedCanFreeze;
        this.canFreezeFields = null;
    }
    // if we're working with a cellSelection, it needs to know how many columns are visible
    if (this.canSelectCells) this.selection.numCols = this.fields.length;

    // if we are showing the header, rebuild it with the new set of fields
    var showingHeader = this.showHeader && this.headerHeight > 0 && this.header != null;
    if (showingHeader) {
        // this method will actually update the header to match this.fields
        this.updateHeader();
    }

    
    var sortStateAlreadySet = false;

    if (this._pendingSort) {
        
        delete this._pendingSort;
        this.setSort(this.getSort());
        sortStateAlreadySet = true;
    } else if (this.sortState != null) {
        // sortState 
        this.setSortState(this.sortState);
        sortStateAlreadySet = true;
    } else {
        // if we've already been sorted and we *can* sort, resort now
        var sortFieldNum = this._getSortFieldNum();
        if (sortFieldNum != null && this._canSortData(sortFieldNum)) {
            
            this.setSort(this.getSort());
        }
    }


    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow.setFields(this.completeFields.duplicate());
    }

    
    this.updateFieldDependencies();

    // If we added formula / summary fields, run the "recalculateSummaries" method to
    // apply calculated values to the records if necessary.
    this.calculateRecordSummaries(null, null, true, true, false, !recalculateSummaries);
    this.updateBody();

    // If we have a filterEditor, update its fields
    
    if (this.filterEditor) {
         // update the ds on the filterEditor (and the edit-form) - we need a ds to support some
        // expression-parsing features, like "matches other field" detecting fields by title as
        // well as name
        this.filterEditor.updateDataSource(this.getDataSource());
        var completeFields = this.completeFields || [];
        this.filterEditor.setFields(completeFields.duplicate());
    }

    // if we've rebuilt the header, this will place it and draw it.
    // this will also determine new field widths for the new fields (whether from the header or
    // otherwise)
    this.layoutChildren(this._$setFields);

    // sync scroll position of new header with current body scroll position
    if (showingHeader && this.body != null) {
        this.syncHeaderScrolling(this.body.getScrollLeft());
    }

    // Now the fields have been set, update the edit values field:
    // Update our editValues, and validation errors to account for any fields that have
    // gone from the list.
    if (this._editSessions != null) {
        var fieldsDropped = {};

        for (var i in this._editSessions) {
            if (this._editSessions[i] == null) continue;
            var vals = this._editSessions[i]._editValues,
                // We want to hang onto primary key values, even if they're not shown in the
                // ListGrid
                pks = (this.dataSource != null
                    ? this.getDataSource().getPrimaryKeyFieldNames()
                    : [])
            ;

            for (var currentFieldName in vals) {
                
                if (!this.fields.containsProperty(this.fieldIdProperty, currentFieldName) &&
                    !pks.contains(currentFieldName)) {
                    // track which fields were dropped so we can inform the user / developer
                    fieldsDropped[currentFieldName] = true;
                    // clearEditValue will clear the editValue and any validation errors for
                    // the field
                    // Pass the additional 3rd parameter to avoid refreshing the updated cells
                    
                    this.clearEditValue(vals, currentFieldName, true);
                }
            }
        }

        fieldsDropped = isc.getKeys(fieldsDropped);
        if (fieldsDropped.length > 0) {
            this.logInfo("'setFields()' removed the following fields which had pending edit " +
                         "values for some row[s]: '" + fieldsDropped.join("', '") + "'.\n" +
                         "Edit values for these fields have been dropped.", "gridEdit");
        }
    }

    // re-show the editor, with the new set of fields
    if (editorShowing) {
        // if the previous edit field is still showing, just re-show the editor
        // and focus silently if appropriate.
        if (editFieldStillPresent) {
            // 2nd and 3rd parameters are both false - even though this field may be in a
            // new position, it's the same logical field, so we don't want to fire
            // editorEnter()
            this.showInlineEditor(editRowNum, newEditColNum, false, false, true);
            if (hadFocus) editForm._focusInItemWithoutHandler(newEditFieldName);
        } else {
            // If we've killed the previous edit field, but still want to be editing, use
            // _startEditing() to start editing the new cell to ensure editValues get set up
            // if necessary
            this._startEditing(editRowNum, newEditColNum, !hadFocus);
        }

        // Refocus without firing the handler if the old edit field is still around and had
        // focus before the setFields.
        if (hadFocus) {
            var newEditFieldName = this.getEditFieldName();
            if (newEditFieldName == oldEditFieldName) {
                editForm._focusInItemWithoutHandler(newEditFieldName);
            } else {
                editForm.focusInItem(newEditFieldName)
            }
        }
    }

    // Re-run the logic to apply hilites (that method stores information on record and
    // field objects).
    
    if (this.hilites != null) this.applyHilites();

    // Remember the fieldState when setFields is first called.
    // If "setFieldState()" is called with a partial fieldState that doesn't include all fields,
    // we'll reapply the default field state for
    // any fields that are not explicitly listed in the new state.
    // That is implemented in DBC.setFieldState
    // _suppressStoreFieldState flag used to ensure 'setFieldState()' doesn't also remember
    // that field state as the default
    
    if (!this._suppressStoreFieldState) this.defaultFieldState = this.getFieldState();

    // Set view state if necessary
    if (this.viewState) {
        var viewState = this.viewState;
        // Only do this the very first time through
        this.viewState = null;

        if (fieldStateAlreadySet) {
            // Don't overwrite fieldState set earlier
            var state = this.evalViewState(viewState, "viewState");
            if (state) {
                delete state.field;
            }
            viewState = "(" + isc.Comm.serialize(state,false) + ")";
        }
        if (sortStateAlreadySet) {
            // Don't overwrite sortState set earlier
            var state = this.evalViewState(viewState, "viewState");
            if (state) {
                delete state.sort;
            }
            viewState = "(" + isc.Comm.serialize(state,false) + ")";
        }
        if (this.hiliteState) {
            // Don't overwrite hiliteState set earlier
            var state = this.evalViewState(viewState, "viewState");
            if (state) {
                delete state.hilite;
            }
            viewState = "(" + isc.Comm.serialize(state,false) + ")";
        }
        if (groupStateAlreadySet) {
            // Don't overwrite groupState set earlier
            var state = this.evalViewState(viewState, "viewState");
            if (state) {
                delete state.group;
            }
            viewState = "(" + isc.Comm.serialize(state,false) + ")";
        }
        this.setViewState(viewState);
    }
},

// override add/removeField to account for us having 'this.completeFields' which
// dataBoundComponent doesn't expect
addField : function (field, index) {
    return this.Super("addField", [field, index, this.completeFields], arguments);
},
removeField : function (field) {
    return this.Super("removeField", [field, this.completeFields], arguments);
},

// Helper method - should this grid show the special checkbox field for
// selectionAppearance:"checkbox". TreeGrid's show the checkbox in the
// special tree field so we don't show this field.
_$checkbox:"checkbox",
shouldShowCheckboxField : function () {
    if (this.fieldSourceGrid) return this.fieldSourceGrid.shouldShowCheckboxField();
    return (this.selectionAppearance == this._$checkbox &&
        this.selectionType != this._$none &&
        !isc.isA.TreeGrid(this));
},

//> @method listGrid.focusInFilterEditor()
// If the filter editor (+link{listGrid.showFilterEditor}) is visible for this grid,
// this method will explicitly put focus into the specified field in the filter editor.
// @group filterEditor
// @visibility external
// @param [fieldName] (String) Name of the field to put focus into. If unspecified focus will go
//                             to the first field in the editor
//<
focusInFilterEditor : function (fieldName) {
    if (this.filterEditor == null) return;
    var fieldNum = fieldName != null ? this.getColNum(fieldName) : null;
    this.filterEditor.startEditing(0, fieldNum);
},

//> @method listGrid.filterByEditor()
// If the filter editor (+link{listGrid.showFilterEditor}) is visible for this grid,
// this method will perform a filter based on the current values in the editor.
// @group filterEditor
// @visibility external
//<
filterByEditor : function () {
    if (this.filterEditor != null) this.filterEditor.performAction();
},


// Override bindToDataSource. Unlike other data-bound widgets if this.showDetailFields is true
// we want to default our detailFields to be hidden (but accessible via the headerContextMenu)
// Note: We do this at init (setFields) time by setting the showIf property on the field,
// rather than overriding fieldShouldBeVisible() to return false for detail fields, so that
// when showField() is called on the field, that method can return true and allow the field
// to show.
bindToDataSource : function (fields, componentIsDetail, a,b,c,d) {
    var numericFieldName = false;

    var completeFields = this.invokeSuper(isc.ListGrid, "bindToDataSource",
                                          fields, componentIsDetail, a,b,c,d);
    if (completeFields != null) {
        for (var i = 0; i < completeFields.length; i++) {
            var field = completeFields[i];
            if (this.showDetailFields) {
                if (field.showIf == null && field.detail == true) {
                    field.showIf = this._$false;
                }
                
                if (this._isNumberOrArrayProp(field.name)) {
                    numericFieldName = true;
                }
                if (this._isFieldObject(field)) {
                    field._isFieldObject = true;
                }
            }
            
            var validators = this.getFieldEditorValidators(field);
            if (validators) field.validators = (field.validators || []).addList(validators);
        }
    }
    this._noNumericFields = !numericFieldName;
    return completeFields;
},

// should we apply the "_isFieldObject" marker to this field object?
// this is used by the column picker submenu to identify "true fields" as opposed to auto-generated 
// columns such as the removeField

_isFieldObject : function (field) {
    if (field == null) return false;
    return (!field.isRemoveField && !field._isRowNumberField && 
            !field._isExpansionField && !field._isCheckboxField);
    
},

// Check whether a field name is a number
// *and* whether it's some property present on the fields array such as "size", etc
_$emptyArr:[],
_isNumberOrArrayProp : function (name) {
    if (this._$emptyArr[name] != null) return true;
    if (isc.isA.Number(parseInt(name)) &&
        parseInt(name).toString() == name) return true;
    return false;
},

// Field State
// --------------------------------------------------------------------------------------------
// The fieldState is an object capturing presentation information about the fields -
// expected to be used as a way for developers to save the current presentation (EG in cookies)
// and re-load that presentation when the page is reloaded.
// fieldState is an opaque format.



//> @type ListGridFieldState
// An object containing the stored presentation information for the fields of a listGrid.
// Information contained in a <code>ListGridFieldState</code> object includes the
// visibility and widths of the listGrid's fields.<br>
// Note that this object is a JavaScript string, and may be stored (for example) as a blob
// on the server for state persistence across sessions.
//
// @group viewState
// @visibility external
//<

//> @attr listGrid.fieldState (String : null : IRW)
// Initial +link{ListGridFieldState, field state} for the grid.
// <p>
// +link{viewState} can be used to initialize all view properties of the grid.
// When doing so, <code>fieldState</code> is not needed because <code>viewState</code>
// includes it as well. If both are provided, <code>fieldState</code> has priority for
// field state.
// <smartclient>
// <P>
// To retrieve current state call +link{ListGrid.getFieldState,getFieldState}.
// </smartclient>
//
// @group viewState
// @visibility external
//<

//> @method listGrid.getFieldState()
// Returns a snapshot of the current presentation of this listGrid's fields as
// a +link{type:ListGridFieldState} object.
// <P>
// This object can later be passed to +link{listGrid.setFieldState()} to reset this grid's
// fields to the current state.
// <P>
// Note that the information stored includes the current width and visibility of each of this
// grid's fields, as well as any +link{listGrid.canAddFormulaFields,formula} or
// +link{listGrid.canAddSummaryFields,summary fields} added by the user.
//
// @group viewState
// @see listGrid.setFieldState();
// @visibility external
// @return (ListGridFieldState) current state of this grid's fields.
//<
// LG.getFieldState() moved up to DBC

//> @method listGrid.setFieldState()
// Sets some presentation properties (visibility, width, userFormula and userSummary) of the
// listGrid fields based on the +link{type:ListGridFieldState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to +link{listGrid.getFieldState()}.
//
// @group viewState
// @param fieldState (ListGridFieldState) state to apply to the listGrid's fields.
// @visibility external
// @see listGrid.getFieldState()
//<
setFieldState : function (fieldState) {

    //!OBFUSCATEOK
    if (this.completeFields == null) this.setFields(this.fields);

    // For a grid initialized with this.fieldState(), we will run setFieldState with no params
    // from within our initial setFields().
    
    if (fieldState == null && this.fieldState != null) {
        if (isc.isA.String(this.fieldState)) {
            fieldState = this.evalViewState(this.fieldState, "fieldState")
        } else {
            fieldState = this.fieldState;
        }
        this.completeFields = this._setFieldState(fieldState);

        // fieldState is init-only property, so null after use
        this.fieldState = null;
        return;
    }

    fieldState = this.evalViewState(fieldState, "fieldState")
    if (fieldState) {
        this.completeFields = this._setFieldState(fieldState);
        this.refreshFields();
    }
},


handleFieldStateChanged : function (preserveSelection) {
    this.fieldStateChanged();
    this.handleViewStateChanged();
    if (this.canSelectCells && !preserveSelection) {
        this.selection.deselectAll();
        if (this.fields && this.fields.length != this.selection.numCols) {
            this.selection.numCols = this.fields.length;
        }
    }
},

// fieldStateChanged implemented in DBC

// Override setHilites to fire the viewStateChanged notification
setHilites : function () {
    this.Super("setHilites", arguments);
    this.handleViewStateChanged();
},

// Override _handleHilitesChanged to fire the hilitesChanged notification.
_handleHilitesChanged : function (hilites) {
    this.Super("_handleHilitesChanged", arguments);
    if (isc.isA.Function(this.hilitesChanged)) this.hilitesChanged();
},

// Override redrawHilites to redraw the body rather than the entire grid.
redrawHilites : function () {
    this._markBodyForRedraw("redrawHilites");
},


// ---------------------------------------------------------------------------------------

//> @type SelectionAppearance
// How data selection should be presented to the user.
// @value "rowStyle" selected rows should be shown with different appearance - see
//                   +link{ListGrid.getCellStyle()} and optionally
//                   +link{ListGrid.selectionCanvas}.
// @value "checkbox" an extra, non-data column should be automatically added to the ListGrid,
//                   showing checkboxes that can be toggled to select rows.
//                   See +link{listGrid.getCheckboxField()}.
// @visibility external
//<

// defaults for checkbox field
checkboxFieldDefaults: {
    name: "_checkboxField",
    excludeFromState:true,
    canEdit: false,
    shouldPrint:false,
    // Note we could probably allow filtering by this field for client-side grids - which would
    // allow you to view all selected / unselected rows easily, (nice feature) but it wouldn't
    // work for databound grids
    canFilter:false,
    canGroupBy: false,
    canSort: false,
    canExport: false,
    canHide: false,
    canReorder: false,
    canDragResize: false,
    // make this special field canHilite false so we don't see it in HiliteEditors by default
    canHilite: false,
    _isCheckboxField: true,
    type:"boolean",
    showDefaultContextMenu: false,
    hoverHTML: "return null;", // suppress hover at row level, only hovering for header
    autoFreeze: true,
    showGridSummary: false,
    showGroupSummary: false,
    summaryValue: "&nbsp;",
    // disable this from ever being assigned as the treeField
    treeField:false,
    title: isc.nbsp
},

//> @method listGrid.getCheckboxField()
// Returns the specially generated checkbox field used when +link{selectionAppearance} is
// "checkbox".
// <P>
// Called during +link{setFields()}, this method can be overridden to add advanced dynamic
// defaults to the checkbox field (call Super, modify the default field returned by Super,
// return the modified field).  Normal customization can be handled by just setting
// +link{AutoChild} properties, as mentioned under the docs for +link{listGrid.checkboxField}.
//
// @return (ListGridField)
// @group checkboxField
// @visibility external
//<
getCheckboxField : function () {
    var grid = this,
        cbField = {
        // default the width to the width of the icon plus an arbitrary buffer
            width:this.checkboxFieldHSpace + this._getCheckboxFieldImageWidth(),
            getAutoFreezePosition: function () { return grid.getCheckboxFieldPosition() }
        }
    ;
    isc.addProperties(cbField, this.checkboxFieldDefaults, this.checkboxFieldProperties);

    cbField.title = (this.canSelectAll == false || this.selectionType == "single" ? isc.nbsp :
        this._getCheckboxValueIconHTML(false, false, true, false, cbField));

    return cbField;
},

//> @attr listGrid.checkboxFieldHSpace (int : 15 : IR)
// How much horizontal space should the +link{getCheckboxField(),checkbox field} leave
// around the checkbox icon when +link{listGrid.selectionAppearance} is set to
// <code>"checkbox"</code>?
// <P>
// The automatically generated checkbox field will be sized to the width of the
// checkbox icon (specified via +link{listGrid.checkboxFieldImageWidth} or
// +link{listGrid.booleanImageWidth}) plus this value.
// @group checkboxField
// @visibility external
//<
checkboxFieldHSpace:15,

getCurrentCheckboxField : function () {
    var fields = this.completeFields || this.fields;
    if (!fields) return null;
    var cbFields = fields.find(this.fieldIdProperty, "_checkboxField");
    return !cbFields ? null : isc.isAn.Array(cbFields) ? cbFields[0] : cbFields;
},

_getCheckboxFieldImageWidth : function () {
    return this.checkboxFieldImageWidth || this.booleanImageWidth ||
            (isc.CheckboxItem ? isc.CheckboxItem.getInstanceProperty("valueIconWidth") : null);
},
_getCheckboxFieldImageHeight : function () {
    return this.checkboxFieldImageHeight || this.booleanImageHeight ||
            (isc.CheckboxItem ? isc.CheckboxItem.getInstanceProperty("valueIconWidth") : null);
},

//> @method listGrid.isCheckboxField()
// Identifies whether the passed-in field is the specially generated
// +link{listGrid.checkboxField,checkboxField} used when +link{selectionAppearance} is
// "checkbox".  Use this method in your custom event handlers to avoid inappropriately
// performing actions when the checkboxField is clicked on.
//
// @param field (ListGridField) field to test
// @return (Boolean) whether the provided field is the checkbox field
// @group checkboxField
// @visibility external
//<
isCheckboxField : function (field) {
    if (!field || !field._isCheckboxField) return false;
    else return true;
},

// helper function to get the checkbox field position
// This is a special field which appears "stuck to" the left edge of the grid.
// We have a few other special fields:
// - rowNumbers column
// - groupTitle column when showing group summaries in header
// - record expansion icon column
getCheckboxFieldPosition : function () {
    if (this.fieldSourceGrid) return this.fieldSourceGrid.getCheckboxFieldPosition();
    if (this.selectionAppearance != "checkbox" || isc.isA.TreeGrid(this)) return -1;
    
    var pos = 0;
    if (this.shouldShowRowNumberField()) pos++;
    return pos;
},

//> @type ListGridSelectedState
// An object containing the stored selection information for a listGrid.
// Note that this object is not intended to be interrogated directly, but may be stored
// (for example) as a blob on the server for state persistence across sessions.
//
// @group viewState
// @visibility external
//<
// ListGridSelectedState object is implemented as an array of primaryKeys indicating the
// selected set of records.

//> @attr listGrid.selectedState (ListGridSelectedState: null : IRW)
// Returns a snapshot of the current selection within this listGrid as
// a +link{type:ListGridSelectedState} object.<br>
// This object can be passed to +link{listGrid.setSelectedState()} to reset this grid's selection
// the current state (assuming the same data is present in the grid).<br>
// @group viewState
// @visibility external
//<

//> @method listGrid.getSelectedState()
// Returns a snapshot of the current selection within this listGrid as
// a +link{type:ListGridSelectedState} object.<br>
// This object can be passed to +link{listGrid.setSelectedState()} to reset this grid's current
// selection state (assuming the same data is present in the grid).<br>
// @group viewState
// @see listGrid.setSelectedState();
// @visibility external
// @return (ListGridSelectedState) current state of this grid's selection
//<
getSelectedState : function (supressWarnings, returnObject) {
    if (!this.selection) return null;
    if (!this.dataSource ||
        isc.isAn.emptyObject(this.getDataSource().getPrimaryKeyFields()))
    {
        if (!supressWarnings) {
            
            this.logWarn("can't getSelectedState without a DataSource " +
                         "with a primary key field set");
        }
        return null;
    }

    var selectedState = [];
    if (this.canSelectCells) {
        var selection = this.selection.getSelectedCells();

        // store primary keys and cell-range.  Works only with a DataSource
        for (var i = 0; i < selection.length; i++) {
            var cell = selection[i],
                PKs = this.getPrimaryKeys(cell[0]),
                entry = null
            ;
            for (var k=0; k<selectedState.length; k++) {
                if (this.objectsAreEqual(PKs, selectedState[k].PKs)) {
                    entry = selectedState[k];
                    break;
                }
            }
            if (!entry) {
                selectedState.add({ PKs: PKs, cells: [] });
                entry = selectedState[selectedState.length-1];
            }
            entry.cells.add(cell[1])
        }
    } else {
        
        var selection = this.getSelection();

        // store primary keys only.  Works only with a DataSource
        var selectionLength = selection.length;
        for (var i = 0; i < selectionLength; ++i) {
            selectedState[i] = this.getPrimaryKeys(selection[i]);
        }
    }

    // returnObject is undocumented and passed when called from getViewState() - return the 
    // object to avoid double escaping
    if (returnObject) return selectedState;

    return isc.Comm.serialize(selectedState,false);
},


//> @method listGrid.getCellSelection()
// When +link{canSelectCells} is active, returns the +link{CellSelection} object that tracks
// and manages the current selection.  Returns null if +link{canSelectCells} is false.
// @return (CellSelection) current cellSelection
// @visibility external
//<
getCellSelection : function () {
    if (!this.canSelectCells) return null;
    return this.getSelectionObject();
},

//> @method listGrid.setSelectedState()
// Reset this grid's selection to match the +link{type:ListGridSelectedState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to
// +link{listGrid.getSelectedState()}.
//
// @group viewState
// @param selectedState (ListGridSelectedState) Object describing the desired selection state of
//                                              the grid
// @see listGrid.getSelectedState()
// @visibility external
//<
setSelectedState : function (selectedState) {
    selectedState = this.evalViewState(selectedState, "selectedState")
    if (!selectedState || selectedState.length == 0) {
        if (this.selection) this.selection.deselectAll();
        this.fireSelectionUpdated();
        return;
    }

    if (selectedState[0].PKs && !this.canSelectCells) {
        if (this.selection) this.selection.deselectAll();
        this.fireSelectionUpdated();
        this.logWarn("Cannot restore CellSelection state to a " +
            "ListGrid with canSelectCells: false.");
        return;
    } else if (!selectedState[0].PKs && this.canSelectCells) {
        if (this.selection) this.selection.deselectAll();
        this.fireSelectionUpdated();
        this.logWarn("Cannot restore Selection state to a " +
            "ListGrid with canSelectCells: true.");
        return;
    }

    var selection = this.selection,
        data = this.originalData || this.data;

    // ignore calls at an invalid time (data still loading or cache just invalidated)
    if (isc.ResultSet && isc.isA.ResultSet(data) && !data.lengthIsKnown()) return;

    if (data && selection) {
        selection.deselectAll();

        var records = [];

        for (var i = 0; i < selectedState.length; i++) {
            var item = selectedState[i]
            // resultSet.indexOf() looks up by matching PK values
            var PKs = selectedState[i];

            if (isc.isAn.Object(item) && item.cells != null) {
                // with cell-selection, we store an object with aPKs object an a cells array
                PKs = selectedState[i].PKs;
            }
            var index = data.findByKeys(PKs, this.getDataSource());
            // record may have been removed
            if (index != -1) {
                if (this.canSelectCells) {
                    // build an array of cell-reference arrays in the format [rowNum,colNum]
                    var cells = item.cells;
                    for (var k=0; k<cells.length; k++) {
                        records.add([index, cells[k]]);
                    }
                } else {
                    records.add(data.get(index));
                }
            }
        }
        if (this.canSelectCells) {
            this.selection.selectCellList(records);
        } else {
            this.selection.selectList(records);
        }
        this.fireSelectionUpdated();
    }
},

//> @type ListGridSortState
// An object containing the stored sort information for a listGrid.
// Note that this object is not intended to be interrogated directly, but may be stored
// (for example) as a blob on the server for state persistence across sessions.
//
// @group viewState
// @visibility external
//<
// ListGridSortState object is implemented as a simple JS object containing fieldName and sortDir
// attributes - also now supports the multiSorting subsystem by storing the grid's list of
// sortSpecifiers

//> @attr listGrid.sortState (ListGridSortState: null : IRW)
// Initial sort state for the grid.
// <P>
// +link{listGrid.viewState} can be used to initialize all view properties of the grid.
// When doing so, <code>sortState</code> is not needed because <code>viewState</code>
// includes it as well. If both are provided, <code>sortState</code> has priority for
// sort state.
// <smartclient>
// <P>
// To retrieve current state call +link{ListGrid.getSortState,getSortState}.
// </smartclient>
//
// @group viewState
// @visibility external
//<

//> @method listGrid.getSortState()
// Returns a snapshot of the current sort state within this listGrid as
// a +link{type:ListGridSortState} object.<br>
// This object can be passed to +link{listGrid.setSortState()} to reset this grid's sort to
// the current state (assuming the same fields are present in the grid).<br>
// @group viewState
// @see listGrid.setSortState();
// @visibility external
// @return (ListGridSortState) current sort state for the grid.
//<
getSortState : function (returnObject) {

    if (this.logIsInfoEnabled("sorting")) {
        this.logInfo("\n"+
            "grid.sortFieldNum is: "+this.sortFieldNum+"\n"+
            "grid.sortField is: "+this.sortField+"\n"+
            "grid.getField(grid.sortFieldNum) is:\n"+
                isc.echoAll(this.getField(this.sortFieldNum))+"\n"+
            "-----------------------------------------\n"+
            "grid._getSortFieldNum() is: "+this._getSortFieldNum()+"\n"+
            "grid.getField(grid._getSortFieldNum()) is:\n"+
                isc.echoAll(this.getField(this._getSortFieldNum()))+"\n"+
            "", "sorting"
        )
    }

    var sortFieldNum = this._getSortFieldNum();

    if (sortFieldNum != null || (this._sortSpecifiers && this._sortSpecifiers.length > 0)) {
        var sortField = (sortFieldNum != null ? this.getField(sortFieldNum) : null),
            sortFieldName = sortField != null ? this.getFieldName(sortField) : null,
            sortDir = this._getFieldSortDirection(sortField),
            sortState = { fieldName: sortFieldName, sortDir: sortDir }
        ;
        if (this._sortSpecifiers) {
            var specifiers = isc.shallowClone(this._sortSpecifiers);
            // remove some props added during sorting - keeps the output neat and they'll be
            // re-applied on setSort()
            specifiers.clearProperty("primarySort");
            specifiers.clearProperty("sortIndex");
            specifiers.clearProperty("normalizer");
            specifiers.clearProperty("context");
            specifiers.clearProperty("_comparator");
            sortState.sortSpecifiers = specifiers;
        }
        
        // returnObject is undocumented and passed when called from getViewState() - return the 
        // object to avoid double escaping
        if (returnObject) return sortState;

        // eval() of a string containing object literal text will js error - enclose in "(" ... ")" to
        // avoid this.
        return "(" + isc.Comm.serialize(sortState,false) + ")";
    }
},


//> @method listGrid.setSortState()
// Reset this grid's sort state (sort field and direction or list of
// +link{sortSpecifier}s) to match the
// +link{type:ListGridSortState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to
// +link{listGrid.getSortState()}.
//
// @param sortState (ListGridSortState) Object describing the desired sort state for the grid.
// @group viewState
// @see listGrid.getSortState()
// @visibility external
//<
setSortState : function (state) {
    state = this.evalViewState(state, "sortState")
    if (!state) {
        if (this.getSort()) this.clearSort();
        return;
    }

    if (state.sortSpecifiers) {
        // all non-legacy state - single specifier or multisort
        this.setSort(isc.shallowClone(state.sortSpecifiers));
    } else if (state.fieldName == null) {
        // no specifiers and no fieldName - never happens - clear the sort
        this.clearSort();
    } else {
        // will only get here now if the user has legacy state or creates their own state
        // object which doesn't include sortSpecifiers - a sortSpecifier will be created
        // anyway and further calls to getSortState() will include it
        var fieldNum = this.getFieldNum(state.fieldName)
        if (fieldNum != -1) this.sort(fieldNum, state.sortDir);
    }
},

//> @type ListGridViewState
// An object containing the "view state" information for a listGrid.<br>
// This object contains state information reflecting<br>
// - +link{type:ListGridFieldState}<br>
// - +link{type:ListGridSortState}<br>
// - +link{type:ListGridSelectedState}<br>
// for the grid.<br>
// Note that this object is a JavaScript string, and may be stored (for example) as a blob
// on the server for state persistence across sessions.
//
// @group viewState
// @visibility external
//<
// ListGridViewState object is implemented as a simple JS object containing the following
// fields:
// - selected [a ListGridSelectedState object]
// - field [a ListGridFieldState object]
// - sort [a ListGridSortState object]

//> @method listGrid.getViewState()
// Returns a snapshot of the current view state of this ListGrid.<br>
// This includes the field, sort, hilite, group, and selected state of the grid, returned 
// as a string representation of a +link{type:ListGridViewState} object.<br>
// This string can be passed to +link{listGrid.setViewState()} to reset this grid's view state
// to the current state (assuming the same data / fields are present in the grid).<br>
// @group viewState
// @see type:ListGridViewState
// @see listGrid.setViewState();
// @visibility external
// @return (ListGridViewState) current view state for the grid.
//<
getViewState : function (returnObject) {

    
    var state = { },
        selected = this.getSelectedState(true, true),
        field = this.getFieldState(true),
        sort = this.getSortState(true),
        hilite = this.getHiliteState(true),
        group = this.getGroupState(true),
        attrCount = 0
    ;

    if (selected && selected != "") { attrCount++; state.selected = selected; }
    if (field && field != "") { attrCount++; state.field = field; }
    if (sort && sort != "") { attrCount++; state.sort = sort; }
    if (hilite && hilite != "") { attrCount++; state.hilite = hilite; }
    if (group && group != "") { attrCount++; state.group = group; }

    if (attrCount > 0) {
        // Available so TG can call Super() and get an object back
        if (returnObject) return state;
        return "(" + isc.Comm.serialize(state,false) + ")";
    }
},

//> @type ListGridGroupState
// An object containing the stored grouping information for a listGrid.
// Note that this object is not intended to be interrogated directly, but may be stored
// (for example) as a blob on the server for state persistence across sessions.
//
// @group viewState
// @visibility external
//<
// ListGridGroupState object is implemented as a serialized array of objects specifying
// fieldName, groupingMode, granularity.
// We also support a simple comma separated string (the older format) for backcompat

//> @attr listGrid.groupState (ListGridGroupState: null : IRW)
// Initial group state for the grid.
// <P>
// +link{listGrid.viewState} can be used to initialize all view properties of the grid.
// When doing so, <code>groupState</code> is not needed because <code>viewState</code>
// includes it as well. If both are provided, <code>groupState</code> has priority for
// group state.
// <smartclient>
// <P>
// To retrieve current state call +link{ListGrid.getGroupState,getGroupState}.
// </smartclient>
//
// @group viewState
// @visibility external
//<

//> @method listGrid.getGroupState()
// Returns a snapshot of the current grouping state of this ListGrid.<br>
// This object can be passed to +link{listGrid.setGroupState()} to reset this grid's grouping
// to the current state (assuming the same data / fields are present in the grid).<br>
// @group viewState
// @see type:ListGridGroupState
// @see listGrid.setGroupState();
// @visibility external
// @return (ListGridGroupState) current view state for the grid.
//<
getGroupState : function (returnObject) {
    var i, field, states, groupFields = this.getGroupByFields();
    if (groupFields == null) {
       return "";
    } else {
        states = [];
        for (i = 0; i < groupFields.length; i++) {
            var allFields = this.completeFields || this.fields || [];
            field = allFields.find("name", groupFields[i]);
            if (field) {
                states.add({
                    fieldName : groupFields[i],
                    groupingMode : field.groupingMode,
                    groupGranularity : field.groupGranularity,
                    groupPrecision : field.groupPrecision
                });
            }
        }
    }

    // returnObject is undocumented and passed when called from getViewState() - return the 
    // object to avoid double escaping
    if (returnObject) return states;

    // eval() of a string containing object literal text will js error - enclose in "(" ... ")" to
    // avoid this.
    return "(" + isc.Comm.serialize(states,false) + ")";

},

//> @method listGrid.setGroupState()
// Reset this grid's grouping to match the +link{type:ListGridGroupState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to
// +link{listGrid.getGroupState()}.
//
// @group viewState
// @param groupState (ListGridGroupState) Object describing the desired grouping state of
//                                              the grid
// @see listGrid.getGroupState()
// @visibility external
//<
setGroupState : function (state) {
    var groupSpec = [];

    if (state) {
        if (isc.isA.String(state)) {
            if (!state.startsWith("(")) {
                // Backcompat - handle the state being stored as a comma separated string of fieldNames
                // in this case, split the string and make an array of objects with a fieldName
                state = state.split(",");
                for (var i=0; i<state.length; i++) {
                    state[i] = { fieldName: state[i] };
                }
            } else {
                state = this.evalViewState(state, "groupState")
            }
        }
        
        for (var i = 0; i < state.length; i++) {
            var item = state[i]
            
            var spec = this.makeGroupSpecifier(item.property || item.fieldName, 
                        item.grouping || item.groupingMode,
                        item.granularity || item.groupGranularity, 
                        item.precision || item.groupPrecision);
            if (spec) groupSpec.add(spec);
        }
    } else {
        groupSpec = null;
    }
    this.setGroupSpecifiers(groupSpec);
},

//> @attr listGrid.viewState (String : null : IRW)
// Initial +link{ListGridViewState, view state} for the grid.
// <P>
// Since view state contains field state it is not necessary
// to set +link{fieldState,fieldState} when also setting <code>viewState</code>.
// If both are provided, <code>fieldState</code> has priority for field state.
// <smartclient>
// <P>
// To retrieve current state call +link{ListGrid.getViewState,getViewState}.
// </smartclient>
//
// @group viewState
// @visibility external
//<

//> @method listGrid.setViewState()
// Reset this grid's view state to match the +link{type:ListGridViewState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to
// +link{listGrid.getViewState()}.
//
// @param viewState (ListGridViewState) Object describing the desired view state for the grid
// @group viewState
// @see listGrid.getViewState()
// @visibility external
//<
setViewState : function (state) {
    state = this.evalViewState(state, "viewState")
    if (!state) return;
    
    var fetchValueMap = this._fetchValueMap;

    // Order is somewhat important - for example show fields before potentially sorting
    // by them, etc
    if (state.field) this.setFieldState(state.field);
    
    
    if (state.group && state.group != "") this.setGroupState(state.group);
    
    if (state.sort && state.sort != "") this.setSortState(state.sort);
    if (state.hilite && state.hilite != "") this.setHiliteState(state.hilite);
    if (state.selected && state.selected != "") this.setSelectedState(state.selected);
    
    if (fetchValueMap && !this.isDrawn()) {
        
        this._fetchValueMap = true;
    }
},

// Group state changed. Fire both "groupStateChanged" and "viewStateChanged".
// These methods documented under stringMethods section.
handleGroupStateChanged : function () {
    // We call this method blindly from regroupFinished which may be due to
    // a true change of group state [group by new field, etc], or may be a simple
    // regroup to accomodate new data, etc.
    // Avoid calling the public notification if the groupState hasn't actually been
    // updated.
    
    
    var groupStateString = this.getGroupState();
    if (this.currentGroupState == groupStateString) return;
    this.currentGroupState = groupStateString;
    
    this.groupStateChanged();
    this.handleViewStateChanged();
    this._provideIsGroupedToRuleContext();
},
groupStateChanged : function () {},

// Fire the viewStateChanged notification. This is documented in registerStringMethods()

handleViewStateChanged : function () {
    this.fireOnPause("viewStateChangeNotification", {target:this,methodName:"viewStateChanged"}, 0);
},
getViewStateChangedFunction : function () {
    if (this._viewStateChangedFunction == null) {
        var grid = this;
        this._viewStateChangedFunction = function () {
            if (grid.destroyed) return;
            grid.viewStateChanged();
        };
    }
    return this._viewStateChangedFunction;
},
viewStateChanged : function() {
},

//> @method listGrid.setDataSource()
// @include dataBoundComponent.setDataSource()
// @visibility external
//<
// Override setDataSource() - we need to reset the stored filter criteria in case we are
// showing the filterEditor.
setDataSource : function (dataSource, fields) {
    // If we have a specified groupByField, ungroup when changing from one DataSource to another.
    // *Don't ungroup if we didn't have a dataSource before this method ran - this is likely to
    // happen on init when a developer can validly set groupBy before setting dataSource.
    
    var currentDS = this.getDataSource();
    if (currentDS != null && currentDS != dataSource && currentDS.ID != dataSource) {
        this.ungroup();
    }

    // discard edits as they don't apply to the new DataSource records
    
    
    this.discardAllEdits();
    // The edit row form has fields as defined in the previous datasource. Drop the form
    // so it will be recreated on the next edit attempt.
    if (this._editorShowing) this.hideInlineEditor();
    if (this._editRowForm) {
        this._editRowForm.destroy();
        delete this._editRowForm;
    }

    this.Super("setDataSource", arguments);
    this.clearFilterValues();
},


// determine which fields should be shown, and add them to the visible fields array.
// (Used as an internal helper - developers should call 'refreshFields' instead)
deriveVisibleFields : function () {
    // NOTE: we use setArray() so that this.fields remains the same array instance.
    this.fields.setArray(this.getVisibleFields(this.completeFields));
    delete this.fields._appliedInitialAutoFitWidth

    this.deriveFrozenFields();
    this.refreshMasterIndex();
},


//> @method ListGrid.refreshFields
// Re-evaluates +link{ListGridField.showIf} for each field, dynamically showing and
// hiding the appropriate set of fields
// @visibility external
//<
refreshFields : function () {
    // nothing to do if external code calls this method before setFields/draw
    if (!this.completeFields) return;
    // Just fall through to 'setFields()' for now
    
    this._suppressStoreFieldState = true;
    this._suppressBindToDS = true;
    this.setFields(this.completeFields);
    delete this._suppressBindToDS;
    delete this._suppressStoreFieldState;
},

//> @method ListGrid.getCurrentFieldWidths()
// Returns an array of widths of the visible fields in this <code>ListGrid</code>, in px.  This
// method is implemented by calling +link{ListGrid.getFieldWidth(),getFieldWidth()} for each field.
// If field widths cannot be determined, the returned array will contain nulls.
// @return (Array of Integer) field widths in px
// @visibility external
//<
getCurrentFieldWidths : function() {
    var widths = [];
    for (var i = 0; i < this.fields.length; i++) {
        widths[i] = this.getFieldWidth(i);
    }
    return widths;
},


getFieldWidths : function (reason) {
    // o appropriate time to get field widths:
    // LG w/ header:
    // - initially: right after we draw the header
    // - after setFields() header rebuilt: right after we rebuild the header
    // LG w/o header:
    // - initially: anytime before the body is drawn
    // - after setFields(): anytime before the body is redrawn

    var sizes = this._getCalculatedFieldWidths();
    // When autoFitFieldWidths is true, we may need to tweak these values to either
    // fill the available space, or clip certain fields if we're overflowing the
    // available space.
    // On drag-resize we set autoFitWidth to false on the field being dragged.
    // However we also want to suppress other fields' resizing (expanding to fill viewport
    // etc/ clipping to avoid h-scrollbars) or we'll get strange interactions with drag
    // similar to the problems if you re-evaluated "*" widths during drag
    if (this.autoFitFieldWidths && !this._calculatingAutoFitFieldWidths
        && !this._dragResizingField )
    {
        this._calculatingAutoFitFieldWidths = true;
        var unfrozenWidths = sizes.duplicate(),
            frozenWidths = null;

        if (this.frozenFields != null) {
            var left = this.freezeStart();
            if (left) {
                frozenWidths = unfrozenWidths.slice(0, this.frozenFields.length);
                unfrozenWidths = unfrozenWidths.slice(this.frozenFields.length);
            } else {
                frozenWidths = unfrozenWidths.slice(-this.frozenFields.length);
                unfrozenWidths = unfrozenWidths.slice(0, -this.frozenFields.length);
            }
        }
        
        var availableSpace = this.getAvailableFieldWidth(true),
            totalSize = unfrozenWidths.sum();

        var unfrozenSpace = availableSpace;
        if (frozenWidths != null) unfrozenSpace -= frozenWidths.sum();

        

        // Case 1: the fields don't fill the available space.
        // Expand the autoFitExpandField to fill the available space in the body.
        // Note: We don't auto-expand frozen fields - that would require resizing the
        // frozen body as well. The getAutoFitExpandField() method already handles not
        // returning frozen fields.
        // NOTE: If we're fitting to data, but data is currently loading, don't expand a field
        // now - wait until we redraw with loaded data. Otherwise we don't really know the
        // rendered sizes of all fields, so we won't know how much to expand the expansion field
        // by. Then when data arrives and the other fields all resize, we end up rendering the
        // expansion field potentially too wide since the other fields may now overflow available
        // space.
        
        var validData = true;
        if (this.autoFitWidthApproach != "title") {
            var dA = this.getDrawArea();
            // drawArea may be null if the body hasn't yet been created.
            if (!this.data || dA == null || Array.isLoading(this.data.get(dA[0]))) {
                validData = false;
            }
        }

        
        if (totalSize < unfrozenSpace && validData) {
            var expandField = this.getAutoFitExpandField();
            if (expandField) {
                // we want to update the sizes array (includes both frozen and
                // unfrozen fields) so get the global fieldNum for the expand field
                // and update that value.
                var expandFieldNum = this.getFieldNum(expandField);

                // limit growth of "expand field" to maxWidth
                var maxWidth = expandField.maxWidth || Infinity,
                    oldWidth = sizes[expandFieldNum],
                    newWidth = oldWidth + unfrozenSpace - totalSize;
                sizes[expandFieldNum] = newWidth  > maxWidth ? maxWidth : newWidth;

                // If we're showing a header for the field we have to resize
                // the button too so it stays in sync with the sizes array we
                // return (which will be applied to the body)
                var button = this.getFieldHeaderButton(expandFieldNum);
                if (button && button.isDrawn()) {
                    button.setWidth(sizes[expandFieldNum]);
                }
            }
        // case 2: the auto-fit fields are overflowing the available space, clip them
        // if appropriate.
        // Note: we don't clip frozen fields - that would require resizing the actual bodies.
        } else if (totalSize > unfrozenSpace && this.autoFitClipFields != null) {
            // If any autoFitFields are marked as clippable, and we're now overflowing
            // horizontally, we want to re-run stretchResize logic ignoring
            // calculated autoFit for those fields -- just let them take up the available
            // space.
            // If we're not showing a header this is easy
            // If we are (and autoFitWidthApproach includes the header title), we need to
            // have the header re-run it's logic so it takes account of other (non clippable)
            // fields' title-widths
            // This means reset it's policy to fill, resize our fields to "*", then reflow,
            // reset the policy back to whatever it was before (probably "none")
            var policy;
            var clipFields = this.autoFitClipFields;
            for (var i = 0; i < clipFields.length; i++) {
                var field = this.getField(clipFields[i]),
                    fieldNum = this.getFieldNum(field);
                if (field == null || fieldNum < 0) continue;

                // Don't attempt to clip frozen fields since that would require resizing
                // the frozen body.
                if (!this._suppressedFrozenFields && field.frozen) {
                    this.logInfo("auto-fitting field:" + field.name +
                        " is present in the autoFitClipFields array for this grid, but is" +
                        " currently frozen. This is not supported - the field will not be clipped.",
                        "frozenFields");
                    continue;
                }


                // deleting the calculated autoFitWidth ensures that when
                // _getCalcualtedFieldWidths runs stretchResizePolicy will simply resize
                // the row to fit if possible, or if a header is showing, the header reflow
                //.will achieve the same result.
                delete field._calculatedAutoFitWidth;
                var header = this.getFieldHeader(fieldNum);
                if (header && header.isDrawn()) {
                    button = header.getMember(this.getLocalFieldNum(fieldNum));
                    
                    button.setWidth(field.width || field.minWidth || "*");
                    
                    button.setOverflow("hidden");
                }
            }
            if (this.header && this.header.isDrawn()) {
                var reflowReason = this._$gettingFieldWidths;
                if (reason != null) reflowReason += reason;
                 policy = this.header.hPolicy;
                 this.header.hPolicy = "fill";
                this.header.reflowNow(reflowReason);
                this.header.hPolicy = policy;
                if (this.frozenHeader) {
                    this.frozenHeader.hPolicy = "fill";
                    this.frozenHeader.reflowNow(reflowReason);
                    this.frozenHeader.hPolicy = policy;
                }
            }
//            this.logWarn("after reflow..." + this.header.getMemberSizes());

            // rerun the method to get the stretch-resize calculated widths
            // (will run the appropriate logic based on whether or not we're showing
            // headers
            sizes = this._getCalculatedFieldWidths();
        }
        this._calculatingAutoFitFieldWidths = false;
    }

//     this.logWarn("getFieldWidths() ultimately gave sizes:" + sizes);

    return sizes;

},
_$gettingFieldWidths:"Getting listGrid fieldWidths. ",

// helper for getFieldWidths() - returns the stretch-resize calculated widths
// (based on the header if appropriate).
_getCalculatedFieldWidths : function () {


    

    var header = this.header;
    if (isc.isA.Layout(header) && header.isDrawn()) {
        
//        this.logWarn("using header-based field widths");
        
        // Handle the case where the header has been resized but the buttons are pending
        // a reflow
        
        if (header._layoutIsDirty) {
            header.reflowNow();
        }
        
        // Force an immediate redraw of any dirty buttons.
        // This is required to ensure sizes are correct -- if redrawOnResize is true for
        // the button or label with overflow:"visible", and setWidth() is called on it
        // the redraw isn't immediate - we need to force a redraw now if it hasn't occurred
        // so getVisibleWidth() returns the new size.
        var buttons = header.members;
        for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].isDirty()) buttons[i].redraw();
            if (buttons[i].label != null && buttons[i].label.isDirty()) buttons[i].label.redraw();
            
        
        }

        // derive field widths from header sizes
        var sizes = header.getMemberSizes();
        if (sizes.length > 0) {
            if (this.allowMismatchedHeaderBodyBorder) {
                
                var leftHeaderBorder = header.getLeftBorderSize() + header.getLeftMargin(),
                    rightHeaderBorder = header.getRightBorderSize() + header.getRightMargin();
                if (leftHeaderBorder != 0) {
                    sizes[0] += leftHeaderBorder;
                }
            }

            var totalSize = sizes.sum(),
                availableSpace = header.getInnerWidth();

            if (this.allowMismatchedHeaderBodyBorder) {
                var overflowAmount = totalSize - availableSpace;
                if (overflowAmount > 0) {
                    sizes[sizes.length-1] += Math.min(overflowAmount, rightHeaderBorder);
                }
            }
        }
        if (this.frozenFields) {
            var frozenWidths = this.frozenHeader.getMemberSizes();
            sizes.addListAt(frozenWidths, this.freezeStart() ? 0 : sizes.length);
        }


    } else {
//         this.logWarn("using stretchResize-based field widths");
        var sizes = this.getStretchResizeWidths();

    }
    return sizes;

},

// convenience method to redirect instance calls to implementation at class level
applyStretchResizePolicy : function (sizes, totalSize, minSize, modifyInPlace, callerMinSizes) {
    var thisClass = this.getClass(),
        policy = this.useOriginalStretchResizePolicy ? thisClass.applyStretchResizePolicy :
                                                    thisClass.applyNewStretchResizePolicy;
        return policy.call(thisClass, sizes, totalSize, minSize, modifyInPlace, this,
                           callerMinSizes);
},

getStretchResizeWidths : function () {
    var fields = this.fields;
    if (fields == null) return [];

    var useOriginal  = this.useOriginalStretchResizePolicy,
        ignoreLimits = this.ignoreStretchResizeMemberSizeLimits || useOriginal;

    var widths = fields.getProperty("width"),
        autoFitWidths = fields.getProperty("_calculatedAutoFitWidth"),
        hasDynamicDefaults = [];

    for (var i = 0; i < widths.length; i++) {
        
        if (autoFitWidths[i] != null) {
            // LGF.width acts as an additional minimum under the new policy
            if (!ignoreLimits && autoFitWidths[i] < fields[i].width) {
                autoFitWidths[i] = fields[i].width;
            }
            
            if (isc.isA.String(widths[i])) {
                hasDynamicDefaults.add(i);
            } else {
                if (widths[i] == null || widths[i] < autoFitWidths[i]) {
                    widths[i] = autoFitWidths[i];
                }
                // constrain numerical width of LGF with LGF.maxWidth/LGF.minWidth
                if (!ignoreLimits) {
                    var maxWidth = fields[i].maxWidth,
                        minWidth = fields[i].minWidth;
                    if (maxWidth != null && widths[i] > maxWidth) widths[i] = maxWidth;
                    if (minWidth != null && widths[i] < minWidth) widths[i] = minWidth;
                    // in addition to the field-specific limits, apply common minimum
                    if (widths[i] < this.minFieldWidth) widths[i] = this.minFieldWidth;
                }
            }
        }
    }

    // apply the stretch-resize policy to properly size any flexible-size LGF
    var innerWidth = this.innerWidth != null ? this.innerWidth : this.getAvailableFieldWidth(),
        calculatedWidths = this.applyStretchResizePolicy(widths, innerWidth, this.minFieldWidth,
                                                         false, autoFitWidths);

    
    if (useOriginal && hasDynamicDefaults.length > 0) {
        var fieldOverflowed = false;
        for (var i = 0; i < hasDynamicDefaults.length; i++) {
            var j = hasDynamicDefaults[i];
            if (calculatedWidths[j] < autoFitWidths[j]) {
                fieldOverflowed = true;
                widths[j] = autoFitWidths[j];
            }
        }
        if (fieldOverflowed) {
            calculatedWidths = this.applyStretchResizePolicy(
                widths,
                innerWidth,
                this.minFieldWidth
            );
        }
    }

    return calculatedWidths;
},

getAvailableFieldWidth : function (specifiedWidth) {
    
    if (specifiedWidth == null) {
        specifiedWidth = this.autoFitData != "both" && this.autoFitData != "horizontal";
    }

    var width = (!specifiedWidth
                    ? this.getVisibleWidth() : this.getWidth());
    
    return this._getInnerSpaceFromWidth(width);
},
_getInnerSpaceFromWidth : function (width) {
    width -= this.getHMarginBorderPad();
    // leave a gap for the scrollbar if vertical scrolling is on or if we're configured to
    // always leave a gap
    var leaveGap = this._shouldLeaveScrollbarGap();

    if (leaveGap) {
        width -= this.body ? this.body.getScrollbarSize() : this.getScrollbarSize();
    }
    return Math.max(1, width);
},



//> @method ListGrid.getFieldWidth()
// Returns a numeric value for the width of some field within this <code>ListGrid</code>.
// @param fieldNum (int | String) Index or name of the field for which the width is to be determined.
// @return (Integer) width of the field in px, or <code>null</code> if the width can't be determined.
// @visibility external
//<
getFieldWidth : function (fieldNum) {
    fieldNum = this.getFieldNum(fieldNum);
    if (fieldNum == -1 || !this.fields || fieldNum >= this.fields.length) return null;
    var width;
    if (this.body != null) width = this.getColumnWidth(fieldNum);
    if (width == null || isNaN(width)) width = this.getFieldWidths()[fieldNum];
    return width;
},

_adjustFieldSizesForBodyStyling : function (sizes, vertical) {
    if (vertical == null) vertical = false;

    if (sizes == null || sizes.length == 0) return sizes;

    
    if (!this.body) {
        
        return sizes;
    }

    // Adjust sizes of first and last field to account for styling on the body.
    
    sizes[sizes.length -1] =
        this._adjustLastFieldForBodyStyling(sizes[sizes.length-1], sizes.sum(), vertical);
    sizes[0] = this._adjustFirstFieldForBodyStyling(sizes[0], vertical);

    return sizes;
},

_adjustFirstFieldForBodyStyling : function (size, vertical) {
    if (!this.body) return size;

    // always knock the left (or top) border off the first field, otherwise everything starts
    // shifted too far right (or down)
    var bodyStartAdjust = (vertical ? this.body.getTopBorderSize() + this.body.getTopMargin()
                                    : this.body.getLeftBorderSize() + this.body.getLeftMargin());
    if (bodyStartAdjust != 0) size -= bodyStartAdjust;
    
    return Math.max(0, size);
},

_adjustLastFieldForBodyStyling : function (size, totalFieldsWidth, vertical) {
    if (!this.body) return size;

    // Figure out whether all the sizes will expand as far or further than the bottom or right
    // edge. If so we want to knock off the end border from the last col or row.
    var bodyEndAdjust = (vertical ? this.body.getBottomBorderSize() + this.body.getBottomMargin()
                                  : this.body.getRightBorderSize() + this.body.getRightMargin());

    if (bodyEndAdjust != 0) {
        
        var overflowAmount = totalFieldsWidth -
            (vertical ? this.body.getInnerHeight() : this.body.getInnerWidth());
        if (overflowAmount > 0) {
            size -= Math.min(overflowAmount, bodyEndAdjust);
        }
    }
    return Math.max(size,1);
},

setBodyFieldWidths : function (sizes) {
    // set the _fieldWidths array to the list passed in
    this._fieldWidths = sizes;

    // adjust the first / last column width for any left/right border or margin on the body.
    
    var origSizes = sizes;
    if (this.allowMismatchedHeaderBodyBorder) {
        if (isc.isAn.Array(sizes)) {
            sizes = this._adjustFieldSizesForBodyStyling(sizes.duplicate());
        }
    }

    // if we have frozenFields, separate out the sizes for those columns
    var frozenFields = this.frozenFields;
    
    if (frozenFields && this.frozenBody) {
        var frozenWidths = this.getFrozenSlots(sizes);
        sizes = this.getUnfrozenSlots(sizes);
        this.frozenBody.setColumnWidths(frozenWidths);

        var freezeWidth = frozenWidths.sum();
        // this will automatically cause the main body to size to fill remaining space
        this.frozenBody.setWidth(freezeWidth);
        
        this.frozenBody._userWidth = freezeWidth;
        if (this.frozenHeader) this.frozenHeader.setWidth(freezeWidth);
    }

    // give the GridRenderer new fieldWidths
    // will mark the body for redraw.
    if (this.body != null) this.body.setColumnWidths(sizes);
    // If we're showing the edit form, update the widths of the form items
    
    if (this._editorShowing) {
        var items = this._editRowForm.getItems(),
            record = this.getRecord(this.getEditRow()),

            // This method gives the widths of form items for every column - since
            // we only create a subset of form items, we won't use every one.
            
            completeFormFieldWidths = this.getEditFormItemFieldWidths(record);

        for (var i = 0; i < items.length; i++) {
            var colNum = items[i].colNum;

            if (items[i].width != completeFormFieldWidths[colNum])
                items[i].setWidth(completeFormFieldWidths[colNum]);
        }
    }
},

//> @type ListGridComponent
// Standard component-type displayed within a ListGrid, as contained by +link{listGrid.gridComponents}.
// @group appearance
// @value "filterEditor" The standard filter-component displayed when +link{listGrid.showFilterEditor}
//   is true
// @value "header" The header-component displayed when +link{listGrid.showHeader} is true.
// @value "body" The body component for the grid.
// @value "summaryRow" The summary-row component displayed when +link{listGrid.showGridSummary} is
//   true.
// @visibility external
//<

//> @attr listGrid.gridComponents (Array of ListGridComponent | Array of any : (see below) : IR)
// Array of components that make up this grid. This array controls which standard and/or custom
// parts will be displayed within this ListGrid.
// <P>
// ListGrid is a subclass of +link{VLayout} and consists of a number of member components. The
// standard set of members are automatically generated by the grid, and include (for example)
// the header (a Toolbar of buttons for each field) and the body
// (a GridRenderer displaying the actual data contained in the grid).<br>
// The default value of <code>gridComponents</code> is an Array of +link{ListGridComponent}s listing
// the standard components in their default order:
// <smartclient>
// <pre>
//    gridComponents : ["filterEditor", "header",
//                      "body", "summaryRow"]
// </pre>
// </smartclient>
// <smartgwt>
// <pre>
//    [ListGridComponent.FILTER_EDITOR, ListGridComponent.HEADER, ListGridComponent.BODY,
//     ListGridComponent.SUMMARY_ROW]
// </pre>
// </smartgwt>
//
// You can override <code>gridComponents</code> to change the order of standard components.
// You can also omit standard components this way, although it more efficient to
// use the related "show" property if available (eg +link{showFilterEditor}). Note that
// this array must contain an entry for the <code>"body"</code> - listGrids with no body showing
// are unsupported.<br>
// <i>Advanced note:</i> The live components generated for each of these standard
// +link{ListGridComponent} types may differ across different listGrids. For example if this
// grid has any +link{listGridField.frozen,frozen fields}, the "body" entry will actually
// be created as an HLayout containing two GridRenderers (one for frozen fields,
// and one for unfrozen fields). This is really an implementation detail - the "body" entry
// in the gridComponents array simply specifies where the UI for the body should render within
// the ListGrid layout.
// <P>
// By embedding a Canvas directly in this list you can add arbitrary additional components to the
// listGrid as members, and have them be displayed alongside the standard automatically generated
// parts of the ListGrid.
// <P>
// Note that having added controls to gridComponents, you can still call APIs directly on
// those controls to change their appearance, and you can also show() and hide() them if
// they should not be shown in some circumstances.
// <P>
// Tip: custom controls need to set layoutAlign:"center" to appear vertically centered.
//
// @visibility external
//<

gridComponents:[
    "filterEditor",
    "header",
    "body",
    "summaryRow"
],

getGridMembers : function () {
    var gridComponents = this.gridComponents,
        members = [],
        bodyShown;

    for (var i = 0; i < gridComponents.length; i++) {
        var component = gridComponents[i],
            liveComponent = null;

        // allow arbitrary canvii to be shoehorned into the grid.
        if (isc.isA.Canvas(component)) {
            liveComponent = component;

        } else if (isc.isA.String(component)) {

            if (!this.shouldShowGridComponent(component)) continue;

            // This isn't quite as simple as auto-children -- for example if we have
            // frozen fields we use a Layout to show the 2 bodies - otherwise we simply
            // add the body directly to ourselves as a child.
            switch (component) {
                case "filterEditor" :
                    if (this.filterEditor == null) this.makeFilterEditor();
                    liveComponent = this.filterEditor;
                    break;

                case "header" :
                    if (this.header == null) {
                        this.makeHeader();
                    }
                    liveComponent = this.headerLayout || this.header;
                    break;

                case "body" :
                    bodyShown = true;
                    
                    this.createBodies();
                    liveComponent = this.bodyLayout || this.body;
                    break;

                case "summaryRow" :
                    liveComponent = this.getSummaryRow();
                    break;

//                 default :
//                     this.logWarn("getGridComponents() - Hit default - unrecognized component " + component);
            }
        }
        // Handle being passed anything you could pass to "addChild" (EG "autoChild:foo") by
        // explicitly calling 'createCanvas'.
        if (component != null && liveComponent == null) {
            liveComponent = this.createCanvas(component);
        }
        members.add(liveComponent);
    }
    if (!bodyShown) {
        this.logWarn("ListGrid specified with gridComponents:" + gridComponents +
            ".  This does not include a \"body\" entry. ListGrids with no body are unsupported," +
            " displaying the body as the last member in the grid.");
        members[members.length] = this.createBodies();
    }
    return members;
},

showComponentPropertyMap:{
    header:"showHeader",
    filterEditor:"showFilterEditor",
    summaryRow:"showGridSummary"
},
_$body:"body", _$header:"header",
shouldShowGridComponent : function (component) {
    if (component == this._$body) return true;
    if (component == this._$header && this.headerHeight == 0) {
        return false;
    }

    var property = this.showComponentPropertyMap[component];
    if (property == null) {
        this.showComponentPropertyMap[component] = property =
                "show" + component.substring(0,1).toUpperCase + component.substring(1);
    }
    return this[property];
},

// createChildren - builds (or retrieves) our standard set of grid components and adds them
// to self as members
// Called from prepareToDraw, also from other cases where we need to refresh UI (EG showing/hiding
// filterEditor)

createChildren : function () {
    
    this.updateGridComponents();

    
    if (isc.Browser.isMoz && isc.Browser.geckoVersion >= 20051111) {
        if (this.header) {
            this.body.mozOutlineOffset = "0px";
            if (this.body.mozOutlineColor == null)
                this.body.mozOutlineColor = this.mozBodyOutlineColor;
        } else {
            if (this.body.mozOutlineColor == null)
                this.body.mozOutlineColor = this.mozBodyNoHeaderOutlineColor;
            this.body.mozOutlineOffset = "-1px";
        }
    }

    
    this._originalUseNativeTabIndex = this._useNativeTabIndex;
    this._useNativeTabIndex = false;
},

// actually creates the standard 'gridComponent' widgets and adds them as members.
// If components are already created they're just retrieved (not clobbered)
// If components are already members, the Layout 'setMembers' code should no-op.

updateGridComponents : function () {
    this.setMembers(this.getGridMembers());
},

// layoutChildren at the Layout level handles positioning and sizing members.
// We have to do a certain amount of tweaking to this, mainly to ensure we calculate field
// widths correctly, and, if we have frozen fields, assign sizes to the frozen header and body
// correctly.

layoutChildren : function (reason,b,c) {
    // If we've created our children, go ahead and call updateFieldWidths() to figure out
    // column sizes, and perform various member-management tasks.
    
    if (this.body != null) {
        // Note - If the grid as a whole was resized, our fields will potentially reflow. This could
        // change the required header heights in autoFitHeaderHeights mode, requiring
        // us to resize the header bar.
        // We already run the _updateHeaderHeight logic within updateFieldWidths so no
        // need to explicitly do that again here.
        this._updateFieldWidths(reason, b,c);
    }

    
    isc.VLayout._instancePrototype.layoutChildren.call(this,reason,b,c);

    if (this.body != null) {
        // Every time we layout children (may be due to body resize or body scroll change), if
        // we're showing the frozen body, ensure it's the correct (explicit) height
        if (this.frozenBody) {
            var adjustForHScroll = this.shrinkForFreeze && this.body.hscrollOn;
            var height = this.bodyLayout.getInnerHeight();
            if (adjustForHScroll) height -= this.body.getScrollbarSize();
            this.frozenBody.setHeight(height);
            if (this.frozenBody._needRowRedraw()) this.frozenBody.markForRedraw("height changed");
            // this will avoid the layout from scrapping this specified height on resize etc
            this.frozenBody._userHeight = height;
        }
    }
},


// override updateMemberTabIndex. If an explicit T.I. is set on the grid just apply it to all
// members

updateMemberTabIndex : function (newMember) {
    // If a developer specifies an explicit tab-index for a Layout as a whole, how to handle this?
    // For now just assign all members the same tab index
    if (this.tabIndex != null && !this._autoTabIndex && this.tabIndex != -1 &&
        // Skip this if we have a CanvasItem
        
        
        
            
        (this.canvasItem == null) &&
        (this.tabIndex < isc.Canvas.TAB_INDEX_FLOOR))
    {
        newMember.setTabIndex(this.tabIndex);
        return;
    }
    return this.Super("updateMemberTabIndex", arguments);
},

// If we're auto-fitting to our fields, we may have specified or calculated
// field widths that exceed the specified width for the widget as a whole (availableFieldWidth)
// In this case, use the greater value to size the header.
_updateHeaderWidth : function (fieldWidths, headerWidth, headerLayout) {

    

    // if autoFitMaxColumns is set, then limit the sum to the initially visible
    // columns; this prevents an infinite resizing loop where we try to resize
    // larger and other logic forces us back to a narrower width
    var maxColumns = this.autoFitMaxColumns;
    if (maxColumns != null) {
        if (this.frozenFields == null || this.freezeStart()) {
            fieldWidths = fieldWidths.slice(0, maxColumns);
        } else {
            var nFrozenFields = this.frozenFields.length;
            if (maxColumns < nFrozenFields) {
                fieldWidths = fieldWidths.slice(-nFrozenFields, -nFrozenFields + maxColumns);
            } else {
                var unfrozenFields = fieldWidths.slice(0, maxColumns - nFrozenFields);
                fieldWidths = fieldWidths.slice(-nFrozenFields);
                fieldWidths.addList(unfrozenFields);
            }
        }
    }
    var sum = fieldWidths.sum();

    // if autoFitMaxWidth is set, clip the sum based on its value
    var maxWidth = this.autoFitMaxWidth;
    if (maxWidth != null) {
        maxWidth = this._getInnerSpaceFromWidth(maxWidth);
    }
    if (maxWidth != null && sum > maxWidth) {
        sum = maxWidth;
    }

    // if width has increased, update header width or resize header layout
    if (sum > headerWidth) {
        if (headerLayout) headerLayout.resizeTo(sum);
        else headerWidth = sum;
    }

    return headerWidth;
},


_updateFieldWidths : function (reason, mustRefresh,c) {

    // don't do anything until we've created our children (eg resized before draw())
    if (this.body == null) return;
        
    // don't allow this method to fire recursively
    
    
    if (this._updatingFieldWidths) {
        if (mustRefresh) this._mustRefreshFieldWidths = true;
        return;
    } else {
        this._mustRefreshFieldWidths = false;
    }

    // getFieldWidths() will actually resize fields in order to handle the special cases
    // where we have autoFitWidths enabled plus expansion of an autoFitField to fill space
    // or clipping to avoid introducing hscrollbars.
    // Avoid running this method in response to a header-resized event from that resize
    
    if (this._calculatingAutoFitFieldWidths) {
        return;
    }
    // Similarly if an explicit autoFit (due to the user hitting the 'autoFitAllColumns'
    // menu item, don't react to things like the header width changing - we'll explicitly
    // size correctly as we go...
    
    if (this._autoFittingFields) {
        return;
    }
    
    this._updatingFieldWidths = true;
    

    // wipe out fieldWidths on resize so they'll be recalculated.
    
    var previousFieldWidths = this._fieldWidths;
    this._fieldWidths = null;

    // If any fields has autoFitWidth set to true, calculate the auto-fit size for the
    // column apply it to the field
    // Note that we only care about the cases where we're fitting to the body content - if
    // we're fitting to the header this is handled by simply setting overflow to "visible"
    // on the header button.

    
    if (reason !== this._$setFields && this.fields && !this.skipAutoFitWidths) {
        // The _appliedInitialAutoFitWidth flag allows us to avoid resizing
        // cols to fit content when this is not required. Should be cleared out
        // lazily by cases where we know content has changed and we should
        // reflow to accommodate it.
        if (!this.fields._appliedInitialAutoFitWidth) {
            var autoFitFieldWidths = this.getAutoFitValueWidths(null, true);
            if (autoFitFieldWidths == null) {
                this.fields.setProperty("_calculatedAutoFitWidth", null);
            } else {
            
                for (var i = 0; i < this.fields.length; i++) {
                    var field = this.fields[i];
                    if (autoFitFieldWidths[i] == null) {
                        field._calculatedAutoFitWidth = null;
                        continue;
                    }
                    var maxWidth = field.maxWidth || Infinity,
                        minWidth = this.getMinFieldWidth(field),
                        autoFitWidth = Math.min(autoFitFieldWidths[i], maxWidth);

                    var headerButton = this.getFieldHeaderButton(i);
                    if (headerButton != null) {
                        var isBoth = this.getAutoFitWidthApproach(field) == "both",
                            originalOverflow = headerButton.overflow,
                            overflowNotVisible = isBoth && (originalOverflow != "visible");
                        if (isBoth && overflowNotVisible) {
                            headerButton.setOverflow("visible");
                        }

                        if (minWidth < autoFitWidth) {
                            // update the header if there is one
                            // Note: If autoFitWidthApproach is "both", the header title can
                            // still overflow this new specified size (giving us the desired
                            // behavior of fitting to the larger of the 2 drawn sizes)
                            headerButton.setWidth(autoFitWidth);                            
                            headerButton.parentElement.reflow();
                        } else {
                            headerButton.setWidth(minWidth);
                            headerButton.parentElement.reflow();
                        }
                        
                        
                        if (headerButton.isDirty()) headerButton.redraw();
                        if (headerButton.label && headerButton.label.isDirty()) {
                            headerButton.label.redraw();
                        }
                        // If the autoFitWidth approach is "both" the header button
                        // may render wider than the specified width (overflow:"visible")
                        // In this case
                        // - we want the calculated autoFitWidth to be wider
                        // - we need to apply that wider size actually to the header button
                        //   (specified size is used directly in calculations
                        //   such as getFieldWidths()
                        if (isBoth) {
                            var headerDrawnWidth = headerButton.getVisibleWidth(),
                                expectedWidth = Math.max(minWidth, autoFitWidth);
                            if (headerDrawnWidth > expectedWidth) {
                                autoFitWidth = Math.min(headerDrawnWidth, maxWidth);
                                headerButton.setWidth(autoFitWidth);
                            }
                            
                            if (overflowNotVisible) {
                                headerButton.setOverflow(originalOverflow);
                            }
                        }
                    
                    }

                    field._calculatedAutoFitWidth = autoFitWidth;
                    var headerButton = this.getFieldHeaderButton(i);
                    if (headerButton != null) {

                        if (minWidth < autoFitWidth) {
                            // update the header if there is one
                            // Note: If autoFitWidthApproach is "both", the header title can
                            // still overflow this new specified size (giving us the desired
                            // behavior of fitting to the larger of the 2 drawn sizes)
                            headerButton.setWidth(autoFitWidth);
                            headerButton.parentElement.reflow();
                        } else {
                            headerButton.setWidth(minWidth);
                            headerButton.parentElement.reflow();
                        }
                    }

                }
                // Hang a flag on the array to avoid re-calculating the width every time we
                // run stretchResizePolicy, etc
                this.fields._appliedInitialAutoFitWidth = true;

                // Remember how big the grid as a whole is - if it resizes we may need to
                // resize the field that expands to fill available space.
                this._initialAutoFitGridWidth = this.getWidth();

            }

        } else if (this._initialAutoFitGridWidth != this.getWidth()) {
            var expandField = this.getAutoFitExpandField();
            if (expandField) {
                var expandFieldNum = this.getFieldNum(expandField);

                delete expandField._calculatedAutoFitWidth;

                // Pick up the autoFitValueWidth for the field in question
                
                var autoFitFieldWidths = this.getAutoFitValueWidths(null, true);
                if (autoFitFieldWidths) {
                    var autoFitValueWidth = autoFitFieldWidths[expandFieldNum];
                    if (isc.isA.Number(autoFitValueWidth)) {

                        var maxWidth = expandField.maxWidth || Infinity,
                            minWidth = this.getMinFieldWidth(expandField);

                        expandField._calculatedAutoFitWidth = 
                            Math.min(autoFitValueWidth, maxWidth);

                        // Note: If autoFitWidthApproach is "both", the header title can
                        // still overflow this new specified size (giving us the desired
                        // behavior of fitting to the larger of the 2 drawn sizes)
                        var headerButton = this.getFieldHeaderButton(expandFieldNum);
                        if (headerButton != null) {
                            headerButton.setWidth(Math.max(minWidth, autoFitValueWidth));
                            headerButton.parentElement.reflow();
                        }
                        this._initialAutoFitGridWidth = this.getWidth();
                    }
                }
            }
        }
    }

    
    var innerWidth = this.getAvailableFieldWidth(true),
        innerWidthChanged = (innerWidth != this.innerWidth);
    this.innerWidth = innerWidth;

//       this.logWarn("total columns width: " + innerWidth +
//                    (this.body ? ", vscrollon: " + this.body.vscrollOn : ""));

    var header = this.header,
        headerHeight = (this.showHeader ? this.getHeaderHeight() : 0);
    if (header != null) {
        
        // place the header
        // in RTL, sorter is on left
        var left = (this.isRTL() && this._showSortButton() ? this._getSorterWidth() : 0);

        
        header.hPolicy = "fill";
        if (this.frozenHeader) this.frozenHeader.hPolicy = "fill";
        var autoFitHorizontal = this.autoFitData == "horizontal" || this.autoFitData == "both",
            headerWidth = this.innerWidth,
            fieldWidths;

        
        if (autoFitHorizontal && this._dragResizingField) {
            fieldWidths = this.getFieldWidths(reason + " [sizing horizontal auto-fit header]");
            headerWidth = this._updateHeaderWidth(fieldWidths, headerWidth);
        }

        if (!this.leaveScrollbarGap && header.isDrawn() &&
            headerWidth != header.getWidth() && reason == "body scroll changed") {
            
            //this.logWarn("header changing size" + this.getStackTrace());
            if (this._settingBodyFieldWidths || !this.resizeFieldsForScrollbar) {
                header.hPolicy = "none";
            }
        }
        var headerLayout = this.headerLayout || header;
        
        headerLayout.resizeTo(headerWidth, headerHeight);
        
        headerLayout._userHeight = headerHeight;

        
        if (autoFitHorizontal && !this._dragResizingField) {
            fieldWidths = this.getFieldWidths(reason + " [sizing horizontal auto-fit header]");
            this._updateHeaderWidth(fieldWidths, headerWidth, headerLayout);
        }

        // if we're in the middle of the initial drawing process, draw the header now so we can
        // get fieldWidths from it to give to the body before it draws.  Also draw the header
        // if we're completely drawn and it's undrawn because it was just recreated.
        
        var isInitialDraw = (reason == "initial draw");
        if (!header.isDrawn() && (isInitialDraw || this.isDrawn())) {
            if (!this.frozenFields) {
                if (isInitialDraw) this._moveOffscreen(header);
                header.draw();
            } else {
                // running getFieldWidths before the header is drawn
                // to determine how much space will be required for the frozen header
                // (see _getCalculatedFieldWidths for explanation)
                if (fieldWidths == null) {
                    fieldWidths = this.getFieldWidths(reason + " [sizing frozen fields]");
                }
                var frozenWidths = this.getFrozenSlots(fieldWidths);
                var frozenWidth = frozenWidths.sum();
                this.frozenHeader.setWidth(frozenWidth);
                
                this.frozenHeader._userWidth = frozenWidth;
                if (isInitialDraw) this._moveOffscreen(this.headerLayout);
                this.headerLayout.draw()
            }
        }

        if (header.isDrawn()) header.hPolicy = "none";
        if (this.frozenHeader && this.frozenHeader.isDrawn()) this.frozenHeader.hPolicy = "none";

        // ensure the sorter is showing in the right place and visible / hidden as appropriate
        
        if (this.sorter) {
            this.updateSorter();
        }

        if (this.autoFitHeaderHeights) {
            var headerHeight = this.getHeaderHeight();
            this.dropCachedHeaderButtonHeights();
            var newHeaderHeight = this.getHeaderHeight();
            if (headerHeight != newHeaderHeight ||
                this.header.getHeight() != newHeaderHeight)
            {
                this.header.setHeight(newHeaderHeight);
                this._updateHeaderHeight();
            } else {
                if (this.headerSpans) {
                    this.header._adjustSpans(true);
                }
            }
        }

    }

    // if we haven't figure out field widths, this is the time to get them, since the header
    // has been drawn if we have one, and the body is yet to be drawn.
    // NOTE: if we are clear()d and then redrawn, and we have a header, we don't want to get
    // sizes from the header while it's undrawn, as it will not run the layout policy while
    // undrawn.
    if ((!this._fieldWidths || innerWidthChanged) &&
        ((header && header.isDrawn()) || headerHeight == 0))
    {
        var fieldWidths = this.getFieldWidths(reason);
        this.setBodyFieldWidths(fieldWidths);

        // update the filter editor field widths too [only need to worry about the body]
        if (this.filterEditor && this.filterEditor.body != null) {
            this.filterEditor.setBodyFieldWidths(this.filterEditor.getFieldWidths(reason));
        }

        // update the summaryRow (if visible)
        if (this.summaryRow && this.showGridSummary && this.summaryRow.body != null) {
            this.summaryRow.setBodyFieldWidths(fieldWidths.duplicate());
        }

        if (this.logIsDebugEnabled("layout")) {
            this.logDebug("new field widths: " + this._fieldWidths, "layout");
        }
    }

    // Normally we can rely on the standard layout behavior to size the filter editor.
    // however, if autoFitData is horizontal our content can exceed our specified size, and
    // the layout doesn't automatically handle expanding content to fit an overflowed breadth
    // Therefore in this case explicitly match the filter editor to the body width
    if (autoFitHorizontal && this.filterEditor) {
        this.filterEditor.setWidth(this.body.getVisibleWidth());
    }

    
    this._updatingFieldWidths = false;
    
    if (this.headerSpans != null && this.autoSizeHeaderSpans) {
        var changed = false;
        
        if (this._mustRefreshFieldWidths) {
            changed = true;
        } else if (this._fieldWidths != null && previousFieldWidths != null) {
            if (previousFieldWidths.length != this._fieldWidths.length) {
                changed = true;
            } else {
                for (var i = 0 ; i < previousFieldWidths.length; i++) {
                    if (previousFieldWidths[i] != this._fieldWidths[i]) {
                        changed = true;
                        break;
                    }
                }
            }
        }
        if (changed) {
            if (this._rerunningUpdateFieldWidths) {
                
            } else {
                this.logDebug("Re-running update field widths to account for header span auto-size");
                this._rerunningUpdateFieldWidths = true;
                var rerunReason = "Ensure header span and field sizes sync";
                if (reason != null) rerunReason += " [from " + reason + "]";
                this._updateFieldWidths(rerunReason);

            }
            this._rerunningUpdateFieldWidths = false;
        }
    }
},

//> @attr listGrid.autoFitHeaderHeights (boolean : null : IR)
// If this property is set to true, header buttons for either
// +link{listGrid.fields,fields} or +link{listGrid.headerSpans,header spans} will
// automatically expand to accommodate their titles vertically.
// This means if you have a "tall" title - typically a long string where
// +link{listGridField.wrap} is set to true such that you end up with several lines of
// text - the button will render large enough to accommodate it.
// If necessary this will cause the header for the grid as a whole to expand beyond the
// specified +link{listGrid.headerHeight}.
// @visibility external
//<



// get the "expected" height for field or span header-buttons based on
// this.headerHeight, span.height, etc.
getHeaderButtonDefaultHeight : function (span, recalculate) {
    if (recalculate || span._defaultHeight == null) {
        this.calculateDefaultSpanHeights();
    }
    return span._defaultHeight;
},

// Perform a one-time iteration through all header buttons determining
// "expected" heights based on header height etc, and cache these values.
calculateDefaultSpanHeights : function () {

    if (this.headerSpans == null) {
        // Shouldn't be called if headerSpans is null
        return;
    }

    if (this.headerSpans != null) {

        var fields = this.getFields(),
            fieldNames = fields.getProperty("name");
        for (var i = 0; i < this.headerSpans.length; i++) {
            var availableSpace = this.headerHeight,
                span = this.headerSpans[i];

            this._calculateDefaultSpanHeight(span, availableSpace, fieldNames);
        }
        for (var i = 0; i < fields.length; i++) {
            if (this.spanMap[fields[i].name] == null) {
                fields[i]._defaultHeight = this.headerHeight;
            }
        }
    }
},

// helper for calculateDefaultSpanHeights()
_calculateDefaultSpanHeight : function (span, availableSpace, fieldNames, isField) {
    if (!isField) {
        // Skip anything that isn't visible
        if (!this._headerSpanVisible(fieldNames, span)) return;

        var defaultHeight;
        if (!span._spanAutoSizeHeight) {
            defaultHeight = span.height || this.headerSpanHeight;
        }
        if (defaultHeight == null) {
            var spanDepth = this.getNestedSpanDepth(span);
            // add one to account for field at the bottom
            spanDepth += 1;
            defaultHeight = Math.floor(availableSpace / spanDepth);
        }
        span._defaultHeight = defaultHeight;
        availableSpace -= defaultHeight;

        if (span.spans) {
            for (var i = 0; i < span.spans.length; i++) {
                this._calculateDefaultSpanHeight(span.spans[i], availableSpace, fieldNames);
            }
        } else {
            for (var i = 0; i < span.fields.length; i++) {
                // skip hidden / missing fields
                var field = this.getField(span.fields[i]);
                if (field) {
                    this._calculateDefaultSpanHeight(field, availableSpace, fieldNames,
                        true);
                }
            }
        }
    } else {
        // not visible? Just bail
        if (!fieldNames.contains(span.name)) return;

        span._defaultHeight = availableSpace;
    }
},

getHeaderButtonMinHeight : function (field, recalculate) {
    if (!recalculate && field._calculatedMinHeight != null) {
        return field._calculatedMinHeight;
    }
    return this.getHeaderButtonMinHeights([field], recalculate)[0];
},

// Use an offscreen tester to figure out how much space is required for
// a field, or span header button based on its specified title.
// Caches the value for re-use
getHeaderButtonMinHeights :function (fields, recalculate) {
    var mustCalculate = [];
    var heights = [];
    var testHTML = "";
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        if (!recalculate && field._calculatedMinHeight != null) {
            heights[i] = field._calculatedMinHeight;
        } else {
            var isSpan = !this.fields.contains(field);
            var width;

            if (isSpan) {
                var spannedFields = this.getSpannedFields(field),
                    width = 0;
                //this.logWarn("fields:" + spannedFields);
                for (var ii = 0; ii < spannedFields.length; ii++) {
                    var spannedField = this.getField(spannedFields[ii]);
                    if (spannedField == null) {
                        continue;
                    }
                    width += this.getFieldWidth(spannedFields[ii]);
                }

            } else {
                width = this.getFieldWidth(field);
            }

            // XXX This basically matches framework behavior if we
            // don't see a useful numerical width. May want to revisit.
            if (isNaN(width)) {
                heights[i] = 1;
            } else {
                
                var baseStyle = field.headerBaseStyle,
                    buttonProperties = this.getHeaderButtonProperties();
                if (baseStyle == null) {
                    if (field.frozen && buttonProperties.frozenBaseStyle) {
                        baseStyle = buttonProperties.frozenBaseStyle;
                    } else if (buttonProperties.baseStyle) {
                        baseStyle = buttonProperties.baseStyle;
                    }
                }
                var titleStyle = field.headerTitleStyle;
                if (titleStyle == null) {
                    if (field.frozen && buttonProperties.frozenTitleStyle) {
                        titleStyle = buttonProperties.frozenTitleStyle;
                    } else if (buttonProperties.titleStyle) {
                        titleStyle = buttonProperties.titleStyle;
                    }
                }

                if (baseStyle == null || titleStyle == null) {
                    var buttonConstructor = this.headerButtonConstructor ||
                                this.header ? this.header.buttonConstructor
                                            : isc.Toolbar.getPrototype().buttonConstructor;
                    if (isc.isA.String(buttonConstructor)) {
                        buttonConstructor = isc[buttonConstructor];
                    }
                    if (baseStyle == null)  {
                        baseStyle = buttonConstructor.getPrototype().baseStyle;
                    }
                    if (titleStyle == null) {
                        titleStyle = buttonConstructor.getPrototype().titleStyle;
                    }
                }

                var title = isSpan ? field.headerTitle || field.title
                                 : this.getHeaderButtonTitle(field);
                var oldConfig = field._calculatedHeightConfig;

                if (oldConfig &&
                    oldConfig.baseStyle == baseStyle &&
                    oldConfig.titleStyle == titleStyle &&
                    oldConfig.width == width &&
                    oldConfig.wrap == field.wrap &&
                    oldConfig.title == title)
                {
                    field._calculatedMinHeight = oldConfig.height;
                    heights[i] = oldConfig.height;
                }
            }
        }
        if (heights[i] != null) continue;

        // At this point we want to actually measure the
        // height (and cache the result).

        var config = {};
        config.width = width;
        config.baseStyle = baseStyle;
        config.titleStyle = titleStyle;
        config.wrap = field.wrap;
        config.title = title

        mustCalculate.add({
            index:i,
            config:config
        });

        var buttonWrap = config.wrap;
        if (buttonWrap == null) buttonWrap = this.wrapHeaderTitles;
        testHTML += "<div style='position:absolute;width:" + width + "px;'><div class=" +
             (config.titleStyle || config.baseStyle) +
             (buttonWrap ? ">" : " style='white-space:nowrap;'>") +
             title +
             "</div></div>"
    }
    if (mustCalculate.length == 0) return heights;

    
    if (isc.ListGrid.headerHeightTester == null) {
        isc.ListGrid.headerHeightTester = isc.Canvas.create({
            overflow:"hidden",
            top:-1000,
            autoDraw:true,
            contents:testHTML
        });
    } else {
        isc.ListGrid.headerHeightTester.setContents(testHTML);
    }
    // immediate redraw (setContents does a delayed redraw)
    if (isc.ListGrid.headerHeightTester.isDirty()) isc.ListGrid.headerHeightTester.redraw();

    var handle = isc.ListGrid.headerHeightTester.getHandle(),

    childNodes = handle.childNodes;
    if (childNodes.length != mustCalculate.length) {
        
    }
    for (var i = 0; i < childNodes.length; i++) {
        var div = childNodes[i];

        var config = mustCalculate[i].config,
            index = mustCalculate[i].index,
            field = fields[index];

        config.height = div.offsetHeight;
        field._calculatedHeightConfig = config;
        field._calculatedMinHeight = config.height;

        heights[index] = config.height;
    }
    return heights;
},

// Drops the cached expected (default) and min-heights for all fields / header spans
dropCachedHeaderButtonHeights : function () {
    for (var i = 0; i < this.fields.length; i++) {
        this.fields[i]._defaultHeight = null;
        this.fields[i]._calculatedMinHeight = null;
        if (this.spanMap) {
            var span = this.spanMap[this.fields[i].name];
            while (span != null) {
                span._defaultHeight = null;
                span._calculatedMinHeight = null;
                span = span.parentSpan;
            }
        }
    }
},

// getHeaderHeight() - if autoFitting headers vertically, this method will calculate
// the required height for the header-bar as a whole and return it
// (Otherwise returns specified header height).
getHeaderHeight : function () {
    if (this.headerHeight == 0 || !this.showHeader) return 0;
    if (!this.autoFitHeaderHeights) return this.headerHeight;

    var minHeight = 0;
    if (this.headerSpans == null) {
        minHeight = this.headerHeight;
        var fields = this.getFields();

        var fieldHeights = this.getHeaderButtonMinHeights(fields);
        minHeight = Math.max(minHeight, fieldHeights.max());

    } else {

        var fields = this.getFields(),
            fieldColHeight = 0;

        // We've found that redraws are a significant bottleneck and that
        // redrawing the offscreen header height tester for every field and every
        // span is expensive.
        // Cut this down by passing all fields into getMinHeights... then all
        // spans (two redraws total rather than one per button)
        var fieldMinHeights = this.getHeaderButtonMinHeights(fields),
            spans = [];

        for (var i = 0; i < fields.length; i++) {
            if (this.spanMap[fields[i].name]) {
                var span = this.spanMap[fields[i].name];
                while (span) {
                    if (!spans.contains(span)) {
                        spans.add(span);
                    }
                    span = span.parentSpan;
                }
            }
        }

        
        var spanMinHeights = this.getHeaderButtonMinHeights(spans);
        for (var i = 0; i < fields.length; i++) {
            fieldColHeight = Math.max(
                                this.getHeaderButtonDefaultHeight(fields[i]),
                                this.getHeaderButtonMinHeight(fields[i])
                             );
            if (this.spanMap[fields[i].name]) {
                var span = this.spanMap[fields[i].name];
                while (span) {

                    fieldColHeight +=  Math.max(
                                        this.getHeaderButtonDefaultHeight(span),
                                        this.getHeaderButtonMinHeight(span)
                                       );
                    span = span.parentSpan;
                }
            }

            minHeight = Math.max(minHeight, fieldColHeight);
        }

    }
    return Math.max(minHeight, this.headerHeight);
},

// getAutoFitValueWidths: Calculates the auto-size width based on rendered field values
// Returns a sparse array of field sizes indexed by fieldNum in this.fields.
// By default expects no params and returns only auto-size width of the fields marked with
// autoFitWidth:true.
// If fields are passed in directly we'll calculate sizes for those fields only (regardless of
// any per-field autoFitWidth settings)
getAutoFitValueWidths : function (fields, checkApproach) {
    if (this.data == null) return;
    if (isc.isA.ResultSet(this.data)) {
        var drawArea = this.body.getDrawArea();
        if (!this.data.rangeIsLoaded(drawArea[0], drawArea[1])) {
            // If we're autofitting all fields, and data is loading, mark for resize
            // again - will occur on redraw from dataChanged/dataArrived
            if (fields == null) {
                this.updateFieldWidthsForAutoFitValue("Delayed resize pending data load");
            }
            return;
        }
    } else if (isc.isA.ResultTree(this.data)) {
        var data = this.data,
            root = data.getRoot();
        
        if (!root || 
            (data.getLoadState(root) != isc.Tree.LOADED && 
             data.getLoadState(root) != isc.Tree.LOADED_PARTIAL_CHILDREN))
        {
            this.updateFieldWidthsForAutoFitValue("Delayed resize pending tree data load");
            return;
        }
    }

    var noAutoFit = (fields == null);
    if (fields == null) {
        fields = [];
        for (var i = 0; i < this.fields.length; i++) {
            var field = this.fields[i];
            
            if (this.shouldAutoFitField(field)) {
                // checkApproach - if passed don't collect valueWidths unless the field's
                // autoFitWidthApproach is 'value' or 'both'
                if (!checkApproach || this.getAutoFitWidthApproach(field) != "title") {
                    fields.add(field);
                    noAutoFit = false;
                }
            }
        }
    }
    if (noAutoFit) return [];

    // widths will be a sparse array containing just the calculated field widths
    var widths = [],
        checkAutoFitWidths = false,
        frozenAutoFitFields = [], frozenAutoFitColNums = [],
        autoFitFields = [], autoFitColNums = [];

    for (var i = 0; i < this.fields.length; i++) {
        if (fields.contains(this.fields[i])) {
            var field = this.fields[i];
            // call getDefaultFieldWidth per field with the special flag to
            // suppress checking autoFitWidths
            // If we get back any nulls (indicating we hit this) pass these to
            // the getColumnAutoSize() method directly.
            // It's more efficient to pass a number of cols to that method
            // at once, but we also want a custom "getDefaultFieldWidth" implementation
            // to behave as expected so it's a viable override point for customizing this
            // behavior.
            var defaultWidth = this.getDefaultFieldWidth(this.fields[i], true);
            if (defaultWidth == null) {
                checkAutoFitWidths = true;
                if (field.frozen) {
                    frozenAutoFitFields.add(this.getLocalFieldNum(i));
                    frozenAutoFitColNums.add(i);
                } else {
                    
                    autoFitFields.add(this.getLocalFieldNum(i));
                    autoFitColNums.add(i);
                }
            } else {
                widths[i] = defaultWidth;
            }
        }
    }
    if (checkAutoFitWidths) {

        if (frozenAutoFitFields.length > 0) {
            var bodyWidths = this._getBodyColumnAutoSize(true, frozenAutoFitFields);
            if (bodyWidths != null) {
                for (var i = 0; i < bodyWidths.length; i++) {
                    widths[frozenAutoFitColNums[i]] = bodyWidths[i];
                }
            }
        }

        if (autoFitFields.length > 0) {
            var bodyWidths = this._getBodyColumnAutoSize(false, autoFitFields);
            if (bodyWidths != null) {
                for (var i = 0; i < bodyWidths.length; i++) {
                    widths[autoFitColNums[i]] = bodyWidths[i];
                }
            }
        }
    }
    return widths;
},

// Helper to call gridRenderer logic to get auto-fit widths for a number of fields.
_getBodyColumnAutoSize : function (frozen, localFieldNums) {
    var body = frozen ? this.frozenBody : this.body;
    if (body == null) return null;
    var bodyWidths = body.getColumnAutoSize(localFieldNums);
    if (this.includeGridSummaryInAutoFitWidth &&
        this.showGridSummary && this.summaryRow != null)
    {
        var summaryBody = (frozen ? this.summaryRow.frozenBody : this.summaryRow.body);
        if (summaryBody != null) {
            var summaryWidths = summaryBody.getColumnAutoSize(localFieldNums);
            if (summaryWidths != null) {
                if (bodyWidths == null) bodyWidths = [];
                for (var i = 0; i < summaryWidths.length; i ++) {
                    if (bodyWidths[i] == null ||
                        summaryWidths[i] > bodyWidths[i]) bodyWidths[i] = summaryWidths[i];
                }
            }
        }
    }
    // In setBodyFieldWidths, we automatically adjust body col sizes (shrink them)
    // to avoid the body styling from impacting the overall width of the body - required
    // to support mismatched header/border styling.
    // Preemptively expand the calculated "auto fit" width so doing this won't eat into
    // that space
    if (this.allowMismatchedHeaderBodyBorder && bodyWidths != null) {
        var body = frozen ? this.frozenBody : this.body,
            firstIndex = localFieldNums.indexOf(0),
            lastIndex = localFieldNums.indexOf(
                            (frozen ? this.frozenFields.length : this.fields.length)-1);
        if (firstIndex != -1) {
            bodyWidths[firstIndex] =  bodyWidths[firstIndex] +
                                        body.getLeftBorderSize() + body.getLeftMargin();
        }
        if (lastIndex != -1) {
            bodyWidths[lastIndex] =  bodyWidths[lastIndex] +
                                        body.getRightBorderSize() + body.getRightMargin();
        }
    }
    return bodyWidths;
},

//> @attr listGrid.iconPadding (integer : 2 : IR)
// When using +link{autoFitFieldWidths}, padding in pixels left on each side of fields that
// show images.
// @visibility external
//<

//> @method listGrid.getDefaultFieldWidth()
// Method to calculate and return the default width of a field. This method is called
// to calculate the size of each field's content as part of the
// +link{listGrid.autoFitFieldWidths,field auto fit} behavior. Note that this method
// returns a size for <i>content</i>, so will not be consulted if
// +link{listGridField.autoFitWidthApproach,autoFitWidthApproach} is set 
// to <code>"title"</code>.
// <P>
// If +link{listGridField.defaultWidth} is specified, this will be returned.
// <P>
// Otherwise, the default implementation varies by +link{ListGridFieldType,field type}.
// For fields of type <code>"icon"</code>, or fields which show only a
// +link{ListGridField.valueIcons,valueIcon} as a value, and for boolean fields which
// show a checkbox value, the width will be calculated based on the icon size and
// +link{listGrid.iconPadding}.
// For other fields the +link{getFieldContentWidth()} method will be used to calculate
// a width based on the rendered width of content. Note that for
// <code>"image"</code> type fields, this method will rely on the +link{listGridField.imageWidth}
// being specified.
// <P>
// Note that this width is the default width of "content" - it does not take into account
// the rendered size of the field title.
//
// @param field (ListGridField) Field for which the size should be determined
// @return (int) default size required for the field's content.
//
// @visibility external
//<

iconPadding:2,
getDefaultFieldWidth : function (field, suppressAutoFitWidths) {

    var width;
    
    // If an explicit, static 'defaultWidth' was specified on the field, respect it.
    if (field.defaultWidth != null) return field.defaultWidth;

    // special cases where we can avoid writing out and measuring content
    if (field.type == "icon" && (field.iconWidth != null || field.iconSize != null)) {
        return (field.iconWidth || field.iconSize) + 2*this.cellPadding + 2*this.iconPadding;
    } else if (this.showValueIconOnly(field)) {
        width = this.getValueIconWidth(field) + (2* this.cellPadding) +
                              this.getValueIconRightPadding(field) +
                              this.getValueIconLeftPadding(field);
        

        
        if (this.showFilterEditor && this.fields != null && this.fields.length > 0) {
            var fieldAlign = field.cellAlign || field.align;
            if (fieldAlign === this._$center && field === this.fields[this.fields.length - 1]) {
                width += 2 * this._getSorterWidth();
            }
        }

        return width;
    }
    if (suppressAutoFitWidths) {
        return null;
    }
    
    return this.getFieldContentWidth(field);
},

//> @method listGrid.getFieldContentWidth()
// Returns the pixel width of the content of a visible field in this grid.
// @param field (ListGridField) field to test
// @return (Integer) drawn width of this fields content
// @visibility external
//<
getFieldContentWidth : function (field) {

    var width,
        fieldNum = this.getFieldNum(field),
        localFieldNum = this.getLocalFieldNum(fieldNum);
    var widths = this._getBodyColumnAutoSize(field.frozen, [localFieldNum]);
    width = widths ? widths[0] : null;
    if (width == null) width = field.width;
    return width;
},

getAutoFitWidthApproach : function (field) {
    if (field.autoFitWidthApproach != null) return field.autoFitWidthApproach;
    return this.autoFitWidthApproach;
},

draw : function (a,b,c,d) {
    if (isc._traceMarkers) arguments.__this = this;
    if (!this.readyToDraw()) return this;

    // set a flag that prevents sortChanged() from firing during initial draw
    this._firstDraw = true;

    // set a flag that prevents sortChanged() from firing during initial draw
    this._firstDraw = true;

    // create children and set up fields if not already set up
    this.prepareForDraw();

    // call the superclass draw routine to do the actual drawing
    this.invokeSuper(isc.ListGrid, "draw", a,b,c,d);

    // clear the flag that prevents sortChanged() from firing during initial draw
    delete this._firstDraw;

    // get the actual rendered sizes of the columns
    this.body.getColumnSizes();

    
    for (var i = 0; i < this.bodies.length; i++) {
        var body = this.bodies[i];
        if (body._embeddedComponents) this.markForRedraw();
    }

    // if the sortFieldNum is specified, tell the header about it
    var sortFieldNum = this._getSortFieldNum();
    if (this.header && sortFieldNum != null && this.selectHeaderOnSort) {
        this.selectSortFieldHeaderButton();
    }

    // scroll the header along with the list (necessary for textDirection == RTL)
    this.bodyScrolled(this.body.getScrollLeft(), this.body.getScrollTop());

    
    if (this.sorter) this.updateSorter();

    // If we have embedded components ensure that our initial auto-fit widths take
    // their size into account.
    if (this.body._embeddedComponents ||
        (this.frozenBody && this.frozenBody._embeddedComponents))
    {
        this.updateFieldWidthsForAutoFitValue("Initial draw with embeddedComponents");
    }
    
    this._wasEmptyForCanFocus = this.isEmpty();

    
    if (isc.Browser.isIE && this.header && this.headerSpans && this.autoFitWidthApproach == "both") {
        this.header.layoutChildren();
    }

    // Register for ruleContextChanged events so dynamic criteria can be re-evaluated
    if (!isc.isA.PickListMenu || !isc.isA.PickListMenu(this)) {
        this._observeRuleContextChanged();
    }        

    return this;
},

// should we show inactive editors for every record - returns true if we have any data and
// alwaysShowEditors is true at the grid or field level [can check specific fields]
_alwaysShowEditors : function (field, ignoreTotalRows) {
    // ignoreTotalRows -- useful to test whether we would ever show editors in every cell
    // as opposed to whether we currently do.

    // if we have no data don't show any edit cells
    if (!ignoreTotalRows && this.getTotalRows() == 0) return false;

    if (this.alwaysShowEditors) return true;
    var fields = field ? [field] : this.fields;
    if (fields) {
        for (var i = 0; i < fields.length; i++) {
            if (fields[i].alwaysShowEditors) {
                return true;
            }
        }
    }
    return false;
},

prepareForDraw : function () {
    

    var pendingGroup = this.groupByField && !this.isGrouped;

    
    if (this.data) {
        this.data._deferCacheInvalidation = pendingGroup;
    }

    // call setFields() for the first time, if it hasn't already been done
    if (this.completeFields == null) this.setFields(this.fields);

    if (this.data) {
        delete this.data._deferCacheInvalidation;
    }

    // if alwaysShowEditors is true, ensure we are editing
    if (this.getEditRow() == null) {
        var forceEditing = this._alwaysShowEditors();
        if (forceEditing) this.startEditing(null,null,true,null,true);
    }

    // if grid is not grouped, and a grouping is already set, apply it with groupBy
    if (pendingGroup) {
            var fields = this.getGroupByFields();
            this.groupByField = null;

        // if we have no fields don't call groupBy yet - should occur on setFields
        //if (this.fields != null)
            this.groupBy(fields);
        }

    // create the header and body.
    this.createChildren();
},

//> @method listGrid.getGroupByFields()
// Get the current grouping of this listGrid as an array of fieldNames.
// <P>
// This method returns an array containing the names of the field(s) by which this
// grid is grouped (either from +link{listGrid.groupByField} having been explicitly set or
// from a call to +link{listGrid.groupBy()}). If this grid is not currently grouped, this method
// will return null.
// @return (Array of String) Current grouping for this grid. If grouped by a single field an array
//  with a single element will be returned.
// @visibility external
//<

getGroupByFields : function () {
    var fields = this.groupByField;
    if (fields != null && !isc.isAn.Array(fields)) {
        fields = [fields];
    }
    return fields;
},

//> @method listGrid.openGroup()
// Opens the node represented by the "record" parameter, if it is a folder and is not already
// open.  This method only applies to +link{ListGrid.groupBy,grouped} ListGrids.
// @param record (Record) node to open
// @return (boolean) true if the node was opened, false if it was not (either because it is not
//                   a folder, or because it was already open)
// @visibility external
//<
openGroup : function (record) {
    if (isc.isA.Tree(this.data) && record.isFolder) {
        if (!this.data.isOpen(record)) {
            this.openFolder(record);
            return true;
        }
    }
    return false;
},

//> @method listGrid.closeGroup()
// Closes the node represented by the "record" parameter, if it is a folder and is not already
// closed.  This method only applies to +link{ListGrid.groupBy,grouped} ListGrids.
// @param record (Record) node to close
// @return (boolean) true if the node was closed, false if it was not (either because it is not
//                   a folder, or because it was already closed)
// @visibility external
//<
closeGroup : function (record) {
    if (isc.isA.Tree(this.data) && record.isFolder) {
        if (this.data.isOpen(record)) {
            this.closeFolder(record);
            return true;
        }
    }
    return false;
},


prepareForDestroy : function (indirectDestroy) {
    if (this._dragLine) {
        this._dragLine.destroy();
        this._dragLine = null;
    }
    if (this._cornerMenu) this._cornerMenu.destroy();
    if (this.spanContextMenu) this.spanContextMenu.destroy();
    if (this.cellContextMenu) this.cellContextMenu.destroy();
    if (this._editRowForm) {
        this._editRowForm.destroy();
        delete this._editRowForm;
        delete this._editorShowing;
    }

    if (this.data){
        // if the data was autoCreated, destroy it to clean up RS<->DS links
        if (this.data._autoCreated && isc.isA.Function(this.data.destroy)) {
            this.data.destroy();
        } else {
            // ignore so we don't leak memory from the observation references
            this._ignoreData(this.data, true);
            delete this.data;
        }
    }
    // If we are grouped our ResultSet may be stored under this.originalData
    // Clean this up too (otherwise we can end up with the DataSource attempting to
    // notify a destroyed ListGrid via it's orphaned resultSet)
    if (this.originalData){
        if (this.originalData._autoCreated && isc.isA.Function(this.originalData.destroy)) {
            this.originalData.destroy();
        } else {
            this._ignoreData(this.originalData, true);
            delete this.originalData;
        }
    }

    if (this.selection) {
        this.destroySelectionModel();
    }
    if (this.selectionCanvas) this.selectionCanvas.destroy();
    if (this.selectionUnderCanvas) this.selectionUnderCanvas.destroy();
    if (this.currentRollOverCanvas) this.currentRollOverCanvas.destroy();
    if (this.currentRollUnderCanvas) this.currentRollUnderCanvas.destroy();

    this._dropODSData();

    // RecordComponents:
    // - if pooling mode is recycled, destroy any created recordComponents sitting in our pool.
    // - if pooling mode is data, destroy any created recordComponents that got scrolled out
    //   of view and never destroyed.
    
    var recordComponents = this.getRecordComponentPool();
    if (recordComponents) {
        for (var i = 0; i < recordComponents.length; i++) {
            var comp = recordComponents[i];
            if (comp && comp.destroy && !comp.destroyed) {
                if (!comp.dontAutoDestroy) comp.destroy();
                else comp.deparent();
            }
        }
    }
    if (this._orphanedRecordComponents != null) {
        for (var ID in this._orphanedRecordComponents) {
            var comp = this._orphanedRecordComponents[ID];
            if (!comp || comp.destroyed || comp.destroying
                || comp._pendingDestroy)
            {
                continue;
            }
            if (!comp.dontAutoDestroy) comp.destroy();
            else comp.deparent();
        }
    }

    this.Super("prepareForDestroy", arguments);
},

//> @method listGrid.redrawHeader()
// Redraw just the +link{listGrid.header,grid header} 
//
// @param   rightNow (boolean) If true, redraw the grid header with a direct inline call
//          to its redraw() method.  Otherwise, 
//          +link{canvas.markForRedraw,mark the header for redraw}
// @visibility external
//<
redrawHeader : function(rightNow) {
    var headerLayout = this.headerLayout || this.header;
    if (headerLayout) {
        if (rightNow) {
            headerLayout.redraw(this.ID + ": redrawHeader()");
        } else {
            headerLayout.markForRedraw(this.ID + ": redrawHeader()");
        }
    }
},

//> @method listGrid.getBaseStyle()
// Return the base styleName for this cell.  Has the following implementation by default:
// <ul>
// <li>If +link{listGrid.editFailedBaseStyle, this.editFailedBaseStyle} is defined, and the
//     cell is displaying a validation error return this value.</li>
// <li>If +link{listGrid.editPendingBaseStyle, this.editFailedPendingStyle} is defined, and
//     the cell is displaying an edit value that has not yet been saved (see
//     +link{ListGrid.autoSaveEdits}) return this value.</li>
// <li>Otherwise return +link{ListGrid.recordBaseStyleProperty, record[listGrid.recordBaseStyleProperty]},
//     if defined, otherwise +link{ListGridField.baseStyle, field.baseStyle}.</li>
// </ul>
// If no custom style is found for the cell as described above, the default baseStyle will be
// returned. If +link{listGrid.baseStyle} is specified this will be used. Otherwise for
// grids showing fixed height rows which match +link{listGrid.normalCellHeight}
// +link{listGrid.normalBaseStyle} will be used. For grids with variable, or modified
// cell heights, +link{listGrid.tallBaseStyle} will be used.
// <P>
// Note also that
// enabling +link{listGrid.fastCellUpdates} will cause the <code>tallBaseStyle</code> to be
// used rather than +link{listGrid.normalBaseStyle}.
// <P>
// As noted under +link{listGrid.enforceVClipping}, cell content which renders taller than the
// available space within a cell may cause rows to expand even if +link{listGrid.fixedRecordHeights} 
// is true. This can lead to misaligned rows when frozen columns are used.
// Developers should be aware that changing cell styling such that there is increased
// borders or padding will reduce the available space for content within the specified cell height,
// making this scenario more common. To fix this, specify a larger cellHeight, or set
// enforceVClipping to true.
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
//
// @see getCellStyle()
//
// @param [record] (ListGridRecord) Record associated with this cell. May be <code>null</code>
//                                  for a new edit row at the end of this grid's data set.
// @param   rowNum  (number)    row number for the cell
// @param   colNum  (number)    column number of the cell
// @return  (CSSStyleName)  CSS class for this cell
// @visibility external
// @example replaceStyle
//<
getBaseStyle : function (record, rowNum, colNum) {

    
    if (this.canEdit == true && !this.isPrinting) {
        if (this.editFailedBaseStyle && this.cellHasErrors(rowNum, colNum))
            return this.editFailedBaseStyle;

        if (this.editPendingBaseStyle && this._cellHasChanges(rowNum, colNum, false, true))
            return this.editPendingBaseStyle;
    }

    if (this.originBaseStyle && this.selection._isCellSelectionOrigin(rowNum, colNum)) {
        return this.originBaseStyle;
    }

    if (record && this.recordBaseStyleProperty && record[this.recordBaseStyleProperty])
        return record[this.recordBaseStyleProperty];

    var field = this.getField(colNum);
    if (field && field.baseStyle) return field.baseStyle;

    if (field && field.type == "summary" && this.recordSummaryBaseStyle)
        return this.recordSummaryBaseStyle;

    if (field && field.frozen && !this._suppressedFrozenFields && this.frozenBaseStyle) {
        return this.frozenBaseStyle;
    }

    if (this.isPrinting && (this.printBaseStyle != null)) return this.printBaseStyle;

    var baseStyle = this.baseStyle;
    if (baseStyle == null) {
        if (this.cellHeight != this.normalCellHeight ||
            
            this.fastCellUpdates ||
            this.allowRowSpanning ||
            !this.shouldFixRowHeight(record, rowNum) ||
            
            (record != null && this._hasEmbeddedComponents(record)))
        {
            baseStyle = this.tallBaseStyle;
        } else {
            baseStyle = this.normalBaseStyle;
        }
    }
    return baseStyle;
},

getCellCSSText : function (record, rowNum, colNum) {
    var field = this.getField(colNum),
        cssText;

    // per-record cssText
    if (record) {
        
        if (!record._isGroup && this.fieldSourceGrid == null && field != null && this.showValueIconOnly(field)) {
            cssText = "line-height:0px;";
        }

        var recordCSSText = record[this.recordCSSTextProperty];
        if (recordCSSText != null) {
            return cssText != null ? cssText + recordCSSText : recordCSSText;
        }
    }

    var removedCSSText = this.removedCSSText;
    if (this.recordMarkedAsRemoved(rowNum) && removedCSSText) {
        cssText = cssText != null ? cssText + removedCSSText : removedCSSText;
    } else {

        if (this.isEditable()) {
            var editCSSText;
            if (this.editFailedBaseStyle == null && (editCSSText = this.editFailedCSSText) &&
                this.cellHasErrors(rowNum, colNum))
            {
                cssText = cssText != null ? cssText + editCSSText : editCSSText;
            } else if (this.editPendingBaseStyle == null && (editCSSText = this.editPendingCSSText) &&
                this._cellHasChanges(rowNum, colNum, false, true))
            {
                cssText = cssText != null ? cssText + editCSSText : editCSSText;
            }
        }
    }

    
    cssText = this.getRecordHiliteCSSText(record, cssText, this.getField(colNum), true);

    return cssText;

},

//> @method listGrid.getRawCellValue()
//      @group  data
//          return the raw data for one particular cell in the list
//
//      @param  record      (object)    a record in the data
//      @param  recordNum   (number)    number of that record (in case it's important for the output)
//      @param  fieldNum    (number)    number of the field to display
//
//      @return (string)    raw value for this cell
//<

getRawCellValue : function (record, recordNum, fieldNum, isFieldName) {
    return this._getRawCellValue(
        this.emptyCellValue, this.groupSummaryRecordProperty, this.gridSummaryRecordProperty,
        null, null, this.data, this.applyFormulaAfterSummary, null, null, null, null,
        record, recordNum, fieldNum, isFieldName);
},
_getRawCellValue : function (
    emptyCellValue, groupSummaryRecordProperty, gridSummaryRecordProperty,
    fieldsHaveUserFormulas, fieldsHaveUserSummaries, data, applyFormulaAfterSummary,
    fieldHasUserFormula, fieldUserFormula, fieldHasUserSummary, fieldUserSummary,
    record, recordNum, fieldNum, isFieldName)
{
    // If `getRawCellValue()` is overridden in a subclass then use that.
    if (this.getRawCellValue != isc.ListGrid.getInstanceProperty("getRawCellValue")) {
        return this.getRawCellValue(record, recordNum, fieldNum, isFieldName);
    }

    var field,
        fieldName,
        dataPath;

    if (isFieldName) {
        fieldName = fieldNum
        // when fieldName specified, search completeFields if available
        field = this.completeFields ? isc.Class.getArrayItem(fieldName, this.completeFields, this.fieldIdProperty) : this.getField(fieldName);
    } else {
        field = this.fields[fieldNum];
        fieldName = field ? field[this.fieldIdProperty] : fieldName;
    }
    if (fieldHasUserFormula == null) {
        fieldHasUserFormula = (field && field.userFormula != null);
    }
    if (fieldHasUserFormula && fieldUserFormula == null) {
        fieldUserFormula = field.userFormula;
    }
    if (fieldHasUserSummary == null) {
        fieldHasUserSummary = (field && field.userSummary != null);
    }
    if (fieldHasUserSummary && fieldUserSummary == null) {
        fieldUserSummary = field.userSummary;
    }
    
    dataPath = field ? this.getTrimmedFieldDataPath(field) : null;

    if (fieldName == null && dataPath == null) return emptyCellValue;
    // Note even if fieldName is set, field is not guaranteed to be present - this could
    // be a displayField which is being rendered in a different field's cell

    var editValue, value, undef;
    
    if (this._editRowMap != null && this._editRowMap[recordNum] != null) {
        editValue = this._getEditValue(recordNum, fieldNum);
    }
//this.logWarn("GRCV is running - row/col:" + [recordNum, fieldNum], editVal:" + editValue);

    if (editValue !== undef) {
        // This ensures that the value for the cell as it is currently stored for local editing
        // is displayed, rather than the saved value of the cell.
        
        return editValue;
    // record can be null if there's no record for this cell
    } else if (record == null) {
        return emptyCellValue;

    // show the result of getRecordSummary for summary fields
    // Note that if shouldApplyRecordSummaryToRecord is true it's already stored on the record
    // object so we've already picked it up
    
    } else if (
        this._shouldShowRecordSummary(
            groupSummaryRecordProperty, gridSummaryRecordProperty, field,record) &&
        !this.shouldApplyRecordSummaryToRecord(field))
    {
        value = this._getRecordSummary(
            fieldsHaveUserFormulas, fieldsHaveUserSummaries, recordNum, field);

    // Default - just look at the record.
    } else {

        // let the dataset return a value if it supports doing so
        
        if (data.getFieldValue && field) {
            value = data.getFieldValue(record, dataPath, field, this, "getRawValue");

        } else if (record.ownerDocument && field) {
            // if working with XML, fetch values via XPath selectors if so configured.  (Needed
            // for viewing XML elements when not dataBound, but could be moved to be a built-in
            // feature of both List and native Array)
            
            value = isc.xml.getFieldValue(record, fieldName, field);
        } else {
            value = isc.Canvas._getFieldValue(dataPath, field, record, this, true, "getRawValue");
            if (value == null) value = record[fieldName];
        }
    }

    // if the field has a 'getRawCellValue' attribute
    
    if (field && field.getRawCellValue) {
        // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "getRawCellValue", "viewer,record,recordNum,field,fieldNum,value");

        // call it as a function (returns string | null)
        value = field.getRawCellValue(this, record, recordNum, field, fieldNum, value);
    }

    // handle user-formula and user-summary fields
    
    if (field) {

        if (this._shouldApplyUserFormulaAfterSummary(
                applyFormulaAfterSummary, fieldHasUserFormula, field) &&
            this._shouldShowUserFormula(
                groupSummaryRecordProperty, applyFormulaAfterSummary, field, record))
        {
            var currentUserFormula = field.userFormula;
            field.userFormula = fieldUserFormula;
            value = this.getFormulaFieldValue(field, record);
            field.userFormula = currentUserFormula;
        }
        // note: actual value computed later (after formatters have been applied
        // to raw value) - see getSummaryFieldValue() call in getFormattedCellValue
        if (fieldHasUserSummary) {
            var currentUserSummary = field.userSummary;
            field.userSummary = fieldUserSummary;
            this.getSummaryFunction(field);
            field.userSummary = currentUserSummary;
        }
    }
    return value;
},

// shouldShowRecordSummary - returns true if this is a summary field unless
// this is a summary row and there's an explicit summaryFunction (which takes precedence over
// any record summary function).

_$summary:"summary",
shouldShowRecordSummary : function (field, record) {
    return this._shouldShowRecordSummary(
        this.groupSummaryRecordProperty, this.gridSummaryRecordProperty, field, record);
},
_shouldShowRecordSummary : function (
    groupSummaryRecordProperty, gridSummaryRecordProperty, field, record)
{
    if (field && field.type == this._$summary) {
        if (record[groupSummaryRecordProperty]) {
            return (field.summaryFunction == null && field.getGroupSummary == null);
        
        } else if (record[gridSummaryRecordProperty]) {
            return (field.summaryFunction == null && field.getGridSummary == null);
        }
        return true;
    }
    return false;
},

// shouldShowUserFormula - As with record summaries, if you have a formula field
// you likely do not want the field-level record-formula to show in a summary row
// - instead the grid or group summary should be displayed as the field value.
shouldShowUserFormula : function (field, record) {
    return this._shouldShowUserFormula(
        this.groupSummaryRecordProperty, this.applyFormulaAfterSummary, field, record);
},
_shouldShowUserFormula : function (
    groupSummaryRecordProperty, applyFormulaAfterSummary, field, record)
{
    var isSummary = this._isSummaryRow ||
                     (record && record[groupSummaryRecordProperty]);
    if (isSummary && !this.__applyFieldFormulaAfterSummary(applyFormulaAfterSummary, field)) {
        return false;
    }
    return true;
},

//> @attr listGrid.applyFormulaAfterSummary (Boolean : false : IRW)
// If +link{listGridField.userFormula} is set for some field, and this grid is showing
// +link{listGrid.showGroupSummary,group summaries} or a
// +link{listGrid.showGridSummary,grid summary}, this property determines what field value
// should be present in those summary rows. Should the field apply the user-formula to the
// calculated summary row, or should it apply a standard grid or group summary to the
// user-formula values displayed in the grid?
// <P>
// May be overridden at the field level via +link{listGridField.applyAfterSummary}
// @visibility external
//<

applyFormulaAfterSummary:false,




//> @attr listGrid.skipHiddenUserSummaryFields (boolean : null : IRW)
// Controls whether hidden fields are included when user formulas are calculated
// for fields where +link{listGridField.applyAfterSummary} is false (also
// controls "record summary" fields - where the field type is "summary").
//<
//> @attr listGrid.skipHiddenGridSummaryFields (boolean : null : IRW)
// Controls whether calculation of grid summaries does anything for
// hidden fields.  If this property is true, grid summaries will only
// be calculated for visible fields.
//<
//> @attr listGrid.skipHiddenGroupSummaryFields (boolean : null : IRW)
// Controls whether calculation of group summaries does anything for
// hidden fields.  If this property is true, group summaries will only
// be calculated for visible fields.
//<

//> @attr listGrid.refreshDependentFieldsForSummaries (Boolean : true : IRW)
// When summaries are refreshed, and a list of fields is passed to limit what's refreshed,
// should the dependent fields automatically be added to ensure they're included?
//<
refreshDependentFieldsForSummaries: true,

// If we have a formulaField, how should the cell value in a summary row be calculated?
// if applyFormulaAfterSummary is true we'll calculate summary row values and apply
// the field-formula to that calculated row. Otherwise we will display "normal" summary
// values for the field in the row (for example summing all the calculated values in the
// formula field).
_applyFieldFormulaAfterSummary : function (field) {
    return this.__applyFieldFormulaAfterSummary(this.applyFormulaAfterSummary, field);
},
__applyFieldFormulaAfterSummary : function (applyFormulaAfterSummary, field) {
    var applyAfterSummary = field && field.applyAfterSummary;
    if (applyAfterSummary == null) applyAfterSummary = applyFormulaAfterSummary;
    if (applyAfterSummary == null) applyAfterSummary = false;
    //this.logWarn("For field:" + field.name + ", applyFormulaAfterSummary:" + applyAfterSummary);
    return applyAfterSummary;
},

_$blank: "blank",
_getCheckboxValueIconHTML : function (isSel, isPartial, canSelect, disabled, field) {
    var icon,
        iconStyle;
    if (!canSelect) {
        // record cannot be selected but we want the space allocated for the checkbox anyway.
        icon = this._$blank;
    } else {
        var isPrinting = this.isPrinting;

        // checked if selected, otherwise unchecked
        var booleanBaseStyle = (isPrinting
                                ? this.printBooleanBaseStyle || this.booleanBaseStyle
                                : this.booleanBaseStyle);
        if (isSel) {
            if (isPartial) {
                icon = (isPrinting
                        ? this.printCheckboxFieldPartialImage || this.checkboxFieldPartialImage ||
                          this.printBooleanPartialImage || this.booleanPartialImage
                        : this.checkboxFieldPartialImage || this.booleanPartialImage);
                iconStyle = booleanBaseStyle == null ? null : booleanBaseStyle + "Partial";
            } else {
                icon = (isPrinting
                        ? this.printCheckboxFieldTrueImage || this.checkboxFieldTrueImage ||
                          this.printBooleanTrueImage || this.booleanTrueImage
                        : this.checkboxFieldTrueImage || this.booleanTrueImage);
                iconStyle = booleanBaseStyle == null ? null : booleanBaseStyle + "True";
            }
        } else {
            icon = (isPrinting
                    ? this.printCheckboxFieldFalseImage || this.checkboxFieldFalseImage ||
                      this.printBooleanFalseImage || this.booleanFalseImage
                    : this.checkboxFieldFalseImage || this.booleanFalseImage);
            iconStyle = booleanBaseStyle == null ? null : booleanBaseStyle + "False";
        }
        if (icon == null) icon = this._$blank;
    }
    // if the record is disabled, make the checkbox image disabled as well
    if (disabled) {
        if (icon != this._$blank) icon = isc.Img.urlForState(icon, false, false, isc.StatefulCanvas.STATE_DISABLED);
        if (iconStyle != null) iconStyle += isc.StatefulCanvas.STATE_DISABLED;
    }
    if (icon == this._$blank) icon = isc.Canvas._nullSrcPlaceholder;

    var extraExtraStuff;
    if (iconStyle != null) {
        extraExtraStuff = "class='" + iconStyle + this._$singleQuote;
    }
    return this.getValueIconHTML(icon, field, extraExtraStuff);
},

//> @method listGrid.getCellValue()   ([A])
//          Obtains the display value for a specific cell according to the given input
//          parameters.<br>
//          To format the value displayed in the cell, make use of the
//          +link{listGrid.formatCellValue(),formatting} methods rather than 
//          overriding this method directly.
//      @visibility external
//      @group  data
//
//      @param  record      (object)    the current record object
//      @param  recordNum   (number)    number of the record in the current set of displayed
//                                      record (e.g. 0 for the first displayed record)
//      @param  fieldNum    (number)    number of the field in the listGrid.fields array
//
//      @see    method:ListGrid.formatCellValue
//      @return (string)    display value for this cell
//<
_$HR:"<HR>",
getCellValue : function (record, recordNum, fieldNum, gridBody) {

    if (gridBody == null) gridBody = this.getFieldBody(fieldNum);

    // If we're handed an empty record, we may be looking at a new edit row - if so get
    // the edit values instead
    if (record == null) {
        if (this.showNewRecordRow && this._isNewRecordRow(recordNum)) {
            return this.getNewRecordRowCellValue();
        }
        record = this._getEditValues(recordNum, fieldNum);
    } else {

        // Special cases:
        // if it's a separator row, return a horizontal rule
        
        if (record[this.isSeparatorProperty]) return this._$HR;

        // group controller node - write out the groupNodeHTML
        if (record._isGroup && fieldNum != null) {

            var currentField = this.fields[fieldNum],
                groupTitleField = this.getGroupTitleField(),
                isGroupTitleField;
            if (groupTitleField == null) {
                isGroupTitleField = currentField._isGroupTitleColumn;
            } else {
                isGroupTitleField = currentField.name == groupTitleField;
            }
            
            if (this.showGroupSummaryInHeader && currentField.name == record.groupName) {
                
                var summaries = record._groupSummaryData && record._groupSummaryData[0];
                if ((!summaries || !summaries[currentField.name]) && currentField.masterIndex != 0) return isc.nbsp;
            }

            // If we're showing multiple fields and we're not showing a summary in the
            // header, explicitly empty all fields except the groupTitleField
            var isCheckboxField = this.isCheckboxField(this.getField(fieldNum));
                
            if ((!this.canSelectGroups || !isCheckboxField) &&
                ((this.singleCellGroupHeaders() && !gridBody._gettingAutoSizeHTML) 
                    || isGroupTitleField))
            {
                return this.getGroupNodeHTML(record, gridBody);
            } else if (isCheckboxField ?
                        !this.canSelectGroups :
                        !this.showGroupSummaryInHeader)
            {
                return isc.nbsp;
            }
        }
    }

    // get the actual data record
    var field = this.fields[fieldNum],
        value = null;

    // if field is null, we've shrunk the number of columns, so forget it
    if (field == null) return isc.emptyString;

    // if this is a summary row and the field has a summaryValue specified, return that - all
    // the special fields (rowNumber, checkbox, expansion, remove) set this value to "&nbsp;"
    if (this._isSummaryRow && field.summaryValue) {
        return field.summaryValue;
    }

    // If this is the checkboxField, write out the checkbox HTML
    
    if (this.isCheckboxField(field)) {
        return this._getCheckboxValueIconHTML(!!this.selection.isSelected(record),
                                              this.showPartialSelection && 
                                                !!this.selection.isPartiallySelected(record),
                                              this.body.canSelectRecord(record),
                                              record && record[this.recordEnabledProperty] == false,
                                              field);
    }

    // Determine whether we should be showing JUST a valueIcon
    // Do this before we figure out other HTML to avoid calculating stuff we're not going to
    // actually use.
    var icon,
        iconStyle,
        iconOnly = this.showValueIconOnly(field),
        isEditCell;
    if (record != null) {

        
        if (record[this.singleCellValueProperty] != null) {
            return record[this.singleCellValueProperty];
        }

        if (Array.isLoading(record)) {
            
            if (!isc.Browser.isSafari || fieldNum == 0) {
                return this.loadingMessage;
            }
            return isc.nbsp;
        }

        // If we are currently editing there are three possibilities for what we should write
        // out for each cell:
        // - This cell is being edited -- write out the edit form's element HTML
        // - This cell has pending edit values, but is not currently being edited.
        //   (this can happen if we're editing another cell in this row, or if an edit was not
        //   successfully saved for this cell) -- display the edit values.
        // - This cell should display the value for the record (default behavior)
        // We catch the first case here, and write out the edit-form item into the cell if
        // appropriate.
        // The other two cases will be handled by 'getRawCellValue()', which will check for
        // the presence of editValues on a cell.
        

        // if rowSpanning is enabled, and the user starts editing a row that
        // is spanned by some cell, behavior is governed by rowSpanEditMode:
        // - if rowSpanEditMode is "first", canEditCell will return false for the
        //   logical cell so we won't show an editor in the cell.
        // - otherwise, we show an editor in the cell and populate it with values
        //   based on the edit row.
        //   This means the value displayed in the editor will come from the
        //   edit-row, whereas the value displayed while not in edit mode comes from
        //   the first spanned record (by default).
        //   In this case the edit-value displayed may be different to the static
        //   value displayed in the spanning cell.
        //   The developer might use this mode if they have some advanced behavior like
        //   custom formatters that render a value for every spanned record, etc
        var editRowNum = this._editRowNum,
            editStartRow = editRowNum;
        if (editStartRow != null && this.allowRowSpanning) {
            editStartRow = this.getCellStartRow(editStartRow, fieldNum);
        }
        isEditCell = (this._editorShowing && editStartRow == recordNum &&
                      (!this.editByCell || this._editColNum == fieldNum) &&
                      
                      this.canEditCell(editRowNum, fieldNum));
        if (isEditCell) {
            var editRecord = record;
            if (editRowNum != recordNum) {
                editRecord = this.getCellRecord(editRowNum, fieldNum);
            }
            // Avoid writing out live form items if we're just getting HTML for the
            // GR auto-sizer canvas.
            
            if (gridBody._gettingAutoSizeHTML) {
                value =this.getInactiveEditorCellValue(editRecord, editRowNum, fieldNum);
            } else {
                value = this.getEditItemCellValue(editRecord, editRowNum, fieldNum);
            }
        // Checking for this._editorShowing would mean that when changing edit cell,
        // hideInlineEditor would render the row with no inactive editors, and they
        // wouldn't get shown again on showEditForm for the new cell without another
        // row-refresh
        } else if (this._showInactiveEditor(fieldNum) && this.canEditCell(recordNum,fieldNum)) {

            value = this.getInactiveEditorCellValue(record, recordNum, fieldNum);
            // set isEditCell -- this will suppress the standard 'valueIcon' stuff
            isEditCell = true;
        } else {
            // get the value according to the field specification
            var field = this.fields[fieldNum],
                displayFieldValue,
                pickUpDisplayFieldValue,
                undef;
            // If a displayField was specified on the field, and no separate optionDataSource,
            // we should display the value for the record from the displayField rather than the
            // data field.
            if (field.displayField != null) {
                pickUpDisplayFieldValue = !field.valueMap &&
                                          !field.getCellValue &&
                                          // this method actually checks for field.valueMap
                                          // being non null
                                          this._useDisplayFieldValue(field) &&
                                          // Do not pick up the display value if it is undefined
                                          // on the record, unless there is a current edited value 
                                          // for the field (because getRawCellValue() returns the
                                          // correct edited value in that case)
                                          (record[field.displayField] !== undef ||
                                           this._getEditValue(recordNum, field.displayField) != undef);

                if (pickUpDisplayFieldValue) {
                    var displayField = field.displayField;
                    displayFieldValue = this.getRawCellValue(record, recordNum, displayField, true);
                }
                // Note: we still need to proceed through the rest of the logic, since the
                // underlying data value drives the valueIcon
            }
            value = this.getRawCellValue(record, recordNum, fieldNum);
            // if the field has a 'getCellValue' attribute
            // NOTE: this is deprecated - overriding 'getCellValue()' at the Grid level is very
            // advanced, so for simple formatting (which is likely to be done at either the Field
            // or Grid level) we provide 'formatCellValue()' methods instead.)
            // Leave this code in place for Back-compat only.

            //>!BackCompat 2005.1.12
            if (field.getCellValue) {
                // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value"
                // Convert a string callback to a function
                isc.Func.replaceWithMethod(field, "getCellValue",
                                                 "viewer,record,recordNum,field,fieldNum,value");
                value = field.getCellValue(this, record, recordNum, field, fieldNum, value);
            }
            //<!BackCompat

            
            icon = this.getValueIcon(field, value, record, recordNum);
            iconStyle = this.getValueIconStyle(field, value, record, recordNum);

            // if we're ONLY showing an icon we don't really need to figure out the text from
            // the valueMap.
            if (!iconOnly) {

                // if the field has an 'valueMap' parameter, treat the value as a key in the map
                var valueMap = field.valueMap;
                if (valueMap) {
                    value = this.resolveValueMap(value, field.valueMap);
                }
            }

            if (pickUpDisplayFieldValue) value = displayFieldValue;
        }
    }

    if (!isEditCell) {

        // If this is a summary row, avoid calling formatCellValue at all if we're not showing
        // a summary for the field.
        if (record &&
            ((record[this.groupSummaryRecordProperty] && !this.shouldShowGroupSummary(field)) ||
             (this._isSummaryRow &&
                ((record[this.gridSummaryRecordProperty] && !this.shouldShowGridSummary(field))
                 || (field.showGridSummary == false))
             )
            )
           )
        {
            value = this.emptyCellValue;
        } else {

            // If this cell isn't showing an editor we may need to write out an icon
            
            var iconHTML = null;

            if (icon != null) {
                var iconExtraExtraStuff = iconStyle == null ? null : "class='" + iconStyle + this._$singleQuote;
                iconHTML = this.getValueIconHTML(icon, field, iconExtraExtraStuff);
            }

            if (iconOnly) {
                // If there's no icon write out the empty cell value. This avoids us having
                // un-styled cells.
                if (!iconHTML || isc.isAn.emptyString(iconHTML)) iconHTML = this.emptyCellValue;
                value = iconHTML;
            } else {

                // apply hilites to capture htmlBefore/after
                var hilites = this.getFieldHilites(record, field);
                // Note hilites can == 0, so if(hilites) doesn't work

                var hiliteAfterFormat = field.hiliteHTMLAfterFormat;
                if (hiliteAfterFormat == null) hiliteAfterFormat = this.hiliteHTMLAfterFormat;
                if (hiliteAfterFormat == null) hiliteAfterFormat = true;
                if (hiliteAfterFormat) {
                    value = this._formatCellValue(value, record, field, recordNum, fieldNum);
                    // Note that hilites can == 0, so if (hilites) doesn't work
                    if (hilites != null) value = this.applyHiliteHTML(hilites, value);
                } else { 
                    if (hilites != null) value = this.applyHiliteHTML(hilites, value);
                    value = this._formatCellValue(value, record, field, recordNum, fieldNum);
                }
                if (iconHTML) {
                    if (field.valueIconOrientation != isc.Canvas.RIGHT)
                        value = iconHTML + value;
                    else
                        value = value + iconHTML;
                }
            }

            // Only show error icon HTML if we're not showing an editor for the cell - otherwise
            // we'd get doubled error icons.
            if (this.isEditable() && this.showErrorIcons && this.cellHasErrors(recordNum, fieldNum)) {
                value = this.getErrorIconHTML(record, recordNum, fieldNum) + value;
            }

            // Add the hiliteIcons last
            var field = this.fields[fieldNum];
            var hilites = this.getFieldHilites(record, field);
            // Note that hilites can == 0, so if(hilites) won't work
            if (hilites != null) {
                if (!record || (record && !record.isGroupSummary) || (this.showHilitesInGroupSummary && field.showHilitesInGroupSummary != false)) {
                    value = this.applyHiliteIcon(hilites, field, value);
                }
            }
        }
    }
    // if current field is the groupTitleField, add indentation to the cell value
    var gtf = this.isGrouped ? this.getGroupTitleField() : null;
    if (gtf && this.fields[fieldNum].name == gtf) {
        var groupIndent =
            isc.Canvas.spacerHTML(this.groupIndentSize + this.groupLeadingIndent, 1);
        value = groupIndent + value;
    }
    return value;
},

//> @method listGrid.cellValueIsClipped()
// @include gridRenderer.cellValueIsClipped()
//<
cellValueIsClipped : function (rowNum, colNum) {
    var body = this.getFieldBody(colNum);
    colNum = this.getLocalFieldNum(colNum);
    return body.cellValueIsClipped(rowNum, colNum);
},

resolveValueMap : function (value, valueMap) {
    // NOTE: this can be really expensive, since we may eval the function that
    // returns the value map for each record!!!
    if (isc.isA.String(valueMap)) valueMap = this.getGlobalReference(valueMap);
    // NOTE: don't look up displayed values in Array valueMaps, which just list legal
    // values, and don't provide stored->displayed value mappings.
    if (!isc.isAn.Array(valueMap)) {
        if (isc.isAn.Array(value)) {
            var displayValue = [];
            for (var i = 0; i < value.length; i++) {
                var dataVal = isc.getValueForKey(value[i], valueMap, value[i]);
                displayValue[displayValue.length] = dataVal;
            }
            value = displayValue;
        } else {
            value = isc.getValueForKey(value, valueMap);
        }
    }
    return value;
},

// Formula/summary -related overrides from DBC
getTitleFieldValue : function (record) {
    var titleField = this.getDataSource().getTitleField(),
        title = this.getCellValue(record, this.getRecordIndex(record),
            this.getFieldNum(titleField), this.body
    );

    if (!title || title == "") {
        title = this.getRawCellValue(record, this.getRecordIndex(record), titleField, true);
    }
    return title;
},

getRawValue : function (record, fieldName) {
    var recordIndex = this.getRecordIndex(record);
    
    return this.getRawCellValue(record, recordIndex, fieldName, true);
},

getFormattedValue : function (record, fieldName, value) {
    var recordIndex = this.getRecordIndex(record),
        field = this.getSpecifiedField(fieldName),
        fieldNum = this.getFieldNum(fieldName);

    if (this.fieldIsVisible(field) && value == null) {
        return this.getCellValue(record, recordIndex, fieldNum, this.body);
    }
    if (value == null) value = this.getRawValue(record, fieldName);
    // if the field has an 'valueMap' parameter, treat the value as a key in the map
    var valueMap = field ? field.valueMap : null;
    if (valueMap) {
        // NOTE: this can be really expensive, since we may eval the function that
        // returns the value map for each record!!!
        if (isc.isA.String(valueMap)) valueMap = this.getGlobalReference(valueMap);
        // NOTE: don't look up displayed values in Array valueMaps, which just list legal
        // values, and don't provide stored->displayed value mappings.
        if (!isc.isAn.Array(valueMap)) {
            if (isc.isAn.Array(value)) {
                var displayValue = [];
                for (var i = 0; i < value.length; i++) {
                    var dataVal = isc.getValueForKey(value[i], valueMap, value[i]);
                    displayValue[displayValue.length] = dataVal;
                }
                value = displayValue;
            } else {
                value = isc.getValueForKey(value, valueMap);
            }
        }
    }
    var ret = this._formatCellValue(value, record, field, recordIndex, fieldNum);
    return ret;

},


// get the width of the specified field or null
getSpecifiedFieldWidth : function (fieldName) {

    var field = this.getField(fieldName);
    if (field == null) {
        // field may just be hidden - if so check for an explicit width on the
        // field object in our completeFields array and return that
        if (isc.isAn.Object(fieldName)) fieldName = fieldName[this.fieldIdProperty];
        field = this.getSpecifiedField(fieldName);
    }
    if (field == null) return;

    var fieldName = field[this.fieldIdProperty],
        members = this.header ? this.header.members : null,
        frozenMembers = this.frozenFields && this.frozenHeader ? this.frozenHeader.members : null,
        width;

    if (members || frozenMembers) {
        var member;
        
        if (members) member = members.find(this.fieldIdProperty, fieldName);
        if (!member && frozenMembers) {
            member = frozenMembers.find(this.fieldIdProperty, fieldName);
        }
        if (member) {
            if (member._userWidth && isc.isA.Number(member._userWidth)) {
                width = member._userWidth;
            }
        // If we don't have a member for the field, look at the specified width and
        // use it if possible.
        // This can happen if a field is currently hidden
        } else {
            if (field.width != null && isc.isA.Number(field.width)) {
                width = field.width;
            }
        }
    }
    return width;
},

showValueIconHandCursor:function (field) {
    return field.valueIconClick != null;
},

getValueIconHTML : function (icon, field, extraExtraStuff) {
    
    var prefix = field.imageURLPrefix || field.baseURL || field.imgDir,
        suffix = field.imageURLSuffix,
        width = this.getValueIconWidth(field),
        height = this.getValueIconHeight(field),
        leftPad = this.getValueIconLeftPadding(field),
        rightPad = this.getValueIconRightPadding(field);

    if (suffix != null) icon += suffix;
    
    var extraCSSText;
    if (this.showValueIconHandCursor(field)) {
        extraCSSText = "cursor:pointer;"
    }

    var iconHTML = isc.Canvas._getValueIconHTML(icon, prefix, width, height,
                                      leftPad, rightPad,
                                      // no need for an ID
                                      null,
                                      // pass in the LG as an instance - required
                                      // for generating the path of the valueIcon src
                                      this,
                                      extraExtraStuff, extraCSSText);
    return iconHTML;
},

//> @method listGrid.getCellAlign()
// Return the horizontal alignment for cell contents. Default implementation returns
// +link{listGridField.cellAlign} if specified, otherwise +link{listGridField.align}.
//
// @see getCellStyle()
//
// @param   record (listGridRecord) this cell's record
// @param   rowNum  (number)    row number for the cell
// @param   colNum  (number)    column number of the cell
// @return  (Alignment)     Horizontal alignment of cell contents: 'right', 'center', or 'left'
// @visibility external
//<
getCellAlign : function (record, rowNum, colNum) {
    var isRTL = this.isRTL();
    // single cells are aligned according to RTL - skip checkboxField (which needs center align)
    if (record && record[this.singleCellValueProperty] != null &&
        (!this.showSingleCellCheckboxField(record) ||
         !this.isCheckboxField(this.getField(colNum)))
       )
    {
        return isRTL ? isc.Canvas.RIGHT : isc.Canvas.LEFT;
    }

    return this.getFieldCellAlign(colNum, isRTL);
},

getFieldCellAlign : function (fieldNum, isRTL) {

    var field = this.getField(fieldNum);

    if (!field) return isRTL ? isc.Canvas.RIGHT : isc.Canvas.LEFT;

    
    if (field.cellAlign == null && field.userFormula) {
        return isRTL ? isc.Canvas.LEFT : isc.Canvas.RIGHT;
    }
    // This is set up in applyFieldDefaults if not explicitly specified on the field config
    var align = field.cellAlign || field.align;
    // If 'reverseRTLAlign' is true, flip the explicitly specified alignment.
    // This is true by default and makes sense for common cases where you really want
    // specified 'left' / 'right' to have the meaning of 'start'/'end'
    if (isRTL && this.reverseRTLAlign) {
        if (align == isc.Canvas.RIGHT) align = isc.Canvas.LEFT;
        else if (align == isc.Canvas.LEFT) align = isc.Canvas.RIGHT;
    }
    return align;
},

// Helper method
// If we're showing a singleCellValue for a record, should we show the checkboxField to the
// left of the single value
showSingleCellCheckboxField : function (record) {
    return (this.getCurrentCheckboxField() != null) && record &&
            (this.canSelectGroups || !record._isGroup) && 
            !record[this.isSeparatorProperty];
},

//> @method listGrid.getCellVAlign()
// Return the vertical alignment for cell contents.
// Expected values are: 'top', 'center', or 'bottom'
//
// @see getCellStyle()
//
// @param   record (listgridRecord) this cell's record
// @param   rowNum  (number)    row number for the cell
// @param   colNum  (number)    column number of the cell
// @return  (Alignment)     Vertical alignment of cell contents: 'right', 'center', or 'left'
// @visibility external
//<
// Unset by default


// Helper method:
// If a displayField was specified for a field, should we pick up the 'displayField' value for
// this record and display it here?
// Basically this makes sense if no optionDataSource was specified, unless overridden by a valueMap
_useDisplayFieldValue : function (field) {
    // no display field, or we have an explicit valueMap
    if (!field || field.valueMap || field.displayField == null ||
        (field.displayField == field.name))
    {
        return false;
    }

    // displayField and no explicit optionDataSource, pick up the value from the record
    // unless explicitly suppressed by the developer
    if (field.optionDataSource == null) {
        if (field.displayValueFromRecord == false) return false;
        return true;
    }

    // field has an optionDataSource and autoFetchDisplayMap is true - in this case we'll
    // fetch against the ODS and build a valueMap from the data we get back - so even if we don't
    // have a valueMap yet, we soon will!
    var fetchDisplayMap = field.autoFetchDisplayMap;
    if (fetchDisplayMap == null) fetchDisplayMap = this.autoFetchDisplayMap;
    if (fetchDisplayMap) return false;

    // At this point, if optionDataSource and valueField matches we'll use the
    // value from the record - however allow the developer to override this to either
    // a) force the display field value to be picked up (as if there was no ODS specified - somewhat
    // probable if autoFetchDisplayMap has been disabled, since the ODS has really no other meaning
    // to the grid) or
    // b) suppress the display field value even if the dataSources do match (for example may want
    // to show display-field values in edit mode only.
    if (field.displayValueFromRecord  != null) return field.displayValueFromRecord;

    // same dataSource / same valueField - pick up the value from the record.
    return (field.valueField == null || field.valueField == field.name) &&
            (isc.DS.get(field.optionDataSource) == this.getDataSource());
},

// Row Spanning
// ---------------------------------------------------------------------------------------

//> @attr listGrid.allowRowSpanning (Boolean : false : IR)
// Should cells in this grid be allowed to span multiple rows?
// If set to <code>true</code>, the +link{listGrid.getRowSpan()} method will be
// called for every cell when rendering out the listGrid to determine how many
// rows the cell should span.
// <P>
// See +link{listGrid.getRowSpan()} for more details
// @visibility external
//<
allowRowSpanning:false,

//> @method listGrid.getRowSpan()
// Return how many rows this cell should span.  Default is 1.
// <P>
// This method will only be called if +link{listGrid.allowRowSpanning} is set to
// <code>true</code>
// <P>
// When using row spanning, consider setting +link{useRowSpanStyling} to enable
// row-span-sensitive styling behaviors.
// <P>
// Note that the standard implementation assumes that the number of rows spanned by cells
// decreases or stays the same, starting with the first (leftmost) column in the grid and
// moving rightwards.
// <P>
// When using row spanning:
// <ul>
// <li> APIs that allow modifying the contents of cells (such as +link{getCellStyle()} or
// +link{listGridField.formatCellValue()}) will be called only once per row-spanning cell
// <li> when using +link{listGrid.canSelectCells,cell-based selection}, only the
// spanning cell is considered selected, and not any of the cells spanned through.  For
// example, if the cell at row 2 column 0 spans 2 cells, +link{CellSelection,CellSelection.isSelected()}
// will be true for 2,0 but false for 3,0.
// <li> if using incremental rendering (either horizontal or vertical),
// <code>getRowSpan()</code> may be called for a rowNum <b>in the middle of a spanning
// cell</b>, and should return the remaining span from that rowNum onward.
// <li> cell-level events such as +link{listGrid.recordClick()} will report the logical
// rowNum for spanned cells. In other words if a cell spans two rows, a different
// rowNum parameter will be passed to the recordClick handler depending on whether the user
// clicks at the top of the spanning cell or the bottom. Developers can normalize
// this to the starting cell via the +link{listGrid.getCellStartRow()} API.
// <li> for cells that span multiple records, editing behavior may be controlled by the
// +link{rowSpanEditMode, rowSpanEditMode} attribute.
// <li> rowSpanning can be used in conjunction with
//  +link{showRecordComponents(),recordComponents}. If record
// component are enabled on a grid with row-spanning cells the behavior is as follows:
//   <ul>
//    <li>Having +link{recordComponentPosition} set to "expand" is not currently supported
//        for grids that render out spanning cells.
//    <li>The method to retrieve / create record components will not be run for cells that
//        are "spanned". In other words if the first row in a grid spans 2 rows for some
//        field, the second logical row is "spanned" for that field - that cell doesn't
//        render any content and won't attempt to create a recordComponent.
//    <li>If +link{showRecordComponentsByCell} is false, the method to create record
//        components will be called for every non-spanned cell in the first column
//        of the grid.
//    <li>Percentage sizing of record components spanning multiple cells will be
//        calculated relative to the set of spanned cells.
//   </ul>
// </ul>
// <P>
// More generally, the ListGrid has a data model of one +link{Record} per row, and spanning cells
// doesn't fit well with this model, meaning that many ListGrid features are incompatible
// with rowSpanning.
//
// @include gridRenderer.getRowSpan()
// @visibility external
//<
// Note the limitation of row spanning never increasing going left to right comes up
// in a couple of spots:
// - the default selection model basically assumes the number of rows spanned is reducing
//   and performs a selection of all spanned cells in the row, moving rightwards
// - the getRowHeight implementation makes this assumption to ensure frozen body row
//   heights are correct (we have an undocumented flag to remove this limitation, but
//   this introduces some extra calculation that would have to run, making this undesirable
//   for many-columned grids).

//> @method listGrid.getCellRowSpan()
// @include gridRenderer.getCellRowSpan()
// @visibility external
//<

//> @method listGrid.getCellStartRow()
// @include gridRenderer.getCellStartRow()
// @visibility external
//<

//> @attr listGrid.useRowSpanStyling (boolean : null : IR)
// Enables various styling behaviors that potentially make sense when +link{getRowSpan()} has
// been overridden to introduce spanning cells, and spanning is largest on the left and
// smaller as cells go to the right.  Specifically:
// <ul>
// <li> computes +link{alternateRecordStyles,banded styling} based on the span of the
//      cell in the left-most column
// <li> enables +link{listGrid.canSelectCells,cell-level selection}, including
//      +link{useCellRollOvers,cell-level rollover} styling
// <li> enables row-span-sensitive cell selection.  See also +link{rowSpanSelectionMode}
//      for available behaviors
// </ul>
// <P>
// Because this setting enables +link{canSelectCells}, it is incompatible with any APIs
// that expect a record-oriented data model.
// <P>
// Because this setting only makes sense when row spanning decreases from the first column
// to the last, it has unspecified behavior with +link{listGrid.canReorderFields}.
//
// @visibility external
//<

//> @type RowSpanSelectionMode
// Behavior of selection when row spanning is active.  See +link{listGrid.useRowSpanStyling}.
// @value "forward" when a cell is clicked on, select any cells in subsequent columns which
//                  are at least partially spanned by the clicked cell
// @value "both"    when a cell is clicked on, selects any cells in any other columns which
//                  are at least partially spanned by the clicked cell
// @value "outerSpan" behaves like "forward", except as though the cell in the first column
//                    was clicked instead.  If the largest row spans are in the first
//                    column and all cells in subsequent columns do not extend out of the
//                    first cell's span, this creates a row-like selection model where the
//                    span of the left-most cell defines the "row" of cells being selected.
// @visibility external
//<

//> @attr listGrid.rowSpanSelectionMode (RowSpanSelectionMode : "forward" : IR)
// Chooses the selection mode when +link{useRowSpanStyling} is enabled.  See
// +link{RowSpanSelectionMode}.
//
// @visibility external
//<
rowSpanSelectionMode:"forward",

//> @attr listGrid.rowSpanEditMode (RowSpanEditMode : "first" : IRWA)
// If +link{listGrid.allowRowSpanning} is enabled, this property may be used to specify
// editing behavior for cells that span multiple rows.
// @visibility external
//<
rowSpanEditMode:"first",

//> @type RowSpanEditMode
// When +link{listGrid.allowRowSpanning} is enabled, certain cells may span multiple
// rows. In this case, the cell displays the value from the record in the first row.
// If the grid is +link{listGrid.canEdit,editable} (and the
// +link{listGridField.canEdit,field is also editable}), these settings allow the user
// to specify what happens to the data when the user edits this cell.
// <P>
// Note that in this scenario, a user may begin an edit on the row-spanning cell directly
// (via double-click for example), or on a cell in another column in any of the rows
// spanned by the cell. The appropriate behavior with respect to user-experience and how
// the data is manipulated will depend on the application in question. Developers may
// of course entirely disable editing for the field via +link{listGridField.canEdit} or
// +link{listGrid.canEditCell()}.
// <P>
// See also: +link{listGrid.useRowSpanStyling}
//
// @value "first" This setting assumes that only the field-value for the first record
//  spanned by this cell is significant. In this case the editor will only show for this
//  cell if the user is editing the first spanned record. If the user initialized the edit
//  on another spanned row, the editor will not show for this field.
// @value "each" This setting assumes that each row's values are logically separate, so if
//  a cell spans multiple rows, and a user initializes an edit on some cell in the
//  second spanned row, the spanning cell will show an editor containing the value for
//  the second spanned row. This may differ from the value displayed when not
//  in edit mode (which is derived from the first spanned row by default). This setting may
//  be useful for developers who which to implement their own logic on how to handle
//  spanning cell display values and/or edit values (for example by using custom
//  +link{listGridField.formatCellValue(),formatting} and applying custom logic to handle
//  editing on +link{listGridField.editorEnter} and +link{listGridField.editorExit}).
//
// @visibility external
//<


// Value Icons
// ---------------------------------------------------------------------------------------

_valueIconStyleTemplate:[
    "style='margin-left:",  // [0]
    ,                       // [1] - icon padding
    "px;margin-right:",     // [2]
    ,                       // [3] - icon padding
    "px;'"
],

//> @method ListGrid.getValueIcon()
// Returns the appropriate valueIcon for a cell based on the field and the data value for the
// cell. Default implementation returns null if +link{ListGridField.suppressValueIcon} is true
// otherwise looks at +link{ListGridField.valueIcons}.
// @param field (ListGridField) field associated with the cell
// @param value (any) data value for the cell's record in this field.
// @param record (ListGridRecord) record associated with this cell
// @return (SCImgURL) url for the icon
// @group imageColumns
// @visibility external
//<
// We need the rowNum for checking whether the cell is editable
// calculate this from the record object via findRowNum(), but also support being passed an
// explicit rowNum for critical path code
getValueIcon : function (field, value, record, rowNum) {
    if (!field.valueIcons || field.suppressValueIcon) {
        if (this._formatBooleanFieldAsImages(field)) {
            var img;
            if (value) {
                img = (this.isPrinting
                       ? this.printBooleanTrueImage || this.booleanTrueImage
                       : this.booleanTrueImage);
            } else {
                img = (this.isPrinting
                       ? this.printBooleanFalseImage || this.booleanFalseImage
                       : this.booleanFalseImage);
            }
            // if the cell can't be edited and can be toggled, make sure it displays the
            // disabled checkbox icon
            rowNum = (rowNum != null) ? rowNum : this.findRowNum(record);
            var colNum = field.masterIndex;
            if (!this.canEditCell(rowNum, colNum) && field.canToggle && img != this._$blank) {
                img = isc.Img.urlForState(img, false, false, isc.StatefulCanvas.STATE_DISABLED);
            }
            if (img == this._$blank) {
                img = isc.Canvas._nullSrcPlaceholder;

            // If no image was specified, still write out a blank gif into the slot - this
            // allows us to recognize events over the (invisible) icon for canToggle behavior
            } else if (img == null) {
                img = isc.Canvas.getImgURL(isc.Canvas._blankImgURL);
            }
            return img;
        }
        return null;
    }
    var icon = field.valueIcons[value];
    return icon;
},

//> @method listGrid.getValueIconStyle() [A]
// Returns the CSS style for a cell based on the field and the data value for the cell.
// @param field (ListGridField) field associated with the cell
// @param value (any) data value for the cell's record in this field.
// @param record (ListGridRecord) record associated with this cell
// @return (CSSStyleName) CSS style to use, or null if no style should be used
//<
getValueIconStyle : function (field, value, record, rowNum) {
    var booleanBaseStyle = (this.isPrinting ? this.printBooleanBaseStyle || this.booleanBaseStyle : this.booleanBaseStyle);
    if (booleanBaseStyle && field && (!field.valueIcons || field.suppressValueIcon)) {
        if (this._formatBooleanFieldAsImages(field)) {
            var imgStyle = booleanBaseStyle + (value ? "True" : "False");
            // if the cell can't be edited and can be toggled, make sure it displays the
            // disabled checkbox style
            rowNum = (rowNum != null) ? rowNum : this.findRowNum(record);
            var colNum = field.masterIndex;
            if (!this.canEditCell(rowNum, colNum) && field.canToggle) {
                imgStyle += isc.StatefulCanvas.STATE_DISABLED;
            }
            return imgStyle;
        }
    }
    return null;
},

// Helpers to get padding on each side of a field's valueIcon
getValueIconLeftPadding : function (field) {
    return (field && field.valueIconLeftPadding != null ? field.valueIconLeftPadding
            : this.valueIconLeftPadding || 0);
},

getValueIconRightPadding : function (field) {
    return (field && field.valueIconRightPadding != null ? field.valueIconRightPadding
            : this.valueIconRightPadding || 0);
},

// showValueIconOnly - returns true if the valueIcon should be displayed without any
// text value for some field.
_$boolean:"boolean",
showValueIconOnly : function (field) {
    if (field.showValueIconOnly != null) return field.showValueIconOnly;

    // See discussion near showValueIconOnly docs.
    // If we have a valueIcons map, with no vmap, return text AND icon
    // if we have both valueIcons and a vmap, return just the icon
    // if we have no icon map, obviously return text (and icon, which is null)
    if (field.valueIcons != null && field.valueMap != null) return true;

    // If we are looking at a boolean field for which we want to show just the checkbox images
    // return true - otherwise false
    return this._formatBooleanFieldAsImages(field);

},

//> @method ListGrid.getValueIconWidth()
// If some field is showing valueIcons, this method returns the width those items should render
// Default implementation derives this from the first specified of
// +link{ListGridField.valueIconWidth}, +link{ListGridField.valueIconSize},
// +link{ListGrid.valueIconWidth}, or +link{ListGrid.valueIconSize}
// @param field (object) field for which we're retrieving the valueIcon width
// @return (number) width for the icon
// @group imageColumns
// @visibility internal
//<
getValueIconWidth : function (field) {

    if (this.isCheckboxField(field)) return this._getCheckboxFieldImageWidth();
    if (this._formatBooleanFieldAsImages(field)) return this.booleanImageWidth;

    return (field.valueIconWidth != null ? field.valueIconWidth  :
                (field.valueIconSize != null ? field.valueIconSize :
                    (this.valueIconWidth != null ? this.valueIconWidth : this.valueIconSize)));
},

//> @method ListGrid.getValueIconHeight()
// If some field is showing valueIcons, this method returns the height those items should render
// Default implementation derives this from the first specified of
// +link{ListGridField.valueIconHeight}, +link{ListGridField.valueIconSize},
// +link{ListGrid.valueIconHeight}, or +link{ListGrid.valueIconSize}
// @param field (object) field for which we're retrieving the valueIcon height
// @return (number) height for the icon
// @group imageColumns
// @visibility internal
//<
getValueIconHeight : function (field) {
    if (this.isCheckboxField(field)) return this._getCheckboxFieldImageHeight();
    if (this.isExpansionField(field)) return this._getExpansionFieldImageHeight();
    if (this._formatBooleanFieldAsImages(field)) return this.booleanImageHeight;

    return (field.valueIconHeight != null ? field.valueIconHeight  :
                (field.valueIconSize != null ? field.valueIconSize :
                    (this.valueIconHeight != null ? this.valueIconHeight : this.valueIconSize)));
},

// New record row: optional special row added to encourage new record entry
// ---------------------------------------------------------------------------------------

_isNewRecordRow : function (recordNum) {
    return this.showNewRecordRow && (recordNum == this.getTotalRows()-1);
},

//> @method ListGrid.getNewRecordCellValue()
//  Returns the contents to display in the new record row.
//  Note that this row displays a single cell spanning every column.
//  @return (string)    Value to display in new record row. Default
//                      implementation returns <code>"-- Add New Row --"</code>
//<
getNewRecordRowCellValue : function () {
    return '<div align="center">' + this.newRecordRowMessage + '</div>';
},

// ---------------------------------------------------------------------------------------
getErrorIconHTML : function (record, rowNum, colNum) {
    var errors = this.getCellErrors(rowNum, colNum);
    if (errors == null) return isc._emptyString;

    var HTML = this.imgHTML(this.errorIconSrc, this.errorIconWidth, this.errorIconHeight, null,
                            " isErrorIcon='true'");

    var isRTL = this.isRTL(),
        align = this.getCellAlign(record, rowNum, colNum),
        spaceOnLeft = ((isRTL && align === isc.Canvas.LEFT) ||
                       (!isRTL && align === isc.Canvas.RIGHT));

    // Since we're writing the icon out to the left of our content, write a spacer out to the
    // right of the image to give us some padding between the image and the cell content
    
    var spacerHTML;
    if (isc.Browser.isIE && this._editorShowing && this.getEditRow() == rowNum &&
        (!this.editByCell || this.getEditCol() == colNum))
    {
        spacerHTML = " ";
    } else {
        
        spacerHTML = isc.Canvas.spacerHTML(this.cellPadding, "auto");
    }

    if (spaceOnLeft) {
        HTML = spacerHTML + HTML;
    } else {
        HTML += spacerHTML;
    }

    return HTML;
},

// Handle events over the error icon by showing a hover containing the
// error text
_handleErrorIconOver : function (rowNum, colNum) {
    this._overErrorIcon = [rowNum,colNum];
    
    // Call the user handler if present
    if (this.cellErrorIconHover &&
            this.cellErrorIconHover(this.getRecord(rowNum, colNum), rowNum, colNum) == false)
    {
        return;
    }
    // This will fire the method on a delay unless the hover is already up
    // in which case it'll update it immediately.
    isc.Hover.setAction(this, this._handleErrorIconHover);


},
_handleErrorIconHover : function () {
    if (this._overErrorIcon == null) return;

    var rowNum = this._overErrorIcon[0],
        colNum = this._overErrorIcon[1];

    var errors = this.getCellErrors(rowNum, colNum);
    if (errors == null) return;

    var promptString = isc.FormItem.getErrorPromptString(errors);
    isc.Hover.show(promptString, this._getHoverProperties());
},

_handleErrorIconOut : function () {
    delete this._overErrorIcon;
    
    if (isc.Hover.isActive) {
        isc.Hover.clear();
    }
},

// _formatCellValue: Helper method to format the static cell value using developer defined
// formatCellValue() methods.
_$text:"text",
_formatCellValue : function (value, record, field, rowNum, colNum) {
    if (field && field.userSummary) {
        value = this.getSummaryFieldValue(field, record);

    } else {
        // If this is a summary row (group or grid level) we support custom formatting.
        // If custom formatters (formatGroupSummary / formatGridSummary) are present, apply them
        // and don't then run through additional formatting logic.
        var customFormatApplied = false;
        if (record && record[this.groupSummaryRecordProperty]) {
            if (field && field.formatGroupSummary) {
                if (!isc.isA.Function(field.formatGroupSummary)) {
                    field.formatGroupSummary =
                        isc.Func.expressionToFunction("value", field.formatGroupSummary);
                }
                if (isc.isA.Function(field.formatGroupSummary)) {
                    value = field.formatGroupSummary(value);
                    customFormatApplied = true;
                }
            }
        }

        
        if (record && this._isSummaryRow) {
            if (field && field.formatGridSummary) {
                if (!isc.isA.Function(field.formatGridSummary)) {
                    field.formatGridSummary =
                        isc.Func.expressionToFunction("value", field.formatGridSummary);
                }
                if (isc.isA.Function(field.formatGridSummary)) {
                    value =  field.formatGridSummary(value);
                    customFormatApplied = true;
                }
            }
        }

        // If we already ran through group/grid summary formatters, don't run
        // standard cellFormatters on top of them!
        if (!customFormatApplied) {
            var valueFormat;

            if (field && field.formatCellValue != null) {
                value = field.formatCellValue(value,record,rowNum,colNum,this);
            } else if (field && field.cellValueTemplate) {
                // NOTE:
                // - probably don't need grid.cellValueTemplate, as this would be rare
                // - not exposed publicly yet
                // - might want XSLT option
                value = field.cellValueTemplate.evalDynamicString(this, {
                            value:value, record:record, field:field});
            // listGrid-wide formatter
            } else if (this.formatCellValue != null) {
                value = this.formatCellValue(value, record, rowNum, colNum);
            } else if (field && field.format && (isc.isA.Number(value) || isc.isA.Date(value))) {
                value = isc.isA.Number(value) ? isc.NumberUtil.format(value, field.format)
                                              : isc.DateUtil.format(value, field.format);

            } else if (isc.CubeGrid && isc.isA.CubeGrid(this) && 
                       (isc.isA.Number(value) || isc.isA.Date(value)) &&
                       (valueFormat = this.getValueFormat(rowNum, colNum)) != null)

            {
                value = isc.isA.Number(value) ? isc.NumberUtil.format(value, valueFormat)
                                              :   isc.DateUtil.format(value, valueFormat);

            
            } else if (field && !field._suppressTypeFormatting) {
                
                value = this.applyCellTypeFormatters(value, record, field, rowNum, colNum);
            }
        }
    }
    // formatValueAsString() performs final conversions such as catching the case
    // where the value is null or "" and mapping to "&nbsp;" in the cell
    // We already do this as part of "getDefaultFormattedValue()".
    // A custom formatCellValue implementation may call 'getDefaultFormattedValue()' directly
    // in this case 'formatValueAsString()' will actually run twice, but should have
    // no ill effects since since the string won't be further modified by a second pass
    // through this method.
    value = this.formatValueAsString(value, record, field, rowNum, colNum);

    // hook for final processing of the display value that is applied to the actual display
    // value as derived by the various other hooks
    
    if (this.formatDisplayValue) {
        value = this.formatDisplayValue(value, record, rowNum, colNum);
    }

    // support escapeHTML flag per field
    if (field && field.escapeHTML) {
        // don't escape "&nbsp;" or the emptyCellValue, though, since DataSourceField.emptyCellValue's
        // documented type is HTMLString
        if (isc.isA.String(value) && value != this._$nbsp &&
            (field.emptyCellValue == null || value != field.emptyCellValue))
        {
            value = value.asHTML();
        }
    }

    return value;
},

//> @method listGrid.getDefaultFormattedValue() [A]
// Get the value for some cell with default formatters applied.
// <P>
// This method is useful for cases where a developer wishes to
// conditionally customize a cell's formatting, but needs to see what
// the default formatted value would be.
// <P>
// For example - a developer might wish to apply a custom
// +link{ListGridField.formatCellValue(),formatter} to some
// <code>link</code> type field, and be able to return the default
// active link HTML in some cases. In this case a formatter could
// check for the conditions in which custom formatting should be applied
// and run appropriate custom logic to generate a value for display - otherwise
// return the result of this method to leave the standard formatted-value intact.
//
// @param record (Record) the cell's record object
// @param rowNum (int) rowNum for the cell
// @param colNum (int) colNum for the cell
// @return (string) Cell value with default formatters applied
// @see ListGridField.formatCellValue
// @visibility external
//<

getDefaultFormattedValue : function (record, rowNum, colNum) {
    var field = this.getField(colNum);
    var value = this.applyCellTypeFormatters(
                    this.getRawCellValue(record, rowNum, colNum),
                    record, field, rowNum, colNum
                );
    return this.formatValueAsString(value, record, field, rowNum, colNum);
},

//> @method listGrid.getDefaultFormattedFieldValue() [A]
// Get a field value for some record with default field formatters applied.
// <P>
// This method differs from +link{getDefaultFormattedValue()} in a couple of ways.
// Firstly, this method does not rely on the rowNum and colNum parameters to find the
// record and field in the grid.<br>
// Secondly, unlike +link{getDefaultFormattedValue()} this method <i>will</i> call
// any explicit cell formatter specified on the field passed in (though it will not
// call a +link{listGrid.formatCellValue(),component level formatter} if one exists).
// <P>
// This is useful for cases where a developer wishes to
// display a formatted value for some record and field combination which does not
// necessarily map to a cell displayed in the ListGrid.
// <P>
// If <code>rowNum</code> and <code>colNum</code> parameters are passed through to
// the field level cell formatter if one exists. If not explicitly provided these are
// defaulted to -1.
//
// @param record (Record) the record object
// @param field (ListGridField) the field object
// @param [rowNum] (int) rowNum (passed to any field level cell formatter)
// @param [colNum] (int) colNum (passed to any field level cell formatter)
// @return (string) Default formatted value
// @see ListGridField.formatCellValue
// @visibility external
//<

getDefaultFormattedFieldValue : function (record, field, rowNum, colNum) {
    var rawValue = isc.DataSource.getFieldValue(field, record);

    if (rowNum == null) rowNum = -1;
    if (colNum == null) colNum = -1;

    var value;
    if (field && field.formatCellValue != null) {
        value = field.formatCellValue(rawValue,record,rowNum,colNum,this);
    } else {
         value = this.applyCellTypeFormatters(rawValue, record, field, rowNum, colNum);
    }
    return this.formatValueAsString(value, record, field, rowNum, colNum);
},

// Apply type-formatters to a cell value.
applyCellTypeFormatters : function (value, record, field, rowNum, colNum, isMultipleElement) {

    if (!isMultipleElement && field && field.multiple && isc.isA.Array(value)) {
        var values = [];
        for (var i = 0; i < value.length; i++) {
            values[i] = this.applyCellTypeFormatters(value[i], record, field,
                                                    rowNum, colNum, true);
        }
        // multipleValueSeparator documented at the DataSource level
        return values.join(field.multipleValueSeparator || ", ");
    }

    // check for formatter defined on a SimpleType definition
    if (field && field._simpleType != null && field._simpleType.shortDisplayFormatter != null) 
    {
        value = field._simpleType.shortDisplayFormatter(value, field, this, record, rowNum, colNum);
    // We apply some standard (default) formatters to fields with particular data types.
    // NOTE: these should be moved to the built-in SimpleType definitions
    } else if (field && field._typeFormatter != null) {
        value = field._typeFormatter(value, field, this, record, rowNum, colNum);
    }

    // Note: this method does *not* run if there is a custom formatter
    // applied to a field (including a custom grid/group formatter for grid/group summary rows).
    //
    // apply the plural title if the special flag was set on the record
    if (value != null && !isc.isA.emptyString(value) &&
        record && field && record[this.recordApplyPluralTitleProperty])
    {
        var fieldNames = record[this.recordApplyPluralTitleProperty];
        if (fieldNames.contains(field.name)) {
            var title = field.pluralTitle;
            if (title == null) title = field.title;
            if (title != null) value += " " + title;
        }
    }
    // For summary rows where the summary method returned null (indicating unable to calculate a
    // summary), return the invalidSummaryValue if specified.
    if (value == null &&
        record && field &&
        this.invalidSummaryValue != null &&
        ((record[this.groupSummaryRecordProperty] && this.shouldShowGroupSummary(field)) ||
         (record[this.gridSummaryRecordProperty] && this.shouldShowGridSummary(field)))
       )
    {
        value = this.invalidSummaryValue;
    }

    return value;
},

// formatValueAsString: This takes a value to be displayed in a cell and ensures it displays
// correctly.
// This is run after any custom formatters / type-based formatters have been applied to
// the value.
formatValueAsString : function (value, record, field, rowNum, colNum) {

    // For "empty" values, write out the emptyCellValue
    
    if (value == null || isc.is.emptyString(value)) {
        // if the field specifies a 'emptyCellValue' (or 'emptyDisplayValue')
        if (this._resolveEmptyDisplayValue(field) != this.emptyCellValue) {
            // return the field-specific value
            value = this._resolveEmptyDisplayValue(field);
        } else if (field.type == "summary") {
            value = this.invalidSummaryValue;

        } else {
            // otherwise return the emptyCellValue for the entire list
            value = this.emptyCellValue;
        }

    // In IE, an element containing only whitespace characters (space or enter) will not show css
    // styling properly.
    
    } else if (this._emptyCellValues[value] == true) {
        value = this._$nbsp;

    // convert the value to a string if it's not already
    } else if (!isc.isA.String(value)) {
        // For date type values we want to respect dateFormatter / timeFormatter specified at the
        // field or component level.
        // If the specified fieldType is "date", "datetime" or "time" this is already handled by the
        // _typeFormatter function (which calls formatDateCellValue / formatTimeCellValue for
        // these fields)
        
        if (isc.isA.Date(value)) {

            // We already know the "type" of this field is not "time" (as formatTimeCellValue)
            // would have run and converted it to a string already.
            // So we'll actually only format as time if the field has any explicit timeFormatter
            // and no explicit dateFormatter.
            if (this._formatAsTime(field)) {
                var formatter = this._getTimeFormatter(field);
                var isLogicalTime = isc.SimpleType.inheritsFrom(field.type, "time");
                value = isc.Time.toTime(value, formatter, isLogicalTime);
            } else {

                var isDatetime = field && isc.SimpleType.inheritsFrom(field.type, "datetime"),
                    isLogicalDate = !isDatetime && field && isc.SimpleType.inheritsFrom(field.type, "date"),
                    formatter = this._getDateFormatter(field);
                if (isDatetime) value = value.toShortDateTime(formatter, true);
                else value = value.toShortDate(formatter, !isLogicalDate);
            }
        } else {
            value = isc.iscToLocaleString(value);
        }
    }
    return value;
},

// these Strings can be considered to be "empty" cells, causing bad styling.  Replace with
// '&nbsp;'

_emptyCellValues:{" ":true, "\n":true, "\r":true, "\r\n":true},
_$nbsp:"&nbsp;",

//> @method listGrid.getEditItemCellValue()   ([IA])
//          Returns the HTML for a cell within a row that is being edited (as a result of a call
//          to 'editRow')<br>
//          Will <i>not</i> call 'updateEditRow()' to update the values displayed in the edit
//          row - this must be handled by calling methods, once we know the form element has
//          been written into the DOM.
//      @visibility internal
//      @group  editing
//
//      @param  record      (object)    the current record object
//      @param  rowNum      (number)    index of the record containing this cell
//      @param  colNum      (number)    index of the field containing this cell
//
//      @return (string)    display value for this cell
//<
getEditItemCellValue : function (record, rowNum, colNum) {
    var itemName = this.getEditorName(rowNum, colNum);

    // If the editRowForm or item haven't yet been created, no op - implies this
    // is being called at an invalid time
    
    if (!this._editRowForm || !this._editRowForm.getItem(itemName)) {
        return "&nbsp;"
    }

    // Write a form item out into this cell.
    // We have already created the '_editRowForm' - a dynamic form with an appropriate set of
    // form items (see 'editRow').
    // Make use of the appropriate item's getStandaloneHTML() to write out the form element

    // If we have any errors for the field, set them on the form item too so the error icon
    // gets rendered out
    var errors = this.getCellErrors(rowNum, colNum);
    if (errors) {
        this._editRowForm.setFieldErrors(itemName, errors);
    }

    // get the HTML for the form item
    // Relies on the form item being present - this is fine as long as our logic to create
    // and remove edit form items for incremental rendering stays in sync with the set of
    // cells being written out.
    var item = this._editRowForm.getItem(itemName),
        HTML = item.getStandaloneItemHTML(item.getValue(), false, true);

    // once we've retrieve the HTML, clear the errors so if we re-render the form for another item
    // etc, we don't end up with errors hanging around
    if (errors) {
        this._editRowForm.setFieldErrors(itemName, null);
    }

    
    var body = item.containerWidget;
    if (!body._drawnEditItems) body._drawnEditItems = [];
    if (!body._drawnEditItems.contains(item)) {
        body._drawnEditItems.add(item);
    }

    return HTML;
},

// should we show inactive version of the edit form item for some cell?
_showInactiveEditor : function (fieldNum) {
    return this._alwaysShowEditors(fieldNum);
},


// getInactiveEditorCellValue()
// If this.alwaysShowEditors is true, we write inactive versions of our edit form items in every
// row (with appropriate value displayed for the record in question)
getInactiveEditorCellValue : function (record, rowNum, colNum) {
    var itemName = this.getEditorName(rowNum, colNum);

    // get the HTML for the form item
    // Relies on the form item being present - this is fine as long as our logic to create
    // and remove edit form items for incremental rendering stays in sync with the set of
    // cells being written out.
    var item = this._editRowForm.getItem(itemName);
    // Don't crash if the form doesn't actually contain an item for this field.
    
    if (item == null) {
        return this.getFormattedValue(record, rowNum, colNum);
    }
    var editorType = isc.DynamicForm.getEditorType(item,this._editRowForm),
        value = this.getRawCellValue(record, rowNum, colNum),
        HTML;

    if (this.shouldShowEditorPlaceholder(this.getField(colNum),editorType)) {
        HTML = this.getEditorPlaceholderHTML(editorType, value, record,rowNum,colNum);
    } else {

        var context = {grid:this.getID(), record:record, rowNum:rowNum, colNum:colNum}
        
        var errors = this.getCellErrors(rowNum, colNum);
        if (errors) {
            this._editRowForm.setFieldErrors(itemName, errors);
        }
        HTML = item.getInactiveEditorHTML(value, false, true, context);
        if (errors) {
            this._editRowForm.setFieldErrors(itemName, null);
        }

        // the inactiveEditorContext ID gets stored directly on the cell
        // When we refresh the cell we'll throw away this inactive context (and potentially create
        // another one)
        // We want to be able to map from row+colNum to contextID so we don't have
        // to iterate through all the inactiveContexts on all the form items
        
        if (!this._inactiveEditorContextMap) this._inactiveEditorContextMap = {};
        var row_col = "_" + rowNum + "_" + colNum;
        if (this._inactiveEditorContextMap[row_col]) {
            this.logWarn("creating new inactiveEditor context for a cell without having cleared " +
                "the previous one." + this.getStackTrace(), "inactiveEditorHTML");
        }
        this._inactiveEditorContextMap[row_col] = context;
    }

    
    return HTML;
},


// if we're showing editors for every record, if this method returns true, suppress showing
// inactive editorHTML and show simplified placeholder HTML instead for the field in question.
// This allows us to not have to ensure that every editorType supports inactiveHTML in an efficient
// manner.
shouldShowEditorPlaceholder : function (field, editorType) {

    if (field.showEditorPlaceholder != null) return field.showEditorPlaceholder;

    return !this._supportsInactiveEditorHTML[editorType];
},
// list of editorTypes that support inactiveEditorHTML for alwaysShowEditors:true

_supportsInactiveEditorHTML:{
    text:true, TextItem:true,
    select:true, SelectItem:true,
    combobox:true, ComboBoxItem:true, comboBox:true,
    checkbox:true, CheckboxItem:true,
    date:true, DateItem:true,
    spinner:true, SpinnerItem:true,
    popUpTextArea:true, PopUpTextAreaItem:true
},

// getEditorPlaceholderHTML()
// If this.alwaysShowEditors is true, return the placeholder HTML to show in place of
// inactiveEditorHTML for cells where shouldShowEditorPlaceholder returns true.
getEditorPlaceholderHTML : function (editorType, value, record, rowNum, colNum) {
    // for now just return the value.
    return value;
},

// _editItemsDrawingNotification - function to notify the edit row form items when they are
// drawn, cleared or redrawn.

_editItemsDrawingNotification : function (item, fireMoved, gr) {
    
    // Items with an optionDataSource may kick off a fetch request on draw
    // Set up a queue around the drawn notifications so we put any such requests into a queue.
    var shouldSendQueue = isc.RPCManager && !isc.RPCManager.startQueue();
    
    var items;
    if (item) items = [item];
    else {
        items = [];
        var allItems = this._editRowForm.getItems();
        for (var i = 0; i < allItems.length; i++) {
            if (allItems[i].containerWidget == gr) items.add(allItems[i]);
        }
    }
    var newlyDrawnItems = gr._drawnEditItems;

    for (var i = 0; i < items.length; i++) {
        var currentItem = items[i],
            wasDrawn = currentItem.isDrawn(),
            isDrawn = newlyDrawnItems ? newlyDrawnItems.contains(currentItem) : false,
            isCanvasItem = isc.CanvasItem && isc.isA.CanvasItem(currentItem);
        if (wasDrawn) {
            if (isDrawn) {
                currentItem.redrawn();
                // Redraw of the body will frequently result in repositioning the edit cells.
                // Fire the 'moved' handler on any visible form items that were present before
                // the redraw to notify them of being moved.
                
                if (fireMoved) currentItem.moved();
            } else {
                currentItem.cleared(true);
            }

        } else if (isDrawn) {
            // newly drawn
            
            if (isCanvasItem) currentItem.placeCanvas();
            currentItem.drawn(true);
        // Sanity check only - if we have a hidden / undrawn canvasItem, with a drawn
        // canvas, clear it.
        
        } else {
            
            if (isc.CanvasItem && isc.isA.CanvasItem(currentItem)) {
                if (currentItem.canvas && currentItem.canvas.isDrawn()) {
                    
                    currentItem.canvas.clear();
                    currentItem.canvas.deparent();
                }
            }
        }
    }

    if (this._editRowForm) {
        this._editRowForm.destroyOrphanedItems("Grid edit-items removed");
    }
    if (shouldSendQueue) isc.RPCManager.sendQueue();

    

    // Get rid of the _drawnEditItems. Next time this method is run we only want to catch
    // items which have subsequently been drawn
    delete gr._drawnEditItems;
},

// clearingInactiveEditorHTML
// Called when we're about to clear the generated inactiveEditorHTML due to cell refresh
// (so clearing a single row), or redraw (clearing all).
// Use this to clean up the generated inactive context objects so we don't fill up lots of memory on
// every redraw etc.
_clearingInactiveEditorHTML : function (rowNum,colNum) {

    // Don't crash if we have no inactiveEditorContextMap set.
    
    if (this._inactiveEditorContextMap == null) return;

    // have cells be rowNum/colNum pairs allowing us to clear just a single row, or
    // if we find we need more intelligent incremental update handling, single col, etc
    if (!this._editRowForm ||
        !this._alwaysShowEditors((colNum != null ? this.getField(colNum) : null),true)) return;

    if (rowNum != null) {
        var row_col = "_" + rowNum + "_" + colNum,
            context = this._inactiveEditorContextMap[row_col];
        if (context) {
            context.formItem.clearInactiveEditorContext(context);
            delete this._inactiveEditorContextMap[row_col];
        }
    } else {
        var editForm = this.getEditForm(),
            items = editForm.getItems();

        for (var i = 0; i < items.length; i++) {
            items[i].clearAllInactiveEditorContexts();
        }

        delete this._inactiveEditorContextMap;
    }
},

// setRecordValues()
// Method to update client-side data in place
// This is called directly by DynamicForms when saving values if this is acting as the selection
// component for a form.
setRecordValues : function (pks, values) {
    if (!this.shouldSaveLocally()) {
        this.logWarn("setRecordValues() not supported for grids where saveLocally is false");
        return;
        
    }
    if (!this.data) return;

    var rowNum = this.data.indexOf(pks),
        record = this.data.get(rowNum);

    // Incoming values will be in a structured form matching the dataPath, which is no good to
    // us because the records inside this component only contain fields from a specific
    // sub-hierarchy.  For example, if this grid is bound to dataPath "/items" it will have
    // flat-named fields called "a" and "b" that are actually at dataPaths "/items/a" and
    // "/items/b".  New values will come into this method in that complete form, so unless
    // we do something, our record will up looking like this:
    // {
    //   a: "something",
    //   b: 10,
    //   items: {
    //     a: "the new value",
    //     b: 100
    //   }
    // }
    //
    // So, we just create a new values object by pulling out whatever is at this component's
    // dataPath in the passed-in values (it will be the same as the form's dataPath, because
    // the only way we get here is for selectionComponents, and a selectionComponent implicitly
    // shares a dataPath with the forms for which it is a selectionComponent)
    
        
    var newValues = isc.Canvas._getFieldValue(this.dataPath, null, values, this, true);

    
    if (!newValues) {
        newValues = values;
    }

    this.combineRecords(record, newValues);
    this.calculateRecordSummaries(record, null, true, true);

    if (this.useCellRecords) {
        rowNum = this.findRowNum(record);
        var colNum = this.findColNum(record);
        this.refreshCell(rowNum,colNum);
    } else {
        this.refreshRow(rowNum);
    }

    // Reapply sort and filter, in case this change affects them
    this.resort();
    this.filterByEditor();

    if (this.valuesManager != null) {
        // _updateMultipleMemberValue handles combining a data-index into a path
        // 2nd param unnecessary since we're modifying the whole record, not a field within it.
        this.valuesManager._updateMultipleMemberValue(rowNum, null, record, this);
    }

},



combineRecords : function (destination, source) {
    return isc.combineObjects(destination, source);
},

//> @method listGrid.setRawCellValue()
//      @group  data
//          Set the raw data for one particular cell in the list.
//
//      @param  record      (object)    record in question
//      @param  recordNum   (number)    number of that record
//      @param  fieldNum    (number)    number of the field to display
//      @param  newValue    (any)       new value
//
//<
// Overridden at the cubeGrid level to handle being passed an entire record rather than a single
// field value for the cell
setRawCellValue : function (record, recordNum, fieldNum, newValue) {

    var field = this.fields[fieldNum];
    // if record or field is null, we're dealing with an invalid column, so forget it
    if (!record || !field) return;
    // if the field has a 'setRawCellValue' attribute
    // We'll assume this DIRECTLY sets the value on the LG's data object, so we're basically done
    // at this point (other than firing dataChanged below to ensure everything gets updated
    // visually)
    if (field.setRawCellValue) {
        // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "setRawCellValue", "viewer,record,recordNum,field,fieldNum,value");

        // call it as a function (returns string | null)
        field.setRawCellValue(this, record, recordNum, field, fieldNum, newValue);

    // otherwise just use the cells value in the normal way
    } else {
        isc.Canvas._saveFieldValue(null, field, newValue, record, this, true);
    }

    // HACK: fire dataChanged() by hand.  Really, we need an interface to update fields on
    // objects in the List so the List can recognize the change and fire dataChanged() itself
    this.getOriginalData().dataChanged();
},

//> @method listGrid.getCellBooleanProperty()   (A)
//  Given a property name, and a cell, check for the value of that property (assumed to be a
//  boolean) on the ListGrid, and the cell's field, returning false if the value is false at
//  either level.
//  If true at the ListGrid and Field level, check the value of the the second "recordProperty"
//  on the record object for the cell.
//  (If recordProperty is not passed, the record object will not be examined).
//
//  @param  property    (string)    Name of the property to look for.
//  @param  rowNum  (number)    Row number of the cell.
//  @param  colNum  (string)    Field number for the cell.
//  @param  [recordProperty]    (string)    Name of the equivalent property to check on the
//                                          record object
//
//  @return (boolean)   true == at least one is true and none are false
//
//<

_$false:"false", _$true:"true",
getCellBooleanProperty : function (property, recordNum, fieldNum, recordProperty) {
    var trueFound = false,
        listValue = this[property]
    ;
    if (listValue == false || listValue == this._$false) return false;
    var fieldValue = this.fields[fieldNum][property];
    if (fieldValue == false || fieldValue == this._$false) return false;

    if (recordProperty != null) {

        var record = this.getRecord(recordNum, fieldNum),
            recordValue = (record != null ? record[recordProperty] : false)
        ;
        if (recordValue == false || recordValue == this._$false) return false;
        if (recordValue == true || recordValue == this._$true) return true;
    }

    // At this point we know none of the values was an explicit false - but we only want to
    // return true if the value was specified as true (rather than undefined) at some level.
    // We've already checked at the record level (if necessary)
    return (listValue == true) || (fieldValue == true) ||
            (listValue == this._$true) || (fieldValue == this._$true);
},


// ---------------------------------------------------------------------------------------

//> @method listGrid.setShowRecordComponents()
// Setter for the +link{listGrid.showRecordComponents} attribute
// @param showRecordComponents (boolean) new value for <code>this.showRecordComponents</code>
// @visibility external
//<
setShowRecordComponents : function (showRC) {
    if (this.showRecordComponents == showRC) return;

    
    if (showRC) {
        if (this.animateFolders) {
            this._animateFoldersWithoutRC = true
            this.animateFolders = false;
        }
    } else {
        if (this._animateFoldersWithoutRC) {
            this.animateFolders = true;
            delete this._animateFoldersWithoutRC;
        }
    }

    this.showRecordComponents = showRC;

    // Update virutalScrolling if necessary.
    // We'll also update virtual scrolling in createBodies() - this handles the case where
    // we're already showing recordComponents and a grid is frozen at runtime.
    this._updateVirtualScrollingForRecordComponents();

    // suppress 'drawAllMaxCells' type behavior - we don't want to render out potentially
    // hundreds of canvases.
    if (showRC) {
        this._oldDrawAllMaxCells = this.drawAllMaxCells;
        this.drawAllMaxCells = 0;
        if (this.body != null) this.body.drawAllMaxCells = 0;

    } else {
        if (this._oldDrawAllMaxCells != null) {
            this.drawAllMaxCells = this._oldDrawAllMaxCells;
            if (this.body != null) this.body.drawAllMaxCells = this._oldDrawAllMaxCells;
            delete this._oldDrawAllMaxCells;
        }

    }
    this.invalidateRecordComponents();

    // For "within" record components, if autoFitting to values, we may need to
    // resize smaller once the components have been removed.
    if (!showRC &&
        (this.recordComponentPosition == this._$within ||
         (this.recordComponentPosition == null && this.showRecordComponentsByCell)))
    {
        this.updateFieldWidthsForAutoFitValue("showRecordComponents changed");
        this._updateFieldWidths();
    }

},

_updateVirtualScrollingForRecordComponents : function () {
    if (!this.showRecordComponents) {
        if (this._rcVScroll) {
            delete this.virtualScrolling;
            delete this._rcVScroll;
        }

    // Virtual scrolling:
    // Embedded components can make row heights unpredictable
    // (may not show for every row, may be 'position:"expand"', or exceed this.cellHeight
    // etc)
    // Because of this we typically have to enable virtual scrolling for record components.
    // However we don't currently support virtual scrolling with frozen fields, so
    // don't enable it if we have frozen fields.
    // This *may* lead to unpredictable behavior. Cases where it's ok:
    // - if recordComonentPosition is 'within' and
    //   the recordComponentPosition < this.cellHeight
    // - if recordComponentHeight is set (and truly is not exceeded by embedded components)
    
    } else {
        if (this.virtualScrolling == null || this._rcVScroll) {
            if (this.frozenFields == null) {
                this.virtualScrolling = true;
                this._rcVScroll = true;

            } else {

                if (this.recordComponentHeight == null) {
                    this.logWarn("This grid has frozen fields and is showing " +
                        "recordComponents. This may lead to unpredictable row heights which " +
                        "are not supported with frozen fields. Setting " +
                        "listGrid.recordComponentHeight will avoid this issue.",
                        "recordComponents");
                }
                if (this._rcVScroll) {
                    delete this.virtualScrolling;
                    delete this._rcVScroll;
                }
            }
        }
    }

    if (this.body && this.virtualScrolling != this.body.virtualScrolling) {
        this.body.virtualScrolling = this.virtualScrolling;
        if (this.frozenBody) {
            this.frozenBody.virtualScrolling = this.virtualScrolling;
        }
    }
    // No need to call 'redraw' on the body -- calling code is expected to handle this.
},



//> @method listGrid.getDrawArea() (A)
// Returns the extents of the rows and columns currently visible in this grid's viewport.
// <P>
// Note: if there are any +link{listGridField.frozen,frozen fields}, they are not included
// in the draw area range returned by this method. Frozen fields are assumed to never be
// scrolled out of view.  The column coordinates returned by this method will only include
// unfrozen columns.
//
// @return  (Array of Integer)  The row/col co-ordinates currently visible in the viewport as
//    [startRow, endRow, startCol, endCol].
// @visibility external
//<

getDrawArea : function () {
    if (this.body) {
        var drawArea = this.body.getDrawArea();
        if (this.frozenFields && this.freezeStart()) {
            drawArea[2] += this.frozenFields.length;
            drawArea[3] += this.frozenFields.length;
        }
        return drawArea;
    }
    
    return null;
},

// _drawAreaChanged() - notification fired on GridRenderer.redraw() when the
// previous draw area doesn't match the new draw area

_drawAreaChanged : function (oldStartRow, oldEndRow, oldStartCol, oldEndCol, body) {
    if (this.frozenFields && this.freezeStart()) {
        oldStartCol += this.frozenFields.length;
        oldEndCol += this.frozenFields.length;
    }
    var oldDrawArea = [oldStartRow, oldEndRow, oldStartCol, oldEndCol];
    if (oldDrawArea.equals(this.getDrawArea())) return;
    
    this.drawAreaChanged(oldStartRow,oldEndRow,oldStartCol,oldEndCol);
},

// documented in registerStringMethods
drawAreaChanged:function () {},

// if any records were programmatically expanded before the grid was drawn,
// expand them properly now
updateExpansionComponents : function () {
    if (!this._recordsToExpand || this._recordsToExpand.length == 0) return;
    this._updatingExpansionComponents = true;
    for (var i=this._recordsToExpand.length-1; i>=0; i--) {
        this.expandRecord(this._recordsToExpand[i]);
    }
    delete this._updatingExpansionComponents;
    delete this._recordsToExpand;
},

// updateRecordComponents() - fired from redraw on grid body (or frozen body).
// This method essentially iterates through our current draw area and ensures that if
// showRecordComponents is true, we're showing recordComponents for each row (or cell),
// calling 'createRecordComponent()' or 'updateRecordComponent()' as necessary to create
// new components, and discarding (or pooling) record components that we previously created
// which are no longer visible.
// This method should not need to be called by developers directly.
// To force an explicit invalidation and refresh of recordComponents, use
// invalidateRecordComponents()
// *Note: This method also handles updating backgroundComponents if specified

updateRecordComponents : function () {
    // Sanity check to avoid infinite loops if adding embedded components trips redraw of
    // body for example
    var debugLog = this.logIsDebugEnabled("recordComponents");
    if (this._updatingRecordComponents) {
        if (debugLog) {
            this.logDebug("updateRecordComponents called recursively - returning",
                "recordComponents");
        }
        return;
    }

     // If we're performing a show/hide row height animation, bail.
    // In this case the HTML in the body won't match the set of records in our data set
    // so we can't update / place embedded components properly
    var body = this.body,
        frozenBody = this.frozenBody;
    if (body == null) return;

    if (body._animatedShowStartRow !=  null) {
        return;
    }

    // This method is fired from various places including gridBody.draw.
    // In this case we may have one body drawn and the other not yet drawn. Wait for both
    // to be drawn before continuing - addEmbeddedComponent (used below) requires the
    // GR be drawn.
    // Also if _fieldWidths isn't set, we can't
    // yet size/position our embedded components. This can occur when we rebuildForFreeze.
    // Catch this case and return.
    if ((!body.isDrawn() || body._fieldWidths == null ||
        (body._fieldWidths.length == 0 && body.fields.length > 0)) ||
        (frozenBody &&
            (!frozenBody.isDrawn() || frozenBody._fieldWidths == null ||
            (frozenBody._fieldWidths.length == 0 && frozenBody.fields.length > 0))))
    {
        return;
    }

    this._updatingRecordComponents = true;

    // Implementation overview: The concept here is that if showRecordComponents is true,
    // we call a method 'createRecordComponent()' [or potentially 'updateRecordComponent']
    // for every visible row, or if showing by cell, every visible cell, lazily as its rendered
    // out.
    // When new cells are rendered out we want to
    // - call createRecordComponent() [or updateRC] for newly rendered cells
    // - *not* call createRC for cells that were visible and still are (regardless of whether
    //   createRecordComponent returned an actual component or just null)
    // - for cells that are no longer visible, clear up the created record components,
    //   clearing them, destroying them or adding them to our 'recordComponentPool' depending on
    //   the recordComponentPoolingMode.
    // Rather than trying to achieve this by tracking viewports (which has the major disadvantage
    // of being fragile on data change or field config change), we take this approach:
    // We store all generated record components in 2 places:
    // - on the records themselves, indexed by fieldName, under record._recordComponents
    // - on the ListGrid in both an array and an object mapping componentIDs to true
    // If the createRecordComponent method returned null for any cell, we store a special
    // nullMarker object on the record._recordComponents object as well.
    //
    // When this method runs we can then iterate through all visible records / fields
    // - determine if we have visible record components already present, or null markers,
    //   in which case we leave the component alone
    // - otherwise run the method to create a new record component / get one from the pool and
    //   apply it to the cell.
    // Once we've gone through all visible cells we iterate through all the recordComponents
    // we previously created and wipe out (either clear, destroy or recycle) any that weren't
    // noted as being attached to a visible cell in the previous step.

    // _liveRecordComponents / _liveRecordComponentsObj is the full set of recordComponents
    // generated last time this method was run.
    var oldRecordCompArr = this._liveRecordComponents || [],
        oldRecordCompObj = this._liveRecordComponentsObj || {};

    if (debugLog) {
        this.logDebug("updateRecordComponents - old record components before refreshing:" +
            this.echo(oldRecordCompArr),
            "recordComponents");
    }

    this._liveRecordComponentsObj = {};
    this._liveRecordComponents = [];

    // If showRecordComponents is false we can skip all logic to create
    // new recordComponents. If we had any previously created recordComponents we'll clear
    // them below. This will handle the showRecordComponents setting being changed dynamically.
    if (this.showRecordComponents || this.showBackgroundComponents) {

        // Determine what our current draw area is - set of drawn fields and rows.
        // This method is being called as part of redraw, before the render has occurred, so
        // we can't just look at body._firstDrawnRow / _lastDrawnRow etc - we need
        // to call the getDrawArea() APIs on the body to actually calculate the new values
        
        var drawArea = this.body.getDrawArea(),
            cellComponents = this.showRecordComponentsByCell,
            bodyID = this.body.getID(),
            frozenBodyID = this.frozenBody ? this.frozenBody.getID() : null;
        
        if (this.recordComponentPoolingMode == "recycle") {
            if (debugLog) {
                this.logDebug("START updateRecordComponents - pre-loop recordComponent " +
                    "cleanup - drawArea is " + drawArea);
                var cleaned = [];
            }
            for (var i = 0; i < oldRecordCompArr.length; i++) {
                // if the component's row is outside of the new draw area, clean the component 
                // up now - this adds it to the pool and allows it to be recycled in the loop 
                // below - otherwise, on the first scroll, we will call createRecordComponent 
                // when we ought to be calling updateRecordComponent
                var comp = oldRecordCompArr[i];
                if (!comp) continue;
                var row = this.getRecordIndex(comp.currentRecord);
                //var row = comp._lastRowNum;
                if (row < drawArea[0] || row > drawArea[1]) {
                    this._cleanUpRecordComponent(comp);
                    oldRecordCompObj[comp.getID()] = null;
                    if (debugLog) {
                        cleaned.add(comp);
                        this.logDebug("cleaned up recordComponent: " + comp.ID + " from row " + row);
                    }
                }
            }
            if (debugLog) {
                this.logDebug("END updateRecordComponents - pre-loop recordComponent cleanup: " + 
                    "cleaned " + cleaned.length + " components");
            }
        }

        if (debugLog) {
            this.logDebug("updating to potentially show recordComponents for drawArea:"
                + drawArea, "recordComponents");
        }
        for (var rowNum = drawArea[0]; rowNum <= drawArea[1]; rowNum++) {
            var record = this.getRecord(rowNum);

            if (record == null || Array.isLoading(record)) continue;

            if (this.showRecordComponents) {

                // If we don't have cell components we will add components to the (unfrozen) body,
                // one per row.
                if (!cellComponents) {

                    var shouldShowRecordComponent = null;
                    // Skip spanned cells.
                    
                    if (this.allowRowSpanning && this.getRowSpan) {
                        var isSpanned = this.getCellStartRow(rowNum, 0) != rowNum;
                        if (isSpanned) shouldShowRecordComponent = false;
                    }

                    if (shouldShowRecordComponent == null) {
                         
                         shouldShowRecordComponent = this.shouldShowRecordComponent(record);
                    }
                    var liveComp = null;
                    if (shouldShowRecordComponent) {
                        // getLiveRecordComponent() will pick up the record component we've already
                        // applied to the record/field.
                        // NOTE: If createRecordComponent ran and returned null we store a special
                        // null-marker object which we'll get back here as well. This means we
                        // don't re-run createRecordComponent() unless we actually want to.
                        liveComp = this._getLiveRecordComponent(record, null, bodyID);
                        if (liveComp != null) {
                            if (liveComp.isNullMarker) {
                                liveComp = null;
                            } else {
                                var ID = liveComp.getID();
                                oldRecordCompObj[ID] = null;
                            }
                        } else {
                            liveComp = this._applyNewRecordComponent(record, null, this.body, rowNum);
                        }
                    }

                    // Store pointers to both the component and its ID
                    
                    if (liveComp != null) {
                        var ID = liveComp.getID();
                        this._liveRecordComponentsObj[ID] = true;
                        this._liveRecordComponents[this._liveRecordComponents.length] = liveComp;
                    }

                // same logic as above, but applied per cell to both the frozen and
                // unfrozen body.
                } else {
                    if (this.frozenBody != null) {
                        for (var fieldNum = 0; fieldNum < this.frozenBody.fields.length; fieldNum++) {
                            var field = this.frozenBody.fields[fieldNum],
                                fieldName = field.name;
                            var shouldShowRecordComponent = null;
                            // Skip spanned cells.
                            if (this.allowRowSpanning && this.getRowSpan) {
                                var isSpanned = this.getCellStartRow(rowNum, field.masterIndex) != rowNum;
                                if (isSpanned) shouldShowRecordComponent = false;
                            }
                            if (shouldShowRecordComponent == null) {
                                shouldShowRecordComponent = this.shouldShowRecordComponent(record, field.masterIndex);
                            }
                            var liveComp = null;

                            if (shouldShowRecordComponent) {
                                liveComp = this._getLiveRecordComponent(record, fieldName, frozenBodyID);
                                if (liveComp != null) {
                                    if (!liveComp.isNullMarker) {
                                        var ID = liveComp.getID();
                                        oldRecordCompObj[ID] = null;
                                    } else {
                                        liveComp = null;
                                    }
                                } else {
                                    liveComp = this._applyNewRecordComponent(record, fieldName, this.frozenBody,
                                                    rowNum, fieldNum);
                                }
                            }
                            if (liveComp != null) {
                                var ID = liveComp.getID();
                                this._liveRecordComponentsObj[ID] = true;
                                this._liveRecordComponents[this._liveRecordComponents.length] = liveComp;
                            }
                        }
                    }
                    for (var bodyCol = drawArea[2]; bodyCol <= drawArea[3]; bodyCol++) {
                        var field = this.body.fields[bodyCol],
                            fieldName = field.name;
                        var shouldShowRecordComponent = null;
                        // Skip spanned cells.
                        if (this.allowRowSpanning && this.getRowSpan) {
                            var isSpanned = this.getCellStartRow(rowNum, field.masterIndex) != rowNum;
                            if (isSpanned) shouldShowRecordComponent = false;
                        }
                        if (shouldShowRecordComponent == null) {
                            shouldShowRecordComponent = this.shouldShowRecordComponent(record, field.masterIndex);
                        }
                        var liveComp = null;

                        if (shouldShowRecordComponent) {
                            var liveComp = this._getLiveRecordComponent(record, fieldName, bodyID);
                            if (liveComp != null) {
                                if (!liveComp.isNullMarker) {
                                     var ID = liveComp.getID();
                                     oldRecordCompObj[ID] = null;
                                } else {
                                    liveComp = null;
                                }
                            } else {
                                liveComp = this._applyNewRecordComponent(record, fieldName, this.body,
                                            rowNum, bodyCol);
                            }
                        }

                        if (liveComp != null) {
                            var ID = liveComp.getID();

                            this._liveRecordComponentsObj[ID] = true;
                            this._liveRecordComponents[this._liveRecordComponents.length] = liveComp;
                        }
                    }
                }
            }

            
            if (this.showBackgroundComponents) {
                if (record && record.backgroundComponent) {
                    var component = this._hasEmbeddedComponents(record) ?
                            this._getEmbeddedComponents(record).find("isBackgroundComponent", true) : null;

                    if (!component) {
                        // should be showing a backgroundComponent but it's not present yet - add it now
                        if (isc.isA.Canvas(record.backgroundComponent)) {
                            // backgroundComponent is specified as a canvas
                            var comp = record.backgroundComponent.addProperties(
                                this.backgroundComponentProperties,
                                { isBackgroundComponent: true }
                            );
                        } else {
                            // backgroundComponent is specified as properties
                            var props = isc.addProperties({ isBackgroundComponent: true },
                                this.backgroundComponentProperties,
                                record.backgroundComponent);
                            var comp = this.createAutoChild("backgroundComponent", props);
                        }

                        var tableIndex = body.getTableZIndex();
                        comp.setZIndex(tableIndex - 49);
                        comp.setWidth("100%");
                        comp.setHeight("100%");
                        comp.setOverflow("hidden");

                        comp.removeOnHideField = true;

                        
                        this.addEmbeddedComponent(record.backgroundComponent, record, rowNum,
                            null, "within");

                        // This should stick with the record until it's wiped due to data change
                        // or similar (EG remapEmbeddedComponents)
                        // At that point, if this method runs again it'll be cleared
                    }
                }
            }
        }
    }

    var drawArea = this.body.getDrawArea();

    for (var rowNum = drawArea[0]; rowNum <= drawArea[1]; rowNum++) {
        var record = this.getRecord(rowNum);

        if (record == null || Array.isLoading(record) || !record.embeddedComponent) {
            continue;
        }

        // Add embedded component to this record
        var position = record.embeddedComponentPosition || "within";
        var fields = record.embeddedComponentFields;
        var colNum = null;

        if (isc.isA.Array(fields) && fields.length > 0) {
            if (fields.length > 2) {
                this.logWarn("Only 2 fields are supported for embeddedComponentFields but " +
                    fields.length + " was provided. Only the 2 first fields will be used.");

                // Lets reduce the fields array down to the first two entries.
                fields = [fields[0], fields[1]];
            }

            for (var fieldIndex = 0; fieldIndex < fields.length; fieldIndex++) {
                colNum = this.fields.findIndex(this.fieldIdProperty, fields[fieldIndex]);

                if (colNum) {
                    break;
                } else {
                    this.logWarn("Could not find field '" + fields[fieldIndex] + "' to embed component inside.");
                }
            }
        }

        // Lets default width and height to 100% on a component that has position "within" and
        // no explicit width and height set.
        if (position === "within" && !record.embeddedComponent.width && !record.embeddedComponent.height) {
            record.embeddedComponent.width = "100%";
            record.embeddedComponent.height = "100%";
        }

        // Turn off autoDismiss on a record with an embedded component.
        record.autoDismiss = false;

        this.addEmbeddedComponent(record.embeddedComponent, record, rowNum, colNum, position);
    }

    this.resized();

    if (this.logIsInfoEnabled("recordComponents")) {
        this.logInfo("updateRecordComponents - new recordComponents:" +
            this.echo(this._liveRecordComponentsObj) +
            ", old record components (will be cleaned up if value is 'true'):" +
            this.echo(oldRecordCompObj), "recordComponents");
    }

    // At this point we've iterated through our draw area (or showRecordComponents is false,
    // in which case we want to drop all pre existing Record Components).
    // Any pre-existing recordComponents that are still visible have been removed from
    // the 'oldRecordCompObj'.
    // Iterate through pre-existing record components that are left and clear them up
    // (remove from DOM if necessary, destroy / pool if necessary)
    for (var i = 0; i < oldRecordCompArr.length; i++) {
        // if it's been cleared from the oldRecordCompObj we know its still visible / being used
        var ID = oldRecordCompArr[i].getID();
        if (oldRecordCompObj[ID] != true) {
            continue;
        }
        if (debugLog) {
            this.logDebug("cleaning up RecordComponent:" + oldRecordCompArr[i], "recordComponents");
        }
        this._cleanUpRecordComponent(oldRecordCompArr[i]);
        oldRecordCompObj[ID] = null;
    }
    delete this._updatingRecordComponents;
},

// _applyNewRecordComponent()
// This method will run 'createRecordComponent()' or 'updateRecordComponent()' to
// get the recordComponent for some record or cell.
_applyNewRecordComponent : function (record, fieldName, body, rowNum, bodyCol) {

    if (this.logIsDebugEnabled("recordComponents")) {
        this.logDebug("getting record component for row/field:" + [rowNum,fieldName],
            "recordComponents");
    }

    var pool = this.recordComponentPoolingMode == "recycle",
        component,
        // same row variable - only used if we're picking up a pooled component
        sameRow,
        colNum = fieldName == null ? null : this.getColNum(fieldName)
    ;

    if (pool) {
        var compConfig = this.getFromRecordComponentPool(record, fieldName);
        component = compConfig ? compConfig[0] : null;
        sameRow = compConfig ? compConfig[1] : null;
    }

    if (!component) {
        if (this.createRecordComponent && isc.isA.Function(this.createRecordComponent)) {
            component = this.createRecordComponent(record, this.getColNum(fieldName));
            if (component != null) component.isRecordComponent = true;
            this.logDebug("created new record component:" + component, "recordComponents");
        }
    } else {
        if (this.updateRecordComponent && isc.isA.Function(this.updateRecordComponent)) {
            var origComponent = component;

            component = this.updateRecordComponent(record, colNum, component, !sameRow);

            // component may well be null - this is valid and allows the developer to
            // suppress components in cells even in pooling mode.
            if (component == null) {
                if (this.logIsInfoEnabled("recordComponents")) {
                    this.logInfo("showRecordComponents: updateRecordComponent() method " +
                        "failed to return an updated component.", "recordComponents");
                }
                // stick it back into the pool for future use
                this.addToRecordComponentPool(origComponent);
            }
            this.logDebug("updated record component from pool:" + component, "recordComponents");
        }
    }
    return this._finishApplyNewRecordComponent(record, fieldName, body, rowNum, bodyCol, component);
},

_finishApplyNewRecordComponent : function (record, fieldName, body, rowNum, bodyCol, component) {
    var pool = this.recordComponentPoolingMode == "recycle",
        addNullMarker = component == null;
    if (addNullMarker) {
        component = {
            isNullMarker:true,
            _embedBody:body.getID(),
            _recordComponentBatch:this._recordComponentSequence
        }
    }
    if (fieldName == null) fieldName = this._$noFieldString;
    
    this._addRecordComponent(record, fieldName, component);
    // We're applying a "currentFieldName" / "currentRecord" flag in addition
    // to the _currentFieldName applied by the embeddedComponents code. This is
    // intentional - we use these flags in pooling mode to pick up the component that
    // matched the previous record (if possible) and previous field if
    // poolComponentsPerColumn is true. Don't want to rely on the flags that are set up and
    // potentially cleared by the standard embeddedComponent subsystem.
    if (pool && !addNullMarker) {
        component.currentFieldName = fieldName;
        component.currentRecord = record;
    }
    if (!addNullMarker) {
        // have the recordComponent removed if the field it's in is hidden
        component.removeOnHideField = true;

        //this.logWarn("created component:" + component + ", adding to:" + [rowNum,fieldName]);
        return body.addEmbeddedComponent(component, record, rowNum, bodyCol, this.getRecordComponentPosition());
    }
},

//> @method listGrid.setDontAutoDestroyComponent()
// If +link{listGrid.showRecordComponents} is true, by default any created record components
// are destroyed once they are no longer in use (for example, if the ListGrid as a whole is
// destroyed).  This method may be used to suppress this behavior for some component. Typical
// usage might call this method as part of +link{listGrid.createRecordComponent()} to suppress
// this behavior.
// @param component (Canvas) component in question.
// @param dontAutoDestroy (boolean) If true, the component will not be destroyed automatically when
//   the grid is destroyed
// @visibility external
//<

setDontAutoDestroyComponent : function (component, dontAutoDestroy) {
    component.dontAutoDestroy = dontAutoDestroy;
},

// fired when a recordComponent's cell is no longer visible. Behavior depends on
// recordComponentPoolingMode.
_cleanUpRecordComponent : function (component, forceDestroy) {
    if (this.logIsDebugEnabled("recordComponents")) {
        this.logDebug("cleaning up recordComponent:" + component,
            "recordComponents");
    }

    var poolingMode = this.recordComponentPoolingMode;
    // If passed the forceDestroy parameter, behave in 'viewport' mode regardless of
    // the actual pooling mode - this means we'll destroy the component passed in.
    if (forceDestroy) poolingMode = "viewport";

    if (poolingMode == "data") {
        // No need to attempt to pool, etc here:
        // If the record is still around, placeEmbeddedComponent() will have cleared it and
        // it'll simply re-render when scrolled back into view, etc.
        //
        // If the record is no longer present in the data array, remapEmbeddedComponents()
        // will have already marked it for destruction, and updateRecordComponents() has
        // already rebuilt the array of _liveRecordComponents so we won't be hanging onto
        // a pointer to it anymore.
        //
        // However - when the listGrid as a whole gets destroyed, we should ensure the
        // recordComponent gets destroyed too.
        // Handle this by storing a separate reference to it which we can look at on
        // destroy(). Use "pointersToThis" to ensure that if the component gets destroyed separately
        // (while this component is still intact) we don't hang onto this reference.
        if (!component.destroyed && !component.destroying && !component._pendingDestroy) {
            if (this._orphanedRecordComponents == null) {
                this._orphanedRecordComponents = {};
            }
            var ID = component.ID;
            if (this._orphanedRecordComponents[ID] != component) {
                this._orphanedRecordComponents[ID] = component;
                // set up 'pointersToThis'
                if (component.pointersToThis == null) component.pointersToThis = [];
                component.pointersToThis.add({
                    object: this._orphanedRecordComponents, property: ID
                });
            }
        }

    } else {
        var ID = component.ID,
            body = isc.Canvas.getById(component._embedBody),
            record = component.embeddedRecord,
            fieldName = component._currentFieldName;

        // wipe the component from the components-cache on the record [IF it hasn't been updated
        // to point at a new component]
        
        
        if (this._hasRecordComponents(record)) {
            this._deleteRecordComponent(record, fieldName);
        }

        // this component may have already been removed from the body, for example by
        // _remapEmbeddedComponentColumns(). In this case _embedBody will have been null
        // so we can detect this by the body var being unset here.
        if (body != null) {
            body.removeEmbeddedComponent(record, component);
            // also remove the entry from record._embeddedComponents_{ID}
            this._removeEmbeddedComponent(record, component);
        }

        if (poolingMode == "viewport") {
            if (!component.dontAutoDestroy) component.markForDestroy();
        } else {
            
            if (component.destroying || component.destroyed || component._pendingDestroy) return;
            this.addToRecordComponentPool(component);
        }
    }
},

// Helper method - look at a record and see if we currently have a recordComponent for it.

_$noFieldString:"_noField",
_recordComponentSequence:0,

getLiveRecordComponent : function (record, fieldName, bodyID) {
    if (!record) return null;
    if (isc.isA.Number(record)) record = this.getRecord(record);
    if (!bodyID) bodyID = this.body.getID();
    var comp = this._getLiveRecordComponent(record, fieldName, bodyID);
    return comp;
},
_getLiveRecordComponent : function (record, fieldName, bodyID) {
    if (fieldName == null) fieldName = this._$noFieldString;

    if (!this._hasRecordComponents(record)) return null;
    var recordComponents = this._getRecordComponents(record);

    if (recordComponents[fieldName] == null) return null;

    var component = recordComponents[fieldName];

    if (component._embedBody != bodyID) {
        return null;
    }
    if (component.isNullMarker && component._recordComponentBatch != this._recordComponentSequence) {
        return null;
    }

    // We should never see this but if a component gets destroyed without first being
    // cleared out of the record._recordComponents block, wipe it out now. This will force
    // creation of a new recordComponent in calling code.
    if (component.destroyed || component.destroying || component._pendingDestroy) {
        this.logWarn("Destroyed or Destroying record component:" + component +
            " present on record. Ignoring", "recordComponents");
        recordComponents[fieldName] = null;
        return null;
    }
    return component;
},

//> @method listGrid.invalidateRecordComponents()
// Invalidates the currently visible set of +link{listGrid.showRecordComponents,recordComponents}
// and gets fresh ones for the visible rows in the grid according to the
// +link{listGrid.recordComponentPoolingMode}
// <P>
// See also +link{listGrid.refreshRecordComponent()} which allows you to refresh a specific
// recordComponent
//
// @visibility external
//<
invalidateRecordComponents : function () {

    // force destruction of the visible recordComponents - otherwise this
    // method would have no visible effect in 'data' pooling mode.
    this.dropRecordComponents(true);

    if (this.showRecordComponents && this.isDrawn()) {
        this.updateRecordComponents();
    }
},

dropRecordComponents : function (forceDestroy) {

    // up the recordComponentSequence count. This is used to identify our special null markers
    // and essentially invalidates them, meaning we'll re-run the createRecordComponent logic
    // for records with null markers we've already set at this point.
    
    this._recordComponentSequence++;

    var oldRecordCompArr = this._liveRecordComponents || [];

    delete this._liveRecordComponents;
    delete this._liveRecordComponentsObj;

    for (var i = 0; i < oldRecordCompArr.length; i++) {
        this._cleanUpRecordComponent(oldRecordCompArr[i], forceDestroy);
    }
},

//> @method listGrid.refreshRecordComponent()
// Discards any +link{listGrid.showRecordComponents,recordComponent} currently assigned to the
// specified record (or cell) and gets a fresh one, according to the
// +link{listGrid.recordComponentPoolingMode}
// <P>
// See also +link{listGrid.invalidateRecordComponents()} which allows you to refresh all record
// components that are currently visible in the grid.
//
// @param rowNum (int) Row to refresh
// @param [colNum] (Integer) Column to refresh. This parameter should be passed
//      if +link{showRecordComponentsByCell} is true.
// @visibility external
//<
refreshRecordComponent : function (rowNum, colNum) {
    if (!this.showRecordComponents || rowNum == null || this.body == null) return;

    if (this.showRecordComponentsByCell && colNum == null) {
        this.logWarn("refreshRecordComponent() called with no colNum. This parameter is required when " +
            "showRecordComponentsByCell is true. Taking no action.");
        return;
    }

    var record = this.getRecord(rowNum);
    if (record == null || Array.isLoading(record)) return;

    var body = this.body,
        bodyColNum = null,
        fieldName = null;

    if (this.showRecordComponentsByCell) {
        body = this.getFieldBody(colNum);
        bodyColNum = this.getLocalFieldNum(colNum);
        fieldName = this.getFieldName(colNum);
    }

    var prevComp = this._getLiveRecordComponent(record, fieldName, body.getID());
    if (prevComp != null && prevComp.isNullMarker) prevComp = null;

    var shouldShowComponent = this.shouldShowRecordComponent(record, colNum);

    var liveComp;
    if (prevComp != null) {
        
        if (shouldShowComponent && isc.isA.Function(this.updateRecordComponent)) {
            liveComp = this.updateRecordComponent(record, colNum, prevComp, false);
            if (liveComp != prevComp) {
                this._cleanUpRecordComponent(prevComp, (this.recordComponentPoolingMode != "recycle"));
                this.addToRecordComponentPool(prevComp);

                liveComp = this._finishApplyNewRecordComponent(record, fieldName, body, rowNum, bodyColNum, liveComp);
                if (liveComp && liveComp.isNullMarker) liveComp = null;
            }
            shouldShowComponent = false;
        } else {
            // This will destroy the component, or add to the pool.
            this._cleanUpRecordComponent(prevComp, (this.recordComponentPoolingMode != "recycle"));
        }
    }

    if (shouldShowComponent) {
        liveComp = this._applyNewRecordComponent(record, fieldName, body, rowNum, bodyColNum);
        if (liveComp && liveComp.isNullMarker) liveComp = null;
    }

    // Update this._liveRecordComponents and this._liveRecordComponentsObj
    var index = this._liveRecordComponents.length;
    if (prevComp) {
        var ID = prevComp.getID();
        this._liveRecordComponentsObj[prevComp.getID()] = null;
        // Null the slot in the live recordComponents array and reuse it if possible for
        // efficiency.
        if (liveComp != null) {
            index = this._liveRecordComponents.indexOf(prevComp);
            this._liveRecordComponents[index] = null;
        } else {
            this._liveRecordComponents.remove(prevComp);
        }
    }

    if (liveComp != null) {
        var ID = liveComp.getID();
        this._liveRecordComponentsObj[ID] = true;
        this._liveRecordComponents[index] = liveComp;
    }
},

getRecordComponentPosition : function () {
    if (this.recordComponentPosition != null) return this.recordComponentPosition;
    return (this.showRecordComponentsByCell ? "within" : "expand");
},

getRecordComponentPool : function () {
    if (!this._recordComponentPool) this._recordComponentPool = [];
    return this._recordComponentPool;
},

// we want to indicate whether the record changed. Handle this by returning a 2 element array
// - the component and a boolean.
getFromRecordComponentPool : function (record, fieldName) {
    var components = this.getRecordComponentPool(),
        subList = [],
        fieldSpecific = this.showRecordComponentsByCell && this.poolComponentsPerColumn == true,
        component
    ;

    if (!components || components.length == 0) return null;

    if (fieldSpecific) {
        subList = components.findAll("currentFieldName", fieldName);
    } else {
        subList = components;
    }
    if (!subList || subList.length == 0) return null;

    for (var i = 0; i < subList.length; i++) {
        component = subList[i];
        var prevRecord = component.currentRecord;
        if (this.comparePrimaryKeys(prevRecord, record)) {
            components.remove(component);
            return [component,true];
        }
    }
    
    // we didn't find a component that previously sat in this record (and that had the correct
    // fieldName, if we're pooling by column) - just return the last component from the 
    // applicable list (subList)
    
    components.remove(component);
    return [component,false];
},

addToRecordComponentPool : function (component) {
    var components = this.getRecordComponentPool();

    components.add(component);
},

// Should we show a recordComponent for this record/col?
// checks for various records we want to skip, like the separator rows, and
// fires the public 'showRecordComponent()' method to allow custom suppression of RCs for
// certain rows or cells.
shouldShowRecordComponent : function (record, colNum) {

    if (record == null || record._isGroup || record[this.isSeparatorProperty]
        || Array.isLoading(record))
    {
        return false
    }
    return this.showRecordComponent(record,colNum);
},

// Override point documented in registerStringMethods().

showRecordComponent : function () {
    return true;
},

// notification from each body when getInnerHTML is called.
bodyDrawing : function (body) {

    if (isc._traceMarkers) arguments.__this = this;

    // don't fetch valueMap in response to draw on both the frozen and liquid body - just
    // on the normal (liquid) one
    if (body != this.body) return;

    // when the primary body draws, kick of a queue of requests for the visible data and any
    // valueMaps we'll need for fields with optionDataSource set
    var startedQueue;
    if (this._fetchValueMap) {
        // fetch valueMaps for fields where optionDataSource is set
        startedQueue = !isc.RPCManager.startQueue();
        this._fetchValueMapData();
    }
    this.requestVisibleRows();

    if (startedQueue) isc.RPCManager.sendQueue();
    this._fetchValueMap = null;
    delete this._redrawOnScrollInProgress;
},


//> @attr listGrid.recordComponentHeight (Integer : null : IRWA)
// If +link{listGrid.showRecordComponents} is true, this attribute may be used to
// specify a standard height for record components.
// If specified every row in the grid will be sized tall enough to accommodate a recordComponent
// of this size.
// <P>
// Note that if this property is unset, the grid will not be able to know row heights in
// advance, and +link{listGridField.frozen,frozen fields} are not currently supported in
// this case.  If you are putting a recordComponent in every row, and they all have a consistent
// height, set <code>recordComponentHeight</code> and you will then be able to use frozen fields
// <i>and</i> avoid the whitespace side-effect of virtual scrolling by setting 
// +link{virtualScrolling}:false.
// <P>
// Similarly, if your recordComponents are never tall enough that they will expand the row
// beyond the +link{cellHeight}, set +link{virtualScrolling}:false to avoid the whitespace
// side-effect of +link{virtualScrolling,virtual scrolling} and to allow 
// +link{listGridField.frozen,frozen fields} to be used.  In this mode, you can have
// recordComponents on some rows but not others, and recordComponents of different heights, so
// long as no recordComponent ever causes a row to grow beyond +link{cellHeight} (which would
// happen if the recordComponents height + 2*+link{cellPadding} is larger than 
// +link{cellHeight}).
// 
// @see virtualScrolling
// @visibility external
//<


//> @method listGrid.setRecordComponentHeight()
// Setter for the +link{listGrid.recordComponentHeight}
// @param height (integer) recordComponent height
// @visibility external
//<
setRecordComponentHeight : function (height) {
    this.recordComponentHeight = height;
    if (this.isDrawn()) this.markForRedraw();
},

// Override 'getAvgRowHeight()' - if recordComponentHeight is specified and we're showing
// recordComponents, make use of it.
// Used by the gridRenderer in virtual scrolling mode to figure out end spacer size /
// thumb size.
getAvgRowHeight : function (body) {

    if (this.showRecordComponents && this.recordComponentHeight != null) {
        var rcrh = this.getRecordComponentRowHeight();
        if (rcrh != null) return rcrh;
    }
    // standard behavior
    // For virtual-scrolling, rely on the "avgRowHeight" specified in the body
    // otherwise assume constant record heights for all rows.
    return !body.virtualScrolling ? body.cellHeight
                                 : Math.max(body.cellHeight,body.avgRowHeight);

},

_$expand:"expand",
getRecordComponentRowHeight : function () {
    if (this.recordComponentHeight == null) return null;
    var pos = this.getRecordComponentPosition();
    if (pos == this._$expand) return this.cellHeight + this.recordComponentHeight;
    else return Math.max(this.recordComponentHeight, this.cellHeight);
},

// ListGridField.optionDataSource handling
// ---------------------------------------------------------------------------------------

// This logic handles fields where an optionDataSource acts as a server-side valueMap
//
// For fields with a specified optionDataSource separate from this grid's dataSource, with
// displayField and valueField specified, we need to perform a fetch against the server to
// get a map from data values to display values

// _setOptionDataSources() (called from setFields())
// iterate through the list of fields and take note of optionDataSource property to look up the
// display map later when the LG is drawn or redrawn (see bodyDrawing)
_setOptionDataSources : function () {

    
    // _fetchValueMap - one time flag to kick off a fetch in bodyDrawing
    var pendingFetch = this._fetchValueMap;
    this._fetchValueMap = null;

    var oldODSs = this._optionDataSources;
    this._optionDataSources = [];

    var gridDS = this.getDataSource();

    for (var i = 0; i < this.completeFields.length; i++) {
        var field = this.completeFields[i];
        
        if (field == null) {
            this.logWarn("Fields array contains an empty entry");
            continue;
        }

        var displayField = field.displayField || field[this.fieldIdProperty],
            valueField = field.valueField || field[this.fieldIdProperty];

        // autoFetchDisplayMap can be set at the field or LG level
        if (field.optionDataSource == null ||
            // If the display field matches the valueField don't bother to do a fetch since
            // we don't need to map the static raw cell value to a display value.
            // If the field is editable this means that we'll rely on the editor to perform a fetch
            // based on the optionDataSource rather than being passed an explicit valueMap.
            field.displayField == null || (field.displayField == field.valueField) ||
            (field.valueField == null && (field.displayField == field[this.fieldIdProperty])) ||
            (field.autoFetchDisplayMap == false) ||
            (this.autoFetchDisplayMap == false && field.autoFetchDisplayMap == null))
        {
            continue;
        }

        var optionDS = isc.DS.get(field.optionDataSource);
        if (optionDS == null) {
            this.logWarn(field.optionDataSource + " dataSource not found, check value of " +
                         "optionDataSource property on the " + field[this.fieldIdProperty] +
                         " field");
            continue;
        

        }

        var optionDSID = optionDS.ID,
            fieldName = field[this.fieldIdProperty],
            optionCriteria = field.optionCriteria;

        // have we already set up an optionDataSource config object from our previous set of fields?
        // which matches this ODS / criteria?

        // If so re-use it - we may not even need to re-fetch data!
        var addedToConfig = false;
        // Never try to fold fields with explicitly specified optionFetchContext into
        // a single responses
        if (oldODSs && !field.optionFilterContext) {
            for (var ii = 0; ii < oldODSs.length; ii++) {
                var ODSConfig = oldODSs[ii];
                if (ODSConfig == null) continue;
                if (this._fieldMatchesODSConfig(field, ODSConfig)) {
                    ODSConfig._fields = [field];
                    this._optionDataSources.add(ODSConfig);
                    oldODSs[ii] = null;
                    addedToConfig = true;
                    /*
                    this.logWarn("setOptionDataSources() field:"+ field.name +
                        " bound to dataSource ID:"+ optionDSID +
                        ", [crit:"+ this.echo(optionCriteria) +
                        "] matched existing optionDataSource config block from previous fields " +
                        "so added field to config.");
                    */
                    break;
                }
            }
        }

        if (!addedToConfig && !field.optionFilterContext) {
            for (var ii = 0; ii < this._optionDataSources.length; ii++) {
                var ODSConfig = this._optionDataSources[ii];
                if (this._fieldMatchesODSConfig(field, ODSConfig)) {
                    ODSConfig._fields.add(field);
                    addedToConfig = true;
                    /*
                    this.logWarn("setOptionDataSources() field:"+ field.name +
                        " bound to dataSource ID:"+ optionDSID +
                        ", [crit:"+ this.echo(optionCriteria) +
                        "] matched existing optionDataSource config block so added to field.");
                    */
                    break;
                }
            }
        }

        if (!addedToConfig) {
            this._optionDataSources.add({
                _dsID:optionDSID,
                _fields:[field],
                _textMatchStyle:field.optionTextMatchStyle,
                _criteria:optionCriteria,
                _optionContext:field.optionFilterContext,
                _optionOperationId:field.optionOperationId
            });

            // -- is this the only case where we need to fetch?
            //    Assumption is that in other cases we either already kicked off a fetch
            //    or picked up the field from our 'old ds's', and so already have a resultSet

            // keep going for a bit...


            // in this case we need to kick off a fetch for this dataSource
            // Set the flag to handle this when the body gets redrawn to reflect the new set of
            // fields
            /*
            this.logWarn("setOptionDataSources() field:"+ field.name +
                " bound to dataSource ID:"+ optionDSID +
                ", [crit:"+ this.echo(optionCriteria) +
                "] doesn't match fetch conditions for any other field with an option dataSource, " +
                "so performing a new fetch for it.");
            */
            this._fetchValueMap = true;
        }
    }

    // If we added to existing config, and we've cleared the _fetchValueMap flag,
    // this implies we have a fetch config set up (which we've updated) but we haven't
    // kicked off the fetch. Re-set the fetchValueMap flag so we do fetch on body draw.
    if (addedToConfig && !this._fetchValueMap && pendingFetch) {
        this._fetchValueMap = true;
    }

    // update the valueMaps for new fields bound to optionDataSources for which we already have
    // a resultSet
    for (var i = 0; i < this._optionDataSources.length; i++) {
        if (this._optionDataSources[i]._data != null) {
            this._updateValueMapFromODS(this._optionDataSources[i]);
        }
    }

    // If we had any previous optionDataSource config type options which are no longer required,
    // clean them up now by calling 'destroy()' on the resultSet (data object) and letting everything
    // go out of scope at the end of the method.
    if (oldODSs != null) {
        for (var i = 0; i < oldODSs.length; i++) {
            if (oldODSs[i] && oldODSs[i]._data) oldODSs[i]._data.destroy();
        }
    }
},

// little helper method - does a field with an optionDataSource specified match an existing
// optionDataSource config object.

_fieldMatchesODSConfig : function (field, config) {

    return (
        // same dataSource
        config._dsID == field.optionDataSource &&
        // optionTextMatchStyle should match
        
        (field.optionTextMatchStyle == config._textMatchStyle) &&
        // if optionOperationId is specified on a field it must also match
        (field.optionOperationId == config._optionOperationId) &&
        // criteria unset or match
        (isc.DataSource.getDataSource(config._dsID).compareCriteria(
            field.optionCriteria || {}, config._criteria || {}) == 0)
    );

},

// Given a resultSet bound to a dataSource, update the valueMap for any fields bound to this
// optionDataSource.
_updateValueMapFromODS : function (ODSConfig) {
    var odsID = ODSConfig._dsID,
        fields = ODSConfig._fields;

    if (fields == null || fields.length == 0) {
        this.logWarn("_updateValueMapFromODS fired for dataSource:"+ odsID +
                    " which no longer applies to any fields in this ListGrid");
        return;
    }

    var resultSet = ODSConfig._data;

    // avoid trying to get a valueMap if we are called when the cache has just been invalidated
    // or before the ResultSet has been created
    if (resultSet == null ||
        // only bail if we have a resultSet with unknown length AND no initialData
        (isc.isA.ResultSet(resultSet) && !resultSet.lengthIsKnown() && !resultSet.initialData))
    {
            return;
    }

    if (ODSConfig._optionOperationId) {
        // if the ODSConfig has an optionOperationId, set that as the fetch op on the resultSet
        resultSet.fetchOperation = ODSConfig._optionOperationId;
    }

    var groupBy = this.getGroupByFields() || [],
        fieldNames = fields.getProperty(this.fieldIdProperty),
        needsRegroup = false
    ;

    if (!isc.isAn.Array(groupBy)) groupBy = [groupBy];

    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            valueField = (field.valueField || field[this.fieldIdProperty]),
            map = resultSet.getValueMap(valueField, field.displayField)
        ;
        // If we haven't yet integrated the field into our fields array, store the
        // valueMap on it directly rather than calling this.setValueMap() -- this way it'll get
        // picked up when setFields() completes
        if (this.getField(field[this.fieldIdProperty]) == null) {
            field.valueMap = map;
        } else {
            this.setValueMap(field[this.fieldIdProperty], map);
        }

        if (groupBy.contains(field.valueField) || groupBy.contains(field.displayField)) {
            // if we've just loaded the ODS for one of the groupFields, we need to regroup to
            // re-evaluate the groupTitles
            this._needsRegroup = true;
        }

    }

    if (this._needsRegroup) {
        // we need a regroup - check to see if all ODSs have been loaded and only regroup if
        // they have
        var allConfigLoaded = true;
        for (var i = 0; i < this._optionDataSources.length; i++) {
            var ODSConfig = this._optionDataSources[i];
            if (!ODSConfig._data) {
                allConfigLoaded = false;
                break;
            }
        }

        if (allConfigLoaded) {
            this.regroup(true);
            delete this._needsRegroup;
        }
    }
},


// _fetchValueMapData()
// for fields with an optionDataSource, kick off a fetch to get a valueMap for the field
_fetchValueMapData : function () {

    var shouldSendQueue;

    // For each field with an optionDataSource, kick off a fetch if we have no data, otherwise
    // update the valueMap with the existing data
    for (var i = 0; i < this._optionDataSources.length; i++) {
        var ODSConfig = this._optionDataSources[i];
        if (ODSConfig._data == null) {
            if (shouldSendQueue == null) {
                shouldSendQueue = !isc.RPCManager.startQueue();
            }

            var optionDSID = ODSConfig._dsID;

            // add component context to request properties for rpc history tree in dev console
            // as a comma delimited list of fields bound to the ODS in question
            var compContext,
                optFields = ODSConfig._fields;
            if (optFields && optFields.length > 0) {
                compContext = "ODS:";
                for (var ii = 0; ii < optFields.length; ii++) {
                    compContext += optFields[ii].name;
                    if (ii < optFields.length - 1) compContext += ",";
                }
            }

            var context = ODSConfig._optionContext || {};
            isc.addProperties(
                context,
                {showPrompt:false, internalClientContext:{ODSConfig:ODSConfig},
                 componentId:this.getID(),
                 componentContext: compContext,
                 textMatchStyle:ODSConfig._textMatchStyle
                }
            );
            if (ODSConfig._optionOperationId != null) {
                context.operationId = ODSConfig._optionOperationId;
            }
            isc.DataSource.getDataSource(optionDSID).fetchData(
                ODSConfig._criteria,
                {target:this, methodName:"_fetchValueMapCallback"},
                context
            );
        }
    }

    if (shouldSendQueue) isc.RPCManager.sendQueue();
},


// _fetchValueMapCallback()
// Callback from request to get all data from some field's optionDS.
// Creates a valueMap so we show the displayField value in the field
_fetchValueMapCallback : function (dsResponse, data, dsRequest) {

    var optionDataSourceConfig = dsRequest.internalClientContext.ODSConfig;
    // if the fields were changed before the fetch returned
    // OR we kicked off 2 fetches against the same dataSource and have already
    // set up our resultSet data, bail
    if (!optionDataSourceConfig || (optionDataSourceConfig._data != null) ||
        !this._optionDataSources || !this._optionDataSources.contains(optionDataSourceConfig))
    {
        return;
    }

    optionDataSourceConfig._data = isc.ResultSet.create({
        dataSource:optionDataSourceConfig._dsID,
        ODSConfig:optionDataSourceConfig,
        targetGrid:this,
        dataChanged:"this.targetGrid._updateValueMapFromODS(this.ODSConfig)",
        initialData:data
    })

    // Force an update now
    this._updateValueMapFromODS(optionDataSourceConfig);

    return true;
},

getPromptStyle : function () {
    return isc.useHighPerformanceGridTimings && this._redrawOnScrollInProgress ? "component" : null;
},
    
showComponentPrompt : function () {
    this.loadingData = true;
    if (this.sorter && this.sorter.setTitle) {
        this.sorter.setTitle(this.sorter.getTitle());
    }
},
clearComponentPrompt : function () {
    delete this.loadingData;
    if (this.sorter && this.sorter.setTitle) {
        this.sorter.setTitle(this.sorter.getTitle());        
    }
},
    
// Helper to destroy() the resultSet(s) we create to handle valueMaps from the server
_dropODSData : function () {
    if (this._optionDataSources == null) return;
    for (var i = 0; i < this._optionDataSources.length; i++) {
        var data = this._optionDataSources[i]._data;
        if (data) data.destroy();
    }
    delete this._optionDataSources;
},

requestVisibleRows : function () {
    // ask for all the rows we're about to render.  This enables better predictive fetching
    // relative to asking for data one row at a time while we render.
    
    var isResultSet = (isc.ResultSet != null && isc.isA.ResultSet(this.data)),
        isPagedResultTree = (
            isc.ResultTree != null && isc.isA.ResultTree(this.data) && this.data.isPaged());
    
    if (isResultSet || isPagedResultTree) {

        if (this.body == null || this.body._reused) {
            
            var willBeGrouped = (isResultSet && (
                    this.isGrouped ||
                    (this.groupByField != null && this.getUnderlyingField(this.groupByField))));
            if (willBeGrouped) {
                var dataPageSize = Math.max(this.dataPageSize || 0, 1);
                
                return this.data.getRange(0, Math.max(dataPageSize, this.groupByMaxRecords));
            } else {
                return this.data.getRange(0, this.dataPageSize);
            }
        }
        
        if (isResultSet && this.data.lengthIsKnown() && this.data.getLength() == 0) {
            return;
        }

        
        if ((isResultSet && !this.data.lengthIsKnown()) || isPagedResultTree) {
            this.body.showAllRows = false;
        } else {
            // NOTE: this check is necessary because the body itself forces showAllRows to true
            // on init if overflow:visible.  It would probably be more robust to pass a
            // one-time flag to getTableHTML() so that we don't clobber other changes to
            // showAllRows
            this.body.showAllRows = (this.body.overflow == isc.Canvas.VISIBLE ?
                                     true : this.showAllRecords);
        }
        
        var drawRect = this.body.getDrawArea();
        if (this._scrollCell && isc.isAn.Array(this._scrollCell)) {
            // if scrolling was applied before draw(), move the drawRect to the requested row
            var diff = drawRect[1]-drawRect[0];
            drawRect[0] = this._scrollCell[0];
            drawRect[1] = drawRect[0]+diff;
        }

        // force all rows to be grabbed if we're grouping. (We'll need them anyway.)
        if (isResultSet && this.isGrouped) {
            
            return this.data.getRange(0, this.groupByMaxRecords);
        } else {
            // getRange() is non-inclusive at the end, but getDrawArea() is inclusive
            // at the end so we need to increment drawRect[1] by 1.
            return this.data.getRange(drawRect[0], drawRect[1]+1);
        }

    
    } else if (this.body != null) {
        // If our data isn't a resultSet, ensure that showAllRows reflects this.showAllRecords
        // This is required for the case where we are databound and grouped so this.data
        // was a resultSet when this method last ran and is now a client-side tree with
        // complete results
        this.body.showAllRows = (this.body.overflow == isc.Canvas.VISIBLE ?
                                     true : this.showAllRecords);
    }
    return null;
},

// Printing
// --------------------------------------------------------------------------------------------

//> @attr listGrid.printAutoFit (Boolean : true : IRW)
// Whether cell contents should wrap during printing.  Equivalent to +link{type:Autofit}, but
// specific to printed output.
// @group printing
// @visibility external
//<
printAutoFit:true,

//> @attr listGrid.printWrapCells (Boolean : true : IRW)
// Whether cell contents should wrap during printing.  Equivalent to +link{wrapCells}, but
// specific to printed output.
// @group printing
// @visibility external
//<
printWrapCells:true,

//> @attr listGrid.printHeaderStyle (CSSStyleName : "printHeader" : IRW)
// Style for header cells in printed output.  Defaults to +link{headerBaseStyle} if null.
// @group printing
// @visibility external
//<
printHeaderStyle:"printHeader",

//> @attr listGrid.printBaseStyle (CSSStyleName : null : IRW)
// Style for non-header cells in printed output.  Defaults to +link{baseStyle} if null.
// @group printing
// @visibility external
//<

//> @attr ListGrid.printMaxRows (int : 100 : IRWA)
// Advanced property - when generating printHTML for a large ListGrid, rows are printed in
// batches in order to avoid triggering a native "script is running slowly" browser dialog.
// <P>
// For grids with exceptional numbers of columns or complex formatting logic, this number
// might need to be adjusted downward.
//
// @group printing
// @visibility external
//<
// Note that this means getPrintHTML() is frequently asynchronous for ListGrids
printMaxRows:100,




getPrintHTML : function (printProperties, callback) {

    var body = this.body;
    // we may have getPrintHTML called while we're undrawn - if so, we'll need to set up our
    // children here
    if (body == null) {
        this.createChildren();
        body = this.body;
    }

    // if the body is pending a redraw, force it now
    if (this.isDirty() || body.isDirty()) {
        this.redraw("updating HTML for printing");
    }

    var printProps = isc.addProperties({}, printProperties, this.printProperties);

    // with a partial cache, print only the contiguous cache around the currently visible rows
    
    var startRow, endRow;
    if (isc.isA.ResultSet(this.data) && !this.data.allMatchingRowsCached()) {
        var visRows = this.body.getVisibleRows(),
            firstVisibleRow = visRows ? visRows[0] : null,
            cachedRange = this.data.getCachedRange(firstVisibleRow);
        if (cachedRange != null) {
            startRow = cachedRange[0];
            endRow = cachedRange[1];
        }
    }

    
    var printWidths = isc.Canvas.applyStretchResizePolicy(this.fields.getProperty("width"),
                                                printProps.width || isc.Page.getWidth());

    // set up the HTML for the header / footer rows based on
    // gridComponents. This will actually be written out by the grid body.
    // Ultimately calls body.getTablePrintHTML() and returns the combined result
    var HTML = this.setupHeaderPrintHTML({startRow:startRow, endRow:endRow, callback:callback,
                                     printWidths:printWidths, printProps:printProps});
                                     
    // if a callback was passed, it will always fire, and this method should return nothing,
    // unless it's being used as an expansionRelated grid inside another LG
     if (this.isExpansionGrid || !callback) {
        return HTML;
    }
},

// This method will generate HTML for the header / footer rows, ultimately picked up by
// the override to gridBody.getPrintHeaders() / getPrintFooters()
// Note - potentially asynchronous, depending on what gridComponents are specified.
setupHeaderPrintHTML : function (gridPrintConfig, HTML, componentIndex) {
    var isAsync = componentIndex != null;
    if (HTML == null) HTML = "";
    if (componentIndex == null) componentIndex = 0;

    var body = this.body;

    // Used by 'shouldPrintChild' and possibly printHTML of arbitrary children
    this.currentPrintProperties = gridPrintConfig.printProps;

    var components = this.gridComponents;
    for (var i = componentIndex; i < components.length; i++) {
        var comp = components[i];

        // Once we hit the body, we've got all the "header" row HTML - store that
        // on the body (will be returned by customized 'getPrintHeaders()'), and
        // continue onto the footer HTML
        
        if (comp == "body") {
            body._printHeadersHTML = HTML;
            // reset "HTML" to start collecting "footers" HTML
            HTML = "";
            continue;
        }

        // This will skip the filterEditor, and anything that's not actually showing
        // by default.
        if (!this.shouldPrintGridComponent(comp)) {
            continue;
        }

        if (comp == "header") {
            HTML += this.getPrintHeaderRow();

        } else if (comp == "summaryRow") {
            HTML += this.getPrintSummaryRow();

        } else if (isc.isA.Canvas(comp)) {
            // this maybe asynchronous, so pass in a callback to continue
            // generating HTML
            
            // Use closure to hang onto context
            var _this = this,
                componentPrintCallback = function componentPrintCallback (compPrintHTML) {
                HTML += "<TR><TD colSpan='" + _this.fields.length + "'>"
                        + compPrintHTML + "</TD></TR>";
                _this.setupHeaderPrintHTML(gridPrintConfig, HTML, i+1);
            }
            var compHTML = comp.getPrintHTML(gridPrintConfig.printProps,
                                componentPrintCallback);

            // Component getPrintHTML method returned null - must be asynchronous, so
            // we'll continue this loop when that method completes.
            if (compHTML == null) {
                return null;
            }

            HTML += "<TR><TD colSpan='"+this.fields.length+ "'>" +
                    compHTML +
                    "</TD></TR>";
        } else {
            // Not an explicit widget, nor one of the standard strings - not clear
            // how to handle this.
            
            this.logWarn("getPrintHTML() - unable to get print HTML for gridComponent " +
                comp);
        }
    }
    delete this.currentPrintProperties;


    // at this point we've got the footer HTML for the body set up - store that off
    // so body.getPrintFooters() behaves correctly
    body._printFootersHTML = HTML;

    return this.setupHeaderPrintHTMLComplete(gridPrintConfig, isAsync);

},


setupHeaderPrintHTMLComplete : function (gridPrintConfig, isAsync) {
    // getTablePrintHTML() - implemented at the GridBody level.
    // If it goes asynchronous it'll fire the callback and return null - otherwise it'll
    // return print HTML
    var bodyHTML = this.body.getTablePrintHTML(gridPrintConfig);

    // isAsync flag - implies setupHeaderPrintHTML was asynchronous - in this case
    // rather than returning the generated HTML, or relying on the grid body to fire the
    // print callback, we have to fire the callback ourselves.
    // September 2015 - if a dev installed a callback, always fire it (as per the docs)

    
    var devCallback = gridPrintConfig.callback && gridPrintConfig.callback.printCallback;
    if (bodyHTML != null && (devCallback || isAsync)) {
        var callback = gridPrintConfig.callback;
        if (callback) {
            this.fireCallback(callback, "HTML,callback", [bodyHTML,callback]);
        }
    }

    return isAsync ? null : bodyHTML;
},

// Undocumented feature - suppress printing of gridComponents via "print<CompName>" flags
// being set to false
shouldPrintAttributeMap:{
    filterEditor:"printFilterEditor",
    header:"printHeader",
    summaryRow:"printSummaryRow"
},
// Suppress printing of filterEditor by default

printFilterEditor:false,

shouldPrintGridComponent : function (component) {
    if (component == null) return false;

    if (isc.isA.String(component)) {
        var shouldPrintAttr = this.shouldPrintAttributeMap[component];
        if (shouldPrintAttr != null && this[shouldPrintAttr] != null) {
            return this[shouldPrintAttr];
        }
        return this.shouldShowGridComponent(component);
    }
    return this.shouldPrintChild(component);

},


// Returns the print HTML (table row) for headers for this grid.
// This is a helper for "setupHeaderPrintHTML"
getPrintHeaderRow : function () {
    var fields = this.fields.duplicate();
    // suppress rendering out the shouldPrint fields
    fields.removeAll(fields.findAll("shouldPrint", false));

    var startCol = 0, endCol = fields.length;
    var defaultAlign = isc.Canvas.LEFT,
        printHeaderStyle = this.printHeaderStyle || this.headerBaseStyle,
        HTML;


    // We support arbitrarily nested, asymmetrical header-spans - these require
    // some slightly tricky logic so use a conditional to avoid this if not required.
    if (this.headerSpans) {

        // Step 1: We'll build an array of "logical columns" in this format:
        // [field1], [innerHeader1], [topHeader]
        // [field2], [innerHeader2], [topHeader]
        // [field3], [topHeader2]
        // Each array contains an entry for each row we'll write out (each header
        // span the field is embedded in, plus the field).
        // Note that the top row of HTML will be the last entry in each sub-array and
        // the bottom row will be the first entry (the field should appear below
        // all its headers).
        // Also note we have repeats in here - we'll handle this by applying colSpans
        // to the generated HTML - and that the column arrays will be different lengths
        // due to different depth of nesting of header spans - we'll handle this by
        // applying rowSpans.
        var logicalColumns = [],
            numRows = 1;

        var spanMap = this.buildSpanMap(null, null, true);
        for (var i = startCol; i < endCol; ++i) {
            var field = fields[i];
            logicalColumns[i] = [field];

            var span = spanMap[field.name];

            // build a logical column from the fieldName up to the top span
            // (Note that we will have the same span in multiple cols, which is ok)
            while (span != null) {
                logicalColumns[i].add(span);
                span = span.parentSpan;
            }
            // Remember how deep the deepest nested column is - this is required to
            // allow us to apply numRows.
            numRows = Math.max(logicalColumns[i].length, numRows);
        }
        

        // Step 2: Iterate through the column arrays starting at the last entry
        // (outermost header)
        HTML = [];

        for (var i = numRows-1; i >= 0; i--) {
            HTML[HTML.length] = "<TR>";

            var lastEntry = null,
                colSpanSlot = null;
            for (var ii = startCol; ii < endCol; ii++) {
                var rowSpan = 1, colSpan = 1;
                // When we reach the first entry in the array we'll be looking at a field
                var isField = (i == 0);

                var entry = logicalColumns[ii][i];
                

                // If we hit a spanned marker we've already written out a row and/or
                // colSpanning cell that covers this entry - short-circuit the logic
                // below in this case.
                if (entry == "spanned") {
                    continue;
                }
                // our logical column arrays will be different lengths as
                // we can have unequal depth header spans (including potentially
                // just fields).
                // To handle this we'll have to apply rowSpans.
                // Sub-headers can have unequal depths - for example a header
                // span could contain a child span with fields and another child span
                // with its own child-span before their are fields.
                // This means we cant "take up all the slack" on the outer headers, we
                // have to apply rowSpans at potentially several levels.
                // Strategy:
                // - if this is a null entry there are fewer rows in this column than
                //   the total, so we need a rowSpan > 1 somewhere.
                //   Reach up the column until we find an entry - this will be the
                //   header we'll write out, and remember how deep we had to go
                //   (that will be the rowSpan)
                // - The header may span multiple columns - repeat this process for
                //   each subsequent column until we find a header span that differs
                //   from the one we were looking at.
                // At this point we'll know how many cols the header spans, and how deep
                // we had to go to find it in each col.
                // ColSpan will be the number of cols spanned.
                // RowSpan will be the minimum depth we had to go.
                // Now modify the logical column arrays to ensure we don't write out
                // duplicate cells in the generated HTML:
                // - replace every cell we span with a "spanned" marker so we skip it
                // - if the entry we are using as the source for the header doesn't
                //   fall in this range, clear its entry from the logical column array.
                //   Then on the iteration for the row where we would have it it we'll
                //   hit another null entry, and that will cause us to look at the
                //   next entry down instead and render it out with appropriate rowSpan
                var minDepth = 0,
                    spanningColNum = ii,
                    spannedColOffsets = [];

                // set colSpan to zero. We'll increment in the loop below
                colSpan = 0;

                while (spanningColNum < endCol) {
                    var entryToTest = null,
                        foundMismatch = false;
                    for (var offset = 0; (i-offset) >= 0; offset++) {
                        entryToTest = logicalColumns[spanningColNum][i-offset];
                        

                        if (entryToTest != null) {
                            // If we originally hit a null entry, pick up the first
                            // non null entry so we have something to actually write out.
                            if (entry == null) {
                                entry = entryToTest;
                                minDepth = offset;
                                if (i-offset == 0) {
                                    isField = true;
                                }
                            }
                            if (entry == entryToTest) {
                                spannedColOffsets[colSpan] = offset;
                                minDepth = Math.min(offset, minDepth);
                            } else {
                                foundMismatch = true;
                            }
                            break;
                        }
                    }
                    if (foundMismatch) {
                        break;
                    }
                    spanningColNum ++;
                    
                    colSpan++;
                }

                // set rowSpan for the cell based on how deep we had to
                // go to find a real entry (shift from zero to 1-based)
                if (minDepth != null) {
                    rowSpan = minDepth+1;
                }

                

                // For each column this entry spans, add markers indicating that
                // we're handling this via TD with rowSpan and colSpan set (and
                // clear out duplicate entries).
                for (var spannedCols = 0; spannedCols < spannedColOffsets.length;
                    spannedCols++)
                {

                    var logicalColArray = logicalColumns[spannedCols + ii],
                        offset = spannedColOffsets[spannedCols];

                    for (var spannedRows = 0; spannedRows <= offset; spannedRows++) {
                        
                        if (spannedCols == 0 && spannedRows == 0) {
                            logicalColArray[i-spannedRows] = entry;
                        } else if (spannedRows <= minDepth) {
                            logicalColArray[i - spannedRows] = "spanned";
                        } else {
                            logicalColArray[i - spannedRows] = null;
                        }
                    }
                }

                

                // We don't expect to ever end up with a null entry - not sure
                // how this could happen but log a warning
                if (entry == null) {
                    this.logWarn("Error in getPrintHeaders() - unable to generate " +
                        "print header HTML from this component's specified headerSpans");
                }

                var align = "center",
                    cellValue;

                if (isField) {
                    align = entry.align || defaultAlign;
                    cellValue = this.getHeaderButtonTitle(entry.masterIndex);
                } else {
                    cellValue = entry.title;
                }

                // Flip alignment if isRTL is true and reverseRTLAlign is set
                if (this.isRTL() && this.reverseRTLAlign) {
                    if (align == isc.Canvas.LEFT) align = isc.Canvas.RIGHT;
                    else if (align == isc.Canvas.RIGHT) align = isc.Canvas.LEFT;
                }

                var cellStart = HTML.length;

                HTML[HTML.length] = "<TD class='";
                HTML[HTML.length] = printHeaderStyle;
                HTML[HTML.length] = "' align='";
                HTML[HTML.length] = align;
                HTML[HTML.length] = "' rowSpan='";
                HTML[HTML.length] = rowSpan;
                HTML[HTML.length] = "' colSpan='";
                HTML[HTML.length] = colSpan;
                HTML[HTML.length] = "'>";
//                    HTML[HTML.length] = "' style='border:1px solid black'>";
                HTML[HTML.length] = cellValue;
                HTML[HTML.length] = "</TD>";

                

            }
            HTML[HTML.length] = "</TR>"
        }
//         this.logWarn("\n\nGenerated print header HTML (including spans):" + HTML.join(""));

    } else {
        var HTML = ["<TR>"];

        var cellStartHTML = ["<TD CLASS=", printHeaderStyle,
                             " ALIGN="].join("");

        // Just iterate through the fields once, then assemble the HTML and return it.
        for (var colNum = startCol; colNum < endCol; colNum++) {
            var field = fields[colNum];
            
            var align = field.align || defaultAlign;
            // Flip alignment if isRTL is true and reverseRTLAlign is set
            if (this.isRTL() && this.reverseRTLAlign) {
                if (align == isc.Canvas.LEFT) align = isc.Canvas.RIGHT;
                else if (align == isc.Canvas.RIGHT) align = isc.Canvas.LEFT;
            }

            HTML.addList([cellStartHTML, align, ">",
                                this.getHeaderButtonTitle(field.masterIndex), "</TD>"]);
        }

        // Output the standard header row
        HTML[HTML.length] = "</TR>";
    }
    return HTML.join(isc.emptyString);
},


getPrintSummaryRow : function () {
    if (!(this.summaryRow) || !(this.summaryRow.body) || !(this.showGridSummary)) {
        // return empty string if no data in the grid
        return "";
    }

    var chunkContext = {
        startRow:0,
        endRow:this.summaryRow.getTotalRows(),
        maxRows:this.summaryRow.printMaxRows,
        printProps:this.printProperties || {},
        html:[]
    }

    
    var printWidths = isc.Canvas.applyStretchResizePolicy(this.fields.getProperty("width"),
                                                          chunkContext.printProps.width || isc.Page.getWidth());
    chunkContext.printWidths = printWidths;
    
    this.summaryRow.body.printChunkOnly = true;
    
    var HTML = this.summaryRow.body.getPrintHTMLChunk(chunkContext, true);
    delete this.summaryRow.body.printChunkOnly;
    // this.logWarn("print summary row HTML:" + HTML);
    return HTML;
},

// -------

// This is run before getting the body tableHTML for printing
// If printing HTML in chunks it'll be run repeatedly for each chunk!
// Purpose is to set up the necessary attributes so the body generates print-formatted
// output
_prepareBodyForPrinting : function (printWidths, printProperties) {
    this.isPrinting = this.body.isPrinting = true;
    this.currentPrintProperties = printProperties;

    var body = this.body,
        // don't print editors?
        oldEditorShowing = this._editorShowing;

    // properties to store off and restore
    var origProps = isc.getProperties(body, ["autoFit", "wrapCells", "showAllRows",
                                "showAllColumns", "fixedRowHeights", "_fieldWidths", "fields"
                                

                    ]);

    body.showAllRows = true;
    body.showAllColumns = true;

    this._editorShowing = false; // never show editors
    body.autoFit = this.printAutoFit;
    body.wrapCells = this.printWrapCells;
    body.fixedRowHeights = !this.printWrapCells;

    var fields = this.fields.duplicate();
    // suppress rendering out the shouldPrint fields
    fields.removeAll(fields.findAll("shouldPrint", false));
    body.fields = fields;

    // mark ourselves as unfrozen so we avoid logic to (for example) offset body col-num
    // with frozen col num)
    var oldFrozenFields = this.frozenFields;
    delete this.frozenFields;
    // Temporarily copy all components embedded in the frozenBody into the _embeddedComponents
    // list of the body.
    var oldEmbeddedComponents = this._oldEmbeddedComponents = body._embeddedComponents,
        numFrozenComponents = (
            this.frozenBody != null && this.frozenBody._embeddedComponents != null ?
                this.frozenBody._embeddedComponents.length : 0);
    if (numFrozenComponents > 0) {
        var numNonFrozenComponents = (
                oldEmbeddedComponents != null ? oldEmbeddedComponents.length : 0),
            numComponents = numFrozenComponents + numNonFrozenComponents,
            newComponents = body._embeddedComponents = new Array(numComponents);

        for (var i = numNonFrozenComponents; i--; ) {
            newComponents[i] = oldEmbeddedComponents[i];
        }
        for (var i = numFrozenComponents; i--; ) {
            var ec = this.frozenBody._embeddedComponents[i];
            ec._wasFrozen = true;
            newComponents[numNonFrozenComponents + i] = ec;
        }
    }
    
    this._embeddedComponentColNumOffset = 0;
    this._frozenEmbeddedComponentColNumOffset = 0;
    if (this.freezeStart()) {
        if (this.frozenBody &&
            this.frozenBody._lastDrawnCol != null &&
            this.frozenBody._firstDrawnCol != null)
        {
            this._embeddedComponentColNumOffset = (
                this.frozenBody._lastDrawnCol - this.frozenBody._firstDrawnCol + 1);
        }
    } else {
        if (this.body &&
            this.body._lastDrawnCol != null &&
            this.body._firstDrawnCol != null)
        {
            this._frozenEmbeddedComponentColNumOffset = (
                this.body._lastDrawnCol - this.body._firstDrawnCol + 1);
        }
    }

    body._fieldWidths = printWidths;
    return {oldEditorShowing:oldEditorShowing, oldFrozenFields:oldFrozenFields,
            origProps:origProps};

},

_bodyDonePrinting : function (context) {
    var body = this.body,
        origProps = context.origProps,
        oldEditorShowing = context.oldEditorShowing;

    isc.addProperties(body, origProps);
    if (origProps.showAllRows == null) body.showAllRows = null;
    this._editorShowing = oldEditorShowing;
    this.frozenFields = context.oldFrozenFields;
    body._embeddedComponents = this._oldEmbeddedComponents;
    delete this._oldEmbeddedComponents;
    if (this.frozenBody != null && this.frozenBody._embeddedComponents != null) {
        for (var i = this.frozenBody._embeddedComponents.length; i--; ) {
            var ec = this.frozenBody._embeddedComponents[i];
            delete ec._wasFrozen;
        }
    }
    delete this._embeddedComponentColNumOffset;
    delete this._frozenEmbeddedComponentColNumOffset;

    delete this.currentPrintProperties;

    this.isPrinting = this.body.isPrinting = false;
    
    this.body.markForRedraw("finished printing");
},

// Event Handling
// --------------------------------------------------------------------------------------------

//> @method listGrid.rowClick() (A)
//
// Event handler for when rows in the body are clicked upon. The default implementation handles
// firing +link{ListGrid.startEditing()} if appropriate, and fires
// +link{ListGridField.recordClick()} and/or +link{ListGrid.recordClick()} if set. Developers
// should typically implement recordClick rather than overriding this method.
// <P>
// Note that this method fires in addition to any specified +link{listGrid.cellClick}
// handler (even if that method cancels the event as a whole by returning <code>false</code>).
//
//      @param  record      (ListGridRecord)    record object returned from getCellRecord()
//      @param  recordNum   (int)   index of the row where the click occurred
//      @param  fieldNum    (int)   index of the col where the click occurred
//      @param  [keyboardGenerated]   (boolean) indicates whether this was a synthesized record
//                                              click in response to a keyboard event
//      @group  events
//      @see    recordClick()
//
//      @group  events
//      @return (Boolean)
//      @visibility external
//<
rowClick : function (record, recordNum, fieldNum, keyboardGenerated) {

    // record the last record clicked (used for keyboard navigation)
    this._lastRecordClicked = recordNum;

    var record = this.getCellRecord(recordNum, fieldNum),
        field = this.fields[fieldNum];

    // don't fire recordClick on loading rows
    if (Array.isLoading(record)) return;

    // if the field has a 'recordClick' method, call that
    var value = this.getCellValue(record, recordNum, fieldNum);
    var rawValue = this.getRawCellValue(record, recordNum, fieldNum);

    // if the record is a group header, expand/collapse the group
    if (record != null && record._isGroup) {
        if (this.canCollapseGroup == false) return;
        // if the user navigates through the grid using arrow up / down keys, don't toggle
        // the group when the user hits the group header (Except on explicit space keypress which is
        // more of a deliberate 'pseudo-click' type interaction).
        
        if (keyboardGenerated) {
            var key = isc.EH.getKey();
            if (key != "Space" && key != "Enter") return;
        }
        
        // Click on the "selection" col will toggle the select value - don't
        // also expand/collapse
        
        if (this.canSelectGroups && this.isCheckboxField(field)) {
            return;
        }
        
        if (!this.collapseGroupOnRowClick) {
            var part = this.getEventPart();
            if (!part || part.part != "opener") return;
        }
        
        
        var mythis = this, myrecord=record;
        if (this.getEditRow() != null) {
            if (this.autoSaveEdits) {
                var saveAttempted = this.saveAllEdits(null, function () {
                    mythis.toggleFolder(myrecord);
                });
                // we'll toggle folder in the callback so no need to carry on here.
                if (saveAttempted) return;
            } else {
                this.storeUpdatedEditorValue();
            }
        }
        this.toggleFolder(record);
        return;
    }
    
    if (field.valueIconClick != null && !keyboardGenerated) {
        var part = this.getEventPart();
        if (part && part.part == "valueicon") {
            isc.Func.replaceWithMethod(field, "valueIconClick",
                                             "viewer,record,recordNum,field,rawValue,editor");
            var returnVal = field.valueIconClick(this, record, recordNum, field, rawValue, null);
            if (returnVal == false) return false;
        }
    }

    if (field.recordClick && !(keyboardGenerated && field.keyboardFiresRecordClick == false)) {
        // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value,rawValue"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "recordClick",
                                         "viewer,record,recordNum,field,fieldNum,value,rawValue");
        var returnVal = field.recordClick(this, record, recordNum, field, fieldNum, value, rawValue);
        if (returnVal == false) return false;
    }

    // Note - there is also a (legacy) recordClick handler on the GridRenderer class, with a
    // different signature.
    // 'recordClick()' is not one of the GridAPIs - so won't be fired automatically from the
    // GridRenderer click handling code.  If the method was defined on both the ListGrid and
    // the Body, both methods would be fired.
    // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value,rawValue"
    if (this.recordClick) {
        if (this.onRecordClick(this,record,recordNum,field,fieldNum,value,rawValue) == false)
            return false;
        if (this.recordClick(this,record,recordNum,field,fieldNum,value,rawValue) == false)
            return false;
    }

    // if the cell is editable on click, edit it now
    // We also start editing if editOnFocus is true.
    var editOnClick = this.isEditable() && (this.editEvent == isc.EH.CLICK || this.editOnFocus);

    // one-click toggling of boolean/valueMapped fields.
    // Note: also allows entering of editing if editEvent is click.
    if (field.canToggle && this.canEditCell(recordNum, fieldNum) &&
        this.shouldToggle(field, keyboardGenerated))
    {
        var valueMap = this.getEditorValueMap(field, this.getEditedRecord(recordNum,fieldNum));
        // autocreate a valueMap for boolean
        if (valueMap == null && isc.SimpleType.getBaseType(field.type) == this._$boolean) {
            valueMap = [true,false];
        }
        if (valueMap != null) {
            if (!isc.isAn.Array(valueMap)) valueMap = isc.getKeys(valueMap);
            if (valueMap.length > 1) {

                var fieldName = this.getFieldName(fieldNum),
                    editValue = this.getEditedCell(recordNum, fieldNum),
                    index = valueMap.indexOf(editValue);
                index += 1;
                if (index >= valueMap.length) index = 0;
                var oldValue = editValue;

                editValue = valueMap[index];

                var cancelChange;

                if (field.change != null) {
                    this.logInfo("canToggle firing specified field.change() event directly", "gridEdit");
                    cancelChange = this.fireCallback(
                            field.change,
                            "form,item,value,oldValue",
                            [null,null,editValue,oldValue]
                    ) == false;
                }

                if (!cancelChange) {

                    // autoSaveEdits: Usually if canToggle is true we instantly commit
                    // however if we're also jumping into edit mode it makes more sense to
                    // just toggle the edit value and save when the user dismisses the editor
                    // as usual.
                    if (!editOnClick && this.autoSaveEdits) {
                        this.setEditValue(recordNum, fieldNum, editValue, true, false);

                    } else {
                        this.setEditValue(recordNum, fieldNum, editValue);
                    }
                    if (field.changed != null) {
                        this.logInfo("canToggle firing specified field.changed() event directly", "gridEdit");
                        this.fireCallback(
                            field.changed,
                            "form,item,value",
                            [null,null,editValue]
                        );
                    }

                    if (this.autoSaveEdits) this.saveEdits(null, null, recordNum, fieldNum);
                }
            }
        }
    }

    if (editOnClick) {
        if (this.handleEditCellEvent(recordNum, fieldNum, isc.ListGrid.CLICK) == true) {
            return true;
        }
        // If this was a keyboard event, and the keyboard click field is not editable, iterate
        // through the other fields, and edit the first editable one we find
        if (keyboardGenerated) {
            for (var i = 0; i< this.fields.length; i++) {
                if (i == fieldNum) continue;
                if (this.handleEditCellEvent(recordNum, i, isc.ListGrid.CLICK) == true) {
                    return true;
                }
            }
        }
    }
},

// By default we only toggle if the event occurred over a field's value-icon
// Exception: If _formatBooleanFieldAsImage returns false we didn't write out an icon for
// the cell
shouldToggle : function (field, keyboardGenerated) {
    if (keyboardGenerated) {
        var key = isc.EH.getKey();
        if (key == this._$Space || key == this._$Enter) return true;
    }
    // Note: no need to check 'canToggle' - this method is only called for fields where
    // canToggle is true.
    if (!this._formatBooleanFieldAsImages(field)) return true;
    var part = this.getEventPart();
    return (part && part.part == "valueicon");
},

//> @method listGrid.rowDoubleClick()   (A)
// Event handler for when a body record is double-clicked.
// <P>
// Default implementation fires 'editCell' if appropriate, and handles firing
// 'recordDoubleClick' stringMethod if defined at the field or LG level (That method has a
// different signature from this one)
//
//      @param  record      (ListGridRecord)    record object returned from getCellRecord()
//      @param  recordNum   (number)    index of the row where the click occurred
//      @param  fieldNum    (number)    index of the col where the click occurred
//      @param  [keyboardGenerated]   (boolean) indicates whether this was a synthesized record
//                                              doubleclick in response to a keyboard event
//
//      @see    recordDoubleClick()
//      @group  events
//      @return (boolean)   false if first click not on same record; true otherwise
//      @visibility external
//<
rowDoubleClick : function (record, recordNum, fieldNum, keyboardGenerated) {

    var field = this.fields[fieldNum],
        value = this.getCellValue(record, recordNum, fieldNum),
        rawValue = this.getRawCellValue(record, recordNum, fieldNum);
    // suppress user-defined handlers on the group header node
    if (record != null && record._isGroup) return;

    if (field.recordDoubleClick) {
        // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value,rawValue"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "recordDoubleClick",
                                         "viewer,record,recordNum,field,fieldNum,value,rawValue");
        var returnVal = field.recordDoubleClick(this, record, recordNum, field, fieldNum, value, rawValue);
        if (returnVal == false) return returnVal;
    }
    if (this.recordDoubleClick != null) {
        // CALLBACK API:  available variables: "viewer,record,recordNum,field,fieldNum,value,rawValue"
        var returnVal = this.recordDoubleClick(this, record, recordNum, field, fieldNum, value, rawValue);
        if (returnVal == false) return returnVal;
    }

    // if the cell is editable, edit it now
    //  (editCell will return true if we've brought up the cell editor)
    if (this.isEditable() && this.editEvent == isc.EH.DOUBLE_CLICK) {
        if (this.handleEditCellEvent(recordNum, fieldNum, isc.ListGrid.DOUBLE_CLICK) == true) return true;
        // If this was a keyboard event, and the keyboard click field is not editable, iterate
        // through the other fields, and edit the first editable one we find
        if (keyboardGenerated) {
            for (var i = 0; i< this.fields.length; i++) {
                if (i == fieldNum) continue;
                if (this.handleEditCellEvent(recordNum, i, isc.ListGrid.DOUBLE_CLICK) == true) return true;
            }
        }
    }

},

// Body Context Menu
// --------------------------------------------------------------------------------------------
// This will fire 'ListGrid.cellContextClick' if defined.
// Otherwise implements default behavior of showing context menu for the cell.
// enhancement: check for contextMenu,cellContextClick on cell, row, field?
_cellContextClick : function (record, rowNum, colNum) {

    // clear any previous context menu items
    this.cellContextItems = null;

    // Call handler if defined; return false to cancel context menu if handler returns false.  The
    // handler can call lv.makeCellContextItems(record,recordNum,fieldNum), modify the items, and
    // set lv.cellContextItems to customize the context menu.
    if (this.cellContextClick) {
        var record = this.getCellRecord(rowNum, colNum);
        if (this.cellContextClick(record, rowNum, colNum) == false) return false;
    }

    // show cell context menus, or generic context menu?
    if (this.showCellContextMenus) {

        // create the cellContextMenu if necessary
        if (!this.cellContextMenu) {
            this.cellContextMenu = this.createAutoChild("cellContextMenu", this.contextMenuProperties , this.getMenuConstructor());
        }

        // get standard menu items if the handler above did not set custom items
        if (!this.cellContextItems) {
            this.cellContextItems = this.makeCellContextItems(
                this.getCellRecord(rowNum, colNum), rowNum, colNum);
        }
        // if there are any menu items, set and show the menu
        if (isc.isAn.Array(this.cellContextItems) && this.cellContextItems.length > 0) {
            this.cellContextMenu.setData(this.cellContextItems);
            this.cellContextMenu.showContextMenu(this);
        }

        // return false to kill the standard context menu
        return false;

    } else {
        // do normal Canvas context menu handling. Will fall through to this.showContextMenu.
        return true;
    }
},

//> @method ListGrid.getShowChildDataSourceContextMenuItemTitle() [A]
// If +link{ListGrid.canOpenRecordDetailGrid} is true and +link{ListGrid.showCellContextMenus}
// is true, we will show menu items to drill into the child datasources in this grid's context
// menu. This method returns the title for that menu item. Override for localization.
// @param ds (DataSource) child datasource to be drilled into
// @return (string) By default returns <code>"Show " + ds.getPluralTitle()</code>
// @group i18nMessages
// @visibility nestedGrid
//<
getShowChildDataSourceContextMenuItemTitle : function (ds) {
    return "Show " + ds.getPluralTitle();
},

// generate standard cell context menu items
makeCellContextItems : function (record, rowNum, colNum) {
    if (this.dataSource != null) {
        var menuItems = [];

        // menu items to drill into a child DataSource via a nested grid
        if (this.canOpenRecordDetailGrid) {
            var recordDS = isc.DS.get(this.getRecordDataSource(record)),
                childDataSources = recordDS.getChildDataSources();
            if (childDataSources != null) {
                for (var i = 0; i < childDataSources.length; i++) {
                    var ds = childDataSources[i];
                    menuItems.add({
                        title : this.getShowChildDataSourceContextMenuItemTitle(ds),
                        record : record,
                        dataSource : ds,
                        click : "target.openRecordDetailGrid(item.record, item.dataSource)"
                    });
                }
            }
        }

        // menu item to edit with an embedded form
        if (this.canOpenRecordEditor) {
            
            menuItems.add({
                title : this.openRecordEditorContextMenuItemTitle,
                record : record,
                click : "target.endEditing();target.openRecordEditor(item.record)"
            });
        }

        // if we are currently showing anything inside the row offer to dismiss it
        if (record != null && this._openRecord == record) {
            menuItems.add({
                title : this.dismissEmbeddedComponentContextMenuItemTitle,
                click : "target.closeRecord()"
            });
        }

        // menu item to delete a record
        menuItems.add({
            title : this.deleteRecordContextMenuItemTitle,
            click : "target.removeSelectedData()"
        });
        return (menuItems.length > 0 ? menuItems : null);
    }
    return null;
},

// Hover
// ---------------------------------------------------------------------------------------

// override getCanHover.
// If this.canHover is explicitly set to true or false, respect it,
// Otherwise - if any fields are going to show hovers, return true

getCanHover : function () {
    if (this.canHover != null) return this.canHover;
    var showClippedValuesOnHover = this._getShowClippedValuesOnHover();
    if (showClippedValuesOnHover) return showClippedValuesOnHover;
    var fields = this.getFields();
    if (fields != null) {
        for (var i = 0; i < fields.length; i++) {
            if (fields[i].showHover) return true;
        }
    }
    // Either null or false
    return this.canHover;
},

_$hoverHTML: "hoverHTML",
_$fieldHoverHTMLArgNames: "record,value,rowNum,colNum,grid",
_getFieldHoverHTMLCallback : function (rowNum, colNum) {
    var field = this.getField(colNum);
    if (field == null) return null;
    if (field.showHover == false) return null;
    if (field.showHover == null && !this.canHover) return null;
    // if the record is a group-row and singleCellGroupHeaders() is true, bail now, before
    // checking for a hoverHTML implementation on the field
    var record = this.getRecord(rowNum);
    if (record._isGroup && this.singleCellGroupHeaders()) return null;
    if (field.hoverHTML) {
        isc.Func.replaceWithMethod(field, this._$hoverHTML, this._$fieldHoverHTMLArgNames);
        return {
            target: field,
            methodName: this._$hoverHTML
        };
    }
    return null;
},

_isCellHoverSuppressed : function (rowNum, colNum) {
    // If we're showing an editor in the cell suppress the standard cell hover.
    if (this.isEditingCell(rowNum, colNum)) {
        return true;
    }
    // Don't attempt to write inactive editor HTML into the hover prompt. This would be
    // odd user-experience and can lead to warnings about inactiveEditorContexts getting
    // unexpectedly dropped.
    
    if (this._showInactiveEditor(colNum) && this.canEditCell(rowNum, colNum)) {
        return true;
    }
    return false;
},

getCellHoverDelay : function (record, rowNum, colNum) {
    var fieldDelay = this.getField(colNum).hoverDelay;
    if (fieldDelay != null) return fieldDelay;
    return this.hoverDelay;
},

// NOTE: JSDoc imported from GR
cellHoverHTML : function (record, rowNum, colNum) {
    var fieldHoverHTMLCallback = this._getFieldHoverHTMLCallback(rowNum, colNum),
        // for the group-cell itself, use getGroupTitle() instead of getCellValue(), which will
        // call through getGroupNodeHTML() and, thus, show the group open/close icon in the
        // hover
        isGroupCell = record._isGroup && (colNum == 0 || this.singleCellGroupHeaders()),
        value = isGroupCell ? this.getGroupTitle(record) : 
            this.getCellValue(record, rowNum, colNum)
    ;
    if (fieldHoverHTMLCallback) {
        return isc.Class.fireCallback(fieldHoverHTMLCallback,
                                      this._$fieldHoverHTMLArgNames,
                                      [ record, value, rowNum, colNum, this ]);
    }

    if (value != null && !isc.isAn.emptyString(value) && value != this.emptyCellValue) {
        return value;
    }
},

cellValueHoverHTML : function (record, rowNum, colNum, defaultHTML) {
    var field = this.getField(colNum);
    if (field.showHover == false) return null;
    if (field.showHover == null && this.canHover == false) return null;

    return defaultHTML;
},

//> @method listGridField.hoverHTML()
// StringMethod override point for returning HTML to be shown in hovers over cells in the
// column described by this field.
// <P>
// Called only when +link{listGrid.canHover,canHover} and +link{listGrid.showHover,showHover}
// are both true.
// <P>
// The value of "this" within the method will by the +link{ListGridField,field definition}.
//
// @param record (ListGridRecord) record being hovered over
// @param value  (any) value of the cell being hovered over
// @param rowNum (number) row number where hover occurred
// @param colNum (number) column number where hover occurred
// @param grid   (ListGrid) ListGrid this field is a part of
// @return (HTML) HTML to show in the hover
// @group hovers
// @visibility external
// @example valueHoverTips
//<

//> @attr listGridField.hoverDelay (integer : null : IRW)
// Delay in ms for hovers shown for cells in this field. If unset, the grid's
// hoverDelay will be used.
// <p>
// This property also governes the hoverDelay for the header button. Developers wishing
// to have a different delay for hovers on the header can use +link{listGridField.headerHoverDelay}
// in addition to this property.
//
// @visibility external
//<


//> @attr listGridField.headerHoverDelay (integer : null : IRW)
// Delay in ms for hovers shown over this field's header.
// <P>
// If unset, any +link{listGridField.hoverDelay} will be used for both header hovers
// and hovers shown over cells in the grid's body.
//
// @visibility external
//<

//> @attr listGrid.showHoverComponents (Boolean : false : IRWA)
// When set to true and canHover is also true, shows a widget hovering at the mouse point.
// <P>
// A number of builtin modes are provided - see +link{type:HoverMode}.
// @group hoverComponents
// @visibility external
//<


//> @type HoverMode
// When +link{ListGrid.canHover, canHover} and
// +link{ListGrid.showHoverComponents, showHoverComponents} are both true, HoverMode
// dictates the type of UI to be displayed when a user hovers over a row or cell.
// <P>
// There are a number of builtin HoverModes and you can override
// +link{listGrid.getCellHoverComponent, getCellHoverComponent()} to create your own
// hover behaviors.
//
//  @value  "detailField"  Show a single field's value in an +link{class:HtmlFlow}. Field
//      to use is +link{listGrid.detailField}.
//  @value  "details"   Show a +link{class:DetailViewer} displaying those fields from the
//      record which are not already displayed in the grid.
//  @value  "related"    Show a separate +link{class:ListGrid} containing related-records.
//      See +link{ListGridRecord.detailDS} and +link{ListGrid.recordDetailDSProperty} for
//      more information.
//  @value  "detailRelated"    Show a +link{class:DetailViewer} displaying those fields
//      from the record not already displayed in the grid, together with a separate
//      +link{class:ListGrid} containing related-records.
// @group hoverComponents
// @visibility external
//<

//> @attr listGrid.hoverMode (HoverMode : null : IRWA)
// When +link{ListGrid.showHoverComponents, showHoverComponents} is true, the builtin mode
// to use when automatically creating a hover component for rows in this grid.
// <P>
// A number of builtin modes are provided - see +link{type:HoverMode}.  You can also override
// +link{ListGrid.getCellHoverComponent, getCellHoverComponent()} to provide a custom hover
// widget - in that case, this attribute is ignored.
// @group hoverComponents
// @visibility external
//<

_getCellHoverComponent : function (record, rowNum, colNum) {
    if (!this.showHoverComponents) return null;
    // If we're showing an editor in the cell suppress the standard cell hover.
    if (this._editorShowing && this.getEditRow() == rowNum &&
        (!this.editByCell || this.getEditCol() == colNum)) return null;
    var field = this.getField(colNum);
    if (field.showHover == false) return null;
    if (field.showHover == null && !this.canHover) return null;

    if (this.getCellHoverComponent && isc.isA.Function(this.getCellHoverComponent)) {
        return this.getCellHoverComponent(record, rowNum, colNum);
    } else return null;
},

//> @method listGrid.getCellHoverComponent()
// When +link{showHoverComponents} is set, this method is called to get the component to show
// as a hover for the current cell.
// <P>
// By default, this method returns one of a set of builtin components, according to the
// value of +link{type:HoverMode, listGrid.hoverMode}.  You can override this method
// to return any component you wish to provide as a hoverComponent, or invoke the superclass
// method to have the default hover component generated, then further customize it.
// <P>
// By default, components returned by <code>getCellHoverComponent()</code> will be
// automatically destroyed when the hover is hidden.  To prevent this, set
// +link{canvas.hoverAutoDestroy} to false on the returned component.
//
// @param record (Record) record to get the hoverComponent for
// @param rowNum (Integer) row number for the cell
// @param colNum (Integer) column number of the cell
// @return (Canvas | Canvas Properties) the component to show as a hover
// @group hoverComponents
// @visibility external
//<
defaultCellHoverComponentWidth: 100,
defaultCellHoverComponentHeight: 1,
getCellHoverComponent : function (record, rowNum, colNum) {
    return this._getStockEmbeddedComponent(record, false, true, rowNum, colNum);
},

_getStockEmbeddedComponent : function (record, isExpansion, isHover, rowNum, colNum) {
    var gridFields = this.getFields(),
        dsFields = this.dataSource ? isc.getValues(this.getDataSource().getFields()) :
            gridFields,
        defWidth = (!isHover ? null :
            this.hoverWidth || this.hoverSize || this.defaultCellHoverComponentWidth),
        defHeight = (!isHover ? null :
            this.hoverHeight || this.hoverSize || this.defaultCellHoverComponentHeight),
        remainingFields = [],
        component
    ;

    for (var i=0; i<dsFields.length; i++) {
        var field = dsFields.get(i);
        if (this.dataSource) {
            if (!gridFields.find("name", field.name)) {
                remainingFields.add(field);
            }
        } else {
            // show all fields when not databound
            if (!this.isExpansionField(field)) {
                remainingFields.add(field);
            }
        }
    }

    var mode = (isHover ? this.hoverMode : (isExpansion ? this.expansionMode : null));

    var props;

    // create an appropriate subcomponent and bind it
    if (mode == "detailField") {
        if (!isExpansion && !record[this.detailField]) return null;
        component = this.createAutoChild("expansionDetailField", {
            styleName: this.hoverStyle,
            contents: record[this.detailField]
        });
        props = {
            width: (isHover ? defWidth : "100%"),
            height: (isHover ? defHeight : "100%"),
            members: [component]
        };

        if (isHover) {
            props = isc.addProperties(props, {
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }

        component = isc.VLayout.create(props);
    } else if (mode == "details") {
        
        remainingFields = remainingFields.map(function (field) {
            if (field.showIf == null) return field;
            return isc.addProperties({}, field, {showIf: "true"});
        });
        props = { dataSource: this.dataSource, fields: remainingFields };

        if (isHover) {
            props = isc.addProperties(props, {
                width: defWidth,
                height: defHeight,
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }
        component = this.createAutoChild("expansionDetails", props);

        if (isc.isA.ResultSet(record)) {
            component.setData(record);
        } else {
            // create ResultSet wrapper on the record, it is possible to observe changes in the datasource
            var recordResultSet = isc.ResultSet.create({
                dataSource : this.dataSource,
                initialData : [record]
            });
            component.setData(recordResultSet);
        }
    } else if (mode == "related") {
        props = { dataSource: this.getRelatedDataSource(record) };

        if (isHover) {
            props = isc.addProperties(props, {
                canEdit: false,
                width: defWidth,
                height: defHeight,
                dataProperties: { context: { showPrompt: false } },
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }

        if (isExpansion) {
            // only propagate to autochild if childExpansionMode has been set
            if (this.childExpansionMode != null) props = isc.addProperties(props, {
                canExpandRecords: this.childExpansionMode ? true : false,
                expansionMode: this.childExpansionMode
            });
            // only propagate to autochild if expansionCanEdit has been set
            if (this.expansionCanEdit != null) props = isc.addProperties(props, {
                canEdit: this.expansionCanEdit
            });
            props.isExpansionGrid = true;
        }

        component = this.createAutoChild("expansionRelated", props);

        // if editing is allowed in the sub-grid, set autoSaveEdits: true
        if (this.expansionCanEdit) component.autoSaveEdits = true;
        component.delayCall("fetchRelatedData", [record, this.dataSource,
            function (dsResponse, data) {
                // for hoverMode: "related", fix ListGrid shown when no related records are
                // present; grid's GridBody is squished; apply overflow: visible to fix it
                if (data == null || data.length == 0) component.setBodyOverflow("visible");
        }]);

    } else if (mode == "detailRelated") {
        props = { dataSource: this.dataSource, fields: remainingFields };

        if (isHover) {
            props = isc.addProperties(props, {
                dataProperties: { context: { showPrompt: false } },
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }

        var detail = this.createAutoChild("expansionDetails", props)
        detail.setData(record);

        props = { dataSource: this.getRelatedDataSource(record), height: "100%" };

        if (isHover) {
            props = isc.addProperties(props, {
                dataProperties: { context: { showPrompt: false } },
                hoverAutoDestroy: this.hoverAutoDestroy,
                canEdit: false
            });
        }
        if (isExpansion) {
            // only propagate to autochild if childExpansionMode has been set
            if (this.childExpansionMode != null) props = isc.addProperties(props, {
                canExpandRecords: this.childExpansionMode ? true : false,
                expansionMode: this.childExpansionMode
            });
            // only propagate to autochild if expansionCanEdit has been set
            if (this.expansionCanEdit != null) props = isc.addProperties(props, {
                canEdit: this.expansionCanEdit
            });
            props.isExpansionGrid = true;
        }

        var related = this.createAutoChild("expansionRelated", props);

        props = { members:[detail, related] };
        if (isHover) {
            props = isc.addProperties(props, {
                width: defWidth,
                height: defHeight,
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }

        component = this.createAutoChild("expansionDetailRelated", props);

    } else if (mode == "editor") {
        component = isc.VLayout.create({
            autoDraw: false,
            width: "100%",
            height: "100%",
            creator: this
        });

        // create an editor form, edit the record in question and validate it - this causes an
        // editor to show validation errors when autoSaveEdits is false and saveAllEdits is
        // called.
        var editorForm = this.createAutoChild("expansionEditor", {
            dataSource: this.dataSource,
            fields: remainingFields,
            extraSpace: 5,
            itemChanged : function () {
                this.saveButton.setDisabled(false);
            }
        });
        editorForm.editRecord(this.getEditedRecord(rowNum) || record);
        editorForm.validate();

        // create a save button for this expansionEditor - add refs to the editor-form and the
        // record being edited for later use.
        var saveButton = this.createAutoChild("expansionEditorSaveButton", {
            title: this.expansionEditorSaveButtonTitle,
            grid: this,
            form: editorForm,
            record: record,
            disabled: true,
            extraSpace: 5
        });

        // add a ref to the save-button onto the editor-form, so we can enable/disable the
        // button according to whether changes have been made
        editorForm.saveButton = saveButton;

        // add a ref to the editorForm to the actual expansion-component - this is used when
        // getting hold of the editor-form to check for changes when a record is collapsed
        component.formMember = editorForm;
        component.addMembers([editorForm, saveButton]);
    }

    if (component) {
        // mark as a stock (auto-generated) component so we can auto-destroy it later
        component.isStockComponent = true;
        component.expandedRecord = record;
    }

    return component;
},

//> @attr listGridField.showAlternateStyle (boolean : null : IRWA)
// When set to false, don't apply alternate-row styling to this field.
// @visibility external
//<

// Selection
// --------------------------------------------------------------------------------------------

// Simple helper methods to avoid having to refer directly to this.selection
// Genericized up to DataBoundComponent, July 2008


//> @method listGrid.selectRecord()
// Select/deselect a +link{Record} passed in explicitly, or by index.
// <P>
// Note that this method selects records unconditionally, allowing multiple selected
// records, even when +link{listGrid.selectionType} is "single".  To enforce mutually-exclusive
// record-selection, use +link{listGrid.selectSingleRecord}.
// @include dataBoundComponent.selectRecord()
//<

//> @method listGrid.deselectRecord()
// @include dataBoundComponent.deselectRecord()
//<

//> @method listGrid.selectRecords()
// @include dataBoundComponent.selectRecords()
//<

//> @method listGrid.deselectRecords()
// @include dataBoundComponent.deselectRecords()
//<

//> @method listGrid.selectAllRecords()
// Select all records.
// <P>
// Note that this method will select records even if +link{listGrid.canSelectRecord()} returns
// false for the record in question. See also +link{listGrid.userSelectAllRecords()}
//
// @param [visibleNodesOnly] (boolean) For TreeGrids, or listGrids showing 
//   hierarchical +link{listGrid.isGrouped,group data}, if <code>true</code> is 
//   passed for this parameter, only visible nodes will be selected. 
//   Nodes embedded in a closed parent folder
//   (and thus hidden from the user) will not be selected.
// @visibility external
//<

selectAllRecords : function (visibleNodesOnly) {
    this._dontRefreshSelection = true;
    this.selection.selectAll(visibleNodesOnly);
    this._dontRefreshSelection = null;
    this._markBodyForRedraw("select all");
    if (this.getCurrentCheckboxField() != null) {
        // don't check the "all records selected header box if we can't select all records
        if (!isc.ResultSet || !isc.isA.ResultSet(this.data) ||
                this.data.allMatchingRowsCached())
        {
            this._setCheckboxHeaderState(true);
        }
    }
    this.fireSelectionUpdated();
},

//> @method listGrid.deselectAllRecords()
// @include dataBoundComponent.deselectAllRecords()
//<
deselectAllRecords : function () {
    this._dontRefreshSelection = true;
    this.selection.deselectAll();
    this._dontRefreshSelection = null;
    this._markBodyForRedraw("deselect all");
    if (this.getCurrentCheckboxField() != null) this._setCheckboxHeaderState(false);
    this.fireSelectionUpdated();
},

//> @method listGrid.selectRange()
// @include dataBoundComponent.selectRange()
//<

//> @method listGrid.deselectRange()
// @include dataBoundComponent.deselectRange()
//<

//> @method listGrid.userSelectAllRecords()
// Selects every user-selectable record in the grid. Unlike +link{listGrid.selectAllRecords()},
// if a record is +link{listGrid.canSelectRecord(),unselectable}, this method will not
// attempt to select it.
// @visibility external
//<
userSelectAllRecords : function () {
    var data = this.getOriginalData(),
        total = data.getLength();
    if (isc.ResultSet && isc.isA.ResultSet(data) && !data.rangeIsLoaded(0, total)) {
        this.selection.warnSelectionRangeNotLoaded();
        return;
    }
    var records = (this.isGrouped ? this.getAllRecordsFromGroupTree() 
                                : data.getRange(0, total)),
        finalRecords = [];
    for (var i = 0; i < records.length; i++) {
        if (!this.canSelectRecord(records[i])) continue;
        finalRecords[finalRecords.length] = records[i];
    }

    this.selection.selectList(finalRecords);
    this.fireSelectionUpdated();
},

getAllRecordsFromGroupTree : function () {
    var data;
    if (this.isGrouped) data = this.data;
    if (!data || !isc.isA.Tree(data)) return;
    
    // getDescendantLeaves will skip over the group-header nodes.
    return this.data.getDescendantLeaves(this.data.getRoot());
},

//> @method listGrid.anySelected()
// @include dataBoundComponent.anySelected()
//<

//> @method listGrid.selectSingleRecord()
// @include dataBoundComponent.selectSingleRecord
// @visibility external
//<

//> @method listGrid.canSelectCell() (A)
// If +link{listGrid.canSelectCells} is set to <code>true</code> then, whenever an end-user or
// programmatic cell-selection is attempted, this method is called for 
// each cell in the selection. If it returns false, the cell will not be selected.
//
// @param rowNum (int) rowNum being selected
// @param colNum (int) colNum being selected
// @return (boolean) return false to disallow selection
//
// @visibility external
//<
canSelectCell : function(rowNum, colNum) {
    return true;
},

//> @method listGrid.canSelectRecord()
// If +link{listGrid.selectionType} is not set to <code>"none"</code>,
// This method will be called for each record the user attempts to select. If it returns false, the
// record will not be selected.
// <P>
// The default implementation will return true for any records where
// +link{listGrid.recordCanSelectProperty} is not explicitly set to false, and false
// if this method was called by a click on the +link{listGrid.expansionField, expansion field}
// and +link{listGrid.selectOnExpandRecord, selectOnExpandRecord} is set to false.
// 
// <P>
// Note this method will not be called at all if +link{canSelectCells} is true.
//
// @param record (ListGridRecord) record being selected
// @return (boolean) return false to disallow selection
//
// @visibility external
//<
// If this method returns false, we disallow user-actions from
// selecting stuff, but still allow programmatic selection via direct access to the
// Selection object, since the "_canSelectItem()" method in Selection just checks for
// the value of the "canSelectProperty".
// We actually make use of this in some cases, such as allowing cascading selection of
// group header nodes when  "canSelectGroups" is false, so "getGroupTreeSelection()"
// can pick up selected header nodes.
canSelectRecord : function(record) {
    if (!record) return false;
    if (this.isGrouped && !this.canSelectGroups && record._isGroup) return false;
    if (this.selectOnExpandRecord == false) {
        // return false if the mouse is over the expansionField
        var field = this.getUnderlyingField(this.getEventColumn());
        if (field) {
            if (this.isExpansionField(field)) return false;
            
        }
    }
    return record[this.recordCanSelectProperty] !== false;
},

//> @attr listGrid.selectOnExpandRecord (boolean : true : IRW)
// When set to false, clicking a record's +link{listGrid.expansionField, expansion field} will
// not add the record to the current selection.
// @visibility external
//<
selectOnExpandRecord: true,

// Keyboard Navigation
// --------------------------------------------------------------------------------------------

//> @method listGrid.keyPress()
// Handle a keyPress event on the ListGrid as a whole.
// <P>
// Note that the majority of keyboard handling for a ListGrid is performed by
// +link{bodyKeyPress()} and most overrides are better performed there.
//
// @return (boolean) return false to cancel
// @visibility external
//<

//> @method listGrid.bodyKeyPress()
// Handle a keyPress event on the body.
// <P>
// Default implementation handles navigating between records with arrow keys, and activating
// records with space and enter.
//
// @return (boolean) return false to cancel
//
// @visibility external
//<

_$ArrowUp:"Arrow_Up", _$ArrowDown:"Arrow_Down",
_$ArrowLeft:"Arrow_Left", _$ArrowRight:"Arrow_Right",
_$Space:"Space", _$Enter:"Enter",
_$f2:"f2",
_$Tab:"Tab",
bodyKeyPress : function (event, eventInfo) {

    // Easy to wrap entryPoint for SGWT.
    if (this.onBodyKeyPress(event, eventInfo) == false) return false;

    
    if (this._editorShowing) {
        var target = event.keyTarget,
            canvasItem;
        while (canvasItem == null && target != this && target != null) {
            canvasItem = target.canvasItem;
            target = target.parentElement;
        }
        if (canvasItem != null && canvasItem.form == this.getEditForm()) {
            var returnVal = this.editorKeyPress(canvasItem, isc.EH.getKey(),
                                isc.EH.getKeyEventCharacterValue());
            return (returnVal == null ? isc.EH.STOP_BUBBLING : returnVal);
        }
    }
    if (this.data.getLength() > 0) {

        // if we start editing on keypress, return false to kill the event (avoiding
        // page navigation on backspace keypress, etc)
        var EH = isc.EventHandler,
            keyName = event.keyName;

        // for arrow keys, navigate to the appropriate record
        var editOnKeyPress = this.editOnKeyPress && this.isEditable();
        if (editOnKeyPress && this._editOnKeyPress(event, eventInfo)) return false;

        var focusCell = this.getFocusCell();
        
        if (this.isGrouped) {
            var isLeft = keyName == this._$ArrowLeft,
                isRight = !isLeft && keyName == this._$ArrowRight;
                
            if (isLeft || isRight) {
                var row = focusCell[0],
                    node = this.data ? this.data.get(row) : null;
                if (node && node._isGroup) {
                    if (isLeft) this.closeFolder(node);
                    else this.openFolder(node);
                    return;
                }
            }
        }

        var focusCell = this.getFocusCell(),
            record = focusCell[0] != null ? this.getCellRecord(focusCell[0], focusCell[1]) : null
        ;
        
        if (this.canExpandRecords && this._canExpandRecord(record, focusCell[0])) {
            var expanded = this.isExpanded(record);
            if (expanded && keyName == this._$ArrowLeft) {
                this.collapseRecord(record);
                return;
            } 
            if (!expanded && keyName == this._$ArrowRight) {
                this.expandRecord(record);
                return;
            }
        }

        switch (keyName) {
            case this._$ArrowUp:    return this._navigateToNextCell(-1,  0);
            case this._$ArrowDown:  return this._navigateToNextCell( 1,  0);
            case this._$ArrowLeft:  return this._navigateToNextCell( 0, -1);
            
            case this._$ArrowRight: return this._navigateToNextCell( 0,  1);
        }

        if (this.shouldNavigateOnTab() && keyName == this._$Tab) {
            if (isc.EH.shiftKeyDown()) return this._navigateToNextCell(0, -1, true);
            else return this._navigateToNextCell(0,1, true);
        }

        // Generate a click on the current focus record when the user hits Space
        if (keyName == this._$Space) {

            // generateFocusRecordClick return values
            // - false implies the actual rowClick handler returned false
            //   In this case suppress the doubleClick (if necessary) and return
            //   false immediately to stop propagation
            // - true implies we found a real cell and executed the rowClick handler
            //   allow doubleclick to fire if necessary, then return false to
            //   cancel propagation of the keypress event.
            //   [we don't for example want a parent to do some odd scroll etc
            //   responding to the space keypress]
            // - null implies we didn't find a target cell. Just allow normal
            //   event propagation.
            var propagate = true;
            if (this.generateClickOnSpace) {
                var rowClickReturnValue = this._generateFocusRecordClick();
                if (rowClickReturnValue == false) return false;
                else if (rowClickReturnValue == true) propagate = false;
            }

            if (this.generateDoubleClickOnSpace) {
                var rowDCReturnValue = this._generateFocusRecordDoubleClick();
                if (rowDCReturnValue != null) propagate = false;
            }
            if (!propagate) return false;

        // Generate a doubleClick on the current focus record when the user hits Enter
        } else if (keyName == this._$Enter) {
            // See "Space" keypress handling for overview of
            // the generateFocusRecordXXX() return values
            var propagate = true;
            if (this.generateClickOnEnter) {
                var rowClickReturnValue = this._generateFocusRecordClick();
                if (rowClickReturnValue == false) return false;
                else if (rowClickReturnValue == true) propagate = false;
            }

            if (this.generateDoubleClickOnEnter) {
                var rowDCReturnValue = this._generateFocusRecordDoubleClick();
                if (rowDCReturnValue != null) propagate = false;
            }
            if (!propagate) return false;

        // Invoke one of the copy/paste shortcuts controlled by useCopyPasteShortcuts
        } else if (EH.modifierKeyDown() &&
                   (keyName == "D" || keyName == "R" || keyName == "C" || keyName == "V")) {
            return this._invokeKeyboardCopyPasteShortcut(keyName);

        // support selecting all cells using Ctrl-A shortcut
        } else if (EH.modifierKeyDown() && keyName == "A" &&
                   this.canSelectCells && this.canSelectAll) {
            this.selection.selectAll();
            this.fireSelectionUpdated();
            return false;

        // Start editing on f2 keypress if editOnF2Keypress is true.
        } else if (keyName == this._$f2 && this.editOnF2Keypress &&
                    this.isEditable() && this.editEvent != "none")
        {
            var rowNum, colNum;
            if (this.canSelectCells && this.editByCell) {
                var cell = this.getFocusCell();
                if (cell[0] >= 0) rowNum = cell[0];
                if (cell[1] >= 0) colNum = cell[1];
            } else {
                rowNum = this.getFocusRow();
                if (rowNum < 0) rowNum = null;
            }
            this.startEditing(rowNum, colNum);
            return false;
        }
    
    // If the grid is empty, do nothing.
    
    }
    return true;
},

//> @method ListGrid.onBodyKeyPress()
// @include ListGrid.bodyKeyPress
// @return (boolean) return false to cancel default drop handling
// @visibility sgwt
//<

onBodyKeyPress : function () {
},


_navigateToNextCell : function (rowStep, colStep, isTabNavigation, checkFirst, navStyle) {
    // If the event was propagated from an embedded component explicitly put focus
    // into the body itself
    
    var event = isc.EH.lastEvent;
    if (this.body.contains(event.keyTarget) && !this.body.hasFocus) {
        this.body.focus();
    } else if (this.frozenBody && 
                this.frozenBody.contains(event.keyTarget) == this.frozenBody && 
                !this.frozenBody.hasFocus)
    {
        this.frozenBody.focus();
    }
    
    if (!this.canSelectCells) return this._navigateToNextRecord(rowStep, checkFirst, navStyle);
    else if (this.selectionType == isc.Selection.NONE) return true;

    if (navStyle == null) {
        navStyle = isTabNavigation ? this.tabKeyAction : this.getArrowKeyAction();
    }
    if (navStyle == this._$none) return true;

    // TabNavigation is slightly different

    var shiftedSelection = isc.EH.shiftKeyDown();

    // To match Excel, re-establish origin if it has been lost
    if (navStyle == this._$select && shiftedSelection) {
        this._ensureValidSelectionOrigin();
    }

    var hiliteCell = this.getFocusCell(shiftedSelection);

//this.logWarn("Get HiliteCell returned this:" + hiliteCell);
    var newRow = hiliteCell[0], newCol = hiliteCell[1];

    if (newRow != null && newCol != null) {
        if (!checkFirst) {
            newRow += rowStep;
            newCol += colStep;
        }
    } else {
        newRow = newCol = 0;
    }
    // getCellRecord ignores the colNum for 1 record / row data models, so
    // with cellSelection enabled, we can go off the end horizontally and
    // still appear to have a valid (enabled) record.
    // Catch this case explicitly
    var totalRows = this.getTotalRows(), totalCols = this.getTotalCols();
    var rowEndAction = "done";
    if (isTabNavigation) rowEndAction = this.rowEndEditAction || "next";

    if (newCol < 0 || newCol >= totalCols) {
        if (rowEndAction == "same") {
            if (colStep > 0) newCol = 0;
            else newCol = totalRows -1;
        } else if (rowEndAction == "next") {
            if (colStep > 0) {
                if (newRow < totalRows-1) {
                    newRow++;
                    newCol = 0;
                } else return true;
            } else {
                if (newRow > 0) {
                    newRow--;
                    newCol = totalCols-1;
                } else return true;
            }
        } else {
            if (rowEndAction == "stop") return false; // suppress normal tab behavior
            // rowEndAction "done" or "none" - return true allowing the
            // user to tab out of the widget.
            return true;
        }
    }

    // For Ctrl+Shift+Arrow Key, We don't want to end up on a disabled cell, so we
    // still need to use the skipping logic below, but reverse the search direction
    var selectToEnd = navStyle == this._$select && isc.EH.modifierKeyDown();
    if (selectToEnd) {
        if      (rowStep > 0) newRow = this.getTotalRows() -1;
        else if (rowStep < 0) newRow = 0;
        if      (colStep > 0) newCol = this.getTotalCols() -1;
        else if (colStep < 0) newCol = 0;
        rowStep = -rowStep;
        colStep = -colStep;
    }
    // At this point we have a pointer to the cell we'd like to hilite / click.
    // If the cell is not enabled, find the next one that is
    while (!this.recordIsEnabled(this.getCellRecord(newRow, newCol), newRow, newCol)) {
        if (rowStep != 0) newRow += rowStep;
        if (colStep != 0) newCol += colStep;
        // bail if reverse search returns to original cell
        if (newRow == hiliteCell[0] && newCol == hiliteCell[1]) {
            return true;
        }
        // moving off the end of the row in either direction - respect the
        // rowEndAction (set up for tab keypresses only)
        if (newCol < 0 || newCol >= totalCols) {
            if (rowEndAction == "same") {
                if (colStep > 0) newCol = 0;
                else newCol = totalRows -1;
            } else if (rowEndAction == "next") {
                if (colStep > 0) {
                    if (newRow < totalRows-1) {
                        newRow++;
                        newCol = 0;
                    } else return true;
                } else {
                    if (newRow > 0) {
                        newRow--;
                        newCol = totalCols-1;
                    } else return true;
                }
            } else {
                if (rowEndAction == "stop") return false; // suppress normal tab behavior
                // rowEndAction "done" or "none" - return true allowing the
                // user to tab out of the widget.
                return true;
            }
        } else if (newRow < 0 || newRow >= totalRows) {
            return true;
        }
    }

    // Note - we already returned if the navigation style is null, so it is fair to assume that
    // we're either going to simulate a click on a cell, or hilite one.
    //
    // Clear out the last hilite. This will both clear out the keyboard specific properties
    // (_lastKeyboardHiliteRow and col), and reset the css style of the last over cell
    this.clearLastHilite();

    // Remember which row and col we're interested in
    this._lastKeyboardHiliteRow = newRow;
    this._lastKeyboardHiliteCol = newCol;
    this._lastKeyboardHiliteBody = this.getFieldBody(newCol);
    if (navStyle == this._$select) {
        // Explicitly hilite the cell.
        // This provides a visual cue (roll over styling) to indicate the record has
        // keyboard focus even if it is un-selectable.
         this._hiliteCell(newRow, newCol);
         
        if (isTabNavigation)this.selection.deselectAll()
        this._generateCellClick(newRow, newCol);
    }
    if (navStyle == this._$focus)  this._hiliteCell(newRow, newCol);

    this._handlingKeyboardNavigation = true;
    this.scrollToCell(newRow, newCol);
    this._handlingKeyboardNavigation = false;

    return false; // stop event propagation
},

//> @method listGrid.focusInCell()
// Puts keyboard focus into the specified cell, showing a highlighted (roll-over style)
// appearance, and ensuring that arrow-key navigation will start from the specified cell.
// <P>
// Only applies where +link{listGrid.canSelectCells} is true.
// @param row (Integer) Index of target row
// @param col (Integer) Index of target col
// @see listGrid.focusInRow()
// @visibility external
//<
focusInCell : function (row, col) {
    this._lastKeyboardHiliteRow = row;
    this._lastKeyboardHiliteCol = col;
    var body = this.getFieldBody(col);
    this._lastKeyboardHiliteBody = body;

    this._hiliteCell(row, col);

    if (!body.hasFocus()) body.focus();

},

//> @method listGrid.focusInRow()
// Puts keyboard focus into the specified row, showing a highlighted (roll-over style)
// appearance, and ensuring that arrow-key navigation will start from the specified row.
// <P>
// Only applies where +link{listGrid.canSelectCells} is false.
// @param row (Integer) Index of target row
// @see listGrid.focusInCell()
// @visibility external
//<
focusInRow : function (row) {
    this._hiliteRecord(row);
    if (!this.body.isFocused()) this.body.focus();
},

_hiliteCell : function (row, col) {
    // if passed in a cell, resolve it to row / col
    if (isc.isAn.Object(row)) {
        col = row._colNum;
        row = row._rowNum;
    }

    // bail if the coordinates passed in don't match a valid row
    if (row == null || col == null ||
        row < 0     || col < 0     ||
        row >= this.getTotalRows() || col >= this.getTotalCols()) return;

    var body = this._lastKeyboardHiliteBody,
        colOffset = body.selection.firstCol || 0;

    body.lastOverRow = row;
    body.lastOverCol = col - colOffset;
    body.setRowStyle(row, null, col - colOffset);

    this.updateRollOverCanvas(row, col);

},

_getLastMouseOverBody : function () {
    if (!this.frozenBody) return this.body;
    if (this.frozenBody.lastMouseOverRow == null &&
        this.frozenBody.lastMouseOverCol == null) return this.body;
    return this.frozenBody;
},

_ensureValidSelectionOrigin : function () {
     if (!this.selection._validateSelectionOrigin(this)) {
         var lastBody = this._getLastMouseOverBody(),
             colOffset = lastBody.selection.firstCol || 0;
         var row = lastBody.lastMouseOverRow || 0,
             col = lastBody.lastMouseOverCol || 0,
             record = this.getCellRecord(row, col + colOffset);
         if (this.recordIsEnabled(record, row, col + colOffset)) {
             lastBody.selectOnMouseDown(record, row, col);
         }
     }
 },

// editOnKeyPress behavior
// - modeled on spreadsheet style application editing
// - normal record selection and navigation occurs on click / arrow keypress when not currently
//   editing the grid
// - on character keypress, start editing (respecting the character typed)

_$f2:"f2",
_$Escape:"Escape",
_$Backspace:"Backspace",
_$Delete:"Delete",
_$keyPress:"keyPress",
_editOnKeyPress : function (event, eventInfo) {
    var keyName = eventInfo.keyName,
        charVal = isc.EH.getKeyEventCharacter(event);
    // We don't want to start editing if the user hit a non character key, such as a function key
    // or escape, etc
    
    if (keyName != this._$f2 && keyName != this._$Delete && keyName != this._$Backspace &&
        (keyName == this._$Escape ||
            isc.EH._nonCharacterKeyMap[keyName] || charVal == null || charVal == isc.emptyString))
    {
        return false;
    }

    var cell = this.getFocusCell(),
        row = cell[0] || 0,
        col = cell[1] || 0;
    // If we're already showing an editor just bail
    if (this._editorShowing || row < 0 || col < 0) return false;

    // on Enter / f2 keypress don't modify the value in the cell
    var undef;
    if (keyName == this._$Enter || keyName == this._$f2) charVal = null;

    var editVal;
    if (charVal != null) {
        if (keyName == this._$Delete || keyName == this._$Backspace) {
            editVal = null;
        } else if (this.autoSelectEditors) {
            editVal = charVal;
        } else {
            editVal = this.getEditedCell(row,col) + charVal;
        }
        // this flag ensures that when we focus in the item we put selection at the end, rather
        // than selecting the entire value.
        this._editorCursorAtEnd = true;
    }
    return this.handleEditCellEvent(cell[0], cell[1], this._$keyPress, editVal);

},

// getArrowKeyAction() - used by _navigateToNextRecord() to determine how the record
// should be hilighted.

// Strings used in navigation styles
_$none:"none", _$focus:"focus", _$select:"select", _$activate:"activate",
getArrowKeyAction : function () {

    var action = this.arrowKeyAction;

    // No action at all trumps everything
    if (action == this._$none) return this._$none;

    // if ctrl key is down but not shift, always just hilite / focus
    var doNotFocus = this.canSelectCells && isc.EH.shiftKeyDown();
    if (isc.EH.modifierKeyDown() && !doNotFocus) return this._$focus;

    // if an explicit arrowKeyAction has been set, respect it
    if (action != null) return action;

    // default to FOCUS if selectionAppearance is "checkbox"; SELECT otherwise
    return this.selectionAppearance == "checkbox" ? this._$focus : this._$select;
},


// In screenReader mode when putting focus onto an actual row element in the body,
// should we show normal keyboard hilite styling etc?
hiliteOnNativeRowFocus:true,

// _navigateToNextRecord()
// Called from this.bodyKeyPress() on arrow keys, to handle navigating around the listGrid.
// If step == +1, we want to navigate to the next record in the list, if step is -1, we want to
// navigate to the previous record.
// Determines which record to navigate to, and falls through to _generateCellClick() or
// _hiliteRecord() depending on the result of this.getArrowKeyAction()
_navigateToNextRecord : function (step, checkFirst, navStyle, suppressScroll) {
    // Are we going to simulate a click on the next record or just hilight it?
    var navStyle = navStyle == null ? this.getArrowKeyAction() : navStyle;

    // If keyboard navigation is disabled return true to allow processing to continue.
    if (navStyle == this._$none || step === 0) return true;

    // Note: we are either going forward or backward one record - assume jumping over multiple
    // records is not supported
    //
    // Default to selecting the next record
    if (step == null) step = 1;

    // Determine which record was last hilighted or clicked
    var newSelectionIndex;

    // By default we want the last row that had keyboard focus
    newSelectionIndex = this.getFocusRow(step > 0);

    // Otherwise, get the last record clicked
    if (newSelectionIndex == null) newSelectionIndex = this._lastRecordClicked;

    var originalSelection = newSelectionIndex,
        normalizedOrigSelection;
    if (!isc.isA.Number(newSelectionIndex)) {
        newSelectionIndex = this.body ? this.body._getViewportFillRows()[0] : 0;
        normalizedOrigSelection = newSelectionIndex;
    } else {
        newSelectionIndex = newSelectionIndex+(checkFirst ? 0 : step);
        normalizedOrigSelection = originalSelection;
    }

    var lastRow = this.getTotalRows() -1;
    // if we are trying to navigate past the ends just ensure the focus row is selected
    if (newSelectionIndex < 0 || newSelectionIndex > lastRow) {
        // bail if there were no records
        if (lastRow < 0) return true;

        // Ensure the original record is selected / focused
        
        newSelectionIndex = normalizedOrigSelection;

    }
    // At this point we are sure that newSelectionIndex is a number.
    // If the number is beyond the end of the list in either direction, or
    // the record is not enabled, recordIsEnabled() will return false.
    // Try the next record in the step direction, and so on until we find an enabled record or
    // hit the end of the list.

    // If the record is disabled, find the first non-disabled record (in the appropriate
    // direction)
    while (!this.recordIsEnabled(this.getCellRecord(newSelectionIndex, 0), newSelectionIndex, 0)) {
        newSelectionIndex += step;
        // if we are trying to navigate past the ends of the list, bail
        if (newSelectionIndex < 0 || newSelectionIndex > lastRow) {
            newSelectionIndex = normalizedOrigSelection;
            break;
        }
    }
    // move native focus to the selected row so that screen readers will read it
    if (isc.screenReader) {
        this.body._putNativeFocusInRow(newSelectionIndex);
    }

    //this.logWarn("navStyle: " + navStyle + ", target index: " + newSelectionIndex);

    if (navStyle == this._$focus) this._hiliteRecord(newSelectionIndex);
    else {
        // Explicitly hilite the record.
        // This provides a visual cue (roll over styling) to indicate the record has
        // keyboard focus even if it is un-selectable.
        this._hiliteRecord(newSelectionIndex);

        // if the user hit up arrow on the first row or down arrow on the last row, don't
        // actually force a click handler to fire on the row.
        // This leads to odd interactions with ListGrid editing on click as arrow down on the
        // last row will hide the editor, then arrow down again will show it on the same
        // row but the first editable col.
        // If the user does want to force a click on the current row via the keyboard
        // they can always hit space or enter.
        
        if (newSelectionIndex == originalSelection) {
            var colNum = this._getKeyboardClickNum();
            if (colNum >= 0) {
                if (this.body.selectionEnabled() &&
                    this.recordIsEnabled(
                        this.getCellRecord(newSelectionIndex, colNum),
                        newSelectionIndex,
                        colNum))
                {
                    this.selection.selectOnMouseDown(this, newSelectionIndex, colNum);
                    this.selection.selectOnMouseUp(this, newSelectionIndex, colNum);

                    // Explicitly fire the selectionUpdated notification
                    this.fireSelectionUpdated();
                }
            }
        }
        else if (navStyle == this._$select) this._generateCellClick(newSelectionIndex);
        else if (navStyle == this._$activate) this._generateRecordDoubleClick(newSelectionIndex);
    }
    if (!suppressScroll) {
        this._handlingKeyboardNavigation = true;
        this.scrollRecordIntoView(newSelectionIndex)
        this._handlingKeyboardNavigation = false;
    }
    // Don't allow the keypress event handling to continue here.
    return false;
},

_getKeyboardClickNum : function () {

    // If this.keyboardClickField was specified, return the appropriate colNum
    // Note - can be specified as a field number or field name...
    var kcf = this.keyboardClickField;
    if (kcf != null) {

        var kcCol;
        if (isc.isA.Number(kcf) && kcf > 0 && kcf < this.fields.length) {
            kcCol = this.fields[kcf];
        } else {
            kcCol = this.fields.find(this.fieldIdProperty, kcf);
        }
        if (kcCol && kcCol.ignoreKeyboardClicks) {
            this.logWarn("Explicitly specified keyboardClickField:" + this.keyboardClickField +
                " refers to a field which disallows keyboard click events.");
            kcCol = null;
        }
        if (kcCol != null) {
            return this.fields.indexOf(kcCol);
        }
    }
    if (this.getCurrentCheckboxField() != null) {
        return this.getCheckboxFieldPosition();
    }

    for (var i = 0; i < this.fields.length; i++) {
        if (this.fields[i].ignoreKeyboardClicks != true) return i;
    }
    // Unable to find a valid field - return -1. Calling code will have to handle this
    return -1;
},

_generateCellClick : function (rowNum, colNum, focus) {
    // Ensure we're not showing a rollOver hilite on a different row.
    if (!this.canSelectCells && this.body.lastOverRow != null &&
        this.body.lastOverRow != rowNum)
    {
        this.clearLastHilite();
    }

    // if passed a record, resolve it to an index!
    if (isc.isAn.Object(rowNum)) rowNum = this.getRecordIndex(rowNum);

    // Make sure we're not trying to select a record beyond the ends of the list.
    if (!isc.isA.Number(rowNum) || rowNum < 0) rowNum = 0;
    if (rowNum >= this.data.getLength()) rowNum = this.data.getLength() -1;

    var body;
    if (this.canSelectCells) {
        if (colNum == null || colNum < 0 || colNum >= this.getTotalCols()) return;
        body = focus ? this.getFieldBody(colNum) : this._lastKeyboardHiliteBody;
    } else {
        body = this.body;
        // remember we artificially selected this record from a keyboard event
        body._lastHiliteRow = rowNum;

        colNum = this._getKeyboardClickNum();
        if (colNum == -1) return;
    }
    var colOffset = body.selection.firstCol || 0;

    // Trigger the methods to perform the selection (selection.selectOnMouseDown AND
    // selection.selectOnMouseUp)
    
    var record = this.getCellRecord(rowNum, colNum),
        performSelection = this.selectOnGeneratedCellClick(record, rowNum, colNum, body);
    
    if (performSelection) {
        body.selectOnMouseDown(record, rowNum, colNum - colOffset, true);
        body.selectOnMouseUp(record, rowNum, colNum - colOffset, true);
    }

    // explicitly fire this 'rowClick' method, passing in the additional method flagging this
    // as a keyboard generated click
    return this.rowClick(this.getCellRecord(rowNum, colNum), rowNum, colNum, true);

},

selectOnGeneratedCellClick : function (record, rowNum, colNum, body) {
    return (body.selectionEnabled() && this.recordIsEnabled(record, rowNum, colNum));
},

//> @method listGrid.getFocusRow() [A]
// Get the row that currently has keyboard focus.  Arrow key navigation moves relative to this
// row.
//
// @return (Integer) rowNum of the current focus row
// @visibility external
//<
// @param last (boolean) if multiple rows are selected, should we return the last row in the
//  selection (rather than the first?
getFocusRow : function (last) {

    // We want the last record hilighted by the keyboard.
    // Note: If the last keyboard hilite type event was a generated record click, the
    // lastHiliteRow will match the lastRecordclicked property for this widget.
    // If the last keyboard hilite type event was a hilite (rollover style) event, the
    // lastHiliteRow will match the lastOverRow for the body.
    // If neither of these are true, we can assume a subsequent mouse event has occurred over
    // a different row, effectively invalidating the _lastHiliteRow property, so should be
    // ignored and deleted
    if (this.body._lastHiliteRow != null &&
        ((this.body._lastHiliteRow == this.body.lastOverRow) ||
         (this.body._lastHiliteRow == this._lastRecordClicked)) )
    {
        return this.body._lastHiliteRow;
    }
    delete this.body._lastHiliteRow;
    // If there is no valid keyboard hilite row, return a record from the end of the selection
    // We use 'direction' param to indicate whether it's more appropriate to return the
    // first or last selected record of a multiple selection
    var selection = this.getSelection();
    if (selection.length == 0) return null;
    selection = selection[(last ? selection.length -1 : 0)]
    return this.getRecordIndex(selection);

},

// Helper method to get the last keyboard hilite cell position.
getFocusCell : function (querySelectionObject) {

    if (!this.canSelectCells) {
        return [this.getFocusRow(), this._getKeyboardClickNum()];
    }

    var row, col;

    // this._lastKeyboardHiliteRow and col are only valid if they match the last row clicked, or
    // the last row hilited - otherwise some non-keyboard manipulation has occurred since the values
    // were set.
    
//this.logWarn("row/col:" + this._lastKeyboardHiliteRow + ", " + this._lastKeyboardHiliteCol);
    if (this._lastKeyboardHiliteRow != null && this._lastKeyboardHiliteCol != null) {
        var body = this._lastKeyboardHiliteBody;
        if (body != null) {
            var colOffset = body.selection.firstCol || 0;
            if ((this._lastKeyboardHiliteRow == body.lastOverRow &&
                 this._lastKeyboardHiliteCol == body.lastOverCol + colOffset) ||
                (this._lastSelectedBody      == body &&
                 this._lastKeyboardHiliteRow == body._lastSelectedRow &&
                 this._lastKeyboardHiliteCol == body._lastSelectedCol + colOffset))
            {
                row = this._lastKeyboardHiliteRow;
                col = this._lastKeyboardHiliteCol;
            }
        }
    }

    // If we didn't find a keyboard cell, grab the last selected cell
    if (row == null || col == null) {
        if (querySelectionObject) {
            row = this.selection.lastRow;
            col = this.selection.lastCol;
        }
        var body = this._lastSelectedBody;
        if (body) {
            var colOffset = body.selection.firstCol || 0;
            if (row == null || col == null) {
                row = body._lastSelectedRow;
                col = body._lastSelectedCol + colOffset;
            }
        }
        if (row == null || col == null) {
            var selection = this.getSelection();
            if (selection.getLength() > 0) {
                row = selection[0]._rowNum;
                col = selection[0]._colNum;
            }
        }
    }
    return [row, col];
},

// Called from grid body keyboard event handling.
// Return values as follows
// - return false if actual rowClick etc returned false.
// - return true if a valid cell was found and the rowClick executed
// - return null if no valid cell was found
_generateFocusRecordClick : function () {
    var cell = this.getFocusCell(),
        row = cell[0],
        col = cell[1];

    if (row != null && col != null) {
        var rv = this._generateCellClick(row, col, true);
        if (rv == null) rv = true;
        return rv;
    }
    return null;
},

_generateRecordDoubleClick : function (rowNum, colNum) {
    if (colNum == null) colNum = this._getKeyboardClickNum();
    if (colNum == null || colNum == -1) return;

    // generate a double click, on the appropriate record (and field), passing in the
    // parameter flagging this as a keyboard synthesized click event.
    //this._handleRecordDoubleClick(currentRecord, colNum);
    return this.rowDoubleClick(this.getCellRecord(rowNum, colNum), rowNum, colNum, true);
},

_generateFocusRecordDoubleClick : function () {
    var cell = this.getFocusCell(),
        row = cell[0],
        col = cell[1];
    if (row != null && col != null && col >= 0) {
        var rv = this._generateRecordDoubleClick(row, col);
        if (rv == null) rv = true;
        return rv;
    }
    return null;
},

// Scrolling
// --------------------------------------------------------------------------------------------

//> @attr listGrid.scrollToCellXPosition (Alignment : "center" : IRW)
// When scrollToCell is called, this is used as defaults if xPosition weren't explicitly passed
// into the method.
// @visibility external
//<
scrollToCellXPosition: "center",

//> @attr listGrid.scrollToCellYPosition (VerticalAlignment : "center" : IRW)
// When scrollToCell is called, this is used as defaults if yPosition weren't explicitly passed
// into the method.
// @visibility external
//<
scrollToCellYPosition: "center",

//> @method listGrid.scrollRecordToTop()    (A)
// Scroll the listGrid body such that the specified row is visible at the top of the viewport.
//      @group  scrolling
//      @param  rowNum  (number)    Index of the row to scroll into view
//<
scrollRecordToTop : function (rowNum) { return this.scrollRecordIntoView(rowNum, "top"); },

//> @method listGrid.scrollRecordIntoView() (A)
// Scroll the listGrid body such that the specified row is visible close to the
// center of the viewport.
//      @group  scrolling
//      @param  rowNum  (number)    Index of the row to scroll into view
//      @param  [yPosition] (VerticalAlignment) Vertical position of scrolled row (optional)
//<
scrollRecordIntoView : function (rowNum, yPosition) {
    return this.scrollToCell(rowNum, null, null, yPosition);
},

//> @method listGrid.scrollToColumn()
// Scroll the grid to specified column such that the row appears near the center of the
// viewport.
// <P>
// See +link{listGrid.scrollToCell()} for a full description of how
// this method interacts with incremental loading and rendering of data.
// @group   scrolling
// @param   colNum  (number)    Index of the column to scroll into view
// @param   [xPosition] (Alignment) Horizontal position of scrolled column (optional)
// @visibility external
//<
scrollToColumn : function (colNum, xPosition) {
    return this.scrollToCell(null, colNum, xPosition);
},

//> @method listGrid.scrollToRow()
// Scroll the grid to specified row such that the row appears near the center of the
// viewport, loading data if necessary.
// <P>
// See +link{listGrid.scrollToCell()} for a full description of how
// this method interacts with incremental loading and rendering of data.
//
// @group scrolling
// @param   rowNum  (number)    Row index of the cell to scroll into view
// @param   [yPosition] (VerticalAlignment) Vertical position of scrolled row (optional)
// @visibility external
//<
scrollToRow : function (rowNum, yPosition) {
    this.scrollToCell(rowNum, 0, null, yPosition);
    // allow for chaining other function calls after scrollToRow()
    return this;
},

// helper callback to weed out calls to scrollToRow that should be ignored.
// we only want to perform the last call to scrollToRow() that occurs before data arrives.
scrollCellCallback : function (rowNum, colNum, xPosition, yPosition, alwaysScroll, stamp) {
    if (stamp == this._currentScrollCall) {
        // reset counter
        this._currentScrollCall = null;
        this.scrollToCell(rowNum, colNum, xPosition, yPosition, alwaysScroll);
    }
},

//> @method listGrid.scrollToCell() (A)
// Will scroll the listGrid body such that the specified cell is visible close to the
// center of the viewport.
// <P>
// This method has no effect if the cell is already visible in the viewport.
// <P>
// When scrolling vertically, this will cause data to be automatically loaded
// if +link{dataFetchMode,paging is active} and you scroll into an area of
// the data that isn't loaded.  Only rows around the target row will be
// loaded, not all intervening rows.  See also +link{ResultSet}.
// <P>
// Scrolling into an undrawn area will cause the body area of the grid to
// redraw, but this won't happen synchronously unless you explicitly call
// redraw().  Scrolling into an area of the data that is not yet loaded
// will never synchronously draw new rows, even if you call redraw() -
// wait for +link{dataArrived} to be notified when new rows have been
// loaded.
// <P>
// Calling this method with a row index larger than the
// current dataset will clamp to the end of the dataset (similarly horizontal
// scrolling will clamp to the last column).
// <P>
// If a call to this method is made while data is still loading, such
// that the last row of the dataset is not yet known the grid will attempt to compensate
// by scrolling the record into view when data arrives, if it is valid.
// For better control over scrolling, developers should consider
// calling <code>scrollToRow()</code> or <code>scrollToCell</code>
// from +link{dataArrived()} if data is still loading.
// <P>
// With mixed-height rows it will only reliably work if virtualScrolling
// is enabled.
//
// @group   scrolling
// @param   rowNum  (int)    Row index of the cell to scroll into view
// @param   colNum  (int)    Column index of the cell to scroll into view
// @param   [xPosition] (Alignment) Horizontal position of scrolled cell (optional)
// @param   [yPosition] (VerticalAlignment) Vertical position of scrolled cell (optional)
// @visibility external
//<
scrollToCell : function(rowNum, colNum, xPosition, yPosition, alwaysScroll) {
    return this.scrollCellIntoView(rowNum, colNum, xPosition, yPosition, alwaysScroll);
},

// alwaysScroll: scroll even if the cell is already in view (position it
//               according to "xPosition" and "yPosition" parameters)
scrollCellIntoView : function (rowNum, colNum, xPosition, yPosition, alwaysScroll) {
    // method arguments has been changed from (rowNum, colNum, center, alwaysCenter) so if
    // we could determine old arguments we should log warning message and convert passed values
    // to new arguments
    if (isc.isA.Boolean(xPosition) && (typeof alwaysScroll == 'undefined')) {
        isc.logWarn("Center argument had been passed to a scroll method(scrollToCell, " +
            "scrollCellIntoView, scrollToColumn or scrollRecordIntoView). This is deprecated. " +
            "See documentation for detailed information about passed arguments.");
        alwaysScroll = yPosition;
        yPosition = xPosition? "center": "top";
        xPosition = xPosition? "center": "left";
    }

    if ((isc.isAn.Array(this.data) && this.data.length == 0 && this.dataSource)
        || (isc.ResultSet && isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown())) {
        // keep track of consecutive calls to scrollToRow() so we can only perform the most
        // recent one, before data arrives.
        if (!this._currentScrollCall) this._currentScrollCall = 1;
        else this._currentScrollCall += 1;
        var stamp = this._currentScrollCall;
        isc.Page.waitFor(this, "dataArrived",
            {method: this.scrollCellCallback, args: [rowNum, colNum, xPosition, yPosition, alwaysScroll, stamp],
            target:this}
        );

        return;
    }

    // if the body isn't drawn, we can't scroll the cell into view - set a flag to scroll the
    // body when it gets drawn
    if (!this.body || !this.body.isDrawn()) {
        this.logInfo("scrollCellIntoView() called before the body has been drawn.  Cell " +
                     rowNum + "," + colNum + " will scrolled into view on draw().");
        this._scrollCell = [rowNum, colNum, xPosition, yPosition];
        return;

    }

    // Force an immediate adjustOverflow before we calculate row / viewport size etc
    
    if (this.body._deferredOverflow || this.body._overflowQueued) {
        this.body.adjustOverflow("ScrollCellIntoView requesting size");
    }

    // Use default values scrollToCellXPosition and scrollToCellYPosition if null or incorrect
    // value has been passed
    if (xPosition != "left" && xPosition != "center" && xPosition != "right") {
        xPosition = this.scrollToCellXPosition;
    }
    if (yPosition != "top" && yPosition != "center" && yPosition != "bottom") {
        yPosition = this.scrollToCellYPosition;
    }

    var x, y, width, height, body = this.body;
    if (rowNum != null) {
        if (!body._isVirtualScrolling) {
            y = body.getRowTop(rowNum);
            height = body.getRowSize(rowNum);
        } else {
            // If the row is already in the viewport, don't call scrollToTargetRow()
            // as this will shift it about which can be confusing if the user is
            // navigating through rows with the keyboard.
            var undrawn = body._firstDrawnRow == null || rowNum < body._firstDrawnRow ||
                rowNum > body._lastDrawnRow,
                inViewport = !undrawn;
            if (inViewport) {
                var rowTop = body.getRowTop(rowNum),
                    rowHeight = body.getRowHeight ?
                                    body.getRowHeight(this.getCellRecord(rowNum), rowNum, 0) :
                                    body.cellHeight,
                    scrollTop = body.getScrollTop();
                if (scrollTop > rowTop ||
                    ((body.getViewportHeight() + scrollTop) < (rowTop + rowHeight)))
                {
                    inViewport = false;
                }
            }
            if (!inViewport) {
                // scrolling to a particular coordinate would be meaningless with unknown row
                // heights
                body._targetRow = rowNum;
                if (yPosition == "center") {
                    var rowHeight = body.getRowHeight ?
                            body.getRowHeight(this.getCellRecord(rowNum), rowNum, 0) :
                            body.cellHeight;
                    body._rowOffset = -1 * (body.getViewportHeight() - rowHeight) / 2;
                } else if (yPosition == "bottom") {
                    var rowHeight = body.getRowHeight ?
                            body.getRowHeight(this.getCellRecord(rowNum), rowNum, 0) :
                            body.cellHeight;
                    body._rowOffset = rowHeight - body.getViewportHeight();
                } else {
                    body._rowOffset = 0;
                }

                if (colNum != null) {
                    var cellOffset = null;
                    if (xPosition == "left") {
                        cellOffset = this.getColumnLeft(colNum);
                    } else if (xPosition == "right") {
                        cellOffset = this.getColumnLeft(colNum) +
                            this.getColumnWidth(colNum) - body.getViewportWidth();
                    } else {
                        cellOffset = this.getColumnLeft(colNum) +
                            (this.getColumnWidth(colNum) - body.getViewportWidth()) / 2;
                        
                    }
                    // Scroll horizontally.
                    // no "virtual scrolling" on the h-axis so this is just a simple number.
                    // The scrollToTargetRow call below will handle scrolling vertically
                    body.scrollTo(cellOffset);

                }
                body._scrollToTargetRow();
            }
            return;
        }
    }
    if (colNum != null) {
        if (this.frozenFields != null && colNum < this.frozenFields.length) {
            colNum = null;
        } else {
            x = this.getColumnLeft(colNum);
            width = this.getColumnWidth(colNum);
        }
    }

    // Catch the case where we're dirty, and the row being scrolled into view is not yet present
    // in our HTML (so we can't scroll into view until the redraw occurs)
    if (this.isDirty() || this.body.isDirty()) {
        var mustRedraw;
        if (rowNum != null) {
            var scrollHeight = body.getScrollHeight();
            if (y+height > scrollHeight) mustRedraw = true;
        }
        if (!mustRedraw && colNum != null) {
            var scrollWidth = body.getScrollWidth();
            if (x+width > scrollWidth) mustRedraw = true;
        }
        if (mustRedraw) this.redraw("scrollIntoView");
    }

    //this.logWarn("ScrollIntoView passed: " + [rowNum, colNum] +
    //             ", calculated target cell position:" + [x,y] + ", size:" + [width,height]);

    body.scrollIntoView(x,y,width,height, xPosition, yPosition,
                        null, null, alwaysScroll)

},

// Header/Body Scroll Sync
// --------------------------------------------------------------------------------------------
// Note - we keep the body / header's horizontal scroll position in sync by firing
// syncHeaderScrolling when the body is scrolled, and syncBodyScrolling where the header is
// scrolled.
// We have to have these no-op if the header / body are already at the same place to avoid an
// infinite loop.

bodyScrolled : function (left, top, isFrozen) {

    if (left == null) left = isFrozen ? this.frozenBody.getScrollLeft() : this.body.getScrollLeft();

    // Assertion
    // the frozen body should never be clipping horizontally so if this was a
    // scroll from the frozen body, just sync up the vertical scroll position of the
    // unfrozen body and we're done.
    // NOTE: There's no obvious way for the user to scroll just the frozen body but this
    // could probably happen from interactions like keyboard events

    
    if (isFrozen) {
        this.body._noScrollObservation = true;
        var frozenBody = this.frozenBody;
        if (frozenBody._literalScroll) {

            this.body._targetRow = frozenBody._targetRow;
            this.body._rowOffset = frozenBody._rowOffset;
            this.body._scrollRatio = frozenBody._scrollRatio;
            this.body._scrollToTargetRow();
        } else {
            this.body.scrollTo(null, top, "scrollSync");
        }
        delete this.body._noScrollObservation

        return;
    }


    if (this.frozenBody != null) {
        this.frozenBody._noScrollObservation = true;
        var body = this.body,
            frozenBody = this.frozenBody;

        // virtual scrolling: The frozen body's virtual scrolling logic
        // (draw area etc) is all driven of the unfrozen body since that can detect
        // cases like "quick drag scrolling" of the scrollbars.
        // If the body is currently doing a "scrollToTargetRow", pick up the
        // stored targetRow info from the body and scrollToTargetRow ourselves
        
        if (body._literalScroll) {

            frozenBody._targetRow = body._targetRow;
            frozenBody._rowOffset = body._rowOffset;
            frozenBody._scrollRatio = body._scrollRatio;
            frozenBody._scrollToTargetRow();
        } else {
            frozenBody.scrollTo(null, top, "bodyScrollSync");
        }
        delete this.frozenBody._noScrollObservation;
    }

    // Don't attempt to sync scrolling while drag-resizing.
    
    if (!this._dragResizingField) {
        this.syncHeaderScrolling(left, top);
        this.syncFilterEditorScrolling(left, top);
        this.syncSummaryRowScrolling(left,top);
    }

    // If we took focus from the edit form as part of a redraw and haven't restored it yet
    // restore it now
    
    if (this._editorShowing && this._editorSelection) {
        var editForm = this.getEditForm(),
            editRow = this.getEditRow(),
            editColNum = this.getEditCol(),
            editItem = editForm.getItem(this.getEditorName(editRow, editColNum));

        if (editItem) {
            if (!editItem.hasFocus &&
                (editForm.hasFocus || isc.EH.getFocusCanvas() == null))
            {
                this._restoreFocusAfterRedraw(editColNum);
            } else {
                delete this._editorSelection;
            }
        }
    }

},


syncHeaderScrolling : function (left, top) {
    if (left != null && this.header) {
        if (!this.isRTL()) {
            if (left != this.header.getScrollLeft()) {
                this.header.scrollTo(left, null, "headerScrollSync");
            }
        } else {
            
            var header = this.header,
                body = this.body,
                headerMaxScroll = header.getScrollWidth() - header.getViewportWidth(),
                headerScrollPos = headerMaxScroll - header.getScrollLeft(),
                bodyMaxScroll = body.getScrollWidth() - body.getViewportWidth(),
                bodyScrollPos = bodyMaxScroll - left;
            /*
            this.logWarn("scroll sync: body new left: " + left +
                         ", body max: " + bodyMaxScroll +
                         ", body pos: " + bodyScrollPos +
                         ", header current left: " + header.getScrollLeft() +
                         ", header max: " + headerMaxScroll +
                         ", header pos: " + headerScrollPos +
                         ", will scroll header to: " + (headerMaxScroll - bodyScrollPos));
            */

            if (bodyScrollPos != headerScrollPos) {
                header.scrollTo(headerMaxScroll - bodyScrollPos, null, "scrollSync");
            }
        }
    }
},

// when the header is scrolled, keep the body scrolled in sync with it!
headerScrolled : function () {
    
    if (!this._delayingBodyScrolling) {
        this._delayingBodyScrolling = this.delayCall("syncBodyScrolling");
    }
},


syncBodyScrolling : function () {
    delete this._delayingBodyScrolling;
    var left = this.header.getScrollLeft();
    if (this.body) {
        if (!this.isRTL()) {
            if (left != this.body.getScrollLeft()) this.body.scrollTo(left, null, "scrollSync");

        } else {

            var header = this.header,
                body = this.body,
                headerMaxScroll = header.getScrollWidth() - header.getViewportWidth(),
                headerScrollPos = headerMaxScroll - header.getScrollLeft(),
                bodyMaxScroll = body.getScrollWidth() - body.getViewportWidth(),
                bodyScrollPos = bodyMaxScroll - left;
            
            if (bodyScrollPos != headerScrollPos) {
                body.scrollTo(Math.max(0, bodyMaxScroll - headerScrollPos), null, "scrollSync");
            }
        }
    }
},

// if we are showing a filter editor we must keep that horizontally scrolled to the same
// position as the body
syncFilterEditorScrolling : function (left, top) {
    if (left == null) return;
    if (this.filterEditor != null && this.filterEditor.body != null) {
        // RTL mode - account for the fact that scrolled to zero (IE hard left) on the main grid
        // body != scrolled to zero (hard left) on the filter editor since their left coords don't
        // align.
        if (this.isRTL()) {
            var offset = this.body.getViewportWidth() - this.filterEditor.body.getViewportWidth()
            left += offset;
        }

        // No op if they are already in sync to avoid an infinite loop
        if (this.filterEditor.body.getScrollLeft() != left)
        {
            this.filterEditor.body.scrollTo(left, null, "scrollSync");
        }
    }
},

syncSummaryRowScrolling : function (left,top) {
    if (left == null) return;
    if (this.summaryRow != null && this.showGridSummary && this.summaryRow.body != null &&
        this.summaryRow.body.getScrollLeft() != left)
    {
        this.summaryRow.body.scrollTo(left, null, "scrollSync");
    }
},

// RollOver
// --------------------------------------------------------------------------------------------


_hiliteRecord : function (recordNum) {
    if (!isc.isA.Number(recordNum)) {
        recordNum = this.getRecordIndex(recordNum);
    }

    // Make sure we're not trying to select a record beyond the ends of the list.
    if (!isc.isA.Number(recordNum) || recordNum < 0) recordNum = 0;

    // clamp to getTotalRows(), not data.getLength() - caters for unsaved rows
    if (recordNum >= this.getTotalRows()) {
        recordNum = this.getTotalRows() - 1;
    }

    this.clearLastHilite();

    // note the row number hilighted by keyboard navigation
    this.bodies.setProperty("_lastHiliteRow", recordNum);

    // set this.body.lastOverRow, so the recordStyle will be updated to the mouseOver style
    
    this.bodies.setProperty("lastOverRow", recordNum);
    this.bodies.setProperty("lastOverCol",0);  // required to make the GR believe the mouse was over a real cell

    // no need to calculate the style - setRowStyle will achieve that
    this.bodies.map("setRowStyle", recordNum);
    
    this.updateRollOverCanvas(recordNum);

},

//> @method listGrid.clearLastHilite()  (A)
// Unhilites the last hilited item.
//      @group  events, hiliting
//<
clearLastHilite : function (frozen) {
    var body = frozen ? this.frozenBody : this.body;
    if (!body) return;

    // the obvious merge of the two cases of this.canSelectCells doesn't work because
    // body.lastOverCol can be != null for the case of !this.canSelectCells
    var rowToClear = body.lastOverRow,
        colToClear;

    if (rowToClear < 0) return;
        
    // clear the pointer to the last row hilited via keyboard navigation
    var hasKeyboardHilites = false;
    if (!this.canSelectCells) {
        hasKeyboardHilites = (body._lastHiliteRow != null);
        body._lastHiliteRow = null;
        if (rowToClear == null) return;
    } else {
        // make sure to clear frozen body hilites
        hasKeyboardHilites = (this._lastKeyboardHiliteRow != null && this._lastKeyboardHiliteCol != null);
        if (!frozen) this.clearLastHilite(true);
        this._lastKeyboardHiliteRow = null;
        this._lastKeyboardHiliteCol = null;
        this._lastKeyboardHiliteBody = null;
        colToClear = body.lastOverCol;
        if (rowToClear == null || colToClear == null) return;
        delete body.lastOverCol;
    }
    delete body.lastOverRow;

    // no need to calculate new styleName here - let setRowStyle determine that
    if (this.showRollOver || hasKeyboardHilites) {
        body.updateRollOver(rowToClear, colToClear);
    }
},

// Note that we basically use the body like a focusProxy - when focus() is called, focus
// will go to the body.
// o Set _useFocusProxy to false - we don't want the grid to ever have native focus
// o Set _useNativeTabIndex to false - this is done AFTER creating the body so the body can
//   pick up the '_useNativeTabIndex' as explicitly specified on the ListGrid before that
//   property gets overridden.
_useFocusProxy:false,

// Override setAccessKey to set the accessKey on the body rather than on the listGrid
setAccessKey : function (accessKey) {
    // call Super - will remember this.accessKey, (though it won't actually set it on the LV handle)
    this.Super("setAccessKey", arguments)
    if (this.body != null) this.body.setAccessKey(accessKey);
},

// Override setFocus to focus on the body rather than the ListGrid
setFocus : function (newfocus) {
    if (this.body != null) {
        this.body.setFocus(newfocus);
    }
},

// If "focusAtEnd" is called, always just pass focus to the "next tab element".
// The grid is marked as canFocus:true, but doesn't actually ever takes focus: Always
// delegates to its children.
// The grid's tab-index will precede that of its children.
// When synthetically tabbing through widgets, this method can be called:
// When the user is tabbing forward and encounters the grid
// - just put focus into the next tab widget (should be the appropriate header toolbar or
//   body)
// When the user is tabbing backwards and has already gone through the grid members
// - just put focus into the prev-tab-widget (will be whatever precedes the LG as a whole
//   in the page's tab order)
focusAtEnd : function (start) {
    this._focusInNextTabElement(start);
},

// Override _canFocus() - we are focusable if the body is focusable
// Note that the body already picks up the 'canFocus' attribute from the ListGrid, if specified
// _canFocus is also overridden in gridBody to disable focus when empty, if appropriate
_canFocus : function () {
    if (this.body) return this.body._canFocus();
    return false;
},
    
//> @attr listGrid.canFocusInEmptyGrid (boolean : true : IRA)
// If the listGrid is empty, should the user be able to put focus into the grid body by tabbing
// to it?
// <P>
// Note that if +link{editOnFocus} is true for this grid and +link{listEndEditAction} is set to next,
// having this property set to true will allow users to automatically create a new edit row by
// simply tabbing into the grid.
//
// @visibility external 
//<
canFocusInEmptyGrid:true,

// disable the focus indicator in Chrome/Safari since it's clipped at the bottom/right and looks
// odd
showFocusOutline:!isc.Browser.isSafari,

// Body Clicks
// --------------------------------------------------------------------------------------------

//> @method listGrid.recordClick()
// Executed when the listGrid receives a 'click' event on an enabled, non-separator
// record. The default implementation does nothing -- override to perform some action
// when any record or field is clicked.<br>
// A record event handler can be specified either as
// a function to execute, or as a string of script to evaluate. If the handler is defined
// as a string of script, all the parameters below will be available as variables for use
// in the script.<br>
// To do something specific if a particular field is clicked, add a recordClick
// method or string of script to that field (same parameters) when you're setting up
// the list.<br>
// <b>Notes:</b><ul>
// <li>This will not be called if the click is below the last item of the list.</li>
// <li>This method is called from the default implementation of
// +link{method:listGrid.rowClick}, so if that method is overridden
// this method may not be fired.</li></ul>
//
// @param viewer (ListGrid) the listGrid that contains the click event
// @param record (ListGridRecord) the record that was clicked on
// @param recordNum (number) number of the record clicked on in the current set of
//                                  displayed records (starts with 0)
// @param field (ListGridField) the field that was clicked on (field definition)
// @param fieldNum (number) number of the field clicked on in the listGrid.fields
//                                  array
// @param value (any) value of the cell (after valueMap, etc. applied)
// @param rawValue (any) raw value of the cell (before valueMap, etc applied)
// @return (boolean) return false to cancel default behavior
//
// @see rowClick()
// @group events
// @visibility external
//<
// NOTE: params not needed for default no-op implementation
recordClick : function () {
    return true;
},

//> @method listGrid.onRecordClick()
// Executed when the listGrid receives a 'click' event on an enabled, non-separator
// record. The default implementation does nothing -- override to perform some action
// when any record or field is clicked.<br>
// A record event handler can be specified either as
// a function to execute, or as a string of script to evaluate. If the handler is defined
// as a string of script, all the parameters below will be available as variables for use
// in the script.<br>
// To do something specific if a particular field is clicked, add a recordClick
// method or string of script to that field (same parameters) when you're setting up
// the list.<br>
// <b>Notes:</b><ul>
// <li>This will not be called if the click is below the last item of the list.</li>
// <li>This method is called from the default implementation of
// +link{method:listGrid.rowClick}, so if that method is overridden
// this method may not be fired.</li></ul>
//
// @param viewer (ListGrid) the listGrid that contains the click event
// @param record (ListGridRecord) the record that was clicked on
// @param recordNum (number) number of the record clicked on in the current set of
//                                  displayed records (starts with 0)
// @param field (ListGridField) the field that was clicked on (field definition)
// @param fieldNum (number) number of the field clicked on in the listGrid.fields
//                                  array
// @param value (object) value of the cell (after valueMap, etc. applied)
// @param rawValue (object) raw value of the cell (before valueMap, etc applied)
// @return (boolean) return false to cancel default behavior
//
// @see rowClick()
//
// @group events
// @visibility sgwt
//<
onRecordClick : function (viewer, record, recordNum, field, fieldNum, value, rawValue) {
    return true;
},

//> @method listGrid.recordDoubleClick()
// Executed when the listGrid receives a 'doubleClick' event on an enabled, non-separator
// record. The default implementation does nothing -- override to perform
// some action when any record or field is double clicked.<br>
// A record event handler can be specified either as a function to execute, or as a string
// of script to evaluate. If the handler is defined as a string of script, all the
// parameters below will be available as variables for use in the script.<br>
// To do something specific if a particular field is double clicked, add a
// recordDoubleClick method or string of script to that field (same parameters) when you're
// setting up the list.<br>
// <b>Notes:</b><ul>
// <li>This will not be called if the click is below the last item of the list.</li>
// <li>This method is called from the default implementation of +link{method:listGrid.rowDoubleClick},
// so if that method is overridden this method may not be fired.</li></ul>
//      @group  events
//
// @param   viewer      (listGrid)  the listGrid that contains the doubleclick event
// @param   record      (ListGridRecord)    the record that was double-clicked
// @param   recordNum   (number)    number of the record clicked on in the current set of
//                                  displayed records (starts with 0)
// @param   field       (ListGridField) the field that was clicked on (field definition)
// @param   fieldNum    (number)    number of the field clicked on in the listGrid.fields
//                                  array
// @param   value       (object)    value of the cell (after valueMap, etc. applied)
// @param   rawValue    (object)    raw value of the cell (before valueMap, etc applied)
// @return (boolean)    return false to cancel event bubbling
//
// @see    rowDoubleClick()
//
// @visibility external
//<
// NOTE: params not needed for default no-op implementation
recordDoubleClick : function () {},

// --------------------------------------------------------------------------------------------
// Summary row
// --------------------------------------------------------------------------------------------

// If grid.showGridSummary is true, generate a 'summaryRow' auto child to show summaries at
// the bottom of the list grid.
// Default behavior is to show totals for numeric fields

//> @attr listGrid.showGridSummary (Boolean : false : IRW)
// Should this ListGrid show a summary row beneath the last record of the grid. This summary
// row will contain per-field summary information. See +link{listGridField.showGridSummary} and
// +link{listGrid.getGridSummaryFunction()} for details on how the summary value to be displayed
// for each column will be calculated.
// <P>
// Note that the +link{listGrid.summaryRow,summaryRow autoChild} will be created to actually
// display the summary row.
// @visibility external
//<
showGridSummary:false,

//> @attr listGrid.invalidSummaryValue (string : "&nbsp;" : IRWA)
// Value to display to the user if showing summary values (through +link{listGrid.showGridSummary},
// +link{listGrid.showGroupSummary} or +link{listGridFieldType,listGridFieldType:"summary"}), and
// the summary function returns <code>"null"</code> (implying it was unable to calculate a
// valid summary value). This property will only be used in the default formatting behavior. If
// an explicit formatter has been specified - via +link{listGrid.formatCellValue} or
// +link{listGridField.formatGridSummary(),formatGridSummary()}, for example - this property has
// no effect.
// @visibility external
//<
invalidSummaryValue:"&nbsp;",

//> @attr listGrid.includeInSummaryProperty (string : "includeInSummary" : IRW)
// Property name on a record that will be checked to determine whether a record should
// be included when calculating totals for the +link{listGrid.showGridSummary,grid summary}.
// @visibility external
//<
includeInSummaryProperty:"includeInSummary",

//> @attr listGridRecord.includeInSummary (boolean : null : IRW)
// If specified as false this record should be ignored when calculating summary totals
// to be shown in the +link{listGrid.showGridSummary,summary row} for this grid.
// <P>
// Note that <code>includeInSummary</code> is the default property name for this attribute,
// but it may be modified via +link{listGrid.includeInSummaryProperty}.
// @visibility external
//<


//> @attr listGrid.gridSummaryRecordProperty (string : "isGridSummary" : IRW)
// If +link{listGrid.showGridSummary} is true, this attribute will be set to true on the
// record object representing the grid summary row.
// @visibility external
//<
gridSummaryRecordProperty:"isGridSummary",

//> @attr listGridRecord.isGridSummary (Boolean : null : IRW)
// This attribute will automatically be set to true for the record representing the
// grid-level summary row shown if +link{listGrid.showGridSummary} is true.
// <P>
// Note that <code>isGridSummary</code> is the default property name for this attribute but
// it may be modified by setting +link{listGrid.gridSummaryRecordProperty}
// @visibility external
//<

//> @attr listGrid.groupSummaryRecordProperty (string : "isGroupSummary" : IRW)
// If +link{listGrid.showGroupSummary} is true, this attribute will be set to true on each
// record object representing a group-level summary row.
// @visibility external
//<
groupSummaryRecordProperty:"isGroupSummary",

//> @attr listGridRecord.isGroupSummary (Boolean : null : IRW)
// This attribute will automatically be set to true for records representing
// group-level summary rows shown if +link{listGrid.showGroupSummary} is true.
// <P>
// Note that <code>isGroupSummary</code> is the default property name for this attribute but
// it may be modified by setting +link{listGrid.groupSummaryRecordProperty}
// @visibility external
//<

// recordApplyPluralTitleProperty
// This property may be set to an array of field-names on a record.
// If set, for each field listed, default formatting logic will apply a space, plus the
// plural title for the field (if present, otherwise the standard title).
//
// Has no effect if there is a custom formatter at the grid or field level.
//
// Used to allow us to append the plural title to field values derived from the
// "count" summary function.

recordApplyPluralTitleProperty: "applyPluralTitle",

//> @method listGrid.setShowGridSummary()
// Setter for the +link{listGrid.showGridSummary} attribute
// @param showGridSummary (boolean) new value for this.showGridSummary
// @visibility external
//<
setShowGridSummary : function (showGridSummary) {
    if (this.showGridSummary == showGridSummary) return;
    this.showGridSummary = showGridSummary;
    if (this.showGridSummary) {
        this.showSummaryRow();
    } else {
        this.clearSummaryRow();
    }
},

_getFieldDependencyTable : function () {
    
    if (this._fieldDependencyTable == null) {
        this.Super("_getFieldDependencyTable");

        var fields = this.fields,
            dependencyTable = this._fieldDependencyTable,
            summaryFields = fields.filter(function (field) { return field.type == "summary";});

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i],
                include = field.includeInRecordSummary;
            if (include == true || include != false && 
                (field.type == "integer" || field.type == "float"))
            {
                if (dependencyTable[field.name] == null) {
                    dependencyTable[field.name] = {};
                }
                var localSummaryFields = field.includeInRecordSummaryFields || summaryFields;
                for (var j = 0; j < localSummaryFields.length; j++) {
                    var summaryField = localSummaryFields[j];
                    if (isc.isA.String(summaryField)) {
                        summaryField = this.getField(summaryField);
                    }
                    dependencyTable[field.name][summaryField.name] = summaryField;
                }
            }
        }
    }
    return this._fieldDependencyTable;
},

//> @method listGrid.recalculateSummaries()
// Recalculates values for fields with
// +link{listGridField.recordSummaryFunction, summary-functions} or 
// +link{listGridField.userFormula, user formulae} defined and for values
// displayed in the +link{listGrid.showGridSummary,grid summary} and
// +link{listGrid.showGroupSummary,group summary rows}.
// @param [records] (Array of Record) Optional array of records to recalculate summaries for,
//                  or null for all records
// @param [fields] (Array of ListGridField) Optional array of fields to recalculate summaries
//                 for, or null for all fields
// <P>
// Note that the records should be from +link{listGrid.data}; thus, if the grid is grouped,
//  the records should be from the grouped data rather than +link{listGrid.originalData}.
// @visibility external
//<
recalculateSummaries : function (records, fields, suppressRedraw) {
    suppressRedraw = suppressRedraw != null ? suppressRedraw : true;
    this.calculateRecordSummaries(records, fields, true, true, suppressRedraw);
},

_recalculateSummaries : function (records, fields, calculateGroupRows, calculateSummaryRows, 
                                  redrawSummaryRow) 
{
    if (this.isGrouped          && this.showGroupSummary  && calculateGroupRows != false) {
        this.refreshGroupSummary(records, fields);
    }
    if (this.summaryRow != null && this.showGridSummary && calculateSummaryRows != false) {
        if (redrawSummaryRow && !this.isDirty()) this.markForRedraw();
        this.summaryRow._recalculateSummaries(fields);
    }
    if (this.summaryRow && this.hideEmptySummaryRow) {
        if (this.summaryRow.data && this.summaryRow.data.length > 0) {
            if (!this.summaryRow.isVisible()) {
                this.summaryRow.show();
            }
        } else {
            if (!this.summaryRow.isVisible()) {
                this.summaryRow.show();
            }
        }
    }
},

//> @method listGrid.recalculateGridSummary()
// Refresh the +link{listGrid.showGridSummary,grid summary}, by either re-calculating from
// already-loaded data or doing a new fetch from the +link{summaryRowDataSource}.
// <P>
// Note unlike +link{listGrid.recalculateSummaries()}, this method will not force a refresh of
// field-level summaries (see +link{listGridField.recordSummaryFunction}) or group level
// summaries (see +link{listGrid.showGroupSummary}).
// @visibility external
//<
recalculateGridSummary : function () {
    if (this.showGridSummary && this.summaryRow != null) {
        this.summaryRow._recalculateSummaries();
    }
},

// shouldShowGridSummary() - determines whether a field should show a grid summary
// If field.showGridSummary is specified, respect it, otherwise check for
// the presence of a field level summaryFunction, or a default summaryFunction for the field type
// NOTE: If a developer overrides getGridSummaryData(), this method does not reflect desired
// behavior - we actually want to show the value for all fields for which there are values,
// unless "showGridSummary" was explicitly set to false at the field level.
// (We don't want to check for the presence of a gridSummaryFunction for the field).

shouldShowGridSummary : function (field) {
    if (field.showGridSummary != null) return field.showGridSummary;
    return (field.getGridSummary != null || this.getGridSummaryFunction(field) != null)
},

//> @method listGrid.getGridSummaryFunction() [A]
// Determines the +link{type:SummaryFunction} to use when calculating per-field summary values
// describing multiple records in this grid.
// Used to determine the summary function to use for both +link{listGrid.showGridSummary} and
// +link{listGrid.showGroupSummary}.
// <P>
// Default implementation picks up +link{listGridField.summaryFunction} if explicitly specified,
// otherwise checks for a default summary function based on field type (see
// +link{SimpleType.setDefaultSummaryFunction()})
// @param field (listGridField) field to check for summary function
// @return (SummaryFunction) summary function for the field in question
// @visibility external
//<

getGridSummaryFunction : function (field) {
    if (!field) return;
    // If an explicit summaryFunction is specified, pick it up.
    // Otherwise pick up the default based on the field type.
    var summaryFunction = field.summaryFunction ||
                           isc.SimpleType.getDefaultSummaryFunction(field.type);

    return summaryFunction;
},

//> @method listGrid.getGridSummary() [A]
// When +link{listGrid.showGridSummary} is <code>true</code> this method is called for each field
// which will show a grid summary value (as described in +link{ListGridField.showGridSummary})
// to get the summary value to display below the relevant column.
// <P>
// The default implementation is as follows:
// <ul><li>If this is a databound grid and not all data is loaded, returns null for every field</li>
//     <li>Otherwise if +link{ListGridField.getGridSummary()} is defined, calls that method passing
//         in the current data set for the grid</li>
//     <li>If +link{ListGridField.getGridSummary()} is undefined, makes use of the
//          +link{listGrid.getGridSummaryFunction(),standard summary function} for the field to
//          calculate the summary based on the current data set</li>
// </ul>
// This method may return an array of values. This implies that the grid summary should show
// multiple rows. Note that if a field has more than one summaryFunction specified, this method
// will pick up values from each summary function and return them in an array, meaning
// these summaries will show up on multiple rows in the grid.
// <P>
// This method may be overridden to completely customize the summary value displayed for
// columns in this grid. An example use case would be when summary information is available on
// the client and does not need to be calculated directly from the data.
// <P>
// <b>Note:</b> this method will not be called if +link{listGrid.summaryRowDataSource} is
// specified.
//
// @param field (ListGridField) field for which the summary value should be returned
// @return (any) summary value to display for the specified field.
// @visibility external
//<
getGridSummary : function (field) {

    if (!field || !this.data || (isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown()))
        return;
    var data = this.getOriginalData(),
        isRS = isc.ResultSet && isc.isA.ResultSet(data),
        isTree = isc.isA.Tree(data);

    if (isTree) {
        data = data.getDescendants(data.getRoot());
        isRS = isc.ResultSet && isc.isA.ResultSet(data);
    }

    if (isRS && !data.allMatchingRowsCached()) {
        this.logWarn("Unable to show summary values - dataset not completely loaded");
        return;
    }

    var localData = isRS ? data.getRange(0, data.getLength()) : data;

    // If we have outstanding / unsaved edits, we want to use those in our calculations
    var editRows = this.getAllEditRows();
    if (editRows != null && editRows.length > 0) {
        // ensure we don't stomp on our live data array!
        localData = localData.duplicate();
        
        for (var i = 0; i < localData.length; i++) {
            var record = localData[i];
            var rowNum = this.getEditSessionRowNum(record);
            if (rowNum != null) localData[i] = this.getEditedRecord(rowNum, null, true);
        }
    }

    // getGridSummary() is an override point on a listGridField which allows the developer to
    // calculate a grid summary based on the group summaries already calculated for the grid.
    // It takes an additional param -- an array of 'groupSummary' objects.
    // groupSummary contains
    // - groupName and groupValue to identify which group it belongs to
    // - for each field in the grid, the summary value for the records in the group.
    
    if (field.getGridSummary) {
        var groupSummaries;
        if (this.isGrouped && this.showGroupSummary && (this.groupTree != null)) {
            groupSummaries = this.assembleGroupSummaries();
        }
        return field.getGridSummary(localData, field, groupSummaries);
    }

    return this.getSummaryValue(localData, field);
},

//> @attr listGrid.summaryRowDataSource (DataSource : null : IRA)
// If +link{listGrid.showGridSummary} is true, by default summary values are calculated on the
// client based on the current data-set for the grid (see +link{ListGrid.getGridSummary()} and
// +link{ListGrid.getGridSummaryFunction()}).
// <P>
// In some cases however it may make sense to calculate summary values on the server and retrieve
// them via a dataSource fetch. If set, this property specifies a dataSource to fetch against for
// the summary row. The dataSource should return a single record with summary data for each
// field for which summary data should be shown. Note that specifying this property completely
// bypasses the standard client-side grid summary calculation logic.
// <P>
// The fetch may be further customized via +link{listGrid.summaryRowCriteria} and
// +link{listGrid.summaryRowFetchRequestProperties}
// @visibility external
//<
// summaryRowDataSource:null,
getSummaryRowDataSource : function () {
    return this.summaryRowDataSource;
},

//> @attr listGrid.summaryRowCriteria (Criteria : null : IRWA)
// If +link{listGrid.showGridSummary} is true, and a +link{listGrid.summaryRowDataSource} is specified
// this property may be used to specify fetch criteria to apply when retrieving summary data
// to show in the summary row. If unset, and any filter criteria have been specified for the
// grid, they will be used.
// @visibility external
//<
// summaryRowCriteria:null,
getSummaryRowCriteria : function () {
    if (this.summaryRowCriteria != null) return this.summaryRowCriteria;
    var data = this.getOriginalData();
    if (isc.ResultSet && isc.isA.ResultSet(data)) {
        return this.data.getCriteria();
    }
    return this.getInitialCriteria();
},

//> @attr listGrid.summaryRowFetchRequestProperties (DSRequest Properties : null : IRWA)
// If +link{listGrid.showGridSummary} is true, and a +link{listGrid.summaryRowDataSource} is specified
// this property may be used to customize the fetch request used when retrieving summary data
// to show in the summary row. An example use case might be specifying a
// +link{DSRequest.operationId} to perform a custom fetch operation which retrieved only summary
// values based on criteria.
//
// @visibility external
//<
//summaryRowFetchRequestProperties:null,
getSummaryRowFetchRequestConfig : function () {
    return isc.addProperties(
                    {textMatchStyle:this.autoFetchTextMatchStyle,
                     showPrompt:false,
                     startRow:0, endRow:1},
                    this.summaryRowFetchRequestDefaults,
                    this.summaryRowFetchRequestProperties);
},

summaryRowFetchComplete : function (response, data, request) {

    this.updateFieldWidthsForAutoFitValue("gridSummary fetch complete");
    
    this._updateFieldWidths();

},

//> @method listGrid.getGridSummaryData()
// This method returns the data <smartclient>to be</smartclient> displayed in the 
// +link{summaryRow} when +link{showGridSummary} is true.
// <P>
// By default this will call +link{getGridSummary} for each field and generate an array of records
// containing the resulting values.
// <P>
// This method <smartclient>may be overridden for custom grid-summary display, and</smartclient> 
// may return multiple records if more than one summary row is desired.
//
// @return (Array of ListGridRecord) summary record(s)
// @visibility external
//<
getGridSummaryData : function (recalculate, fields) {

    if (this._gridSummaryData && !recalculate) return this._gridSummaryData;

    
    var data;
    if (this._gridSummaryData && fields != null) {
        data = this._gridSummaryData;
    } else {
        fields = this.skipHiddenGridSummaryFields ? this.fields : this.getAllFields();
        data = [];
        if (fields == null) return data;
    }
    
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            fieldName = fields[i].name;
        if (!this.shouldShowGridSummary(field)) {
             continue;
         }

        var values = this.getGridSummary(field),
            summaryFunc = this.getGridSummaryFunction(field);
        if (!isc.isAn.Array(summaryFunc)) summaryFunc = [summaryFunc];
        // getGridSummary returns either an atomic value or an array. If an array is returned
        // we map this to multiple records - this is how multiple summary functions give us
        // a multi-line result in the grid-summary.
        
        if (!isc.isAn.Array(values)) {
            values = [values]
        }
        for (var ii = 0; ii < values.length; ii++) {
            if (data[ii] == null) {
                data[ii] = {};
                // This property is used to allow summary fields to suspend the standard
                // summary from data in this record [so a standard 'grid summary' type sum etc can
                // be performed against the live grid data].
                data[ii][this.gridSummaryRecordProperty] = true;
                // this prevents the checkbox select column from showing a checkbox
                // for the summary row
                
                data[ii][this.recordCanSelectProperty] = false;

                // If this record came from a "count" summary function, set the
                // recordApplyPluralTitleProperty flag on the record.
                
                if (summaryFunc[ii] == "count") {
                    var array = data[ii][this.recordApplyPluralTitleProperty] || [];
                    array.add(fieldName);
                    data[ii][this.recordApplyPluralTitleProperty] = array;
                }

            }
            data[ii][fieldName] = values[ii];
        }
    }
    this._gridSummaryData = data;
    return data;
},

//> @method listGrid.getGroupSummaryData()
// If this grid is +link{listGrid.groupByField,grouped}, and +link{showGroupSummary} is true,
// this method will <smartclient>be called for each group to</smartclient> return the
//  group summary data <smartclient>to display</smartclient><smartgwt>displayed</smartgwt>
//  at the end of the group.
// <P><smartclient>
// By default this will call +link{listGridField.getGroupSummary} if defined for each field and
// generate an array of records containing the resulting values. If no explicit per-field
// getGroupSummary method is present, this method will fall back to calling the appropriate
// +link{listGridField.summaryFunction}.
// <P></smartclient>
// This method may <smartclient>be overridden for custom group-summary display, and
// may</smartclient> return multiple records if more than one summary row per group is desired.
//
// @param records (Array of Record) the records in the group, for which the summary values
//                                  are being calculated
// @param groupNode (Record) object with specified groupValue and groupName for this group
//
// @return (Array of ListGridRecord) summary record(s)
// @visibility external
//<

getGroupSummaryData : function (records, groupNode, fields) {
    return this._getGroupSummaryData(
        this.includeInSummaryProperty, this.applyFormulaAfterSummary,
        this.groupSummaryRecordProperty, null, records, groupNode, fields);
},
_getGroupSummaryData : function (
    includeInSummaryProperty, applyFormulaAfterSummary, groupSummaryRecordProperty,
    fieldsHaveUserFormulas, records, groupNode, fields)
{
    // If `getGroupSummaryData()` is overridden by the user then we have to call it.
    if (this.getGroupSummaryData != isc.ListGrid.getInstanceProperty("getGroupSummaryData")) {
        return this.getGroupSummaryData(records, groupNode, fields);
    }

    var summaryData;
    if (groupNode && groupNode._groupSummaryData && fields != null) {
        summaryData = groupNode._groupSummaryData;
    } else {
        fields = this.skipHiddenGroupSummaryFields ? this.fields : this.getAllFields();
        summaryData = [];
        if (fields == null) return summaryData;
    }

    for (var i = 0; i < fields.getLength(); i++) {
        var field = fields[i],
            fieldName = field.name,
            summaryValue;
        if (this.shouldShowGroupSummary(field)) {
            var fieldHasUserFormula = (
                    fieldsHaveUserFormulas == null ?
                        (field && field.userFormula != null) :
                        fieldsHaveUserFormulas[i]);
            summaryValue = this._getGroupSummary(
                includeInSummaryProperty, applyFormulaAfterSummary, fieldHasUserFormula,
                records, field, groupNode);

            // handle being passed an atomic value or an array. If an array
            // is returned we show multiple summary rows.
            if (!isc.isAn.Array(summaryValue)) summaryValue = [summaryValue];

            var summaryFunc = this.getGridSummaryFunction(field);
            if (!isc.isAn.Array(summaryFunc)) summaryFunc = [summaryFunc];

            for (var ii = 0; ii < summaryValue.length; ii++) {
                var summaryRecord = summaryData[ii];
                if (summaryRecord == null) {
                    summaryRecord = summaryData[ii] = {};

                    summaryRecord.customStyle = this.groupSummaryStyle;
                    // mark as disabled so we don't respond to clicks / attempts to select etc.
                    // should have no effect on styling since customStyle is static
                    summaryRecord[this.recordEnabledProperty] = false;
                    // don't include this record in the overall grid summary row!
                    summaryRecord[includeInSummaryProperty] = false;

                    // flag the record as a groupSummary record
                    // This allows custom record summary functions to treat it
                    // differently if necessary
                    summaryRecord[groupSummaryRecordProperty] = true;

                    // If this record came from a "count" summary function, set the
                    // recordApplyPluralTitleProperty flag on the record.
                    
                    if (summaryFunc[ii] == "count") {
                        var array = summaryRecord[this.recordApplyPluralTitleProperty] || [];
                        array.add(fieldName);
                        summaryRecord[this.recordApplyPluralTitleProperty] = array;
                    }
                }
                var currentVal = summaryValue[ii];
                summaryRecord[fieldName] = currentVal;
            }
        }
    }
    if (groupNode) groupNode._groupSummaryData = summaryData;
    return summaryData;
},

//> @object GroupSummary
// Group Summary.
//
// @treeLocation Client Reference/Grids/ListGrid
//@visibility external
//<

//> @attr groupSummary.groupName        (string : null : IRW)
//<
//> @attr groupSummary.groupValue       (string : null : IRW)
//<
//> @attr groupSummary.customStyle      (string : null : IRW)
//<

// This method is called to put together the group level summary values and pass them
// to the getGridSummary method, so developers can look at the summaries, rather than
// necessarily calculating grid summaries based on every data record.
assembleGroupSummaries : function (node, summaries) {
    var tree = this.groupTree;
    if (!node) node = tree.getRoot();
    if (!summaries) summaries = [];

    var folders = tree.getFolders(node);
    for (var i = 0; i < folders.length; i++) {
        var headerNode = folders[i];

        if (this.groupByFieldSummaries == null ||
            this.groupByFieldSummaries.contains(headerNode.groupName))
        {

            var summaryRecords = tree.combineWithEditVals(tree.getRecordsInGroup(headerNode));
            var summaryData = this.getGroupSummaryData(summaryRecords, headerNode);

            for (var ii = 0; ii < summaryData.length; ii++) {
                var groupSummary = isc.addProperties({},summaryData[ii]);
                delete groupSummary.customStyle;
                delete groupSummary[this.recordEnabledProperty];
                delete groupSummary[this.includeInSummaryProperty];
                groupSummary.groupName = headerNode.groupName;
                groupSummary.groupValue = headerNode.groupValue;

                summaries.add(groupSummary);
            }
        }

        // make this recursive
        this.assembleGroupSummaries(folders[i], summaries);
    }
    return summaries;

},

// getSummaryValue() - generic handler to take a bunch of records and a field definition and
// return the summary value from them. Used for both grid level summaries and group-level summaries
getSummaryValue : function (records, field) {
    return this._getSummaryValue(
        this.includeInSummaryProperty, this.applyFormulaAfterSummary,
        (field && field.userFormula != null), records, field);
},
_getSummaryValue : function (
    includeInSummaryProperty, applyFormulaAfterSummary, fieldHasUserFormula, records, field)
{
    if (records == null) return null;
    
    // pull out any records where includeInSummary is false
    var includedRecords = [];
    for (var i = 0; i < records.length; i++) {
        var record = records[i];
        if (!record || (record[includeInSummaryProperty] == false)) continue;
        includedRecords[includedRecords.length] = record;
    }

    var summaryFunction = this.getGridSummaryFunction(field);
    if (summaryFunction == null) return null;

    
    if (this._shouldApplyUserFormulaAfterSummary(
            applyFormulaAfterSummary, fieldHasUserFormula, field))
    {
        return [];
    }

    if (!isc.isAn.Array(summaryFunction)) {
        summaryFunction = [summaryFunction]
    }
    var results = [];
    for (var i = 0; i < summaryFunction.length; i++) {

        var currentFunction = summaryFunction[i];
        if (currentFunction != null) {
            
            results[i] = isc.SimpleType.applySummaryFunction(includedRecords, field, 
                                                             currentFunction, this, this);
        }
    }
    return results;
},


shouldShowGroupSummary : function (field) {
    if (field.showGroupSummary != null) return field.showGroupSummary;
    return (field.getGroupSummary != null || this.getGridSummaryFunction(field) != null)
},


getGroupSummary : function (records, field, groupNode) {
    return this._getGroupSummary(
        this.includeInSummaryProperty, this.applyFormulaAfterSummary,
        (field && field.userFormula != null), records, field, groupNode);
},
_getGroupSummary : function (
    includeInSummaryProperty, applyFormulaAfterSummary, fieldHasUserFormula, records, field, groupNode)
{
    var summaryValue;
    if (field.getGroupSummary != null) {
        summaryValue = field.getGroupSummary(records, field, groupNode);
    } else {
        summaryValue = this._getSummaryValue(
            includeInSummaryProperty, applyFormulaAfterSummary, fieldHasUserFormula,
            records, field);
    }
    return summaryValue;
},

//> @method listGrid.getRecordSummary() [A]
// Provides access to the summary (see +link{listGridFieldType,summary-type} fields)
// value of the record for other fields when called from inside the body of
// +link{listGridField.getRecordSummary()} (since they're not available directly off
// the record).  The behavior is unspecified if not called from inside the
// +link{listGridField.getRecordSummary()} method.
// <P>
// @param record (ListGridRecord) record for which a summary is being generated
// @param field (ListGridField | int | ID) field, or its number or id
// @return (any) summary value to display
// @visibility external
//<

getRecordSummary : function (recordNum, summaryField) {
    // allow the summary-type field to be specified by field position or name
    if (!isc.isAn.Object(summaryField)) summaryField = this.getField(summaryField);
    return this._getRecordSummary(null, null, recordNum, summaryField);
},
_getRecordSummary : function (fieldsHaveUserFormulas, fieldsHaveUserSummaries, recordNum, summaryField) {
    // we want to use edit vals when calculating totals
    var record = isc.isAn.Object(recordNum) ? recordNum : this.getEditedRecord(recordNum);

    // override point for a completely custom method based on the record without looking at other
    // fields, etc
    if (summaryField.getRecordSummary != null) {
        return summaryField.getRecordSummary(record, summaryField, this);
    }

    var fieldsToInclude = [],
        fields = this.fields;

    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];

        // should a field be included in this summary calculation?

        // Never include a field in its own calculation!
        if (field.name == summaryField.name) {
            // partial summary - only include fields up to this one (index < this field's index)
            if (summaryField.partialSummary) break;
            continue;
        }

        var shouldInclude = field.includeInRecordSummary;

        // If 'includeInRecordSummary' is unset, default to including numeric non summary fields
        
        var hasUserFormula = (
                fieldsHaveUserFormulas == null ?
                    (field && field.userFormula != null) : fieldsHaveUserFormulas[i]),
            hasUserSummary = (
                fieldsHaveUserSummaries == null ?
                    (field && field.userSummary != null) : fieldsHaveUserSummaries[i]);
        if (shouldInclude == null && (field.type == "integer" || field.type == "float")
            
            && (!hasUserFormula && !hasUserSummary))
        {
            shouldInclude = true;
        }

        // if 'includeInRecordSummaryFields' is explicitly set, respect it as well
        if (shouldInclude && field.includeInRecordSummaryFields != null) {
            if ((isc.isA.String(field.includeInRecordSummaryFields) &&
                     field.includeInRecordSummaryFields != summaryField.name) ||
                (isc.isAn.Array(field.includeInRecordSummaryFields) &&
                     !field.includeInRecordSummaryFields.contains(summaryField.name)))
            {
                shouldInclude = false;
            }
        }
        if (shouldInclude) {
            fieldsToInclude.add(field);
        }
    }
    var summaryFunction = summaryField.recordSummaryFunction || "sum";
    var value = isc.DataSource.applyRecordSummaryFunction(summaryFunction, record,
                                            fieldsToInclude, summaryField);
    return value;
},

// Summary fields are tricky: If we have a summary field which is also showing
// a group or grid level summary, it needs the summary value available on each
// record passed in so it can do calculations like "sum"
// Recalculate these summaries and hang them on the objects now

_$summary:"summary",
shouldApplyRecordSummaryToRecord : function (field) {
    return field && (field.type == this._$summary) &&
            (field.summaryFunction != null || field.getGroupSummary != null);
},

// Handle formula fields the same way we handle summary fields with the added wrinkle
// that the developer can allow formula functions to apply across summary rows
shouldApplyUserFormulaBeforeSummary : function (field) {
    return field && field.userFormula != null && !this._applyFieldFormulaAfterSummary(field);
},
shouldApplyUserFormulaAfterSummary : function (field) {
    return this._shouldApplyUserFormulaAfterSummary(
        this.applyFormulaAfterSummary, (field && field.userFormula != null), field);
},
_shouldApplyUserFormulaAfterSummary : function (applyFormulaAfterSummary, fieldHasUserFormula, field) {
    return (
        fieldHasUserFormula &&
        this.__applyFieldFormulaAfterSummary(applyFormulaAfterSummary, field));
},


calculateRecordSummaries : function (records, fields, updateGroupSummaries, 
    updateGridSummaries, suppressDisplay, suppressApplyToRecords, keepUserCache)
{
    var fieldsToUpdate = this.skipHiddenUserSummaryFields ? this.fields : this.getAllFields();

    if (fields != null) {
        var grid = this;
        if (!isc.isAn.Array(fields)) fields = [fields];

        // translate field names to fields
        fields = fields.map(function (field) { 
            return isc.isA.String(field) ? grid.getField(field) : field;
        });
        // expand to all dependent fields if configured
        if (this.refreshDependentFieldsForSummaries) {
            fields = this._addDependentUserFields(fields);
        }
        fieldsToUpdate = fields;
    }

    // clear cache for specified records/fields to ensure recalculation
    if (!keepUserCache) this.invalidateUserCache(records, fields);

    // nothing to do if there are no fields to update
    if (!fieldsToUpdate) return;

    if (records != null && !isc.isAn.Array(records)) records = [records];
    var recordsToUpdate = records == null ? this.getOriginalData() : records;
    if (recordsToUpdate == null || 
        isc.isA.ResultSet(recordsToUpdate) && !recordsToUpdate.lengthIsKnown())
    {
        return;
    }

    var valuesChanged = false;

    if (!suppressApplyToRecords) {
        var summaryFields     = [],
            userFormulaFields = [];

        for (var i = 0; i < fieldsToUpdate.length; i++) {
            var field = fieldsToUpdate[i];
            if        (this.shouldApplyRecordSummaryToRecord   (field)) {
                summaryFields.add(field);
            } else if (this.shouldApplyUserFormulaBeforeSummary(field)) {
                userFormulaFields.add(field);
            }
        }

        if (summaryFields.length > 0 || userFormulaFields.length > 0) {
            for (var i = 0; i < recordsToUpdate.getLength(); i++) {

                var record =          isc.isA.ResultSet (recordsToUpdate) || 
                    isc.ResultTree && isc.isA.ResultTree(recordsToUpdate) ? 
                    recordsToUpdate.getCachedRow(i) : recordsToUpdate.get(i);
                if (record == null) continue;

                var editVals = this.getEditValues(record),
                    hasEditVals = !isc.isAn.emptyObject(editVals),
                    editedRecord = hasEditVals ? isc.addProperties({_noCache: true}, record,
                                                                   editVals) : record;
                if (record == null) continue;
                
                for (var ii = 0; ii < summaryFields.length; ii++) {

                    var field = summaryFields[ii];

                    // Verify that we actually want to show a record summary value in
                    // this cell.
                    // This method will return false for the case where this is a summary row
                    // and we want to (for example) sum the calculated record summary shown in
                    // this column for all rows in the grid, rather than trying to perform
                    // record-summary arithmetic on the summary row itself.
                    if (!this.shouldShowRecordSummary(field, record)) {
                        continue;
                    }

                    var oldValue = record[field.name];

                    var summaryVal = this.getRecordSummary(editedRecord,field);
                    record[field.name] = summaryVal;

                    if (!this.fieldValuesAreEqual(field, oldValue, summaryVal)) {
                        valuesChanged = true;
                    }
                }
                for (var ii = 0; ii < userFormulaFields.length; ii++) {

                    var field = userFormulaFields[ii];
                    // Skip records where we suppress the formula (EG group summary rows)
                    if (!this.shouldShowUserFormula(field,record)) {
                        continue;
                    }

                    var oldValue = record[field.name],
                        newValue = this.getFormulaFieldValue(field, editedRecord);

                    if (!this.fieldValuesAreEqual(field, oldValue, newValue)) {
                        
                        if (hasEditVals) {
                            this.invalidateUserCache(record, [field]);
                            record[field.name] = newValue;
                        }
                        valuesChanged = true;
                    }
                }
            }
        }
    }

    // if we're showing neither group nor grid summaries we can bail here since the
    // remaining code below is strictly dealing with group and grid summary rows.
    if ((!this.isGrouped         || !this.showGroupSummary) && 
        (this.summaryRow == null || !this.showGridSummary))
    {
        return;
    }

    
    this._recalculateSummaries(records, fields,
        updateGroupSummaries != null ? updateGroupSummaries : valuesChanged,
        updateGridSummaries  != null ? updateGridSummaries  : valuesChanged, !suppressDisplay);
},


// Standard field level summary functions.
// These allow a developer to specify a field of type "summary" with summaryFunction "sum" rather
// than re-implementing the sum method on their field.
// It's basically the same list as the SimpleType registered summary functions but it
// takes different parameters - A single record and multiple fields rather than vice versa


//> @attr listGrid.recordSummaryBaseStyle (CSSStyleName : "recordSummaryCell" : IRWA)
// If showing any record summary fields (IE: fields of +link{listGridFieldType,type:"summary"}),
// this attribute specifies a custom base style to apply to cells in the summary field
// @visibility external
//<
recordSummaryBaseStyle:"recordSummaryCell",

//> @attr listGrid.summaryRow (AutoChild ListGrid : null : RA)
// Automatically generated ListGrid for displaying grid summary information (see
// +link{listGrid.showGridSummary}).
// <P>
// This component is an +link{type:AutoChild} and as such may be customized via
// <code>listGrid.summaryRowProperties</code> and <code>listGrid.summaryRowDefaults</code>
// @visibility external
//<
summaryRowConstructor:"ListGrid",

summaryRowDefaults:{
    // disable rollOver styling
    showRollOver:false

},


//> @attr listGrid.summaryRowHeight (int : 20 : IR)
// Default height for the +link{listGrid.summaryRow,summary row autoChild}. Note that this
// height is a minimum - the summary row has +link{listGrid.autoFitData} set to "vertical" so
// if multiple rows are visible in the grid summary, the summaryRow component
// will expand to accommodate them.
//
// @visibility external
//<
summaryRowHeight:20,

//> @attr listGrid.summaryRowStyle (CSSStyleName : "gridSummaryCell" : IRWA)
// +link{listGrid.baseStyle} for the +link{listGrid.summaryRow}
// @visibility external
//<
summaryRowStyle:"gridSummaryCell",

//> @attr listGrid.hideEmptySummaryRow (Boolean : null : IRW)
// If true, causes the +link{listGrid.summaryRow,summaryRow} component to be hidden if it has
// no data after summaries have been recalculated
// @visibility external
//<

// creates (or updates) and returns the summaryRow autoChild.
// not called directly -- call 'setShowGridSummary' instead
getSummaryRow : function () {

    if (!this.summaryRow) {

        var dataSource = this.getSummaryRowDataSource();

        var initialFields;
        if (this.completeFields) initialFields = this.completeFields.duplicate();
        else if (this.fields) initialFields = this.fields.duplicate();
        // We respond to setFields(), setFieldWidths(), showField(), hideField() etc explicitly
        // in those methods so don't worry if initialFields is null - it'll get set when required

        var height = this.summaryRowHeight;
        this.summaryRow = this.createAutoChild("summaryRow", {
        
            showEmptyMessage:false,

            warnOnReusedFields:false,
            autoDraw:false,

            width:"100%",
            height:height,
            minHeight: null,

            autoFitData:"vertical",
            // autoFitMaxRows etc can be specified in summaryRowProperties if desired.

            // setting bodyOverflow to hidden.
            // If we don't do this and field widths exceed grid size, we end up with
            // hscrollbars on both the listGrid and the summary row.
            
            
            bodyOverflow:"hidden",

            showHeader:false,

            getBaseStyle:function() {return this.creator.summaryRowStyle},
            alternateRecordStyles:false,

            disabled:this.disabled,
            applyFormulaAfterSummary: this.applyFormulaAfterSummary,

            // Make fetchValueMapData into a no-op. We copy our fields from
            // our creator so any optionDataSources will match up meaning we can rely on
            // the creator's fetchValueMapData / 'setValueMap()' to update our valueMap
            // rather than having to do a second fetch against optionDataSources
            _fetchValueMapData : function () {
            },

            // The default summary functions all return number or string values, even if field.type
            // is boolean. If this method returns true we'll always display a checkbox rather than
            // the expected summary value.
            
            _formatBooleanFieldAsImages : function (field) {
                return false;
            },

            // support for databinding of summary row
            dataSource:dataSource,
            // pick up data from the gridSummaryData method
            data:dataSource == null ? this.getGridSummaryData() : null,

            _recalculateSummaries : function (fields) {
                
                var grid = this.creator,
                    data = grid.data
                ;
                // prevent the summaryRow from fetching before the parent grid - it will fetch
                // again when the parent is ready
                if (!grid.fields || (isc.isA.ResultSet(data) && !data.lengthIsKnown())) return;

                // if we are getting data from a dataSource, simply re-fetch
                if (this.dataSource != null) {
                    var criteria = grid.getSummaryRowCriteria(),
                        forceRefresh = isc.ResultSet && isc.isA.ResultSet(this.data) &&
                                       !this.data.willFetchData(criteria);
                    
                    // Note - if we're dropping cache, do this before the fetchData call so our
                    // callback fires!
                    if (forceRefresh) this.invalidateCache();
                    this.fetchData(
                        criteria,
                        {target:grid, methodName:"summaryRowFetchComplete"},
                        grid.getSummaryRowFetchRequestConfig()
                    );
                } else {
                    this.setData(grid.getGridSummaryData(true, fields));
                }
            },

            fieldSourceGrid:this,
            fields:initialFields,

            // Copy formatting related properties across so _formatCellValue
            // behaves correctly
            
            recordApplyPluralTitleProperty:this.recordApplyPluralTitleProperty,
            gridSummaryRecordProperty:this.gridSummaryRecordProperty,
            invalidSummaryValue:this.invalidSummaryValue,
            emptyCellValue:this.emptyCellValue,


            // We size fields according to the main grid field-widths.
            
            skipAutoFitWidths:true,
            getFieldWidths : function () {
                return this.creator.getFieldWidths();
            },

            // We have our fields assigned from the source grid - If 'showIf' is set, evaluate it
            // on the source grid, not on this grid.
            // This ensures that the "list" param passed to that method refers to the correct grid
            
            fieldShouldBeVisible : function (field, fieldNum) {
                return this.fieldSourceGrid.fieldShouldBeVisible(field, fieldNum);
            },

            canEditCell:function () {
                return false;
            },

            // mark the summary row so we can have special handling for like checkboxField, etc
            _isSummaryRow: true
        });

    } else {
        this.summaryRow.setDataSource(this.getSummaryRowDataSource(), this.completeFields.duplicate());
        // recalculateSummaries handles moving and resizing the summary row
        // (It has to, since the number of summary rows displayed may change, changing the
        // height of the summary row grid).
        this.summaryRow._recalculateSummaries();
    }
    return this.summaryRow;
},


showSummaryRow : function () {
    // Refuse to show if the gridComponents array doesn't include the s.row
    var componentIndex = this.gridComponents.indexOf("summaryRow");
    if (componentIndex == -1) {
        this.logWarn("showGridSummary set to true, but gridComponents array does not include an " +
            "entry for the summary row - not showing.");
        return;
    }
    // This will handle creating, or updating the summary row and adding it as a member
    this.updateGridComponents()
    this.syncSummaryRowScrolling(this.body.getScrollLeft(), this.body.getScrollTop);

},

// clearSummaryRow() - clears (but doesn't destroy()) the summaryRow component.
// Developers will call 'setShowGridSummary' rather than calling this method directly
clearSummaryRow : function () {
    if (this.summaryRow && this.summaryRow.parentElement == this) {
        this.removeMember(this.summaryRow);
    }
},

_isSummaryRecord : function (record) {
    return record[this.gridSummaryRecordProperty] || record[this.groupSummaryRecordProperty];
},

// The method +link{listGrid.recalculateSummaries()} is ListGrid specific, so
// we can't apply it in the general case as implemented in DataBoundComponent.
_setUserField : function (field, property, value, updateSummaries, markForRedraw) {
    var grid = this;
    this.Super("_setUserField", [field, property, value,
       function (field) {
           if (updateSummaries) grid.recalculateSummaries(null, field);
           if (markForRedraw)   grid.markForRedraw();
       }
    ]);
},
_setUserFieldText : function (field, property, text, updateSummaries, markForRedraw) {
    var grid = this;
    this.Super("_setUserFieldText", [field, property, text,
       function (field) {
           if (updateSummaries) grid.recalculateSummaries(null, field);
           if (markForRedraw)   grid.markForRedraw();
       }
    ]);
},

//> @method listGrid.setUserFormula()
// Updates the user formula of the supplied field.  This method is preferred over setting the
// the field property directly since it allows any component dependencies to be updated.  If
// the formula is not passed or undefined, it is assumed it has already been updated and only
// the dependency propagation logic will run.<P> Known component dependencies are:<ul>
// <li>the cached record values of the formula for this field
// <li>the common formula variable =&gt; field name map maintained by the component for
// calls to the FormulaBuilder</ul>
// @param field (ListGridField | String) field owning the userFormula
// @param [userFormula] (UserFormula) optional formula to install
// @see listGridField.userFormula
// @visibility external
//<
setUserFormula : function (field, userFormula, updateSummaries, markForRedraw) {
    this._setUserField(field, "userFormula", userFormula, updateSummaries, markForRedraw);
},

//> @method listGrid.setUserSummary()
// Updates the user summary of the supplied field.  This method is preferred over setting the
// field property directly since it allows any component dependencies to be updated.  If the
// summary is not passed or undefined, it is assumed it has already been updated and only the
// dependency propagation logic will run.<P>
// Known component dependencies are:<ul>
// <li>the cached record values of the summary for this field</ul>
// @param field (ListGridField | String) field owning the userSummary
// @param [userSummary] (UserSummary) optional summary to install
// @see listGridField.userSummary
// @visibility external
//<
setUserSummary : function (field, userSummary, updateSummaries, markForRedraw) {
    this._setUserField(field, "userSummary", userSummary, updateSummaries, markForRedraw);
},

//> @method listGrid.setUserFormulaText()
// Updates the user formula text of the supplied field.  This method is preferred over setting
// the text property directly since it allows any component dependencies to be updated.  If the
// formula text is not passed or undefined, it is assumed it has already been updated and only
// the dependency propagation logic will run.<P> Known component dependencies are:<ul>
// <li>the cached record values of the formula for this field</ul>
// @param field (ListGridField | String) field owning the userFormula
// @param [text] (String) optional formula text to install
// @see listGridField.userFormula
// @visibility external
//<
setUserFormulaText : function (field, text, updateSummaries, markForRedraw) {
    this._setUserFieldText(field, "userFormula", text, updateSummaries, markForRedraw);
},

//> @method listGrid.setUserSummaryText()
// Updates the user summary text of the supplied field.  This method is preferred over setting
// the text property directly since it allows any component dependencies to be updated.  If the
// summary text is not passed or undefined, it is assumed it has already been updated and only
// the dependency propagation logic will run.<P> Known component dependencies are:<ul>
// <li>the cached record values of the summary for this field</ul>
// @param field (ListGridField | String) field owning the userSummary
// @param [text] (String) optional summary text to install
// @see listGridField.userSummary
// @visibility external
//<
setUserSummaryText : function (field, text, updateSummaries, markForRedraw) {
    this._setUserFieldText(field, "userSummary", text, updateSummaries, markForRedraw);
},

// --------------------------------------------------------------------------------------------
// Filter editor row
// --------------------------------------------------------------------------------------------

// When 'showFilterEditor' is true on a listGrid, it will be drawn with a RecordEditor used to
// filter the List's data.

//> @method listGrid.setShowFilterEditor()
// Setter for the +link{ListGrid.showFilterEditor} property. Allows the filter editor to be
// shown or hidden at runtime.
// @param value (boolean) true if the filter editor should be shown, false if it should be hidden
// @group filterEditor
// @visibility external
//<
setShowFilterEditor : function (value) {
    // No op is required to avoid potentially setting up duplicate FEs etc.
    if (this.showFilterEditor == value) return;
    this.showFilterEditor = value;

    if (value) {
        var componentIndex = this.gridComponents.indexOf("filterEditor");
        if (componentIndex == -1) {
            value = false;
            this.logWarn("setShowFilterEditor(true) called, but gridComponents array does not " +
                "include the filterEditor. FilterEditor will not be shown.");
        }
    }

    if (value) {
        // if we're already drawn re-run createChildren to build the filterEditor and plug it in
        if (this.isDrawn()) {
            // store the viewState and restore it after updating
            var state = this.getViewState();
            this.updateGridComponents();
            this.setViewState(state);
        }

    // filterEditor may have never been defined if this widget has not yet been drawn
    } else if (this.filterEditor) {
        this.filterEditor.destroy();
        this.filterEditor = null;
    }

    // This will ensure field widths, sizes etc are all correct.
    this.layoutChildren();
},

// makeFilterEditor()
// Create a RecordEditor instance as this.filterEditor.
makeFilterEditor : function () {
    var ds = this.getDataSource();
    if (this.allowFilterOperators == null && ds && ds.supportsAdvancedCriteria()) {
        // if allowFilterOperators is unset, switch it on if the DS supports advancedCriteria
        this.allowFilterOperators = true;
    }
    var filterEditorProps = isc.addProperties({
        autoDraw:false,
        warnOnReusedFields:false,
        reverseRTLAlign:this.reverseRTLAlign,

        
        dataPath:this.dataPath,
        setDataPath : function (dataPath) {
            this.dataPath = dataPath;
        },

        // Pass the dataSource through to the filter editor - this is useful for
        // items which will pick up their options from the DS as an option dataSource
        dataSource:this.dataSource, 
        saveLocally:true,

        // Disable fetchValueMapData on the filterEditor entirely.
        // If we're showing an edit item for the field it'll have an optionDataSource
        // set on it, meaning the selectItem / comboBox etc will be responsible for issuing
        // any fetch request against the ODS if necessary.
        _fetchValueMapData : function () {
        },

        height: this.filterEditorHeight,
        // NOTE: filterEditors handle width sizing themselves

        sourceWidget: this,
        
        ID: this.getID() + "_filterEditor",
        
        // We built this thing ourselves so mark it as generated. Allows the AutoTest subsystem to
        // generate a locator that keeps going up the chain, potentially
        _generated:true,
        locatorParent: this,

        bodyConstructor: "FilterEditorBody",

        // We have our fields assigned from the source grid - If 'showIf' is set, evaluate it
        // on the source grid, not on this grid.
        // This ensures that the "list" param passed to that method refers to the correct grid
        
        fieldShouldBeVisible : function (field, fieldNum) {
            return this.sourceWidget.fieldShouldBeVisible(field, fieldNum);
        },

        // we share field objects with the main grid.
        // This 'fieldSourceGrid' property is used to ensure we do the right thing about
        // generated fields like the selection-checkbox field etc.
        fieldSourceGrid:this,

        actionType:"filter",
        actionButtonPrompt:this.filterButtonPrompt,
        actionButtonProperties:this.filterButtonProperties,

        fetchDelay: this.fetchDelay,

        allowFilterExpressions: this.allowFilterExpressions,
        expressionDataSource: this.getDataSource(),
        
        allowFilterOperators: this.allowFilterOperators,
        
        // When the user hides a field, remember the user-entered criteria for that field
        discardEditsOnHideField: false
        
    }, this.filterEditorDefaults, this.filterEditorProperties);

    if (filterEditorProps.bodyDefaults == null) filterEditorProps.bodyDefaults = {};
    // Ensure if the user tabs into the body we shift focus into the edit form
    // Exception: If this came from a click, we'll already start editing the clicked cell,
    // and a call to startEditing would mess that up and jump focus to the first
    // edit item unexpectedly.
    filterEditorProps.bodyDefaults.focusChanged = function (hasFocus) {
        if (hasFocus && isc.EH.isKeyEvent()) {
            if(this.parentElement.isA("RecordEditor")) {
                this.parentElement.startEditing();
            } else {
                // maybe we are using frozen fields, in that case the RecordEditor is the grandparent
                if(this.parentElement.parentElement.isA("RecordEditor")) {
                    this.parentElement.parentElement.startEditing();
                }
            }
        }
    }

    this.filterEditor = isc.RecordEditor.create(filterEditorProps);

},



//> @method listGrid.getFilterEditorValueMap()  ([A])
//
//  If we're showing the filter (query-by-example) row for this ListGrid, this method is
//  used to determine the valueMap to display in the filter row for this field.
//  Default implementation will return the field.filterEditorValueMap if specified, or
//  field.valueMap.
//
//  @group  filterEditor
//
//  @param  field   (ListGridField)    field definition field for which we need a valueMap
//  @return         (ValueMap)  ValueMap for the edit field (or null if no valueMap required)
//  @visibility external
//<
getFilterEditorValueMap : function (field) {
    return  field.filterEditorValueMap || field.valueMap || 
        (field.filterEditorProperties && field.filterEditorProperties.valueMap);
},

//> @method listGrid.getFilterEditorType()  ([A])
// If we're showing the filter (query-by-example) row for this ListGrid, this method is
// used to determine the type of form item to display in the filter edit row for this field.
// Default implementation will return the field.filterEditorType if specified, or
// the result of +link{DynamicForm.getEditorType, form.getEditorType()} otherwise.
//
// @group filterEditor
//
// @param field (ListGridField) field definition to get the editorType for
// @return (String) the editorType to use in the filterEditor for the passed field
// @visibility external
//<
_$binary:"binary", _$file:"file", _$imageFile:"imageFile",
getFilterEditorType : function (field) {
    // Simple case: support explicit filterEditorType on the field
    if (field.filterEditorType != null) return field.filterEditorType;

    // TODO: re-implement this once RecordEditor correctly returns AdvancedCriteria
    var ds = this.getDataSource();
    if (isc.SimpleType.inheritsFrom(field.type, "date") &&  ds &&
        ds.supportsAdvancedCriteria())
    {
        return "MiniDateRangeItem";
    }

    var type = field.type;
    var isFileType = (type == this._$binary || type == this._$file || 
                        type == this._$imageFile);
                    
    if (isFileType && field.editorType == null) {
        if (field.filenameSuppressed || ds && ds.getFilenameField(field.name) == null) {
            return "StaticTextItem";
        } else {
            return "TextItem";
        }
    }

    // filter editor config is basically picked up from field defaults and explicit
    // field.filterEditorProperties.
    // If a a field specifies an explicit filterEditorType or a filterEditorProperties block with
    // an explicit editor type, respect it.
    // Otherwise if a field specifies an explicit editorType, respect that
    // Otherwise generate the editor type based on data type in the normal way
    // A couple of exceptions:
    // - override canEdit with canFilter, so we don't get a staticTextItem in the field
    
    // - clear out field.length: we don't want to show the long editor type (text area) in our
    //   filter editor
    var filterEditorConfig = isc.addProperties ({}, field,
                                                 {canEdit:field.canFilter !== false,
                                                  length:null});

    // the _constructor property can come from XML -> JS conversion, and matches the
    // XML tag name for the field element.
    // Don't attempt to use this to determine DynamicForm editor type - it's likely to be
    // ListGridField or similar which shouldn't effect the generated form item type.
    if (filterEditorConfig._constructor != null) delete filterEditorConfig._constructor;
    if (field.filterEditorType != null) filterEditorConfig.editorType = field.filterEditorType;
    isc.addProperties(filterEditorConfig, field.filterEditorProperties);
    var type = isc.DynamicForm.getEditorType(filterEditorConfig, this);
    return type;

},

// getFieldFilterEditorProperties - returns a block of properties to apply to the form item displayed
// in the filter row for some field.
getFieldFilterEditorProperties : function (field) {
    var result = field.filterEditorProperties || {};
    if (field.filterOperator) result.operator = field.filterOperator;
    if (this.shouldAllowFilterOperators(field)) {
        isc.addProperties(result, {
            lgField: field,
            init : function () {
                this.Super("init", arguments);
                this._defaultOperator = this.getOperator();
            },
            setCriterion : function (criterion) {
                this.Super("setCriterion", arguments);
                if (this.getOperator() != criterion.operator) {
                    // operator has changed, update the operatorIcon
                    this.grid.sourceWidget.setFieldSearchOperator(field, criterion.operator)
                }
            },
            canEditCriterion : function (criterion) {
                // when allowing custom filter-operators, crit only needs to have the right 
                // fieldName to be considered editable
                if (criterion.fieldName != null && criterion.fieldName == this.getCriteriaFieldName()) {
                    return true;
                }
                return this.Super("canEditCriterion", arguments);
            },
            _getIconTextAlign : function (icon) { return "center"; },
            
            _getInlineLeftPadding : function (style) { return 1; },
            _getInlineRightPadding : function (style) { return 1; },
            showContextMenu : function () {
                if (this.operator && this.operator != this._defaultOperator) return;
                var grid = this.grid.sourceWidget,
                    items = grid.getFilterOperatorMenuItems(this.lgField, true),
                    menu = grid.filterOperatorMenu
                ;
                if (!menu) {
                    menu = grid.filterOperatorMenu = grid.createAutoChild("filterOperatorMenu");
                }
                menu.setItems(items);
                var button = grid.getFieldHeaderButton(grid.getFieldNum(this.lgField));
                menu.placeNear(button.getPageLeft(), button.getPageTop());
                menu.show();
                return false;
            }
        });
        if (!result.icons) result.icons = [];
        var operatorId = result.operator;
        if (!result.icons.getProperty("name").contains("operatorIcon")) {
            result.icons.add(this.getOperatorIcon(field, result.operator));
        }
    }

    var type = field.type;
    var isFileType = (type == this._$binary || type == this._$file || 
                        type == this._$imageFile);
    if (isFileType && !field.filenameSuppressed) {
        var ds = this.getDataSource(),
            fileNameField = ds && ds.getFilenameField(field.name);
        if (fileNameField != null) {
            result.criteriaField = fileNameField;
        }
    }

    return result;
},

// Unexposed but publicly accessible method to get a pointer to the filter editor grid

getFilterEditor : function () {
    return this.filterEditor;
},

//> @method listGrid.setFilterEditorCriteria()
// If +link{listGrid.showFilterEditor} is true, this method will update the criteria shown
// in the <code>filterEditor</code> without performing a filter.
// @param criteria (Criteria or AdvancedCriteria) New criteria to show
// @visibility external
//<
setFilterEditorCriteria : function (criteria) {
    if (this.filterEditor) {
        // Normally we either want setFilterValues to drop all criteria and replace with new
        // ones (programmatic 'filterData()'), or retain all hidden criteria and just
        // sparsely apply specified criteria to visible fields (user interactions with the
        // filter editor).
        // However if 'setFilterEditorCriteria' is called directly we want to clear
        // criteria on fields that have been explicitly hidden by the user, but are
        // present in the grid 'completeFields' definition, 
        // but still retain criteria applied to fields which aren't
        // actually present in the grid at all.
        
        var hasHiddenFields = false,
            hiddenFields = [];
        var editForm = this.filterEditor.getEditForm();
        for (var i = 0; i < this.completeFields.length; i++) {
            var field = this.completeFields[i];
            
            if (this.fieldIsVisible(field,true)) {
                // incremental rendering may cause the field not to be present in our 
                // filter editor edit-form
                // Catch the case where we have the form, but not the item for some
                // (logically) visible field.
                if (!editForm || editForm.getItem(field.name) != null) {
                    continue;
                }
            }
            
            hasHiddenFields = true;
            hiddenFields.add(field.name);
        }
        this.setFilterValues(criteria, hasHiddenFields, hiddenFields);
    }
    // if there is no filterEditor yet, but there will be, store as initialCriteria
    else if (this.showFilterEditor) this.initialCriteria = criteria;
},

//> @method listGrid.getFilterEditorCriteria()
// If +link{listGrid.showFilterEditor} is true, this method will return the criteria currently
// displayed in the <code>filterEditor</code>. Note that these values may differ from the
// criteria returned by +link{listGrid.getCriteria()} if the filter editor values have been modified
// without performing an actual filter.
// @param [omitHiddenFields] (Boolean) By default this method will include criteria applied to
//   fields, including criteria that are not actually visible/editable in the filterEditor for the
//   grid. Pass in this parameter to get only values for visible fields returned.
// @return (Criteria or AdvancedCriteria) criteria currently displayed in the filterEditor
// @visibility external
//<
// Note: we rely on the filterEditor edit form to handle combining specified criteria with criteria
// from live items - as such calling getValuesAsCriteria() on that form will return all specified
// criteria, even for fields not visible in the grid.
// This is not always desired - it can be useful to apply additional criteria outside those
// editable by the user, and in order to repeatedly do this, we need to be able to get back a
// clean copy of *only* the criteria the user has modified. The includeHiddenFields parameter
// allows us to do this.
// - See the DynamicReporting sample for an example of this use-case:
//      isomorphic/system/reference/SmartClient_Explorer.html#dynamicReporting

getFilterEditorCriteria : function (omitHiddenFields) {
    if (this.filterEditor) {
        
        if (!omitHiddenFields || !this.filterEditor.getEditForm()) {
            return this.filterEditor.getValuesAsCriteria(this.autoFetchTextMatchStyle);

        } else {
            var items = this.filterEditor.getEditForm().getItems(),
                simple = true,
                criteria = {},
                advancedCriteria = {_constructor: "AdvancedCriteria",
                    operator:"and", criteria:[]}
            ;
            for (var i = 0; i < items.length; i++) {
                if (items[i].hasAdvancedCriteria()) {
                    var crit = items[i].getCriterion();
                    if (crit != null) {
                        simple = false;
                        advancedCriteria.criteria.add(crit);
                    }
                } else {
                    var value = items[i].getValue();
                    if (value != null) {
                        criteria[items[i].getCriteriaFieldName()] = value;
                    }
                }
            }
            if (!simple) {
                criteria = isc.DataSource.combineCriteria(criteria, advancedCriteria);
            }
            return criteria;
        }
    }
},

// Default setCriteria implementation will no-op if we have no data (and won't update the
// filterEditor even if we do have data) - override to ensure the FE reflects the new criteria
setCriteria : function (criteria) {
    if (this.filterEditor != null) {
        this.setFilterValues(criteria, true);
    }
    // If grouped we need to apply criteria to underlying ResultSet    
    var data = this.isGrouped ? this.getOriginalData() : this.data;
    if (data) {
        // if setCriteria() exists (ResultSet) call it
        if (data.setCriteria) data.setCriteria(criteria);
        else {
            // data is an array - store the criteria 
            this.initialCriteria = criteria;
            // if filterLocalData is true, pass the criteria to filterData()
            if (this.filterLocalData) this.filterData(criteria);
        }
    // if there is no data yet, set initial criteria to parameter criteria
    } else this.initialCriteria = criteria;

    this.dataSetChanged();
},
    
// setFilterValues() - helper method called when this widgets filter criteria change.
// Will store the criteria locally and call the method to update the filter editor values.
// dropExtraCriteria is passed on to filterEditor.setValuesAsCriteria() and causes it to
// drop any criteria that apply to fields which can't be edited
// The explicit fields passed in as dropCriteriaFields allows us to retain 
// values for fields which aren't defined in the grid at all, but still clear values for
// fields which are defined but hidden (so aren't represented in the edit form)
// This matches the use case of a user editing a filter value, hiding a field and then
// attempting to clear filter editor values via the clearFilter menu item.
setFilterValues : function (criteria, dropExtraCriteria, dropCriteriaFields) {
    // store this in a local var - this allows us to show and hide the filterEditor independently
    // and know what the current criteria are.
    this._filterValues = isc.addProperties({}, criteria);

    // Update initialization property to match current criteria
    this.initialCriteria = this._filterValues;

    this.updateFilterEditor(dropExtraCriteria, dropCriteriaFields);
},


// update the filter editor's values to match the current filter criteria
// Needs to happen whenever the filter criteria change or the filter editor is shown
updateFilterEditor : function (dropExtraCriteria, dropCriteriaFields) {
    var editor = this.filterEditor;
    if (!editor) return;

    var values = this._getFilterEditorValues();
    this.filterEditor.setValuesAsCriteria(values, true, dropExtraCriteria, dropCriteriaFields);
},


// _getFilterEditorValues returns the values to be shown in our filter editor (doesn't get the
// values FROM our filter editor - see getFilterEditorCriteria() for that).
// Called when the filter editor is first created, and used by updateFilterEditorValues to update
// the filterEditor when it is already showing.
// Note that developers can customize the display value via the 'updateFilterEditorValues()'
// stringMethod
_getFilterEditorValues : function () {
    var currentCriteria = isc.addProperties({}, this._filterValues);

    // Allow for a completely custom display of filterEditorValues by the developer
    if (this.updateFilterEditorValues != null) {
        
        currentCriteria = this.updateFilterEditorValues(currentCriteria, this.autoFetchTextMatchStyle);
    }



    // If we've never performed a filter, use our default filter values. Note that if we
    // explicitly filter with null or empty criteria we do NOT want to reset to defaults -
    // defaults are only used if we've never filtered this datasource. Handled by the fact
    // that setFilterValues() will always store an object, never null.
    if (currentCriteria == null) {
        currentCriteria = {};
        for (var i = 0; i < this.completeFields.length; i++) {
            currentCriteria[this.completeFields[i].name] = this.completeFields[i].defaultFilterValue;
        }
    }

    return currentCriteria;
},


// re-set the filterEditor's values to display the defaultFilterValues.
// This will be called if the defaultFilterValues change (can happen from setFields()) [and
// no filter has yet been performed], or if we change datasources so the current filter gets
// invalidated.

clearFilterValues : function () {
    this._filterValues = null;
    this.updateFilterEditor(true);
},

handleFilterEditorSubmit : function (criteria, context, callback) {
    // notification method fired when the user modifies the criteria in the filter editor
    // and hits the filter button / enter key.
    if (this.filterEditorSubmit != null && this.filterEditorSubmit(criteria) == false) return;
    this.filterData(criteria, callback, context);
},


// If we're doing an auto-fetch, apply each field's defaultFilterValue to the initialCriteria object
getInitialCriteria : function () {
    var initialCriteria = {},
        hasInitialFieldValue,
        fields = this.getFields(),
        undef;
    for (var i = 0; i < fields.length; i++) {
        if (fields[i].defaultFilterValue !== undef) {
            hasInitialFieldValue = true;
            var fieldName = this.getFieldName(fields[i]);
            initialCriteria[fieldName] = fields[i].defaultFilterValue;
        }
    }

    // allow explicitly specified initialCriteria to override the field level defaultFilterValues
    if (!hasInitialFieldValue) {
        initialCriteria = this.initialCriteria || this.getCriteria(true);
    } else {
        isc.addProperties(initialCriteria, this.initialCriteria || this.getCriteria(true));
    }
    
    if (this.implicitCriteria) {
        //initialCriteria = isc.DS.combineCriteria(initialCriteria, this.getImplicitCriteria());
    }
    
    return initialCriteria;
},


// Treat the filterEditor as a "special" peer -- keep it next to us in the page's z-order
_adjustSpecialPeers : function (newIndex) {
    if (this.filterEditor != null) this.filterEditor.setZIndex(newIndex-1);
    return this.Super("_adjustSpecialPeers", arguments);
},

//> @attr listGrid.allowFilterExpressions (boolean : null : IR)
// For use with +link{showFilterEditor}:true, allows simple search expressions to be entered
// into filter fields, as though +link{dynamicForm.allowExpressions} were true.
// <P>
// Can also be enabled or disabled on a field-by-field basis via
// +link{listGridField.filterEditorProperties}.
//
// @group advancedFilter
// @visibility external
//<


// --------------------------------------------------------------------------------------------
// Inline Editing
// --------------------------------------------------------------------------------------------



// Editing kickoff
// --------------------------------------------------------------------------------------------

//> @attr listGrid.canEditFieldAttribute (string : "canEdit" : IRA)
// @include dataBoundComponent.canEditFieldAttribute
// @visibility external
//<

//> @method listGrid.canEditCell() (A)
// Can this cell be edited?
// <P>
// The default implementation of <code>canEditCell()</code> respects the various property
// settings affecting editability:
// <ul><li>+link{listGridField.canEdit,field.canEdit} can be set to disable editing
//          for a field</li>
//     <li>If the grid is bound to a dataSource, the +link{listGrid.canEditFieldAttribute} value on the
//         dataSource field may enable / disable editing</li>
//     <li>a record with the +link{listGrid.recordEditProperty,recordEditProperty} set to
//         false is not editable</li>
//     <li>disabled records are not editable</li>
// </ul>
// You can override this method to control editability on a cell-by-cell basis.  For example,
// if you had a grid that allows editing of "orders", and you had a field "shipDate" that is
// normally editable, but should not be editable if the order is already "complete", you might
// implement <code>canEditCell()</code> as follows:
// <P>
// <smartclient><pre>
//   isc.ListGrid.create({
//       ...
//       canEditCell : function (rowNum, colNum) {
//           var record = this.getRecord(rowNum),
//               fieldName = this.getFieldName(colNum);
//           if (fieldName == "shipDate" &&
//               record.orderStatus == "complete")
//           {
//               return false;
//           }
//           // use default rules for all other fields
//           return this.Super("canEditCell", arguments);
//       }
//   });
// </pre></smartclient>
// <smartgwt><pre>
//    public boolean canEditCell(int rowNum, int colNum) {
//      Record record = this.getRecord(rowNum);
//      String fieldName = this.getFieldName(colNum);
//      if (fieldName.equals("shipDate") && record.getAttribute("orderStatus").equals("complete") {
//        return false;
//      }
//      // use default rules for all other fields
//      return super.canEditCell(rowNum, colNum);
//    };
// </pre></smartgwt>    
// <P>
// Notes on providing custom implementations:
// <ul>
// <li> In order to allow complete control over editing, <code>canEditCell()</code> is called
// very frequently.  If you see delays on row to row navigation, check that your implementation
// is efficient
// <li> If you change the editability of a cell on the fly, for example, during
// +link{editorExit()} on another cell, call refreshCell() to show or hide the editor
// <li> If this ListGrid allows new records to be created, <code>canEditCell()</code> may be
// called when there is no record available, in which case getRecord() will return null.  The
// values input so far by the user are available via +link{getEditValues()}.
// </ul>
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
//
// @param rowNum (number) row number for the cell
// @param colNum (number) column number of the cell
// @return (boolean) Whether to allow editing this cell
//
// @group editing
// @visibility external
//<
canEditCell : function (rowNum, colNum) {
    // just return if passed bad colNum
    if (colNum < 0 || colNum >= this.fields.length) return false;

    if (this.allowRowSpanning && this.rowSpanEditMode == "first") {
        // Disallow edit of the cell if it's a spanning cell and the user is
        // attempting to edit something other than the first row in the cell
        var startRow = this.getCellStartRow(rowNum, colNum);
        if (startRow != rowNum) {
            return false;
        }
    }

    var cellRecord = this.getCellRecord(rowNum, colNum);
    // Note - we may have no cellRecord - this will occur if we're editing a new row
    if (cellRecord != null) {
        if (!this.recordIsEnabled(cellRecord, rowNum, colNum)) return false;

        // Suppress editing if we're showing an embedded editor or detailGrid for this row
        if (this._openRecord == cellRecord) return false;
    }

    // If the field is explicitly marked as disabled, disallow editing
    
    var field = this.getField(colNum);
    if (field && field.disabled) return false;

    if (field && field.type == "summary") return false;

    // otherwise check the cascaded canEdit property
    if (
        // Note: the isEditable() check is required as 'getCellBooleanProperty' will not return
        // false if the record's "_canEdit" property is set to 'true', but canEdit is unset at
        // the field and listGrid level, and we don't allow editing cells when canEdit is
        // not set at both the listGrid and field level.
        !this.isEditable() ||
        this.getCellBooleanProperty(
                "canEdit",
                rowNum,
                colNum,
                (cellRecord != null ? this.recordEditProperty : null)
        ) == false
    ) {
        return false;
    }

    // Disallow editing of formula fields by default
    if ((field.userFormula || field.userSummary) && field.canEdit == null) return false;
    return true;
},

//> @method listGrid.isEditable()   (A)
//  Looks at the 'canEdit' property on both the listGrid and the set of fields to
//  determine whether any cells in this listGrid can be edited.
//  @return (boolean)   true if any fields in this listGrid can be edited.
//<
_$true:"true",
isEditable : function () {
    // A field can be edited if:
    // listGrid.canEdit is true, and field.canEdit is not set to false
    // listGrid.canEdit is unset, and field.canEdit is set to true
    // No field can be edited if listGrid.canEdit is set to false.

    if (this.canEdit == false) return false;

    if (this.canEdit == true || this.canEdit == this._$true) {
        var fields = this.getFields() || [];
        for (var i = 0; i < fields.length; i++) {
            if (fields[i].canEdit != false) return true;
        }
        return false;
    } else {
        // this.canEdit is null
        var fields = this.getFields() || [];
        for (var i = 0; i < fields.length; i++) {
            if (fields[i].canEdit == true) return true;
        }
        return false;
    }
},

//> @method listGrid.fieldIsEditable()
// Can the field be edited?  This method looks at +link{canEdit} for the grid as well as the
// +link{listGridField.canEdit} value, to determine whether editing is actually allowed.
// For a detailed discussion, see the documentation at +link{canEdit}.
//
// @param field (ListGridField | number | string)  field object or identifier
// @return      (boolean)                          whether field can be edited
//
// @group editing
// @visibility external
//<
fieldIsEditable : function (field) {
    var colNum = this.getFieldNum(field);
    return this.canEditCell(null, colNum);
},

//> @method listGrid.setCanEdit()
// Updates the canEdit property for this listGrid at runtime.
// <P>
// If setting canEdit to false, any current editing is cancelled by calling
// +link{cancelEditing}.
//
// @param (boolean) desired value of canEdit for this grid
//<
setCanEdit : function (canEdit) {
    if (canEdit == false) {
        if (this.getEditRow() != null) this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
        this.canEdit = false;
    } else {
        this.canEdit = canEdit;
    }
},

//> @method listGrid.setFieldCanEdit()
//  Updates the canEdit property for some field at runtime.
//  @param  (boolean)   desired value of canEdit for this field
//<
setFieldCanEdit : function (field, canEdit) {

    if (isc.isA.String(field)) field = this.getField(field);
    if (field == null || !this.completeFields.contains(field) || field.canEdit == canEdit) return;

    field.canEdit = canEdit;
    if (this._editorShowing) {
        var editRow = this.getEditRow(),
            fieldName = field[this.fieldIdProperty],
            colNum = this.getColNum(field);

        // If we're editing by cell and making the current edit field non editable, kill the
        // current edit
        if (this.editByCell) {
            if (!canEdit && colNum == this.getEditCol()) {
                this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
            }

        // If we're showing editors for the entire row, we need to refresh the appropriate
        // field in the edit row to display / hide the editor
        } else if (colNum >= 0) {

            // If we're hiding the current edit field, we want to shift focus to the nearest
            // edit field instead.
            // If there isn't one, just cancel the edit.
            if (!canEdit && colNum == this.getEditCol()) {

                var currentEditItem = this._editRowForm.getItem(fieldName),
                    fieldHasFocus = currentEditItem.hasFocus;

                // Try to put focus in an adjacent field - say the previous one
                // (try going backwards first, then forwards)
                var newEditCell = this.findNextEditCell(editRow, colNum, -1,
                                                        true, false, false, true);

                if (newEditCell == null || newEditCell[0] != editRow)
                    newEditCell = this.findNextEditCell(editRow, colNum, 1,
                                                        true, false, false, true);

                // If there isn't another editable cell in this row, just cancel the edit
                if (newEditCell == null || newEditCell[0] != editRow) {
                    this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
                    return;
                }
                // startEditing the new cell. This will fire the editorExit handler on the
                // previous cell and save out the value if appropriate.
                // Note: don't focus in the new cell unless focus was already in the cell being
                // made un-editable.
                this.startEditing(newEditCell[0], newEditCell[1], !fieldHasFocus);
            }
            // Refresh the cell to actually display / hide the edit form item.
            this.refreshCell(this.getEditRow(), colNum);
        }
    }
},



//> @method listGrid.handleEditCellEvent()  (A)
// Handle an 'editCell' event - typically a click or double click on an editable ListGrid.
// Verifies that the cell passed in is a valid edit candidate before falling through to
// startEditing().
//
//  @group  editing
//
//  @param  rowNum      (number)    Row number of the cell to edit.
//  @param  colNum      (number)    Column number of the cell to edit.
//  @param  event       (editCompletionEvent)   How was this edit event triggered. If
//                                      we shift focus to a new edit cell this event will be
//                                      passed to the editorExit handler(s) of the previous row.
//                                      Expected vals are "click", "doubleClick" or "focus"
//                                      (or null).
//  @param [newValue] (any) optional new edit value for the cell
//  @return (boolean)   true if we are editing the cell, false if not editing for some reason
//<
handleEditCellEvent : function (rowNum, colNum, event, newValue) {
    // set a flag to notify us that we started this 'edit session' on keyPress
    // This is required for 'moveEditorOnArrow' behavior, which only applies to edit sessions
    // started on keypress
    // We can't use the _editorCursorAtEnd flag as that won't get set unless the value was
    // modified, and we want the moveEditorOnArrow behavior even if the user started editing
    // from an f2 keypress...
    // This flag will be cleared
    // - here if the user double clicks (etc) another cell
    // - by cellEditEnd unless the event is keyboard navigation to another cell
    if (event == this._$keyPress) this._editSessionFromKeyPress = true;
    else delete this._editSessionFromKeyPress

    // if they're trying to edit an invalid cell, return false
    if (rowNum < 0 || colNum < 0) return false;

    // if passed a logical cell that is part of a rowSpan, adjust the rowNum so we edit
    // the first spanned row
    if (this.allowRowSpanning) {
        rowNum = this.getCellStartRow(rowNum, colNum);
    }

    // can we actually edit that cell?  If not, bail.
    if (this.editByCell) {
         if (!this.canEditCell(rowNum, colNum)) return false;
    } else {
        // If the user double-clicks on a non-editable field and editByCell is
        // false assume they want to start editing the row and put focus into the closest
        // editable cell in that row.
        var editCell = this.findNextEditCell(rowNum, colNum, -1, true, true, false, true);
        if (editCell == null || editCell[0] != rowNum)
            editCell = this.findNextEditCell(rowNum, colNum, 1, true, false, false, true);

        if (editCell == null || editCell[0] != rowNum) return false;
        // Update the colNum to reflect the closest editable cell to the one clicked if the
        // row is editable.
        colNum = editCell[1];
    }
    var undef;
    if (newValue !== undef) {
        this.setEditValue(rowNum,colNum, newValue);
    }

    // startEditing will save out the value in the previous edit cell if necessary...
    return this.startEditing(rowNum, colNum, null, event);
},

// Show/Hide Inline Editor
// --------------------------------------------------------------------------------------------

//> @method listGrid.startEditing() (A)
// Start inline editing at the provided coordinates.
// <p>
// Invoked when a cell is editable and the <code>editEvent</code> occurs on that cell.  Can
// also be invoked explicitly.
// <P>
// If this method is called while editing is already in progress, the value from the current
// editCell will either be stored locally as a temporary edit value, or saved via 'saveEdits()'
// depending on <code>this.saveByCell</code>, and the position of the new edit cell.<br>
// Will update the UI to show the editor for the new cell, and put focus in it unless
// explicitly suppressed by the optional <code>suppressFocus</code> parameter.
//
//  @group  editing
//
//  @param  [rowNum]      (Integer) Row number of the cell to edit.  Defaults to first
//                                  editable row
//  @param  [colNum]      (Integer) Column number of the cell to edit.  Defaults to first
//                                  editable column
//  @param  [suppressFocus] (Boolean)   If passed this parameter suppresses the default
//                                  behavior of focusing in the edit form item when
//                                  the editor is shown.
//  @return (Boolean)   true if we are editing the cell, false if not editing for some reason
//
// @see canEditCell()
// @see editEvent
// @visibility external
//<

startEditing : function (rowNum, colNum, suppressFocus, eCe, suppressWarning) {
    
    
    if (this._keyboardEventsDisabled) {
        this.logInfo("call to startEditing() while keyboard events disabled (may be due to " +
                     "a component-mask blocking this grid). Ignoring", "gridEdit");
        return false;
    }

    // force editing on if it's not configured for any field, but a programmatic call is made
    if (!this.canEdit && !(this.completeFields || this.fields).getProperty("canEdit").or()) {
        this.canEdit = true;
    }

    // if setFields() has never been called, call it now.
    if (this.completeFields == null) this.setFields(this.fields);

    // Possibilities:
    // - This is an entirely new editing flow
    // - We are in an uncompleted editing flow
    // - We are currently showing an editor for another cell

    // What needs to happen?
    // - Showing a previous editor:
    //   *Save the new value from the edit cell locally into the temp set of editValues (for
    //     the appropriate record)
    //   *Hide the inline editor (unless it's another field in the same row and we're editing
    //     the whole row)
    // - Update edit info for this edit:
    //   *If we have no editFlowID, set up a new one
    //   *If there are no editValues stored for this record, store those values
    //   *Update the current editRowNum and editColNum, so we know which field is being edited

    // - show the editor:
    //   *Call 'showInlineEditor' to show the editor.  This will draw a new editor if required,
    //       or just focus in the appropriate field of the existing editor.

    // default to editable row / col
    var noRow = (rowNum == null),
        noCol = (colNum == null);
    if (noRow || noCol) {
        var testRow = (noRow ? 0 : rowNum),
            testCol = (noCol ? 0 : colNum);
        var newCell = this.findNextEditCell(testRow, testCol, 1, noCol, true);
        if (newCell == null) {
            this.logInfo("startEditing() passed bad cell coordinates:" + [rowNum, colNum],
                "gridEdit");
        } else {
            this.logInfo("startEditing() using derived coordinates:"+ newCell, "gridEdit");
            rowNum = newCell[0];
            colNum = newCell[1];
        }
    }

    // Legal coordinates are
    // - any rowNum within the dataSet
    // - any rowNum for which we already have editValues (even if the record has not been saved)
    // - one rowNum past our last row (== this.getTotalRows()). In this case we'll be creating
    //   a new row on the end of the list.
    // Bail if the coordinates are not legal.
    
    if (rowNum == null || rowNum < 0 || rowNum > this.getTotalRows()) {
        //>DEBUG
        // SuppressWarning param passed in when alwaysShowEditors is true and we blindly call
        // 'startEditing()' with no coordinates.
        // In this case we expect to fail to start the edit if there's no data or no visible,
        // editable cells.
        if (!suppressWarning) {
            this.logWarn("startEditing() passed bad cell coordinates:" + [rowNum, colNum] +
                        ", can't edit" + this.getStackTrace(), "gridEdit");
        }
        //<DEBUG
        return false;
    }

    if (!this.canEditCell(rowNum, colNum)) {
        //>DEBUG
        this.logInfo("startEditing(): cell " + [rowNum, colNum] +
                     " is non editable. Returning.", "gridEdit");
        //<DEBUG
        return false;
    }

    // at this point we have a valid cell to start editing.
    // If we're showing an editor, allow 'changeEditCell()' to handle saving out the
    // previous cell value, etc. - otherwise just call _startEditing() to start the edit
    // process
    if (this._editorShowing) {
        this._changeEditCell((eCe || isc.ListGrid.PROGRAMMATIC),
                             this.getEditRow(), this.getEditCol(), rowNum, colNum);
    } else {

        // Punt it over to _startEditing to handle the actual editing
        this._startEditing(rowNum, colNum, suppressFocus);
    }

    // return true to indicate editing has begun
    
    return true;
},

isEditingCell : function (rowNum, colNum) {
    return this._editorShowing && this.getEditRow() == rowNum && this.canEditCell(rowNum, colNum) &&
           (!this.editByCell || this.getEditCol() == colNum);
},

// _changeEditCell()
// Internal method used by both 'startEditing' and 'cellEditEnd' to complete editing one cell
// and start editing another.
// This method will fire user event / change handlers, and save out the edit values if
// appropriate.
// Falls through to _startEditing() to handle updating the display (hides this editor and shows
// the new one), and setting up the editValues for the new edit row.
_changeEditCell : function (editCompletionEvent, currentRowNum,
                            currentColNum, newRowNum, newColNum)
{

    // Note that the getEditValue() method will automatically pick up the current value
    // of the form item and store it in the edit-values
    // Note - this will fire the 'editorChange()' handler if the value has changed.
    var newValue = this.getEditValue(currentRowNum, currentColNum);

    // if we never fired 'editorEnter' avoid firing editor exit.
    
    var fieldName = this.getFieldName(currentColNum),
        editForm = this._editRowForm,
        editItem = editForm ? editForm.getItem(fieldName) : null,
        shouldFireEditorExit = editItem ? !editItem._cellEnterOnFocus : true
    ;
    if (editItem) {
        // If the edit item never got focused, the 'enterOnFocus' tags will still be present
        // just clean these up since we'll reset them if necessary (if focus goes back to the row)
        delete editItem._cellEnterOnFocus;
        delete editItem._rowEnterOnFocus;

        
        if (this._shouldParkFocus(editItem, currentRowNum, newRowNum, newColNum)) {
            this._parkFocus(editItem, currentColNum);
        }
    }

    // determine whether we need to validate or save on this cell transition
    // Use _getEditValues() - we already updated the editValue if necessary
    var leavingRow = (newRowNum != currentRowNum),
        newValues = this._getEditValues(currentRowNum, currentColNum);
        
    // Fire any developer defined handlers to fire when the user attempts to exit the edit cell
    // Stop if 'editorExit' handlers returned false.
    if (shouldFireEditorExit) {
        var editKilled = !this._handleEditorExit(editCompletionEvent,
                                                 currentRowNum, currentColNum, newValue);
        if (leavingRow && !editKilled) {
            editKilled = !this._handleRowEditorExit(editCompletionEvent, currentRowNum, newValues);
        }

        if (editKilled) {
            // If the editorExit handlers didn't already cancel this edit, or start a new one, force
            // focus back into the current edit field.
            // This is required as focus may not be in this form field
            
            if (editCompletionEvent == isc.ListGrid.EDIT_FIELD_CHANGE) {
                var newFieldName = this.getFieldName(newColNum);
                if (editItem && editForm.getItem(newFieldName).hasFocus) {
                    editItem.focusInItem();
                }
            }
            return false;
        }
    }
    
    
    var undef;
    if (newValue !== undef && !leavingRow && editItem && !this.editByCell) {
        var atomicVal = this._getEditValue(currentRowNum, currentColNum);
        var formattedVal = this._formatEditorValue(
                            atomicVal, this.getCellRecord(currentRowNum, currentColNum), 
                            currentRowNum, currentColNum);
        editItem.setValue(formattedVal);
    }
    
    var saveNow = (this.autoSaveEdits &&
                    ((leavingRow &&
                     this.shouldSaveOnRowExit(currentRowNum, currentColNum, editCompletionEvent)) ||
                     this.shouldSaveOnCellExit(currentRowNum, currentColNum, editCompletionEvent)));

    // The 'neverValidate' property effectively disables validation for form items.
    // Otherwise:
    // - If we're saving, we avoid validating here, since saving will auto-validate for us.
    // - otherwise perform cell or row validation based on this.validateByCell / this.autoValidate

    if (!saveNow && this._validationEnabled()) {
        var validationFailed,
            validateRow = leavingRow &&
                          this.shouldValidateByRow(currentRowNum, currentColNum, editCompletionEvent);
        // Note that if we're working with cellRecords we call validateCell() directly
        // if we should validate the row
        if (validateRow && !this.usingCellRecords) {
            validationFailed = !this.validateRow(currentRowNum);
        // If we're not validating the entire row, determine whether we should validate the
        // cell individually
        } else {
            if (validateRow ||
                this.shouldValidateByCell(currentRowNum, currentColNum, editCompletionEvent))
            {
                validationFailed = !this.validateCell(currentRowNum, currentColNum);
            }
        }

        // Suppress navigation if validation failed. No need to show error to user - already
        // handled by the validation methods.
        if (this.stopOnErrors && validationFailed) return false;
    }

    // At this point the old editor is still showing, but values have been updated, and
    // handlers fired.  Fall through to _startEditing to handle hiding this editor and showing
    // the new one.
    
    if (saveNow) {
        return this._saveAndStartEditing(newRowNum, newColNum, editCompletionEvent);
    } else {
        // proceed immediately to next cell
        this._startEditing(newRowNum, newColNum);
    }

    // If the user changed the grouped value of an edit row, regroup.
    // Exception - if we're saving, locally, we will have already saved at this point, which
    // already handles regrouping.
    if (leavingRow && this.isGrouped && (!saveNow || !this.shouldSaveLocally())) {
        this._updateGroupForEditValueChange(currentRowNum);
    }
},

// If the user edits a grouped tree, and changes a value within the groupBy field we
// may need to regroup.
// Determine this from rowNum by looking at the current editValues / record values for the
// groupBy field[s] and the current position in the group tree.
//
// We call this when the user is done editing a row, so from
// - user moving from one edit row to another - _changeEditCell()
// - editor being dismissed - saveAndHideEditor()
//   [NB: that method doesn't actually save if autoSaveEdits is false]
// We do not call this if either of these actions tripped a local save since that
// occurs synchronously and handles regrouping automatically.


_updateGroupForEditValueChange : function (rowNum) {
    if (!this.isGrouped || !isc.isA.Tree(this.data)) return;

    var node = this.data.get(rowNum),
        groupNode = node,
        shouldRegroup = false;
    // passed a bad rowNum
    if (node == null) return;

    var groupFields = this.getGroupByFields();

    if (!isc.isAn.Array(groupFields)) groupFields = [groupFields];
    var curVals = this.getEditedRecord(rowNum);

    for (var i = groupFields.length-1; i >=0; i--) {
         var fieldName = groupFields[i],
            groupNode = this.data.getParent(groupNode);

        if (groupNode == null || groupNode.groupName != fieldName) {
            this.logWarn("error updating group for edit value change - unexpected group " +
                "tree structure. Regrouping.");
            shouldRegroup = true;
            break;
        }

        var value = curVals[fieldName],
            field = this.getUnderlyingField(fieldName);

        // trasnform raw value of the group field (potentially) 
        value = this._getGroupValue(value, curVals, field, fieldName);
        if (groupNode.groupValue != value) {
            shouldRegroup = true;
            break;
        }
    }

    if (shouldRegroup) {
        // call _remapEditRows() before _incrementalRegroup, as does dataChanged()
        this._remapEditRows();
        this._incrementalRegroup(null, node, curVals);
        this.markForRedraw();
    }
    return shouldRegroup;
},


_shouldParkFocus : function (editItem, currentRowNum, newRowNum, newColNum) {
    if (!isc.Browser.isIE) return false;

    // If current focus is in a non-text-based item we don't need to park focus - selection
    // will update as appropriate.
    var textBasedFocusItem = (isc.isA.PopUpTextAreaItem(editItem) &&
                              // in a difficult-to-reproduce case, editItem._popupForm can end up
                              // undefined when hiding columns while editing.  This check
                              // prevents a JS error, but may still cause focus to skip
                              editItem._popupForm && editItem._popUpForm.hasFocus) ||
                             (editItem.hasFocus && isc.FormItem._textBasedItem(editItem));
    //if (!textBasedFocusItem) return false;

    // If we will not be removing the current item from the DOM, we don't need to park focus.
    
    if (!this.editByCell && newRowNum == currentRowNum) return false;

    // If the new item is text-based - no need to park focus
    var newEditorType =
        this.getEditorType(this.getField(newColNum), this.getCellRecord(newRowNum, newColNum));
    return !(newEditorType == null || isc.FormItem._textBasedItem(newEditorType, true));

},

// Internal method to unconditionally start editing a rowNum / colNum.
// This method will
//  - hide the current editor (if appropriate)
//  - set up edit values for the new cell
//  - show the editor for the new cell (and focus unless suppressFocus param passed)
// o Does not check for validity of rowNum / colNum
// o Does not save / modify pending edit values for some other cell/row
_startEditing : function (rowNum, colNum, suppressFocus) {

    
    if (rowNum == "delayed") {
        // we're firing from a timer for a delayed edit

        // another call to startEditing happened while we were waiting for the timer to fire,
        // and its params took precedence
        var params = this._delayedStartEditing;
        if (params == null) return;

        rowNum = params[0];
        colNum = params[1];
        suppressFocus = params[2];

        

    } else if (this.isDrawn() &&
                (!this.body.readyToRedraw() ||
                 (this.frozenBody && !this.frozenBody.readyToRedraw())))
    {
        // set a timer if we have not already set one, otherwise, just update the parameters
        // for the delayed edit
        if (!this._delayedStartEditing) {
            this.delayCall("_startEditing", ['delayed'],0);
        }
        this._delayedStartEditing = [rowNum, colNum, suppressFocus];
        
        return;
    }

    // we're starting editing now, we don't need the delayed edit params (the current
    // startEditing invocation overrides them)
    delete this._delayedStartEditing;

    // Remember which cell we're currently editing as the last "keyboard hilite" cell.
    // This ensures that if the user hides the editor, then re-displays it, editing
    // will recommence at the same spot.
    if (!suppressFocus) {
        this._lastKeyboardHiliteRow = rowNum;
        this._lastKeyboardHiliteCol = colNum;
        this._lastKeyboardHiliteBody = this.getFieldBody(colNum);
        // If we're selecting on edit, also update the "lastSelected" cell.
        // This can also be used in determining the "focusCell"
        
        if (this.selectOnEdit && this._lastKeyboardHiliteBody != null) {
            this._lastSelectedBody = this._lastKeyboardHiliteBody;
            this._lastSelectedBody._lastSelectedRow = rowNum;
            this._lastSelectedBody._lastSelectedCol = colNum;
        }
    }


    var changingRow = this.getEditRow() != rowNum;

    // On a call to startEditing the current editRow / col, just put focus into the
    // field editor in question

    if (!changingRow && !suppressFocus && (this.getEditCol() == colNum)) {
        this.getEditForm().focusInItem(this.getEditorName(rowNum, colNum));
        return;
    }

    //>DEBUG
    this.logInfo("Starting editing at row " + rowNum + ", colNum " + colNum, "gridEdit");
    //<DEBUG

    // if we currently have an embedded editor showing, dismiss it
    if (this._openRecord != null) this.closeRecord();
    if (this._editorShowing) {
        // if we're changing rows, or only editing one cell at a time, hide the current editor,
        // as it has no overlap with the old editor
        if (this.editByCell || changingRow) {

            // hide the editor (but don't focus back in the body), and don't hide the CM as
            // we're about to show another editor.
            
            this.hideInlineEditor(false, true);
        }
    }



    // We're in a new edit flow if
    // - this._editingFlowID is null
    // - saveByCell is false
    // - we're editing a cell in a different row.
    // Otherwise this method is just showing the editor for a different cell
    
    var newEditFlow = (this._editingFlowID == null)  ||
                      changingRow ||
                      this.saveByCell;

    if (newEditFlow) {
        this._editingFlowID = this._getNextEditFlowID();
    }

    //this.logWarn("about to start editing, editValues for row: " + rowNum + " are now: " +
    //             this.echo(this.getEditValues(rowNum)));
    var record = this.getCellRecord(rowNum, colNum);
    if (record == Array.LOADING) {
        // DO not edit temporary 'loading' records
        return true;
    }

    // Set up initial empty edit vals
    
    var displayNewValues = this._editorShowing && (this.getEditRow() == rowNum)
    this.initializeEditValues(rowNum, colNum, displayNewValues, true);

    // At this point - we are definitely going to start editing the new row, and the editValues
    // have been set up.
    // If 'selectOnEdit' is true, select the row.
    
    if (this.selectOnEdit && record != null) this.selectRecordForEdit(record, colNum);


    // ModalEditing (and edit event 'click') - in this case we show a click mask so won't
    // update rollovers when the user moves over other rows in the grid.
    // If they then click another record we'll start editing there, but never have cleared the
    // current 'over' row.
    // This can lead to the over styling getting left around until editing is complete.
    // Resolve this by explicitly clearing the hilite here:
    if (this.modalEditing) this.clearLastHilite();

    // If this is a new record, and 'addNewBeforeEditing' is true, we want to create the new
    // edit record BEFORE we start editing it - we do this via the standard 'saveEdits()'
    // method - this will save out the newly created editValues.
    // The save, which may be asynchronous, may modify the values of the saved record, setting
    // up default field values, etc.  We want to reflect these changes in the edit data for
    // the record.
    // Handle this by having a method _updateNewEditRowValues() update the edit values for the
    // row with the values taken from the record.
    // We continue to show the editor on the newly created row, either now, or if wait for save
    // is true, after the save occurs.
    if (record == null && this.addNewBeforeEditing) {
        // Hang onto the editRow / col, so we know what cell we're currently editing
        // This is usually done in 'showInlineEditor' but we need this for the saveEdits call
        // in this case
        this._editRowNum = rowNum;
        this._editColNum = colNum;
        var waitForSave = this.shouldWaitForSave();

        
        var callback = "this._updateNewEditRowValues(" + waitForSave + "," + suppressFocus + ")" ;
        this.saveEdits(isc.ListGrid.PROGRAMMATIC, callback);
        if (waitForSave) return;
        else {
            // The 'saveEdits()' call above may have changed the edit row's position.
            rowNum = this._editRowNum;
            colNum = this._editColNum;
        }
    }
    // - show the editor:
    //      - if the editor is showing for the same row, this will just focus
    //      - if another row, or editByCell, this will update the edit form, and show it in
    //        the right place
    // Note that 3rd param is always true - we'll be calling showInlineEditor to show the
    // same cell in this method.
    this.showInlineEditor(rowNum, colNum, true, changingRow, suppressFocus);

    // When showing editor the first time or when changing rows update rule context
    if (changingRow && !suppressFocus) this._provideEditRecordToRuleContext();

    return true;

},

// Select the record about to be edited
selectRecordForEdit : function (record, colNum) {
    // perf: avoid updating the row we're about to draw editors into anyway
    
    if (!this.editByCell) record._ignoreStyleUpdates = true;
    
    if (this.canSelectCells) {
        var cell = this.getRecordCellIndex(record, colNum);
        this.selection.selectSingleCell(cell[0],cell[1]);
        this.fireSelectionUpdated();
    } else if (this.selection != null && (!this.selection.isSelected(record) ||
                                           this.selection.multipleSelected()))
    {
        // we want a selection similar to select on mouse down: If we're using simple selection
        // select the record in addition to whatever else is selected - otherwise do a
        // single selection
        if (this.selectionType == isc.Selection.NONE) {
            // shouldn't see this as we disable selectOnEdit when selectionType is none
            this.logInfo("selectOnEdit is true, but this.selectionType is set to 'none'." +
                " Unable to perform a selection on edit.", "gridEdit");

        } else if (this.selectionType == isc.Selection.SIMPLE) this.selection.select(record);
        else this.selection.selectSingle(record);
        this.fireSelectionUpdated();
    }
    delete record._ignoreStyleUpdates;

},


// For text-based editors, update selection on focus
// The behavior we want is:
// - if the user started editing via editOnKeyPress (they started typing in the cell), put focus
//   at the end of the value so they don't wipe out what they already typed
// - otherwise respect this.autoSelectEditors
// We achieve this via a temporary flag set when we start editing a cell via 'editOnKeyPress'
_updateEditorSelection : function (item) {
    // applies only to text items (and subclasses)
    if (!isc.isA.TextItem(item) && !isc.isA.TextAreaItem(item) &&
        !(isc.isA.TimeItem(item) && item.useTextField!=false) &&
        !(isc.isA.DateItem(item) && item.useTextField)) return;

    // set up when form item.refocusAfterRedraw() fires.
    if (item._suppressGridTextSelection) return;
    
    var inputItem = isc.isA.DateItem(item) ? item.dateTextField :
                    isc.isA.TimeItem(item) ? item.textField : item;
    var element = inputItem.getDataElement();
    if (!element) return;
    if (this._editorCursorAtEnd || !this.autoSelectEditors) {
        var val = element.value || "";
        inputItem.setSelectionRange(val.length, val.length);
        // Assertion: we only want this special behavior of putting the cursor at the end after
        // the first 'focus()' on the item the user typed in, so clear out the flag here
        delete this._editorCursorAtEnd;
    } else {
        inputItem.selectValue();
    }
},

// Helper method to update the edit row values for the special case where we have saved out a
// new record before editing it due to 'addNewBeforeEditing'

_updateNewEditRowValues : function (showEditor, suppressFocus) {

    var rowNum = this._editRowNum,
        colNum = this._editColNum,
        record = this.getCellRecord(rowNum, colNum);

    if (record != null && record != "loading") {
        
        var values = this.getEditValues(rowNum, colNum);
        for (var i in record) {
            
            if (record[i] != null && values[i] == null) {
                values[i] = record[i];
            }
        }
    }

    if (showEditor) this.showInlineEditor(rowNum, colNum, true, true, suppressFocus);
    else this.updateEditRow(rowNum);
    // Note - no need to explicitly focus in the editor here - this will be handled by
    // showInlineEditor if we're showing a new editor - and if we're already showing the
    // editor we don't need to modify it's focus
},

//> @method listGrid.editField() (A)
//
//  Start editing a specific field.  This will save the current edit if appropriate.
//
//  @group  editing
//
//  @param  fieldName   (string)    Field to start editing
//  @param  [rowNum]  (number)  Optional row to start editing - if null defaults to the current
//                              edit row.
//  @return (boolean)   true if we are editing the cell, false if not editing for some reason
//
// @see canEditCell()
// @see editEvent
//<
editField : function (fieldName, rowNum) {
    // If this grid has not yet been drawn, this.fields may not have been set up yet
    if (this.completeFields == null) this.setFields(this.fields);

    var colNum;
    if (isc.isA.Number(fieldName)) colNum = fieldName;
    else colNum = this.fields.findIndex(this.fieldIdProperty, fieldName);
    if (rowNum == null) {
        rowNum = this.getEditRow();
        // It's legal to pass in no rowNum param, but if we're not already editing a row,
        // bail with a warning.
        if (rowNum == null) {
            this.logWarn("editField(): unable to determine which row to edit - returning.",
                        "gridEdit");
            return;
        }
    }
    // Fall through to startEditing() to handle performing the edit.
    return this.startEditing(rowNum, colNum);
},

// create or update the editForm to reflect the editable and visible fields around the given
// coordinate, and show editors.
// Focuses in the target cell unless suppressed.
// internal: assumes we are logically set up to edit this row (editValues created)
// Application developers would call 'startEditing()' instead of this method

// this method is also responsible for firing editorEnter handlers when focus goes to the
// new edit cell - handled by setting up a flag to be checked by the form item's focus()
// handler.
showInlineEditor : function (rowNum, colNum, newCell, newRow, suppressFocus) {

    // This method is called in the following circumstances:
    // - we need to re-set focus to the current edit cell (example: setFields, redraw of body, etc)
    // - we need to move focus to a new cell that is already showing (called from startEditing())
    // - The editor is currently hidden and we need to show it (and put focus into the
    //   appropriate cell).
    // It is not expected to be called when the editor is currently showing for another
    // row (or for editByCell grids, another cell) - this method should not have to handle
    // hiding the edit form just showing it (if necessary) and assigning focus.
    //
    // NOTE: if we're doing full-row editing and the editForm is already showing, we assume the
    // current edit field's value has already been updated / saved by 'startEditing' call
    // whenever appropriate.
    if (this._editorShowing) {
        // Catch the case where we're showing the edit form for another row
        if (rowNum != this.getEditRow() || (this.editByCell && colNum != this.getEditCol())) {
            this.logWarn("Unexpected call to 'showInlineEditor' during another edit " +
                         "- cancelling previous edit", "gridEdit");
            this.cancelEditing();
            this.startEditing(rowNum, colNum);
            return;
        }
    }
    // Set a flag to note that we're in the process of setting up the editor.
    // This will avoid infinite loops if showInlineEditor is called directly from
    // anything called by this method - EG: the redraw triggered by scrolling the
    // cell into view
    
    if (this._settingUpEditor && this._settingUpEditor[rowNum] == rowNum
        && this._settingUpEditor[colNum] == colNum)
    {
        return;
    }
    this._settingUpEditor = [rowNum,colNum];

    var suppressScroll = (this.suppressEditScrollIntoView || suppressFocus ||
                          
                          this.ns.EH._handlingTouchEventSequence());

    this.logDebug("showing inline editor at: " + [rowNum, colNum] +
                  ", will focus: " + !suppressFocus, "gridEdit");

    
    var scrollBeforeShowing = this.body && (!this.body.shouldShowAllColumns() || !this.body.showAllRows);
    if (scrollBeforeShowing && !suppressScroll) {
        // set scrollRedrawDelay to zero before scrolling into view. This ensures that the body will
        // be marked dirty instantly if a redraw is required, which in turn makes sure we set up the
        // correct set of form items
        var srd = this.body.scrollRedrawDelay;
        this.body.scrollRedrawDelay = 0;
        this.scrollToCell(rowNum, colNum, "left", "top");
        this.body.scrollRedrawDelay = srd;
    }

    // If we're showing the rollOver canvases, clear them now
    var refRollOverCanvas = this.currentRollOverCanvas || this.currentRollUnderCanvas;
    if (refRollOverCanvas != null && refRollOverCanvas._currentRowNum == rowNum) {
        this.updateRollOverCanvas(refRollOverCanvas._currentRowNum,
                                  refRollOverCanvas._currentColNum, true);
    }

    var forceRedraw;
    if (!this._editorShowing) {
        // create or update the editForm used to display editors for the fields.
        var rebuiltForm = this.makeEditForm(rowNum, colNum);
        if (this._alwaysShowEditors() && rebuiltForm) {
            // if the edit form items actually changed (rather than just having
            // new properties applied to them in place), we'll need a full redraw
            // since the inactiveHTML currently written into all other rows will
            // not be associated with the new set of live items
            this.logInfo("Edit Form rebuilt with alwaysShowEditors:true, requires full redraw",
                         "inactiveEditorHTML");
            forceRedraw = true;
        }
    }
    // If the user is shifting focus forward we want to focus "at the start" of the
    // edit item, otherwise at the end, if supported.
    
    var focusAtEnd = this._editColNum != null && (colNum > this._editColNum);
    // Update the remembered editColNum
    this._editRowNum = rowNum;
    this._editColNum = colNum;

    // Also update the stored "lastRecordClicked".
    // This is used for keyboard navigation when the editor isn't showing.
    // Setting this will ensure that we don't mysteriously jump to whatever was previously
    // recorded as the last record clicked once the editor is dismissed and the user hits
    // the up or down arrow key
    
    this._lastRecordClicked = rowNum;

    // write the editor form items into the DOM
    this._showEditForm(rowNum, colNum, forceRedraw);

    // Clear the settingUpEditor flag here
    
    this._settingUpEditor = null;


    // Ensure the edit cell is visible in the viewport
    
    if (this.body && !suppressScroll) {
        var mustScroll;
        if (!scrollBeforeShowing) mustScroll = true;
        else {
            var body = this.body,
                rowTop = body.getRowTop(rowNum),
                rowHeight = body.getRowSize(rowNum),
                scrollTop = body.getScrollTop(),
                portHeight = body.getViewportHeight();
            mustScroll = (rowTop < scrollTop) || (rowTop + rowHeight > scrollTop + portHeight);
        }
        if (mustScroll){
            this.scrollToCell(rowNum, colNum, "left", "top");
        }
    }

    // Don't show the click mask, or focus in the form item if we're not drawn.
    if (!this.isDrawn()) {
        return;
    }
    this._showEditClickMask();
    var focusItemName = this.getEditorName(rowNum, colNum),
        focusItem = this._editRowForm.getItem(focusItemName);
    // focusItem should be present since we've just scrolled it into view, but perform
    // check for safety anyway
    if (focusItem == null) {
        this.logWarn("ListGrid showing inline editor. Unable to get a pointer to the edit " +
                        "form item for field:"+ focusItemName);
    } else {

        // If this is a shift to a new cell, we'll want to fire editorEnter.
        // If a new row, we'll want to fire rowEditorEnter.
        // [Otherwise this method could be a refresh / refocus of current edit cell]
        

        
        if (newCell) focusItem._cellEnterOnFocus = true;
        if (newRow) focusItem._rowEnterOnFocus = true;
        // focus in the field being edited if appropriate
        if (!suppressFocus) {

            if (isc.Browser.isMoz) {
                
                var handle = this.body.getClipHandle(),
                    beforeFocus = handle.scrollTop;
            }

            
            var lastEvent = isc.EH.lastEvent;
            var delayFocus = false;
            if (isc.Browser.isIE && lastEvent.eventType == isc.EH.MOUSE_DOWN) {
                var target = lastEvent.target;
                if (target != this._editRowForm) {
                    delayFocus = true;
                    var ciCanvii = this._editRowForm.getCanvasItemCanvii();
                    for (var i = 0; i < ciCanvii.length; i++) {
                        if (ciCanvii[i] == target || ciCanvii[i].contains(target)) {
                            delayFocus = false;
                            break;
                        }
                    }
                }
            }
            
            if (isc.Browser.isIE) {
                var focusParkForm = isc.ListGrid._focusParkForm;
                if (focusParkForm &&
                    (focusParkForm.hasFocus || focusParkForm.itemHasFocus())) delayFocus = true;
            }

            
            if (isc.Browser.isSafari && this.alwaysShowEditors) {
                delayFocus = true;
            }

            if (delayFocus) {
                this._delayedFocusEvent = this._editRowForm.delayCall("focusInItem", [focusItemName, focusAtEnd]);

            } else {
                
                if (isc.Browser.isMoz && this.body.overflow == isc.Canvas.VISIBLE) {
                    this.adjustOverflow();
                }
                this._editRowForm.focusInItem(focusItemName, focusAtEnd);
            }
        }
    }
},

// Write the editor form items into the cells in the ListGrid body, by redraw or refresh
// Re-evaluates canEditCell(), so may hide editors or show new editors.
// Internal: purely a helper to showInlineEditor
_showEditForm : function (rowNum, colNum, forceRedraw) {
    var editorWasShowing = this._editorShowing;
    this._editorShowing = true;
    if (!this.isDrawn() || !this.body) return;

    // The edit form has been created, and we need to show its items in the DOM.
    // 3 cases to catch:
    //  - Some edit form items are already showing for the edit row:
    //     If editByCell is false, it's possible that the 'canEditCell' criteria have changed
    //     for some currently visible edit cells.
    //     Need to refresh any cells where this is the case to show / hide form items.
    //  - No edit form items are showing
    //    - if the edit row is beyond the end of the list, we need to redraw the body to
    //      display the new edit row.
    //    - Otherwise for each cell where canEditCell is true, we must refreshCell() to write
    //      the form item into the DOM.

    // If we're showing the editor for a new edit row at the end of the list that's not currently
    // in the DOM redraw the body
    // Note: if this._editorShowing was true at the start of this method, we know we're
    // editing a new cell in the current edit row (_startEditing will hide the inline editor
    // if we're editing a different row). In this case we only need to redraw the body if it's
    // already been marked as dirty.

    
    var newRow = this.isEmpty() ||
                 (!editorWasShowing &&
                    (rowNum >= this.data.getLength()) &&
                    (this.showNewRecordRow ||
                     
                     (this.body.getTableElement(rowNum) == null)));

    var showInactiveEditors = this._alwaysShowEditors();

    // If we're showing embedded component(s) for the row force a redraw
    // This'll place them properly
    
    var record = this.getCellRecord(rowNum,colNum);
    if (record && this._hasEmbeddedComponents(record)) {
        
        //forceRedraw = true;
    }

    if (forceRedraw || newRow || this.body.isDirty() ||
        (this.frozenBody && this.frozenBody.isDirty()) ) {
        
        var body = this.bodyLayout ? this.bodyLayout : this.body;
        body.redraw("Showing editor");
        return;
    }

    // Drawing of edit items can trip a server fetch to pick up optionDataSource data
    // use a queue to minimize client-server transactions where possible
    
    var wasQueuing = isc.RPCManager && isc.RPCManager.startQueue();
    
    // otherwise, editor is showing for the same row
    if (this.editByCell) {
        // We need to refresh the entire row if
        // - frozenFields is non null -- this ensures the height of the row in both
        //   bodies matches
        // - we're using explicit tall vs normal base style -- ensure we switch to tall base
        //   style while the editor is showing
        var refreshRow = (this.frozenFields != null) || (this.baseStyle == null);
        // editing by cell - just refresh the edit cell to show the editor.
        if (refreshRow) this.refreshRow(rowNum);
        else this.refreshCell(rowNum, colNum);

    } else {
        // editing whole row - draw editors into the currently visible cells

        

        // use getDrawnFields() to retrieve the set of drawn fields (takes care of frozen fields and
        // incremental rendering)
        var fields = this.getDrawnFields();
        // Check the 'canEdit' status of each cell in the edit row and refresh to show (or hide)
        // editors as appropriate.

        for (var i = 0; i < fields.length; i++) {
            if (this.isCheckboxField(fields[i])) continue;

            var field = fields[i],
                fieldName = fields[i][this.fieldIdProperty],
                formItem = this._editRowForm.getItem(fieldName),
                colNum = formItem.colNum,
                
                formItemVisible = !!(editorWasShowing && formItem.isDrawn()),

                canEditCell = this.canEditCell(rowNum, colNum);
            if (formItemVisible != canEditCell) {
                
                formItem._gridRefresh = true;
                this.refreshCell(rowNum, colNum);
                delete formItem._gridRefresh;
            }
            // For cells we are not redrawing, we need to update the cellStyle if:
            // - This is the last over row - need to clear the current 'over' style since we
            //   will not be showing  rollovers for the edit row.
            // - ensure the row shows up in the 'selected' state if selectOnEdit is true
            else if (this.selectOnEdit || this.lastOverRow) {
                var body = (field.frozen && !this._suppressedFrozenFields) ? this.frozenBody : this.body;
                body._updateCellStyle(this.getCellRecord(rowNum, colNum), rowNum, colNum);
            }
        }
    }
    
    if (!wasQueuing && isc.RPCManager) isc.RPCManager.sendQueue();
    
},

// show the clickmask to catch clicks outside the editors, which means we're done editing
// the row (and should save) if this.modalEditing is true.

_showEditClickMask : function () {

    //!DONTCOMBINE
    // only show the C.M. if this.modalEditing is true.
    if (!this.modalEditing) {
        // Note - if a hover is showing, or pending on the body, clear it now.
        
        if (this.canHover) this.stopHover();
        return;
    }

    // if the editRowForm CM is already up, no need to show it.
    if (!this._editRowForm.clickMaskUp()) {
        if (!this._editClickMaskFunction)
            this._editClickMaskFunction =
                isc._makeFunction(this.getID() + "._handleClickOutsideEditor()");

        var unmasked = [this._editRowForm];
        if (isc.ListGrid._focusParkForm != null) {
            unmasked.add(isc.ListGrid._focusParkForm);
        }

        this._editRowForm.showClickMask(this._editClickMaskFunction,
                                    // If this.stopOnErrors is true, always cancel the
                                    // 'mouseDown' that dismisses the clickMask.
                                    // [technically this should only be required if there
                                    //  actually *are* errors, but since errors may come
                                    //  back from an async save it's appropriate to always
                                    //  cancel here].
                                    (this.stopOnErrors ? isc.EH.SOFT_CANCEL : isc.EH.SOFT),
                                    // pass in the editForm to ensure that the form items
                                    // are not masked
                                    unmasked);
    }
},

//> @method ListGrid.stopHover()
// Notification that the user is no longer hovering over some cell. Hides the current hover canvas
// if one is showing.
// @visibility external
//<
// Implemented at the Canvas level. Gets called on mouseOut.

stopHover : function () {
    if (this._editorShowing && isc.EH.getTarget() == this.getEditForm()) return;
    return this.Super("stopHover", arguments);

},

// shouldWaitForSave()
// Should we block user interactions during save, or allow the user to keep editing.
// If this function returns true, we wait for a save to return successfully before moving to
// a new edit cell, or hiding the current editor.
// This depends on this.waitForSave, and this.stopOnErrors.
// Note that we can't really support stopOnErrors = true / waitForSave = false, as we will not
// know if we have validation errors from server logic until a save has completed (performing
// a server round trip), and stopOnErrors implies we want to leave the editor up (as well as
// alerting the error messages).
shouldWaitForSave : function () {
    if (this.stopOnErrors && !this.waitForSave) {
        var message =
            "Note: ListGrid initialized with 'waitForSave' false, and 'stopOnErrors' true." +
            " In this case user input will be be blocked during save, to allow server side " +
            " errors to be determined before the editor is hidden. Setting 'waitForSave' to true.";

        // Log this at the info level rather than the warning level unless waitForSave has
        // explicitly been set to 'false', as it is very likely to occur
        if (this.waitForSave == false) this.logWarn(message, "gridEdit");
        else this.logInfo(message, "gridEdit");

        // actually update 'waitForSave' -- this will avoid us showing this log repeatedly
        // when this method is run.
        // Note - if we want to support modifying these values on the fly
        // ("setStopOnErrors" / "setWaitForSave") we will have to take this modification into
        // account too.
        this.waitForSave = true;
    }

    
    return !!(this.waitForSave || this.stopOnErrors);
},

// Hide the editor(s) for the current edit row.  Internal

hideInlineEditor : function (focusInBody, suppressCMHide, shiftFocus) {
    // focusInBody is intended to restore focus to the body after hiding the (focused) editor
    // Therefore check for whether the body or the edit form currently has focus and only
    // refocus if so
    if (focusInBody) {
        if (!this.hasFocus && !(this.body && this.body.hasFocus) &&
            !(isc.ListGrid._focusParkForm && isc.ListGrid._focusParkForm.hasFocus))
        {
            var editForm = this.getEditForm();
            if (editForm == null) {
                focusInBody = false;
            } else if (!editForm.hasFocus) {
                // focus may be in a CanavsItem canvas [or descendant thereof]
                // force focus in body if the current focus target is a child of our
                // body.
                
                var focusCanvas = isc.EH.getFocusCanvas();
                if (!focusCanvas || !this.body || !this.body.contains(focusCanvas)) {
                    focusInBody = false;
                }
            }
        }
    }

    
    if (isc.Browser.isFirefox) {
        var editForm = this.getEditForm();
        if (editForm != null) {
            var item = editForm.getFocusItem();
            if (item != null && item.hasFocus) {
                var element = item._getCurrentFocusElement();
                if (element && element.blur) element.blur();
            }
        }
    }

    // - clear out the flags marking the editor as being visible
    // - If we're showing the editor for a new temporary edit row, who's values have been
    //   cleared, but we're still showing the row in the DOM, redraw the body to clear the row
    //   from the DOM
    // - otherwise call 'refreshCell()' for each cell currently showing a form item to clear
    //   it from the DOM.

    // If we aren't currently editing a row, no-op
    if (!this._editorShowing) return false;

    
    this._editorShowing = null;

    // clear _editorSelection flag - ensures we don't inappropriately refocus in the edit form
    // after redraw if we subsequently re show the editor.
    this._editorSelection = null;

    var editRow = this._editRowNum,
        editField = this._editColNum;
    this._editRowNum = this._editColNum = null;

    

    // ensure that the clickmask gets taken down after edit
    // We suppress this step when we're hiding an editor, then reshowing - for example on
    // ListGrid redraw / cell navigation.
    
    if (!suppressCMHide) this._editRowForm.hideClickMask();

    // At this point, if we have edit values for the row, but they match the underlying
    // data values, just drop them.
    
    if (this.getEditValues(editRow, editField) != null &&
        (!this._savingEdits || !this._savingEdits[this.getEditValuesID(editRow, editField)]) &&
        !this.recordHasChanges(editRow, editField, false) &&
        // recordHasChanges will return false for a row that has been submitted
        // (save not yet completed), without further edits. In this case we of course want
        // to retain the edit vals
        !this.hasSubmittedEditValues(editRow, editField) &&
        // clearing edit values drops removed flag. Unlikely to really hit this
        // case on a removed record since it's non interactive so won't show an editor, but
        // sanity check that the record isn't marked for removal before clearing edit vals
        !this.recordMarkedAsRemoved(editRow))
    {
        this.logInfo("hideInlineEditor for row with no edits - dropping edit values", "gridEdit");
        // Don't hang onto the empty edit values for the row
        this._clearEditValues(editRow, editField);
    }

    if (!suppressCMHide) {
        this._provideEditRecordToRuleContext();
    }

    if (!this.body) return true;

    // update the visible cells.  Now that editRow/Field is unset, they'll revert to normal
    // display.  NOTE: don't bother updating if we're already slated to redraw the body
    
    var editForm = this._editRowForm;

    if (editForm.hasFocus) {
        editForm.blur();
    }
    if (isc.Browser.isIE) {
        var focusItem = editForm.getFocusSubItem(),
            unconfirmedBlur = isc.EH._unconfirmedBlur;
        if (editForm.hasFocus ||
            (unconfirmedBlur &&
                ((unconfirmedBlur == editForm) || (isc.EH._unconfirmedBlur.form == editForm)) ) )
        {
            
            focusItem.elementBlur();

            // Another artifact of IE's asynchronous focus handling behavior is that
            // if 'blur()' is called on a text item, then the item is cleared from the DOM
            // before onblur fires, and 'focus()' is called on another item in the DOM, when the
            // user hits a key, focus will be pulled from the new focus item for no good reason.
            // We work around this here by putting focus in the 'focus park form'.
            
            this._parkFocus(focusItem, editField);
        }
    }

    

    // If we're showing embedded component(s) for the row force a redraw
    // This'll place them properly
    
    var record = this.getCellRecord(editRow,editField),
        forceRedraw = false;
    if (record && this._hasEmbeddedComponents(record)) {
        forceRedraw = true;
    }

    if (!this.body.isDirty() && (!this.bodyLayout || !this.bodyLayout.isDirty()) &&
        !this.isDirty())
    {
        if (forceRedraw || editRow >= this.getTotalRows()) {
            var widget = this.bodyLayout || this.body;
            widget.markForRedraw("Editor Hidden");
        } else {
            if (this.editByCell) {
                var refreshRow = (this.frozenFields != null) || (this.baseStyle == null);

                if (refreshRow) this.refreshRow(editRow);
                else this.refreshCell(editRow, editField);

            }
            else this.refreshRow(editRow);

            // force a refresh of the group-summary row if one is showing.
            
            this.refreshGroupSummary(editRow);
        }
    }

    if (focusInBody) {

        if (shiftFocus != null) {
            // shiftFocus: This would come from a Tab/Shift+Tab keypress -- in this case move focus forward
            // to the next focusable widget.
            shiftFocus == 1 ? this.body.focusInNextTabElement() : this.body.focusInPreviousTabElement();
        } else {
            // return focus to the body
            // -- ensure we don't editOnFocus via the 'suppressEditOnFocus' flag
            //    (will get cleared out by _focusChanged on the body)
            
            this._suppressEditOnFocus = true;
            
            this.body.focus();
        }
    }

    // Editor is hidden so it cannot have focus
    this._provideEditFocusToRuleContext(null);

    return true;
},

_parkFocus : function (focusItem, editField) {
    
    
    if (isc.isA.TextItem(focusItem) || isc.isA.TextAreaItem(focusItem) ||
        isc.isA.PopUpTextAreaItem(focusItem))
    {
        var focusParkForm = isc.ListGrid._focusParkForm;

        // If the hidden text item we use for managing focus doesn't exist, create it
        // here.
        if (!focusParkForm) {
            focusParkForm = isc.ListGrid._focusParkForm = isc.DynamicForm.create({

                // Ensure that if this gets destroy'd we also clear up the pointer to it
                pointersToThis:[{object:isc.ListGrid, property:"_focusParkForm"}],
                getFocusParkItem : function () {
                    return this.getItem(0);
                },
                autoDraw:false,
                _redrawWithParent:false,
                ID:"_ListGrid_focusParkForm",
                _generated:true,
                selectOnFocus:true,
                tabIndex:-1,
                numCols:1,
                items:[
                    {name:"focusPark", type:"text", title:isc.nbsp,
                        // Suppress all key event handling - this will avoid the user from
                        // being able to tab out of this focus parking form (temporarily
                        // putting focus somewhere else on the page)
                        handleKeyPress:function(){return false;}
                    }
                ],
                width:1, height:1, overflow:isc.Canvas.HIDDEN,
                
                itemHasFocus : function () {
                    var item = this.getFocusParkItem();
                    if (item.hasFocus) return true;
                    if (isc.Browser.isIE && this.isDrawn() && this.isVisible() &&
                        (this.getActiveElement() == this.getFocusParkItem().getFocusElement()))
                            return true;
                    return false;
                },
                redraw : function () {
                    var forceRefocus = false;
                    //this.logWarn("redrawing fpf");
                    if (this.itemHasFocus()) forceRefocus = true;
                    this.Super("redraw", arguments);
                    if (forceRefocus) this.focusInItem(this.getFocusParkItem());
                },
                // If the clickMask gets shown / hidden while the focus is parked
                // don't manipulate focus / store as the current "masked focus target"
                // If we don't do this, we can get bugs whereby we 'park' focus while
                // the clickMask is up, then when the clickMask hides, focus gets put
                // back in the focus-park form rather than being left alone
                
                _ignoreClickMaskFocus:true
            })
        }

        // We'll position the form under the target cell
        // Avoids any unexpected native scrolling issues with focus change.
        if (focusParkForm.isVisible()) focusParkForm.hide();

        focusParkForm.moveTo(
            Math.max(this.body.getPageLeft(), this.getColumnPageLeft(editField)),
            this.getPageTop() + Math.min(
                ((this.showHeader ? this.getHeaderHeight() : 0) + this.getRowTop(this.getEditRow())
                        - this.body.getScrollTop()),
                this.getScrollHeight()-1
            )
        );

        focusParkForm.sendToBack();
        // focusParkForm must be visible to receive focus
        focusParkForm.show();

        // If we're showing the edit clickMask, unmask the focusParkForm wrt that so we don't
        // dismiss the editor when it receives focus
        
        if (this._editRowForm.clickMaskUp()) focusParkForm.unmask(this._editRowForm.getID());

        // Put focus into the text item.
        focusParkForm.getFocusParkItem().focusInItem();

        // Ensure the editRowForm is aware it doesn't have focus any more
        
        focusItem.form.hasFocus = false;
    }
},


// Create inline editing form and items
// --------------------------------------------------------------------------------------------

// create a DynamicForm for inline editing.  This form manages FormItems embedded in GR cells,
// but does not actually draw them.
// It's up to the calling function to handle displaying these edit form items in the DOM.
updateEditorItemsInPlace:true,
makeEditForm : function (rowNum, colNum) {
    
    var record = this.getCellRecord(rowNum, colNum),
        // get the values for the form
        
        values = this.getEditDisplayValues(rowNum, colNum),
        updateItemsInPlace
    ;
    // If we're already showing an edit form and the set of editable fields
    // hasn't changed we may be able to update the items in place (changing just
    // rowNum, colNum, record, valueMap, etc) rather than performing a full
    // setItems(...) with new items on the DynamicForm
    // If 'alwaysShowEditors' is true this is going to mean we can avoid a full
    // redraw, since the currently drawn inactiveEditorHTML for other records in
    // the grid will already point to the existing form items and have appropriate
    // 'inactiveEditorContext' set allowing us to respond to events properly
    if (this.updateEditorItemsInPlace && this._editRowForm != null) {
        updateItemsInPlace = true;

        var editFields = this.editByCell ? [this.getField(colNum)] : this.getDrawnFields();
        if (editFields) {
            if (editFields.length != this._editRowForm.getItems().length) {
                updateItemsInPlace = false;
            } else {
                for (var i = 0; i < editFields.length; i++) {
                    var editField = editFields[i],
                        fieldName = this.getEditorName(rowNum, editField),
                        liveItem = this._editRowForm.getItem(fieldName);

                    if (liveItem == null ||
                        (this.getEditorType(editField, values) !=
                         this._editRowForm.getEditorType(liveItem)))
                    {
                        updateItemsInPlace = false;
                        break;
                    }
                }
            }
        }
        if (updateItemsInPlace && editFields) {
            var widths = this.getDrawnFieldWidths(record, editFields);

            for (var i = 0; i < editFields.length; i++) {
                var editField = editFields[i],
                    editColNum = this.getColNum(editField),
                    fieldName = this.getEditorName(rowNum, editField),
                    liveItem = this._editRowForm.getItem(fieldName),
                    record = this.getRecord(rowNum),
                    editedRecord = this.getEditedRecord(rowNum),
                    props = this.getEditItem(editField, record, editedRecord,
                                            rowNum, editColNum, widths[i], true);
                liveItem.setProperties(props);
                liveItem._size = null;
                if (editField.frozen) {
                    liveItem.containerWidget = this.frozenBody;
                } else {
                    liveItem.containerWidget = this.body;
                }
            }

        } else {
            // get currently visible items
            var items = this.getEditRowItems(record, rowNum, colNum, this.editByCell);
            // just update the items array and current values if the form already exists
            //this.logWarn("rebuilding editRowForm");// + this.getStackTrace());
            this._editRowForm.setItems(items);
        }
        this._editRowForm.setValues(values);

    } else {
        var items = this.getEditRowItems(record, rowNum, colNum, this.editByCell);
        // create the editForm.  Done once only per grid lifetime
        var properties = isc.addProperties({},
            this.editFormDefaults, {

            // keep track of the listGrid
            grid:this,
            // Editor form shares same ruleScope as grid to support formulas
            ruleScope:this.ruleScope,
            // 
            _populateSharedRuleContext:false,

            
            dataPath:this.dataPath,
            // for AutoTest apis
            locatorParent:this,

            showErrorIcons:this.showErrorIcons,

            // Give the form the same tabIndex - this is not relevant in most ListGrids,
            // since the clickMask / keypress handling will prevent tabbing in and out of the
            // edit form, but we rely on this behavior in the RecordEditor class where the user
            // must be able to tab in and out of the edit row.
            tabIndex:this.getTabIndex(),

            // pass it this widget's datasource too
            dataSource:this.dataSource,
            // suppressAllDSFields - this ensures that if we are created without any
            // specified items we *won't* pick up all the DS fields as items by default.
            // useful for alwaysShowEditors case / recordEditors where the editForm may
            // be created *before* draw so getEditRowItems returns an empty array - in 
            // this case we'll update with the correct items when draw occurs.
            suppressAllDSFields:true,

            autoComplete:this.autoComplete,
            uniqueMatch:this.uniqueMatch,
            // Avoid autoFocus - we explicitly focus and blur when appropriate.
            autoFocus:false,

            // Override _useDisplayFieldValue to avoid using the display field if
            // displayValueFromRecord is false
            _useDisplayFieldValue : function (field) {
                if (!this.Super("_useDisplayFieldValue", arguments)) return false;
                
                var gridField = field != null ? this.grid.getSpecifiedField(field.name) : null;
                if (gridField && gridField.displayValueFromRecord === false) return false;
                return true;
            },

            // Override focus change methods on edit form to provide current
            // focus field in ruleScope
            setFocusItem : function (item) {
                this.Super("setFocusItem", arguments);
                this.grid._provideEditFocusToRuleContext(this.isFocused() ? item : null);
            },
            clearFocusItem : function () {
                this.Super("clearFocusItem", arguments);
                this.grid._provideEditFocusToRuleContext(null);
            },
            
            
            alwaysManageFocusNavigation:true,
            _focusInNextTabElement : function (forward, mask) {
                this.logDebug("focusInNextTabElement() invoked on a ListGrid editForm.  " +
                    "This will fire 'cellEditEnd()' with an appropriate editEvent", 
                    "syntheticTabIndex");
                var editEvent = forward ? isc.ListGrid.TAB_KEYPRESS
                                            : isc.ListGrid.SHIFT_TAB_KEYPRESS;
                                            
                if (isc.EH.clickMaskUp()) {
                    isc.EH.setMaskedFocusCanvas(null, isc.EH.clickMaskRegistry.last());
                }

                // Fire cellEditEnd to handle saving out the value / moving to the next cell as
                // appropriate
                this.grid.cellEditEnd(editEvent);

            }

            
            //items:items,
            //values:values

        }, this.editFormProperties);

        if (this.dateFormatter != null && properties.dateFormatter == null) {
            properties.dateFormatter = this.dateFormatter;
        }
        if (this.datetimeFormatter != null && properties.datetimeFormatter == null) {
            properties.datetimeFormatter = this.datetimeFormatter;
        }
        if (this.timeFormatter != null && properties.timeFormatter == null) {
            properties.timeFormatter = this.timeFormatter;
        }
        this._editRowForm = isc.DynamicForm.create(properties);
        this._editRowForm.setItems(items);
        this._editRowForm.setValues(values, true);
    }

    if (this.logIsDebugEnabled("gridEdit")) {
        this.logDebug("editRowForm created with values: " +
                      this.echo(this._editRowForm.getValues()), "gridEdit");
    }
    
    // The return value will indicate whether we actually rebuilt the form
    // (as opposed to just modifying the existing items in place)
    // We use this to determine whether a full redraw is required in the
    // alwaysShowEditors case
    return !updateItemsInPlace;
},

//> @method listGrid.getEditForm() [A]
// Method to retrieve the live edit form for an +link{listGrid.canEdit,editable} ListGrid.
// This is the automatically generated DynamicForm used to manage the per field edit items.
// <P>
// Note that this is an advanced method and developers should be aware of the following issues:
// <ul><li>The edit form is only present while the user is actually editing a record and this
// method will return null if no editor is currently showing.</li>
// <li>Live edit items may be retrieved by calling <code>getItem(<i>someFieldName</i>);</code>
// but items are only created for fields that are visible and being written out into the grid.
// This means with +link{showAllColumns} set to false an item may not be created until the
// user scrolls the column in question into view</li>
// <li>The editForm's values are managed by the ListGrid through the edit-values subsystem.
// If you want to change an edit value for a field, call +link{listGrid.setEditValue()} and the
// grid will handle updating the value in the live item if necessary. You should not need to call
// <code>setValue();</code> directly on the form or item and doing so will not always update the
// edit value for the grid.
// </li></ul>
// In general - bear in mind that this is an advanced usage and if there is an equivalent API
// available on the ListGrid it is always preferable to use that.
// @return (DynamicForm) the live edit form, or null if the grid is not currently showing any editors.
// @visibility internal
//<
// currently unexposed - getEditFormItem() is much more likely to be needed.
getEditForm : function () {
    return this._editorShowing ? this._editRowForm : null;
},


// These helpers are required to allow rowNum / colNum based edit values management
// rather than fieldName based valuesManagement.


//> @method listGrid.getEditFormItem() [A]
// Method to retrieve a live edit form item for an +link{listGrid.canEdit,editable} ListGrid.
// This is the automatically generated editor displayed in a cell while editing the grid.
// <P>
// Note that this is an advanced method and developers should be aware of the following issues:
// <ul><li>Edit form items are only present while a user is actually editing a cell. This method
// will return null if the user is not editing the grid or the field in question is not editable
// or not visible. Note that due to +link{showAllColumns,incremental rendering} columns which are
// not currently scrolled into view may be un-rendered, in which case they may have no associated
// edit item until the user scrolls them into view.</li>
// <li>The items' values are managed by the ListGrid through the edit-values subsystem.
// If you want to change an edit value for a field, call +link{listGrid.setEditValue()} and the
// grid will handle updating the value in the live item if necessary. You should not need to call
// <code>setValue();</code> directly on the item and doing so will not always update the
// edit value for the grid.
// </li></ul>
// In general - bear in mind that this is an advanced usage and if there is an equivalent API
// available on the ListGrid it is always preferable to use that.
// @param field (String or Integer) fieldName or colNum to get the edit item for.
// @return (FormItem) the live edit item for the current edit row and specified field, or null if the grid is not currently showing any editors.
// @visibility external
//<
// NOTE: this differs from getEditItem() - it's retrieving an existent item in the edit form
// for a cell -- not retrieving the properties to create a form item object
getEditFormItem : function (colNum) {
    var editForm = this.getEditForm();
    if (!editForm) return null;
    // getEditorName() already handles being passed a fieldName or colNum
    var fieldName = this.getEditorName(this.getEditRow(), colNum),
        item = editForm.getItem(fieldName);
    // sanity check - if item.colNum != the colNum passed in assume the editorName is reused for
    // multiple fields
    if (!isc.isA.Number(colNum) || (item && item.colNum == colNum)) return item;
},

getEditFormValue : function (colNum) {
    var item = this.getEditFormItem(colNum);
    return (item ? item.getValue() : null);
},

// helper: sets edit form items to latest editValues (including reverting to original record
// values if editValues have been cleared)
// Called from setEditValues()
_updateEditItemValues : function () {
    if (!this._editRowForm) return;

    var rowNum = this.getEditRow(), colNum = this.getEditCol(),
        values = this.getEditDisplayValues(rowNum, colNum);
    this._editRowForm.setValues(values);
},


// Helper method to get all the values for the edit form at once
getEditDisplayValues : function (rowNum, colNum, dontCheckForChanges) {
    var editValues = dontCheckForChanges ? this._getEditValues(rowNum, colNum) 
                                        : this.getEditValues(rowNum, colNum),
        record = this.getCellRecord(rowNum, colNum),
        values = {};
    for (var fieldName in record) {
        values[fieldName] = record[fieldName];
    }
    
    for (var fieldName in editValues) {
        values[fieldName] = editValues[fieldName];
    }

    for (var fieldName in values) {
        var fieldNum = this.getFieldNum(fieldName);
        // call the edit formatter (if defined) for all visible cells
        if (fieldNum >=0 && this._formatEditorValue != null) {
            values[fieldName] = this._formatEditorValue(values[fieldName], record, rowNum, fieldNum);
        }
    }

    return values;
},

// Method to get the horizontal space available for the form items for each column
// (Note this is not a 1:1 mapping to form items, as not every field is editable, and we
// incrementally create form items for columns as they are rendered out)
// Overridden by TreeGrid to account for indentation in tree field.
getEditFormItemFieldWidths : function (record) {
    var widths = [];
    for (var i =0; i<this.fields.length; i++) {
        var colNum = this.getLocalFieldNum(i),
            field = this.fields[i],
            body = (!this._suppressedFrozenFields && field.frozen) ? this.frozenBody : this.body;
        widths[i] = body.getInnerColumnWidth(colNum);
    }
    return widths;
},

//> @method listGrid.getEditorValueMap()  ([A])
//
//  Returns the valueMap to display for a field when it is displayed in the editor while
//  editing some record.<br>
//  Called when a user starts to edit a field, or whenever the field valueMap is updated via
//  a call to +link{listGrid.setValueMap()} or +link{listGrid.setEditorValueMap()}.
//  Default implementation will return the <code>field.editorValueMap</code> if specified, otherwise
//  <code>field.valueMap</code> - can be overridden to provide a
//  different specific valueMap for some field based on the record/field data.
//
//  @group  editing
//
//  @param  field   (ListGridField)    field definition field for which we need a valueMap
//  @param  values  (object)    Field values for record being edited. Note that this will include
//                              the current edit values for fields that have not yet been saved.
//                              May be null, if editing a new record.
//  @return         (ValueMap)  ValueMap for the edit field (or null if no valueMap required)
//  @visibility external
//<

//> @method listGridField.getEditorValueMap()
// Optional stringMethod to get a +link{listGridField.valueMap} for a specific field.
// If present this method will be called from +link{listGrid.getEditorValueMap()} and the resulting
// valueMap will be used instead of any static specified valueMap for the field.
// @param values (object) Field values for record being edited. Note that this will include
//                        the current edit values for fields that have not yet been saved.
//                        May be null, if editing a new record.
// @param field (ListGridField) pointer to the listGridField
// @param grid (ListGrid) pointer back to this ListGrid instance.
// @return (valueMap) ValueMap for the field (or null if no valueMap required)
// @visibility external
//<

getEditorValueMap : function (field, values) {
    if (field.getEditorValueMap != null) {
        
        isc.Func.replaceWithMethod(field, "getEditorValueMap", "values,field,grid");
        return field.getEditorValueMap(values,field,this)
    }
    if (field.editorValueMap != null) {
        return field.editorValueMap;
    }
    if (field.editorProperties && field.editorProperties.valueMap) {
        return field.editorProperties.valueMap;
    }
    return field.valueMap;
},


//> @method listGrid.getEditorValueIcons()
// Returns the valueIcons for a field when it is displayed in the editor while editing some
// record. Default implementation will return +link{ListGridField.editorValueIcons} if specified
// otherwise +link{ListGridField.valueIcons}
// @param field (object) field definition
// @param values (object) current edit values for the record
// @return (object) valueIcons for the editor
// @visibility external
// @group imageColumns
//<
getEditorValueIcons : function (field, values) {
    return  field.editorValueIcons || field.valueIcons;
},

//> @method listGrid.getEditorValueIconWidth()
// Returns the width for any valueIcon for a field when it is displayed in the editor
// while editing some record.<br>
// Returns +link{listGridField.editorValueIconWidth} if specified - otherwise
// +link{listGridField.valueIconWidth} or +link{listGridField.valueIconSize}
// @param field (object) field definition
// @return (number) width for the value icon to show in the editor
// @visibility internal
// @group imageColumns
//<
// Don't return listGrid.valueiconWidth / size - this is just a default and likely to break
// form items with standard valueIconSizes, such as checkboxes.
getEditorValueIconWidth : function (field) {
    if (field.editorValueIconWidth != null) return field.editorValueIconWidth;
    return (field.valueIconWidth != null ? field.valueIconWidth : field.valueIconSize);
},

//> @method listGrid.getEditorValueIconHeight()
// Returns the height for any valueIcon for a field when it is displayed in the editor
// while editing some record.<br>
// Returns +link{listGridField.editorValueIconHeight} if specified - otherwise
// +link{ListGridField.valueIconHeight} or +link{listGridField.valueIconSize}
// @param field (object) field definition
// @return (number) height for the value icon to show in the editor
// @visibility internal
// @group imageColumns
//<
getEditorValueIconHeight : function (field) {
    if (field.editorValueIconHeight != null) return field.editorValueIconHeight;
    return field.valueIconHeight != null ? field.valueIconHeight : field.valueIconSize;
},

//> @method listGrid.setEditorValueMap() ([A])
//
// Set a valueMap to display for this field while editing.<br>
// This method sets the +link{ListGridField.editorValueMap, field.editorValueMap} property -
// note that if  +link{ListGrid.getEditorValueMap()} has been overridden it may not make use
// of this property.
// @group editing
// @param fieldID   (object | number | field name)  Field object or identifier
// @param   map     (object)    ValueMap to apply to the field
// @visibility external
//<
setEditorValueMap : function (fieldID, map) {
    var fieldNum = this.getColNum(fieldID),
        field = this.getField(fieldID),
        fieldName = field[this.fieldIdProperty];
    field.editorValueMap = map;
    if (this._editorShowing) {
        var rowNum = this.getEditRow(),
            editRecord = this.getEditedRecord(rowNum, fieldNum);
        // Apply the valueMap to the edit form field - note that we retrieve it via the
        // getter method in case it has been overridden.
        this._editRowForm.setValueMap(fieldName, this.getEditorValueMap(field, editRecord));
    }

},

//> @method listGrid.getEditorType()  ([A])
//
//  Returns the form item type (Class Name) to display for a field when it is displayed in the
//  editor while editing some record.<br>
//  Default implementation will return field.editorType if specified.
//  If not specified, the default form item for the appropriate data type will be displayed
//  - can be overridden to provide a different specific form item type for some field based on
//  the record/field data.
//
//  @param  field   (ListGridField)    field definition field for which we need a valueMap
//  @param  values  (object)    current edit values for the record (may be null, if editing a
//                              new record)
//  @return         (string)  form item type for the edit field
//
//  @group editing
//  @see getEditorProperties
//  @visibility external
//<
getEditorType : function (field, values) {

    // determining type: editorProperties, being most specific, wins.  Otherwise
    // field.editorType, otherwise, you get the default editor picked
    // for field.type (which is the field's *data* type, not editor type).
    // NOTE: editorProps.type will always refer to the form item type, not the data type.
    // NOTE: "formItemType" is a legacy synonym of "editorType"
    
    var props = this.getEditorProperties(field, values);
    var editorProperties = isc.addProperties({}, field, field.editorProperties, props);

    // Use the static method on DynamicForm to get the editorType for this field.
    // Pass this ListGrid in as a parameter so the method can examine
    // this.longTextEditorThreshold and this.longTextEditorType.
    return isc.DynamicForm.getEditorType(editorProperties, this);
},

//> @method listGrid.getEditorProperties()
// Get the default properties for editor form items displayed while editing some field.
// Overriding this method allows developers to dynamically customize the form item displayed in
// an editable grid, based on the cell being edited.
// <P>
// Note: you should set +link{formItem.editorType,editorType} in the returned properties to
// control the type of form item that is used.
// 
// @param field (ListGridField) field whose properties are needed
// @return      (Object) default properties for the field
//
// @see getEditorType
// @visibility external
//<
// Overridden in RecordEditor

getEditorProperties : function (editField, editedRecord, rowNum) {
    return isc.addProperties({}, this.editorProperties, editField.editorProperties);
},

//> @method listGrid.getEditRowItems()  (IA)
//
//      Given a record to edit, return an appropriate array of dynamicForm item init blocks
//
//  @group  editing
//
//  @param  record  (object)    Record to be edited
//  @param  rowNum  (number)    index of the row being edited
//  @param  fieldNum (number)   index of the field on which the 'startEditing' occurred (typically
//                              used as a focus field)
//  @return         (array)     Array of DynamicForm item object instantiation blocks
// @visibility internal
//<
// Note: if editByCell is false, and we're incrementally rendering, we only create form items
// for the visible set of fields.

getEditRowItems : function (record, rowNum, fieldNum, singleCell) {
    var body = this.body;
    // if we haven't created the body yet, don't create any form items - they'll get set up
    // at draw, and updated at redraw.
    if (body == null) return [];

    // The set of fields for the form is basically this.fields, with some custom properties, such
    // as 'editorType'
    var firstEditable, lastEditable,
        widths = [],
        items = [];

    var editedRecord = this.getEditedRecord(rowNum, fieldNum);

    // create an array of the fields we want to work with
    var editFields;
    if (singleCell) editFields = [this.getField(fieldNum)]
    else editFields = this.getDrawnFields();

    widths = this.getDrawnFieldWidths(record, editFields);
    if (editFields != null) {
        for (var i = 0; i < editFields.length; i++) {

            // (Set up each item as a property-value map)
            
            
            var colNum = this.getColNum(editFields[i]);
            var item = this.getEditItem(editFields[i], record, editedRecord, rowNum, colNum, widths[i])
            if (item == null) continue;

            items[items.length] = item;
        }
    }
    return items;

},

getDrawnFields : function () {

    if (!this.body) return null;

    var drawnFields = [], body = this.body;
    var ff = this.frozenFields, fLeft = this.freezeStart();

    if (ff && fLeft) {
        // this assumes that we are not dealing with incremental column rendering of frozen
        // fields (should be true as not scrollable)
        drawnFields.addList(ff);
    }

    var firstVisible, lastVisible;
    
    if ((body._firstDrawnCol == null) || !body.isDrawn() || body.isDirty() || body._redrawing) {
        var drawnRange = body.getDrawArea();
        firstVisible = drawnRange[2];
        lastVisible = drawnRange[3];
    } else {
        firstVisible = body._firstDrawnCol;
        lastVisible = body._lastDrawnCol;
    }
    if (ff && fLeft) {
        firstVisible += ff.length;
        lastVisible += ff.length;
    }
    for (var i = firstVisible; i <= lastVisible; i++) {
        drawnFields.add(this.fields[i]);
    }

    if (ff && !fLeft) {
        drawnFields.addList(ff);
    }
    return drawnFields
},

getDrawnFieldWidths : function (record, fields) {
    // Allow the developer to pass in the fields to return widths for
    if (!fields) fields = this.getDrawnFields();

    if (!fields) return null;
    // apply the width from the fieldWidths array
    var completeWidths = this.getEditFormItemFieldWidths(record),
        widths = [];
    for (var i = 0; i < fields.length; i++) {
        widths[i] = completeWidths[fields[i].masterIndex];
    }
    return widths;
},

// getEditItem()
// returns an individual property block for edit-form form item.

// Helper methods to be applied to pop up text area items to specially process keydown and
// keypress events.  Fired in the scope of the pop up text area

_popUpTextAreaItemKeyPress : function (item, keyName, characterValue) {
    return this.grid.editorKeyPress(this, keyName, characterValue);
},
_popUpTextAreaItemKeyDown : function (item, keyName, characterValue) {
    return this.grid.editorKeyDown(this, keyName, characterValue);
},

// On focus in a pop up text area item, ensure that we have updated the current edit cell info.
// This handles the case where we got no elementFocus on the PUTA directly - happens if the
// PUTA has no focusable element itself.

_popUpTextAreaItemFocus : function () {
    var form = this.form, lg = this.grid,
        rowNum, colNum, fieldName, fieldChanged;
    if (lg._editorShowing) {
        rowNum = lg._editRowNum;
        // don't worry about editByCell case- for the pop up textareaitem to have got focus we
        // must have already shown it, meaning we must already know which field is being edited
        if (!lg.editByCell) {
            rowNum = lg._editRowNum;
            fieldName = this.getFieldName(),
            colNum = lg.fields.findIndex(lg.fieldIdProperty, fieldName);

            fieldChanged = (lg._editColNum != colNum);
            // If the user has clicked in another field in the edit form, fire editField on
            // the appropriate field
            if (fieldChanged) {
                // store the new edit cell
                lg.setNewEditCell(rowNum, colNum);
                // fire 'cellEditEnd' to save / validate before moving to the new cell
                lg.cellEditEnd(isc.ListGrid.EDIT_FIELD_CHANGE);

            }
        }
    }
},

_getPopUpTextAreaTop : function () {
    var grid = this.grid,
        fieldName = this.getFieldName(),
        rowNum = grid.getEditRow(),
        style = grid.getCellStyle(grid.getRecord(rowNum), rowNum, grid.getColNum(fieldName)),
        rowTop = grid.getRowPageTop(rowNum) +
                 isc.Element._getTopBorderSize(style) + isc.Element._getTopPadding(style);
    return rowTop;
},

_checkboxClick : function (a,b,c,d) {
    if (!this.hasFocus) {
        var lg = this.grid;
        lg.setNewEditCell(this.rowNum, this.colNum);
        lg.cellEditEnd(isc.ListGrid.EDIT_FIELD_CHANGE);
        // and force cellEnterOnFocus, so when the (delayed) focus
        // handler fires, we get a cellEnter
        this._cellEnterOnFocus = true;
    }

    return this.invokeSuper("CheckboxItem", "handleClick", a,b,c,d);
},



// handleEditorChanged()
// Fired when the changed() handler fires for any of our edit items.
// Allows us to perform validation on change
handleEditorChanged : function (item) {
    
    if (this._drawingItem == item) return;
    var fieldName = item.getFieldName(),
        field = this.getField(fieldName),
        validateOnChange;
    
    if (field && field.validateOnChange != null) validateOnChange = field.validateOnChange;
    else validateOnChange = this.validateOnChange;
    
    var rowNum = this.getEditRow();
    if (rowNum == null || rowNum != item.rowNum) return;

    if (validateOnChange) {

        // Note: we don't always update the editValue for the cell when the change handler
        // fires on the edit item - instead we usually update when the user moves to a new cell.
        // However, validateCell(), like most other APIs that interact with the editValues,
        // will update the edit value for the cell if it's stale before performing validation.
        this.validateCell(rowNum, fieldName, false, true);

    // We support form items changing their value after they've lost focus - EG:
    // delayed "Tab" autoComplete for databound comboBoxItems.
    // In this case if we're validating or saving by cell we need to perform an update now
    // (as we won't get an editor exit event to react to).
    } else if (!item.hasFocus && !this.editByCell) {

        if (item.isDrawn() && item.isVisible()) {
            this.storeUpdatedEditorValue(false, item.colNum);

            if (this.saveByCell && this.autoSaveEdits) {
                // Essentially we're saving for the same reason as if the user had
                // taken focus from the field.
                var editCompletionEvent = isc.ListGrid.EDIT_FIELD_CHANGE;
                this.saveEdits(editCompletionEvent, null, rowNum, item.colNum);
            } else if (this.validateByCell) this.validateCell(rowNum, fieldName);

        }
    } else {
        // Update the ruleContext
        var contextValues = {};
        contextValues[fieldName] = item.getValue();
        this._provideEditRecordToRuleContext(contextValues);
    }

},

// Override for the (internal) handleChanged method so we can be notified when the
// user changes an edit cell's form item value.
_editorHandleChangedOverride : function (a,b,c,d) {
    
    this.invokeSuper(this.getClassName(), "handleChanged", a,b,c,d);

    if (!this.destroyed) this.grid.handleEditorChanged(this);

},

_editorGetAutoComplete : function () {
    var grid = this.grid;
    // This would imply something like a destroyed form item - so just ignore it.
    if (!grid) return null;

    var field = grid.getField(this.getFieldName());
    if (field.autoComplete != null) return field.autoComplete;
    if (grid.autoComplete != null) return grid.autoComplete;
    return this.Super("_getAutoCompleteSetting", arguments);
},


_timeEditorTypes:{time:true, TimeItem:true},
_$time:"time",
_dateEditorTypes:{date:true, DateItem:true},
_datetimeEditorTypes:{datetime:true, dateTime:true, DatetimeItem:true, DateTimeItem:true},
_$date:"date",
_$datetime:"datetime",

popUpTextAreaEditorTypes:{popUpTextArea:true, PopUpTextAreaItem:true},
_checkboxEditorTypes:{checkbox:true, CheckboxItem:true},
_$boolean:"boolean",
_$checkbox:"checkbox",
_$CycleItem:"CycleItem",
_selectEditorTypes:{select:true, SelectItem:true},


_commonEditorStringMethodsFromField:["change", "changed", "defaultDynamicValue"],
_commonEditorStringMethods:["change", "changed", "defaultDynamicValue",
                            "keyPress", "click",
                            // Not sure if showIf / enableIf would be set on editors - more
                            // likely to set canEdit:false for the cell
                            "showIf", "enableIf"],
// getEditItem()
// returns a config block for an item to be displayed in the edit form.
// 'updateOnly' parameter implies we're going to take the returned properties and
// apply them to an existing form item, so no need to include standard handlers
// or properties that wouldn't be applied to a live item such as editorType

getEditItem : function (editField, record, editedRecord, rowNum, colNum, width, updateOnly) {
 
    var item = {};

    item.width = width;
    // Hang some properties onto the form item so keypress handers (etc.) written onto
    // the form item can readily access details about the edit:
    item.record = record;
    item.rowNum = rowNum;

    item.colNum = colNum;

    item.getGlobalTabIndex = function () {
        if (!this.containerWidget) return this.Super("getGlobalTabIndex", arguments);
        return this.containerWidget.getTabIndex();
    };

    // the error icons will be written directly into the form item (so no need to
    // adjust the size of the edit item to account for them).

    // Set the "name" of the item
    var fieldName = this.getEditorName(rowNum, editField);
    item[this.fieldIdProperty] = fieldName;

    // Also copy the dataPath across if present
    var dataPath = this.getEditorName(rowNum, editField, true);
    if (dataPath && dataPath != fieldName) {
        item.dataPath = dataPath;
    }

    // copy the title (won't be visible but needed for ARIA)
    if (editField.title != null) item.title = editField.title;
    // Use the accessor function to get the valueMap for the item
    // This allows override of visible options on a per cell basis
    // Note that we pass in the edit values, rather than the record's saved values - we want
    // the valueMap to update as edits are performed
    
    item.valueMap = this.getEditorValueMap(editField, editedRecord);
    // if "multiple" is set on the field, apply it directly to the item.
    // Of course if multiple were set on the DataSource field it'd get picked up by the item
    // automatically.
    if (editField.multiple != null) item.multiple = editField.multiple;

    // If field.canEdit is explicitly set at the component level, set it on the item.
    // This is required for cases where we default canEdit to false at the DS level
    // (fields derived from other DSs etc) but we have custom logic to allow editing
    // so should override this setting at the component level...
    if (editField.canEdit != null) item.canEdit = this.canEditCell(rowNum, colNum);

    if (editField.disabled != null) item.disabled = editField.disabled;

    // If the field has a specified optionDataSource, pass that through to the editor too,
    // along with the valueField / displayField properties
    
    
    if (editField.valueField != null) item.valueField = editField.valueField
    if (editField.displayField != null) item.displayField = editField.displayField
    if (editField.optionDataSource) item.optionDataSource = editField.optionDataSource
    if (editField.optionFilterContext) item.optionFilterContext = editField.optionFilterContext
    if (editField.optionCriteria) item.optionCriteria = editField.optionCriteria
    if (editField.optionOperationId != null) item.optionOperationId = editField.optionOperationId;

    // apply valueIcons and related properties to the editor
    // Note that we allow different value icons in the editor from the icons displayed in the
    // static cell
    item.valueIcons = this.getEditorValueIcons(editField, editedRecord);
    
    var valueIconWidth = this.getEditorValueIconWidth(editField),
        valueIconHeight = this.getEditorValueIconHeight(editField);
    if (valueIconWidth) item.valueIconWidth = valueIconWidth;
    if (valueIconHeight) item.valueIconHeight = valueIconHeight;
    
    if (editField.valueIconClick != null) {
        item.valueIconClick = this._editorValueIconClickFunction;
    }
    
    item.imageURLPrefix = (editField.editorImageURLPrefix || editField.imageURLPrefix);
    item.imageURLSuffix = (editField.editorimageURLSuffix || editField.imageURLSuffix);
    // back compat only:
    item.baseURL = editField.baseURL;
    item.imgDir = editField.imgDir;
    // Pick up icon-related properties from the edit field (if any set)
    // (most of these will be undef, so pick up standard defaults from item type)
    var undef;
    if (editField.icons !== undef) item.icons = editField.icons;
    if (editField.showPickerIcon !== undef) item.showPickerIcon = editField.showPickerIcon;
    if (editField.pickerIconSrc !== undef) item.pickerIconSrc = editField.pickerIconSrc;
    if (editField.pickerIconWidth !== undef) item.pickerIconWidth = editField.pickerIconWidth;
    if (editField.pickerIconHeight !== undef) item.pickerIconHeight = editField.pickerIconHeight;

    // Generic icon properties are unlikely to be set on a per-field basis, but handle them anyway
    if (editField.defaultIconSrc !== undef) item.defaultIconSrc = editField.defaultIconSrc;
    var iconHeight = (editField.editorIconHeight || editField.iconHeight);
    if (iconHeight !== undef) item.iconHeight = iconHeight
    var iconWidth = (editField.editorIconWidth || editField.iconWidth);
    if (iconWidth !== undef) item.iconWidth = iconWidth;
    if (editField.iconPrompt !== undef) item.iconPrompt = editField.iconPrompt;
    if (editField.iconHSpace !== undef) item.iconHSpace = editField.iconHSpace;
    if (editField.iconVAlign !== undef) item.iconVAlign = editField.iconVAlign;

    // ValueIcons properties:
    // Setting showValueIconOnly before getting editor type ensures we get back a cycle item
    // if appropriate rather than a select.
    if (this.showValueIconOnly(editField)) {
        if (editField.editorProperties == null) editField.editorProperties = {};
        editField.editorProperties.showValueIconOnly = true;
    }

    // If pickListWidth / fields is defined on the field object, pass it through to the item:
    if (editField.pickListWidth != null) item.pickListWidth = editField.pickListWidth;
    if (editField.pickListFields != null) item.pickListFields = editField.pickListFields;

    // Apply editor[Text]Formula to item
    if (editField.editorFormula != null) item.formula = editField.editorFormula;
    if (editField.editorTextFormula != null) item.textFormula = editField.editorTextFormula;

    // Set textAlign to match field alignment (required so text within text items etc reflects
    // horizontal alignment even though the item will be sized to take up all the space in the
    // cell).
    item.textAlign = this.getFieldCellAlign(editField, this.isRTL())

    
    if (editField.editorProperties != null) {
        for (var i = 0; i < this._commonEditorStringMethods.length; i++) {

            var prop = this._commonEditorStringMethods[i],
                value = editField.editorProperties[prop];
            // convert both "action" objects and strings
            if (value != null && !isc.isA.Function(value)) {
                var stringMethodReg = isc.FormItem._stringMethodRegistry;
                editField.editorProperties[prop] =
                    value = isc.Func.expressionToFunction(stringMethodReg[prop], value);
            }
            if (value != null) editField.editorProperties[prop] = value;
        }
    }

    // This block applies field.change, field.changed, and field.defaultDynamicValue
    for (var i = 0; i < this._commonEditorStringMethodsFromField.length; i++) {

        var prop = this._commonEditorStringMethodsFromField[i];
        if (editField.editorProperties && editField.editorProperties[prop] != null) {
            continue;
        }
        var value= editField[prop];
        if (value != null) {
            if (editField.editorProperties == null) editField.editorProperties = {};
            if (!isc.isA.Function(value)) {
                var stringMethodReg = isc.FormItem._stringMethodRegistry;

                value = isc.Func.expressionToFunction(stringMethodReg[prop], value);
            }
            editField.editorProperties[prop] = value;
        }

    }

    item.valueIconLeftPadding = this.getValueIconLeftPadding(editField);
    item.valueIconRightPadding = this.getValueIconRightPadding(editField);

    // A re-used FormItem should not retain the internal last formula calculation value  
    item._lastFormulaValue = null;

    // if we're updating an existing item in place we don't need to reapply standard handlers,
    // or any properties which can't be updated on the fly (like editorType)
    if (!updateOnly) {
        // Pick up autoCompletion settings from the grid in preference to any default settings
        // on the form item
        item._getAutoCompleteSetting = this._editorGetAutoComplete;
        item.autoCompleteCandidates = editField.autoCompleteCandidates;
        item.uniqueMatch = editField.uniqueMatch;

        // containerWidget should point to the ListGrid body (or frozen body if appropriate)
        // this ensures that 'formItem.isVisible()' tests the visibility of this widget, rather than
        // the DynamicForm managing the form's values.
        item.containerWidget = (!this._suppressedFrozenFields && editField.frozen)
                                ? this.frozenBody : this.body;

        item.grid = this;
        
        // validateOnChange: validation of edits is performed by the grid, not the editForm.
        // Override the internal 'handleChanged()' method to notify us if the edit item value
        // is changed by the user. The grid then checks for validateOnChange, and if appropriate
        // performs validation of the cell.
        item.handleChanged = this._editorHandleChangedOverride;

        // Apply a keyDown handler to all items.
        // Allows us to kill native tab navigation in Safari
        item.keyDown = function (item, form, keyName) {
            // check if form is still valid. It could happen that the startEditing() has moved
            // the editor to a new row, but the browser is sending the "keyPress" notification
            // after this has happened
            if (this.form == null) return;

            return this.form.grid.editorKeyDown(item, keyName);
        }

        // Apply an inactiveEditorHTML handler for mouseDown so we can switch edit rows on mouseDown
        // on inactive editor HTML.
        // This handles switching edit rows when alwaysShowEditors is true and the user mouseDowns
        // on a row other than the current edit row.
        
        item.inactiveEditorMouseDown = function (inactiveContext, itemInfo) {
            if (inactiveContext && (inactiveContext.grid == this.form.grid.getID()) &&
                inactiveContext.rowNum != null && inactiveContext.colNum != null)
            {
                // check first if form is still valid. It could happen that the startEditing() has moved
                // the editor to a new row, but the browser is sending the notification
                // after this has happened
                if (this.form == null) return;

                this.form.grid.startEditing(inactiveContext.rowNum, inactiveContext.colNum);
            }
        }

        
        item.handleMouseDown = function () {
            var rv = this.Super("handleMouseDown", arguments);
            
            var cell = this._setLGEditCellForFocus();
            this._fireLGEditorEnter(cell[0], cell[1]);
            return rv;
        }

        item.type = editField.type;
        // pick a form item type appropriate for embedded editing

        // explicit specification
        item.editorType = this.getEditorType(editField, record);
        var eT = item.editorType;

        
        item.browserAutoCorrect = false;

        // Pass specified "displayFormat", "dateFormatter" and "timeFormatter" through to the
        // edit item verbatim - FormItem knows how to handle these.
        if (editField.dateFormatter != null) item.dateFormatter = editField.dateFormatter;
        if (editField.timeFormatter != null) item.timeFormatter = editField.timeFormatter;
        if (editField.displayFormat != null) item.displayFormat = editField.displayFormat;

        var inputFormat = this._getDateInputFormat(editField);
        if (inputFormat) item.inputFormat = inputFormat;

        // for date items, use the text field rather than the 3 selects
        if (this._dateEditorTypes[eT] == true || this._datetimeEditorTypes[eT] == true ||
            (editField.type == this._$date && eT == null))
        {
            item.editorType = (this._datetimeEditorTypes[eT] == true? this._$datetime : this._$date);
            item.useTextField = true;
            // This improves the appearance for this item type
            item.cellPadding = 0;
            // Don't apply a style to the sub items' cells - we don't want padding, etc.
            item.itemCellStyle = null;
            // have the picker icon butt up against the text box.
            item.pickerIconHSpace = 0;

        }

        if (this._timeEditorTypes[eT] == true) {
            item.editorType = this._$time;
            var ds = this.getDataSource();
            if (ds && ds.allowAdvancedCriteria == false) item.allowExpressions = false;
        }

        //>PopUpTextAreaItem
        // For pop-up textArea type editors, apply the keyPress handling code to the textArea<b></b>
        if (this.popUpTextAreaEditorTypes[eT] == true) {
            // PopUpTextAreaItems are a subclass of staticTextItems. Override the default textBoxStyle
            // to match the hack - suppress "over" styling when getting the cell style since we
            // always suppress it on the edit row once the editor is showing
            item.getTextBoxStyle = function () {
                var grid = this.grid,
                    record = grid.getCellRecord(this.rowNum,this.colNum);
                this.textBoxStyle = grid.getCellStyle(record, this.rowNum,this.colNum);
                return this.Super("getTextBoxStyle", arguments);
            }

            // notification when the grid's cell style changed so we can update our textBoxStyle
            item.gridCellStyleChanged = function (record, rowNum, colNum, newStyle) {
                var textBox = this._getTextBoxElement();
                if (textBox) {
                    textBox.className = this.textBoxStyle = newStyle;
                }
            }

            // suppress doubled borders etc
            
            item.textBoxCellCSS = isc.Canvas._$noStyleDoublingCSS

            // Apply the custom keydown & keypress handlers to the pop up text area's textArea
            item.textAreaKeyDown = this._popUpTextAreaItemKeyDown;
            item.textAreaKeyPress = this._popUpTextAreaItemKeyPress;
            // Override getTextAreaTop() - rather than sticking to the top of the form item (which
            // may not line up with other items), stick to the top of the cell.
            item.getTextAreaTop = this._getPopUpTextAreaTop;
            // default popUpOnEnter to true.
            if (item.popUpOnEnter == null) item.popUpOnEnter = true;

            // react to text area focus as we would to item focus for other items
            // so we know what cell the user is editing
            item.textAreaFocus = this._popUpTextAreaItemFocus;
        }
        //<PopUpTextAreaItem

        // Don't show label for checkboxes by default.
        if (this._checkboxEditorTypes[eT] == true || (editField.type == this._$boolean && eT == null)) {
            if (item.showLabel == null) item.showLabel = false;
            // Also verify that the item has focus on click.
            // Required for IE where focus is asynchronous and would occur after the click changed
            // the value
            
            if (item.handleClick == null) {
                item.handleClick = this._checkboxClick;
            }
        }

        // Default to overflow:"auto" for richTextItem editors. Otherwise we find they typically
        // overflow into the next column
        if (eT == "RichTextItem" || eT == "richText") {
            if (item.overflow == null) item.overflow = "auto";
        }

        item.elementFocus = this._editFormItem_elementFocus;
        item._setLGEditCellForFocus = this._editFormItem_setLGEditCellForFocus;
        item._fireLGEditorEnter = this._editFormItem_fireLGEditorEnter;

        // By default set 'canTabToIcons' to false for edit fields
        // can be overridden on a per-field basis
        item.canTabToIcons = false;

        // override 'focusInItem' to manage selection
        // - we need more complicated behavior than the standard 'selectOnFocus'.
        //   If we started editing via editOnKeypress we will have updated the value of the item
        //   so should set the cursor at the end of the item value. Otherwise, just select on focus.
        // refocusAfterRedraw override prevents this from clobbering selection when its a straight
        // redraw of the item and it already has a meaningful selection set.
        item.focusInItem = this._editFormItem_focusInItem;
        item._refocusAfterRedraw = this._editFormItem_refocusAfterRedraw;
    }

    // Allow for developer specified defaults / properties for this field
    
    var propertyDefaults = this.getEditorProperties(editField, record, rowNum);
    isc.addProperties(item, propertyDefaults);
    // if this grid is databound, any other properties specified in the DS will be picked
    // up by the form during databinding
    return item;
},


// A method to be applied to edit items as "valueIconClick"
_editorValueIconClickFunction : function (form,item,value) {
    var field = this.grid.getField(this.name);
    var rowNum = this.grid.getEditRow(), colNum = this.grid.getEditCol();
    var record = this.grid.getCellRecord(rowNum, colNum);
    isc.Func.replaceWithMethod(field, "valueIconClick",
                                     "viewer,record,recordNum,field,rawValue,editor");
    var returnVal = field.valueIconClick(this.grid, record, rowNum, field, value, this);
    if (returnVal == false) return false;
    // Handle the case where a formItem subclass has a meaningful valueIconClick installed
    // directly.
    return this.Super("valueIconClick", arguments);
},
    


// focusInItem override for edit form items.
_editFormItem_focusInItem : function () {
    this.Super("focusInItem", arguments);
    this.grid._updateEditorSelection(this);
},

// Override _refocusAfterRedraw()
// This handles setting the selection on the item to whatever it was before redraw().
// Don't allow this to get clobbered by _updateEditorSelection
_editFormItem_refocusAfterRedraw : function () {
    this._suppressGridTextSelection = true;
    this.Super("_refocusAfterRedraw", arguments);
    this._suppressGridTextSelection = false;
},

// helper to return the editItem name for some cell
getEditorName : function (rowNum, editField, returnDataPath) {
    // accept a colNum or a field object
    editField = this.getField(editField);
    if (!editField) return null;
    if (returnDataPath && editField.dataPath) {
        return editField.dataPath;
    }
    return editField[this.fieldIdProperty];
},

getTrimmedFieldDataPath : function (field) {
    // convert whatever we were passed (object, string, index) to a field object
    var fieldObj = this.getField(field);
    // If the conversion failed assume we were passed a string we can just use.
    if (fieldObj == null) return field;
    if (fieldObj.dataPath) {
        return this._trimDataPath(fieldObj.dataPath);
    } else {
        return field.name;
    }
},


_editItemStringMethodCache:{},

//> @method listGrid.refreshCell()
//  @include    gridRenderer.refreshCell()
//  @example calculatedCellValue
//<
// override refreshCell just to pass the additional params through to refreshCellValue()
refreshCell : function (rowNum, colNum, refreshingRow, allowEditCellRefresh) {
    if (rowNum == null) {
        
        this.logInfo("ListGrid.refreshCell(): first parameter rowNum not present, returning");
        

        return;
    }
    if (!this.isDrawn() || !this.body) return;

    var body = this.getFieldBody(colNum);

    // If the body is already marked for redraw, allow that to handle updating the cell
    if (body.isDirty()) {
        this.logDebug("refresh cell redrawing body", "gridEdit");
        body.redraw("refresh cell");
        // return false to indicate that we did not update the cell in place, but forced a
        // redraw (used to make 'refreshRow' more efficient.
        return false;
    }

    if (this._alwaysShowEditors(this.getField(colNum),true)) {
        this._clearingInactiveEditorHTML(rowNum,colNum);
    }

    var bodyColNum = this.getLocalFieldNum(colNum);
    body.refreshCellStyle(rowNum, bodyColNum);
    // refresh the value too unless it's already been refreshed as part of styling
    if (!body.shouldRefreshCellHTML()) {
        this.refreshCellValue(rowNum, colNum, refreshingRow, allowEditCellRefresh);
    }
},


_pendingCellRefreshDelay: 100,
_pendingCellRedrawThreshold: 0.2,
markCellForRefresh : function (rowNum, colNum) {
    if (rowNum == null) {
        
        this.logInfo("ListGrid.refreshCell(): first parameter rowNum not present, returning");
        

        return;
    }
    if (!this.isDrawn() || !this.body) return;

    // no need for incremental strategy if body is already dirty
    var body = this.getFieldBody(colNum);
    if (body.isDirty()) return;

    var grid = this;

    
    if (!this._pendingCellsToRefresh) this._pendingCellsToRefresh = [];
    var pendingCells = this._pendingCellsToRefresh;

    // add the new cell to our pending list of cells to refresh
    var foundCell = false;
    for (var i = 0; i < pendingCells.length; i++) {
        var cell = pendingCells[i];
        if (cell[0] == rowNum && cell[1] == colNum) {
            foundCell = true;
            break;
        }
    }
    if (!foundCell) pendingCells.add([rowNum, colNum]);

    // if a callback is already set up, we're done; otherwise set it up
    if (this._pendingCellRefreshTimer) return;
    this._pendingCellRefreshTimer = isc.Timer.setTimeout(function () {
        // clear state up front; use closure variables below
        delete this._pendingCellRefreshTimer;
        delete this._pendingCellsToRefresh;

        if (body.isDirty()) return;

        // if a lot of cells must be refreshed, just redraw the entire GridBody instead
        var drawArea = body.getDrawArea();
        if (isc.isAn.Array(drawArea)) {
            var nTotalCells = (drawArea[1] - drawArea[0] + 1) *
                              (drawArea[3] - drawArea[2] + 1);
            if (pendingCells.length > nTotalCells * grid._pendingCellRedrawThreshold) {
                return body.redraw("markCellForRefresh");
            }
        }

        for (var i = 0; i < pendingCells.length; i++) {
            var cell = pendingCells[i];
            grid.refreshCell(cell[0], cell[1]);
        }

    }, this._pendingCellRefreshDelay);
},

cancelPendingCellRefresh : function () {
    isc.Timer.clear(this._pendingCellRefreshTimer);
    delete this._pendingCellRefreshTimer;
    delete this._pendingCellsToRefresh;
},

// refreshCellValue overridden to handle refreshing cells within the edit row
// If we are showing an edit form item for this cell:
// - if the form item is present in the DOM, and has focus:
//   - we must save out it's element value (may be dirty)
//   - blur the item without firing the handler
// - rewrite the HTML for the cell (including the form item)
// - inform the form item that it has been written out / redrawn in the DOM
// - reset the element value
// - if the item had focus, re-set focus (and selection).

refreshCellValue : function (rowNum, colNum, refreshingRow, allowEditCellRefresh) {
    if (!this.isDrawn() || !this.body) return;

    var body = this.getFieldBody(colNum),
        bodyColNum = this.getLocalFieldNum(colNum);

    // If we need to delay the refresh, fire again after a delay
    if (!body._readyToRefreshCell(rowNum, bodyColNum)) {
        this.delayCall("refreshCellValue", [rowNum, colNum, refreshingRow, allowEditCellRefresh]);
        return;
    }
    // Handle the case of showing an edit form field for this cell.
    
    var editFieldName = this.getEditorName(rowNum, colNum),
        fieldName = this.getFieldName(colNum),
        form = this._editRowForm,
        editItem, cellHasFocus = false,
        cellShowingEditor, cellWillShowEditor;
    if (form) {
        var editItem = form.getItem(editFieldName),
            rowHasEditor = (this._editorShowing && rowNum == this.getEditRow());
        // sanity check if the colNum on the edit item doesn't match the colNum of the
        // cell we're refreshing, it doesn't relate to this cell.
        // This occurs in CubeGrids where we have one record per cell
        if (editItem && editItem.colNum != colNum) editItem = null;

        if (rowHasEditor) {
            // whether there is currently an editor in the cell
            cellShowingEditor = (editItem && editItem.isDrawn());
            // whether there will be an editor in the cell after refresh
            cellWillShowEditor = this.canEditCell(rowNum, colNum);
            if (editItem != null && form.hasFocus) {
                var formFocusItem = form.getFocusSubItem();
                cellHasFocus = (formFocusItem == editItem ||
                               (editItem.items && editItem.items.contains(formFocusItem)));
            }
        // catch the case where we're clearing out a drawn item
        
        } else if (editItem && editItem.rowNum == rowNum) {
            cellWillShowEditor = false;
            cellShowingEditor = editItem.isDrawn();
        }
    }

    
    if (!allowEditCellRefresh && (cellHasFocus && cellShowingEditor && cellWillShowEditor))
    {
        return;
    }
    // If there is a visible editor in this cell, update it's value and blur before redrawing
    if (cellShowingEditor) {
        
        this.getUpdatedEditorValue();
        if (editItem != null) {
            if (cellHasFocus) {
                // Note - if the item will be visible after this method, silently blur and
                // refocus. Otherwise allow the blur handler to fire, since we won't be
                // restoring focus.
                if (cellWillShowEditor) {
                     form._blurFocusItemWithoutHandler();
                }
                else editItem.blurItem();
            }
            // If this method will redraw a form item, notify it now
            if (cellWillShowEditor) editItem.redrawing();
            else editItem.clearing(true);
        }
    } else {
        if (editItem != null && cellWillShowEditor) {
            editItem.drawing(true);
        }
    }
    
    delete body._drawnEditItems;
    // Call the body's method to update the HTML of the cell:
    body.refreshCellValue(rowNum, bodyColNum);
    if (editItem && (cellShowingEditor || cellWillShowEditor)) {
        // Call our method to fire the appropriate 'drawn()' / 'redrawn()' / 'cleared()'
        // notification on the edit item.

        
        if (cellWillShowEditor) this._drawingItem = editItem;

        this._editItemsDrawingNotification(editItem, null, body);
        if (cellWillShowEditor) {
            // restore the element value (since it's not written out with the element)
            
            editItem.setValue(this.getEditDisplayValue(rowNum, colNum));
            delete this._drawingItem;
            // restore focus if it had focus
            
            if (cellHasFocus) {
                editItem._suppressGridTextSelection = true;
                form._focusInItemWithoutHandler(editItem);
                editItem._suppressGridTextSelection = false;
            }
        }
    }
},


//> @method listGrid.refreshRow()
// @include gridRenderer.refreshRow()
//<
refreshRow : function (rowNum) {
    if (!this.body || !this.isDrawn()) return;

    // If the body is already dirty, allow the redraw to handle updating the row.
    var frozenFields = this.frozenFields && this.frozenFields.length > 0;
    // If deriveVisibleFields is called, and then this method fires before the grid has redrawn
    // we won't  have created the frozen body. Treat this case like frozenFields is false;
    if (frozenFields && !this.frozenBody) frozenFields = false;

    
    //var dirty = this.body.isDirty() ||
    //            frozenFields ? (this.frozenBody.isDirty() || this.bodyLayout.isDirty()) : false;
    var dirty = false;
    if (this.body.isDirty()) dirty = true;
    if (frozenFields && !dirty) {
        if (this.frozenBody.isDirty() || this.bodyLayout.isDirty()) dirty = true;
    }

    if (dirty) {
        var bodyWidget = frozenFields ? this.bodyLayout : this.body;
        return bodyWidget.redraw("refresh row");
    }

    if (this._editorShowing && this._editRowForm != null) {
        this.logInfo("refresh row: " + rowNum, "gridEdit");
    }

    // just call 'refreshCell' on all drawn cells
    if (frozenFields) {
        for (var i = 0; i < this.frozenFields.length; i++) {
            this.refreshCell(rowNum, this.getFieldNum(this.frozenFields[i]), true);
        }
    }

    var firstVisible = this.body._firstDrawnCol,
        lastVisible = this.body._lastDrawnCol;

    for (var i = firstVisible; i <= lastVisible; i++) {
        var colNum = this.getFieldNumFromLocal(i, this.body);
        this.refreshCell(rowNum, colNum, true);
    }
},

//> @method listGrid.startEditingNew() (A)
//
// Start editing a new row, after the last pre-existing record in the current set of data.
// <P>
// This new row will be saved via the "add" +link{group:dataSourceOperations,DataSource
// operation}.
// <P>
// See the +link{group:editing,Grid Editing overview} and also the
// +link{group:unsavedRecords,Editing Unsaved Records overview} for context about how unsaved
// records behave.
// <P>
// You can optionally pass <code>newValues</code> which are the initial values for the newly
// added record.  See also +link{listGridField.defaultValue} as a means of setting default
// values every time the user begins editing a new record, for instance, by pressing downArrow
// on the last normal record in the grid when +link{listEndEditAction} is "next".
// <P>
// If editing is already underway elsewhere in the grid, startEditingNew() behaves just like
// +link{startEditing()}.
//
// @group  editing
//
// @param  [newValues] (Map | Record)  Optional initial set of properties for the new record
// @param  [suppressFocus] (Boolean) Whether to suppress the default behavior of moving focus
//                                   to the newly shown editor.
// @see    startEditing()
// @visibility external
//<
startEditingNew : function (newValues, suppressFocus) {

    // force editing on if it's not configured for any field, but a programmatic call is made
    if (!this.canEdit && !(this.completeFields || this.fields).getProperty("canEdit").or()) {
        this.canEdit = true;
    }

    
    if (isc.isAn.Array(this.data) && this.data.length == 0 &&
        this.dataSource && !this.shouldSaveLocally())
    {
        this.fetchData(null, null, {_suppressFetch:true});
        this.data.setFullLength(0);
    }

    // The new row will be added to the end of the current set of rows
    
    
    var newRowNum = this.body ? this.body.getTotalRows() : this.getTotalRows();

    // If we're showing the 'edit new record' row, ensure we insert the record over that row,
    // rather than inserting after that row.
    if (this.showNewRecordRow) newRowNum -= 1;

    if (!this.useCellRecords && newValues != null) {
        // if this grid is using rowRecords (ListGrid), set the edit values before calling
        // findNextEditCell - rowRecords only need the rowNum to store editValues and doing 
        // that first for LG means the new values are made available to getEditedRecord()
        // immediately (eg, before findNextEditCell(), below, starts calling canEditCell())
        this.setEditValues(newRowNum, isc.addProperties({}, newValues), true);
    }

    var newEditCell = this.findNextEditCell(newRowNum, 0, 1, true, true, true);

    // newEditCell can be null if canEditCell returned false for all fields!
    if (newEditCell == null) {
        this.logInfo("startEditingNew() failed to find any editable fields in this grid.",
                     "gridEdit");
        if (!this.useCellRecords && newValues != null) {
            // setEditValues() was called above, but there were no fields to edit - clear 
            // the editSession
            this._clearEditValues(newRowNum, null, false);
        }
        return;
    }

    if (this.useCellRecords && newValues != null) {
        // Suppress displaying the new edit values - handled by 'startEditing', which will show
        // the edit form for the row.
        this.setEditValues(newEditCell, isc.addProperties({}, newValues), true);
    }

    // fall through to 'startEditing()' -- handles any current edit in another cell.
    this.startEditing(newEditCell[0], newEditCell[1], suppressFocus);
},

//> @method listGrid.updateEditRow()  (IA)
//
// Internal method to update the set of form fields written into the ListGrid body's
// currently editable row (after a call to editRow()).
// - Updates the values of the form items
// - Focuses in the appropriate item
//
//  @group  editing
//
//  @param  rowNum      (number)    Row number to update.
//
//  @visibility internal
//<
updateEditRow : function (rowNum) {
    // if updateEditRow is called on a delay, by the time this update occurs, we may have moved
    // on to another row.
    if (this._editRowNum != rowNum || !this._editRowForm) {
        //this.logWarn("updateEditRow bailing, update was for row: " + rowNum +
        //             " current editRow is " + this._editRowNum);
        return;
    }

    // update the item values of the edit form.
    
    this._editRowForm.setItemValues();
    // Clear out the _setValuesPending flag
    delete this._editRowForm._setValuesPending;
    this._editRowForm._waitingOnUpdate = false;
},

// shouldFixRowHeight()
// Internal method allowing 'fixedRecordHeights' to be overridden for individual rows in the
// GridRenderer.
// Currently only used for row-level editing.
// When row-level editing is enabled, we want to allow the row showing the embedded editor to
// expand to accommodate it's contents regardless of this.fixedRecordHeights
//

shouldFixRowHeight : function (record, rowNum) {

    // if this row is being edited, don't vertically clip
    // (Note check for != false rather than == true, as if lg.canEdit is unset, we support
    // editing on fields where canEdit is explicitly set to true)
    if (this.canEdit != false && this._editorShowing && rowNum == this._editRowNum) {
       return false;
    }
    return this.fixedRecordHeights;
},

//--- helpers for edit flow methods

// Provide unique identifiers to be used to identify the edit flow.

_getNextEditFlowID : function () {
    if (this.__lastEditFlowID == null) this.__lastEditFlowID = isc.timeStamp();
    return this.__lastEditFlowID ++;
},

// internal helper method for click outside editor - avoids us having to determine the appropriate
// cell's value in a click-mask event handler type stringMethod.
_handleClickOutsideEditor : function () {
    // If we're modal editing and the user clicked on the grid body, remember the
    // cell coordinates of the click.
    // This ensures that if the row-height changes when we hide the editor, we still 
    // treat this as a click on the appropriate target cell (which may have jumped to a new position)
    if (this.modalEditing) {
        var target = isc.EH.getTarget();
        if (target == this.body || target == this.frozenBody) {
            var rowNum = target.getEventRow(),
                colNum = target.getEventColumn();
            target._maskedMouseDownCell = [rowNum, colNum];
        }
    }
    this.cellEditEnd(isc.ListGrid.CLICK_OUTSIDE);
},

// Retrieving / updating editValues.
// We store copies of edited values locally for multiple records in the _editSessions
// object.  This allows us to hang onto edit values for more than one edited record at a time
// - required for records that have been edited but not yet saved, either because a save is
// in process, but hasn't returned from the server, and 'waitForSave' is false, or because a
// save failed with validation errors, and stopOnErrors is false.



// value to display in a cell for which there may be edit values present.

// Note: optional 'record' parameter passed by 'getEditDisplayValues' only.
getEditDisplayValue : function (rowNum, colNum, record) {
    
    var undef;
    // If 'record' is not passed, determine it from rowNum, colNum now.
    if (record === undef) record = this.getCellRecord(rowNum, colNum);

    // use the edit value for the cell if present
    var value = this._getEditValue(rowNum, colNum);
    if (value === undef) {
        if (record != null) {
            
            value = this.getRawCellValue(record, rowNum, colNum);
        }
    }
    // If a formatter is defined for the editor values, apply it now
    value = this._formatEditorValue(value, record, rowNum, colNum);
    return value;
},

// Internal method to fire developer defined 'formatEditorValue' methods at either the Grid or
// Field level.

_formatEditorValue : function (value, record, rowNum, colNum) {
    // If this is a new row, the record passed in will be null -
    // In this case pass the edit values to the formatter instead
    
    if (record == null) record = this._getEditValues(rowNum, colNum);

    // If a field-level formatter is defined, apply it.
    var field = this.fields[colNum];

    if (field && field.formatEditorValue != null) {
        
        isc.Func.replaceWithMethod(field, "formatEditorValue",
                                            "value,record,rowNum,colNum,grid");
        value = field.formatEditorValue(value, record, rowNum, colNum, this);
    // Only apply a Grid-level formatter if no formatter exists at the field level.
    } else if (this.formatEditorValue != null) {
        value = this.formatEditorValue(value, record, rowNum, colNum);
    }
    return value;
},

//> @method listGrid.getEditValuesID()
//
//  Given either a rowNum, a set of primary key values,
//  returns a unique identifier for the set of temporary locally stored edit values for some
//  record being edited.
//  If passed the editValuesID, it will just be returned.
//
//  @group  editing
//  @visibility advancedInlineEdit
//  @param  ID (number | object | string)    Identifier for editValues for which we need to
//                                           return the unique editValuesID.
//  @return (string)   Unique identifier for the set of editValues.
//<

getEditValuesID : function (ID) {
    if (ID == null || this._editSessions == null) return null;

    if (isc.isA.String(ID) && this._editSessions[ID] != null) return ID;

    // rowNum (common case)
    if (isc.isA.Number(ID)) {
        return this._editRowMap[ID];
    }

    // handle primary keys object OR the edit data object itself
    for (var i in this._editSessions) {
        var data = this._editSessions[i];
        if (data == ID) return i;
        var pk = data._primaryKeys;
        if (pk && this.comparePrimaryKeys(pk, ID)) {
            return i;
        }
    }

    return null;
},

// getEditSession - returns the edit data object for some row.
// This contains the editValues, the rowNum (if known), any validation errors, and primary
// keys for the edited record.
getEditSession : function (editDataID, colNum) {
    // editDataID can be a rowNum, a primary key or an editValuesID string.
    if (this._editSessions == null) return null;

    if (!isc.isA.String(editDataID)) editDataID = this.getEditValuesID(editDataID, colNum);
    return this._editSessions[editDataID];
},

// getEditSessionRowNum   - given an edit data object, or an ID for an edit data object, returns
// the rowNum of the record associated with the data.
// May be null if we're editing a new row on the end of the list, or with a paged result-set
// if we don't yet know the rowNum for the record.
getEditSessionRowNum : function (editDataID) {
    editDataID = this.getEditSession(editDataID);
    return (editDataID != null ? editDataID._rowNum : null)
},

getEditSessionColNum : function (editDataID) {
    editDataID = this.getEditSession(editDataID);
    // Note that the _colNum will be unset if we have 1 record per row
    return (editDataID != null ? editDataID._colNum : null)
},

//> @method listGrid.getAllEditRows()
// Returns an array of every rowNum for which we have pending (unsubmitted) edits.
// This will return records that have been marked as removed (see +link{listGrid.markRecordRemoved()}
// as well as records with unsaved changes to field values.
//  @group  editing
//  @visibility external
//  @return (Array of int) Array of rowNums for rows with edit values pending submission.
//<

getAllEditRows : function (getIds) {
    return this.getAllEditCells(getIds, true);
},


getAllEditCells : function (getIds, rowsOnly) {
    var registry = this._editSessions,
        cells = [];
    if (!registry) return cells;

    if (getIds) return isc.getKeys(this._editSessions);

   
    for (var i in registry) {
        var rowNum = registry[i]._rowNum;
        // Convert "1" to 1, etc.
        
        rowNum = parseInt(rowNum);
        if (rowNum == null || rowNum < 0 || isNaN(rowNum)) continue;
        if (rowsOnly) cells[cells.length] = rowNum
        else {
            var colNum = registry[i]._colNum;
            // If rowNum only was stored on the cell, use the special getRowEditColNum() to
            // figure out the colNum in question
            if (colNum == null) {
                colNum = this._editorShowing && (rowNum == this.getEditRow())
                                    ? this.getEditCol() : this.getRowEditColNum(rowNum);
            }
            if (colNum != null && !isc.isA.Number(colNum)) colNum = parseInt(colNum);
            cells[cells.length] = [rowNum, colNum];
        }
    }
    return cells;
},

//> @method listGrid.getEditValues()
// Returns the current set of unsaved edits for a given row being edited.
//
//  @param  valuesID (number | Object)  rowNum of the record being edited, or an Object
//                                      containing values for all the record's primary keys
//  @return (object)   Current editValues object for the row.  This contains the current
//                     edit values in {fieldName1:value1, fieldName2:value2} format.
//  @group  editing
//  @visibility external
//<
//  @param [colNum] (number) colNum of the record being edited. Only required if valuesID
//                           is passed in as a rowNum, and we're displaying one record per cell
//                          as in a +link{CubeGrid}

getEditValues : function (valuesID, colNum) {
    if (valuesID == null) {
        return this.logWarn("getEditValues() called with no valuesID. "
                + (this.logIsDebugEnabled("gridEdit") ? this.getStackTrace() : ""));
    }

    
    
    if (this._initializingEditValues) return {};

    // handle being passed a 2 element array [rowNum,colNum] since this is the format we
    // accept for setEditValues()
    if (colNum == null && isc.isA.Array(valuesID)) {
        colNum = valuesID[1];
        valuesID = valuesID[0];
    }

    // If we're showing an editor for this row, ensure that the current value in the
    // edit field is present in the editValues we return.
    
    var rowNum = (isc.isA.Number(valuesID) ? valuesID : this.getEditSessionRowNum(valuesID));
    if (this._editorShowing && (this.getEditRow() == rowNum)) {
        this.storeUpdatedEditorValue();
    }

    
    var values = {};
    this.combineRecords(values,this._getEditValues(valuesID, colNum));
    if (values != null) {
        delete values[this.recordRemovedProperty];
    }
    return values;
},

// Retrieve the stored edit values for some row (or null)
// Unlike the public method, this will not first update the editVals with the current value
// from the editForm (if showing)
_getEditValues : function (valuesID, colNum) {
    // we may be passed the editValues object, in which case we're passing it back again,
    var editSession = this.getEditSession(valuesID, colNum);
    return editSession != null ? editSession._editValues : null;
},

//> @method listGrid.getEditedRecord()
// Returns the combination of unsaved edits (if any) and original values (if any) for a given
// row being edited.
// <P>
// The returned value is never null, and can be freely modified.
//
// @param  valuesID (number | Object)  rowNum of the record being edited, or an Object
//                                      containing values for all the record's primary keys
// @return (Object) A copy of the record with unsaved edits included
// @group  editing
// @visibility external
//<

getEditedRecord : function (rowNum, colNum, suppressUpdate) {
    if (rowNum == null) return this.logWarn("getEditedRecord() called with no valuesID");

    // the valuesID allows for rowNum independent data storage - if passed a valuesID
    // determine resolve to rowNum/colNum here so we can get a pointer to the record object
    if (!isc.isA.Number(rowNum)) {
        rowNum = this.getEditSessionRowNum(rowNum);
        colNum = this.getEditSessionColNum(rowNum);
    }

    var record = this.getCellRecord(rowNum, colNum),
        // respect the parameter to avoid checking the edit form for updates
        editValues = suppressUpdate ? this._getEditValues(rowNum, colNum)
                                    : this.getEditValues(rowNum, colNum);

    // don't hang the "removed" flag onto the record.
    if (editValues != null) {
        
        //delete editValues[this.recordRemovedProperty];
    }

    var rtn = {},
        baseRecordCopy = {};
    // Combine a recursive copy of the base data, not the base data itself; if we don't do this,
    // the combined record includes pointers to any sub-objects in the base data, so values in
    // the base data will get overwritten by the combination process.  Note, this.getEditForm()
    // may well return null for some uses of this method, but it's OK because 
    // DBC._duplicateValues() now copes with being passed a null component (it just performs a 
    // straight schemaless dup)
    isc.Canvas._duplicateValues(this.getEditForm(), record, baseRecordCopy);
    this.combineRecords(rtn, baseRecordCopy);
    this.combineRecords(rtn, editValues);
    if (rtn.__ref) rtn.__ref = null;
    
    return rtn;
},

//> @method listGrid.getEditedCell()
// Returns the current value of a cell. If the cell has an outstanding edit value, this will
// be returned, otherwise the underlying value of the record will be returned.
//
// @param  record (number | Object)  rowNum of the record being edited, or an Object
//                                      containing values for all the record's primary keys
// @param field (number | string) colNum or fieldName of the cell
// @return (any) Current edit value, or underlying value for the cell
// @group  editing
// @visibility external
//<
getEditedCell : function (record, field) {
    if (record == null || field == null)
        return this.logWarn("getEditedCell() called with no record / field parameter");

    var editValues = this.getEditValues(record, field),
        rowNum = isc.isA.Number(record) ? record : this.getEditSessionRowNum(record),
        colNum = isc.isA.Number(field) ? field : this.getFieldNum(field),
        record = this.getCellRecord(rowNum, colNum);

    var editFieldName = this.getEditorName(rowNum, this.getField(colNum))
    var undef;

    if (editValues && editValues[editFieldName] !== undef) return editValues[editFieldName];
    return record ? record[editFieldName] : null;
},

// When we attempt to save an edit remember the edit values
// We use this to perform intelligent change detection while pending a save on the server
rememberSubmittedEditValues : function (valuesID, colNum) {
    
    var editSession = this.getEditSession(valuesID);
    if (editSession != null) {
        editSession._submittedValues = isc.addProperties({}, editSession._editValues);
    }
},

// retrieve the last set of editValues submitted to the server.
getSubmittedEditValues : function (valuesID, colNum) {
    var editSession = this.getEditSession(valuesID, colNum);
    return editSession != null ? editSession._submittedValues : null;
},

hasSubmittedEditValues : function (valuesID, colNum) {
    var vals = this.getSubmittedEditValues(valuesID, colNum);
    return vals != null && !isc.isA.emptyObject(vals);
},

// Clear the stored "submitted edit values"
// called from editFailedCallback method - oldValues object is required so we don't clear
// the submitted editValues if they have been modified since the (failed) save was committed
// a case we can only hit if 2 overlapping saves have been kicked off.
clearSubmittedEditValues : function (valuesID, oldValues) {
    var editSession = this.getEditSession(valuesID);
    if (editSession == null) return;
    var submittedVals = editSession._submittedValues;
    if (!submittedVals) return;

    for (var field in oldValues) {
        if (submittedVals[field] == oldValues[field]) delete submittedVals[field];
    }
    if (isc.isA.emptyObject(submittedVals)) editSession._submittedValues = null;
},



//> @method listGrid.createEditValues()
//
// This method creates a new set of editValues for a row at the end of the list, and returns
// the editValuesID which can subsequently be passed to any of the following methods as a
// unique identifier (in place of the 'rowNum' parameter where appropriate):
// 'setEditValue()', 'getEditValues()', 'getEditValue()', 'getEditValues()', 'clearEditValue()'
// and 'clearEditValues()'.<br>
// The new edit values will be displayed at the end of the list.
//
//  @param  values       (any)       New values for the row
//  @visibility advancedInlineEdit
//<

createEditValues : function (values) {
    var rowNum = this.body.getTotalRows();
    // set up the edit values, and display them in the listGrid (don't pass the
    // suppressDisplay param)
    
    this.setEditValues(rowNum, values);
    return this.getEditValuesID(rowNum);
},



// initializeEditValues() - helper method to set up empty edit vals for some
// record
initializeEditValues : function (rowNum, colNum, displayNewValues, recalculateSummaries) {
    // If we don't have edit values for this record, set them up.
    // (we can use the internal method - we know we don't have outstanding edits in the
    // edit form at this point, as the editor should have been hidden)
    if (this._getEditValues(rowNum, colNum) == null) {
        this._initializingEditValues = true;
        // *If* this is a new record, pick up any specified 'initialValues' per field
        
        var initialVals = {};
        if (this.getCellRecord(rowNum, colNum) == null) {
        
            var gridFields = this.getAllFields();
            for (var i = 0; i < gridFields.length; i++) {
                if (gridFields[i] && gridFields[i].initialValue != null) {
                    
                    isc.Canvas._saveFieldValue(gridFields[i].dataPath || gridFields[i].name, null,
                                              gridFields[i].initialValue, initialVals, this, true);
                }
            }
        }
        this.setEditValues([rowNum, colNum], initialVals, !displayNewValues, !recalculateSummaries);
        delete this._initializingEditValues;
        //this.logWarn("editValues for row: " + rowNum + " are now: " + this.echo(this.getEditValues(rowNum)));
    }
},


//> @method listGrid.setEditValues()
//
// This method sets up a set of editValues for some row / cell.  It differs from
// 'setEditValue()' in that:<br>
// &nbsp;- it takes values for multiple fields<br>
// &nbsp;- it clears out any previous edit values for the record<br>
//
//  @param rowNum (number) Row number for the record being edited
//  @param values (Object) New values for the row
//
// @visibility external
//<
// @param   suppressDisplay (boolean)   Additional internal parameter to suppress updating the
//                                      affected row to display the new edit values.
// Note that the first param may be a 2 element array of rowNum, colNum for one record-per-cell
// data models (documented in CubeGrid)

setEditValues : function (rowNum, editValues, suppressDisplay, suppressSummaryRecalc) {
    var colNum;
    if (isc.isAn.Array(rowNum)) {
        colNum = rowNum[1];
        rowNum = rowNum[0];
    }

    if (!isc.isA.Number(rowNum)) {
        this.logWarn("setEditValues() called with bad rowNum: " + this.echo(rowNum));
        return;
    }

    // Default to an empty set of values - if the user wants to entirely clear an editValues
    // object, they should use 'clearEditValue(s)' instead.
    if (editValues == null) editValues = {};

    var oldEditValues, changedFields, addedRow = true;
    if (!suppressDisplay) {

        var record = this.getCellRecord(rowNum, colNum);
        if (record == null) record = {};
        else addedRow = false;

        oldEditValues = this.getEditValues(rowNum, colNum);
        if (oldEditValues != null) addedRow = false;

        changedFields = isc.addProperties({}, oldEditValues);
        for (var i in changedFields) {
            changedFields[i] = record[i];
        }

        isc.addProperties(changedFields, editValues);

        // At this point changedFields will be a mapping of the new edit display values for
        // each field that has been changed.
    }

    if (this.logIsInfoEnabled("gridEdit")) {
        oldEditValues = oldEditValues || this.getEditValues(rowNum, colNum);
        if (!oldEditValues) {
            this.logInfo("establishing new edit session at row: " + rowNum +
                         (colNum != null ? ", col:" + colNum : "") +
                         (this.logIsDebugEnabled("gridEdit") ?
                         " with values: " + this.echo(editValues) :
                         ""), "gridEdit");
        }

    }
    // If we were marked as removed afore this method ran, continue to keep us marked as removed
    // If the user wants to drop that they can explicitly call 'discardEditValues()' or
    // 'unmarkRecordRemoved'.
    var markedAsRemoved = this.recordMarkedAsRemoved(rowNum);
    if (markedAsRemoved) editValues[this.recordRemovedProperty] = true;

    // store the new edit value
    this._storeEditValues(rowNum, colNum, editValues);
    var hasModifiedValues = changedFields != null && !isc.isAn.emptyObject(changedFields);

    if (suppressDisplay || !this.isDrawn() || !this.body) {
        if (hasModifiedValues && !suppressSummaryRecalc) {
            // unless explicitly prohibited, if suppress display is passed we do still want to
            // redraw the summary row if there is one since the calling code never handles that
            if (this.summaryRow && this.showGridSummary) this.summaryRow._recalculateSummaries()
        }
        return;
    }

    if (hasModifiedValues && rowNum < this.data.getLength()) {
        // don't refresh display when recalculating summaries - we'll refresh the row and
        // the grid summary if necessary.
        var modifiedRecord = this.data.get(rowNum);
        this.calculateRecordSummaries(modifiedRecord, null, true, true, true);
    }

    // values shown in the cells for this row are now stale (whether each cell is being edited
    // or not), so refresh.

    // if totalRows changed, it indicates that that a new edit row is being created at the end
    // of the body, hence we need to redraw to add the row to the DOM
    var shouldRedrawBody =  (addedRow || this.body.isDirty());

    if (shouldRedrawBody) {
        var editorShowing = this.isEditingRecord(rowNum, colNum) && this._editRowForm != null

        
        if (editorShowing) this._updateEditItemValues();

        this.body.markForRedraw(
            
        );
        if (hasModifiedValues && this.summaryRow && this.showGridSummary) {
            this.summaryRow.markForRedraw();
        }

    } else {
        this._displayNewEditValues(rowNum, colNum, changedFields);
    }
},

_displayNewEditValues : function (rowNum, colNum, changedFields, errors) {

    if (!changedFields || isc.isAn.emptyObject(changedFields)) {
        return;
    }

    var editorShowing = this.isEditingRecord(rowNum, colNum) && this._editRowForm != null
    // update each cell effected by the change, either by setting the form item value or
    // refreshing the cell
    
    var hasVisibleChanges = false;
    for (var fieldName in changedFields) {
        var fieldColNum = this.getColNum(fieldName);

        // If we're showing an edit item for the cell, set it's value rather than
        // refreshing the cell (and rewriting the form item HTML completely)
        var editItemDrawn;
        if (editorShowing) {
            var editItem = this._editRowForm.getItem(fieldName);
            editItemDrawn = (fieldColNum >=0 && editItem && this.canEditCell(rowNum, fieldColNum));
            
            var value = editItem ? 
                    this._formatEditorValue(
                            changedFields[fieldName], this.getCellRecord(rowNum, colNum), 
                            rowNum, fieldColNum) : 
                    changedFields[fieldName];
            
            this._editRowForm.setValue(fieldName, value);

        }
        // undrawn cell - just continue to the next field
        // [note do this after modifying edit form values]
        if (fieldColNum == -1) continue;
        hasVisibleChanges = true;

        if (!editItemDrawn) {
            this.refreshCell(rowNum, fieldColNum);
        } else if (errors && errors[fieldName]) {
            this.showCellErrors(rowNum, fieldColNum);
        }
    }
    if (hasVisibleChanges && this.summaryRow && this.showGridSummary) {
        this.summaryRow._recalculateSummaries();
        // refresh the group summary!
        this.refreshGroupSummary(rowNum);
    }

},


// Internal helper method for 'setEditValues' - actually stores the editValues object for the
// row
// Call 'setEditValues()' rather than calling this method directly.
// NOTE: editValuesId is a *highly internal* param that allows creating of a new editSession
// with a predictable ID

_storeEditValues : function (rowNum, colNum, editValues, editValuesId) {
    // Get the record for this row.  Note that this might be null as we may be adding a new
    // edit row to the end of the list.
    var record = this.getCellRecord(rowNum, colNum);

    // Assertion - if we don't have the edit data for this rowNum, we don't have the
    // edit data for this record, since 'getRecord()' will always associate the edit data
    // for some record with the appropriate rowNum, if required.
    var editSession = this.getEditSession(rowNum, colNum) ||
            this.createEditSession(rowNum, colNum, record, editValuesId);
    // Always add the primary keys to edit values for databound lists, so that they are
    // available to identify the record in saveEditedValues().  Non-databound lists are
    // expected to use object identity.
    if (this.dataSource != null) {
        // set the 'newRecord' marker on loading rows to indicate that there's no associated
        // record (and we don't have PKs for the row
        if (record == "loading") {
            editSession._newRecord = true;
        } else if (record != null) {
            var ds = this.getDataSource(),
                pkArray = ds.getPrimaryKeyFieldNames();

            for (var i = 0; i < pkArray.length; i++) {
                // do not overwrite primary key value in editValues with NULL value;
                if (record[pkArray[i]] != null) editValues[pkArray[i]] = record[pkArray[i]];
            }
        }
    }

    // set the _newRecord flag for each row without an associated record
    if (record == null) {
        editSession._newRecord = true;

        // if we have any fields with a specified default value, pick it up as a default
        // edit value.
        // (true even if the field is hidden)
        
        // If we are showing any 'enum' type fields, and
        var fields = this.completeFields || this.fields || [],
            undef;

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i],
                fieldName = field[this.fieldIdProperty];
            if (editValues[fieldName] === undef) {
                var defaultValue = this.getDefaultEditValue(fieldName, field);
                if (defaultValue != null) {
                    editValues[fieldName] = defaultValue;
                }
            }
        }
    }

    // clear out any stored editValues and copy the passed editValues into place, preserving
    // the same instance.
    for (var i in editSession._editValues) {
        delete editSession._editValues[i];
    }
    for (var i in editValues) {
        editSession._editValues[i] = editValues[i];
    }

    // Cache the last edit row - used by 'getTotalRows()'.  This value will also be
    // updated by 'clearEditValues()'
    
    if (this._lastEditRow == null || rowNum >= this._lastEditRow) {
        this._lastEditRow = rowNum
    }

    // Update the ruleContext
    if (this._editorShowing && this.getEditRow() == rowNum) {
        this._provideEditRecordToRuleContext(editValues);
    }

},

// Helper method - gets the default value to show in an editor for a field (if no explicit value
// was specified).
getDefaultEditValue : function (fieldName, field) {
    var defaultValue = field.defaultValue;
    if (defaultValue == null && this.enumCriteriaAsInitialValues &&
        field.type == "enum" && this._filterValues != null&&
        this._filterValues[fieldName] != null)
    {
        // We could check the value against this.getEditorValueMap(fieldName, null)?
        defaultValue = this._filterValues[fieldName];
    }
    return defaultValue;
},

//> @method listGrid.createEditSession() (I)
//
//  Internal method to initially set up internal, temporary edit values (and old, pre edit values)
//  for a record.
//  This method doesn't store these editValues - use 'setEditValues()' for that
//  These get updated as the record is edited, and cleared out when the edit is complete.
//
//  @group  editing
//  @visibility internal
//<

createEditSession : function (rowNum, colNum, record, editValuesID) {

    var editSession = {};
    if (record != null && record != Array.LOADING) {
        editSession._primaryKeys = this.getPrimaryKeys(record);
    }

    // A null primary key will imply we're editing a new record.
    // Assertion: when initializing edit data we will always be passed a rowNum
    
    editSession._rowNum = rowNum;
    if (this.useCellRecords) {
        editSession._colNum = colNum;
        
        if (this.getCellFacetValues) editSession._facetValues = this.getCellFacetValues(rowNum, colNum);
    }

    editSession._editValues = {};

    if (this._editSessions == null) this._editSessions = {};

    // generate an editValuesId if not passed one
    if (editValuesID == null) {
        if (this._currentEditValuesID == null) this._currentEditValuesID = 0;
        editValuesID = "_" + this._currentEditValuesID++;
    }

    this._editSessions[editValuesID] = editSession;

    // editRowMap used for retrieving edit sessions / row
    if (this._editRowMap == null) this._editRowMap = {};
    this._editRowMap[rowNum] = editValuesID;
    return editSession;
},


//> @method listGrid.setEditValue()     ([A])
//
//  Modifies a field value being tracked as an unsaved user edit.<P>
//  Use for suggested or reformatted values for edits that remain unsaved.
//
//  @group  editing
//  @visibility external
//
//  @param  rowNum      (number)    Row number (or edit values ID)
//  @param  colNum      (number | string)    Column number of cell, or name of field
//                                           having editValue updated
//  @param  value       (any)       New value for the appropriate field.
//<


setEditValue : function (rowNum, colNum, newValue, suppressDisplay, suppressChange, 
                         suppressSummaryRecalc, atomicValue)
{
    if (isc.isA.String(rowNum)) {
        this.logWarn("Warning: first parameter rowNum is a string, expecting a number");
        // bail if we have a bad rowNum
        return false;
    }
    
    var fieldName = isc.isA.String(colNum) ? colNum : this.getEditorName(rowNum, colNum, true);
    fieldName = this._trimDataPath(fieldName);
    if (isc.isA.String(colNum)) colNum = this.getFieldNum(colNum);

    // store the new edit value
    
    var changed = this._storeEditValue(rowNum, colNum, fieldName, newValue,
                           isc.CubeGrid && isc.isA.CubeGrid(this) ? true : suppressDisplay,
                                       suppressChange, suppressSummaryRecalc, atomicValue);

    // only proceed if there was a change
    if (!changed) {
        return false;
    }
    // If we were passed an atomic value, pick up the "opaque" equivalent now if necessary.
    if (atomicValue) newValue = this._getEditValue(rowNum, colNum, true);
    // If this is an edit value for a field with a specified displayField, and no
    // optionDataSource (so we're picking up the field's display value from the 'displayField' value
    // of the record), also update the edit value of the displayField on the record.
    
    
    var field = this.getField(fieldName);
    if (field && this._useDisplayFieldValue(field)) {
        var hasDisplayValue = false,
            displayValue;
        // Pick up the display value associated with this data-value from the edit-item if
        // possible.
        var editForm = this.getEditForm(),
            editItem = editForm ? editForm.getItem(fieldName) : null;

        if (editItem && this.getEditRow() == rowNum &&
            this.fieldValuesAreEqual(field, editForm.getValue(fieldName), newValue))
        {
            hasDisplayValue = true;
            displayValue = editItem.mapValueToDisplay(newValue);
        }
        // Otherwise, if we're looking at data from our own dataSource, reach into our
        // data array and see if we can find a record to lazily perform a mapping with
        // no fetch.
        if (!hasDisplayValue &&
            (field.valueField == null || field.valueField == field.name) &&
            (!field.optionDataSource ||
                isc.DS.get(field.optionDataSource) == this.getDataSource()) )
        {

            var data = this.data;
            if (isc.ResultSet && isc.isA.ResultSet(data)) data = data.localData;
            if (data) {
                var record = data.find(fieldName, newValue);
                if (record) {
                    hasDisplayValue = true;
                    displayValue = record[field.displayField];
                }
            }
        }
        if (hasDisplayValue) {
            // update the display field value on the edit form as well as storing out
            // the new value. This means that if allowEditFormValueManipulation
            // is true (so we pick up values from other fields) we won't clobber this with
            // the original value for that field.
            if (this._editRowForm && this.getEditRow() == rowNum) {

                // if displayValue was set to {formItem}.emptyDisplayValue, this means that data 
                // value is empty (i.e. is null). {formItem} here stands for items that support 
                // emptyDisplayValue, like SelectItem/ComboBoxItem/etc, for other items this check 
                // would be always false, since emptyDisplayValue would be undefined.
                // So, we do not want to save emptydisplayValue (which can be set to some string as 
                // part of UI) as displayField value if data value is empty (null), therefore we save 
                // null as value for displayField as well.
                if (editItem && displayValue == editItem.emptyDisplayValue) displayValue = null;

                this._editRowForm.setValue(field.displayField, displayValue);
            }
            this.setEditValue(rowNum, field.displayField, displayValue, suppressDisplay, true);
        // Couldn't get a display value back. Log a warning so developers understand why the
        // displayValue doesn't show up.
        } else {
            if (this.warnOnUnmappedValueFieldChange) {
                this.logWarn("Edit value updated for field:" + fieldName
                    + ". This field has 'displayField' attribute specified as '"
                    + field.displayField
                    + ((field.optionDataSource == null ||
                        isc.DataSource.get(field.optionDataSource) == this.getDataSource())
                         ? "', and no unique optionDataSource, "
                         : "', ")
                    + "so display value is derived from the "
                    + "current record. In order to ensure the display value is updated to "
                    + "reflect the new edit-value for this field, developers can explicitly update the "
                    + "edit value for the display-field on this record. To avoid seeing this method "
                    + "set listGrid.warnOnUnmappedValueFieldChange to false.");
            }
        }
    }
    // If we're not supposed to update the display we're done.
    
    if (suppressDisplay) {
        if (!suppressSummaryRecalc) {
            // unless explicitly prohibited, if suppressDisplay is passed we do still want to
            // recalculate the summaries if present since the calling code never handles that
            this.calculateRecordSummaries(this.data.get(rowNum), null, true, true, true);
        }
        return true;
    }
    // Remember which field was most recently modified - this will be passed to callbacks as
    // the 'colNum' param
    this.setRowEditFieldName(rowNum, fieldName);

    if (!isc.isA.Number(rowNum)) {
        colNum = this.getEditSessionColNum(rowNum);
        rowNum = this.getEditSessionRowNum(rowNum);

    } else if (!isc.isA.Number(colNum)) {
        
        colNum = this.getFieldNum(colNum);
    }
    var vals = {};
    vals[fieldName] = newValue;
    this._displayNewEditValues(rowNum, colNum, vals);
    return true;
},

// store an edit value, firing editorChange() notification if there was a change.
// internal helper: call setEditValue() instead


_storeEditValue : function (rowNum, colNum, fieldName, newValue, suppressDisplay, 
                            suppressChange, suppressSummaryRecalc, atomicValue)
{
    
    
    var changed = true, saveEqual = false,
        editSession, editValues, oldValue,
        undef;

    var dataPath = fieldName;
    // If we're working with a datapath, trim it (handles absolute dataPath being applied to field)

    if (dataPath.contains(isc.Canvas._$slash)) {
        dataPath = this._trimDataPath(dataPath);
    }

    editSession = this.getEditSession(rowNum, colNum)
    if (editSession != null) {
        editValues = editSession._editValues;
        // using getFieldValue() will allow us to use dataPath
        oldValue = isc.Canvas._getFieldValue(dataPath, null,
                                editValues, this, true, "edit");
    } else {
        // create a new set of edit values as necessary
        this.logInfo("creating new edit values for row: " + rowNum, "gridEdit");
        this.initializeEditValues(rowNum, colNum, !suppressDisplay, !suppressSummaryRecalc);
        editSession = this.getEditSession(rowNum, colNum);
        editValues = editSession._editValues;
    }

    // if there's no previous editValue, the old value is the original value from the
    // dataset
    if (oldValue === undef) {
        var record = this.getCellRecord(rowNum, colNum);
        oldValue = record ? isc.Canvas._getFieldValue(dataPath, null, record, this, true, "edit")
                          : null;
    
    } else saveEqual = true;

    
    
    var oldAtomicValue = oldValue, newAtomicValue = newValue;

    var field = this.getField(fieldName);
    if (field && field.type) {
        var simpleType = isc.SimpleType.getType(field.type);
        if (simpleType && simpleType.getAtomicValue != null) {
            oldAtomicValue = simpleType.getAtomicValue(oldValue, "compare");
            if (!atomicValue) newAtomicValue = simpleType.getAtomicValue(newValue, "compare");
        }
    }
    if (this.fieldValuesAreEqual(field, oldAtomicValue, newAtomicValue)) changed = false; // indicate no change

    // store the changed value
    // Note: If newValue was not passed in, clear the field value instead
    
    if (newValue === undef) {
        isc.Canvas._clearFieldValue(fieldName, editValues, this, true);
    } else if (saveEqual || changed) {
        // Don't pass the field in - we don't want to run any conversion based on type - the
        // value passed in is the actual value we want to save.
        isc.Canvas._saveFieldValue(dataPath, (atomicValue ? field : null),
                                              newValue, editValues, this, true);

        // If we were passed an atomic value, pick up the raw value we actually stored
        // before firing the change handler
        
        if (atomicValue) {
            
            newValue = isc.Canvas._getFieldValue(dataPath, null, record, this, true);
        }
    }

//     this.logWarn("edit value changed: oldValue: " + this.echo(oldValue) +
//                   ", new value: " + this.echo(newValue) +
//                   ", save equal?:" + saveEqual +
//                   " updated edit vals:" + this.echo(editValues), "gridEdit");
    // fire the change notification.
    if (changed && !suppressChange){
        this._editorChange(rowNum, colNum, newValue, oldValue);
    }

    // Update the ruleContext

    if (changed && this._editorShowing && this.getEditRow() == rowNum) {
        var contextValues = {};
        contextValues[fieldName] = newValue;
        this._provideEditRecordToRuleContext(contextValues);
    }

    return changed; // indicate change
},

// setRowEditFieldName() - used to track which field was last being edited for some set of edit values
setRowEditFieldName : function (rowNum, fieldName) {

    var editSession = this.getEditSession(rowNum);
    // Set up empty edit values if necessary
    if (!editSession) {
        var colNum = this.getColNum(fieldName);
        this.setEditValues([rowNum, colNum], null, true);
        editSession = this.getEditSession(rowNum);
    }

    if (isc.isA.Number(fieldName)) fieldName = this.getFieldName(fieldName);
    editSession._lastField = fieldName;
},

// getEditField() - given an edited row / valuesID, return the name of the last field being
// edited for that row
getRowEditFieldName : function (editValuesID) {
    var editSession = this.getEditSession(editValuesID);
    return (editSession ? editSession._lastField : null);
},

// getRowEditColNum - returns the colNum for the last edited field within some edit row
getRowEditColNum : function (editValuesID) {
    var fieldName = this.getRowEditFieldName(editValuesID);
    return fieldName ? this.getColNum(fieldName) : null;
},


//> @method listGrid.getEditValue()
//
// Returns the current temporary locally stored edit value for some field within a record
// being edited.
//
// @param  rowNum  (number)    index of the row for which the editValue should be returned
// @param  colNum (number | string) index of the field, or fieldName, for which value should be
//                              returned
// @return (any)   edit value for the field in question
// @group  editing
// @visibility external
//<

getEditValue : function (rowNum, colNum) {

    var colID = colNum
    if (isc.isA.String(colNum)) colNum = this.getColNum(colNum);
    if (this._editorShowing &&
        (this.getEditRow() == rowNum) && (this.getEditCol() == colNum))
    {
        this.storeUpdatedEditorValue();
    }
    // Note pass the original column ID (colNum or fieldName) on to the _getEditValue() method
    // since there may be no column associated with the fieldName passed in
    return this._getEditValue(rowNum, colID, true);
},

// Retrieve the stored edit value for some row / field
// (unlike the public method, this will NOT first check for the value present in the editor
// if showing)
// returnOpaqueValue parameter: If the field for which we want the edit value is of a
// simpleType with a 'getAtomicValue()' method, should we call that and extract the atomic
// value or return the raw complex object.
// Most internal usage cares about the atomic value so by default we return that, but if
// this param is passed we'll return the complex object.
_getEditValue : function (rowNum, colNum, returnOpaqueValue) {
    // Note: Edit values are a case where the distinction between a value being unset and
    // being set to null is important... One case implies the user has not edited a cell,
    // the other implies the user has cleared out an edit value from a cell...
    var vals = this._getEditValues(rowNum, colNum);
    // Return undefined rather than explicit null if the edit row doesn't have any stored
    // values
    if (vals == null) return;

    var field = this.getField(colNum);
    // pass the field to _getFieldValue() so that method can apply the 'getAtomicValue' method
    // if necessary
    if (field && !returnOpaqueValue) {
        return isc.Canvas._getFieldValue(null, field, vals, this, true, "edit");
    } else {

        // Convert the colNum to a fieldName to get the value
        var fieldID = this.getTrimmedFieldDataPath(field || colNum);
        return isc.Canvas._getFieldValue(fieldID, null, vals, this, true, "edit");
    }
},



//> @method listGrid.clearEditValue()   ([A])
//
//  Clear a field value being tracked as an unsaved user edit.<P>
//  The saved record value will be displayed in the the appropriate cell instead.
//  Will also discard any validation errors for the specified field / row.
//
//  @group  editing
//  @visibility external
//
//  @param  editValuesID (number | object)    Row number, primary keys object for the record,
//                                              or editValues object
//  @param  colNum (number | string)    Column number, or Name of field for which
//                                      the value is to be cleared
//<
// @param   suppressDisplay (boolean)   Optional internal parameter to avoid updating the
//                                      affected cell to display the field value for the record
//                                      rather than the cleared out edit value.
// Note that in LGs the second parameter can be a fieldName
// If we're dealing with a 1 record / cell data model (EG CubeGrid) we need to
// be passed either a true editValuesId as the first parameter OR a colNum and a rowNum
clearEditValue : function (editValuesID, colNum, suppressDisplay, dontDropAll) {
    var rowNum = (isc.isA.Number(editValuesID) ? editValuesID
                                               : this.getEditSessionRowNum(editValuesID));

    var fieldName = colNum;
    if (isc.isA.Number(fieldName)) fieldName = this.getEditorName(rowNum, fieldName);
    else colNum = this.getColNum(fieldName);

    // If the user is currently editing this field, ensure the current value in the edit form
    // item is stored in this.editValues before clearing it, (so that the focused field is
    // successfully cleared!)
    if (this._editorShowing) {
        if (this.getEditRow() == rowNum && this.getEditFieldName() == fieldName) {
            // Suppress change - we're about to clear the value anyway!
            this.storeUpdatedEditorValue(true);
        }
    }

    //
    // This method will remove the edit value from the appropriate editValues object
    // If that was the last editValue in the object, fall through to clearEditValues to remove
    // the entire object
    // Otherwise, if suppressDisplay is not passed:
    // - if the field had validation errors, re-style the affected cell to hide the validation
    //   style (by default a red outline)
    // - if there is an editRowForm item for the effected cell, update it's value to reflect
    //   the value of the record
    // - otherwise call refresh cell to update the static innerHTML for the cell

    var editSession = this.getEditSession(editValuesID, colNum);
    //this.logWarn("clearEditValue got editSession: " + this.echo(editSession));

    if (editSession == null) return;

    var editValues = editSession._editValues,
        hasChanges = false,
        submittedValues = editSession._submittedValues,
        errors = editSession._validationErrors,
        hadErrors = errors && errors[fieldName],
        rowNum = editSession._rowNum;

    if (editValues != null) {
        var record = this.getRecord(rowNum);
        hasChanges = isc.propertyDefined(editValues, fieldName) &&
                     ((rowNum == null || record == null) ||
                         !this.fieldValuesAreEqual(this.getField(fieldName),
                                                   editValues[fieldName], record[fieldName]));

        delete editValues[fieldName];
        if (submittedValues) delete submittedValues[fieldName];
        if (errors != null) delete errors[fieldName];

        // If there's nothing in the editValues, clear the vals for the whole row
        
        if (!dontDropAll && isc.isAn.emptyObject(editValues)) {
            this.logDebug("no edit values left for row, discarding editSession", "gridEdit");
            return this._clearEditValues(editValuesID, colNum, suppressDisplay);
        }
    }

    // If this field has a specified 'display' field, we track edit values on that field that
    // match the record with the editValue specified for this field.
    // Drop the value on the display field as well.
    
    var field = this.getField(fieldName);
    if (field && this._useDisplayFieldValue(field) && (field.displayField != fieldName)) {
        this.clearEditValue(editValuesID, field.displayField, suppressDisplay, dontDropAll)
    }

    // If the edit val isn't displayed in a cell in this grid, we're done
    // otherwise continue to update the value if it changed, and clear any errors from the
    // cell.
    
    if (suppressDisplay || rowNum == null) return;

    // Update the display:
    // - If the edit form is showing for the row always set its value for the field
    // - If the cell is visible, but we're not showing an edit form item for it, refresh the
    //   cell to display the value of the record
    // Otherwise if we had errors, refresh the cell to hide the error icons
    if (hasChanges) {
        var editItemDrawn;
        if (this._editorShowing && this.getEditRow() == rowNum) {
            var newVal = record ? record[fieldName] : null;
            this._editRowForm.setValue(fieldName, newVal);
            editItemDrawn = colNum >= 0 && this.canEditCell(rowNum, colNum) &&
                            this._editRowForm.getItem(fieldName);
        }

        if (colNum >= 0 && !editItemDrawn) this.refreshCell(rowNum, colNum);

    // If we had validation errors for the cell, call 'refreshCellStyle' to clear the
    // error hilight from the cell (only necessary if we didn't refresh the entire cell)
    } else if (hadErrors && colNum >= 0) {
        if (hadErrors) this.showCellErrors(rowNum, colNum);
    }
},

//> @method listGrid._clearEditValues()
//
//  Clear a whole row of values being tracked as an unsaved user edit.<P>
//  This should not be used for clearing out the edit values for some row after a save
//  has completed.  When a save has been successfully confirmed for some set of cell values,
//  the stored values should be cleared cell by cell using 'clearEditValue()', rather than
//  this method.
//
//  @group  editing
//  @visibility internal
//
//  @param  editValuesID      (number | object)    Identifier for the editValues to clear.
//                                                  This can be a rowNum, or a set of
//                                                  editValues (or a primary key)
//<
//  @param [colNum] (number) colNum of the record being edited. Only required if valuesID
//                           is passed in as a rowNum, and we're displaying one record per cell
//                          as in a +link{CubeGrid}
// @param   dontRefresh (boolean)   Optional internal parameter. If passed, don't update any
//                                  affected cells to display the removed edit values

_clearEditValues : function (editValuesID, colNum, dontRefresh) {
    // This method must
    // - update the central editSessions object to remove the specified set of edit values
    // - update the editRowMap if these values were mapped to a row.
    // - if this was a row beyond the end of the data for the List, shuffle subsequent
    //   temporary edit values down a rowNum
    // if refreshing to display the change:
    //   - if this was a row beyond the end of the list, it must be removed from the list:
    //      - if the editRowForm is showing for the row, it must be hidden
    //      - the body must be redrawn.
    //   - otherwise for each cell for which there was an edit value before this method must
    //     be updated.
    //      - if an edit form item is showing for the field
    //          - its value should be updated to show the record's value
    //          - if there were any validation errors for the row, the style of the relevant
    //            cells should be updated
    //      - otherwise the cell should be refreshed to show the record's value as static HTML.

    if (editValuesID == null) {
        
        return;
    }


    // If we're passed a rowNum, or primary keys, resolve to an editValuesID
    if (!isc.isA.String(editValuesID)) editValuesID = this.getEditValuesID(editValuesID, colNum);
    var editSession = this.getEditSession(editValuesID);
    

    // Bail if we can't get the object (not necessarily an error - may have already been
    // cleared)
    if (editSession == null) return;

    var rowNum = editSession._rowNum;
    if (rowNum != null) delete this._editRowMap[rowNum];
    // for cellRecords, ensure we have a valid rowNum and colNum
    if (colNum == null) colNum = editSession._colNum;

    var valuesObj = this._editSessions[editValuesID];
    // clear the object from the array
    delete this._editSessions[editValuesID];

    // Clear out the cached last edit row. Will be recalc'd lazily when required
    
    var lastRow = this._getLastEditRow();
    delete this._lastEditRow;
    // If this is a new record (not yet saved in the dataset), and we have any subsequent new
    // edit rows, we have to shuffle them down to fill the gap left by this record.
    if (rowNum != null && editSession._newRecord) {
        var editRow = this.getEditRow();

        for (var i = rowNum+1; i <= lastRow; i++) {
            var newRowObject = this.getEditSession(i);
            var oldRow = newRowObject._rowNum;
            newRowObject._rowNum = i-1;

            //this.logWarn("clearEditValues reordering temp rows." +
            //             " editSession: " + this.echo(newRowObject) +
            //             " was at row: " + oldRow);

            // No danger of putting this over another edit record, since we have already moved
            // every one.
            this._editRowMap[i-1] = this._editRowMap[i];
            delete this._editRowMap[i];
        }
        // If we're currently showing an editor for a subsequent temp-row, shift it up one row
        if (editRow != null && editRow > rowNum) this._editRowNum -= 1;

        //this.logWarn("clearEditValues: editRow was at: " + editRow +
        //             " now at: " + this._editRowNum);

        // We're clearing out edit values for an additional row beyond the end of the grid's data
        // refresh the UI if necessary
        if (!dontRefresh) {
            if (this._editorShowing) {
                    // if we're showing the inline editor for this row hide it now.
                    if (rowNum == editRow) this.hideInlineEditor();
                    // Otherwise if the edit row was AFTER this row, shuffle it up by 1 row to
                    // account for this row going away
                    else {
                        if (rowNum < editRow) this._moveEditor(editRow-1, null, "Earlier temp edit row removed");
                    }
            }
            // Redraw the body to hide the additional row.
            if (this.body) {
                var bodyContainer = this.frozenBody != null ? this.bodyLayout : this.body;
                bodyContainer.markForRedraw("clear edit values, remove row");
            }
        }

    } else if (rowNum != null && !dontRefresh) {
        // _displayNewEditValues takes an object describing the new edit values to display
        // Explicitly pass in the vals from the underlying record object so we update the
        // edit-form items
        var changedVals = {},
            record = this.data.get(rowNum);
        for (var fieldName in valuesObj._editValues) {
            changedVals[fieldName] = record ? record[fieldName] : null;
        }
        this._displayNewEditValues(rowNum, colNum, changedVals,
                                   valuesObj._validationErrors);
   }
},






//> @method listGrid.newRecordForEditValues()
// Internal method to associate a set of pending edit values with a new record in the
// dataset.<br>
// This method is required to handle the saving of a new edit row on the end of a list.
// When the save returns we need to associate the edit values with the record in the dataSet
// (which may also change the rowNum of the record).
// With background saving (waitForSave:false), after the attempted save was submitted to the
// server, further editing may have taken place.  This method will make sure any further edits
// get associated with the new record.
//
// @param editValuesId (ID)     id for the editValues which have been saved as a new record
// @param rowNum       (number) index of the newly saved record
// @visibility internal
//<


newRecordForEditValues : function (editValuesId, record) {

    
    var oldEditSession = this.getEditSession(editValuesId),
        editValues = oldEditSession._editValues;
    oldEditSession._primaryKeys = this.getPrimaryKeys(record);
    var pkFields = this.getDataSource().getPrimaryKeyFieldNames();
    for (var i = 0; i<pkFields.length; i++) {
        var field = pkFields[i];
        editValues[field] = record[field];
    }
    delete oldEditSession._newRecord;
},




// Re-associate all editValues with the appropriate rowNums for the records.
// Fired in response to dataChanged().
// This will be fired when the data is re-sorted, re-filtered, modified asynchronously from
// the server, or scrolled such that the cache is dropped when we have a partial cache.
// In any of these cases, the rowNums for each record can change (and in some cases rows can
// be entirely removed from the data cache)
// This method will attempt to match the editValues to the cached records after dataChanged()
// and update the rowNums as appropriate.  It will also take any editValues that represent
// newly created records and renumber them so they are past the new end of the dataset.
// If a record can't be found for some editValues object, there are a couple of possibilities:
// - If we have a complete cache (or local data), we know the record has gone from the dataSet
//   so we warn the user and clear out the editValues for that record
// - If we have a partial cache, the record may have gone from the resultSet (filter change,
//   for example), or it may be available in the resultSet, but not loaded in the client-side
//   cache (scrolled out of view).
//   In this case we keep the editValues around and set the _hasUnmatchedEdits flag on the
//   ListGrid.  getCellRecord() will then compare each record with the unmatched edits whenever
//   it is called, so we will re-associate the editValues with the appropriate rowNum as soon as
//   it is scrolled into view.
//   Note that editing will be dismissed if the record that was being edited vanishes in this
//   way.



// This method returns a boolean - true if any edit sessions were left intact and shifted to
// new rows, false otherwise.
_remapEditRows : function (dontMoveEditor) {

    // clear out the _lastEditRow and _hasUnmatchedEdits flags
    // - lastEditRow can get recalc'd lazily when required.
    // - we'll update _hasUnmatched edits below if required.
    delete this._lastEditRow;
    delete this._hasUnmatchedEdits;
    if (this._editSessions == null) return false;

    var remappedSession = false;

    var oldEditRow = this.getEditRow(),
        oldEditCol = this.getEditCol(),
        foundOldRecord = false;

    var lastRowNum = this.data.getLength(),
        editRowMap = {};

    // getKeys() first to avoid possible problems with key deletion during for..in (never
    // observed)
    var sessionList = isc.getKeys(this._editSessions);

    for (var i = 0; i < sessionList.length; i++) {


        var editValuesId = sessionList[i],
            editSession = this._editSessions[editValuesId];
        var oldRowNum = editSession._rowNum;

        var newCell = this._calculateEditCell(editSession, lastRowNum);
        // increment the lastRowNum if we added a row
        
        if (editSession._primaryKeys == null) lastRowNum ++;
        
        // newCell == null -> notification that we totally dropped an empty edit session
        if (newCell == null) continue;

        var newRowNum = newCell[0],
            newColNum = newCell[1];

        if (newRowNum != null && newRowNum >= 0) {

            if (newRowNum != oldRowNum) remappedSession = true;

            // we found the corresponding record in the modified dataset (or it was an unsaved,
            // newly created record)

            // Is this the current edit record?
            if (oldEditRow != null && oldEditRow == editSession._rowNum &&
                (!this.useCellRecords || (oldEditCol == editSession._colNum)))
            {
                foundOldRecord = true;
                // moveEditor will shift the edit form if necessary
                if (!dontMoveEditor) this._moveEditor(newRowNum, newColNum, "remapEditRows")
            }

            editRowMap[newRowNum] = editValuesId;

            editSession._rowNum = newRowNum;
            if (this.useCellRecords) editSession._colNum = newColNum;

        } else {

            if (oldRowNum != null && oldRowNum >= 0) remappedSession = true;

            var liveData = this.getOriginalData();
            var localSave = !this.dataSource || this.shouldSaveLocally() ||
                (isc.ResultSet && isc.isA.ResultSet(liveData) && liveData.allRowsCached());

            // drop the edit if the record being edited was clearly deleted
            // Don't blindly drop the record if we're grouped or data is a tree,
            // it may have just been hidden (folder closed) - in which case the rowNum
            // would be -1 -- use 'find' to see if the node is present in the tree
            // at all.
            if (localSave && !isc.isA.Tree(this.data) &&
                    (!this.isGrouped || !this.data.find(editSession._primaryKeys))
                )
            {
                    this.logWarn("Record:" + this.echo(editSession._primaryKeys) +
                       ", is no longer present in this List." +
                       "<br>Clearing edit values for this record.", "gridEdit");

                    delete this._editSessions[this.getEditValuesID(editValuesId)];
            } else {
                // the record could be either truly gone, or just not in the cache.  Hold onto
                // the edits hoping the record reappears (in which case we'll re-associate the
                // edit values with the record).
                // Note: If we're working with a paged result set, the data will typically have
                // disappeared because it has been scrolled out of view (due to data resort,
                // etc.) In this case it will reappear with scrolling.
                // However the data may have disappeared as it no longer matches the current
                // filter criteria.
                // We could also add a check for 'data.allMatchingRowsCached()' and handle the
                // case where we have loaded all the records for the current filter criteria
                // differently. We're much more likely to encounter the case of having loaded
                // all rows that match some criteria than caching every row in the data set.
                this.logInfo("Record:" + this.echo(editSession._primaryKeys) +
                    (localSave ? ", hidden in grouped tree data. " :
                                ", lost from local cache in paged result set. ") +
                    "Pending edits for this record will be maintained.", "gridEdit");
                delete editSession._rowNum;
                delete editSession._colNum;
                this._hasUnmatchedEdits = true;
            }
        }
    }
    // store the new editSession locations
    this._editRowMap = editRowMap;

    
    if (oldEditRow != null && !foundOldRecord && !dontMoveEditor) {
        this.hideInlineEditor(true);
    }
    return remappedSession;
},

// helper method called from dataChanged() to re-associate embeddedComponents stored in the
// grid body with the appropriate records
_remapEmbeddedComponents : function () {

    if (!this.body || this.body._embeddedComponents == null) return;

    if (this.showRecordComponents && this.recordComponentPoolingMode != "data") {
        this._remapVisibleEmbeddedComponents();
        return;
    }

    var components = this.body._embeddedComponents,
        componentCount = components ? components.length : 0,
        removeThese = [];

    // reset the _expandedRecordCount - we'll increment it if a currentRowNum is detected below,
    // and component.isExpansionComponent:true, rather than decrementing it if
    // the row is NOT present.  This handles the case of records eliminated from cache by
    // filtering.
    this._expandedRecordCount=0;
    for (var i = 0; i < componentCount; i++) {
        // get the keys for the record associated with the embeddedComponent
        var component = components[i],
            embeddedRecord = component.embeddedRecord,
            recordKeys = this.getPrimaryKeys(embeddedRecord),
            currentRowNum = component._currentRowNum,
            currentRecord = currentRowNum != null ? this.data.get(currentRowNum) : null,
            getRecord = false
        ;

        if (!(currentRecord === embeddedRecord)) {
            // only call findRowNum if the record has moved or changed
            currentRowNum = this.findRowNum(recordKeys);
            getRecord = true;
        }

        if (currentRowNum >= 0) {
            // only call data.get() for a second time if findRowNum was also called - otherwise
            // we already have the correct currentRecord
            if (getRecord) currentRecord = this.data.get(currentRowNum);
            // the record is present in the cache, rebuild the association between the record
            // and the embeddedComponent
            if (currentRecord && !this._hasEmbeddedComponents(currentRecord) ||
                    !this._getEmbeddedComponents(currentRecord).contains(component))
            {
                component._currentRowNum = currentRowNum;
                component.embeddedRecord = currentRecord;
                this._addEmbeddedComponent(currentRecord, component);
                
                if (component.isExpansionComponent) {
                    if (this.maxExpandedRecords == null ||
                        (this._expandedRecordCount < this.maxExpandedRecords))
                    {
                        this._expandedRecordCount++;
                        this._setExpanded(currentRecord, true);
                        this._setExpansionComponent(currentRecord, true);
                        if (!this.canExpandMultipleRecords) this._currentExpandedRecord = currentRecord;
                    } else {
                        // remove the 'expanded' marker from the row, and
                        // fire 'removeEmbeddedComponent' to clear up "embeddedComponent"
                        // markers on the record, etc.
                        // This will also clear the component - we still may want to
                        // destroy it below so also add to the "removeThese" list.
                        this._setExpanded(currentRecord, false);
                        this._setExpansionComponent(currentRecord, false);

                        this.removeEmbeddedComponent(currentRecord, component, true);
                        removeThese.add(component);
                        continue;
                    }
                } else {
                    // re-add to the "_recordComponents_" array on the record
                    this._addRecordComponent(currentRecord, component._currentFieldName, component);
                }
            }
        } else {
            // Note - even if indexOf returned -1,
            // the embeddedRecord may actually be non null here - either having been
            // dropped from this.data, or being a node in a closed parent in a tree.
            // Clear up the flags on the record object in this case as well.
            
            if (isc.isA.Tree(this.data)) {
                var pkVals;
                if (isc.ResultTree && isc.isA.ResultTree(this.data)) {
                    var pks = this.data.getDataSource().getPrimaryKeyFieldNames();
                    pkVals = isc.applyMask(embeddedRecord, pks);
                } else {
                    pkVals = embeddedRecord;
                }
                currentRecord = this.data.find(pkVals);
            }
            if (currentRecord == null) currentRecord = embeddedRecord;

            if (this._shouldRetainEmbeddedComponents == false ||
                    (this.showRecordComponents && this.recordComponentPoolingMode == "data") ||
                    
                    (component.isExpansionComponent)
            ) {
                if (currentRecord != null) {
                    // This is essentially a dup of code form _removeEmbeddedComponent:
                    var ids = currentRecord[this._$embeddedComponentsPrefix + this.ID];
                    if (ids != null && ids.length > 0) {
                        ids.remove(component.getID());
                    }
                    if (ids && ids.length == 0) {
                        currentRecord[this._$embeddedComponentsPrefix + this.ID] = null;
                    }
                    // remove the 'expanded' marker from the row
                    if (component.isExpansionComponent) {
                        this._setExpanded(currentRecord, false);
                        this._setExpansionComponent(currentRecord, false);
                    }
                }
                // remove the embeddedComponent from the grid body and rehash the properties
                // that track expandedRecords
                removeThese.add(component);
            }
        }

    }
    if (removeThese.length>0) {
        // get rid of any embeddedComponents that no longer map to a cached row and update the
        // associated props that track expandedRecords
        for (var i = 0; i < removeThese.length; i++) {
            var item = removeThese[i];

            // only affect expandedRecord values if we're using expansionComponents - this loop
            // now also runs for recordComponents
            if (this.canExpandRecords) {
                if (this._currentExpandedRecord && this._currentExpandedRecord == item.embeddedRecord)
                    delete this._currentExpandedRecord;
            }
            this.body._embeddedComponents.remove(item);
            if (this.shouldDestroyOnUnembed(item, this._$dataChanged)) {
                item.markForDestroy();
            } else {
                item.deparent();
            }
        }
    }
},

// helper method called from remapEmbeddedComponents() when recordComponentPoolingMode is not "data"
_remapVisibleEmbeddedComponents : function () {

    var debugLog = this.logIsDebugEnabled("recordComponents");

    if (!this.body || this.body._embeddedComponents == null) return;

    var allComponents = this.body._embeddedComponents,
        removeThese = [],
        drawArea = this.getDrawArea(),
        rowRange = [ drawArea[0], drawArea[1] ]
    ;

    if (rowRange[0] == null && rowRange[1] == null) return;

    // reset the _expandedRecordCount - we'll increment it if a currentRowNum is detected below,
    // and component.isExpansionComponent:true, rather than decrementing it if
    // the row is NOT present.  This handles the case of records eliminated from cache by
    // filtering.
    this._expandedRecordCount=0;

    var remappedCount = 0,
        inPlaceCount = 0
    ;

    if (debugLog) {
        this.logDebug("START _remapVisibleEmbeddedComponents - rowRange is: " + rowRange);
    }

    for (var i=rowRange[0]; i<=rowRange[1]; i++) {
        var record = this.data.get(i),
            recordEntries = record ? this._getRecordComponents(record) : null,
            components = recordEntries ? isc.getValues(recordEntries) : null
        ;

        if (components) {
            for (var j=0; j<components.length; j++) {
                var component = components[j];
                if (!component || component.isNullMarker) continue;
                if (component._currentRowNum == i) {
                    if (debugLog) {
                        this.logDebug(component.ID + " remains at rowNum " + i + ": no action");
                    }
                    // record is still in the same place - just ignore it
                    component._detectedInLoop = true;
                    inPlaceCount++;
                    continue;
                }

                component._currentRowNum = i;
                this._addEmbeddedComponent(record, component);
                component._detectedInLoop = true;
                remappedCount++;
                
                if (component.isExpansionComponent) {
                    if (this.maxExpandedRecords == null ||
                        (this._expandedRecordCount < this.maxExpandedRecords))
                    {
                        if (debugLog) {
                            this.logDebug("ExpansionComponent " + component.ID + " added at row " + i);
                        }
                        this._expandedRecordCount++;
                        this._setExpanded(record, true);
                        this._setExpansionComponent(record, true);
                        if (!this.canExpandMultipleRecords) this._currentExpandedRecord = record;
                    } else {
                        if (debugLog) {
                            this.logDebug("Removed expansionComponent " + component.ID + 
                                " from row " + i + ": too many expanded records");
                        }
                        // remove the 'expanded' marker from the row, and
                        // fire 'removeEmbeddedComponent' to clear up "embeddedComponent"
                        // markers on the record, etc.
                        // This will also clear the component - we still may want to
                        // destroy it below so also add to the "removeThese" list.
                        this._setExpanded(record, false);
                        this._setExpansionComponent(record, false);

                        this.removeEmbeddedComponent(record, component, true);
                        removeThese.add(component);
                        continue;
                    }
                } else {
                    if (debugLog) {
                        this.logDebug("recordComponent " + component.ID + " added at row " + i);
                    }
                }
            }
        }

    }

    if (this.recordComponentPoolingMode != "data") {
        for (var i = 0; i < allComponents.length; i++) {
            var c = allComponents[i];
            if (c._detectedInLoop) delete c._detectedInLoop;
            else {
                // don't remove rollOver/UnderCanvas
                if (c == this.currentRollOverCanvas || c == this.currentRollUnderCanvas) continue;
                if (c.isBackgroundComponent || c.isExpansionComponent) {
                    // if this is an expansion component, only remove the component if the
                    // stored record is no longer in the grid - prevents us from removing
                    // components because an expanded record was scrolled out of view
                    var r = this.getRecordIndex(c.embeddedRecord);
                    if (r >= 0) {
                        if (c.isExpansionComponent) this._expandedRecordCount++;
                    } else {
                        if (c.isExpansionComponent && c.embeddedRecord) {
                            // the component is from a record which is no longer present -
                            // remove expansionComponent references
                            this._setExpanded(c.embeddedRecord, false);
                            this._setExpansionComponent(c.embeddedRecord, false);
                        }
                        removeThese.add(c);
                    }
                } else if (c.isRecordComponent) {
                    removeThese.add(c);
                }
            }
        }
    }

    if (removeThese.length>0) {
        // get rid of any embeddedComponents that no longer map to a cached row and update the
        // associated props that track expandedRecords
        for (var i = 0; i < removeThese.length; i++) {
            var item = removeThese[i];

            // only affect expandedRecord values if we're using expansionComponents - this loop
            // now also runs for recordComponents
            if (this.canExpandRecords) {
                if (this._currentExpandedRecord && this._currentExpandedRecord == item.embeddedRecord)
                    delete this._currentExpandedRecord;
            }
            this.body._embeddedComponents.remove(item);
            if (this.shouldDestroyOnUnembed(item, this._$dataChanged)) {
                item.markForDestroy();
            } else {
                item.deparent();
            }
        }
    }

    //this.logWarn("remappedCount = " + remappedCount + "\ninPlaceCount = " + inPlaceCount);
    if (debugLog) {
        this.logDebug("END _remapVisiblEmbeddedComponents:\n\t" + 
            "remappedCount = " + remappedCount + 
            "\n\tinPlaceCount = " + inPlaceCount);
    }
},

// Helper method to update all per-cell embedded components' "_currentColNum" based on the stored
// field name for the component
// Called per body when we reorder fields, show/hide fields etc.
// Note: this method updates all embedded components. It doesn't re run any specific
// recordComponent logic to re-create recordComponents on column reorder, or to re-pool components
// that are no longer visible. This is all handled by updateRecordComponents() which fires on
// redraw.
_$columnRemap:"column remap",
_remapEmbeddedComponentColumns : function (body) {

    if (body._embeddedComponents == null) return;
    var components = body._embeddedComponents,
        fieldMap = {},
        changes = false;
    for (var i = 0; i < body.fields.length; i++) {
        fieldMap[body.fields[i].name] = i;
    }
    // clear embedded components that are no longer visible once we've iterated through
    // this loop to avoid the array length being effected.
    var componentsToClear = [];
    for (var i = 0; i < components.length; i++) {
        var fieldName = components[i]._currentFieldName;
        // this is expected - it's not a per-cell component.
        if (fieldName == null) {
            continue;
        }
        var colNum = fieldMap[fieldName];
        

        // If the field has been hidden just remove the embedded component.
        
        if (colNum == null) {
            componentsToClear[componentsToClear.length] = components[i];
        } else {
            if (components[i]._currentColNum != colNum) {
                changes = true;
                components[i]._currentColNum = colNum;
            }
        }
    }
    if (componentsToClear.length > 0) {
        for (var i = 0; i < componentsToClear.length; i++) {
            var comp = componentsToClear[i];
            if (comp.removeOnHideField) {
                body.removeEmbeddedComponent(comp.embeddedRecord, comp);
                if (this.shouldDestroyOnUnembed(comp, this._$columnRemap)) {
                    comp.markForDestroy();
                }
                // already cleared by removeEmbeddedComponent() so no need to clear() or
                // deparent() here if we didn't mark for destroy
            } else {
                
                changes = true;
            }
        }
    }

    if (changes) {
        body._placeEmbeddedComponents();
    }
},

// calculateCell - helper for remapEditRows - given an editSession determine which cell it
// currently belongs to so we can update editSession._rowNum/colNum etc
_calculateEditCell : function (editSession, lastRowNum) {
    var newRowNum, newColNum,
        pk = editSession._primaryKeys;
    // in the case of a new edit row, we want to just make sure the rowNums are off the
    // end of the data...
    if (pk == null) {
        newRowNum = lastRowNum;

    } else {

        // if the editValues consist of just primary keys, drop them unless this is the
        // editSession for the current editRow
        
        var editValues = editSession._editValues,
            hasEdits = false,
            undef;
        if (editSession._validationErrors != null &&
            !isc.isA.emptyObject(editSession._validationErrors_))
        {
            hasEdits = true;
        } else {
            for (var val in editValues) {
                if (editValues[val] != pk[val] || pk[val] === undef) {
                    hasEdits = true;
                    break;
                }
            }
        }

        if (!hasEdits && editSession._rowNum != null &&
            !this.isEditingRecord(editSession._rowNum, editSession._colNum))
        {
            this.logInfo("dropping empty editSession", "gridEdit");
            delete this._editSessions[this.getEditValuesID(editSession)];
            return null;
        }

        // look for a row with matching primary keys
        newRowNum = this.findRowNum(pk, editSession);
        // colNum will only apply when the data model shows 1 record/cell (EG CubeGrid);
        newColNum = this.findColNum(pk, editSession);
    }

    return [newRowNum,newColNum];
},

// Override _filter
// - if we have pending edits, changing the filter criteria means that the
//   edited rows may not show up in the returned set of values.
//   For windowed result sets this is true even if we're broadening our criteria, as the edited
//   row may not be in our viewport.
//   In this case if confirmDiscardEdits is true, show a dialog giving the user a chance to
//   save or discard unsaved edits.
// - if we are showing a filterEditor, update the filterEditor values to show the new criteria
_filter : function (type, criteria, callback, requestProperties, doneSaving) {

    // call setFields() for the first time, if it hasn't already been done
    // This will "complete" databinding -- Ensure that we combine our DataSource's
    // field attributes with live specified field attributes for issuing a server request.
    if (this.completeFields == null) this.setFields(this.fields);

    if (!doneSaving 
            && (this.confirmDiscardEdits || this.autoConfirmSaveEdits) 
            && this.dataSource != null)
    {
        var data = this.getOriginalData();

        if (this.hasChanges() &&
            // If the criteria is unchanged, the filter will be a no-op. In this case
            // no need to drop edit values
            
            !(isc.ResultSet && isc.isA.ResultSet(data) &&
                  data.compareCriteria(criteria, data.getCriteria()) == 0) )
        {
            this.showLostEditsConfirmation({target:this, methodName:"_continueFilter"},
                                           {target:this, methodName:"_cancelFilter"});
            this._filterArgs = {
                type:type, criteria:criteria, callback:callback,
                requestProperties:requestProperties
            }
            return;
        }
    }
    // Apply criteria to filterEditor.
    
    // If passed a filter component, resolve to actual filter values!
    var criteriaValues = criteria
    if (isc.isA.Class(criteriaValues)) {
        criteriaValues = isc.DynamicForm.getFilterCriteria(criteriaValues);
    }

    // compress the criteria - walks the entire criteria, flattens and removes 
    // unnecessary wrapper criteria - improves what can be edited in the 
    // filterEditor
    criteriaValues = isc.DS.compressNestedCriteria(criteriaValues);
    
    
    this.setFilterValues(criteriaValues, true);

    this.dataSetChanged();

    return this.Super("_filter", [type,criteria,callback,requestProperties], arguments);
},

// Completes a filter after the user has been prompted to save or discard pending edits.
_continueFilter : function () {
    var args = this._filterArgs,
        type = args.type, criteria = args.criteria, callback = args.callback,
        requestProperties = args.requestProperties;
    delete this._filterArgs;
    this._filter(type, criteria, callback, requestProperties, true);
},

// Fired when a user cancelled a filter to resolve pending edits.
_cancelFilter : function () {
    delete this._filterArgs;
},

// showLostEditsConfirmation() - this method is fired from sort / filter if there are
// outstanding unsaved edits that may be otherwise lost by the sort/filter action.
// Shows the user a dialog with options to save, discard, or cancel.
showLostEditsConfirmation : function (continueCallback, cancelCallback) {
    // these callbacks will be fired, then cleared up when the callback fries from the
    // global warn dialog.
    this._continueCallback = continueCallback;
    this._cancelCallback = cancelCallback;

    if (this.autoConfirmSaveEdits) {
        this.lostEditsCallback("save", null);
    } else {
        isc.confirm(this.confirmDiscardEditsMessage,
                    "if(window[this.targetGridID])window[this.targetGridID].lostEditsCallback(value, this);",
                    {   targetGridID:this.getID(),


                        // Show "OK", "Save" and "Cancel" buttons
                        buttons:[isc.Dialog.OK,
                                 {title:this.discardEditsSaveButtonTitle, width:75,
                                  click:"this.hide();this.topElement.returnValue('save');"},
                                 isc.Dialog.CANCEL]
                    });
    }
},

// Fired as a callback from the user selecting ok/save/cancel from the dialog displayed in
// showLostEditsConfirmation().
// Will save or discard edits as appropriate, and call any callback (used to fire the action
// after the values have been saved / discarded).
lostEditsCallback : function (value, dialog) {
    var continueCallback = this._continueCallback,
        cancelCallback = this._cancelCallback;
    delete this._continueCallback;
    delete this._cancelCallback;

    // CancelClick
    if (value == null) {
        this.fireCallback(cancelCallback);

    // Ok click
    } else if (value == true) {
        this.discardAllEdits();
        this.fireCallback(continueCallback);

    // save click
    } else if (value == "save") {
        // Pass continueCallback into saveAllEdits - we want to allow the
        // original action to continue after the save completes
        this.saveAllEdits(null, continueCallback);
    }

    // clear out the targetGrid pointer from the global warn dialog
    if (dialog) dialog.targetGrid = null;
},

// Given the primary keys for some record, return the rowNum.

findRowNum : function (primaryKeys) {

    var dataSource = this.getDataSource(),
        isAnArray = isc.isA.Array(this.data);

    // If a DataSource is present and the data object is an Array, and the 
    // target has primary key values, use findByKeys on the
    // DataSource to compute index; otherwise, call indexOf on the data.
    if (dataSource && isAnArray) {
        var pkFields = dataSource.getPrimaryKeyFields(),
            hasPKs = false;
            
        if (pkFields) {
            // getPrimaryKeyFields() returns a map of fieldName to field-object
            for (var key in pkFields) {
                if (primaryKeys[key] == null) {
                    hasPKs = false;
                    break;
                }
                hasPKs = true;
            }
        }
        // Having no primary keys is valid in some cases - a dataSource where editing
        // (to the DS) is disallowed may not have primary keys defined [and we could still allow
        // in-grid editing of local data], or we could be dealing with special data which
        // is lacking PKs for some other reason - for example a batch of new records
        // pending submission in bulk as in the BatchUploader 'preview grid'.
        // Typically this implies saveLocally will be true - log a warning if this flag is
        // not set as we may just be dealing with bad target record data
        if (!hasPKs) {
            if (!this.shouldSaveLocally()) {
                this.logWarn("findRowNum(): Attempt to find row number on dataBound grid. " +
                             "Target record has no primary keys. Typically this is only supported " +
                             "where listGrid.saveLocally is true. Specified primaryKeys are :" +
                             this.echo(primaryKeys));
            }
            // indexOf will use object identity
            return this.data.indexOf(primaryKeys);
        } else {
            return dataSource.findByKeys(primaryKeys, this.data);
        }
    }

    // ResultSet / ResultTree indexOf will look up data by PK rather than object identity
    // automatically
    return this.data.indexOf(primaryKeys);
},

// Given the primary keys for some record return the colNum of the cell displaying the
// record
// Required to support 1 record / cell data model (EG cubeGrid)
findColNum : function (primaryKeys) {
    // ListGrids never show 1 record/cell so just return -1
    return -1;
},




_moveEditor : function (rowNum, colNum, reason) {

    if (!this._editorShowing || rowNum == this._editRowNum) {
        return;
    }

    var previousRow = this._editRowNum;

    this.logInfo(reason + ": editSession: " + this.getEditValuesID(rowNum) +
                 " with values: " + this.echo(this._getEditValues(rowNum, colNum)) +
                 " was being edited at row: " + previousRow +
                 ", will now edit at row: " + rowNum, "gridEdit");
    this._editRowNum = rowNum;

    var editForm = this._editRowForm,
        items = editForm ? editForm.getItems() : null;
    if (items) {
        for (var i = 0; i < items.length; i++) {
            items[i].rowNum = rowNum;
        }
    }

},

//> @method listGrid.rowEditNotComplete()
//  Given a rowNum, return true if we have locally stored editValues for the row.  This implies
//  that it is the current edit row (an editor is showing in that row), or that it has not been
//  saved since it was edited - likely due to save / validation errors.
//  @group  editing
//  @visibility internal
//  @param  rowNum (number) index of row for which we want to determine 'edit status'
//  @return (boolean)   true if we still have edit values for the row
//<

rowEditNotComplete : function (rowNum) {
    return (this._editRowMap != null && this._editRowMap[rowNum] != null);
},

// ---------------------------------------------------------------------------------------

_editorChange : function (rowNum, colNum, newValue, oldValue) {
    
    var record = this.getCellRecord(rowNum, colNum);
    if (this.editorChange != null) this.editorChange(record,newValue,oldValue,rowNum,colNum);
    //>!BackCompat 2004.12.10
    var fieldName = this.getFieldName(colNum);
    if (this.editValueChanged != null)
        this.editValueChanged(rowNum, fieldName, newValue, oldValue);
    //<!BackCompat


    // If we are providing dynamic edit item value maps for any fields, they may return a
    // different value since their value may be dependent on the edited field.
    // Therefore we go through and determine whether we need to update the valueMap for any
    // form items visible in the rowEditForm.
    
    if (this._editorShowing && this.isEditingRecord(rowNum, colNum) && this.fields != null) {
        record = isc.addProperties({}, this._getEditValues(rowNum, colNum), record);
        var fields = !this.editByCell ? this.fields : [this.getEditField()];


        for (var i =0; i < fields.length; i++) {
            var field = fields[i],
                formItem = this._editRowForm.getItem(field[this.fieldIdProperty]);

            // We don't create form items for un-rendered fields if we're incrementally rendering
            if (formItem == null) continue;

            var valueMap = this.getEditorValueMap(field, this.getEditedRecord(rowNum, colNum, true));
            

            if (formItem.valueMap != valueMap) {
                var changed = true;
                if (isc.isAn.Array(valueMap) && isc.isAn.Array(formItem.valueMap)) {
                    changed = !valueMap.equals(formItem.valueMap);

                } else if (isc.isAn.Object(valueMap) && isc.isAn.Object(formItem.valueMap)) {
                    if (isc.getKeys(valueMap).equals(isc.getKeys(formItem.valueMap))) {
                        changed = false;
                        for (var key in valueMap) {
                            if (valueMap[key] != formItem.valueMap[key]) {
                                changed = true;
                                break;
                            }
                        }
                    }
                }
                // we're rerunning getEditorValueMap on every change of the item.
                // Its very likely that the vm will be a different object but meaningfully unchanged
                // - check for this since we don't want to call setValueMap() if unnecessary.
                // This causes a side-effect where if a multiple:true pickList is showing it'd
                // appear to auto-dismiss on every selection change.
                if (changed) formItem.setValueMap(valueMap);
            }
        }
    }
},


//> @method listGrid.getEditRow()
// Returns the index of the row being edited or <smartclient>null</smartclient>
// <smartgwt>-1</smartgwt> if there is no current edit row.
//
// @return (int) index of the current edit row
// @group  editing
// @visibility external
//<
getEditRow : function () {
    return this._editRowNum;
},

//> @method listGrid.getEditCol()
// Returns the index of the column being edited or <smartclient>null</smartclient>
// <smartgwt>-1</smartgwt> if there is no current edit column.
//
// @return (int) index of the current edit column
// @group  editing
// @visibility external
//<
getEditCol : function () {
    return this._editColNum;
},

//> @method listGrid.getEditField()
//
//  Returns the field object associated with cell currently being edited
//
//  @group  editing
//  @visibility external
//
//  @return (object)    Field object definition
//<
getEditField : function () {
    return this.getField(this.getEditCol());
},

//> @method listGrid.getEditFieldName()
//
//  Returns the field name for the current edit field
//
//  @group  editing
//  @visibility internal
//
//  @return (string) Field name
//<
getEditFieldName : function () {
    return this.getFieldName(this.getEditCol());
},


//> @method listGrid.getEditRecord()
//
//  Returns the record object currently being edited
//
//  @group  editing
//  @visibility internal
//
//  @return (object)    Current edit record object
//<
getEditRecord : function () {
    return this.getCellRecord(this.getEditRow(), this.getEditCol());
},

//> @method listGrid.cancelEditing()
//
//  Cancel the current edit without saving.
//
//  @group  editing
//  @visibility external
//<
// Called directly from cellEditEnd with escape keypress, etc.
// Exposed so may also be called programmatically by developers
cancelEditing : function (editCompletionEvent) {
    if (!this._editorShowing) return;

    // fall through to 'discardEdits' to drop the edit values and hide the editor
    // Note: that method also catches the case where alwaysShowEditors is true and avoid hiding
    // the editor.
    this.discardEdits(this.getEditRow(), this.getEditCol(), false, editCompletionEvent);

},

//> @method listGrid.cellEditEnd()
//
//  Method called on when editing ends for a cell as a result of a user interaction.
//  <P>
//  Editing may continue in another cell or row or end entirely, depending on the
//  editCompletionEvent, which represents what action the user took to end editing.
//  <P>
//  If this.shouldCancelEdit(rowNum, colNum, editCompletionEvent) returns true, the edit is
//  cancelled.
//  <P>
//  Otherwise the edit will be saved, and we'll proceed to a new cell to edit based on
//  getNextEditCell(rowNum, colNum, editCompletionEvent).
//  <P>
//  Return false from this method to notify the caller that the intended behavior failed -
//  typically this cancels the cell edit end (restoring focus to the appropriate edit-field).
//
//  @group  editing
//  @visibility internal
//
//  @param  editCompletionEvent (EditCompletionEvent)  Edit completion event constant
//                                                          indicating how edit was
//                                                          completed
//  @param  [newValue]    (any)   New Value for the edited cell. If not passed will be derived
//                                from current editor value for the edited cell.
//  @return (boolean)    False if the user should still be editing the current cell.
//<
cellEditEnd : function (editCompletionEvent, newValue) {


    // delete the _editSessionFromKeypress flag when editing completes unless the user is
    // simply using the keyboard to shift to another cell
    if (this._editSessionFromKeyPress &&
        editCompletionEvent != isc.ListGrid.TAB_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.SHIFT_TAB_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.UP_ARROW_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.DOWN_ARROW_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.LEFT_ARROW_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.RIGHT_ARROW_KEYPRESS) delete this._editSessionFromKeyPress

    var rowNum = this.getEditRow(),
        colNum = this.getEditCol();
    if (rowNum == null && colNum == null) return;

    // If we were passed a new value, store it as an editValue
    // (Otherwise the next call to getEditValue() / getEditValues()
    //  [changeEditCell / saveAndHideEditor] will pick up the current edit value
    //  from the form item)
    if (arguments.length >= 2) {
        this.setEditValue(rowNum, colNum, newValue);
    }

    //this.logInfo("cellEditEnd: editValues: " + this.echo(this.getEditValues(rowNum)) +
    //             ", old values: " + this.echo(this.getRecord(rowNum)), "gridEdit");

    
    var fieldName = this.getFieldName(colNum),
        shouldCancelEdit = this.shouldCancelEdit(rowNum, colNum, editCompletionEvent);
    if (shouldCancelEdit) return this.cancelEditing(editCompletionEvent);

    

    // get the next editCell (if null, we're done with the edit)
    var nextEditCell = this.getNextEditCell(rowNum, colNum, editCompletionEvent);
    // The 'newEditCell' is used by getNextEditCell.  Clear it out now, since we've determined
    // which cell we'll be editing.
    this.clearNewEditCell();

    // if we've no next cell to go to, we're done editing
    if (nextEditCell == null) {
        //>DEBUG
        this.logInfo("cellEditEnd: ending editing, completion event: " + editCompletionEvent,
                     "gridEdit"); //<DEBUG
        this._saveAndHideEditor(editCompletionEvent);
        return;
    }

    // prevent editing of the loading marker.  Can happen with rapid tabbing / shift-tabbing
    // with non-blocking row loading
    if (Array.isLoading(this.getCellRecord(nextEditCell[0], nextEditCell[1]))) {
        //this.logWarn("prevented edit of loading row at: " + nextEditCell);
        return false;
    }
    this._changeEditCell(editCompletionEvent, rowNum, colNum, nextEditCell[0], nextEditCell[1]);
},


// getUpdatedEditorValue()
// Retrieves the value from the current edit cell editor item
// NOTE: returns the parsed version [can be saved as a raw value to the record]
getUpdatedEditorValue : function () {
    // If we're not showing an editor return undefined - there is no edit value to save.
    if (!this._editorShowing) return;

    var editItem = this._editRowForm.getItem(this.getEditFieldName()),
        editField = this.getEditField(),
        value;
    if (editItem) {

        if (editItem._itemValueIsDirty()) editItem.updateValue();
        value = editItem.getValue();
        return this._parseEditorValue(value, editField,this.getEditRow(), this.getEditCol());

    } else {
        // no edit item, just return the saved value
        return this.getEditDisplayValue(this.getEditRow(), this.getEditCol());
    }
},

// undocumented flag: If a developer modifies the values of the editRowForm directly
// should we save out those changes.

allowEditFormValueManipulation:true,

// storeUpdatedEditorValue()
// Retrieves the value from the current edit cell editor item and stores it as an edit value
// for the appropriate row.
storeUpdatedEditorValue : function (suppressChange, editCol) {
    if (!this.isDrawn() || !this._editorShowing) return;
    
    var editRow = this.getEditRow();
    
    if (editCol == null) editCol = this.getEditCol();

    
    var editField = this.getField(editCol),
        editForm = this._editRowForm,
        editItem = this.getEditFormItem(editCol),
        value;
    if (editItem) {
        if (editItem._itemValueIsDirty()) editItem.updateValue();
        
        var itemValue = editItem.getValue();
        value = this._parseEditorValue(itemValue,
                                         editField, editRow, editCol);
        // Convert undefined to explicit null so we actually clear out the value
        // for the field if appropriate.

        var undef;
        if (value === undef) value = null;

        
        var oldVal = this._getEditValue(editRow, editCol),
            undef;
        if (oldVal === undef || !this.fieldValuesAreEqual(editField, oldVal, value)) {
            var type = isc.SimpleType.getType(editField.type);
            if (type && type.getAtomicValue != null) {
                // calling form.getValue(fieldName) rather than item.getValue() will give
                // us the opaque value - what we actually want to store.
                var opaqueValue = editForm.getValue(editItem.name);
                // If parseEditorValue changed it, we'll have to apply the change to this
                // opaqueValue of course.
                
                if (itemValue != value && type.updateAtomicValue != null) {
                    type.updateAtomicValue(value, opaqueValue);
                }
                value = opaqueValue;
            }
            this.setEditValue(editRow, editCol, value, true, suppressChange);
        }
    }
    // Pick up the entire values object from the form in case developer code directly
    // manipulated the edit-form values without going through setEditValue()
    
    if (this.allowEditFormValueManipulation) {
        var changed = false,
            formValues = editForm.getChangedValues(),
            currentValues = this.getEditDisplayValues(editRow, editCol, true),
            untestedFields = isc.getKeys(formValues);

        // If we're editing a Tree, ensure we don't attempt to store out
        // tree meta data or the children array
        
        if (isc.isA.Tree(this.data)) {
            formValues = this.data.getCleanNodeData(formValues, false);
        }

        var completeFields = {};
        this.getAllFields().map(function (field) { completeFields[field.name] = field; });
        var undef;
        for (var fieldName in currentValues) {
            untestedFields.remove(fieldName);
            
            // We already pulled the value from the current focused edit item.
            if (editField && fieldName == editField.name) continue;
            
            var field = this.getSpecifiedField(fieldName),
                fieldVal = formValues[fieldName];
            
            // Skip anything which is unpopulated in the "changed" form values object
            if (fieldVal === undef) continue;
            
            if (editForm.getItem(fieldName) != null && field) {
                fieldVal = this._parseEditorValue(fieldVal,
                                     field, editRow, this.getFieldNum(fieldName));
            }
            // do not propagate differences in user formula/summary fields
            if (field && (field.userFormula || field.userSummary ||
                          field.type == this._$summary))
            {
                
                continue;
            }

            // if the value is unchanged, carry on.
            if (this.fieldValuesAreEqual(
                    this.getSpecifiedField(fieldName), 
                    fieldVal, currentValues[fieldName]))
            {
                continue;
            }

            // if the field and value appear to be a local scribbling, skip it
            if (completeFields[fieldName] == null && fieldVal === undef) {
                continue;
            }
            // No need to worry about converting from atomic to opaque value - the
            // "values" object on the form should already be the opaque version.
            
            
            changed |= this.setEditValue(editRow, fieldName, fieldVal, 
                                         true, true, true) != false;
        }
        // Check for any field-values specified directly on the form which weren't
        // present in the original record object.
        for (var i = 0; i < untestedFields.length; i++) {
            var fieldName = untestedFields[i];
            // do not propagate changes to the user field caches!
            if (fieldName == null || fieldName == "_cache_" + this.ID) continue;

            var value = formValues[fieldName];
            // if the value is unchanged, carry on.
            if (this.fieldValuesAreEqual(
                    this.getSpecifiedField(fieldName),
                    value, currentValues[fieldName]))
            {
                continue;
            }

            // if the field and value appear to be a local scribbling, skip it
            if (completeFields[fieldName] == null && value === undef) continue;
            changed |= this.setEditValue(editRow, fieldName, value, 
                                         true, true, true) != false;
        }
        
        if (changed) {
            this.calculateRecordSummaries(this.data.get(editRow), null, true, true, true);
        }
    }
},

// Internal handler to fire user-defined editorExit handler functions
_handleEditorExit : function (editCompletionEvent, rowNum, colNum, newValue) {
    var record = this.getCellRecord(rowNum, colNum),
        field = this.getField(colNum),
        editFieldName = this.getEditorName(rowNum, field),
        returnVal = true;

    var item = this._editRowForm.getItem(editFieldName);
    //>PopUpTextAreaItem         If this is a pop-up text area, ensure the T.A. is hidden.
    if (isc.isA.PopUpTextAreaItem(item)) item.hidePopUp();  //<PopUpTextAreaItem

    // clear any selection if we're in a CubeGrid
    if (isc.CubeGrid && isc.isA.CubeGrid(this) && this.selection &&
            this.selection.anySelected()) this.selection.deselectAll();

    // NOTE: field can be null if hiding focused field
    
    if (field && field.editorExit != null) {
        isc.Func.replaceWithMethod(field, "editorExit",
                                     "editCompletionEvent,record,newValue,rowNum,colNum,grid");
        returnVal =
            (field.editorExit(editCompletionEvent, record, newValue, rowNum, colNum, this)
             != false);
    }
    if (returnVal && this.editorExit != null)
        returnVal = this.editorExit(editCompletionEvent, record, newValue, rowNum, colNum) != false;

    return returnVal;
},

// fired when the user leaves a row
_handleRowEditorExit : function (editCompletionEvent, rowNum, newValues) {

    var record = this.getRecord(rowNum);
    if (this.rowEditorExit != null)
        return (this.rowEditorExit(editCompletionEvent, record, newValues, rowNum) != false);
    // In this case there was no rowEditorExit handler defined.
    return true;

},

// Internal handler to fire user-defined editorEnter handler functions
_handleEditorEnter : function (editorItem, rowNum, colNum, value) {

    var record = this.getCellRecord(rowNum, colNum),
        fieldName = this.getFieldName(colNum),
        field = this.getField(colNum),
        returnVal = true;


    //>PopUpTextAreaItem
    // If this is a pop-up textArea editor, show the pop-up if appropriate
    
    if (isc.isA.PopUpTextAreaItem(editorItem) && editorItem.popUpOnEnter) {
        // pass in the param to put focus into the pop-up
        editorItem.showPopUp(true);
    }   //<PopUpTextAreaItem

    
    if (field && field.editorEnter != null) {
        isc.Func.replaceWithMethod(field, "editorEnter", "record,value,rowNum,colNum,grid");
        returnVal = field.editorEnter(record, value, rowNum, colNum, this) != false;
    }
    if (returnVal && this.editorEnter != null)
        returnVal = this.editorEnter(record, value, rowNum, colNum) != false;
    return returnVal;
},

_handleRowEditorEnter : function (editorItem, rowNum, editValues) {
    var record = this.getRecord(rowNum);
    if (this.rowEditorEnter != null)
        return this.rowEditorEnter(record, editValues, rowNum) != false;
    return true;
},

_validationEnabled : function () {
    if (!isc.DS) return false;
    var ds = isc.DS.get(this.dataSource);
    return !this.neverValidate &&
                    
                      !(ds && ds.useLocalValidators != null &&
                        ds.useLocalValidators == false);
},

// These methods determine what action should be taken on cell edit completion

//> @method listGrid.shouldSaveOnCellExit()
//  When a user exits a field within the current row being edited, but does not exit the edit
//  row, should a save be performed?<br>
//  Default behavior is <br>
//  - Never saveCellOnExit if this is a new edit row (has no corresponding record)<br>
//  - return this.saveByCell if defined, otherwise return true if the user is editing
//    individual cells, false if the entire row is editable (set via the editByCell property).
//
//  @group  editing
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @return (boolean)    true if the value should be saved when moving to a different field within
//                       the edit row.
//  @see saveByCell
//  @see editByCell
//<
shouldSaveOnCellExit : function (rowNum, colNum) {
    if (this.getCellRecord(rowNum, colNum) == null) return false;
    return (this.saveByCell != null ? this.saveByCell : this.editByCell);
},

//> @method listGrid.shouldSaveOnRowExit()
//
//  When a user exits the current edit row, should a save be performed.
//  Always returns true.
//
//  @group  editing
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @param  editCompletionEvent (EditCompletionEvent) what caused the edit completion
//  @return (boolean)    true if the value should be saved when moving to a different field within
//                       the edit row.
//<
shouldSaveOnRowExit : function (rowNum, colNum, editCompletionEvent) {
    return true;
},

//> @method listGrid.shouldValidateByCell()
//
//  When a user exits a field within the current row being edited, but does not exit the edit
//  row, should validation be performed.<br>
//  Default behavior is to return this.validateByCell if defined, otherwise return true if
//  the user is editing individual cells, false if the entire row is editable (set via the
//  editByCell property).<br>
//  Note that all edit-validation will be suppressed if listGrid.neverValidate is set to
//  true.
//
//  @group gridValidation
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @return (boolean)    true if validation should be performed when moving to a different field
//                       within the edit row.
//  @see listGrid.validateByCell
//  @see listGrid.autoValidate
//<
shouldValidateByCell : function (rowNum, colNum, editCompletionEvent) {
    var field = this.getField(colNum);
    if (field && field.validateByCell != null) return field.validateByCell;

    return (this.validateByCell != null ? this.validateByCell : this.editByCell);
},


//> @method listGrid.shouldValidateByRow()
// Should we perform validation on the current edit row when the user navigates away from it,
// even if the row is not being saved (due to +link{listGrid.autoSaveEdits} being false)?
// Default implementation returns +link{listGrid.autoValidate}.
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @return (boolean)    true if validation should be performed when moving to a different field
// @group gridValidation
// @see listGrid.autoValidate
// @see listGrid.autoSaveEdits
//<
shouldValidateByRow : function (rowNum, colNum, editCompletionEvent) {
    // Note: Method will only be called if _validationEnabled() returned true, so we
    // don't need to check this.neverValidate.
    return this.autoValidate;
},

//> @method listGrid.shouldCancelEdit()
//
//  On completion of an edit via some editCompletionEvent, should the edited values be discarded,
//  rather than being saved.
//  Default implementation returns true if the editCompletionEvent was a keypress on the escape
//  key and the escapeKeyEditAction was set to cancel.
//  Override for different cancellation behavior.
//
//  @group  editing
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @param  editCompletionEvent (EditCompletionEvent)  Event that completed the edit
//  @return (boolean)    true if the save should be cancelled
//  @see getNextEditCell()
//<
shouldCancelEdit : function (rowNum, colNum, editCompletionEvent) {
    if (editCompletionEvent == isc.ListGrid.ESCAPE_KEYPRESS) {
        var field = this.getField(colNum),
            action = field.escapeKeyEditAction || this.escapeKeyEditAction;
        if (action == "cancel") return true;
    }
    return false;
},

// Also see 'getNextEditCell()'


// --  Methods to perform the mechanics of saving / validation / etc.

//> @method listGrid._killEdit()
//
//  Complete editing by hiding the cell editor, and clearing out any edit information.
//  Public API for this is 'cancelEditing()'
//
//  @group  editing
//  @visibility internal
//
//  @param  editingFlowID   (number)    Unique ID for the edit flow to quit.  We take this parameter
//                                      to avoid this method from attempting to quit an edit-flow
//                                      that has already ended (likely to cause a valid new edit-flow
//                                      to close.
//  @param  editCompoletionEvent (EditCompletionEvent) Event that caused the cancellation
//                                      of the edit.
//  @param  [confirmed]   (boolean)     If confirmCancelEditing is true, when the user
//                                      dismisses the confirmation dialog we call this method
//                                      back, with this additional parameter indicating
//                                      yes or no click.
//  @see cancelEditing()
//<
_killEdit : function (editingFlowID, editCompletionEvent, confirmed) {
    if (this._editingFlowID != editingFlowID) return;

    if (this.confirmCancelEditing) {
        if (confirmed == null) {
            var callback =
                    this.getID() + "._killEdit('" + editingFlowID + "','"
                                                 + editCompletionEvent + "',value);";

            isc.ask(this.cancelEditingConfirmationMessage, callback);
            
            var yesButton = isc.Dialog.Warn.toolbar.getButton(0);
            if (yesButton.isDrawn()) yesButton.focus()
            else isc.Timer.setTimeout({target:yesButton, methodName:"focus"}, 0);
            return;
        } else if (confirmed == false) return;
    }

    // If editorExit / rowEditorExit returns false, don't allow the cancellation
    var rowNum = this.getEditRow(), colNum = this.getEditCol(),
        newVal = this.getUpdatedEditorValue(),
        newVals = this.getEditValues(rowNum, colNum);
    if (!this._handleEditorExit(editCompletionEvent, rowNum, colNum, newVal) ||
        !this._handleRowEditorExit(editCompletionEvent, rowNum, newVals))
    {
        return;
    }

    // We're going to kill the temp-edit value, but we don't want to update any visible form
    // items' values since we're then going to hide the form items anyway.
    // Therefore track any cells that have no form item showing, but DO have edit values, so
    // we can refresh them individually.
    var mustRedraw,
        cellsToRedraw = [],
        editRowNum = this._editRowNum,
        editValues = this.getEditValues(editRowNum, colNum),
        // if undrawn set start/end col such that we don't attempt to redraw any cells
        drawnArea = this.body ? this.body.getDrawArea() : [null,null,1,0],
        startCol = drawnArea[2], endCol = drawnArea[3],
        undef;
    if (editValues != null) {
        // if the user is editing a new record (no underlying data value) we have to redraw
        // the whole body as the total length will change by discarding the edit
        if (this.isNewEditRecord(editRowNum, colNum)) {
            if (this.isDrawn()) this.body.markForRedraw("clearing extra edit row");
            mustRedraw = true;
        } else {
            for (var i = startCol; i <= endCol; i++) {
                if ( editValues[this.getFieldName(i)] !== undef &&
                     ((this.editByCell && this._editColNum != i) ||
                      !this.canEditCell(editRowNum, i)) )
                {
                    cellsToRedraw.add(i);
                }
            }
        }
        // Kill the temporary edit values for the row (passing in the additional parameter to avoid
        // refreshing the effected cells)
        this._clearEditValues(this._editRowNum, colNum, true);

        // Grouping: If we just cleared an edit value that'd need a regroup we need to
        // handle it
        // (This automatically requests a redraw)
        if (this.isGrouped && this._updateGroupForEditValueChange(editRowNum)) {
            mustRedraw = true;
            // no need to markForRedraw - already handled by updateGroupForEditValueChange(...)
        }

    }

    if (this.body) {
        // hide the editor and put focus back in the body
        this.hideInlineEditor(true);
        if (this.isDrawn()) {
            if (!mustRedraw) {
                for (var i = 0 ; i < cellsToRedraw.length; i++) {
                    this.refreshCell(editRowNum, cellsToRedraw[i]);
                }
            }
        }
    }
    
    this._provideEditRecordToRuleContext();
},

isNewEditRecord : function (rowNum) {
    var editData = this.getEditSession(rowNum);
    return editData && editData._newRecord
},

//> @method listGrid.endEditing()
//
// Complete the current edit by storing the value and hiding the inline editor. Note that
// if +link{ListGrid.autoSaveEdits} is true, the value will be saved to the server.
//
//  @group  editing
//  @visibility external
//  @see startEditing()
//<
endEditing : function () {
    if (this.getEditRow() != null) this._saveAndHideEditor(isc.ListGrid.PROGRAMMATIC);
},

// Called from cellEditEnd when the user completes and edit with an enter keypress / click
// outside saves the values locally and hides the editor. If autoSaveEdits is true, it will
// also actually save the outstanding set of edits.

_saveAndHideEditor : function (editCompletionEvent) {

    // If we're always showing editors, just call 'saveEdits' and refuse to hide
    
    if (this._alwaysShowEditors()) {
        this.saveEdits(editCompletionEvent);
        return;
    }
    
    if (editCompletionEvent == isc.ListGrid.ESCAPE_KEYPRESS &&
            this.escapeKeyEditAction == "ignore")
    {
        return;
    }

    
    var shiftFocus = (editCompletionEvent == isc.ListGrid.TAB_KEYPRESS) ? 1 : 
                        (editCompletionEvent == isc.ListGrid.SHIFT_TAB_KEYPRESS) ? -1 : null;

    var rowNum = this.getEditRow(),
        colNum = this.getEditCol(),
        // Note getEditValue() will pick up the updated value from the form (and store in
        // this.editValues)
        newValue = this.getEditValue(rowNum, colNum),
        newValues = this.getEditValues(rowNum, colNum);


    // If editorExit or rowEditorExit returns false, don't save and quit.
    if (!this._handleEditorExit(editCompletionEvent, rowNum, colNum, newValue) ||
        !this._handleRowEditorExit(editCompletionEvent, rowNum, newValues)) return;

    // Closing the editor: If waitForSave is false we will kick off the save and then close
    // the editor without waiting to see if the save completed successfully.
    // If waitForSave is true - we will pass a callback into the saveEdits method that will
    // close the editor when the save returns.
    // We'll use the "success" parameter to determine whether a validation error occurred
    // on the attempted save. If so, we'll look at this.stopOnErrors to determine whether
    // the navigation should continue
    var waitForSave = (this.autoSaveEdits && this.shouldWaitForSave()),
        stopOnErrors = (this.autoSaveEdits && this.stopOnErrors),
        saveCallback;

    // It is possible that the current edit flow will have been completed, and another begun when
    // the callback function fires for this save (true for any saveEdits call).
    // If this is the case we want to no-op, rather than close the new edit flow.
    // Note - we fire this in the scope of the ListGrid via 'apply'
    if (waitForSave) saveCallback = "if((success||!this.stopOnErrors)&&" +
                                        "(this._editingFlowID==" + this._editingFlowID + "))" +
                                            "this.hideInlineEditor(true, null, " + shiftFocus + ");";

    
    var cancelling = (editCompletionEvent == isc.ListGrid.ESCAPE_KEYPRESS &&
                        this.escapeKeyEditAction == "exit"),
        saving = this.autoSaveEdits && !cancelling;

    if (saving) {
        this.saveEdits(editCompletionEvent, saveCallback);
    } else {

        var fieldName = this.getFieldName(colNum);

        // Note: no need to call 'storeUpdatedEditorValue()'here
        // this has already been handled by getEditValue() above
        var validateNow = !cancelling && this._validationEnabled() &&
                          (this.shouldValidateByCell(rowNum, colNum, editCompletionEvent) ||
                           this.shouldValidateByRow(rowNum, colNum, editCompletionEvent));
        if (validateNow) {
            var validationFailed;
            if (this.useCellRecords) {
                validationFailed = !this.validateCell(rowNum, colNum);
            } else {
                validationFailed = !this.validateRow(rowNum);
            }
            if (this.stopOnErrors && validationFailed) return false;
        }

        // drop empty edit sessions, normally accomplished by saving
        
        
        if (!this.recordHasChanges(rowNum, colNum, false) &&
            !this.hasSubmittedEditValues(rowNum, colNum)
           ) 
        {
            this.logInfo("editor hiding at " + [rowNum,colNum] +
                         ", no actual changes, dropping editSession", "gridEdit");
            // Don't hang onto the empty edit values for the row
            this._clearEditValues(rowNum, colNum);
        }
    }

    // If we not blocking interaction during save, we want to hide the inline editor here.
    // However, we _killEdit to clear our editValues only after saving, since if there are
    // validation errors, etc. we may yet require the editValues
    if (!waitForSave) this.hideInlineEditor(true, null, shiftFocus);

    // If we're currently grouped, and the value of the grouping field changed, should we
    // regroup here?
    //
    // If we're actually saving:
    // - if the save is local we'll already have regrouped. In this case definitely don't
    //    attempt to regroup again since the rowNum for the data may have changed, etc.
    // - otherwise, we will regroup when the save successfully completes, but regrouping here
    //   will essentially just update the tree to show the edit values in the new position
    //   while the save is occurring (desirable).
    //
    // If we're not saving, (autoSaveEdits is false, or the user hit "escape"), we do need
    // to regroup to put the edit values in their new position.
    if (this.isGrouped && (!saving || !this.shouldSaveLocally())) {
        this._updateGroupForEditValueChange(rowNum);
    }
},

//> @method listGrid.saveAndEditNewCell()
//
//  Save the current edit, and start editing another cell (may be in another row).
//
//  @group  editing
//  @visibility internal
//
//  @param  newRowNum   (number)    Index of new row to edit.
//  @param  newColNum   (number)    Index of new column to edit.
//  @param  editCompletionEvent (EditCompletionEvent)  How was the edit completed?
//  @see editNewCell()
//<

saveAndEditNewCell : function (newRowNum, newColNum, editCompletionEvent) {
    if (editCompletionEvent == null) editCompletionEvent = isc.ListGrid.PROGRAMMATIC;

    this._saveAndStartEditing(newRowNum, newColNum, editCompletionEvent);

},

// _saveAndStartEditing.  Saves the current edit, and starts editing the new cell passed in
_saveAndStartEditing : function (newRowNum, newColNum, editCompletionEvent) {
    
    var waitForSave = this.shouldWaitForSave(),
        saveCallback;
    if (waitForSave) {
        saveCallback = "if((success||!this.stopOnErrors)&&" +
                         "(this._editingFlowID==" + this._editingFlowID + "))" +
                          "this._startEditing(" + newRowNum + "," + newColNum + ");";
    }

    this.saveEdits(editCompletionEvent, saveCallback);
    if (!waitForSave) {
        this._startEditing(newRowNum, newColNum);
    }

},


// Internal helper method to save the current cell and move to the next one in some direction.
_saveAndEditNextCell : function (direction, stepThroughCells) {
    var rowNum = this.getEditRow(), colNum = this.getEditCol(),
        editCompletionEvent = isc.ListGrid.PROGRAMMATIC,

        nextEditCell = this.findNextEditCell(rowNum, colNum, direction, stepThroughCells, false);

    this._saveAndStartEditing(nextEditCell[0], nextEditCell[1], editCompletionEvent);
},

//> @method listGrid.saveAndEditNextCell()
//
//  Save the current edit, and edit the next editable cell, found by stepping through each field
//  in the current row (and possibly subsequent rows, depending on this.rowEndEditAction).
//
//  @group  editing
//  @visibility internal
//<
saveAndEditNextCell : function () {
    this._saveAndEditNextCell(1, true);
},

//> @method listGrid.saveAndEditPreviousCell()
//
//  Save the current edit, and edit the previous editable cell, found by stepping through each field
//  in the current row (and possibly subsequent rows, depending on this.rowEndEditAction).
//
//  @group  editing
//  @visibility internal
//<
saveAndEditPreviousCell : function () {
    this._saveAndEditNextCell(-1, true);
},

//> @method listGrid.saveAndEditNextRow()
//
//  Save the current edit, and edit the same field in the next editable row.
//
//  @group  editing
//  @visibility internal
//<
saveAndEditNextRow : function () {
    this._saveAndEditNextCell(1, false);
},

//> @method listGrid.saveAndEditPreviousRow()
//
//  Save the current edit, and edit the same field in the previous editable row.
//
//  @group  editing
//  @visibility internal
//<
saveAndEditPreviousRow : function () {
    this._saveAndEditNextCell(-1, false);
},

// Editing Navigation: finding next cell or record
// --------------------------------------------------------------------------------------------

//> @method listGrid.getNextEditCell()
//
//  Given a current edit cell, and an edit completion event, return the next cell to be edited,
//  or null if there is no next cell to edit.<br>
//  Default implementation:<ul>
//  <li>return null (editing complete), if the edit completion event was an enter keypress,
//      a click outside the editor, or an escape keypress</li>
//  <li>return the result of 'getNewEditCell()' if the edit completion event was
//      ListGrid.EDIT_FIELD_CHANGE or PROGRAMMATIC.  This relies on 'setNewEditCell()' having
//      been called earlier to specify the next cell to edit.</li>
//  <li>return the next editable cell in the same column moving up or down rows if the edit
//      completion event was an up or down arrow keypress<li>
//  <li>return the next editable cell in the same row, or if there is none, and
//      this.rowEndEditAction is "next", in subsequent rows, if the edit was
//      completed with a Tab or Shift+Tab keypress.</li>
//  </ul>
//
//  @group  editing
//
//  @param  rowNum      (number)    Index of record edited
//  @param  colNum      (number)    Index of field edited
//  @param  editCompletionEvent (EditCompletionEvent)    Edit completion event constant
//  @return (Array)  2 element array specifying next editable rowNum, colNum.  Will
//                   return null if the edit should be completed without navigating to
//                   another cell.
//  @visibility internal
//<

getNextEditCell : function (rowNum, colNum, editCompletionEvent) {

    switch (editCompletionEvent) {
        case isc.ListGrid.CLICK_OUTSIDE :
        // unlikely to see this case, since this is a 'cancellation' by default, but treat as
        // not attempting to navigate elsewhere
        case isc.ListGrid.ESCAPE_KEYPRESS :
            return null;

        case isc.ListGrid.ENTER_KEYPRESS :
            var field = this.getField(colNum),
                navStyle = field.enterKeyEditAction || this.enterKeyEditAction;
            if (navStyle == "done") return null;
            else if (navStyle == "nextCell")
                return this.findNextEditCell(rowNum, colNum, 1, true, false);
            else if (navStyle == "nextRow")
                return this.findNextEditCell(rowNum, colNum, 1, false, false);
            else if (navStyle == "nextRowStart") {
                var listEndAction = this.listEndEditAction || "done";
                if (rowNum+1 < this.getTotalRows() || listEndAction == "next") {
                    // either there are more record or we're allowed to create new records by
                    // navigating off the end of the list, proceed
                    return this.findNextEditCell(rowNum +1, 0, 1, true, true);
                } else {
                    // we've hit Enter on the last row, and we're not allowed to create new
                    // rows.
                    // if we're supposed to "stop", we should return the current coordinates,
                    // so we can't call findNextEditCell with rowNum+1 since it wouldn't know
                    // the current coordinates.
                    if (listEndAction == "stop") return [rowNum, colNum];
                    return null; // "done"
                }
            }

        case isc.ListGrid.EDIT_FIELD_CHANGE :
        case isc.ListGrid.PROGRAMMATIC :
        // In this case we have an explicit cell to move to - should have been saved as
        // 'newEditCell'
            return this.getNewEditCell();

        case isc.ListGrid.UP_ARROW_KEYPRESS :
            return this.findNextEditCell(rowNum, colNum, -1, false, false);

        case isc.ListGrid.DOWN_ARROW_KEYPRESS :
            return this.findNextEditCell(rowNum, colNum, 1, false, false);

        case isc.ListGrid.TAB_KEYPRESS :
        case isc.ListGrid.RIGHT_ARROW_KEYPRESS :
            var field = this.getField(colNum);
            if (field.nextTabColNum != null) {
                return this.findNextEditCell(rowNum +1, field.nextTabColNum, 1, true, true);
            } else {
                return this.findNextEditCell(rowNum, colNum, 1, true, false);
            }
        case isc.ListGrid.SHIFT_TAB_KEYPRESS :
        case isc.ListGrid.LEFT_ARROW_KEYPRESS :
            var field = this.getField(colNum)
            if (field.previousTabColNum != null) {
                return this.findNextEditCell(rowNum -1, field.previousTabColNum, -1, true, true);
            } else
                return this.findNextEditCell(rowNum, colNum, -1, true, false);
    }

    this.logWarn("getNextEditCell(): Passed unrecognized editCompletionEvent type:" +
                editCompletionEvent + ", returning null");
    return null;
},

//> @method listGrid.findNextEditCell()
//
// Method to find the next editable cell given a starting row/col, and a direction,
// either iterating through fields within each row, or checking the same field in each row.
// <p>
// Note, this is potentially an expensive method.  For example, consider a listGrid where the 
// user can add rows but not edit any existing rows; in this case, <code>canEditCell()</code>
// would inspect and reject every row in the dataSet before returning true for the last row.
// Consider this before making use of this method on grids with large dataSets
//  @group  editing
//
//  @param  rowNum      (Number)    Index of starting row
//  @param  colNum      (Number)    Index of starting column
//  @param  direction   (Number)    +1 if searching forward for the next edit cell, -1 if
//                                  searching backwards
//  @param  stepThroughFields   (boolean)   true if we should check every field in each row -
//                                          false if we should check the same field in each
//                                          row.
//  @param  [checkStartingCell] (boolean)   Should we check whether the cell passed in is
//                                          editable? Default behavior WILL check that cell -
//                                          pass false to suppress checking that cell.
//  @return (Array)  2 element array specifying next editable rowNum, colNum, or null if 
//                   this method fails to find an editable cell.
//  @visibility external
//<
// @param [checkPastListEnd]    Optional, internal parameter forces this method to check beyond
// the end of the list if necessary, even if this.listEndEditAction is not "next"
// @param [dontCheckPastRowEnd] Optional, internal parameter suppresses checking beyond the end
// of the row. We use this in handleEditEvent(click) to avoid iterating through the entire grid
// if there's no editable cell in a row!
// @param [ignoreFocus] optional, internal parameter - if we can't focus in an item

findNextEditCell : function (rowNum, colNum, direction, stepThroughFields, checkStartingCell,
                                checkPastListEnd, dontCheckPastRowEnd, ignoreFocus) {

    var newRow = rowNum,
        newCol = colNum,
        lastRow,
        totalCols = this.getFields().length;
    // no columns --> no way to get a valid cell
    if (totalCols == 0) return;

    // We want to look at every row up until the last drawn row.
    // IF listEditAction is "next", we will also check one row beyond the last drawn record
    // - this allows the user to tab beyond the end of the list and create a new edit row.
    // If we are passed a rowNum greater than the last drawn row, we will check every field
    // within that row (even if it's after the current last drawn row).  This allows the
    // programmatic editing of rows beyond the end of the list via 'startEditingNew()'.
    // In cases where there is no record associated with a row, canEditCell() checks
    // editability based on the field definitions.
    
    lastRow = (dontCheckPastRowEnd ? newRow :
                (this.listEndEditAction == "next" || checkPastListEnd) ? this.getTotalRows()
                                                                       : this.getTotalRows() -1);
    if (newRow > this.getTotalRows()) lastRow = newRow;

    // Note: If we have an editable field with a non focusable editor, always skip it.
    // This method is typically called when the user hits Tab to shift focus to the next
    // editable cell, etc.
    // If editing by row, skipping non-focusable fields is intuitive - the focus jumps over
    // the non editable field. If editing by cell it means that editor actually won't show up unless
    // the user double-clicks the cell (which seems acceptable since if you tabbed into it you'd
    // be unable to tab out again anyway).
    // ignoreFocus param disables this check - used whenever we need to find the next editable
    // cell and for some reason don't care about focus. Example use case: Finding the first
    // edit cell with a RecordEditor.

    // check whether we can edit at the starting coordinates, unless that is being
    // explicitly suppressed
    // Note: The cell passed in may be off the end of the list or past the end of the fields,
    //       since we blindly add 1 to a newRow / colNum in some cases.
    if (  (checkStartingCell != false || direction == 0) &&
          newRow <= lastRow && newRow >=0 && newCol < totalCols && newCol >=0 &&
          this.canEditCell(newRow, newCol) &&
          (ignoreFocus || this._canFocusInEditor(newRow, newCol))
        )
    {
        return [newRow, newCol];
    }

    // direction will be either -1 or 1.
    // check for other values is unnecessary so long as this method remains internal, but
    // check for zero anyway, since that would cause real problems!
    if (direction == 0) return null;

    var canEditStartingCell = this.canEditCell(newRow, newCol) &&
                              this._canFocusInEditor(newRow, newCol),
        firstRow = dontCheckPastRowEnd ? newRow : 0;

    if (stepThroughFields) {
        var style = this.rowEndEditAction || "next";
        while (newRow < (lastRow+1) && newRow >= firstRow) {

            // special case - break if we hit a loading row.
            // Exception: for newly added, as yet unsaved rows, rowIsLoaded
            // will return false, so accept these -- we won't go past "lastRow"
            // anyway.
            
            if (isc.ResultSet && isc.isA.ResultSet(this.data)) {
                if (newRow < this.data.getLength() && !this.data.rowIsLoaded(newRow)) return null;
            }
            newCol += direction;

            // If we've looped through the editable cells for this row, and are back at the
            // initial col return the starting row if it's editable.
            if (style == "same" && colNum == newCol) {
                return canEditStartingCell ? [rowNum, colNum] : null;
            }
            // if we hit the end of the row, check the rowEndEditAction to determine whether
            // to move to the next record, etc.
            if (newCol < 0 || newCol >= totalCols) {
                if (style == "done" || isc.isA.RecordEditor(this)) return null;
                if (style == "stop") return (canEditStartingCell ? [rowNum, colNum] : null)
                // if we're looping through the same row, set the newCol to be off the end
                // since we add / subtract one before checking for canEdit()
                else {
                    newCol = (direction > 0 ? -1 : totalCols);
                    if (style == "next") newRow += direction;
                }
            } else if (this.canEditCell(newRow,newCol) &&
                        (ignoreFocus || this._canFocusInEditor(newRow, newCol)))
            {
                return [newRow, newCol];
            }
        }
        // reached the end of the list without finding an editable cell.
        // If the end action is stop, or we're trying to move past the start of the list and
        // the end action is 'next', start editing the same cell again
        // - otherwise return null to stop editing
        if (this.listEndEditAction == "stop" ||
            (this.listEndEditAction == "next" && newRow < firstRow))
        {
            if (canEditStartingCell) return [rowNum, colNum];
            else return null;
        // default behavior - rowEndEditAction is "done"
        } else {
            return null;
        }

     } else {
        newRow += direction;
        while (newRow >= firstRow && newRow <= lastRow) {

            if (this.canEditCell(newRow, newCol) &&
                (ignoreFocus || this._canFocusInEditor(newRow, newCol))) {
                return [newRow, newCol];
            }
            newRow += direction;
        }
        // reached the end of the list without finding an editable cell.
        // If listEndEditAction is stop, or "next" - and we're trying to navigate past the
        // beginning of the list, return the cell passed in - otherwise return null to stop
        // editing
        if (this.listEndEditAction == "stop" ||
            (this.listEndEditAction == "next" && newRow < firstRow))
        {
            return canEditStartingCell ? [rowNum, colNum] : null;
        }
        return null;
     }
},

_canFocusInEditor : function (rowNum, colNum) {

    var fieldName = this.getFieldName(colNum),
        
        editForm = this.getEditForm();

    if (editForm == null) {
        this.makeEditForm(rowNum, colNum);
        editForm = this._editRowForm;
    }

    var editItem = editForm ? editForm.getItem(fieldName) : null;
    // editItem can still be null since we may be editing by cell in which case
    // we only populate with a single item.
    if (editItem) return editItem._canFocus();

    var field = this.getField(fieldName);
    if (field.canFocus != null) return field.canFocus;
    var editorType = this.getEditorType(field, this.getEditedRecord(rowNum));

    // call getItemClassName on FormItemFactory to actually get a SmartClient class from
    // the editor type (required to get SelectItem from SelectOtherItem, etc)
    editorType = isc.FormItemFactory.getItemClassName(field, editorType, null, true);

    // Resolve to an actual class
    var editorClass = editorType = isc.FormItemFactory.getItemClass(editorType);


    // This could potentially be broken by an override to _canFocus() which required looking
    // at a live instance.
    
    
    if (editorClass) {
        
        var _prototype = editorClass.getPrototype(),
            canFocus = _prototype.canFocus;
        if (canFocus != null) return canFocus;

        // Special case: If this is a CanvasItem, assume it's a custom implementation
        // and editable.
        if (isc.isA.CanvasItem(editorClass)) {
            return true;
        }
        if (_prototype._canFocus) return _prototype._canFocus();
    }
    return false;
},

//> @method listGrid.setNewEditCell() (I)
//
//  Internal method to record an explicit 'new edit cell'.  This can be retrieved (as an array)
//  via getNewEditCell();
//  Currently used when focus is put into a new cell by clicking in a field in a visible
//  (row-style) edit form, and by editField.
//
//  @group  editing
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the new row to edit
//  @param  colNum      (number)    Index of new field to edit
//<
setNewEditCell : function (rowNum, colNum) {
    this._newEditCell = [rowNum, colNum];
},

//> @method listGrid.getNewEditCell() (I)
//
//  Internal method to retrieve the 'new edit cell', previously stored by setNewEditCell.
//
//  @group  editing
//  @visibility internal
//
//  @return (array)    2-element array indicating the stored rowNum and coNum
//<
getNewEditCell : function () {
    if (this.canEditCell(this._newEditCell[0], this._newEditCell[1])) return this._newEditCell;
    return null;
},

//> @method listGrid.clearNewEditCell() (I)
//
//  Internal method to clear the 'new edit cell' stored by setNewEditCell.
//
//  @group  editing
//  @visibility internal
//<
clearNewEditCell : function () {
    this._newEditCell = null;
},


//> @method listGrid.discardAllEdits() (A)
//
// Cancel outstanding edits, discarding edit values, and hiding editors for the record[s] passed
// in if appropriate.
// <P>
// If no rows are passed in, all outstanding edit values will be dropped.  This will <b>not</b>
// automatically end editing; call +link{endEditing()} <b>before</b> calling discardAllEdits()
// if you also want to end editing.
// <P>
// Note that this also clears the +link{listGrid.markRecordRemoved,removed} state of any records
// that have been marked as removed.
//
// @param  [rows] (Array of Number) allows you to specify which row(s) to drop edits for
// @param   [dontHideEditor]    (boolean)   By default this method will hide the editor if
//                              it is currently showing for any row in the grid. Passing in
//                              this parameter will leave the editor visible (and just reset
//                              the edit values underneath the editor).
// @visibility external
// @group editing
//<
discardAllEdits : function (rows, dontHideEditor) {
    
    if (rows == null) rows = this.getAllEditRows(true);
    else {
        // Convert numeric rows to edit-values IDs
        for (var i = 0; i < rows.length; i++) {
            if (isc.isA.Array(rows[i])) rows[i] = this.getEditValuesID(rows[i][0], rows[i][1]);
            if (isc.isA.Number(rows[i])) rows[i] = this.getEditValuesID(rows[i]);
        }
    }
    if (rows == null) return;

    // call discardEdits()
    // Note that we're passing in an editValuesID rather than a rowNum / colNum here
    for (var i = 0; i < rows.length; i++) this.discardEdits(rows[i], null, dontHideEditor);
},

//> @method listGrid.discardEdits() (A)
//
// Cancel outstanding edits for the specified rows, discarding edit values, and hiding editors
// if appropriate.
// <P>
// Note that if this method is called on a new edit row (created via
// +link{listGrid.startEditingNew()} for example), which has not yet been saved, this method
// will remove the row entirely.
// <P>
// Also note that this method will clear the +link{listGrid.markRecordRemoved,removed} state
// of records that have been marked as removed.
//
// @param  rowNum (int) Row to cancel
// @param colNum (int) Column to cancel. Note that this parameter is ignored in ListGrids but
//                        may be required in subclasses of ListGrid where each cell represents
//                        one record in the data set (EG CubeGrid)
// @param   [dontHideEditor]    (Boolean)   By default this method will hide the editor if
//                              it is currently showing for the row in question. Passing in
//                              this parameter will leave the editor visible (and just reset
//                              the edit values underneath the editor).
// @group  editing
// @visibility external
//<
discardEdits : function (rowNum, colNum, dontHideEditor, editCompletionEvent) {
    if (rowNum == null) return;

    // if passed an ID rather than a rowNum, figure out the rowNum, so we can
    // easily see if its the current edit row.
    var ID;
    if (isc.isA.Number(rowNum)) {
        ID = this.getEditValuesID(rowNum, colNum);
    } else {
        ID = rowNum;
        rowNum = this.getEditSessionRowNum(ID, colNum);
    }
    var markedAsRemoved = this.recordMarkedAsRemoved(rowNum);

    // If alwaysShowEditors is true, suppress hiding the editor
    // unless we have no data and are showing a single new edit row.
    if (!dontHideEditor && this._alwaysShowEditors() &&
        (!(this.getTotalRows() == 1 && rowNum == 0)))
    {
        this.logInfo("Refusing to hide editor on 'discardEdits' [editCompletionEvent:" +
                editCompletionEvent + "] due to alwaysShowEditors settings", "inactiveEditorHTML");
        dontHideEditor = true;
    }

    if (!dontHideEditor && this._editorShowing && this.getEditRow() == rowNum) {

        if (editCompletionEvent == null) editCompletionEvent = isc.ListGrid.PROGRAMMATIC;
        this._killEdit(this._editingFlowID, editCompletionEvent);
        
    } else {
        // Ensure the stored edit value matches the value in the edit form item before we clear it
        // This is required to refresh the edit item value
        
        if (this._editorShowing && this.getEditRow() == rowNum) {
            this.storeUpdatedEditorValue(true);
        }
        this._clearEditValues(ID, colNum);
        
        this._provideEditRecordToRuleContext();
        // If marked as removed, explicitly refresh the row so we reset to normal styling
        if (markedAsRemoved) this.refreshRow(rowNum);
    }
    // Refresh summaries if the edit session rowNum is valid (otherwise nothing to do)
    if (rowNum != null) {
        this.calculateRecordSummaries(this.data.get(rowNum), null, true, true, true);
    }
},

// Saving Inline Edits
// --------------------------------------------------------------------------------------------


//> @method listGrid.saveEdits() (A)
//
// Validates and saves edits within the row currently being edited (or another row with unsaved
// edits, if indicated).
// <P>
// This method can be called to manually trigger saves if the default mechanisms of
// +link{saveByCell,cell by cell} or row by row saving are not suitable.
// <P>
// The 'callback' parameter provides a notification when the save attempt completes, which is
// likely to be asynchronous for databound grids.  Cases under which the callback will fire are:
// <ul><li>Save completed successfully</li>
// <li>No changes to the edited row, so save not required</li>
// <li>Validation failure occurred on the client or on the server</li></ul>
// Note that if this method was unable to determine the row to be saved, the callback will NOT
// fire - in this case, the method is a no-op.
// <P>
// Other, standard callbacks such as +link{editComplete()}, +link{editFailed()} and
// +link{cellChanged()} will fire normally.
// <P>
// Note this method does not hide the inline editors if they are showing - to explicitly save
// and end editing, use the method 'endEditing()'
// <P>
// If this method is called for a row which has been marked for deletion
// (see +link{listGrid.markRecordRemoved}) it will cause the record to be removed from the
// data-set.
//
//  @group  editing
//  @visibility external
//
//  @param  [editCompletionEvent] (EditCompletionEvent) Event used to complete cell editing.
//          Optional, and defaults to <code>"programmatic"</code>.  Can be used by the
//          <code>callback</code> method to perform custom actions such as navigation when the
//          save completes.
//  @param  [callback]    (Callback)  Callback to fire on completion of the saving process.
//                                    If no edits were made or client-side validation fails
//                                    the callback will be fired synchronously at the end of this
//                                    method.<br>
//                                    Takes the following parameters:
//                                    <br>- rowNum <i>(Number) edited row number</i>
//                                    <br>- colNum <i>(Number) edited column number</i>
//                                    <br>- editCompletionEvent <i>(EditCompletionEvent) event
//                                      passed in (defaults to <code>"programmatic"</code>)</i>
//                                    <br>- success <i>(boolean) false if the save was unable to
//                                      complete due to a validation failure or server-side
//                                      error.</i>
//  @param  [rowNum] (number) Which row should be saved. If unspecified the current edit row
//                            is saved by default. Note that if there is no current edit row
//                            this method will no op.
//  @see    endEditing()
//<
// parameter 'validateOnly' is used internally to avoid actually saving if validation
// succeeds - just return true to indicate success


// parameter 'skipValidation' used internally to suppress client side validation and allow the
// save to proceed. This is helpful for the case where we've validated the record in the same
// thread and want to avoid re-running validators unnecessarily
saveEdits : function (editCompletionEvent, callback, rowNum, colNum, validateOnly, skipValidation) {
    // Since this is being exposed as a public method (allowing saving while leaving
    // the editor visible), default to a "PROGRAMMATIC" editCompletionEvent.
    if (editCompletionEvent == null) editCompletionEvent = isc.ListGrid.PROGRAMMATIC;

    if (rowNum == null) {
        rowNum = this.getEditRow()
        colNum = this.getEditCol();
    } else if (colNum == null) {
        // this will not apply to cubeGrid editing
        
        colNum = (rowNum == this.getEditRow() ? this.getEditCol() : this.getRowEditColNum(rowNum));
    }
    // clicking rapidly from one row to another when the editEvent is 'CLICK', and editOnFocus
    // is true can sometimes cause this method to get fired before the editRow / col has been
    // set up.  Just bail if this happens.
    if (rowNum == null) return false;

    // If this is a removal, we want to remove rather than update.
    if (this.recordMarkedAsRemoved(rowNum)) {
        
        if (validateOnly) {
            return true;
        }

        var newRow = this.isNewEditRecord(rowNum, colNum);
        // new row - by dropping edit values we discard the row entirely.
        
        if (newRow) {
            this.discardEdits(rowNum);
            this._fireSaveCallback(callback, rowNum, colNum, editCompletionEvent, true);
            return;
        } else {
            // wrap the callback passed in in a ds callback,
            // using closure to access the various params we want
            var _this = this;
            var dsCallback = function (response,data,request) {
                _this.fireCallback(callback, "rowNum,colNum,editCompletionEvent,success",
                        [rowNum,colNum,editCompletionEvent,true]);
            };
            this.removeData(this.getCellRecord(rowNum, colNum), dsCallback, null, true);
            return;
        }
    }

    // If we're actually showing the editor, getEditValues() will ensure any changes are
    // saved in the editValues object for the row.
    var newValues = this.getEditValues(rowNum, colNum),
        record = this.getCellRecord(rowNum, colNum),
        editValuesID = this.getEditValuesID(rowNum, colNum);
    // don't pass the actual record as oldValues; allows downstream code to modify it freely
    var oldValues;
    if (record != null && !Array.isLoading(record)) {
        if (isc.isA.Tree(this.data)) {
            
            oldValues = this.data.getCleanNodeData(record, false);
        } else {
            oldValues = isc.addProperties({}, record);
        }
        
        if (oldValues && this.selection) delete oldValues[this.selection.selectionProperty];
    }
    // Assemble the edit information into a single object to be passed to callback
    // methods.
    // We use this object if we have to call editCompleteCallback or editFailedCallback
    // directly from this method - otherwise we'll re-create this object in
    // saveEditedValues() / updateRecordsReply()
    var editInfo = {
            // Note: rowNum / colNum are basically available for callbacks, and for special
            // handling if a user overrides this method
            rowNum:rowNum,
            colNum:colNum,
            oldValues:oldValues,
            editValuesID:editValuesID,
            values:newValues,
            editCompletionEvent:editCompletionEvent,
            newRecord:(rowNum > this.data.getLength())
    };
    //>DEBUG
    if (this.logIsDebugEnabled("gridEdit")) {
        this.logDebug("change detection: newValues: " + this.echo(newValues) +
                      ", oldValues: " + this.echo(oldValues), "gridEdit");
    } //<DEBUG

    
    var haveChanges = this.recordHasChanges(rowNum, colNum, false);

    // perform validation on the edited row before saving
    // NOTE: we always save, and validate the whole row, even if saveByCell is true
    // as saveByCell really governs when the save is kicked off rather than what is
    // to be saved.
    
    if (haveChanges && !skipValidation && this._validationEnabled()) {
        
        this._skipServerValidation = (validateOnly || haveChanges);

        var validationFailed;
        if (this.useCellRecords) {
            validationFailed = !this.validateCell(rowNum, colNum);
        } else {
            validationFailed = !this.validateRow(rowNum);
        }
        this._skipServerValidation = null;

        if (validationFailed) {
            if (!validateOnly) this._editFailedCallback(editInfo, callback);
            return false;
        }
    }
    // If we're only validating return true here to indicate that validation passed.
    if (validateOnly) return true;
    if (!haveChanges) {
        this.logInfo("saveEdits: no actual change, not saving", "gridEdit");
        // haveChanges will return false if we're pending a save and further edits haven't
        // been made.
        // In this case, retain the edit values.
        // Otherwise they are basically empty / match the record values, so remove 'em
        if (!this.hasSubmittedEditValues(editValuesID, colNum)) {
        this._clearEditValues(editValuesID, colNum);
        }
        // fire the saveCallback to finish flow (eg move to next cell, end editing..)
        
        this._fireSaveCallback(callback, rowNum, colNum, editCompletionEvent, true);
        return;
    }

    // get refreshed editValues since validation converts values to declared types, and we need
    // to store with correct types
    newValues = this._getEditValues(rowNum, colNum);

    //>DEBUG
    this.logInfo("Saving newValues '" + isc.echoAll(newValues) + "'", "gridEdit");
    //<DEBUG

    // remember this set of editValues as the "last submitted" for this row - this is used
    // for change detection while any save is pending.
    
    this.rememberSubmittedEditValues(rowNum, colNum);

    // NOTE: dupe the new values because they can be the live "editValues" for a row, and the
    // save implementation might integrate them directly into the data set with no copy
    newValues = isc.addProperties({}, newValues);

    // call the 'saveEditedValues' method to actually perform the save.
    var attempted = this.saveEditedValues(rowNum, colNum, newValues, oldValues,
                          editValuesID, editCompletionEvent, callback);

    // If saveEditedValues() returns explicit false, we abandoned the save attempt because
    // we're offline at the moment
    if (attempted === false) {
        this._editFailedCallback(editInfo, callback);
        return false;
    }

    // return true to indicate we're (attempting to) save the value
    // (If we're saving to the server, this does not indicate success, the server could still
    // give validation errors back to the asynchronous callback function - don't fire
    // _editCompleteCallback until we know the edit either went through or failed)
    return true;
},

//> @method listGrid.rowHasChanges()
// If this listGrid can be edited, this method will return true if the row passed in has been
// edited, but the edits have not yet been saved to the ListGrid's data object.
// <P>
// Note this method will not return true if a record has been marked as
// +link{markRecordRemoved,removed}, but has no other changes. Developers can use
// +link{listGrid.recordMarkedAsRemoved()} to check for this case.
//
// @param rowNum (int) index of row to check for changes
// @return (Boolean) true if the row has changes.
// @visibility external
// @group editing
//<


rowHasChanges : function (rowNum, checkEditor) {
    // call recordHasChanges
    // Ignore the 2nd parameter - this method is not supported in 1 record/cell editing
    // pattern (IE CubeGrid)
    return this.recordHasChanges(rowNum, null, checkEditor);
},

// this one is documented at the CG level where it should be used instead of rowHasChanges
recordHasChanges : function (rowNum, colNum, checkEditor) {

    if (checkEditor == null) checkEditor = true;

    var changes = false,
        newValues = (checkEditor ? this.getEditValues(rowNum, colNum)
                                 : this._getEditValues(rowNum, colNum)),
        oldValues = this.getCellRecord(rowNum, colNum);
    // If there is no record for this row, we're editing a new row.
    // In this case we always want to save the values out.
    if (!oldValues) return true;

    // determine whether any changes have occurred by looking at the oldValues.
    // If the record is pending a save, compare the last submitted edit values to the new
    // values rather than looking at the underlying record values.
    
    var testValues = isc.addProperties({}, oldValues,
                                       this.getSubmittedEditValues(rowNum, colNum));
    for (var fieldName in newValues) {
        if (fieldName == this.removeRecordProperty) continue;
        var oldFieldValue = testValues[fieldName],
            newFieldValue = newValues[fieldName];

        // Use custom comparator to catch things like Dates where '==' check is not sufficient
        if (!this.fieldValuesAreEqual(this.getField(fieldName), oldFieldValue,newFieldValue)) {
            //this.logWarn("field: " + fieldName +
            //             " changed from '" + this.echo(oldFieldValue) +
            //             "' to '" + this.echo(newFieldValue) + "'");
            changes = true;
            break;
        }
    }
//     this.logWarn("newValues:" + this.echoAll(newValues) +
//         ", compared against oldValues:" + this.echo(testValues) +
//         " and .. combined with submitted:" + this.echo(testValues));
    return changes;
},

//> @method listGrid.hasChanges()
// Whether the grid as a whole has any unsaved edits, in any row. Note that this method will return
// true if any rows are +link{markRecordRemoved,marked as removed} in addition to any rows that have
// pending unsaved edits.
// @return (Boolean) returns true of any unsaved edits are present
// @group editing
// @visibility external
//<

hasChanges : function (checkEditor) {
    var editRows = this.getAllEditRows();
    if (editRows != null) {
        for (var i = 0; i < editRows.length; i++) {
            if (this.recordMarkedAsRemoved(editRows[i])) return true;
            if (this.rowHasChanges(editRows[i], checkEditor)) return true;
        }
    }
    return false;
},

//> @method listGrid.cellHasChanges()
// If this listGrid can be edited, this method will return true if the cell passed in has been
// edited, but the edits have not yet been saved to the ListGrid's data object.
// @param rowNum (int) index of row to check for changes
// @param colNum (int) index of the col to check for changes
// @return (Boolean) returns true if the cell has unsaved edits
// @group editing
// @visibility external
//<
// Additional checkEditor param: Should we check for changes in the editor which have not yet been
// stored in our editValues?
// If unset, assumed to be true.
// Useful as when we use this method internally we're typically in the process of writing out
// CSS text, etc for the cell, so if the editor is showing we know the user hasn't had a
// chance to modify it.
cellHasChanges : function (rowNum, colNum, checkEditor) {
    return this._cellHasChanges(rowNum, colNum, checkEditor, false);
},
_cellHasChanges : function (rowNum, colNum, checkEditor, ignoreSubmittedVals) {

    if (rowNum == null || colNum == null) return false;
    var newValues = (checkEditor ? this.getEditValues(rowNum, colNum)
                                 : this._getEditValues(rowNum, colNum));
    // No new edit values - therefore no changes
    if (!newValues) return false;

    var savedValues = this.getCellRecord(rowNum, colNum);
    // No record, therefore this is a new row so every cell has a new value
    if (!savedValues) return true;

    var field = this.getField(colNum);
    // presumably field being null implies a bad colNum
    if (field == null) return false;

    
    var dataPath = !field.dataPath && isc.CubeGrid && isc.isA.CubeGrid(this) ?
        this.getValueProperty(rowNum, colNum) : null;

    // Pass the field directly into _getFieldValue()
    
    var newValue = isc.Canvas._getFieldValue(dataPath, field, newValues, this, true, "compare");

    var undef;
    // Edit values are sparse, so if undef, assume no edit value for the cell
    if (newValue === undef) return false;

    // If we have issued a save, don't report the cell as having changes 
    // unless the field was re-edited since the save was kicked off
    // This matches recordHasChanges behavior
    
    var submittedValues = ignoreSubmittedVals ? null : this.getSubmittedEditValues(rowNum, colNum),
        oldValue;
    if (submittedValues) {
        oldValue = isc.Canvas._getFieldValue(dataPath, field, submittedValues, this, true, "compare");
    }
    if (oldValue == null) {
        oldValue = isc.Canvas._getFieldValue(dataPath, field, savedValues, this, true, "compare");
    }
    if (oldValue == null) {
        oldValue = isc.Canvas._getFieldValue(dataPath, field, submittedValues, this, true, "compare");
    }
    return !this.fieldValuesAreEqual(field, oldValue, newValue);
},

//> @method ListGrid.saveAllEdits()
// Save a number of outstanding edits for this ListGrid. If no rows are specified, all
// outstanding edits will be saved.
// <P>
// Note that if +link{listGrid.saveRequestProperties} is specified and the grid is performing
// a databound save, these properties will be applied to each generated DSRequest.
//
// @param [rows] (Array of Number) optionally specify which rows to save
// @param [saveCallback] (callback) If specified this callback will be fired on a successful save
//  of the specified rows. Note that if there are no pending edits to be saved this callback will
//  not fire - you can check for this condition using +link{ListGrid.hasChanges()} or
//  +link{ListGrid.rowHasChanges()}.  Use +link{editFailed} to find out about failures
//  encountered during saving (on a per-row basis).
// @return (boolean) true if a save has been initiated (at least one row had changes, passed
//                   client-side validation, and a save has been attempted).  False otherwise
// @group editing
// @visibility external
//<

_saveAllEditsFlow:0,
saveAllEdits : function (rows, saveCallback) {
    this._saveAllEditsPendingRows = this._saveAllEditsPendingRows || {};
    this._saveAllEditsRemoveRows = this._saveAllEditsRemoveRows || {};
    this._saveAllEditRowsCallback = this._saveAllEditRowsCallback || {};

    if (rows == null) rows = this.getAllEditCells();
    if (rows == null) return false;

    // handle being passed just a rowNum
    if (!isc.isAn.Array(rows)) rows = [rows];

    // We're going to iterate through our set of edited rows twice - the first time we'll
    // just perform validation. This allows us to bail if stopOnErrors is true.
    // The second time we iterate through the rows that didn't fail validation only, performing
    // the actual saves.
    if (this._validationEnabled()) {
        for (var i = 0; i < rows.length; i++) {

            // for the cube, each entry in "rows" can be a two-element array of rowNum, colNum
            var rowNum = isc.isAn.Array(rows[i]) ? rows[i][0] : rows[i],
                colNum = isc.isAn.Array(rows[i]) ? rows[i][1] : null;

            // call saveEdits with a flag telling it just to perform client-side validation.
            // Note this also prevents editFailed() from being called (it would normally be
            // called for a client-side validation failure)
            // Suppress this for records marked as removed.
            
            var validated = this.recordMarkedAsRemoved(rowNum) ||
                            this.saveEdits(null, null, rowNum, colNum, true);
            if (!validated) {
                if (this.stopOnErrors) return false;
                // don't save rows that failed client validation
                // Also suppress the callback from firing (just clear it) as firing would indicate
                // success
                else {
                    rows[i] = null; //
                    saveCallback = null;
                }
            }
        }
    }

    var shouldQueue = (this.dataSource != null && !this.shouldSaveLocally()),
        startedQueue = false;
    if (shouldQueue) startedQueue = !isc.RPCManager.startQueue();

    // If a callback was provided, we want to fire if we know every row saved successfully.
    // We handle this by tracking the set of rows committed with each 'saveAllEdits()' call and
    // only firing the callback once we've seen a callback tripped from every row committed.
    // The 'flowNum' logic is required to allow more than one 'saveAllEdits' call to be kicked
    // off before the response from the server without us clobbering info
    // (and therefore failing to fire the callback) from earlier calls to the method.
    
    var flowNum = this._saveAllEditsFlow ++,
        savingRows = this._saveAllEditsPendingRows[flowNum] = [],
        removingRows = this._saveAllEditsRemoveRows[flowNum] = [];

    this._saveAllEditRowsCallback[flowNum] = saveCallback;

    var saveAttempted = false;

    // We only want to fire the 'saveCallback' when we know every row committed has been
    // successfully saved. This is handled by _saveAllEditsRowCallback()
    var callback = ["this._saveAllEditsRowCallback('",,"',rowNum," + flowNum +
                                                        ",colNum,editCompletionEvent,success)"];

    var removedRowNums = [];
    for (var i = 0; i < rows.length; i++) {

        // any rows that failed validation have been removed from the array.
        if (rows[i] == null) continue;

        var rowNum = rows[i],
            colNum;
        if (isc.isAn.Array(rowNum)) {
            colNum = rowNum[1];
            rowNum = rowNum[0];
        }

        // Adjust the rowNum to account for previously removed rows.
        
        var offset = 0;
        if (removedRowNums && removedRowNums.length > 0) {
            for (var k = removedRowNums.length; k--; ) {
                if (rowNum > removedRowNums[k]) {
                    ++offset;
                }
            }
        }
        rowNum -= offset;
        var newRow = this.isNewEditRecord(rowNum, colNum);
        var removing = this.recordMarkedAsRemoved(rowNum);
        if ((!shouldQueue || newRow) && removing) {
            removedRowNums.push(rowNum);
        }

        // Don't call saveEdits() for an unchanged row, as it will synchronously call the
        // callback and hose tracking of committed changes.
        if (!this.recordHasChanges(rowNum,colNum) && !removing) {
            continue;
        }

        saveAttempted = true;
        var editValuesID = this.getEditValuesID(rowNum, colNum);
        callback[1] = editValuesID;
        if (removing) {
            removingRows[removingRows.length] = editValuesID;
        } else {
            savingRows[savingRows.length] = editValuesID;
        }
        // pass in the skipValidation param - we already validated earlier in this thread.
        this.saveEdits(null, callback.join(""), rowNum, colNum, false, true);
    }

    // If we're queuing, send the queue now
    
    if (startedQueue) {
        isc.RPCManager.sendQueue(null,null,null,true);
    }
    // return true to indicate we're (attempting to) save the value unless every save attempt
    // gave a validation error
    // (If we're saving to the server, this does not indicate success, the server could still
    // give validation errors back to the asynchronous callback function - don't fire
    // _editCompleteCallback until we know the edit either went through or failed)
    return saveAttempted;
},

_saveAllEditsRowCallback : function (editValuesID, rowNum, flowNum, colNum, editCompletionEvent, success) {
    if (!success) {
        // Clean up the stored array of saving rows and the stored callback method.
        // _saveAllEditsRowCallback will successfully recognize if this has occurred and have
        // other (successful) callbacks from this flow no-op.
        delete this._saveAllEditRowsCallback[flowNum];
        delete this._saveAllEditsPendingRows[flowNum];
        delete this._saveAllEditsRemoveRows[flowNum];
        return;
    }

    // look up the set of rows that were committed to together
    var savingRows = this._saveAllEditsPendingRows[flowNum],
        removingRows = this._saveAllEditsRemoveRows[flowNum];

    // If we have no stored 'saving rows' one of the saves must have failed so we will
    // never fire our save callback. Just bail in this case.
    if (savingRows == null && removingRows == null) return;

    // remove the row that we have just successfully saved
    var index, found, removing;
    for (index = 0; index < savingRows.length; index++) {
        var testID = savingRows[index];
        if (testID == editValuesID) {
            found = true;
            break;
        }
    }

    if (!found) {
        for (index = 0; index < removingRows.length; index++) {
            var testID = removingRows[index];
            if (testID == editValuesID) {
                found = true;
                break;
            }
        }
        if (found) removing = true;
    }

    

    if (removing) {
        removingRows.removeAt(index);
    } else {
        savingRows.removeAt(index);
    }
    // if all rows have been successfully saved
    if (savingRows.length == 0 && removingRows.length == 0) {
        // fire the callback passed into saveAllEdits()
        
        this._fireSaveCallback(this._saveAllEditRowsCallback[flowNum],
                                rowNum, colNum, editCompletionEvent);
        // clean up:
        delete this._saveAllEditRowsCallback[flowNum];
        delete this._saveAllEditsPendingRows[flowNum];
        delete this._saveAllEditsRemoveRows[flowNum];
    }
},

// _parseEditorValue - helper method to convert the value currently displayed in an editor into
// the appropriate raw value for saving.
// calls 'parseEditorValue' at the field / grid levels if defined.

_parseEditorValue : function (value, field, rowNum, colNum, record) {
    // allow the record to be passed in as an optional parameter if it happens to be available
    // for the calling function.
    var undef;
    if (record === undef) record = this.getCellRecord(rowNum, colNum);

    if (field && field.parseEditorValue != null) {
        isc.Func.replaceWithMethod(field, "parseEditorValue",
                                            "value,record,rowNum,colNum,grid");
        value = field.parseEditorValue(value, record, rowNum, colNum, this);
    } else if (this.parseEditorValue != null) {
        value = this.parseEditorValue(value, record, rowNum, colNum);
    }
    return value;

},

// returns true if edits should not propagate to upstream data sources/sets

// NOTE: This method has been moved up to DataBoundComponent, because there are methods at
// that level which call it, and not every DBC is a ListGrid (eg, TileGrid)
//shouldSaveLocally : function () {
//    return (!this.dataSource || this.getFullDataPath() != null || this.saveLocally);
//},

//> @method listGrid.saveEditedValues() (A)
//  Save edited values that have passed client-side validation.  Fire the callback when
//  save process completes (with param to indicate failure if appropriate).
//
//  @group  editing
//
//  @param  rowNum  (number)    index of edited row
//  @param  colNum  (number)    index of edited column
//  @param  newValues   (object)    Values returned by the editor.
//  @param  oldValues   (object)    Values before the edit
//  @param  editCompletionEvent (EditCompletionEvent)  event that caused edit completion
//  @param  [saveCallback]    (Callback)  optional callback function to fire on completion of
//                                        saving process
//  @visibility internal
//<
saveEditedValues : function (rowNum, colNum, newValues, oldValues,
                             editValuesID, editCompletionEvent, saveCallback)
{
    // assemble the edit information into a single object, so it can be passed around as part
    // of the context for this event.
    

    // NOTE: we use an arbitrary "editValuesID" to track edited values, since newly
    // created records won't have primary keys, and rowNums could change if data is shuffled.
    var editInfo = {
        editValuesID:editValuesID,
        rowNum:rowNum,
        colNum:colNum,
        values:newValues,
        oldValues:oldValues,
        editCompletionEvent:editCompletionEvent
    };
    // At this point we have already validated the change (on the client), so we just need to
    // save changes

    // if there's no dataSource, immediately commit changes locally
    if (this.shouldSaveLocally()) {

        // if useRemoteValidators is true, ask the dataSource to validate the change and only
        // continue with the save if validation is successful.
        
        if (this.useRemoteValidators == true) {
            var hasServerValidators = false,
                ds = this.getDataSource(),
                fields = ds ? ds.getFieldNames() : null;

            if (fields != null) {
                for (var i = 0; i < fields.length; i++) {
                    var field = ds.getField(fields[i]),
                        validators = field.validators;
                    if (validators == null) continue;
                    if (!isc.isAn.Array(validators)) validators = [validators];
                    for (var ii = 0; ii < validators.length;ii++) {
                        if (isc.Validator.isServerValidator(validators[ii])) {
                            hasServerValidators = true;
                            break;
                        }
                    }
                    if (hasServerValidators) break;
                }
            }

            if (hasServerValidators) {
                var requestProperties = {
                    validationMode:"partial",
                    prompt:isc.RPCManager.validateDataPrompt,
                    showPrompt:this.shouldWaitForSave(),
                    internalClientContext:{
                        editInfo:editInfo,
                        saveCallback:saveCallback
                    },
                    componentID:this.ID
                };
                ds.validateData(
                    editInfo.values,
                    // this callback handles calling saveLocally directly.
                    {target:this,methodName:"remoteValidationForLocalSaveComplete"},
                    requestProperties
                );

                // Hang onto a flag noting we're in the process of saving this row
                if (this._savingEdits == null) this._savingEdits = {};
                this._savingEdits[editInfo.editValuesID] = true;

                return;
            }
        }
        // no server-side validation errors so just call saveLocally synchronously.
        return this._saveLocally(editInfo, saveCallback);
    }

    // If we're offline, forbid the save
    if (isc.Offline && isc.Offline.isOffline() && !this.dataSource.clientOnly) {
        isc.warn(this.offlineSaveMessage);
        return false;
    }

    // otherwise, submit change to server, and wait until it returns without error to commit
    var callback = this.getID() + "._updateRecordReply(dsResponse, dsRequest)",
        request = {
        // allow customizing the operation used to save
        operationId : (oldValues == null ? this.addOperation : this.updateOperation) ||
                    this.saveOperation,
        // allow customizing the application the operation is performed in
        application : this.application,

        // so we can see validation errors
        willHandleError : true,
        // show a prompt to block user interaction during save
        showPrompt : this.shouldWaitForSave(),

        // for long transactions, if supported by backend.  NOTE: currently no error codes or
        // frontend UI defined for handling concurrent update error case
        oldValues : oldValues,

        // the actual record object that was edited, if present.  Needed for
        _originalRecord: this.getRecord(rowNum, colNum),

        // Client side context stuff
        internalClientContext:{
            // if we were passed an explicit callback, hang onto this
            // (It will be fired by _updateRecordReply)
            saveCallback : saveCallback,

            // changed values
            newValues : newValues,
            // all other context
            editInfo : editInfo
        },

        componentId: this.ID
    };

    // support for dataBoundComponentField.includeFrom:<dataSourceID>.<fieldName>
    // for fields that are not in the dataSource but pick up their value from
    // a related dataSource
    // In this case simply update the outputs property of the request -- the
    // server will be responsible for actually getting the value from the other
    // dataSource
    var completeFields = this.getAllFields();
    if (completeFields != null) {
        for (var i = 0; i < completeFields.length; i++) {
            if (completeFields[i].includeFrom != null &&
                this.getDataSource().getField(completeFields[i].name) == null)
            {
                if (request.additionalOutputs == null) request.additionalOutputs = "";
                else request.additionalOutputs += ",";
                request.additionalOutputs += [
                        completeFields[i].name,
                        completeFields[i].includeFrom].join("!")

            }
        }
    }

    if (this.saveRequestProperties) {
        isc.addProperties(request, this.saveRequestProperties);
    }

    // unsort to prevent changed data popping out of viewport
    
    this._unsortOnChange(newValues, oldValues);

    // Hang onto a flag noting we're in the process of saving this row
    if (this._savingEdits == null) this._savingEdits = {};
    this._savingEdits[editInfo.editValuesID] = true;

    var ds = isc.DS.get(this.dataSource);

    if (oldValues == null) {
        var newRecord = isc.addProperties({}, oldValues, newValues);
        ds.addData(newRecord, callback, request);
    } else {
        // combine the new values with primary keys to form the update set for the modified
        // record.  Copy so that we still have the original values intact when the transaction
        // returns.
        var pks = isc.DS.get(this.dataSource).filterPrimaryKeyFields(oldValues),
            updates = isc.addProperties({}, pks, newValues);
        ds.updateData(updates, callback, request);
    }
},

_saveLocally : function (editInfo, saveCallback) {

    var rowNum = editInfo.rowNum,
        colNum = editInfo.colNum,
        oldValues = editInfo.oldValues,
        newValues = editInfo.values;

    
    var record = this.getCellRecord(rowNum, colNum),
        addNew = (record == null);
    // Note: This should be split into a separate method, which would handle updating
    // local data, or server-side data (and the list would automatically unsort as a result
    // of dataChanged())
    if (addNew) {
        var data = this.getOriginalData();

        // Associate the new record object with the edit values before adding the record to
        // the data array.
        
        var editValuesContext = this.getEditSession(rowNum);
        editValuesContext._primaryKeys = this.getPrimaryKeys(newValues);
        
        delete editValuesContext._newRecord;

        if (isc.ResultSet && isc.isA.ResultSet(data)) {
            if (data.allRows != null) {
                data.allRows.add(isc.addProperties({},newValues));
                data.filterLocalData();
            } else {
                this.logWarn("Unable to add data to resultSet - allRows is not set");
            }
        } else {
            data.add(newValues);
            data.dataChanged();
        }

    // update the record in place with 'setRawCellValue()' if we're editing an existing one
    } else {

        var cellValue, undef;
        
        var seenFieldNames = {};
        for (var i = 0; i < this.completeFields.length; i++) {
            var field = this.completeFields[i],
                fieldLocator = this.getEditorName(rowNum, field, true);
            cellValue = isc.Canvas._getFieldValue(null, field, newValues,
                                                     this, true, "edit");
            if (cellValue !== undef) {
                var fieldNum = this.fields.indexOf(field);
                if (fieldNum != -1) {
                    this.setRawCellValue(record, rowNum, fieldNum, cellValue);
                } else {
                    isc.Canvas._saveFieldValue(null, field, cellValue,
                                                 record, this, true);
                }
            }


            var name = fieldLocator;
            if (fieldLocator.indexOf("/") >= 0) {
                name = isc.DynamicForm._trimDataPath(fieldLocator, this);
            }
            seenFieldNames[name] = true;
        }

        
        this.combineValuesRecursively(record, newValues, seenFieldNames);
    }

    // un-sort the list if the sorted field value was edited.  Otherwise the record might
    // get sorted out of the viewport.
    this._unsortOnChange(newValues, oldValues);
    this._editCompleteCallback(editInfo, saveCallback);

    // If we are part of a valuesManager notify it of the update
    
    if (this.valuesManager != null) {
        // _updateMultipleMemberValue handles combining a data-index into a path
        // 2nd param unnecessary since we're modifying the whole record, not a field within it.
        this.valuesManager._updateMultipleMemberValue(rowNum, null, record, this);
    }
},

combineValuesRecursively : function (target, source, skipFields, path, objectCache) {
    if (path == null) path = "";

    // Avoid stack overflows arising from recursion loops
    if (objectCache == null) objectCache = [];
    if (isc.isAn.Object(target) && !isc.isA.Date(target)) {
        if (objectCache.contains(target)) return;
        objectCache.add(target);
    }

    if (skipFields[path]) {
        //isc.logWarn("Skipping object tree rooted at path '" + path + "' because it's in the skip list");
        return;
    }

    if (isc.isAn.Array(source)) {
        //isc.logWarn("Processing array at dataPath '" + path);
        for (var i = 0; i < source.length; i++) {
            var newPath = path == "" ? "" + i : path + "/" + i;
            if (isc.isAn.Object(source[i]) && !isc.isA.Date(source[i])) {
                if (target[i] == null) target[i] = isc.isAn.Array(source[i]) ? [] : {};
                this.combineValuesRecursively(target[i], source[i], skipFields, newPath, objectCache);
            } else {
                target[i] = source[i];
            }
        }
    } else if (isc.isAn.Object(source) && !isc.isA.Date(source)) {
        //isc.logWarn("Processing object at dataPath '" + path);
        for (var attr in source) {
            var newPath = path == "" ? attr : path + "/" + attr;
            if (isc.isAn.Object(source[attr]) && !isc.isA.Date(source[attr])) {
                if (target[attr] == null) target[attr] = isc.isAn.Array(source[attr]) ? [] : {};
                this.combineValuesRecursively(target[attr], source[attr], skipFields, newPath, objectCache);
            } else {
                if (skipFields[newPath]) {
                    //isc.logWarn("Skipping value at dataPath '" + newPath + "' - found it as a leaf in the skip list");
                } else {
                    //isc.logWarn("Setting value at dataPath '" + newPath + "' to " + source[attr]);
                    target[attr] = source[attr];
                }
            }
        }
    }
},


remoteValidationForLocalSaveComplete : function (dsResponse, data, dsRequest) {
    var context = dsResponse.internalClientContext,
        editInfo = context.editInfo;

    // drop the savingEdits flag we set up to ensure we don't kick off multiple save attempts
    // for the same edited values, etc.
    if (this._savingEdits && this._savingEdits[editInfo.editValuesID]) {
        delete this._savingEdits[editInfo.editValuesID];
        if (isc.isAn.emptyObject(this._savingEdits)) delete this._savingEdits;
    }

    if (dsResponse.status < 0 && dsResponse.status != isc.RPCResponse.STATUS_VALIDATION_ERROR) {
        this.logWarn("Server-side validation failed: " + dsResponse.data);
        isc.RPCManager.handleError(dsResponse,dsRequest);
        return;
    }

    var liveEdits = this._getEditValues(editInfo.editValuesID);

    if (dsResponse.errors) {
        var errors = isc.DynamicForm.getSimpleErrors(dsResponse.errors),
            nonEmptyErrors = false;

        // Show server errors
        for (var fieldName in errors) {
            nonEmptyErrors = true;
            if (liveEdits == null) {
                this.logWarn("Asynchronous remote validation failed for attempted save of edits " +
                    "for row:" + editInfo.rowNum + " but edit values have subsequently been " +
                    "discarded. Ignoring validation failure.  Validation failure details:\n" +
                    this.echoFull(errors));
                break;
            }
            var fieldErrors = errors[fieldName],
                field = this.getField(fieldName)
            ;
            if (fieldErrors != null && field != null) {
                // if the edit val has changed since the user attempted to save it, we should
                // presumably not show the validation error for the field.
                
                var saveVal = editInfo.values[fieldName],
                    liveVal = liveEdits[fieldName];

                if (saveVal != liveVal &&
                    !(isc.isA.Date(liveVal) && isc.isA.Date(saveVal) &&
                        (liveVal.getTime() == saveVal.getTime())))
                {
                    this.logWarn("Asynchronous remote validation failed for attempted save of edits " +
                        "for row:" + editInfo.rowNum + ". Submitted value for field " + fieldName +
                        " was " + saveVal + ", but the edit value has subsequently been modified " +
                        "and is now:" + liveVal + ". Not showing the following validation " +
                        "error[s] for this field:\n" + this.echoAll(fieldErrors));

                    continue;
                }
                if (!isc.isAn.Array(fieldErrors)) fieldErrors = [fieldErrors];
                fieldErrors = fieldErrors.getProperty("errorMessage");

                this.setFieldError(editInfo.rowNum, fieldName, fieldErrors, false);
            }
        }
        if (nonEmptyErrors) return;
    }

    // At this point we know validation was successful - run saveLocally to update the
    // actual data set.
    this._saveLocally(editInfo, context.saveCallback);

},

// unsort() if we are sorted and the sort field will be changed in this update
_unsortOnChange : function (newValues, oldValues) {
    if (this.logIsInfoEnabled("sorting")) {
        this.logInfo("unsort on change: sortFieldNum: " + this.sortFieldNum +
                    ", newValues: " + this.echo(newValues) +
                    ", oldValues: " + this.echo(oldValues)
        );
    }

    var sortFieldNum = this._getSortFieldNum();
    if (sortFieldNum == null) return;

    var sortField = this.fields[sortFieldNum];
    if (sortField == null) return;

    var sortFieldName = sortField[this.fieldIdProperty];
    var undef;
    if (sortFieldName != null && newValues[sortFieldName] !== undef &&
        (oldValues == null || newValues[sortFieldName] != oldValues[sortFieldName]))
    {
        this.unsort();
        if (this.logIsInfoEnabled("sorting")) {
            this.logInfo("called unsort, sortProp is: " + this.data._sortProperty + 
                " - oldValue is " + oldValues[sortFieldName] + 
                ", newValue is " + newValues[sortFieldName]
            );
        }
    }
},

// callback from server save triggered in commitEditValue
_updateRecordReply : function (dsResponse, dsRequest) {
    var results = dsResponse.data,
        context = dsResponse.internalClientContext,
        editInfo = context.editInfo,
        colNum = editInfo.colNum,
        field = this.fields[colNum];

    // Clear out the _savingEdits flag for this row as the save will have completed now.
    
    if (this._savingEdits && this._savingEdits[editInfo.editValuesID]) {
        delete this._savingEdits[editInfo.editValuesID];
        if (isc.isAn.emptyObject(this._savingEdits)) delete this._savingEdits;
    }

    // the rowNum may be different by now due to unrelated changes.  Look up the editValues we
    // were trying to save by editValuesId, and see what rowNum they are now associated with.
    
    var editSession = this.getEditSession(editInfo.editValuesID);

    if (editSession != null) {
        editInfo.rowNum = editSession._rowNum;
        
    } else {
        
        if (results && results[0]) {
            editInfo.rowNum = this.findRowNum(results[0]);
            if (this.useCellRecords) editInfo.colNum = this.findColNum(results[0]);
        }

        // If no record was returned, assume it was an attempt to save a new row which
        // failed to save, and for which editVals have now been discarded
        else editInfo.rowNum = -1;
    }

    var rowNum = editInfo.rowNum, colNum = editInfo.colNum;
    if (dsResponse.status < 0) { // error occurred
        // XXX We should really check for the 'validation failed' error code here
        // (results.status) rather than just checking for the presence of errors

        // we store validation errors per row as a simple object with an array
        // of error message strings per field.  dsResponse.errors is allowed to have one of a
        // few possible formats - convert this error block into our internal format before
        // storing / displaying errors
        var errors = this.parseServerErrors(dsResponse.errors);

        this.logInfo("error on save, status: " + dsResponse.status +
                     ", errors: " + this.echo(dsResponse.errors), "gridEdit");

        // The server will return an array of error object - one per record edited.
        // Since we only support saving out one record at a time, this should be a one element
        // array only.
        // Pull out the error object for the edited row, and pass it back to the setRowErrors()
        // method to store and display the errors
        
        if (isc.isAn.Array(errors)) {
            if (errors.length != 1)
                this.logWarn("Server reports validation errors for multiple records - only " +
                             "displaying errors for the first record.", "gridEdit");

            errors = errors[0];
        }

        // Store, and display the new errors
        if (this.useCellRecords) this.setCellErrors(rowNum, colNum,
                                                    errors[this.getEditorName(rowNum, colNum)]);
        else this.setRowErrors(rowNum, errors);

        // fire the simple callback function indicating the edit failed
        // (The second param would be any additional callback to fire on completion)
        this._editFailedCallback(editInfo, context.saveCallback, dsResponse, dsRequest);

        return false;
    }
    // if we got here, the edit was successful
    this._editCompleteCallback(editInfo, context.saveCallback, dsResponse, dsRequest)
},

// parseServerErrors(): convert the formats allowed for dsResponse.errors to our internal
// error storage format

parseServerErrors : function (errors) {
    if (isc.isAn.Array(errors)) {
        if (errors.length > 1) {
            this.logWarn("server returned errors for multiple records - dropping all but the " +
                        "first record returned");
        }
        errors = errors[0];
    }

    
    if (errors && errors.recordPath) delete errors.recordPath;

    for (var fieldName in errors) {
        var fieldErrors = errors[fieldName];
        if (fieldErrors == null) fieldErrors = "Unspecified error";

        if (isc.isAn.Array(fieldErrors)) {
            for (var i = 0; i < fieldErrors.length; i++) {
                fieldErrors[i] = fieldErrors[i].errorMessage;
            }
        } else if (fieldErrors.errorMessage) {
            errors[fieldName] = [fieldErrors.errorMessage];
        } else {
            errors[fieldName] = [fieldErrors];
        }
    }
    return errors;
},


//> @method listGrid._editCompleteCallback    (I)
//
//      Callback method triggered when a saveEditedValues flow completes successfully.
//      Fired whether the save succeeded on the client or on the server.
//      Calls the 'editComplete' string method (with the same signature) if present.
//
//  @group  editing
//
//  @param  editInfo (object)       Details of the edit
//                                  <br>Contains:
//                                  <ul>
//                                  <li>rowNum - index of edited row</li>
//                                  <li>colNum - index of edited column</li>
//                                  <li>values - edited values for the record</li>
//                                  <li>oldValues - values for the record before this edit</li>
//                                  <li>editCompletionEvent - how the edit was completed</li>
//                                  </ul>
//  @param [callback] (function)      Optional callback function to fire
//  @param [dsResponse] (DSResponse)  DSResponse for DataSource saves
//
//  @visibility internal
//<
_editCompleteCallback : function (editInfo, callback, dsResponse, dsRequest) {
    // If the editForm has focus, ensure the latest values have been stored
    if (this._editorShowing && this.getEditForm().hasFocus) this.storeUpdatedEditorValue(true);

    var rowNum = editInfo.rowNum,
        colNum = editInfo.colNum,
        valuesID = editInfo.editValuesID,
        editSession = this.getEditSession(valuesID),
        newRecord = this.isNewEditRecord(valuesID);

    var record;

    // Databound saves will have been passed a dsResponse from the server
    if (dsResponse != null) {

        var updateData = isc.DataSource.getUpdatedData(dsRequest, dsResponse, true),
            record = isc.isAn.Array(updateData) ? updateData[0] : updateData;
        if (record == null) {
            
            return;
        }

        // If the user was editing a new record, we may not have any primary key field
        // on the editSession object, required to reliably associate the editSession with
        // the record in the dataSet.
        // Catch this case and call newRecordForEditValues() to perform the association
        if (editSession && editSession._primaryKeys == null) {
            this.newRecordForEditValues(valuesID, record);
        }

    } else {
        // for client-only saves assume the save will never change the rowNum
        record = this.getCellRecord(rowNum, colNum)
    }

    // Clear up the editValues that have already been saved to the server.
    // Leave anything that has been edited after the save was committed
    
    var submittedValues = editInfo.values,
        // use th internal getEditValues() since we already stored the updated value if
        // appropriate
        currentEditValues = this._getEditValues(valuesID),

        
        stillEditing = this.isEditingRecord(rowNum, colNum),
        primaryKeyFields =
            this.dataSource ? isc.DS.get(this.dataSource).getPrimaryKeyFieldNames()
            : null;

    var hasChanges = false;
    for (var field in currentEditValues) {
        var isPK = primaryKeyFields && primaryKeyFields.contains(field);
        if (this.fieldValuesAreEqual(this.getField(field),
                                     currentEditValues[field], submittedValues[field]))
        {
            // If we're still showing the editor, don't wipe out primary key fields- we always
            // want these included in our edit values. Only required for databound grids.
            
            if (!(stillEditing && isPK)) this.clearEditValue(valuesID, field, true, true);
        } else {
            if (!isPK) hasChanges = true;
        }
    }
    // If the editor is no longer showing, and there are no outstanding edits, ensure the
    // editValues object has been cleared
    // Note: If the editor is still showing, we'll drop all unchanged edit values when the
    // editor gets hidden.
    
    if (!stillEditing && !hasChanges) {
        this._clearEditValues(valuesID, colNum);
    }

    // displayUpdatedDSRecord will refresh the mapping between pending edit values and rowNums.
    // We can avoid this if this was a local save (which we can handle by just refreshing
    // the cells in question.
    if (dsResponse != null || newRecord) {
        if (dsResponse != null && this.isGrouped) {
            var ignore = false;
            // New record always requires regrouping so it ends up in the correct group.
            // Existing record only requires regroup if group field value changed.
            if (!newRecord) {
                ignore = true;
            var groupFields = this.getGroupByFields(),
                    fieldNames = dsResponse.context && dsResponse.context.params ? dsResponse.context.params : {}
            ;
            for (var i=0; i<groupFields.length; i++) {
                var key = groupFields[i];
                if (fieldNames[key] != null) {
                    ignore = false;
                    break;
                }
            }
            }
            if (ignore) this._ignoreRegroup = true;
        }
        this.displayUpdatedDSRecord(rowNum, colNum, record);
    }

    // At this point edit context objects match their associated edit rows, and all edit values
    // have been updated.
    // Fire callbacks.
    

    
    var newValues = editInfo.values,
        oldValues = editInfo.oldValues,
        editCompletionEvent = editInfo.editCompletionEvent;

    
    if (rowNum == -1) rowNum = editInfo.rowNum;

    if (this.convertToMethod("editComplete")) {
        this.editComplete(rowNum, colNum, newValues, oldValues, editCompletionEvent, dsResponse);
    }

    this._fireCellChanged(record, rowNum, colNum, newValues, oldValues, dsRequest);


    if (callback) this._fireSaveCallback(callback, rowNum, colNum, editCompletionEvent, true);
},

// displayUpdatedDSRecord - called from editCompleteCallback on databound save
// calls dataChanged() to to refresh the mapping between pending edit values and rowNums,
// and redraw to show new rows


displayUpdatedDSRecord : function (rowNum, colNum, record) {
    if (this._remapEditRows()) {
        this.suppressEditRowRemap = true;
        this.dataChanged();
        this.suppressEditRowRemap = false;
    } else if (this.isGrouped) {
        // If we're grouped, and we didn't fire dataChanged here, explicitly regroup so
        // records' whose group field value changed show up in the right place.
        
        if (this._ignoreRegroup && !this._markForRegroup) {
            delete this._ignoreRegroup;
            return;
        }
        this.regroup();
    }
},

isEditingRecord : function (rowNum, colNum) {
    return this.getEditRow() == rowNum;
},

// Fires the single callback explicitly passed into saveEdits() as a parameter
_saveCallbackParams:"rowNum,colNum,editCompletionEvent,success",
_fireSaveCallback : function (callback, rowNum, colNum, editCompletionEvent, success) {
    if (callback != null) {
        this.fireCallback(callback,
                          this._saveCallbackParams,
                          [rowNum,colNum,editCompletionEvent,success]
        );
    }
},

_fireCellChanged : function (record, rowNum, colNum, newValues, oldValues, dsRequest) {
    // if a cellChanged was supplied, call that
    // Currently available at field and LG level (should we allow it per-row too?)
    var changeGroup, autoFitField;
    for (var i in newValues) {
        var oldValue = (oldValues == null ? null : oldValues[i]);
        if (newValues[i] == oldValue) continue;
        var currentField = this.fields.find(this.fieldIdProperty, i);

        // if a field was changed which does not exist in the grid's field list,
        // ignore it. It can't be grouped and cellChanged() cannot be called on it.
        if (!currentField) continue;

        // check for the need to re-group this record
        if (this.isGrouped && currentField) {
            var groupFields = this.getGroupByFields();
            if (groupFields.contains(currentField.name)) changeGroup = true;
        }
        if (this.shouldAutoFitField(currentField)) {
            autoFitField = true;
        }

        this._cellChanged(
                            record, currentField,
                            newValues[i], oldValue,
                            rowNum,
                            this.fields.indexOf(currentField)
                          );
    }


    if (autoFitField) {
        if (this.shouldSaveLocally()) {
            // if bound, dataChanged will already handle this
            this.updateFieldWidthsForAutoFitValue("Local edit");
        }
    }
    if (changeGroup) {
        if (this.shouldSaveLocally()) {
            // if bound, dataChanged will already handle this
            this._incrementalRegroup(record, record, newValues);
        }

        // redraw grid
        // regardless of if the data is saved locally, folderToggleObservation is not
        // called before this point, so it must exist outside the above codepath.
        this._suppressFolderToggleRedraw = false;
        this._folderToggleObservation();
    }
},

// Fire the 'cellChanged' string method handler(s) at the field or List level, if defined.
// If an entire row was edited this method (and the public cellChanged handlers) will be fired
// for each field edited.
_cellChanged : function (record, field, newValue, oldValue, recordNum, fieldNum) {

    if (field && field.cellChanged) {
        if (!isc.isA.Function(field.cellChanged)) {
            // (We must use replaceWithMethod rather than convertToMethod as the field is
            // not an ISC class with a string method registry on it)
            isc.Func.replaceWithMethod(field, "cellChanged",
                        "record,newValue,oldValue,rowNum,colNum,grid,recordNum,fieldNum");
        }

        // call() to call the function on the grid rather than the field
        field.cellChanged.call(this,
                               record,newValue,oldValue,recordNum,fieldNum,this,recordNum,fieldNum);

    } else if (this.cellChanged) {
        // call the list.cellChanged method, and note if it returns false (thus rejecting the change)
        this.cellChanged(record,newValue,oldValue,recordNum,fieldNum,this,recordNum,fieldNum);
    }

},

// Called when saving fails due to validation or other errors.  Calls the 'editFailed'
// string method (with the same signature) if present.  Will be called once per record
// if there was an attempt to save multiple records at once (saveAllEdits())

_editFailedCallback : function (editInfo, callback, dsResponse, dsRequest) {
    var rowNum = editInfo.rowNum,
        colNum = editInfo.colNum,
        values = editInfo.values,
        oldValues = editInfo.oldValues,
        eCe = editInfo.editCompletionEvent
    ;

    var record = this.getRecord(rowNum);
    if (record != null && this.canExpandRecord(record, rowNum) && 
        this.expansionMode == "editor") 
    {
        // we're expandable and
        var errors = isc.isAn.Array(dsResponse.errors) ? dsResponse.errors[0] : dsResponse.errors,
            record = this.getRecord(rowNum),
            shouldExpand = false
        ;

        if (isc.isAn.Object(errors)) {
            for (var key in errors) {
                var field = this.getField(key);
                if (!field || !this.fieldIsVisible(field)) {
                    shouldExpand = true;
                    break;
                }
            }
        }

        if (shouldExpand) {
            this.expandRecord(record);
            // do we need to validate the form just now?
        }
    }

    // note newValue can be a single value or an entire record
    if (this.convertToMethod("editFailed")) {        
        this.editFailed(rowNum, colNum, values, oldValues, eCe, dsResponse, dsRequest);
    }
    if (callback != null) this._fireSaveCallback(callback, rowNum,colNum,eCe,false);

    
    this.clearSubmittedEditValues(editInfo.editValuesID, values);

},

// see doc near stringMethod declaration, below
editFailed : function (rowNum, colNum, newValues, oldValues, editCompletionEvent, dsResponse, dsRequest) {

    // if this was an attempted server-side commit that returned a failure code from the server
    // (with no specific error messages), pass it on to rpcManager.handleError()
    
    if (dsResponse != null && dsResponse.errors == null) {
        isc.RPCManager._handleError(dsResponse, dsRequest);
    }
},

// ============================================================================================
// Validation
// ============================================================================================

// Performing validation
// ------------------------------------------------

//> @groupDef gridValidation
// ListGrids support automatic validation of edited cells / records. This group is a collection
// of APIs related to the validation subsystem.
// <p>
// Default validation occurs in response to the user navigating between edit cells
// (see +link{listGrid.validateByCell}) or whenever edited values are to be committed to the
// server for saving.  Standard validation can also be triggered for a cell or row programmatically at
// any time.<br>
// When standard validation occurs, +link{listGridField.validators} will be run on each
// cell to be validated.<br>
// In addition to this standard behavior developers can add custom errors to fields
// via +link{listGrid.setFieldError()} / +link{listGrid.setFieldError()}.
//
// @see group:editing
// @visibility external
//<


//> @method listGrid.validateRow()
// Validate the current set of edit values for the row in question.
// <P>
// Called when the user moves to a new edit row, or when an edited record is to be saved if
// client side validation is enabled for this grid.
// <P>
// This method may also be called directly to perform row level validation at any time.
//
// @param   rowNum (int) index of row to be validated.
// @return  (Boolean) returns true if validation was successful (no errors encountered), false
//                    otherwise.
// @group gridValidation
// @visibility external
//<
validateRow : function (rowNum, suppressRefresh) {
    return this.validateRecord(rowNum, suppressRefresh);
},


// validateRecord()
// Actually perform the validation of edit values for some record
// For one-record-per-cell implementations this will need to be overridden
validateRecord : function (cell, suppressRefresh) {
    var rowNum, colNum;
    if (isc.isAn.Array(cell)) {
        rowNum = cell[0];
        colNum = cell[1];
    } else {
        rowNum = cell;
    }

    
    var newValues = this.getEditValues(rowNum, colNum);

    // Feed this through _getFieldValue to narrow down by dataPath if necessary
    //if (this.dataPath) {
    //    newValues = isc.Canvas._getFieldValue(this.dataPath, newValues, this);
    //}

    // If the row is not being edited always "pass" validation.
    if (newValues == null) return true;

    var record = this.getCellRecord(rowNum,colNum),
        // Validate every field. This is necessary because of conditional validators
        // that may depend on other field values.
        fields = this.getFields().getProperty(this.fieldIdProperty)
    ;

    // Wrap field validation in a queue so that server validators are
    // sent as a single request.
    var wasAlreadyQueuing = isc.rpc.startQueue();

    if (this._skipServerValidation != true) {
        this._deferServerValidation = true;

        // Field objects that require server validation
        this._fieldsNeedingServerValidation = [];
    }

    var errorBlock = this.validateRowValues(newValues, record, rowNum, fields);

    // Perform deferred server validation if needed
    if (this._deferServerValidation && this._fieldsNeedingServerValidation.length > 0) {
        var validationOptions = {rowNum: rowNum}
        this.validateFieldsOnServer(this._fieldsNeedingServerValidation, 
                            this.getEditedRecord(rowNum, null, true), validationOptions);
    }
    this._deferServerValidation = null;

    // Submit server validation requests queue
    if (!wasAlreadyQueuing) isc.rpc.sendQueue();

    // call setRowErrors() to store, and display the new set of editValues for the row.
    this.setRowErrors(rowNum, errorBlock, suppressRefresh);

    return (errorBlock == null)
},


//> @method listGrid.validateRowValues()
//  Helper method to perform validation on a row.
//  Called by validateRow() - returns any errors found on the row.
//
//  @group gridValidation
//  @param  newValues   (object)    Field-value mapping showing the edited values for each field
//  @param  oldValues   (object)    Field-value mapping showing the values for each field before
//                                  editing
//  @param  rowNum      (number)    Index of the row being edited
//  @param  fields      (number | string | array)
//                          Fields to be validated.  If more than one field is to be validated,
//                          this will be an array.
//                          Note that each field can be designated either by fieldName or the
//                          numeric index.
//  @return (object)   set of errors returned by validation, in the format
//                      {fieldName:["errorMessage", ...],...}.
//                     will be null if no errors encountered
//  @visibility internal
//<
validateRowValues : function (newValues, oldValues, rowNum, fields) {
    var validationPassed = true,
        errorBlock = {};

    // handle being passed a single field
    if (!isc.isAn.Array(fields)) fields = [fields];

    // Handle editing a new record - oldValues for each cell will be undefined.
    var isNewRecord = false;
    if (oldValues == null) {
        isNewRecord = true;
        oldValues = {};
    }

    // validate each field separately, then show the errors for all fields
    for (var i = 0; i < fields.length; i++) {
        
        if (fields[i] == null) continue;
        var fieldName,
            colNum;

        // ensure fields[i] is a fieldName and record the colNum
        if (isc.isA.Number(fields[i])) {
            colNum = fields[i];
            fieldName = fields[i] = this.getFieldName(colNum);
        } else {
            fieldName = fields[i];
            colNum = this.getFields().findIndex(this.fieldIdProperty, fieldName)
        }
        // If the field isn't included in this list, skip it... This is likely to happen
        // as lists won't show every field, but we will include the primary keys in our edit
        // values
        if (colNum < 0) continue;

        // validate if this is an editable cell in a new record (in order to enforce eg the
        // required validator), or if the field has been edited.
        var shouldValidateCell = (
            (isNewRecord && this.canEditCell(rowNum, colNum)) ||
            isc.propertyDefined(newValues, fieldName)
        
        );
        var newValue, oldValue;

        var field = this.getField(fieldName),
            dataPath = field ? field.dataPath : null,
            undef;
        if (dataPath != null) {
            dataPath = this._trimDataPath(dataPath);
        } else {
            dataPath = field.name;
        }
        
        newValue = isc.Canvas._getFieldValue(dataPath, field, newValues,
                                                        this, true, "validate");
        oldValue = isc.Canvas._getFieldValue(dataPath, field, oldValues,
                                                            this, true, "validate");

        if (!shouldValidateCell) {
            shouldValidateCell = (newValue !== undef || oldValue === undef || oldValue == null);
        }
        if (!shouldValidateCell) continue;

        
        var validationErrors = this.validateCellValue(rowNum, colNum, newValue, oldValue);

        if (validationErrors != null) {
            validationPassed = false;
            errorBlock[fieldName] = validationErrors;
        }
    }
    if (!validationPassed) return errorBlock;
    return null;
},


//> @method listGrid.validateCell()
// Validate the current edit value for the cell in question.  Called when the user moves to a
// new edit cell if +link{ListGrid.validateByCell} is true.<br>
// This method may also be called directly to perform cell level validation at any time.
// @param   rowNum (number) index of row to be validated.
// @param   fieldName (string | number) field name (or column index) of field to be validated
// @return  (Boolean) returns true if validation was successful (no errors encountered), false
//                    otherwise.
// @group gridValidation
// @visibility external
//<
validateCell : function (rowNum, fieldName, suppressDisplay, processDependencies) {

    var colNum;
    if (isc.isA.String(fieldName)) colNum = this.getColNum(fieldName);
    else {
        colNum = fieldName;
        fieldName = this.getEditorName(rowNum, colNum);
    }

    // if we're showing an edit item for the field, ensure its value is up to date.
    
    if (this._editorShowing && (this.getEditRow() == rowNum )
        && this.getEditForm().getItem(fieldName) != null)
    {
        this.storeUpdatedEditorValue(null, colNum);
    }

    var editVals = this.getEditValues(rowNum, colNum),
        hadErrors = this.cellHasErrors(rowNum, fieldName),
        newValue = editVals ? editVals[fieldName] : null,
        record = this.getCellRecord(rowNum, colNum),
        oldValue = record ? record[fieldName] : null;

    // don't validate if the cell has not been edited (unless this is a new record in which
    // case it will be saved as a null value.
    if (record != null && (!editVals || !isc.propertyDefined(editVals, fieldName))) {
        return true;
    }

    var errors = this.validateCellValue(rowNum, colNum, newValue, oldValue, processDependencies);
    if (errors != null) {
        // call setFieldError() to store the error object on the
        // appropriate cell, and display it to the user.
        this.setFieldError(rowNum, fieldName, errors);
        return false;
    }

    // if the cell previously had errors, explicitly clear them out
    if (hadErrors) {
        this.setFieldError(rowNum, fieldName, null);
    }
    return true;
},

//> @method listGrid.validateCellValue()    (A)
// Helper method for validateCell(): Validate the new value the user supplied for a single cell.
// <p>
// Default implementation falls through to the stringMethod
// list.validateFieldValue(newValue, oldValue, record, field, rowNum, colNum) to
// perform validation based on the edit field's validators.
//
//  @group gridValidation
//
//  @param  rowNum  (integer)   Edited cell's row number
//  @param  colNum (integer)   Edited cell's field number
//  @param  newValue    (any)       Value returned by the editor.
//  @param  oldValue    (any)   Value before editing
//  @return (array) Array of validation error objects, or null if none found
//<
validateCellValue : function (rowNum, colNum, newValue, oldValue, processDependencies) {
    var record = this.getCellRecord(rowNum, colNum);
    var field = this.getField(colNum);
    return this.validateFieldValue(newValue, oldValue, record, field, rowNum, colNum, processDependencies);
},

// Allow customization of the 'required field' validation error message

//> @method listGrid.getRequiredFieldMessage()
// Returns the message to display when a user attempts to save a required field with an
// empty value.  By default returns +link{Validator.requiredField}.
// @param field (object) definition of the field being edited
// @param record (object) record object being edited
// @return (string) "Field is required"
// @group i18nMessages, gridValidation
// @visibility external
//<
getRequiredFieldMessage : function (field, record) {
    return isc.Validator.requiredField;
},

//> @method listGrid.validateFieldValue()   (A)
//
//  Validate the new value the user supplied for a cell via an editCellValue() call against
//  any validators defined on the edit field.
//
//  @group  editing
//
//  @param  newValue    (any)       Value returned by the editor.
//  @param  oldValue    (any)       Value before editing
//  @param  record  (object)    pointer to the record object for the edited cell
//  @param  field   (object)    pointer to the field descriptor object for the edited cell
//  @param  rowNum  (number)    row index of the edited cell
//  @param  colNum  (number)    column index for the edited cell
//  @return (array)     array of error objects, or null if no errors found
//<
validateFieldValue : function (newValue, oldValue, record, field, rowNum, colNum, processDependencies) {
    var errors = [],
        success = true;

    var required = this.cellIsRequired(rowNum, colNum);
    // Check for required fields
    if (required && (newValue == null || isc.isAn.emptyString(newValue))) {
        var errorMessage = this.getRequiredFieldMessage(field, record);
        errors.add(errorMessage);
        success = false;
    }
    // validate the value if the field specifies validators
    var validators = this.getCellValidators(rowNum, colNum);
    if (validators) {

        if (this.logIsDebugEnabled("gridEdit")) {
            this.logDebug((this.useCellRecords ? "At col:" + colNum : "At field: " + field.name) +
                          " applying validators: " + this.echoAll(validators) +
                          " to value:" + newValue,
                          "gridEdit");
        }

        var fieldResult,
            editedRecord = this.getEditedRecord(rowNum,colNum),
            allErrors = null,
            options = {rowNum: rowNum}
        ;
        
        if (this._skipServerValidation == true) {
            options.skipServerValidation = true;
        } else if (this._deferServerValidation == true) {
            options.deferServerValidation = true;
        }
        if (processDependencies) {
            fieldResult = this.validateFieldAndDependencies(field, validators, newValue,
                                            editedRecord, options);
        } else {
            fieldResult = this.validateField(field, validators, newValue,
                                            editedRecord, options);
        }
        if (fieldResult != null) {
            if (fieldResult.needsServerValidation) {
                this._fieldsNeedingServerValidation.add(field);
            }
            if (fieldResult.valid != true) {
                success = false;
                if (processDependencies)
                    errors = fieldResult.errors[field.name] || [];
                else
                    errors = fieldResult.errors || [];
            } else {
                
                if (fieldResult.resultingValue != null) {
                    this.setEditValue(rowNum, colNum,
                                      fieldResult.resultingValue,
                                      null, null, null, true);
                    newValue = fieldResult.resultingValue;
                }
            }

            // Even though the changed field may be valid, there may be other fields
            // that are no longer valid because of a dependency. These errors should
            // be shown on the form.
            allErrors = fieldResult.errors;

            if (this.logIsInfoEnabled("gridEdit")) {
                this.logInfo("validateFieldValue, newValue: " + this.echo(newValue) +
                             ", passed validation: " + success +
                             ", resultingValue: " + this.echo(fieldResult.resultingValue),
                             "gridEdit");
            }
        }
    }

    // If dependencies were processed, we may have errors on other fields to show/clear.
    if (processDependencies) {
        for (var errorFieldName in allErrors) {
            if (errorFieldName != field.name) {
                this.setFieldError(rowNum, errorFieldName, allErrors[errorFieldName], true);
            }
        }
    }

    if (success) return null
    else return errors;
},

// cellIsRequired / getCellValidators allows us to separate our validator definitions from
// true field objects (makes custom cubeGrid validation easier to apply)
cellIsRequired : function (rowNum, colNum) {
    var field = this.getField(colNum);
    return field && (field.required || this.isXMLRequired(field));
},

getCellValidators : function (rowNum, colNum) {
    var field = this.getField(colNum);
    if (field && field.validators) return field.validators;
    return null;
},

getFieldEditorValidators : function (field) {

    if (!field) return [];
    var validators = [];
    var editorClass = field.editorType ? isc[field.editorType] : null;
    if (editorClass && editorClass.getPrototype && editorClass.getPrototype().validators) {
        // if there are prototype validators on the (editorType) formItem, append them
        validators.addList(isc.shallowClone(editorClass.getPrototype().validators));
    }
    var editorProps = field.editorProperties
    if (editorProps && editorProps.validators) {
        // if there are validators on the field's editorProperties, append those too
        validators.addList(isc.shallowClone(editorProps.validators));
    }
    // if there are validators, return them - otherwise return null
    return validators.length > 0 ? validators : null;
},

// Validation Errors
// ---------------------------------------------------------------------------------------

//> @method listGrid.hasErrors()
// Does this grid currently have errors associated with editValues for any row in the grid.
// @group gridValidation
// @return  (Boolean)   true if there are unresolved errors, false otherwise
// @visibility external
// @see listGrid.rowHasErrors()
// @see listGrid.cellHasErrors()
//<
hasErrors : function () {
    var editRows = this.getAllEditRows(true);
    for (var i = 0; i < editRows.length; i++) {
        if (this.rowHasErrors(editRows[i])) return true;
    }
    return false;
},

//> @method listGrid.rowHasErrors()
// Does the specified row have unresolved errors?
// @group gridValidation
// @param rowNum (int)   rowNum to check for errors
// @return  (Boolean)   true if there are unresolved errors, false otherwise
// @visibility external
// @see listGrid.hasErrors()
// @see listGrid.cellHasErrors()
//<
// Note: the rowNum parameter can also be the editValuesID property associated with some
// set of edit values [IE some edited row] for the grid.
rowHasErrors : function (rowNum, colNum) {
    var editData = this.getEditSession(rowNum, colNum);

    return (editData && editData._validationErrors &&
            !isc.isA.emptyObject(editData._validationErrors));
},

//> @method listGrid.cellHasErrors()
// Given a rowNum and a colNum or fieldName, determine whether we currently have stored
// validation errors for the record/field in question.
//  @group gridValidation
//  @param  rowNum  (number)    index of row to check for validation errors
//  @param  fieldID (string | number)    name of field, or index of column to check for validation
//                                      errors
//  @return (Boolean)   true if we have validation errors for the row/col in question
// @visibility external
// @see listGrid.hasErrors()
// @see listGrid.rowHasErrors()
//<
// As with rowHasErrors, the rowNum can be an editValuesID as well as a rowNum

cellHasErrors : function (rowNum, fieldID) {
    var fieldName = this.getEditorName(rowNum, fieldID),
        editData = this.getEditSession(rowNum, fieldID),
        errors = editData ? editData._validationErrors : null;

    return (
        errors != null &&
        errors[fieldName] != null
    );
},


// No obvious use for a listGrid.getErrors() method.

//>!BackCompat 2007.02.14
//> @method listGrid.getRowValidationErrors()
//  Returns any currently stored validation errors for this row in the following format:<br>
//  &nbsp;&nbsp;<code>{fieldName:[validation error array], ...}</code>
//  @group  editing
//  @visibility internal
//  @param  rowNum (number) index of row to check for validation errors.
//  @return (object)   object showing validation error arrays by field for the row passed in - if
//                      no validation errors stored for the row, null is returned.
// @deprecated in favor of +link{listGrid.getRowErrors()}
//<

getRowValidationErrors : function (rowNum) {
    return this.getRowErrors(rowNum);
},
//<!BackCompat

//> @method listGrid.getRowErrors()
//  Returns any currently stored validation errors for this row in the following format:<br>
//  &nbsp;&nbsp;<code>{fieldName:[array of error messages], ...}</code>
//  @group gridValidation
//  @param  rowNum (number) index of row to check for validation errors.
//  @return (object)   object showing validation error arrays by field for the row passed in
//                      - if no validation errors stored for the row, null is returned.
// @visibility external
// @see listGrid.getCellErrors()
//<

getRowErrors : function (rowNum, colNum) {
    var data = this.getEditSession(rowNum, colNum);
    return (data != null ? data._validationErrors : null);
},

//> @method listGrid.getCellErrors()
//  Returns the current set of errors for this cell.
//  @group gridValidation
//  @param  rowNum (number) index of row to check for validation errors.
//  @param  fieldName   (String | number)   field to check for validation errors - can be fieldName
//                                          or index of the column.
//  @return (Array of String) array of error messages (strings) for the specified cell. If no validation
//                  errors are present, returns null.
//  @visibility external
//<
getCellErrors : function (rowNum, fieldName) {
    // assume fieldName is a colNum if we're working with cellrecords
    var data = this.getEditSession(rowNum, fieldName);
    if (data == null) return null;

    if (isc.isA.Number(fieldName)) fieldName = this.getEditorName(rowNum, fieldName);
    var errors = data._validationErrors;
    return (errors == null ? null : errors[fieldName]);
},


// Synonym of setFieldError(), since we already supply getCellErrors()
setCellErrors : function (row, field, error, suppressDisplay) {
    return this.setFieldError(row, field, error, suppressDisplay);
},

//> @method listGrid.setFieldError()
// Set a validation error for some cell.
// @group gridValidation
// @param  rowNum  (number)    row index of cell to add validation error for
// @param  fieldName (String | number)    col index or field name of cell to add validation error for
// @param  errorMessage  (string | array of strings)    validation error/errors for the cell.
// @visibility external
// @see listGrid.getCellErrors()
// @see listGrid.setRowErrors()
//<
setFieldError : function (rowNum, fieldID, errorMessage, dontDisplay) {
    var fieldName = fieldID;
    if (isc.isA.Number(fieldName)) fieldName = this.getEditorName(rowNum, fieldName);

    // If passed an empty set of errors, use delete to clear the error instead
    if (errorMessage == null || (isc.isAn.Array(errorMessage) && errorMessage.length == 0)) {

        if (!this.cellHasErrors(rowNum, fieldID)) return;

        this.logDebug("setFieldError() passed empty errors- clearing the errors for row:" + 
                      rowNum + ", field:" + fieldID, "gridEdit");

        var data = this.getEditSession(rowNum, fieldID);
        delete data._validationErrors[fieldName];
        // Don't hang onto an empty errors object - this will confuse hasErrors et al.
        if (isc.isAn.emptyObject(data._validationErrors)) delete data._validationErrors
    } else {
        // If passed a bad fieldNum, for example, just drop it
        if (fieldName == null) {
            this.logWarn("setFieldError() passed field identifier '" + fieldID + "'. " +
                        "Unable to find corresponding field in this grid - not setting error.");
            return;
        }

        // Warn if the user has set errors on non visible fields (or completely random fields)
        var visFields = this.getFields().getProperty(this.fieldIdProperty);
        if (!visFields.contains(fieldName)
            
            )
        {
            this.logWarn("setFieldError() passed field identifier '" + fieldID + "'. This " +
                         "is not a visible field in the grid - error may not be visible to user.");
        }

        var errors;
        if (isc.isAn.Array(errorMessage)) errors = errorMessage
        else errors = [errorMessage];

        var data = this.getEditSession(rowNum, fieldID);
        // Unlikely to happen, but catch the case of being passed a row with no edit values
        if (data == null) {
            var colNum = this.getColNum(fieldID),
                record = this.getCellRecord(rowNum, colNum);
            data = this.createEditSession(rowNum, colNum, record);
        }

        this.logDebug("setFieldError() setting errors for row:" + rowNum + ", field:"
              + fieldID + " to:" + this.echo(errors), "gridEdit");


        if (data._validationErrors == null) data._validationErrors = {};
        data._validationErrors[fieldName] = errors;
    }

    // If appropriate show the errors to the user
    if (!dontDisplay) {
        
        if (this.useCellRecords) this.showCellErrors(rowNum, fieldID)
        else this.showErrors(rowNum, [fieldName]);
    }
},

// This method passes straight through to setFieldError; it is implemented purely so that
// DBC._handleServerValidationResponse has a standard method to call when populating errors
addFieldErrors : function (fieldName, errorMessage, showErrors, rowNum) {
    this.setFieldError(rowNum, fieldName, errorMessage);
},

//> @method listGrid.setRowErrors()
// Set the validation errors for some row (replacing any pre-existent validation errors)
// <P>
// Note that in the case of a +link{listGrid.groupByField,grouped listGrid}, or a 
// +link{treeGrid}, some records may be hidden form view (part of a collapsed group or
// parent folder). In this case there is no meaningful row number associated with a record.
// This method cannot be called on such rows - developers should make the row visible first.
// This is by design - users should always be able to see errors.
//    
// @group gridValidation
// @param  rowNum  (number)    row to add validation error for
// @param  errors (any) validation errors for the row in the format
//                          <code>{fieldName:errorMessage, ...}</code> <br>or <br>
//                          <code>{fieldName:[errorMessage1, errorMessage2], ...}</code>
// @visibility external
// @see listGrid.getRowErrors()
// @see listGrid.setFieldError()
//<

setRowErrors : function (rowNum, errors, dontDisplay) {
    

    if (rowNum == null || rowNum == -1) return;

    var storedErrors = this.getRowErrors(rowNum);
    if (!errors && !storedErrors) return;

    var data = this.getEditSession(rowNum);
    
    if (data == null) data = this.createEditSession(rowNum, null, this.getRecord(rowNum));
    if (errors) {

        var visibleFields = this.getFields().getProperty(this.fieldIdProperty);
        for (var fieldName in errors) {
            // Warn if passed an error on a non-visible field as this will not show up
            // via the standard 'error cell' styling
            // Should probably have a customizable method to handle this
            if (!dontDisplay && !visibleFields.contains(fieldName)) {
                this.logWarn("setRowErrors() passed error for non-visible field: '" + fieldName + "'");
            }

            // Convert single error message strings into arrays.
            if (!isc.isAn.Array(errors[fieldName])) errors[fieldName] = [errors[fieldName]];
        }
    }
    this.logDebug("setRowErrors() setting errors for row " + rowNum + " to " + 
                  this.echo(errors), "gridEdit");

    // Actually store the validation object.
    data._validationErrors = errors;

    if (!dontDisplay) {

        // For efficiency, only refresh cells that actually need to be refreshed due to
        // new errors, or errors being cleared.
        var fields = errors ? isc.getKeys(errors) : [];

        // We need to update each cell in the row to reflect any changes to validation errors,
        // either new errors, or errors that have been cleared.
        for (var fieldName in storedErrors) {
            var colNum = this.getColNum(fieldName);

            if (!fields.contains(fieldName)) fields.add(fieldName);
        }

        // Call showErrors() to actually update the error styling on the cells and show any
        // error messages to the user
        this.showErrors(rowNum, fields);
    }
},

//> @method listGrid.clearFieldError()
// Clears any validation errors for some cell.
// @group gridValidation
// @param  rowNum  (number)    row index of cell to add validation error for
// @param  fieldName (number | string)    col index or field name of cell to add validation error for
// @visibility external
// @see listGrid.setFieldError()
//<
clearFieldError : function (rowNum, fieldName, dontDisplay) {
    return this.setFieldError(rowNum, fieldName, null, dontDisplay);
},


//> @method listGrid.clearRowErrors()
//  Clear any stored validation errors for some row
//  @group  validation
//  @param  rowNum  (number)    index of row to clear validation error for
// @visibility external
// @see listGrid.setRowErrors()
//<
clearRowErrors : function (rowNum, dontDisplay) {
    this.setRowErrors(rowNum, null, dontDisplay);
},



// Showing Validation Errors
// ---------------------------------------------------------------------------------------

//> @method listGrid.showErrors() ([A])
// Update the specified row to display the current set of validation errors.<br>
// If +link{listGrid.stopOnErrors} is true and the row has errors, this method will also
// call display the error messages to the user in a warning dialog, and reset focus to
// the first cell that failed validation.
// @param rowNum (number) row to be updated
// @param [fields] (array) Array of fieldNames for which errors should be displayed or cleared.
//                      If not passed defaults to displaying errors for every field in the row.
// @group gridValidation
// @visibility internal
//<
// Notes:
// - This is a potential override point - may want to make this external
// - The fields parameter is for more than just efficiency - it will also modify which
//   errors get displayed to the user via displayRowErrorMessages()
// - falls through to displayRowErrorMessages() to actually show the error messages
//   to the user in a warn dialog if stopOnErrors is true. Not clear that there's much point
//   to exposing this as if a developer wants to perform custom validation display this method
//   would probably be the more natural override point.
showErrors : function (rowNum, fields) {
    
    if (fields == null) fields = this.getFields().getProperty(this.fieldIdProperty);

    var errors = this.getRowErrors(rowNum);
    if (errors == null) errors = {};

    var firstFieldName;
    for (var i = 0; i < fields.length; i++) {
        var fieldName = fields[i];
        // Update the cell to display error styling and icon (or clear errorIcon and styling)
        this.showCellErrors(rowNum, fieldName);

        if (firstFieldName == null && errors[fieldName]) firstFieldName = fieldName;
    }

    // Split the method to convert the errors into a user-visible string into a separate
    // method for localization
    var errorMessageString = this.assembleErrorMessage(errors, fields);

    // Call a simple (overrideable) method to actually inform the user of the validation errors.
    
    if (errorMessageString) {
        this.displayRowErrorMessages(errorMessageString);
    }

    // If we're not saving in the background, put focus back into the first cell that failed
    // the edit (only necessary if the validation failed)
    if (this.stopOnErrors && firstFieldName != null) {
        var firstColNum = this.getColNum(firstFieldName);

        if (firstColNum != -1) {
            this.showInlineEditor(rowNum, firstColNum);
            return;
        }
        for (var fieldName in errors) {
            if (this.fieldIsVisible(fieldName) && errors[fieldName]) {
                this.showInlineEditor(rowNum, this.getColNum(fieldName));
            }
        }
    }
},

// showCellErrors()
// Helper method to update a cell in the body to display errors (or clear errors if appropriate)
showCellErrors : function (rowNum, colNum) {

    // Accept the 2nd param as a colNum or fieldName
    var fieldName;
    if (isc.isA.Number(colNum)) {
        this.getEditorName(rowNum, colNum);
    } else {
        fieldName = colNum;
        colNum = this.getColNum(fieldName);
    }
    // If passed a non-visible field, just bail.
    if (colNum == -1) return;

    if (this.showErrorIcons) {
        // refresh cell to rewrite the HTML to show (or hide) the icon.
        this.refreshCell(rowNum,colNum, null, true);
    } else {
        this.body._updateCellStyle(null, rowNum, colNum)
    }
},


//> @method listGrid.assembleErrorMessage()
// This method is called when validation errors occur, and assembles the set of errors into
// a string to be displayed to the user. Overridable for localization.
// @param errors (object) Object containing <code>fieldName:error</code> mappings. Note that the
//              <code>error</code> object for each field may be a simple error message string,
//              a pointer to the validator that failed (so the errorMessage is available as
//              the <code>errorMessage</code> attribute of that object, or
//              an array of validator type objects (for multiple validation failures).
// @return (string) By default returns a string in the following format:<pre>
//                  Validation errors occurred:
//                  Field '[fieldTitle]':
//                  * [errorMessage]
//                  * [errorMessage]
//                  </pre>
// @visibility internal
// @group editing, i18nMessages
//<
assembleErrorMessage : function (errors, fields) {

    // Iterate through the set of errors, assembling an
    // error message string to show the user for the row.
    // Note the errors object is expected to be in the format:
    //   {fieldName:["error message 1", "errorMessage 2", ...],
    //    fieldName2:["error message 1", ...], ... }
    var errorMessageFound = false,
        errorMessageString = "Validation Errors occurred:\r\n";

    for (var fieldName in errors) {
        if (fields && !fields.contains(errors)) continue;

        // Assemble the errors together into a string to ultimately be passed to
        // 'displayRowErrorMessages'
        var errorMessage = this._createFieldErrorString(fieldName, errors[fieldName]);

        if (errorMessage != null) {
            errorMessageFound = true;
            errorMessageString += errorMessage;
        }

    }
    return (errorMessageFound ? errorMessageString : null);
},


// Internal helper for assembling all the error messages for a row into a single string
_createFieldErrorString : function (fieldName, errors) {
    // Assemble the errors together into a string to ultimately be passed to
    // 'displayRowErrorMessages'
    var errorMessageString, fieldErrorMessage,
        field = this.getField(fieldName),
        fieldTitle = field && field.title ? field.title : fieldName;

    // Note that we always normalize the format of stored errorMessages to
    // an array of strings per field
    for (var i =0; i < errors.length; i++) {
        var errorMessage = errors[i];
        if (errorMessage != null) {
            if (fieldErrorMessage == null) {
                fieldErrorMessage = "<br>Field '" + fieldTitle + "':";
            }
            fieldErrorMessage += "<br>* " + errorMessage;
        }
    }
    return fieldErrorMessage;
},

//> @method listGrid.displayRowErrorMessages()
//  A simple method called from 'showErrors' to display errorMessages from validation
//  on some row.
//  Takes a single errorMessage parameter - default implementation alerts this string if
//  this.stopOnErrors is true.<br>
//  Notes:<br>
//  Override this method to display error messages in some other way.<br>
//  For a more sophisticated validation error handling, the 'showErrors()' method can be
//  overridden instead.<br>
//  @group  editing
//
//  @param  rowNum  (number) Index of the record on which the validation errors occurred.
//  @param  errors  (object) Object containing a map of field names to arrays of validation errors.
//  @see    listGrid.validateCellValue()
//  @see    listGrid.showErrors()
//  @see listGrid.assembleErrorMessage()
//<
displayRowErrorMessages : function (errorString) {
    
    if (this.stopOnErrors) isc.warn(errorString, "var LG=" + this.getID() +
                                            ";if(LG._editRowForm)LG._editRowForm.focus()");
    // -- in this case we might want to stick the error into a hover, etc.
    // - but hold off on that for now
},

// Removal of data
// ---------------------------------------------------------------------------------------



//> @method listGrid.removeData()
// Remove a record from this ListGrid.
// <P>
// If this grid is bound to a DataSource, it will perform a DataSource "remove" operation to
// remove records from this component's DataSource.
// <P>
// Otherwise the data will be removed from the grid's +link{listGrid.data,data} object.
// <P>
// To make changes to the local data object even when a DataSource is present, use
// +link{listGrid.saveLocally}.
//
// @param data (Record) listGrid record, or primary key values of record to delete.
// @param [callback] (DSCallback)  method to call on operation completion.
//   Note that if this is method does not trigger a dataSource remove operation, the callback
//   will still be fired when the data has been removed, but the <code>dsResponse</code> parameter
//   will be null.
// @param [requestProperties] (DSRequest Properties)   additional properties to set on any DSRequest
//                                          that will be issued
//
// @group dataBoundComponentMethods
// @visibility external
//<
removeData : function (recordKeys, callback, requestProperties, fromUserAction) {

    // Hang the original callback onto the request internalClientContext - we'll fire it from
    // 'removeDataComplete()'.
    

    // copy to avoid problems with re-using the same object
    requestProperties = isc.addProperties({}, requestProperties);

    
    requestProperties.internalClientContext = {
        removeDataCallback: callback
    };

    var editInfo = {
        fromUserAction:fromUserAction,
        // Note: rowNum / colNum are basically available for callbacks
        rowNum:this.findRowNum(recordKeys),
        colNum:null,
        values:recordKeys,
        editCompletionEvent:isc.ListGrid.PROGRAMMATIC
    };
    requestProperties.internalClientContext.editInfo = editInfo;

    // Override willHandleError so we don't get wedged in a loading state
    requestProperties.internalClientContext._explicitWillHandleError = requestProperties.willHandleError;
    requestProperties.willHandleError = true;

    if (this.getDataSource() != null && !this.shouldSaveLocally()) {

        return this.Super("removeData",
                [recordKeys, {target:this, methodName:"removeDataComplete"}, requestProperties],
                arguments);
    }
    if (this.data) {
        var editValuesID = this.getEditValuesID(recordKeys);
        if (editValuesID != null) this.discardEdits(editValuesID);
        if (isc.ResultSet && isc.isA.ResultSet(this.data) && this.shouldSaveLocally()) {
            if (this.data.allRows != null) {
                this.data.allRows.remove(recordKeys);
                this.data.filterLocalData();
            } else {
                this.logWarn("Unable to remove data from resultSet - allRows is not set");
            }
        } else {
            var origData = this.getOriginalData();
            origData.remove(recordKeys);
        }
        this.updateFieldWidthsForAutoFitValue("removeData");
        this.regroup();
    }

    this.fireCallback({target:this, methodName:"removeDataComplete"},
                    "dsResponse,data,dsRequest",
                     [null,recordKeys,requestProperties]);
},

removeDataComplete : function (dsResponse, data, dsRequest) {

    // We set up dsRequest.internalClientContext.editInfo even if this was client-only.
    var context = dsRequest.internalClientContext,
        editInfo = context.editInfo,
        fromUserAction = editInfo.fromUserAction,
        rowNum = editInfo.rowNum,
        colNum = editInfo.colNum,
        values = editInfo.oldValues || editInfo.values,
        editCompletionEvent = editInfo.editCompletionEvent;

    var success = dsResponse == null || dsResponse.status >= 0;
    if (success) {
        // if we have edit vals for the removed data, clear them up.
        if (!isc.isAn.Array(data)) data = [data];
        for (var i = 0; i < data.length; i++) {
            var editValsID = this.getEditValuesID(data[i]);
            if (editValsID != null) {
                this.discardEdits(editValsID);
            }
        }

        // Fire 'editComplete' notification since a remove is a specialized edit.
        // editComplete takes old and new values -- for removal of course this is just
        // the record being removed -- really just the primary key.
        var newValues = editInfo.values || editInfo.oldValues,

            rowNum = editInfo.rowNum;

        if (fromUserAction && this.convertToMethod("editComplete")) {
            this.editComplete(rowNum, colNum, values, values, editCompletionEvent, dsResponse);
        }
    } else {
        // We overrode willHandleError for the request.
        // Fire standard error handling now unless the original request already suppressed
        // this.
        var willHandleError = dsRequest.internalClientContext._explicitWillHandleError;
        if (!willHandleError) {
            isc.RPCManager._handleError(dsResponse, dsRequest)
        }
//        this.logWarn("removeData failed on server:" + data);
        // fire editFailed notification
        if (fromUserAction && this.convertToMethod("editFailed")) {
            this.editFailed(rowNum, colNum, values, values,
                            editCompletionEvent, dsResponse, dsRequest);
        }
    }

    // Note that if the server failed, we still need to fire callbacks - expected in
    // 'showRemoveCompleteAnimation' at least.
    if (context.removeDataCallback) {
        this.fireCallback(context.removeDataCallback,
                        "dsResponse,data,dsRequest", [dsResponse,data,dsRequest]);
    }
},

//> @method listGrid.removeRecordClick()
// Method fired when the user clicks the "remove" icon if +link{canRemoveRecords} is true.
// Default behavior will remove the record from the data set, or if we're
// +link{deferRemoval,deferring removal} mark record as removed [or for records already
// marked as removed, clear this removed marker].
// <P>
// If +link{listGrid.warnOnRemoval} is set, this method will also show a warning dialog to users
// allowing them to cancel the removal.
// <P>
// This method may be called directly to cause a record to be removed or marked for removal
// as if the user had hit the "remove" icon.
// <P>
// <smartgwt>To be notified when a "remove" click occurs, developers
// should add a
// {@link com.smartgwt.client.widgets.grid.ListGrid#addRemoveRecordClickHandler * RemoveRecordClickHandler}.
// </smartgwt>
// <smartclient>May be overridden to perform custom logic on remove click.</smartclient>
// @param rowNum (int) Row on which the icon was clicked
// @visibility external
//<

removeRecordClick : function (rowNum,colNum) {
    var record = this.getRecord(rowNum);
    // if there's no record, nothing to do

    // If this record is explicitly marked to not allow removal ignore the click
    if (this.recordCanRemoveProperty && record != null &&
        record[this.recordCanRemoveProperty] == false)
    {
        return;
    }

    // SGWT event handler entry point.
    
    if (this.onRemoveRecordClick(rowNum) == false) return;
    var shouldWarn = this.warnOnRemoval,
        shouldDefer = this.shouldDeferRemoval();
    // don't warn on unremoval.
    if (shouldWarn && shouldDefer && this.recordMarkedAsRemoved(rowNum)) shouldWarn = false;

    if (shouldWarn) {
        isc.ask(
            this.warnOnRemovalMessage,
            this.getID() + ".completeRemoveRecordClick(value, " + rowNum + "," + colNum + ")"
        );
    } else {
        this.completeRemoveRecordClick(true, rowNum, colNum);
    }
},

//> @method listGrid.onRemoveRecordClick ()
// Handler fired when the user clicks the "remove" icon if +link{canRemoveRecords} is true.
// Default behavior will remove the record from the data set, or if we're
// +link{deferRemoval,deferring removal} mark the record as removed [or for records already
// marked as removed, clear this removed marker].
// <P>
// If +link{listGrid.warnOnRemoval} is set, this method will also show a warning dialog to users
// allowing them to cancel the removal.
// <P>
// This event may be cancelled to suppress the default behavior.
//
// @param rowNum (int) Row on which the icon was clicked
// @return (boolean) return false to cancel the event
// @visibility sgwt
//<

onRemoveRecordClick : function (rowNum) {
    return true;
},

completeRemoveRecordClick : function (shouldRemove, rowNum, colNum) {
    // user hit "No" on the warn dialog - just bail.
    if (!shouldRemove) return;

    if (this.shouldDeferRemoval()) {
        if (this.recordMarkedAsRemoved(rowNum)) {
            this.unmarkRecordRemoved(rowNum);
        } else {
            this.markRecordRemoved(rowNum);
        }
    } else {
        var editRows = this.getAllEditRows(),
            isEditing = editRows.contains(rowNum);

        if (isEditing) this.discardEdits(rowNum, colNum);

        var record = this.getCellRecord(rowNum,colNum);
        if (record == null) return;
        // use delayCall to actually remove the record in a separate thread.
        // required since we can't redraw immediately in response to a mouseDown
        this.delayCall("removeRecord", [rowNum, record]);
    }
},

// Remove a record from this ListGrid.
// This is called from a click on the remove field.

removeRecord : function (rowNum, record) {
    if (record == null) record = this.data.get(rowNum);
    else rowNum = (this.data ? this.data.indexOf(record) : null)

    // Only support removing the record if it's actually showing up in this grid!
    // (This not removing nodes in closed parent folders for example)
    if (record == null || rowNum == null || rowNum == -1 || !this.data) return;

    if (isc.Offline && isc.Offline.isOffline() && this.dataSource && !this.dataSource.clientOnly) {
        isc.warn(this.offlineSaveMessage);
        return;
    }

    // animating record removal
    // If we're animating the record removal, we want to remove the data before starting the
    // animation. This ensures the record gets successfully cleared (not guaranteed in the case
    // of a server operation).
    // Set up the row animation before removing the data, then kick off the animation when we know
    // row removal was successful.
    
    var animateRemoveRecord = this.animateRemoveRecord && this.isDrawn() && this.isVisible() &&
                              this.body &&
                              rowNum >= this.body._firstDrawnRow &&
                              rowNum <= this.body._lastDrawnRow;

    // Don't attempt to animate remove rows with embedded components. Since the components
    // won't be clipped by the animation it'll look funky.
    if (this._hasEmbeddedComponents(record)) {
        animateRemoveRecord = false;
    }

    if (animateRemoveRecord) {
        this._suppressRedrawOnDataChanged = true;
        var delta = 1;
        if (isc.isA.Tree(this.data) && this.data.isFolder(record) && this.data.isOpen(record)) {
            var children = this.data.getChildren(record);
            if (children && (!isc.isA.ResultSet(children) || children.lengthIsKnown())) {
                delta += children.getLength();
            }
        }

        this._removeRowDelta = delta;
        // perform the setup for the animated hide while our data is still present in our dataSet
        this.body._initializeShowHideRow(false, rowNum, rowNum+delta);
    }

    var ds = this.getDataSource(),
        removeLocally = (ds == null || this.shouldSaveLocally());
    if (!removeLocally) {
        if (!ds.getPrimaryKeyField()) {
            this.logWarn("DataSource:"+ ds +
                        " has no primary key field - unable to remove records");
            return;
        }
    }
    var callback;
    if (animateRemoveRecord) {
        callback = this.getID() + ".showRemoveCompleteAnimation(" + rowNum + ", data,dsResponse);";
    }
    this.removeData(record, callback, {showPrompt:false}, true);
},

// Callback to animate a removed record out of view. Set up by 'removeRecord()'
showRemoveCompleteAnimation : function (rowNum, record, response) {
    // if this was a server-based removal, check for errors
    if (response && response.status < 0) {
        this.logWarn("Removal of record failed");
        record = null;
    }

    if (!record) {
        delete this._suppressRedrawOnDataChanged;

        if (this.body) {
            // clear up the properties set up by _initializeShowHideRow
            delete this.body._animatedShowStartRow;
            delete this.body._animatedShowEndRow;
            delete this.body._animatedShowRowHeight;
            delete this.body._animatedShowCallback;
        }
        this.markForRedraw();
    } else {
        this.startRowAnimation(false, rowNum, rowNum+this._removeRowDelta,
                                {target:this, methodName:"_removeDataAnimationComplete"},
                                this.animateRemoveSpeed, this.animateRemoveTime);
        delete this._removeRowDelta;
    }
},

_removeDataAnimationComplete : function () {
    delete this._suppressRedrawOnDataChanged;
    this.redraw();
},


// Row Animation
// ---------------------------------------------------------------------------------------

//>Animation
// Animated showing and hiding of rows
//> @method listGrid.startRowAnimation()
// @include gridRenderer.startRowAnimation()
//<
startRowAnimation : function (show, startRow, endRow, callback, speed,
                               duration, effect, slideIn, delayed)
{
    if (!this.body) return;

    // force an immediate finish of any currently running row animation.
    // will no op in most cases
    this.finishRowAnimation();

    this._rowAnimationCompleteCallback = callback;

    // if we have a frozen body too, animate there, but avoid firing the callback twice when
    // both animations complete
    if (this.frozenBody) {
        this.frozenBody.startRowAnimation(show, startRow, endRow,
                                          {target:this, methodName:"rowAnimationComplete",
                                           argNames:"body,hasFrozenBody",
                                           args:[this.frozenBody, true]},
                                          speed,
                                          duration, effect, slideIn, true, delayed);
    }
    this.body.startRowAnimation(show, startRow, endRow,
                                {target:this, methodName:"rowAnimationComplete",
                                 argNames:"body,hasFrozenBody",
                                 args:[this.body, (this.frozenBody != null)]},
                                speed,
                                duration, effect, slideIn, true, delayed);
},

// rowAnimationComplete callback - fires the callback passed to startRowAnimation.
// Will be called twice if we have a frozenBody as well as a liquid body - in this case
// only fire the callback we were passed when both bodies have finished animating
rowAnimationComplete : function (body, hasFrozenBody) {
    var fireCallback = !hasFrozenBody || this._frozenBodyAnimationComplete;

    if (!fireCallback) {
        // just set a flag so the next time this method is run (with the other body), we'll
        // fire our callback.
        this._frozenBodyAnimationComplete = true;
    } else {
        delete this._frozenBodyAnimationComplete;

        var callback = this._rowAnimationCompleteCallback;
        delete this._rowAnimationCompleteCallback;
        if (callback != null) this.fireCallback(callback);
    }
},

finishRowAnimation : function () {
    if (this.body) this.body.finishRowAnimation();
    if (this.frozenBody) this.frozenBody.finishRowAnimation();
},

//> @method listGrid.animateRowHeight()
// @include gridRenderer.animateRowHeight()
//<
animateRowHeight : function (rowNum, newHeight, callback, speed, duration, effect, slideIn) {
    if (!this.body) return;
    return this.body.animateRowHeight(rowNum, newHeight, callback, speed, duration, effect, slideIn, true);
},
//<Animation

//> @method listGrid.setCellHeight()
// Set the cellHeight for the listGrid as a whole. To set the height of individual rows use
// +link{ListGrid.setRowHeight()} instead.
//<
setCellHeight : function (newHeight) {
    var oldHeight = this.cellHeight;
    this.cellHeight = newHeight;
    if (this.body) this.body.cellHeight = newHeight;
    if (oldHeight != newHeight && this.isDrawn()) {
        this.body.markForRedraw("Cell height changed");
        if (this.frozenBody) this.frozenBody.markForRedraw("Cell height changed");
    }

},


//> @method listGrid.setRowHeight()
// @include gridRenderer.setRowHeight()
//<
setRowHeight : function (rowNum, newHeight) {
    if (!this.body) return;
    // keep frozen / unfrozen bodies in sync
    if (this.frozenBody != null) this.frozenBody.setRowHeight(rowNum, newHeight);

    return this.body.setRowHeight(rowNum, newHeight);
},


// Body Drag&Drop (selection, reorder records, drag records out, drop records in)
// --------------------------------------------------------------------------------------------

//> @method listGrid.setDragTracker()
// @include dataBoundComponent.setDragTracker()
// @visibility external
//<

//> @method listGrid.getDragTrackerProperties()
// @include dataBoundComponent.getDragTrackerProperties()
//<

//> @attr listGrid.dragTrackerStyle
// @include dataBoundComponent.dragTrackerStyle
//<


//> @method listGrid.getDragTrackerIcon()
// Return an icon to display as a drag tracker when the user drags some record.<br>
// Default implementation:
// If +link{listGridField.valueIcons} is specified for the title field of this grid
// (see +link{listGrid.getTitleField()}), the appropriate value icon will be displayed.
// If no appropriate valueIcon can be found, the icon will be derived from
// +link{ListGrid.trackerImage}.<br>
// If multiple records are selected, only the first record is examined for valueIcons.
// <p>
// Note: Only called if +link{listGrid.dragTrackerMode} is set to <code>"icon"</code>.
// @param records (Array of ListGridRecord) Records being dragged
// @return (string) Image URL of icon to display
// @group dragTracker
// @visibility external
//<
getDragTrackerIcon : function (records) {
    // we don't expect this method to fire if no records are selected, but if so, just show
    // the generic drag tracker
    var record = records ? records[0] : null,
        icon;
    if (record) {
        var titleFieldName = this.getTitleField();
        icon = this.getValueIcon(this.getField(titleFieldName), record[titleFieldName], record);
    }
    if (icon == null) icon = this.trackerImage;
    return icon;
},

//> @method listGrid.getDragTrackerTitle()
// Return "title" HTML to display as a drag tracker when the user drags some record.<br>
// Default implementation will display the cell value for the title field (see
// +link{listGrid.getTitleField()}) for the record(s) being dragged (including any
// icons / custom formatting / styling, etc).
// <p>
// Note: Only called if +link{listGrid.dragTrackerMode} is set to <code>"title"</code>.
// @param record (ListGridRecord) First selected record being dragged
// @param rowNum (number) row index of first record being dragged
// @return (string) Title for the row. Default implementation looks at the value of the
//                  title-field cell for the row.
// @group dragTracker
// @visibility external
//<
getDragTrackerTitle : function (record, rowNum) {
    var undef,
        titleField = this.getTitleField(),
        formattedValue = this.getFormattedValue(record, titleField, record ? record[titleField] : undef);
    return "<nobr>" + formattedValue + "</nobr>";
},

// We have our own drag/drop handling and don't want the Layout level handling
// (showing drop line, allowing user to drop new members in the layout, etc)
_suppressLayoutDrag:true,

//> @method listGrid.dragStart()    (A)
// drag start event
// @group events, dragging
// @return (boolean) false non-existent record or !canDrag; true otherwise
//<
dragStart : function () {
    // if dragging means drag-selection, we do nothing until dragMove
    if (this.canDragSelect) return true;

    // get the selection
    var selection = this.selection.getSelection();
    // if the selection is empty or anything in the selection is canDrag == false,
    //  cancel the drag by returning false
    if (selection.length == 0) return false;
    for (var i = 0; i < selection.length; i++) {
        if (!selection[i]._isGroup && selection[i].canDrag == false) return false;
    }

    // Otherwise store a snapshot of the current selection on the ListGrid object so that we
    // are able to transfer the correct record(s) when the user drops them, in the unlikely
    // event that they change the ListGrid selection (with the keyboard) during the drag
    // operation
    this._selectionAtDragStart = selection;

    return true;
},

dragMove : function () {
    var dropTarget = isc.EH.dropTarget;
    // if you're not allow to drag records out, cancel dragging over anything that isn't this
    // grid
    if (!this.canDragRecordsOut && dropTarget != null &&
        dropTarget != this && !this.contains(dropTarget))
    {
        return false;
    }
},

//> @method listGrid.dropMove() (A)
// Handle a dropMove event.  This will show the drag line in the appropriate position.
// @group events, dragging
// @return (boolean) true if the list can't reorder
//<
dropMove : function () {
    var accept = this.willAcceptDrop();
    if (accept) {
        // If the list can be reordered, show the dragLine
        if (this.canReorderRecords) this.showDragLineForRecord();

        // In case it was previously set
        this.body.clearNoDropIndicator();
        
        // We've claimed the drop, so don't bubble
        return false;
    } else if (accept == null) {
        // We wouldn't accept this drop for any record. So, let it bubble.
        return true;
    } else {
        // The drop would have been accepted for some rows, but not this one. 
        // In this case, show the no-drop cursor. 
        this.body.setNoDropIndicator();
        
        // But still show the drag-line if reordering is enabled, so the user
        // can see where they would be dropping -- so it's clear what's
        // disallowed.
        if (this.canReorderRecords) this.showDragLineForRecord();
        
        // We've conclusively denied the drop, so don't bubble
        return false;
    } 
},

dropOver : function () {
    // Execute the dropMove() logic for dropOver, so that we stop bubbling
    // in the appropriate cases, so that our ancestors don't draw dropLines
    // inappropriately.
    return this.dropMove();
},

//> @method listGrid.dropOut()  (A)
// handle a dragOut event
// @group events, dragging
//<
dropOut : function () {
    this.body.clearNoDropIndicator();
    this.hideDragLine();
},

//> @method listGrid.dragStop() (A)
// handle a dragStop event
// @group events, dragging
//<
dragStop : function () {
    this.body.clearNoDropIndicator();
    this.hideDragLine();
    this._selectionAtDragStart = null
},

//> @method listGrid.willAcceptDrop()   (A)
//
// This method overrides +link{Canvas.willAcceptDrop()} and works as follows:<br>
// <ul>
// <li>If +link{Canvas.willAcceptDrop()} (the superclass definition) returns false, this
//     method always returns false.  This allows +link{canvas.dragType} and
//     +link{canvas.dropTypes} to be used to configure eligibility for drop.  By default,
//     a ListGrid has no dropTypes configured and so this check will not prevent a drop.</li>
// <li>If this is a self-drop, that is, the user is dragging a record within this list, this is
//     an attempted drag-reorder.  If +link{ListGrid.canReorderRecords} is
//     false, this method returns false.</li>
// <li>If the +link{EventHandler.getDragTarget(),dragTarget} is another widget, if
//     +link{ListGrid.canAcceptDroppedRecords} is false this method returns false.</li>
// <li>If a call to +link{ListGrid.getDragData()} on the <code>dragTarget</code> fails to return
//     an record object or an array of records, this method returns null.</li>
// <li>If the drop target record is disabled or has +link{ListGridRecord.canAcceptDrop}
//     set to false, return false.</li>
// </ul>
// Note that this method may be called repeatedly during a drag-drop interaction to update the
// UI and notify the user as to when they may validly drop data.
//
// @group   events, dragging
// @return (boolean) true if this component will accept a drop of the dragData,
//                   otherwise false, or null if the drop() should be bubbled
//                   to parent elements
// @see ListGridRecord.canAcceptDrop
// @see ListGrid.getDragData()
//
// @visibility external
//<
willAcceptDrop : function () {
    // Use superclass implementation to check that there is a valid dragTarget, and
    // that dragType / dropTypes (if set) match up.
    // Note - if we're dragReordering a record within this listGrid, the dragTarget will
    // be this widget.  This is because we set up the listGrid body's dragTarget property to
    // point back to this widget (unless this.canDragSelect is true).
    // If we're doing a drag selection, this method will not be called, as drag select doesn't
    // involve dropping.
    // Therefore if the dragTarget is this widget, we can assume we're reordering records within
    // this widget.
    // If dropTypes are specified on this widget, and a developer wants canReorderRecords
    // behavior, they must specify a dragType on this LV that matches a dropType -- they can
    // just make up a "reorderDragDrop" dragType/dropType.
    var EH = this.ns.EH;

    var superAccept = this.Super("willAcceptDrop", arguments);
    if (!superAccept && EH.dragTarget != this.body) return superAccept;

    if (EH.dragTarget == this) {
        // Bail if we're attempting to drag records within LV, and we can't reorder
        // Since we're dragging our own records, return false to forbid bubbling
        if (!this._canDragRecordsToSelf()) return false;
    } else {
        // Bail if we're attempting to drag from elsewhere and canAcceptDroppedRecords is false
        // Since we're dragging from elsewhere, return null to allow bubbling
        if (!this.canAcceptDroppedRecords) return null;
    }

    // if not native dragging and the 'getDragData' for the dragTarget doesn't give us a suitable
    // object (Array or Object), bail (but allow bubbling)
    if (!EH.nativeDragging &&
        !EH.wasNativeDragging &&
        !isc.isAn.Object(EH.dragTarget.getDragData()))
    {
        // Allow bubbling
        return null;
    }

    isc._useBoxShortcut = true;
    // get the record being dropped on
    var rowNum = this.getEventRecordNum(),
        colNum = this.getEventFieldNum();
    var position = this.getRecordDropPosition(rowNum);
    if (rowNum != -2 && position == isc.ListGrid.AFTER) rowNum += 1;
    isc._useBoxShortcut = false;

    // if cursor is below the list, it's ok (may want to drop below last record), unless
    // canDropInEmptyArea is false
    if (rowNum < -1) {
        if (this.canDropInEmptyArea == false) return false;
        return true;
    }

    // if the cursor is above the list, bail
    if (rowNum == -1) return false;

    // if the record is disabled or can't accept drops, return false to cancel drop
    var record = this.getRecord(rowNum, colNum);
    if (!this.recordIsEnabled(record, rowNum, colNum) ||
        (record != null && record.canAcceptDrop == false)) return false;
    
    // if we get here, it should be OK!
    return true;
},

//> @method listGrid._canDragRecordsToSelf() (AR)
// Can we drag records within this LV
// @group events, dragging
//<
_canDragRecordsToSelf : function () {
    return this.canReorderRecords;
},

//> @method listGrid.transferSelectedData()
// @include dataBoundComponent.transferSelectedData()
//<

//> @method listGrid.drop() (A)
// handle a drop event
// @return (boolean) true if the list can't reorder or dragging did not begin from the list body;
//                   false if disabled, no selection, or otherwise
// @group events, dragging
// @visibility internal
//<
drop : function () {
    // verify that the drop is valid
    if (this.willAcceptDrop() == false) return false;

    var sourceWidget = this.ns.EH.dragTarget;

    var dropIndex = this.getDropIndex();

    var dropRecords = sourceWidget.cloneDragData();

    var targetRecord = (dropIndex != -2 && this.getTotalRows()>dropIndex ? this.data.get(dropIndex) : null);
    
    // onRecordDrop() - fires before recordDrop() and gives developers an opportunity to cancel
    // the drop event
    
    var dropPosition = this.getRecordDropPosition(this.getEventRecordNum());
    if (this.onRecordDrop != null &&
        (this.onRecordDrop(dropRecords,targetRecord,dropIndex,dropPosition,sourceWidget) == false))
    {
        return false;
    }
    return this.recordDrop(dropRecords, targetRecord, dropIndex, sourceWidget);
},


//> @method listGrid.recordDrop()
// Process a drop of one or more records on a ListGrid record.
// <P>
// This method can be overridden to provide custom drop behaviors, and is a more appropriate
// override point than the lower level +link{Canvas.drop()} handler.
// <P>
// If this is a self-drop, records are simply reordered.
// <P>
// For a drop from another widget, +link{ListGrid.transferDragData()} is called, which
// depending on the +link{ListGrid.dragDataAction,dragDataAction} specified on the source
// widget, may either remove the source records from the original list
// (<code>dragDataAction:"move"</code>) or just provide a copy to this list
// (<code>dragDataAction:"copy"</code>).
// <P>
// If this grid is databound, the new records will be added to the dataset by calling
// +link{dataSource.addData()}.  Further, if the new records were dragged from another
// databound component, and +link{DataBoundComponent.addDropValues,addDropValues}
// is true, +link{DataBoundComponent.getDropValues,getDropValues} will be called for every item
// being dropped.
// <P>
// For multi-record drops, Queuing is automatically used to combine all DSRequests into a
// single HTTP Request (see QuickStart Guide, Server Framework chapter).  This allows the
// server to persist all changes caused by the drop in a single transaction (and this is
// automatically done when using the built-in server DataSources with Power Edition and
// above).
// <P>
// Note that reordering records has no effect on a databound grid.
// <P>
// The newly dropped data is then selected automatically.
// <P>
// If these default persistence behaviors are undesirable, return false to cancel them, then
// and implement your own behavior, typically by using grid.updateData() or addData() to add
// new records.
// <p><b>NOTE:</b> the records you receive in this event are the actual Records from the source
// component.  Use +link{DataSource.copyRecords()} to create a copy before modifying the records
// or using them with updateData() or addData().
// <P>
// NOTE: for a drop beyond the last visible record of a ListGrid, <code>targetRecord</code>
// will be null and the <code>index</code> will be one higher than the last record.  This
// includes a drop into an empty ListGrid, where <code>index</code> will be 0.
//
// @param dropRecords (Array[] of ListGridRecord) records being dropped
// @param targetRecord (ListGridRecord) record being dropped on.  May be null
// @param index (int) index of record being dropped on
// @param sourceWidget (Canvas) widget where dragging began
//
// @visibility external
//<
recordDrop : function (dropRecords, targetRecord, index, sourceWidget) {
    this.transferRecords(dropRecords, targetRecord, (this.canReorderRecords ? index : null),
                         sourceWidget);

    // signature "records,rowNum,viewer,sourceWidget"
    if (this.recordsDropped) this.recordsDropped(dropRecords, index, this, sourceWidget);

    // NOTE: we don't need to redraw since we're watching the data and it will change!

    // return false to cancel additional event processing
    return false;
},

//> @method ListGrid.transferDragData() (A)
// @include dataBoundComponent.transferDragData()
// @visibility external
//<

//> @method listGrid.getDragData()
// @include dataBoundComponent.getDragData()
//<

// --------------------------------------------------------------------------------------------

viewRow : function (rowNum) {
    this.getDataSource().viewFile(this.getRecord(rowNum));
},

downloadRow : function (rowNum) {
    this.getDataSource().downloadFile(this.getRecord(rowNum));
},

viewCell : function (rowNum, fieldName) {
    this.getDataSource().viewFile(this.getRecord(rowNum), fieldName);
},

downloadCell : function (rowNum, fieldName) {
    this.getDataSource().downloadFile(this.getRecord(rowNum), fieldName);
},

//> @method listGrid.autoSizeColumn()   (A)
//      @group  sizing, positioning
//
//      Can only be called after draw()
//
//      Resize this column to the size it needs to be in order to accommodate it's contents.
//<
autoSizeColumn : function (columnNum) {
    // determine the auto-size
    var body = this.body,
        frozen = this.fieldIsFrozen(columnNum),
        localFieldNum = this.getLocalFieldNum(columnNum);
    if (frozen && this.frozenBody) {
        body = this.frozenBody;
    }
    if (!body) return;

    var columnWidth = body.getColumnAutoSize(localFieldNum);
    if (this.includeGridSummaryInAutoFitWidth && this.showGridSummary && this.summaryRow != null) {

        var summaryBody = frozen ? this.summaryRow.frozenBody : this.summaryRow.body;
        if (summaryBody != null) {
            var summaryWidth = summaryBody.getColumnAutoSize(localFieldNum);
            if (summaryWidth > columnWidth) columnWidth = summaryWidth;
        }
    }

    // resize the field
    if (columnWidth != null) this.resizeField(columnNum, columnWidth);
},

//> @method listGrid.getRecord()    (A)
// Return the pointer to a particular record by record number.
// Synonym for +link{ListGrid.getCellRecord()}.
//
// @see ListGrid.getCellRecord()
// @see ListGrid.getEditedRecord()
// @param recordNum  (number) row index of record to return.
// @return (ListGridRecord) Record object for the row.
// @visibility external
//<
getRecord : function (rowNum, colNum) {
    return this.getCellRecord(rowNum, colNum);
},

// used by DBC/CellSelection to determine whether to return cellRecords (CubeGrid) or normal
// distinct records (ListGrid)
cellRecordMode: "row",

//> @method listGrid.getCellRecord()    (A)
// Return the pointer to a particular record by record number.<br>
// Notes:<br>
// - If this is a databound grid, and the record for some row has not yet been loaded,
//   returns the +link{resultSet.getLoadingMarker(),loading marker}, and a fetch will be
//   initialized to retrieve the record from the server.<br>
// - If this is a new row in an editable ListGrid, and has not yet been saved, this method will
//   return null.
// @see ListGrid.getRecord()
// @see ListGrid.getEditedRecord()
// @param recordNum  (number) row index of record to return.
// @return (ListGridRecord) Record object for the row.
// @visibility external
//<
getCellRecord : function (rowNum, colNum) {
    if (!isc.isA.Number(rowNum)) {
        this.logWarn("getCellRecord called with bad rowNum: " + this.echo(rowNum)
         //+ this.getStackTrace()
        );
        return;
    }
    // ListGrid assumes one record per row
    // Note - this.getTotalRows() may return a value higher than this.data.length. Don't
    // try to fetch records beyond the end of the dataset
    if (!this.data || 0 > rowNum || rowNum >= this.data.getLength()) return null;

    var record = this.data.get(rowNum);

    if (this._hasUnmatchedEdits) this._testRowEditData(record,rowNum);
    return record;
},


_getCachedCellRecord : function (rowNum, colNum) {
    if (!isc.isA.Number(rowNum)) {
        this.logWarn("getCellRecord called with bad rowNum: " + this.echo(rowNum));
        return;
    }
    if (!this.data || 0 > rowNum ||
        (isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown()) ||
        rowNum >= this.data.getLength())
    {
        return null;
    }
    var record = this.data.getCachedRow(rowNum);
    if (this._hasUnmatchedEdits) this._testRowEditData(record, rowNum);
    return record;
},

// Internal method to map edit data for some record to that record's rowNum.

_testRowEditData : function (record, rowNum) {
    if (record == null || record[this.editValuesTestedProperty]) return;

    if (this._editRowMap == null) this._editRowMap = {};
    var noUnmatchedEdits = true;

    for (var i in this._editSessions) {
        var vals = this._editSessions[i];
        if (vals != null && vals._rowNum == null) {
            if (this.comparePrimaryKeys(record, vals._primaryKeys)) {
                vals._rowNum = rowNum;
                this._editRowMap[rowNum] = i;
            } else {
                // We use 'noUnmatchedEdits' to determine whether we have a rowNum for every
                // record in this._editValuesArray.
                // This is used to update the '_hasUnmatchedEdits' flag allowing us to avoid this
                // method entirely when we have matched every set of edit values to a rowNum.
                // Note - if this record is the last unmatched edit, and it matches the record,
                // we  leave this flag set to true, and avoid firing this method again.
                noUnmatchedEdits = false;
            }
        }
    }

    if (noUnmatchedEdits) delete this._hasUnmatchedEdits;
    record[this.editValuesTestedProperty] = true;
},

//> @method listGrid.comparePrimaryKeys()   ([AI])
//  Compare a record and a primaryKeys object, returning true if the primary keys match the
//  record.
//  @group  data
//  @param  record  (object)    Record to compare to primary keys object
//  @param  keys    (object)    set of primary keys / values
//  @return (boolean)   True if the primary keys match the record.
//<
comparePrimaryKeys : function (record, keys) {
    var rKeys = this.getPrimaryKeys(record);

    // For local data sets we use a pointer to the record object as primary keys
    if (!this.dataSource || this.shouldSaveLocally()) return (rKeys == keys);

    for (var keyField in rKeys) {
        if (rKeys[keyField] != keys[keyField]) return false;
    }
    return true;

},

// Returns unique primary keys for a record.
// Use 'comparePrimaryKeys()' to compare against some record.

getPrimaryKeys : function (record) {

    // assume a number is a recordIndex
    if (isc.isA.Number(record)) record = this.getRecord(record);
    if (this.shouldSaveLocally()) return record;

    var ds = this.getDataSource(),
        pkArray = ds.getPrimaryKeyFieldNames(),
        keys = {};

    if (!isc.isAn.Array(pkArray)) pkArray = [pkArray];

    for (var i = 0; i < pkArray.length; i++) {
        keys[pkArray[i]] = record[pkArray[i]]
    }
    return keys;
},

//> @method listGrid.getTotalRows()
// Return the total number of rows in the grid.
// <P>
// Note that, when creating new rows via inline editing, this can be more than the total number
// of rows in the dataset (that is, grid.data.getLength())
//
// @return (int) total number of rows in the grid
// @visibility external
//<
// Override 'getTotalRows' - the total set of rows for the grid are the length of the data, and
// any unsaved edit rows beyond the last record.
getTotalRows : function () {

    if (this.data == null) return 0;
    if (this.data.getLength == null) {
        this.logWarn("GetTotalRows: ListGrid has invalid data object:"+ this.echo(this.data));
        return 0;
    }
    var totalRows = this.data.getLength(),
        lastEditRow = this._getLastEditRow();
    if (lastEditRow != null && lastEditRow+1 > totalRows) totalRows = lastEditRow+1;

    if (this.showNewRecordRow) totalRows += 1;

    return totalRows;
},

// Needed by the cell navigation logic moved down from CubeGrid to ListGrid
getTotalCols : function () { return this.fields.length; },

// Internal method to return the last (highest value) row for which we have edit values.
// Note: returns -1 if we have no edit values for any rows.
_getLastEditRow : function () {

    // Cache the last edit row for performance reasons.  We update this in the methods to
    // set / clear edit values
    if (this._lastEditRow == null) {
        var lastER = -1,
            allEditRows = (this._editRowMap ? isc.getKeys(this._editRowMap) : []);
        for (var i = 0; i < allEditRows.length; i++) {
            // Note the 'parseInt' is required, because the rowNums returned are strings rather
            // than numbers
            var currentER = parseInt(allEditRows[i]);
            if (currentER > lastER) lastER = currentER;
        }
        this._lastEditRow = lastER;
    }

    return this._lastEditRow;
},

//> @method listGrid.recordIsEnabled()  (A)
// return if record recordNum is enabled
// note: also returns false if the <code>record[this.isSeparatorProperty]</code> is true
// @param record (ListGridRecord) the record at index recordNum
// @param recordNum (number) record number to test for enabled
// @group selection, appearance
// @return (boolean) whether this record is enabled or not
//<
recordIsEnabled : function (record, row, col) {
    
    if (record == null) return true;
    if (this.recordMarkedAsRemoved(row)) return false;
    return (record[this.recordEnabledProperty] != false && record[this.isSeparatorProperty] != true);
},

cellIsEnabled : function (record, row, col) { return this.recordIsEnabled(record, row, col); },

//> @method listGrid.getCellField() (A)
//      Takes rowNum / colNum as parameters.
//      Return the pointer to the field structure for a cell
//
//      @group  display
//      @param  rowNum  (number)    Row Index of the cell
//      @param  colNum  (number)    Column index of the cell
//
//      @return (object)    Field description
//<
getCellField : function (rowNum, colNum) {
    return this.getField(colNum);
},

//> @method listGrid.getFields()
// Get the array of all <b>currently visible</b> fields for this ListGrid.
// <P>
// This list fields is only valid once the ListGrid has been +link{draw(),drawn} or once
// +link{setFields()} has been called explicitly.  If called earlier, only the list of directly
// specified fields will be returned (the Array passed to create()).
// <P>
// This Array should be treated as <b>read-only</b>.  To modify the set of visible fields, use
// +link{showField()}, +link{hideField()} and related APIs.  To update properties of individual
// fields, use +link{setFieldProperties()} or more specific APIs such as
// +link{setFieldTitle()}.
// <P>
// To get the Array of all fields, including fields that are not currently visible or were
// specified implicitly, use +link{getAllFields()}.
//
// @return (Array of ListGridField) Array of all currently visible fields
//<
getFields : function () {
    return this.fields;
},

//> @method listGrid.getAllFields()
// Get the complete array of fields for this ListGrid, including fields that are not currently
// visible or were specified implicitly via +link{listGrid.dataSource}.
// <P>
// This list of fields is only valid once the ListGrid has been +link{canvas.draw(),drawn} or once
// +link{setFields()} has been called explicitly.  If called earlier, only the list of directly
// specified fields will be returned (the Array passed to create()).
// <P>
// This Array should be treated as <b>read-only</b>.  To modify the set of visible fields, use
// +link{showField()}, +link{hideField()} and related APIs.  To update properties of individual
// fields, use +link{setFieldProperties()} or more specific APIs such as
// +link{setFieldTitle()}.
//
// @return (Array of ListGridField) Array of all fields in the ListGrid
// @visibility external
//<
getAllFields : function () {
    return this.completeFields || this.fields;
},

//> @method listGrid.getSpecifiedField() (A)
// Looks up a field object by name or position.
// <p>
// Returns the field from this.completeFields (if available) rather than this.fields,
// allowing you to get a pointer to any field in the completeFields array
//
// @group display
// @param fieldID (string || number || ListGridField)
//                field number or field.name. If passed a field, it will be returned.
// @return (object) Field description
//<

getSpecifiedField : function (fieldID) {
    var fields = this.completeFields;
    if (fields == null) fields = this.fields;
    if (fields == null) return;
    
    var field = null;

    if (isc.isAn.Object(fieldID)) {
        if (fields.contains(fieldID)) field = fieldID;
        // Catch the case where we're passed a field that's not present in our
        // fields/completeFields array.

        
        if (isc.isA.RecordEditor(this) && this.isAFilterEditor()) {
            field = this.getSpecifiedField(fieldID[this.fieldIdProperty]);        
        }

    } else if (isc.isA.String(fieldID)) field = fields.find(this.fieldIdProperty, fieldID);
    else field = fields[fieldID];
    
    if (field) this._setFieldGridID(field);
    return field;
},

_setFieldGridID : function (field) {
    if (field && !field._componentID) field._componentID = this.ID;
},

//> @method listGrid.getFieldName() (A)
// Given a column number or field id, return the field name of a field.
//      @group  display
//      @param  colNum      (number or id)  number or id of the field.
//      @return (string)    Name of the field.
//      @visibility external
//<
getFieldName : function (fieldNum) {
    var field = this.getField(fieldNum);
    return field ? field[this.fieldIdProperty] : null;
},

//> @method listGrid.getFieldByName()
// Given a field name, return the appropriate field definition.  Unlike 
// +link{listGrid.getField, getField()}, this method will return the field definition even if
// it's not visible in the grid.
//
// @param fieldName (String) name of the field to retrieve
// @return (ListGridField) field definition
// @visibility external
//<
getFieldByName : function (fieldName) {
    return this.getSpecifiedField(fieldName);
},

//> @method listGrid.getField()
// Given a column number or field name, return the field definition of a field which is visible
// in the grid.  To retrieve the definition of <i>any</i> field, including hidden ones, use
// +link{listGrid.getFieldByName, getFieldByName()}.
// <P>
// When using +link{attr:DataBoundComponent.fields,DataBinding}, the field definition may be
// a mix of information derived from +link{listGrid.fields} and +link{listGrid.dataSource}.
//
// @param colNum (int | ID) number or id of the field.
// @return (ListGridField) field definition
// @visibility external
//<

getField : function (id) {
    if (this.fields == null || id == null) return null;

    var field;

    if (this._noNumericFields) {
        field = this.fields[id];
        if (field != null) return field;
    } else {
        // Number: assume index.
        if (isc.isA.Number(id)) return this.fields[id];
    }

    // Object: return unchanged
    if (id._isFieldObject || isc.isAn.Object(id)) return id;

    // String: fieldName / dataPath
    if (isc.isA.String(id)) {
        var isDataPath = id.contains(isc.Canvas._$slash);
        if (!isDataPath) {
            return this.fields.find(this.fieldIdProperty, id);
        } else {
            // The dataPath declared on the field may be full or partial, absolute or
            // relative, and may have a (meaningless) trailing slash as well.  We'll have to
            // look for it in all the various forms it might take.  We'll keep this comparison
            // as sparse as possible - the following compare fields will be undefined unless
            // they are different from the base id (eg, if the base id starts with a slash,
            // "absolute" will remain undefined, because it would otherwise be identical to id)
            var absolute,
                noLeadingSlash,
                noTrailingSlash,
                slashesTrimmed = id.trim(isc.Canvas._$slash),
                complete,
                thisLevelOnly,
                thisLevelPlusTrailing,
                undef;

            if (id.startsWith(isc.Canvas._$slash)) {
                noLeadingSlash = id.substring(1);
                if (id.endsWith(isc.Canvas._$slash)) {
                    noTrailingSlash = id.substring(0, id.length);
                } else {
                    absolute = id + "/";
                }
            } else {
                if (id.endsWith(isc.Canvas._$slash)) {
                    noTrailingSlash = id.substring(0, id.length);
                    absolute = "/" + id;
                } else {
                    absolute = "/" + id + "/";
                }
                complete = "/" + id;
            }
            var lastSlash = slashesTrimmed.lastIndexOf(isc.Canvas._$slash);
            if (lastSlash != -1) {
                thisLevelOnly = slashesTrimmed.substring(lastSlash + 1);
                thisLevelPlusTrailing = thisLevelOnly + "/";
            }

            for (var i = 0; i < this.fields.length; i++) {
                var dataPath = this.fields[i].dataPath;
                if (!dataPath) continue;
                if (dataPath == id ||
                    (noLeadingSlash && dataPath == noLeadingSlash) ||
                    (noTrailingSlash && dataPath == noTrailingSlash) ||
                    (slashesTrimmed && dataPath == slashesTrimmed) ||
                    (complete && dataPath == complete) ||
                    (absolute && dataPath == absolute) ||
                    (thisLevelOnly && dataPath == thisLevelOnly) ||
                    (thisLevelPlusTrailing && dataPath == thisLevelPlusTrailing)
                   )
                {
                    return this.fields[i];
                }
            }
        }
    }

    // otherwise invalid
    return null;
},

//> @method listGrid.getFieldNum()  (A)
//      Given a field or field id, return it's index in the fields array
//      @group  display
//      @param  fieldID     (String | number)   field number or field.name
//      @return (int)   index of the field within this.fields
//      @visibility external
//<
// NOTE: implemented on Canvas

// make 'getColNum' a synonym of getFieldNum() since it's common to refer to 'colNum's
getColNum : function (fieldId) {
    return this.getFieldNum(fieldId);
},


//> @method listGrid.getFieldTitle() (A)
// Return the title of a field, specified by name or index.
// @param fieldId (String | Number) name or index of the field
// @return (String) Field title.
// @visibility external
//<
getFieldTitle : function (fieldId) {
    // get the field from the grid or the DS
	var field = this.getUnderlyingField(fieldId);

    // bail if no field
	if (!field) return "Unknown field";

	// if the field specifies a "getFieldTitle" method, call that
	if (field.getFieldTitle) {
		// CALLBACK API:  available variables:  "viewer,fieldNum"
		// Convert a string callback to a function
		isc.Func.replaceWithMethod(field, "getFieldTitle", "viewer,fieldNum");

		return field.getFieldTitle(this, this.getFieldNum(field));
	}

	// otherwise just return the title or the fieldName
	return field.title || field.name;
},

//> @method listGrid.getSummaryTitle()  (A)
// Return the summary title of particular field.  This is the title of
// the field to be used in the show / hide fields context menu. Default implementation will
// use  +link{listGridField.getSummaryTitle()} or +link{ListGridField.summaryTitle} if specified,
// otherwise +link{listGridField.title}.
// @group i18nMessages
// @group display
// @param field (listGridField) field for which we're returning the title
// @return  (string)    Field summary title.
// @visibility external
//<
getSummaryTitle : function (field) {
    var title;
    // If the custom 'summary title' has been specified on the field, use that.
    if (field.getSummaryTitle != null) {
        // CALLBACK API:  available variables:  "viewer,field"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "getSummaryTitle", "viewer,field");
        title = field.getSummaryTitle(this, field);
    } else if (field.summaryTitle != null) {
        title = field.summaryTitle;
    } else {
        title = this.getFieldTitle(field);
    }

    return title;
},


//> @method listGrid.setValueMap()
// Set the +link{listGridField.valueMap, valueMap} for a field.
// See also the +link{ListGrid.setEditorValueMap(), setEditorValueMap()}
// and +link{ListGrid.getEditorValueMap(), getEditorValueMap()} methods which allow further
// customization of the valueMap displayed while the field is in edit mode.
// @param fieldID (String | int) Name or index of field to update
// @param map (object) ValueMap for the passed field
// @visibility external
//<
setValueMap : function (fieldID, map) {
    this.setFieldValueMap(fieldID, map);

    if (this._editorShowing) {
        var fieldName, field;
        var fieldNum = this.getColNum(fieldID);
        // don't crash on hidden fields / bad fieldNames that don't exist
        if (fieldNum != -1 && fieldNum < this.fields.length) {
            var field = this.getField(fieldID),
                fieldName = field[this.fieldIdProperty];
            this._editRowForm.setValueMap(
                fieldName,
                this.getEditorValueMap(field, this.getEditedRecord(this.getEditRow(), fieldNum))
            );
        }
    }
    // If we're showing a summaryRow grid, copy the valueMap across to that so if we do
    // something like show a max, or a mean that has a display value it'll update correctly
    if (this.summaryRow) {
        this.summaryRow.setValueMap(fieldID, map);
    }

    if (this.isDrawn() && this.isVisible()) {
        this._markBodyForRedraw("setValueMap");
    }
},

//> @method listGrid.getDisplayValue()
// Given a field with a specified +link{listGridField.valueMap} or +link{listGridField.displayField}
// this method will return the display value for any underlying data value.
// @param fieldID (string || number || ListGridField) Field or field identifier with valueMap
// @param valueFieldValue (any) Data value for this field
// @return (string) Display value associated with the specified valueFieldValue
// @visibility external
//<
getDisplayValue : function (fieldID, valueFieldValue, record) {
    var field = this.getField(fieldID),
        valueMap = field ? field.valueMap : null;
    return this._getDisplayValue(
        field, valueMap, field && field.displayField, valueFieldValue, record);
},
_getDisplayValue : function (field, valueMap, displayField, valueFieldValue, record) {
    // If `getDisplayValue()` is overridden by the user then we have to call it.
    if (this.getDisplayValue != isc.ListGrid.getInstanceProperty("getDisplayValue")) {
        return this.getDisplayValue(field, valueFieldValue, record);
    }

    if (field) {
        if (isc.isAn.Object(valueMap) && !isc.isAn.Array(valueMap) &&
            isc.propertyDefined(valueMap, valueFieldValue))
        {
            return valueMap[valueFieldValue];
        } else if (record && displayField) {
            valueFieldValue = record[displayField];
        }
    }

    return valueFieldValue;
},

//> @method listGrid.getData()
//      Get the data that is being displayed and observed
//      @return (object)    The data that is being displayed and observed
//<
getData : function () {
    return this.data;
},

//> @method listGrid.getRecordIndex()
// Get the index of the provided record.
// <P>
// This is essentially the same as calling listGrid.data.indexOf(record), except that
// the currently visible range of records is checked first.  This is important for
// responsiveness in functions that respond to user actions when the user is working near the
// end of a very large dataset (eg 500k records).
//
// @param record (ListGridRecord) the record whose index is to be retrieved
// @return (int) index of the record, or -1 if not found
// @visibility external
//<
getRecordIndex : function (record) {
    var index = -1;

    if (this.body && this.body.isDrawn()) {
        index = this.data.indexOf(record, this.body._firstDrawnRow, this.body._lastDrawnRow);
    }
    if (index == -1) index = this.data.indexOf(record);
    return index;
},

//> @method listGrid.getRowNum()
// Synonym of +link{getRecordIndex(),getRecordIndex()}.
//
// @include method:getRecordIndex()
//<
getRowNum : function (record) {
    return this.getRecordIndex.apply(this, arguments);
},

//> @method listGrid.getRecordCellIndex()
// Get the row and column index of the provided record.
// <P>
// This function is set up with a colNum argument so it can be called on a ListGrid
// and return a meaningful cell object.  When 'selectOnEdit' is ultimately supported
// in CubeGrid, the overridden version of this function there won't use that argument,
// since the record will completely determine the cell to return.
//
// @param record (ListGridRecord) the record whose index is to be retrieved
// @param colNum (number) the cell column position (since record represents entire row)
// @return cell (Array) 2 element array containing the rowNum and colNum of the record
//                      (or -1 in both slots if not found)
//
// @visibility internal
//<
getRecordCellIndex : function (record, colNum) {
    var rowNum = this.getRecordIndex(record);
    return rowNum >= 0 ? [rowNum, colNum] : [-1, -1];
},


//> @method listGrid.getEventRow()
// @include gridRenderer.getEventRow()
// @group events
// @visibility external
//<
getEventRow : function (y) {

    // If we're over the header, bail
    // XXX this works, but is a little kludgey - ideally we'd not call getEventRow() unless
    // we were over the body.
    if (this.header && this.header.containsPoint(this.ns.EH.getX(), this.ns.EH.getY())) {
        return -1;
    }
    return this.body.getEventRow(y);
},

//> @method listGrid.getEventColumn()
// @include gridRenderer.getEventColumn()
// @group events
// @visibility external
//<
getEventColumn : function (x) {
    var tempX = (x != null ? x : this.getOffsetX()),
        colNum = 0,
        frozenColumns = 0
    ;
    if (this.frozenBody) frozenColumns = this.frozenFields.length;

    if (frozenColumns > 0 && tempX < this.frozenBody.getVisibleWidth()) {
        colNum = this.frozenBody.getEventColumn(x);
    } else {
        colNum = this.body.getEventColumn(x) + frozenColumns;
    }

    return colNum;
},

// local synonyms reflect ListGrid's row<->record, column<->field convention
getEventRecordNum : function (y) {
    return this.getEventRow(y);
},
getEventFieldNum : function (x) {
    return this.getEventColumn(x);
},

// inner drop position logic is reused in a few different places
_getRecordDropPosition : function (recordNum, y, dropAppearance) {
    if (!dropAppearance) dropAppearance = this.recordDropAppearance;

    var localY = y - this.body.getRowTop(recordNum),
        recordHeight = this.body.getRowSize(recordNum);

    if (dropAppearance == isc.ListGrid.BETWEEN) {
        // Top half, drop above, bottom half drop below
        if (localY > Math.round(recordHeight / 2)) {
            return isc.ListGrid.AFTER;
        } else {
            return isc.ListGrid.BEFORE;
        }
    } else if (dropAppearance == isc.ListGrid.BOTH) {
        if (localY < Math.round(recordHeight / 4)) {
            return isc.ListGrid.BEFORE; // top 1/4, drop above, 
        } else if (localY > Math.round(3 * recordHeight / 4)) {
            return isc.ListGrid.AFTER;  // bottom 1/4, drop below
        } else {
            return isc.ListGrid.OVER;   // middle - drop into folder    
        }
    }
},

//> @method listGrid.getRecordDropPosition()
// Returns the +link{RecordDropPosition} for some record drop operation.
// This value is passed to the +link{recordDrop()} event notification method.
// <P>
// Default implementation determines the position to return based on
// the specified +link{listGrid.recordDropAppearance} for the grid and the
// +link{EventHandler.getY(),y-coordinate of the drop event}.
//
// @return (RecordDropPosition) record drop position.
//
// @visibility external
//<
getRecordDropPosition : function (recordNum, y, dropAppearance) {
    if (this.recordDropAppearance == isc.ListGrid.OVER) return isc.ListGrid.OVER;
    if (this.recordDropAppearance == isc.ListGrid.BODY) return null;

    // If a y-coordinate was not passed, get it from the offset of the last event
    if (y == null) y = this.body.getOffsetY();

    // which row is the mouse over?
    if (recordNum == null) recordNum = this.getEventRow(y);

    // -2 implies we're past the end of the list
    if (recordNum == -2) return isc.ListGrid.AFTER;

    // a number greater than the number of records in the list implies we're past the end
    // of the list, so we want to return before since it's meaningless to position after a
    // non existent row -- we'll actually just be dropping at the end of the list.
    if (recordNum >= this.getTotalRows()) return isc.ListGrid.BEFORE;

    return this._getRecordDropPosition(recordNum, y, dropAppearance);
},

//> @method listGrid.getDropIndex()
// Return the drop-index for a given row and reorderPosition.
// <P>
// When there are no rows in the grid, getDropIndex() returns zero.
// <P>
// If parameter <i>recordNum</i> is not passed, the current event row is used, see
// +link{listGrid.getEventRow()}.
// <P>
// Parameter +link{ReorderPosition,reorderPosition} indicates where the drop-item should appear
// in relation to the row at index <i>recordNum</i>.  If no reorderPosition is provided, it is
// calculated based on the physical position of the mouse in the drop-target row when the drop
// occurs; if the mouse is in the top half of a row, the drop-index is before
// <i>recordNum</i>.  Otherwise, the drop-index is after <i>recordNum</i>.
//
// @param [recordNum]        (number)    Index of the record to drop onto
// @param [reorderPosition]  (ReorderPosition) Where to drop in relation to <i>recordNum</i>
// @return (number) The calculated drop-index
// @visibility external
//<
getDropIndex : function (recordNum, reorderPosition) {
    if (this.data.getLength() == 0) {
        // if there's no data, we have to drop in position 0
        return 0;
    }

    if (recordNum == null) recordNum = this.getEventRow();
    if (reorderPosition == null) reorderPosition = this.getRecordDropPosition(recordNum);

    if (this.canReorderRecords) {
        // if drop-record is -2, set to last record to slide after last record
        if (recordNum == -2) recordNum = this.data.getLength() - 1;

        if (reorderPosition == isc.ListGrid.AFTER) recordNum++;
    }

    return recordNum;
},

// cellSelectionChanged is passed through from the GR - include documentation for it.
//> @method listGrid.cellSelectionChanged() ([A])
// @include gridRenderer.cellSelectionChanged()
// @example cellSelection
//<
cellSelectionChanged : function () {
},

// selectionChanged is passed through from the GR - include documentation for it.
//> @method listGrid.selectionChanged()
// Called when (row-based) selection changes within this grid. Note this method fires for
// each record for which selection is modified - so when a user clicks inside a grid this
// method will typically fire twice (once for the old record being deselected, and once for
// the new record being selected).
// <P>
// NOTE: For updating other components based on selections or triggering selection-oriented
// events within an application, see the
// +link{dataBoundComponent.selectionUpdated(),selectionUpdated()} event
// which is likely more suitable.  Calls to +link{listGrid.getSelection(),getSelection()}
// from within this event may not return a valid set of selected records if the event has
// been triggered by a call to +link{dataBoundComponent.selectAllRecords(),selectAllRecords()}
// or +link{dataBoundComponent.deselectAllRecords(),deselectAllRecords()} - in this case
// use the +link{dataBoundComponent.selectionUpdated(),selectionUpdated()} event instead.
//
// @param   record  (ListGridRecord)    record for which selection changed
// @param   state   (boolean)   New selection state (true for selected, false for unselected)
// @group selection
// @visibility external
// @example multipleSelect
//<


selectionChanged : function () {
},

// selectionUpdated is defined in DBC - include documentation for it
//> @method listGrid.selectionUpdated()
// @include dataBoundComponent.selectionUpdated()
// @visibility external
//<

getSerializeableFields : function (removeFields, keepFields) {
    removeFields = removeFields || [];
    removeFields.addList(["header", "selection"]);

    return this.Super("getSerializeableFields", [removeFields, keepFields], arguments);
},

// Frozen Fields / Frozen Columns
// ---------------------------------------------------------------------------------------

// detect frozen fields and reorder the fields array to place frozen fields first, also
// establishing this.frozenFields vs this.normalFields.
// Called by deriveVisibleFields(), which in turn is called by setFields and in other
// circumstances where the set of visible fields has changed or been reordered.
// this.fields is assumed to contain only visible fields.
deriveFrozenFields : function () {

    // detect frozen fields
    var frozenFields = this.frozenFields = this.fields.findAll("frozen", true),
        autoFreezeFields = this.fields.findAll("autoFreeze", true),
        autoFrozenFields = this.fields.findAll("__autoFrozen", true)
    ;

    // if all frozen fields were __autoFrozen, unfreeze them all now
    if (frozenFields && autoFrozenFields && frozenFields.length == autoFrozenFields.length) {
        for (var i=0; i<autoFrozenFields.length; i++) {
            var field = autoFrozenFields[i];
            field.frozen = false;
            delete field.__autoFrozen;
        }
        frozenFields = this.frozenFields = null;
    }

    var allFrozenFields = this.completeFields.findAll("frozen", true);

    // Exception - disallow having all frozen fields and no 'unfrozen' fields
    // Our code doesn't currently handle this and it's not clear what the expected behavior would
    // be!
    if (frozenFields && frozenFields.length == this.fields.length) {
        frozenFields = this.frozenFields = null;
        // setting this flag lets us know that if we show additional, unfrozen fields
        // we'll have to do a rebuild to properly "freeze" the frozen fields!
        
        this._suppressedFrozenFields = true;
    } else this._suppressedFrozenFields = false;

    if (frozenFields) {
        // freeze any unfrozen autoFreeze: true fields, since other fields are frozen
        if (autoFreezeFields) {
            for (var i=0; i<autoFreezeFields.length; i++) {
                var field = autoFreezeFields[i];
                if (!field.frozen) {
                    field.frozen = true;
                    field.__autoFrozen = true;
                    var pos = field.getAutoFreezePosition ? field.getAutoFreezePosition() :
                            this.freezeStart() ? 0 : this.fields.length,
                        allPos = field.getAutoFreezePosition ? field.getAutoFreezePosition() :
                            this.freezeStart() ? 0 : this.completeFields.length
                    ;
                    frozenFields.addAt(field, pos);
                    allFrozenFields.addAt(field, allPos);
                }
            }
        }

        // reorder the main fields array to put frozen fields on left or right
        this.fields.slideList(frozenFields, this.freezeStart() ? 0 : this.fields.length);
        this.completeFields.slideList(allFrozenFields, this.freezeStart() ? 0 : this.completeFields.length);

        // does not currently work
        this.resizeFieldsInRealTime = false;
    }

    for (var i = 0; i < this.fields.length; i++) {
        var field = this.fields[i];
        // mark all fields with a masterIndex - their index in the master fields Array
        // (listGrid.fields)
        field.masterIndex = i;
    }

    if (frozenFields) {
        // put together the normal fields for the primary body (excludes frozen fields)
        var normalFields = this.normalFields = [];
        for (var i = 0; i < this.fields.length; i++) {
            var field = this.fields[i];
            if (!field.frozen) normalFields.add(field);
        }
    } else this.normalFields = null;

    
},

// rebuild for possible change in frozen fields.  Can be called as an alternative to
// a full setFields() when only the frozenness of fields has changed.  Unlike setFields(), this
// ends inline editing.

_$toggleFrozen:"toggle frozen fields",
rebuildForFreeze : function (forceRebuild) {

    if (!this.body) return; // children have not been created

    // If we're showing a filterEditor, essentially rebuild it for freeze, but without
    // killing the current edit.
    
    if (this.filterEditor) {
        // Note: this also handles shifting the checkboxField (if we're showing one) into the
        // frozen fields block via deriveFrozenFields()
        

        this.filterEditor.deriveVisibleFields();
        this.filterEditor.updateBody(forceRebuild);
        this.filterEditor.remapEditFieldsForFreeze();
        this.filterEditor.layoutChildren(this._$toggleFrozen);
    }
    this.endEditing();

    this.deriveVisibleFields();
    // NOTE: will destroy old header and re-create.  Always happens for any change in fields
    this.updateHeader();

    // will recreate bodies if necessary, otherwise just refresh fields
    this.updateBody(forceRebuild);
    this.layoutChildren(this._$toggleFrozen);

    // If we have a frozen body, the 'getDrawRows()' method delegates to the unfrozen body.
    // Since they're both rendered in a layout we can end up with the frozen body being sized
    // and drawn first, meaning the unfrozen body's getDrawRows() is initially unreliable.
    // Handle this by always doing a single immediate redraw of the frozen body after
    // layoutChildren sizes and renders everything.
    if (this.frozenBody) {
        this.frozenBody.markForRedraw("Recalculating draw area from initial sizing of body");
    }
    // If we're showing a gridSummary row, freeze it as well
    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow.setFields(this.completeFields.duplicate());
        this.summaryRow.rebuildForFreeze(forceRebuild);
        this.summaryRow._recalculateSummaries();
    }

    if (this.showRecordComponents && this.recordComponentPoolingMode == "data") {
        // bodies may have been destroyed, which would orphan recordComponents in "data"
        // pooling mode - if there are any orphaned components, loop over them and re-add any
        // that still have records in the loaded data, removing them from the "orphaned" array
        if (this._orphanedRecordComponents) {
            var comps = isc.getValues(this._orphanedRecordComponents),
                len = comps.length
            ;
            for (var i=len-1; i>=0; i--) {
                var comp = comps[i];
                if (!this.data.contains(comp.embeddedRecord)) continue;
                
                this.addEmbeddedComponent(comp, comp.embeddedRecord);
                delete this._orphanedRecordComponents[comp.ID];
            }
        }
    }
},

//> @method ListGrid.setCanFreezeFields()
// Setter method for +link{ListGrid.canFreezeFields}
// @param canFreeze (boolean) New value for <code>listGrid.canFreezeFields</code>
// @visibility external
//<
setCanFreezeFields : function (canFreeze) {
    this.canFreezeFields = canFreeze;
    delete this._autoDerivedCanFreeze;
},

// refresh the "masterIndex" property on subcomponents that have been created with a copy of
// the fields array
refreshMasterIndex : function () {
    // this.fields may be set before this.body has been built.
    // Ensure the masterIndex property is correct there.
    
    if (this.fields) this._refreshMasterIndexForFields(this.fields);
    if (!this.body) return;

    if (this.header) this._refreshMasterIndexForFields(this.header.getMembers());
    if (this.body) this._refreshMasterIndexForFields(this.body.fields || []);
    if (!this.frozenFields) return;
    if (this.frozenHeader) this._refreshMasterIndexForFields(this.frozenHeader.getMembers());
    if (this.frozenBody) this._refreshMasterIndexForFields(this.frozenBody.fields);

},
_refreshMasterIndexForFields : function (fields) {
    for (var i = 0; i < fields.length; i++) {
        fields[i].masterIndex = this.fields.findIndex("name", fields[i].name);
    }
},

getFreezeOn : function () {
    return (this.freezeOn != null ? this.freezeOn : (this.isRTL() ? "right" : "left"));
},

// Whether frozen columns are on the left or right
freezeLeft : function () {
    return this.getFreezeOn() == "left";
},

// whether frozen columns are at the start or end (before or after the unfrozen body)
freezeStart : function () {
    if (this.isRTL()) {
        return this.getFreezeOn() == "right";
    } else {
        return this.getFreezeOn() == "left";
    }
},

getLeftBody : function () {
    var freezeLeft = this.freezeLeft()
    return this.frozenFields && freezeLeft ? this.frozenBody : this.body;
},

getRightBody : function () {
    var freezeLeft = this.freezeLeft();
    return this.frozenFields && !freezeLeft ? this.frozenBody : this.body;
},

setFreezeOn : function (side) {
    var oldSide = this.get
    this.freezeOn = side;
    if (side != oldSide) this.rebuildForFreeze(true);
},

// given an Array, return a subArray of just the slots corresponding to the frozen fields
// (getFrozenSlots) or unfrozen fields (getUnfrozenSlots).  Can be used on an Array of fields,
// or an Array containing any other value that corresponds 1 to 1 with the fields, such as
// field sizes
getFrozenSlots : function (array) {
    var frozenFields = this.frozenFields;
    if (!frozenFields) return array;
    return this.freezeStart() ? array.slice(0, frozenFields.length) :
                               array.slice(array.length - frozenFields.length);
},
getUnfrozenSlots : function (array) {
    var frozenFields = this.frozenFields;
    if (!frozenFields) return array;
    return this.freezeStart() ? array.slice(frozenFields.length) :
                               array.slice(0, array.length - frozenFields.length);
},

fieldIsFrozen : function (colNum) {
    // This can happen even if field.frozen is true - see _suppressedFrozenFields
    if (!this.frozenFields) return false;

    var field = this.getField(colNum);
    return field && !!field.frozen;
},

// frozen fields column numbering:
// - frozen fields do appear in this.fields, always first or last depending on which side the
//   frozen body appears on
// - both header buttons and the fields passed to the body/frozenBody have a masterIndex
//   property indicating their index in this.fields
// - events coming from either body will have a colNum that matches the index in this.fields.
//   This is done via remapping the colNum in makeBodyMethods
// - if you have a colNum with respect to this.fields:
//   - getFieldBody()/getFieldHeader() will give you the body (GR instance) or header (Toolbar
//     instance) where that column appears
//   - getLocalFieldNum() will give you the field/column number within that component

// return the "body" where a column is rendered
getFieldBody : function (colNum) {
    if (!this.frozenFields) return this.body;
    return this.fieldIsFrozen(colNum) ? this.frozenBody : this.body;
},

// return the "header" where a column is rendered
getFieldHeader : function (colNum) {
    if (!this.frozenFields) return this.header;
    return this.fieldIsFrozen(colNum) ? this.frozenHeader : this.header;
},

getFieldHeaderButton : function (fieldNum) {
     // getFieldHeader / getLocalFieldNum will account for frozen fields
    var header = this.getFieldHeader(fieldNum);
    return header ? header.getMember(this.getLocalFieldNum(fieldNum)) : null;
},

// given a colNum, return the index for that column in the body or header where it appears
// (Takes a numeric colNum - not a string or field object)
getLocalFieldNum : function (colNum) {
    // For a null colNum just return null.
    
    if (colNum == null) return null;

    // when printing the body fields array gets out of sync with that of the listGrid
    // s we directly pull out any shouldPrint:false fields until printing is complete.
    // We need to handle this otherwise we'd end up returning the wrong colNum - this can lead to
    // JS errors with our complex logic to fire passthrough / passback methods as we end up
    // unable to find fields.
    if (this.body && this.body.isPrinting) {
        var field = this.fields[colNum];
        if (!this._suppressedFrozenFields && field.frozen && this.frozenBody) {
            return this.frozenBody.fields.indexOf(field);
        } else {
            return this.body.fields.indexOf(field);
        }
    }
    if (!this.frozenFields) return colNum;

    var offset;
    
    offset = this.frozenFields.length;

    // if column is in main body, subtract number of frozen fields if fields are frozen on left
    if (!this.fieldIsFrozen(colNum)) return colNum - offset;

    // otherwise, column is in frozen body.
    return this.freezeStart() ? colNum
                             : colNum - (this.fields.length - this.frozenFields.length);
},

// given a colNum within the body / frozen body, return the 'fieldNum' in our fields array
getFieldNumFromLocal : function (localColNum, body) {
    if (localColNum == null) return null;

    // if we're printing, shouldPrint:false fields will have been pulled out of the body
    // so we need to adjust for that.
    if (this.isPrinting) {
        var bodyFields = this.frozenFields != null ?
                            (body == this.frozenBody ? this.frozenFields : this.unfrozenFields) :
                            this.fields;
        var localField = body.fields[localColNum];
        for (var i = 0; i < bodyFields.length; i++) {
            if (bodyFields[i].name == localField.name) break;
            if (bodyFields[i].shouldPrint == false) localColNum++;
        }

    }

    if (!this.frozenFields) return localColNum;

    if (body == this.frozenBody) {
        if (this.freezeStart()) return localColNum;
        else {
            var unfrozen = this.fields.length - this.frozenFields.length;
            return localColNum + unfrozen;
        }
    } else {
        var offset = this.freezeStart() ? this.frozenFields.length : 0;
        return localColNum + offset;
    }
},

// map various methods through to the appropriate body.
// if this set continues to grow, we may want to take a code generation approach instead

//> @method ListGrid.getColumnLeft() ([A])
// Return the left offset (in local coordinate space) of a particular column.
// @param colNum (Integer) number of the column
// @return (Integer) left offset of the passed colNum, or null if not yet drawn or no such column
// @group sizing, positioning
// @visibility external
//<
getColumnLeft : function (colNum) {
    var body = this.getFieldBody(colNum);
    if (!body) return null;
    return body.getColumnLeft(this.getLocalFieldNum(colNum));
},

//> @method ListGrid.getColumnPageLeft() ([A])
// Return the left coordinate for a given column number as a GLOBAL coordinate
// @param colNum (Integer) number of the column
// @return (Integer) page left offset of the passed colNum, or null if undrawn or no such column
// @group sizing, positioning
// @visibility external
//<
getColumnPageLeft : function (colNum) {
    var body = this.getFieldBody(colNum);
    if (!body) return null;
    return body.getColumnPageLeft(this.getLocalFieldNum(colNum));
},

//> @method ListGrid.getColumnWidth() ([A])
// Return the width of a particular column.
// @param colNum (number) number of the column
// @return (Integer) width of the column, or <code>null</code> if undrawn or no such column.
// @group sizing, positioning
// @visibility external
//<
getColumnWidth : function (colNum) {
    var body = this.getFieldBody(colNum);
    if (!body) return null;
    return body.getColumnWidth(this.getLocalFieldNum(colNum));
},

//> @method ListGrid.getCellPageRect() ([A])
// Returns the page offsets and size of the cell at the passed row and column.  If auto-sizing
// is enabled, sizes are not definitive until the grid has finished drawing, so calling this
// method before drawing completes will return the configured column sizes.
// @param rowNum (number) row index of the cell
// @param colNum (number) column index of the cell
// @return (Array of Integer) the page rect of the passed cell, or null if undrawn
// @group sizing, positioning
// @visibility external
//<
getCellPageRect : function (rowNum, colNum) {
    var body = this.getFieldBody(colNum);
    if (!body) return null;
    return body.getCellPageRect(rowNum, this.getLocalFieldNum(colNum));
},

refreshCellStyle : function (rowNum, colNum, className) {
    var body = this.getFieldBody(colNum);
    return body.refreshCellStyle(rowNum, this.getLocalFieldNum(colNum), className);
},

//> @method listGrid.freezeField()
// Freeze the indicated field, so that it remains in place and visible when horizontal
// scrolling occurs.
//
// @param field (ListGridField or Integer or String or Array) field or fields to freeze.
//  fields may be specified as ListGridField objects, field names or colNum.
// @group frozenFields
// @visibility external
//<
freezeField : function (field) {
    return this.toggleFrozen(field, true);
},

//> @method listGrid.unfreezeField()
// Unfreeze a frozen field, so that it will now scroll along with other fields when horizontal
// scrolling occurs.
//
// @param field (ListGridField or Integer or String or Array) field or fields to unfreeze.
//  fields may be specified as ListGridField objects, field names or colNum.
// @group frozenFields
// @visibility external
//<
unfreezeField : function (field) {
    return this.toggleFrozen(field, false);
},

//> @method listGrid.toggleFrozen()
// Freeze or unfreeze the indicated field according to whether it is currently frozen.
// <P>
// Called when the ListGrid freezes or unfreezes fields by user action.
//
// @param field (ListGridField or Integer or String or Array) field or fields to freeze.
//  fields may be specified as ListGridField objects, field names or colNum.
// @group frozenFields
// @visibility external
//<
// isFrozen parameter undocumented - developer would typically call freezeField or unfreezeField
// directly
toggleFrozen : function (field, isFrozen) {
    if (!isc.isAn.Array(field)) field = [field];
    var changed = false;
    for (var i = 0; i < field.length; i++) {
        var currentField = this.getField(field[i]);
        if (!currentField || !this.fieldIsVisible(currentField) ||
            this.isCheckboxField(currentField))
        {
            continue;
        }
        var shouldFreeze = isFrozen;
        if (shouldFreeze == null) shouldFreeze = !currentField.frozen;
        if (currentField.frozen == isFrozen) continue; // field frozenness did not change

        changed = true;
        currentField.frozen = shouldFreeze;
    }

    if (!changed) return false;

    this.rebuildForFreeze();
    // Note: rebuildForFreeze will ultimately call updateBody() which
    // remaps any embedded components to the appropriate colNum based on field name.

    // re-select the sort-button as necessary
    this.selectSortFieldHeaderButton();

    this.handleFieldStateChanged(true);

    return true; // field frozenness changed
},

// Body
// --------------------------------------------------------------------------------------------

// update the body for a change in fields
updateBody : function (forceRebuild) {
    // if frozen fields are being introduced or going away entirely, recreate the body[s] and
    // bodyLayout.  Otherwise, just refresh the fields array being used by each body.

    if (forceRebuild ||
        (this.frozenFields && !this.frozenBody) ||
        (this.frozenBody && !this.frozenFields))
    {
        forceRebuild = true;
        // We're going to destroy the current body or bodies. Drop all recordComponents first
        // so we don't get confused by pointers to destroyed recordComponents.
        this.dropRecordComponents();

        

        if (this.body) {
            // Un-embed and Destroy all embedded components.
            
            this._destroyEmbeddedComponentsForRebuild();
        }

        // frozen body being introduced or going away, or freeze side changing
        if (this.bodyLayout) this.bodyLayout.destroy();
        else if (this.body)  this.body.destroy();
        this.body = this.bodyLayout = this.frozenBody = null;
        this.createBodies();
    }

    // If we've already run through "createChildren" we need to explicitly add the
    // body as a member now.
    // Calling code will handle calling "layoutChildren" which'll ensure the fieldWidths are
    // correct, etc.
    if (this.isDrawn()) {
        this.updateGridComponents();
    }

    if (this.body) {
        this.body.fields = this.normalFields || this.fields;
        if (!forceRebuild) this._remapEmbeddedComponentColumns(this.body);
        this.body.markForRedraw("fields change");
    }
    if (this.frozenBody) {
        this.frozenBody.fields = this.frozenFields;
        if (!forceRebuild) this._remapEmbeddedComponentColumns(this.frozenBody);
        this.frozenBody.markForRedraw("fields change");
        if (this.canSelectCells) this._updateDependentSelections();
    }
},

// In various circumstances we automatically un-embed embedded components.
// - rebuilding bodies for freeze / unfreeze
// - data change such that an embedded components' record is no longer present in the
//   data set
// - field visibility changes to show/hide cells containing components.
// Should we auto-destroy components when this occurs?

shouldDestroyOnUnembed : function (embeddedComponent, reason) {

    // Respect 'dontAutoDestroy' on embedded components. We explicitly doc this for recordComponent
    // usage
    if (embeddedComponent.dontAutoDestroy) return false;

    if (embeddedComponent.isBackgroundComponent) {
        // if we created the backgroundComponent for some record, and the record has now
        // been lost from our data-set, drop it
        if (reason == this._$dataChanged && embeddedComponent.creator == this) return true;
        // Otherwise keep it around (either the developer explicitly created the canvas,
        // or we are simply changing fields / rebuilding for freeze but still have the
        // data around).
        return false;
    }

    if (embeddedComponent.isRecordComponent) {
        if (reason == this._$dataChanged) return true;
        return false;
    }

    if (embeddedComponent.destroyOnUnembed != null) return embeddedComponent.destroyOnUnembed;

    // Keep components around if we just changed columns, otherwise destroy
    if (reason == this._$columnRemap) return false;
    return true;
},

// Used by updateBody - when we rebuild the entire body we just wipe out all embedded
// components.
_$rebuildingBody:"rebuilding body",
_destroyEmbeddedComponentsForRebuild : function () {
    var components = this.body._embeddedComponents;
    if (this.frozenBody) {
        var allComponents = [];
        if (components == null) components = allComponents;
        else components = allComponents.addList(components);
        components.addList(this.frozenBody._embeddedComponents || []);
    }

    if (components && components.length > 0) {
        for (var i=0; i<components.length; i++) {
            var record = components[i].embeddedRecord,
                shouldCollapse = false,
                embeddedComponents = this._getEmbeddedComponents(record)
            ;
            if (embeddedComponents) {
                for (var j=0; j<embeddedComponents.length; j++) {
                    var component = embeddedComponents[j];
                    shouldCollapse = shouldCollapse || component.isExpansionComponent;

                    if (this.shouldDestroyOnUnembed(component, this._$rebuildingBody)) {
                        component.markForDestroy();
                    } else {
                        component.deparent();
                    }
                }
                this._setEmbeddedComponents(record, null);
                if (shouldCollapse) this._setExpanded(record, false);
                this._deleteEmbeddedComponents(record);
            }
        }
    }
},

createBodies : function () {
    if (this.body != null) return; // already created

    // Update virtual scrolling based on showRecordComponents()
    
    this._updateVirtualScrollingForRecordComponents();

    // create the primary body and add it as a child
    this.body = this.createBody(this.ID + "_body", this.normalFields || this.fields);
    // unless gridComponents is customized, the header and sorter button are created before the
    // body. Because the sorter button width may depend on the body's scrollbar size, if the
    // sorter button exists, recompute its width.
    if (this.sorter != null) {
        this.sorter.setWidth(this._getSorterWidth(true));
    }

    this.body.resizeTo("100%", "100%");

    this.bodies = [this.body];

    // drag scrolling should target the body
    this.dragScrollTarget = this.body;

    var frozenFields = this.frozenFields;
    if (frozenFields == null || frozenFields.length == 0) {
        return this.body;
    }

    this.body.addProperties({
        _getViewportFillRows : function () {
            // the frozen body may report an additional row if the normal body is showing an
            // h-scrollbar - check for that and increment the endRow accordingly
            var frozenRows = [0,0];
            if (!this.frozen && this.grid && this.grid.frozenBody) {
                frozenRows = this.grid.frozenBody._getViewportFillRows();
            }

            var rows = this.Super("_getViewportFillRows", arguments);
            if (frozenRows[1] > rows[1]) rows[1]++;
            return rows;
        }
    });

    this.frozenBody = this.createBody(this.ID + "_freezeBody", frozenFields, true);
    this.frozenBody.useNativeDrag = false;
    this.frozenBody.drawAllMaxCells = 0;
    
    // NOTE: Freezing the fields on the left implies we almost certainly have an HScrollbar
    // for the fields on the right, creating a difference in viewport area
    // Add some space to the bottom of the freeze body to make up this difference in the
    // scrollHeight so when the user scrolls to the bottom the grids stay in sync
    if (this.body.hscrollOn && !this.shrinkForFreeze) {
        this.frozenBody.setEndSpace(this.body.getScrollbarSize());
    }

    if (this.freezeStart()) {
        this.bodies.unshift(this.frozenBody);
    } else {
        this.bodies.add(this.frozenBody);
    }

    this.bodyLayout = this.createAutoChild("bodyLayout", {
        width:"100%", height:"100%",
        autoDraw:false,
        members : this.bodies
    }, isc.HLayout);

    // create separate selection objects for body/frozenBody
    this._separateDependentSelections();
},

//> @method listGrid.getBody()
// Returns the primary +link{ListGrid.body,body}, which, when there are frozen fields, is the
// +link{GridRenderer} used to render the non-frozen portion of the dataset; otherwise, the
// primary body (the only body) is the GridRenderer used to render the entire dataset.
// @return (GridRenderer) the primary body or null if this ListGrid has not been drawn yet.
// @visibility external
//<
getBody : function () {
    return this.body;
},

_separateDependentSelections : function () {
    if (this.canSelectCells) {
        var start = this.freezeStart(),
            normalLength = this.body.fields.length,
            frozenLength = this.frozenBody ? this.frozenBody.fields.length : 0;
        this.body._setSeparateCellSelection(this.selection, start ? frozenLength : 0);
        this.frozenBody._setSeparateCellSelection(this.selection, start ? 0 : normalLength);
    }
},

_updateDependentSelections : function () {
    if (!isc.isA.DependentCellSelection(this.body.selection)||
        !isc.isA.DependentCellSelection(this.frozenBody.selection)) {
            // this.logWarn("ListGrid._updateDependentSelection() called when one or more" +
            //              "GridRenderer bodies are not DependentCellSelections!");
        return;
    }
    var start = this.freezeStart(),
        normalLength = this.body.fields.length,
        frozenLength = this.frozenBody.fields.length;
    this.body.selection._updateDependency(start ? frozenLength : 0, normalLength);
    this.frozenBody.selection._updateDependency(start ? 0 : normalLength, frozenLength);
},

// bodyOverflowed - notification method when adjustOverflow runs on the body
// Updates the endSpace on this.frozenBody if we're showing frozen cells.
bodyOverflowed : function () {
    if (this.summaryRow != null && this.summaryRow.body) {
        this.summaryRow.body.setRightSpace(this.body.vscrollOn ? this.body.getScrollbarSize() : 0);
    }
    if (!this.frozenBody) return;
    this.frozenBody.setEndSpace(this.body.hscrollOn && !this.shrinkForFreeze
                                    ? this.body.getScrollbarSize() : 0);
},

//> @attr listGrid.screenReaderCellSeparator (HTMLString : "/" : IRA)
// When +link{isc.setScreenReaderMode(),screen reader mode} is enabled,
// this invisible separator string is written out between each cell value. This
// string will be picked up by screen readers allowing them to more obviously identify
// to the user the different cell values as the contents of a row are read aloud. The
// +link{ListGrid.screenReaderRowSeparator,screenReaderRowSeparator} string if any will
// be written out after the last cell in a row to separate the last cell's value from
// the screen reader's announcement of the row's number and total number of rows in the grid
// (such as "3 of 20").
// <P>
// This attribute may be set to null to disable the feature.
// <P>
// Note that screen readers vary widely on which punctuation symbols are read aloud, and
// sometimes it depends on the context of the punctuation. However, the widely-used JAWS, NVDA,
// and VoiceOver screen readers all read the forward slash '/' as "slash".
// See +externalLink{http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/,Why Dont Screen Readers Always Read Whats on the Screen? Part 1: Punctuation and Typographic Symbols}
// for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA,
// and VoiceOver.
// @group accessibility
// @visibility external
//<
screenReaderCellSeparator:"/",

//> @attr listGrid.screenReaderRowSeparator (HTMLString : "," : IRA)
// When +link{isc.setScreenReaderMode(),screen reader mode} is enabled,
// this invisible string will be written out after the last cell in a row. This
// string will be picked up by screen readers allowing them to more obviously identify
// to the user the end of the row's contents and the screen reader's announcement of the row's
// number and total number of rows in the grid (such as "3 of 20").
// <p>
// This attribute may be set to null to disable writing out an invisible string at the
// end of each row.
// <p>
// Note that screen readers vary widely on which punctuation symbols are read aloud, and
// sometimes it depends on the context of the punctuation. However, the widely-used JAWS, NVDA,
// and VoiceOver screen readers all pause briefly for a comma ',' that is within text.
// See +externalLink{http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/,Why Dont Screen Readers Always Read Whats on the Screen? Part 1: Punctuation and Typographic Symbols}
// for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA,
// and VoiceOver.
// @see screenReaderCellSeparator
// @group accessibility
// @visibility external
//<
screenReaderRowSeparator:",",

createBody : function (ID, fields, frozen) {
    // create a body object to show the body of the list
    var body = isc.ClassFactory.getClass(this.bodyConstructor, true).createRaw();

    body.ID = ID;
    body.autoDraw = false;

    // Body doc'd as auto-child so set creator for back-reference
    body.creator = this;

    body.grid = this;

    body.fields = fields;

    body.frozen = frozen;

    body.overflow = frozen ? "hidden" : this.bodyOverflow;

    if (this.scrollbarConstructor != null) body.scrollbarConstructor = this.scrollbarConstructor;
    if (this.showCustomScrollbars != null) body.showCustomScrollbars = this.showCustomScrollbars;
    if (this.alwaysShowScrollbars != null) body.alwaysShowScrollbars = this.alwaysShowScrollbars;
    
    if (this.useTouchScrolling != null) body.useTouchScrolling = this.useTouchScrolling;
    if (this.scrollbarSize != null) body.scrollbarSize = this.scrollbarSize;

    body.backgroundColor = this.bodyBackgroundColor;
    var bodyStyleName = this.bodyStyleName;
    if (this.alternateBodyStyleName != null && this.alternateRecordStyles) {
        bodyStyleName = this.alternateBodyStyleName;
    }
    body.styleName = bodyStyleName;

    // In order to float widgets above the list, we want to allow contents (the
    // actual table) and children to be drawn for this element.
    body.allowContentAndChildren = true;

    // table geometry (NOTE: record -> row terminology translation)
    
    body.fixedRowHeights = this.fixedRecordHeights;
    body.fixedColumnWidths = this.fixedFieldWidths;
    body.alternateRowStyles = this.alternateRecordStyles;
    body.alternateRowFrequency = this.alternateRecordFrequency;
    body.alternateColumnStyles = this.alternateFieldStyles;
    body.alternateColumnFrequency = this.alternateFieldFrequency;
    body.canSelectText = this.canDragSelectText;
    body.showAllRows = this.showAllRecords;
    if (this.virtualScrolling != null) body.virtualScrolling = this.virtualScrolling;

    // if using drag selection, don't give the Grid a dragTarget
    // - the Grid can handle the selection
    // - the ListGrid won't show a dragTracker
    // Otherwise we're doing dragging of records in and out, so have the ListGrid
    // handle the drag event, and show a tracker.
    body.dragTarget = this.canDragSelect ? null : this;
    body.dragAppearance = isc.EventHandler.NONE;

    body.screenReaderCellSeparator = this.screenReaderCellSeparator;
    body.screenReaderRowSeparator = this.screenReaderRowSeparator;

    // For AutoTest APIs
    body.locatorParent = this;

    // To make checkboxField work with singleCellValue
    body.selectionAppearance = this.selectionAppearance;

    // support for defining GridRenderer override functions and properties directly
    // on the LV instead of via LV.body.
    var propNames = isc.ListGrid._gridPassthroughProperties;

    // pass all of these properties straight through
    for (var i = 0; i < propNames.length; i++) {
        var propName = propNames[i],
            value = this[propName];
        if (value != null) body[propName] = value;
    }

    if (this._originalUseNativeTabIndex != null) {
        body._useNativeTabIndex = this._originalUseNativeTabIndex;
    }

    isc.addProperties(body, this.bodyDefaults, this.bodyProperties);

    // suppress empty message on frozen body - only show it in one place!
    if (frozen) body.showEmptyMessage = false;

    body.completeCreation();
    body = isc.SGWTFactory.extractFromConfigBlock(body);

    // add passthroughs from the body to the ListGrid for pluggable body APIs defined on the grid
    // Note that this has to be after extracting the body from the SGWT config block, if any
    this._addBodyPassthroughMethods(body);

    return body;
},


//> @method listGrid.getDrawnRowHeight() ([A])
// Get the drawn height of a row.
//
// @param rowNum (number)
// @return (number) height
// @group sizing, positioning
// @visibility external
//<

//> @method listGrid.getRowHeight()
// Return the height this row should be.  Default is this.cellHeight. If
// +link{listGrid.fixedRecordHeights} is false, the row may be rendered taller than this
// specified size.
// <P>
// If records will be variable height,
// you should switch on +link{listGrid.virtualScrolling, virtualScrolling}.
// <P>
// Note if +link{listGrid.allowRowSpanning,row spanning} is enabled,
// this method should return the height of a single row (with rowSpan set to 1).
//
// @param   record  (ListGridRecord)    cell record as returned by getCellRecord
// @param   rowNum  (number)    row number
// @return  (number)    height in pixels
// @visibility external
//<
// Undocumented 'isFrozenBody' param used by the ListGrid
// Freezing and editing
// By default in edit mode we allow form items to overflow the available space (don't fix the edit
// However if we have frozen fields we can have form items of different heights in the 2 bodies
// leading to a mismatch.
// Catch this if we can by applying an explicit min-height matching the space that will be
// required by the edit items (for efficiency only run this logic if we have to)
getRowHeight : function (record,rowNum,isFrozenBody) {
    var cellHeight;
    
    if (this.allowRowSpanning && this.getRowSpan) {
        // This code makes an assumption that rowSpanning will never increase going from
        // left to right, and you'll always have at least one column with rowSpan set to 1.
        // If we don't make this assumption we'll have to call the getRowSpan method for
        // every column on both bodies to figure out what the minimum rowSpan for each
        // gridRenderer instance is which won't scale well (code to do this included, can
        // be enabled via an undocumented flag).
        if (!this.allowIncreasingRowSpanning) {
            if (isFrozenBody) {
                cellHeight = this.cellHeight
                    * this.frozenBody._getRowSpan(record, rowNum, this.frozenFields.length-1);
            } else {
                cellHeight = this.cellHeight;
            }

        } else {
            var minRowSpan,
                body = isFrozenBody ? this.frozenBody : this.body,
                startField = isFrozenBody ? 0 :
                            (this.frozenFields ? this.frozenFields.length : 0),
                endField = isFrozenBody ? this.frozenFields.length : this.fields.length;

            for (var i = startField; i < endField; i++) {
                if (minRowSpan == null) {
                    // calling the internal version of the method which will round
                    // off if the rowSpan exceeds the number of rows
                    minRowSpan = body._getRowSpan(record, rowNum, i);
                } else {
                    minRowSpan = Math.min(minRowSpan, body._getRowSpan(record, rowNum, i));
                }
                if (minRowSpan == 1) break;
            }
            cellHeight = this.cellHeight * minRowSpan;
        }
    } else {
        cellHeight = this.cellHeight;
    }

//    this.logWarn("getRowHeight called at row: " + rowNum +
//                 " body is: " + (isFrozenBody ? "frozen" : "unfrozen") +
//                 " returning: " + cellHeight);

    if (this.frozenFields && this.getEditRow() == rowNum) {
        var editForm = this.getEditForm(),
            items = editForm ? editForm.getItems() : [];
        for (var i = 0; i < items.length; i++) {
            var itemHeight = (items[i].getHeight() + 2*this.cellPadding);
            if (itemHeight > cellHeight) cellHeight = itemHeight;
        }
    }
    return this.body.updateHeightForEmbeddedComponents(record, rowNum, cellHeight);
},

// Selection / Rollover effects
// ---------------------------------------------------------------------------------------

selectionCanvasDefaults: {
    
    _constructor: "SelectionOrRollOverCanvas",
    opacity: 20
},

selectionUnderCanvasDefaults: {
},

makeSelectionCanvas : function (record) {
    
    return this.selectionCanvas = this.createAutoChild("selectionCanvas",
        {
            eventProxy:this.body,
            snapTo:"TL",
            width:"100%", height:"100%",
            bubbleMouseEvents:true,
            destroyOnUnEmbed:false,
            percentSource:this, percentBox:"custom",
            grid:this,
            autoDraw:false
        }
    );
},

makeSelectionUnderCanvas : function (record) {
    
    return this.selectionUnderCanvas = this.createAutoChild("selectionUnderCanvas",
        {
            eventProxy:this.body,
            snapTo:"TL",
            width:"100%", height:"100%",
            bubbleMouseEvents:true,
            destroyOnUnEmbed:false,
            percentSource:this, percentBox:"custom",
            grid:this,
            autoDraw:false
        }
    );
},

getSelectionCanvas : function () {
    var selectionCanvas = this.selectionCanvas;
    if (selectionCanvas == null || selectionCanvas.destroyed) {
        selectionCanvas = this.makeSelectionCanvas();
    }
    return selectionCanvas;
},

getSelectionUnderCanvas : function () {
    var selectionUnderCanvas = this.selectionUnderCanvas;
    if (selectionUnderCanvas == null || selectionUnderCanvas.destroyed) {
        selectionUnderCanvas = this.makeSelectionUnderCanvas();
    }
    return selectionUnderCanvas;
},

updateSelectionCanvas : function () {
    var selection = this.selection,
        rowNum,
        colNum,
        record;
    if (isc.isA.CellSelection(selection)) {
        var cell = selection.getSelectedCells()[0];
        rowNum = cell ? cell[0] : -1,
        colNum = cell ? cell[1] : -1;
        record = cell ? this.getCellRecord(rowNum,colNum) : null;
    } else {
        record = this.getSelectedRecord();
        rowNum = this.data ? this.data.indexOf(record) : -1;
    }

    var selectionCanvas = this.selectionCanvas,
        selectionUnderCanvas = this.selectionUnderCanvas,
        refSelectionCanvas = selectionCanvas || selectionUnderCanvas,
        currentRecord,
        currentRowNum,
        currentColNum;
    if (refSelectionCanvas != null) {
        currentRecord = refSelectionCanvas.embeddedRecord;
        currentRowNum = refSelectionCanvas._currentRowNum;
        currentColNum = refSelectionCanvas._currentColNum;
        
    } else {
        currentRecord = null;
        currentRowNum = -1;
        currentColNum = -1;
    }

    // nothing to do if we don't have a selection canvas or a selection, OR
    // we have a selectionCanvas already assigned to the selected record
    var showSelectionOrSelectionUnderCanvas = this.showSelectionCanvas || this.showSelectionUnderCanvas;
    if (refSelectionCanvas == null) {
        if (record == null || !showSelectionOrSelectionUnderCanvas) return;
    } else if (showSelectionOrSelectionUnderCanvas &&
               currentRecord == record &&
               currentRowNum == rowNum &&
               currentColNum == colNum)
    {
        return;
    }

    if (showSelectionOrSelectionUnderCanvas && this.selectionType != isc.Selection.SINGLE &&
        this.selectionType != isc.Selection.NONE)
    {
        this.logWarn((this.showSelectionCanvas
                      ? (this.showSelectionUnderCanvas
                         ? "showSelectionCanvas and showSelectionUnderCanvas are"
                         : "showSelectionCanvas is")
                      : "showSelectionUnderCanvas is") +
                     " set to true, but this is not supported for selectionType " +
                     this.selectionType);
        this.showSelectionCanvas = false;
        this.showSelectionUnderCanvas = false;
        showSelectionOrSelectionUnderCanvas = false;
    }

    // If we're not showing the row, or we have no selection,
    // ensure the selectionCanvas is hidden and bail.
    if (!record || rowNum == -1 || !showSelectionOrSelectionUnderCanvas) {
        if (selectionCanvas != null) {
            this.removeEmbeddedComponent(currentRecord, selectionCanvas);
        }
        if (selectionUnderCanvas != null) {
            this.removeEmbeddedComponent(currentRecord, selectionUnderCanvas);
        }
        return;
    }

    // calling the getters will create the selectionCanvas / selectionUnderCanvas if necessary
    if (this.showSelectionCanvas) {
        selectionCanvas = this.getSelectionCanvas();
        
        selectionCanvas.record = record;
        selectionCanvas.removeOnHideField = true;
        this.addEmbeddedComponent(selectionCanvas, record, rowNum, colNum, "within");
    }
    if ((this.showSelectionCanvas && this.showSelectionUnderCanvas == null) ||
        this.showSelectionUnderCanvas)
    {
        selectionUnderCanvas = this.getSelectionUnderCanvas();
        
        selectionUnderCanvas.record = record;
        selectionUnderCanvas.removeOnHideField = true;
        this.addEmbeddedComponent(selectionUnderCanvas, record, rowNum, colNum, "within");
    }
},

// Roll Over Canvas


rollOverCanvasDefaults: {
    
    _constructor: "SelectionOrRollOverCanvas",
    snapTo: "TL",
    width: "100%",
    height: "100%"
},

rollUnderCanvasDefaults: {
    snapTo: "TL",
    width: "100%",
    height: "100%"
},

makeRollOverCanvas : function () {
    
    return this.rollOverCanvas = this.createAutoChild("rollOverCanvas",
        {   eventProxy:this.body,
            percentSource:this, percentBox:"custom",
            bubbleMouseEvents:true,
            destroyOnUnEmbed:false,
            grid:this,
            autoDraw:false
        }
    );
},

makeRollUnderCanvas : function () {
    
    return this.rollUnderCanvas = this.createAutoChild("rollUnderCanvas",
        {
            eventProxy:this.body,
            percentSource:this, percentBox:"custom",
            bubbleMouseEvents:true,
            destroyOnUnEmbed:false,
            grid:this,
            autoDraw:false
        }
    );
},



//> @method listGrid.getRollOverCanvas()
// If the +link{rollOverCanvas,rollOverCanvas} is enabled, this method will be called to create
// the canvas to display over the current row or cell when a user moves their mouse over the row.
// <p>
// Note that for efficiency this should not typically create a new Canvas every time that it is
// called. Instead typically a single rollOver canvas should be created and updated to reflect
// the current rollOver row if necessary.
// <p>
// Return null to avoid showing a <code>rollOverCanvas</code> for this row.
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
//
// @param rowNum (Integer) index of the current rollOver row.
// @param colNum (Integer) index of the current rollOver column. This parameter will be null unless
// +link{useCellRollOvers,useCellRollOvers} is true for the grid.
// @return (Canvas) the embedded component
// @group hoverComponents
// @visibility external
//<
getRollOverCanvas : function (rowNum, colNum) {
    var rollOverCanvas = this.rollOverCanvas;
    if (rollOverCanvas == null || rollOverCanvas.destroyed) {
        rollOverCanvas = this.makeRollOverCanvas();
    }
    return rollOverCanvas;
},

//> @method listGrid.getRollUnderCanvas()
// If the +link{rollUnderCanvas,rollUnderCanvas} is enabled, this method will be called to create
// the canvas to display under the current row or cell when a user moves their mouse over the row.
// <p>
// Note that for efficiency this should not typically create a new Canvas every time that it is
// called. Instead typically a single rollUnder canvas should be created and updated to reflect
// the current rollOver row if necessary.
// <p>
// Return null to avoid showing a <code>rollUnderCanvas</code> for this row.
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
//
// @param rowNum (Integer) index of the current rollOver row.
// @param colNum (Integer) index of the current rollOver column. This parameter will be null unless
// +link{useCellRollOvers,useCellRollOvers} is true for the grid.
// @return (Canvas) the embedded component
// @group hoverComponents
// @visibility external
//<
getRollUnderCanvas : function (rowNum, colNum) {
    var rollUnderCanvas = this.rollUnderCanvas;
    if (rollUnderCanvas == null || rollUnderCanvas.destroyed) {
        rollUnderCanvas = this.makeRollUnderCanvas();
    }
    return rollUnderCanvas;
},

updateRollOverCanvas : function (rowNum, colNum, leaving) {
    var removeOnly = false;
    var record;

    if (leaving || (!this.showRollOverCanvas && !this.showRollUnderCanvas) || rowNum == -1) {
        removeOnly = true;
    } else {
        record = this.getCellRecord(rowNum, colNum);

        if (record == null || Array.isLoading(record)) {
            removeOnly = true;
        }
    }

    if (removeOnly) {
        if (this.currentRollOverCanvas && !this.currentRollOverCanvas.destroying && !this.currentRollOverCanvas.destroyed) {
            this.removeEmbeddedComponent(this.currentRollOverCanvas.embeddedRecord, this.currentRollOverCanvas);
        }

        if (this.currentRollUnderCanvas && !this.currentRollUnderCanvas.destroying && !this.currentRollUnderCanvas.destroyed) {
            this.removeEmbeddedComponent(this.currentRollUnderCanvas.embeddedRecord, this.currentRollUnderCanvas);
        }

        return;
    }

    

    if (!this.useCellRollOvers) {
        colNum = null;
    }

    // Assume we will never be called if the rowNum / colNum hasn't changed since we already
    // have a check for this in GR.mouseMove
    

    
    var oldRollOverCanvas = this.currentRollOverCanvas,
        oldRollUnderCanvas = this.currentRollUnderCanvas;
    var rollOverCanvas;
    if (this.showRollOverCanvas) {
        rollOverCanvas = this.getRollOverCanvas(rowNum, colNum);
    } else {
        rollOverCanvas = null;
    }
    this.currentRollOverCanvas = rollOverCanvas;
    var rollUnderCanvas;
    if ((this.showRollOverCanvas && this.showRollUnderCanvas == null) ||
        this.showRollUnderCanvas)
    {
        rollUnderCanvas = this.getRollUnderCanvas(rowNum, colNum);
    } else {
        rollUnderCanvas = null;
    }
    this.currentRollUnderCanvas = rollUnderCanvas;

    if (rollOverCanvas != null) {
        rollOverCanvas.grid = this;
        rollOverCanvas.record = record;
        rollOverCanvas.removeOnHideField = true;
        this.addEmbeddedComponent(rollOverCanvas, record, rowNum, colNum, "within");

    } else if (oldRollOverCanvas != null && !oldRollOverCanvas.destroying) {
        this.removeEmbeddedComponent(oldRollOverCanvas.embeddedRecord, oldRollOverCanvas);
    }

    if (rollUnderCanvas != null) {
        rollUnderCanvas.grid = this;
        rollUnderCanvas.record = record;
        rollUnderCanvas.removeOnHideField = true;
        this.addEmbeddedComponent(rollUnderCanvas, record, rowNum, colNum, "within");

    } else if (oldRollUnderCanvas != null && !oldRollUnderCanvas.destroying) {
        this.removeEmbeddedComponent(oldRollUnderCanvas.embeddedRecord, oldRollUnderCanvas);
    }
},

// handle embedded components' z-indices here - allows us to float selection canvas behind
// the LG table if appropriate
updateEmbeddedComponentZIndex : function (component) {
    if (!component) return;
    if (this.selectionCanvas == component) {
        var tableIndex = this.body.getTableZIndex();
        this.selectionCanvas.setZIndex(tableIndex + 50);
    }
    if (this.selectionUnderCanvas == component) {
        var tableIndex = this.body.getTableZIndex();
        this.selectionUnderCanvas.setZIndex(tableIndex - 100);
    }
    // rollover should appear on top of selection.
    if (this.currentRollOverCanvas == component) {
        var tableIndex = this.body.getTableZIndex();
        component.setZIndex(tableIndex + 100);
    }
    if (this.currentRollUnderCanvas == component) {
        var tableIndex = this.body.getTableZIndex();
        component.setZIndex(tableIndex - 50);
    }

},

_handleEmbeddedComponentResize : function (body, component, deltaX, deltaY) {

    // This logic ensures that we don't allow fields to size smaller than their
    // widest embedded component (and that we change that min on component resize
    // if necessary.
    if (component != null && component._currentFieldName &&
        component.embeddedPosition == this._$within &&
        deltaX != null && deltaX != 0)
    {
        // Ignore components not embedded in a column.
        var fieldName = component._currentFieldName,
            field = this.getField(fieldName);
        // Ignore percentWidth components whose size is driven by the
        // field itself rather than vice versa.
        var percentWidth = component._percent_width;
        if (field &&
            (percentWidth == null || !percentWidth.endsWith("%")))
        {

            var newSize = component.getVisibleWidth(),
                oldSize = newSize - deltaX;

            var currentMaxWidth = field._maxComponentWidth;

            // Assertion - if the "field._maxComponentWidth" is currently null,
            // it's either never been set, or we're pending a re-calculation of it.
            // Either way, no need to fire the notification to recalculate again.
            if (currentMaxWidth != null) {
                if (newSize > currentMaxWidth) {
                    this._fieldComponentWidthsChanged(fieldName, newSize);
                } else if (oldSize == currentMaxWidth) {
                    // Don't pass in a "new width" here - we don't know if
                    // other embedded components in this field exceed this component's
                    // new size so have fieldComponentWidthsChanged simply drop the
                    // cached max-width for lazy recalculation.
                    this._fieldComponentWidthsChanged(fieldName);
                }
                // Nothing to do if neither the new nor old size exceeds the
                // width of some other embedded component in the col.
            }
        }
    }


    // If we have frozen fields and an embeddedComponent in one body resizes vertically,
    // refresh both the frozen and unfrozen body to ensure row heights tay in sync.
    if (this.frozenBody != null && deltaY != null && deltaY != 0) {
        var otherBody = (body == this.frozenBody) ? this.body : this.frozenBody;
        otherBody.markForRedraw("Embedded component requires row resizing");
    }
},

// Header
// --------------------------------------------------------------------------------------------

// get properties common to *both* header buttons and the corner sort button
getButtonProperties : function () {
    var propsFromGrid = {
        // textAlign: wipe out the default alignment, which is center, to cause the default to
        // come from the text direction
        align:null
    };
    if (this.headerTitleStyle != null) propsFromGrid.titleStyle = this.headerTitleStyle;
    // NOTE: for headerButtons, headerBaseStyle needs to be re-applied after init, because if
    // field.baseStyle is set it overrides this default.  field.baseStyle is meant to apply to
    // cells only
    if (this.headerBaseStyle != null) propsFromGrid.baseStyle = this.headerBaseStyle;

    // headerButtonSrc / frozenHeaderButtonSrc
    // In multiple skins we use an ImgButton for our header buttons, and provide a custom src
    // property to get the appearance we want
    // These properties allow the overriding of that property for frozen and non frozen ImgButton
    // based header buttons
    
    if (this.headerButtonSrc != null) propsFromGrid.src = this.headerButtonSrc;
    // If 'frozenHeaderBaseStyle' / frozenHeaderTitleStyle is specified, store it on the button
    // defaults under a custom property name so we can apply it when creating buttons for frozen
    // fields
    if (this.frozenHeaderBaseStyle != null)
        propsFromGrid.frozenBaseStyle = this.frozenHeaderBaseStyle;
    if (this.frozenHeaderTitleStyle != null)
        propsFromGrid.frozenTitleStyle = this.frozenHeaderTitleStyle;
    if (this.frozenHeaderButtonSrc != null)
        propsFromGrid.frozenSrc = this.frozenHeaderButtonSrc;


    var properties = isc.addProperties({},
                this.headerButtonDefaults, propsFromGrid, this.headerButtonProperties);
    return properties;
},

// get properties for the headerButtons only (not the sort button)
getHeaderButtonProperties : function (props) {

    var properties = this.getButtonProperties();

    if (this.buttonTitleFunction == null) {
        this.buttonTitleFunction = function () {
            return this.parentElement.grid.getHeaderButtonTitle(this);
        };
    }

    isc.addProperties(
                properties,
                {
                    _canHover: true,
                    minNonEdgeSize: isc.Browser.isTouch? 10: 5,

                    // header button selection is mutex
                    
                    defaultRadioGroup: this.getID()+"_header_radioGroup",

                    // If this field is sortable, we want the button to be a radio button
                    // (Note - mutually-exclusive selection is handled by default by toolbars for
                    // radio type buttons)
                    getActionType : function (a,b,c,d) {
                        var header = this.parentElement,
                            grid;

                        if (header) grid = header.grid;

                        if (grid && isc.isA.ListGrid(grid)) {

                            var field = grid.fields[header.getButtonNumber(this)];

                            // if the list's canSort is false, or the field's
                            // 'canSort' property is false, then this field can't be sorted
                            var canSort = (grid.canSort != false);
                            if (canSort && field != null) canSort = (grid._canSort(field) != false);

                            if (canSort && grid.selectHeaderOnSort) return isc.Button.RADIO;
                        }

                        // We either are canSort:false, or couldn't get a pointer to the list.
                        return this.invokeSuper(this.getClassName(), "getActionType", a,b,c,d);

                    },
                    getTitle : this.buttonTitleFunction,

                    
                    // force layoutAlign: bottom for all header buttons.
                    // Typically this has no impact as header buttons span the breadth of the header, but
                    // if we are showing spans above a field we want to ensure the button is
                    // vertically below the spans.
                    layoutAlign:"bottom",
                    
                    // Override handleMouseOver / handleMouseOut to show the headerMenuButton if appropriate
                    handleMouseOver : function (event) {
                        var grid = this.parentElement.grid;
                        if (grid.shouldShowHeaderMenuButton(this, null, true)) {
                            var hmb = grid._showHeaderMenuButton(this);

                            
                            if (event) {
                                var hmbPageRect = hmb.getPageRect();
                                if (hmbPageRect[0] <= event.x && hmbPageRect[1] <= event.y &&
                                    event.x <= (hmbPageRect[0] + hmbPageRect[2]) &&
                                    event.y <= (hmbPageRect[1] + hmbPageRect[3]))
                                {
                                    
                                    this._delayedSuperHandleMouseOverTmrID = this._delayedSuper("handleMouseOver", arguments, null, 50);
                                    return;
                                }
                            }
                        }

                        return this.Super("handleMouseOver", arguments);
                    },
                    handleMouseOut : function () {
                        if (this._delayedSuperHandleMouseOverTmrID != null) {
                            isc.Timer.clear(this._delayedSuperHandleMouseOverTmrID);
                            delete this._delayedSuperHandleMouseOverTmrID;
                        }

                        
                        var EH = this.ns.EH;
                        if (!isc.Browser.isTouch &&
                            !this.containsPoint(EH.getX(), EH.getY()))
                        {
                            var grid = this.parentElement.grid,
                                headerMenuButton = grid.headerMenuButton;
                            // If the HMB is showing over this button, hide it unless the user rolled
                            // onto it.
                            if (isc.EH.getTarget() != headerMenuButton) {
                                grid._hideHeaderMenuButton(this);
                            }
                        }

                        return this.Super("handleMouseOut", arguments);
                    },
                    handleHover : function () {
                        var header = this.parentElement,
                            grid = header.grid,
                            fieldNum = this.masterIndex;

                        // headerHover is not currently a cancellable event, though
                        // this would be easy to implement as such.                        
                        if (grid.headerHover != null) grid.headerHover(fieldNum);
                        
                        var HTML = grid.defaultHeaderHoverHTML(fieldNum);
                        if (grid.headerHoverHTML) HTML = grid.headerHoverHTML(fieldNum, HTML);
                        
                        grid._showHeaderHover(fieldNum, HTML);
                    }
                },
                props
    );

    return properties;

},

//> @method listGrid.makeHeader()   (A)
// Make the headerBar for the body columns.
// @group   gridHeader
//<
// This method will create a single header or a layout containing frozen and unfrozen header if
// there are frozen fields.
// It will not add as a member or draw() - the calling code is responsible for that.
makeHeader : function () {

    if (this.header != null) return;

    var header = this.header = this.makeHeaderForFields(this.normalFields || this.fields || []);
    // for autoTest APIs
    header.locatorParent = this;

    // make and add the sorter
    if (this.sorter == null) {
        this.makeCornerSortButton();
    }

    this.headers = [header];

    
    if (this.frozenFields) {


        var frozenHeader = this.frozenHeader =
                this.makeHeaderForFields(this.frozenFields, "visible", this.getID() + "_frozenHeader");

        if (this.freezeStart()) {
            this.headers.unshift(this.frozenHeader);
        } else {
            this.headers.add(this.frozenHeader);
        }

        var headerMembers= this.headers.duplicate();

        this.headerLayout = this.createAutoChild("headerLayout", {
            autoDraw: false,
            overflow:"hidden",
            height: this.getHeaderHeight(),
            members : headerMembers
        }, isc.HLayout);
    }

    var outerHeader = this.headerLayout || this.header;


    // We explicitly size the header to fit the specified width less scrollbar-width
    // so we don't want standard layout member-breadth-mgmt code to override this.
    outerHeader.inherentWidth = true;

    this.observe(outerHeader, "moved", function () { this.updateSorter(); });
    this.observe(outerHeader, "resized", function () { this.updateSorter(); });
},

// updateSorter - ensures the sorter is in the correct position and visible (or hidden) as appropriate.
updateSorter : function () {

    if (this.destroying || this.destroyed) return;
    if (!this.sorter || this.sorter.destroying || this.sorter.destroyed) return;

    if (this._overflowQueued || this._deferredOverflow) {
        this.delayCall("updateSorter");
        return;
    }

    // If this.showSort is unset, the sort button's visibility is determined by
    // leaveScrollbarGap, and whether the body has a vertical scrollbar.
    // This may have changed, so ensure the sorter is visible or hidden as appropriate.
    var showSorter = (this.header || this.headerLayout) && this._showSortButton();
    if (showSorter) {
        this.sorter.moveTo(this.getSorterLeft(), this.getSorterTop());
        this.sorter.setHeight(this.getHeaderHeight());
    } else {
        this.sorter.moveTo(0,0);
    }
    this.sorter.setVisibility(
        showSorter ? isc.Canvas.INHERIT : isc.Canvas.HIDDEN
    );
    // if the sorter wasn't created at init, it may not have been drawn yet
    if (showSorter) {
        if (this.isDrawn() && !this.sorter.isDrawn()) this.sorter.draw();
        else this.sorter.moveAbove(this.headerLayout || this.header);
    }
    
    if (this.sortByGroupFirst) {
        var sort = this.getSort();
        
        this.setSort(sort);
    }

},

makeHeaderForFields : function (fields, overflow, ID) {
    // make and add the header
    var header = this.createHeader({
        
        ID:ID,
        grid:this,

        // both the header and LV are looking at the same set of objects for field/button
        // config, but they may have them in a different order due to distinct Array instances.
        buttons:fields.duplicate(),

        // don't actually permanently change the order of the members on drop - we'll handle it from
        // reorderField
        reorderOnDrop:false,

        // wipe the default height of the Toolbar.  Use null instead of headerHeight since, for
        // frozen columns, when there are multiple headers in an HLayout, we don't want heights
        // on each header, just on the overall layout (applied in layoutChildren())
        height:null,

        minMemberLength : this.minFieldWidth,

        // don't force the user to tab between the fields in the toolbar
        tabWithinToolbar:false,

        overflow: overflow || "hidden",

        
        _redrawWithParent:!this.fixedFieldWidths
    })

    // observe the scroll routine of the header to ensure we sync scrolling of the body if the
    // header is scrolled
    // This is necessary when we can natively tab to the button elements (or to focusProxies
    // positioned behind the button elements) because when the native focus goes to a button in
    // the header, the native behavior is to scroll the button into view
    // (if it's not  currently in view).
    this.observe(header, "scrollTo", function () { this.headerScrolled(); });

    return header;
},

//> @method listGrid.setFieldButtonProperties()
// Method to update properties on a field's header button at runtime.
// This property allows customization of any settable properties on the ListGridField's
// header button after it has been generated.  <smartgwt>Note that the provided Canvas should
// only have the minimal needed properties set on it, and should not be a Canvas that's already
// been drawn or added as the child of another widget.</smartgwt>
// @param name (String) Field to update
// @param properties (Canvas properties) new properties to apply to the header button
// @visibility external
//<
// The reasoning behind this is that developers will likely want to customize
// the "src" attribute [and other stuff like capSize] for img / stretchImg based
// header buttons.

setFieldButtonProperties : function (name, properties) {
    var field = this.getField(name)
    if (field != null) {
        var button = this.getFieldHeaderButton(this.getFieldNum(field));
        if (button != null) {
//            this.logWarn("Setting prop:" + button + " > " + this.echo(properties));
            button.setProperties(properties);
        }

    } else {
        field = this.completeFields.find("name", name);
    }
    if (field == null) {
        this.logWarn("setFieldButtonProperties() Unable to find specified field: " + name);
        return;
    }

    // Also copy the properties onto the field definition, so if the button is
    // destroyed / created later, we don't lose the settings.
    // Note that we have some special cases where we pick up a property from a field
    // as part of 'makeButton' and store it on the button under a different name, so
    // remap before applying to the field object. This means we wont (for example)
    // inadvertently clobber the field level "baseStyle" which has different meaning
    // for a ListGridField than for a header button.
    var maskedProps = isc.addProperties({}, properties);
    var remappedPropNames = {
        titleStyle:"headerTitleStyle",
        baseStyle:"headerBaseStyle"
    }
    for (var prop in remappedPropNames) {
        if (maskedProps[prop] != null) {
            maskedProps[remappedPropNames[prop]] = maskedProps[prop];
            delete maskedProps[prop];
        }
    }
    isc.addProperties(field, maskedProps);
},

getHeaderSpanConfig : function (name, spans) {
    if (spans == null) spans = this.headerSpans;
    if (spans == null) return;

    var spanConfig = spans.find("name", name);
    if (spanConfig != null) return spanConfig;
    // Nested header spans - check the "name" property of each span's sub-spans recursively
    
    for (var i = 0; i < spans.length; i++) {
        var span = spans[i];
        if (span.spans != null) {
            spanConfig = this.getHeaderSpanConfig(name, span.spans);
            if (spanConfig != null) return spanConfig;
        }
    }
},

//> @method listGrid.setHeaderSpanButtonProperties()
// Method to update properties on a headerSpan's header button at runtime.
// This property allows customization of any settable properties on the HeaderSpan's
// header button after it has been generated.
// @param name (String) +link{HeaderSpan.name,name} of span to update
// @param properties (Canvas properties) new properties to apply to the header button
// @visibility external
//<
setHeaderSpanButtonProperties : function (name, properties) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanButtonProperties() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    if (spanConfig.liveObject) {
        spanConfig.liveObject.setProperties(properties);
    }

    // Also copy the properties onto the header-span definition, so if the button is
    // destroyed / created later, we don't lose the settings.
    // Note that we have some special cases where we pick up a property from a field
    // as part of 'makeButton' and store it on the button under a different name, so
    // remap before applying to the field object. This means we wont (for example)
    // inadvertently clobber the field level "baseStyle" which has different meaning
    // for a ListGridField than for a header button.
    var maskedProps = isc.addProperties({}, properties);
    var remappedPropNames = {
        titleStyle:"headerTitleStyle",
        baseStyle:"headerBaseStyle"
    }
    for (var prop in remappedPropNames) {
        if (maskedProps[prop] != null) {
            maskedProps[remappedPropNames[prop]] = maskedProps[prop];
            delete maskedProps[prop];
        }
    }
    isc.addProperties(spanConfig, maskedProps);
},

// For some span - goes through every nested inner-span and figures out for all branches
// of the tree the maximum depth. Used for apportioning sizing
getNestedSpanDepth : function (span) {
    if (span._nestedSpanDepth != null) return span._nestedSpanDepth;
    if (span.spans) {
        var innerSpanDepth = 0;
        for (var i = 0; i < span.spans.length; i++) {
            innerSpanDepth = Math.max(innerSpanDepth, this.getNestedSpanDepth(span.spans[i]));
        }
        span._nestedSpanDepth = (1 + innerSpanDepth);
        return span._nestedSpanDepth
    }
    // No inner spans so no nesting
    return 1;
},

//> @method listGrid.createHeader() (A)
// Create a header object suitable for labelling rows or columns
// @group gridHeader
//<
createHeader : function (properties) {
    
    var grid = this;
    var canTabToHeader = this.canTabToHeader || (this.canTabToHeader == null && isc.screenReader);
    var headerProps = isc.addProperties(
        {
            // shouldDragScroll is overridden for the header as the standard implementation is
            // dependent on the header having scrollbars. This header scrolls in sync with the
            // grid body which owns the scrollbars.
            shouldDragScroll: function() { return grid && grid.body && grid.body.hscrollOn;},
            // override makeButton to ignore any baseStyle specified directly on the
            // field definition, and instead always use this.headerBaseStyle
            // Also pick up headerTitleStyle from the field if specified
            makeButton : function (button,a,b,c,d) {
                // this copy is necessary because we pass the actual objects from this.fields
                // into Toolbar.buttons, and hence Toolbar.makeButton receives them, and they
                // should not be modified
                button = isc.addProperties({}, button);
                // The ListGrid already mirrors the button's alignment if reverseRTLAlign is true.
                button.ignoreRTL = true;

                // if the ListGrid is managing the title clipping, then do not enable title
                // clipping in the button. Also set showClippedTitleOnHover to false.
                if (!grid.clipHeaderTitles) {
                    button.clipTitle = false;
                    button.showClippedTitleOnHover = false;
                }

                
                button._redrawLabelWithMaster = true;

                button._getAfterPadding = function () {
                    if (this.masterIndex != null) {
                        var grid = this.grid,
                            field = grid.getField(this.masterIndex),
                            defaultAlign = (this.isRTL() && !grid.reverseRTLAlign
                                            ? isc.Canvas.RIGHT : isc.Canvas.LEFT);
                        if (field != null &&
                            grid.shouldLeaveHeaderMenuButtonSpace(field) &&
                            grid.shouldShowHeaderMenuButton(this) &&
                            (this.wrap || grid._shouldClipHeaderTitle(this.masterIndex)) &&
                            (field.align != defaultAlign ||
                             (grid.headerMenuButton && grid.headerMenuButton.isVisible() &&
                              grid.headerMenuButton.masterElement == this)))
                        {
                            return grid.headerMenuButtonWidth + 1;
                        }
                    }
                    return null;
                };

                if (button.headerTitleStyle) button.titleStyle = button.headerTitleStyle;
                else if (button.frozen && this.buttonProperties.frozenTitleStyle)
                    button.titleStyle = button.frozenTitleStyle;

                if (button.frozen && this.buttonProperties.frozenSrc)
                    button.src = this.buttonProperties.frozenSrc;

                // Override showIf to be unset - we already handle evaluating showIf on listGrid
                // fields - if it returned false the button will never be created - if it returned
                // true for the field we know we want to show the button rather than re-eval
                // field.showIf on button draw
                button.showIf = null;

                button.grid = grid;
                
                // If the field is marked as autoFitWidth, autoFitApproach:'title',
                // set overflow to visible
                var autoFit = grid.shouldAutoFitField(button),
                    approach,
                    fitTitle, fitValue;
                if (autoFit) {
                    approach = grid.getAutoFitWidthApproach(button);
                    if (approach == "both") {
                        fitTitle = true;
                        fitValue = true;
                    } else if (approach == "title") {
                        fitTitle = true;
                        fitValue = false;
                    } else {
                        fitTitle = false;
                        fitValue = true;
                    }
                }

                if (autoFit && fitTitle) {

                    button.overflow = "visible";
                    button.resized = function () {
                        if (this.isDrawn() && this.grid) {
                            this.grid.headerButtonResized(this);
                        }
                    }
                } else {
                    // pick up the default wrap and apply it to the button
                    if (button.wrap == null) {
                        button.wrap = grid.wrapHeaderTitles;
                    }
                }
                // Also if we already calculated a field width based on auto-fit to values,
                // apply it to the header button:
                if (button._calculatedAutoFitWidth) {
                    if (button.width == null || button.width < button._calculatedAutoFitWidth) {
                        button.width = button._calculatedAutoFitWidth
                    }
                // Otherwise we must be auto-fitting to title.  Set the default width to the
                // minimum field width (max of field and grid's minimums), and then the title
                // overflowing will expand the button to accommodate it.
                } else if (button.width == null && fitTitle) {
                    button.width = Math.max(grid.minFieldWidth || 1, button.minWidth || 1);
                }
                // This flag ensures that if the header button is implemented as an imgButton
                // we size the actual image to fit the overflowed size of the label rather than
                // sizing to explicit width
                button.sizeImageToFitOverflow = true;

                // If reverseRTLAlign is true, flip titles too
                if (grid.reverseRTLAlign && grid.isRTL()) {
                    if (button.align == isc.Canvas.LEFT) button.align = isc.Canvas.RIGHT;
                    else if (button.align == isc.Canvas.RIGHT) button.align = isc.Canvas.LEFT;
                }

                // ScreenReader support: Mark header buttons as
                // "rowheaders". Include haspopup:true if we support context menus
                // on them
                // Note - the "button" passed in is the field object so we can check on the
                // master-index directly
                
                if (button.masterIndex != null) {
                    button.ariaRole = "rowheader";
                     
                    var shouldShowMenu = grid.shouldShowHeaderMenuButton(button, null, true),
                        items = button._menuItems || [],
                        hasPopup = button.showDefaultContextMenu != false && items.length > 0
                    ;
                    if (hasPopup) {
                        button.ariaState = isc.addProperties({haspopup:true}, button.ariaState);
                    }
                }
                var button = this.Super("makeButton", [button,a,b,c,d]);

                // pick up field level headerBaseStyle if specified.
                
                if (button.headerBaseStyle) {
                    button.setBaseStyle(button.headerBaseStyle);
                // otherwise rely on the fact that headerBaseStyle is passed to us as part
                // of our default 'button' config
                } else {
                    if (button.frozen && this.buttonProperties.frozenBaseStyle)
                        button.setBaseStyle(this.buttonProperties.frozenBaseStyle);
                    else if (this.buttonProperties.baseStyle != null)
                        button.setBaseStyle(this.buttonProperties.baseStyle);
                }

                return button;
            },
            // Note: make all headerButton items members of the same radio group for
            // click-sort.  Previously this was taken care of by an auto-init of the radioGroup
            // in the Toolbar class - which was in turn based on the value returned by
            // getActionType() method on the button.  Since our getActionType override assumes a
            // parent chain and Toolbar no longer guarantees that this will be set up before
            // the radio group is auto-inited, we just pass one in here.
            buttonProperties:this.getHeaderButtonProperties(),

            border:this.headerBorder,
            styleName:this.headerBarStyle,
            backgroundColor:this.headerBackgroundColor,
            backgroundImage:this.headerBackgroundImage,
            
            canResizeItems: (this.canResizeFields || (this.editingOn && this.editProxy && this.editProxy.canResizeFields)),
            canReorderItems: (this.canReorderFields || (this.editingOn && this.editProxy && this.editProxy.canReorderFields)),
            
            dontObserve:false,

            childVisibilityChanged : function () {
                this.Super("childVisibilityChanged", arguments);
                this._sizeSpans();
            },

            // use this internal API rather than childResized/resized - this leaves those
            // public APIs available for other use, plus reduces the number of reflows by
            // dealing with the layout directly rather than responding to a cascae of
            // childResize()s
            _layoutChildrenDone : function () {
                this.Super("_layoutChildrenDone", arguments);
                this._sizeSpans();
            },

            addSpan : function (span) {

                if (!this._spans) this._spans = [];
                this._spans.add(span);

                // unless the user passed an explicit, always size the span to the height of
                // the header
                if (this.isDrawn()) {
                    this._sizeSpan(span);
                    this.addChild(span);
                }
            },
            _sizeSpans : function () {
                if (!this._spans || !this.isDrawn()) return;
                // We explicitly suppress this method when resizing field buttons
                // in _adjustSpans (where we've already handled setting span button sizes)
                if (this._suppressSizeSpans) return;

                // diable instantRelayout while sizing the spans.
                
                var instantRelayout = this.instantRelayout;
                this.instantRelayout = false;

                for (var i = 0; i < this._spans.length; i++) this._sizeSpan(this._spans[i]);
                this.instantRelayout = instantRelayout;
                delete this._sizingSpans;
            },
            // members == actual members of the layout so they correspond to fields in the
            // grid.
            // if we have nested spans, this method will will return all fields covered by the
            // span and it's child-spans
            _getSpannedMembers : function (span) {
                // use the cached _spanButtons if we've already calculated it.
                // This cache is dropped when we add or remove buttons in the
                // toolbar, so we'll lazily recreate it here.
                if (span._spansButtons != null) {
                    return span._spansButtons;
                }
                var fields = grid.getSpannedFields(span);

                var spansButtons = [],
                    count = fields.length,
                    empty = true;
                for (var i = 0; i < this.members.length; i++) {
                    if (span._spansFields[this.members[i].name] == true) {
                        empty = false;
                        spansButtons[spansButtons.length] = this.members[i];
                        count--;
                    }
                    if (count == 0) break;
                }
                span._spansButtons = spansButtons;
                return empty ? null : spansButtons;
            },

            getNestedSpanDepth : function (span) {
                return grid.getNestedSpanDepth(span);
            },
            _sizeSpan : function (span) {
                if (!this.isDrawn()) {
                    return;
                }

                if (span._spanAutoSizeHeight) {
                    if (grid.autoFitHeaderHeights) {
                        span.setHeight(
                            Math.max(grid.getHeaderButtonDefaultHeight(span.spanConfig),
                                     grid.getHeaderButtonMinHeight(span.spanConfig))
                        );
                    } else {

                        // For nested spans, figure out how many parents / children we have so we can
                        // size and align vertically.
                        // Note: We support "asymmetrically nested" spans - for example a top-span
                        // containing one child span which has fields and another which has an additional
                        // layer of nesting.
                        // Therefore we need to figure out the maximum nested depth and divide
                        // the available space to get a consistent appearance.
                        // Note 2: We support allowing header titles to expand header buttons
                        // vertically. When this occurs the header as a whole has to expand -
                        // already handled via getHeaderHeight(). When this occurs we'll
                        // size the actual header buttons to the max of the calculated
                        // height (specified headerHeight/stack depth) and overflowed height
                        // and rely on the fact that getHeaderHeight() already sized the
                        // header as a whole large enough to accommodate this.
                        var currentSpan = span,
                            availableSpace = grid.headerHeight;
                        while (currentSpan.parentSpan != null
                            && currentSpan.parentSpan.liveObject)
                        {
                            var parentSpan = currentSpan.parentSpan.liveObject;
                            availableSpace -= parentSpan.getVisibleHeight();
                            currentSpan = parentSpan;
                        }

                        // Figuring out the max-depth of nesting of child spans is recursive, handled
                        // in a separate method
                        var childDepth = this.getNestedSpanDepth(span);
                        var height = Math.floor(availableSpace / (childDepth + 1));
                        
                        if (height <= 0) height = 1;

                        span.setHeight(height);
                    }
                }
                if (span.parentSpan != null && span.parentSpan.liveObject != null) {
                    span.setTop(span.parentSpan.liveObject.getBottom());
                }
                var autoSizeWidth = grid.autoSizeHeaderSpans;
                
                var spannedMembers = this._getSpannedMembers(span);

                // buttons are removed from the layout when hidden, so don't break on the lack
                // of spanned members
                var allHidden = spannedMembers == null || spannedMembers.length == 0;
                if (allHidden) {
                    if (this.isVisible()) {
                        span.hide();
                    }
                    return;
                }

                var firstVisibleMember,
                    totalVisibleMembers = 0,
                    spanWidth = 0
                ;
                for (var i = 0; i < spannedMembers.length; i++) {
                    var spannedMember = spannedMembers[i];

                    // disable header reorder drop over spanned columns
                    spannedMember.canReorder = false;

                    if (spannedMember.visibility != isc.Canvas.HIDDEN) {
                        totalVisibleMembers++;
                        spanWidth += spannedMember.getVisibleWidth();
                        if (!firstVisibleMember || this.isRTL()) firstVisibleMember = spannedMember;
                    }
                }

                if (firstVisibleMember) {
                    span.setVisibility(isc.Canvas.INHERIT);
                    span.setLeft(firstVisibleMember.getLeft());
                    var originalWidth = span.getWidth();
                    span.setWidth(spanWidth);
                    
                    if (autoSizeWidth && span.isDrawn()) {
                        // Force an immediate redraw if the span is dirty so getVisibleWidth()
                        // below picks up on the correct new size which may be effected by
                        // the innerHTML
                        if (span.isDirty()) span.redraw();
                        span.setOverflow(isc.Canvas.VISIBLE);

                        var visibleWidth = span.getVisibleWidth();
                        if (visibleWidth > spanWidth) {
                            span.setWidth(visibleWidth);
                            var delta = visibleWidth - spanWidth;

                            for (var i = 0; i < spannedMembers.length; i++) {
                                var spannedMember = spannedMembers[i];
                                if (spannedMember.visibility != isc.Canvas.HIDDEN) {
                                    var itemDelta = Math.ceil(delta / totalVisibleMembers);
                                    delta -= itemDelta;
                                    totalVisibleMembers -= 1;
                                    spannedMember.resizeBy(itemDelta);
                                }
                            }
                            
                            
                            if (visibleWidth != originalWidth) {
                                grid._updateFieldWidths("autoSizeHeaderSpans: Caused fields to expand", true);
                            }
                        }
                        span.setOverflow(isc.Canvas.HIDDEN);
                    }
                }
            },

            _adjustSpans : function (resizeFieldsOnly) {
                if (!this._spans) return;
                
                var recursive = this._adjustingSpans;
                this._adjustingSpans = true;
                if (!resizeFieldsOnly) this._sizeSpans();
                var thisHeight = this.getVisibleHeight();

                // Flag to suppress reacting to reflow for sizing header buttons by
                // re-sizing spans!
                this._suppressSizeSpans = true;
                // also disable instantRelayout while sizing the field buttons
                
                var instantRelayout = this.instantRelayout;
                this.instantRelayout = false;

                for (var i = 0; i < this._spans.length; i++) {
                    var span = this._spans[i];
                    if (!this.resizeFieldsOnly) this.addChild(span);

                    var spannedMembers = this._getSpannedMembers(span);
                    if (!spannedMembers) continue;

                    for (var j = 0; j < spannedMembers.length; j++) {
                        var header = spannedMembers[j],
                            headerHeight = header.getVisibleHeight()
                        ;

                        // For nested spans, figure out the total height of nested spans,
                        // and size the field to take up the rest of the header's height
                        
                        var parentSpan = grid.spanMap[header.name],
                            spanHeight = 0;
                        do {
                            // 'liveObject' should have been created if we have
                            // a button for the children!
                            if (parentSpan.liveObject == null) break;
                            spanHeight += parentSpan.liveObject.getVisibleHeight();
                            parentSpan = parentSpan.parentSpan;
                        } while (parentSpan != null)
                        header.setHeight(thisHeight - spanHeight);
                        // Depending on skin, buttons sometimes need to redraw on resize
                        // Do this now so the reported visible width/height is accurate for
                        // subsequent layout.
                        // Resolves an issue where in some cases header buttons could be
                        // mis-positioned when 
                        if (header.isDirty()) {
                            header.redraw();
                        }
                    }
                    span.bringToFront();
                }
                this.instantRelayout = instantRelayout;
                if (!recursive) {
                    delete this._suppressSizeSpans;
                    delete this._adjustingSpans;
                }
            },

            removeButtons : function (buttons) {
                if (grid.headerSpans) grid._removeHeaderSpans(buttons, this);
                this.Super("removeButtons", arguments);
            },
            addButtons : function (buttons, position) {
                this.Super("addButtons", arguments);
                if (grid.headerSpans) grid._addHeaderSpans(buttons, this);
                this._adjustSpans();
            },


            draw : function () {
                if (this._spans && grid.unspannedHeaderVAlign) {
                    for (var i = 0; i < this.buttons.length; i++) {
                        var button = this.buttons[i],
                            isSpanned = grid.spanMap[button.name] != null;
                        if (!isSpanned) {
                            button.valign = grid.unspannedHeaderVAlign;
                        }
                    }
                }
                this.Super("draw", arguments);
                this._adjustSpans();

            }

            // AutoTest subsytem APIs
            // Allow mapping header buttons by field name rather than just position in the
            // header!
            

            ,getStandardChildLocator : function (canvas) {
                var fieldNum = canvas.masterIndex,
                    grid = this.grid;
                if (fieldNum != null && grid != null) {
                    var fieldName = grid.getFieldName(fieldNum);
                    return isc.AutoTest.createLocatorFallbackPath("headerButton", {fieldName:fieldName});
                }

                return this.Super("getStandardChildLocator", canvas);
            },

            getChildFromLocatorSubstring : function (substring, index, locatorArray, configuration)
            {
                // Don't interfere with standard 'autoChild' / 'scrollbar' identifiers
                if (isc.isA.Canvas(this[substring])) return this[substring];

                var parsedPath = isc.AutoTest.parseLocatorFallbackPath(substring);
                if (this.grid && parsedPath && parsedPath.name == "headerButton") {

                    var fieldName = parsedPath.config.fieldName,
                        fieldNum = this.grid.getFieldNum(fieldName),
                        header = this.grid.getFieldHeader(fieldNum);

                    // field, or header may have been hidden
                    if (fieldNum == -1 || header == null) {
                        this.logWarn("fieldName:" + fieldName + ", gave fieldNum:" + fieldNum
                                + " unable to find header button for this field.");
                        return;
                    }
                    if (header != this) {
                        this.logWarn("AutoTest locator string specified this header for field "
                            + fieldName + " but that header button is contained in header "
                            + header + ". This can happen if headers have been frozen / "
                            + "unfrozen since the locator string was created. Redirecting to that widget.");
                        return header.getChildFromLocatorSubstring(substring);
                    }
                    // return locator header button state value if requested
                    if (configuration && configuration.attribute == isc.Canvas._$Value) {
                        var field = this.grid.fields[fieldNum];
                        if (fieldNum == this.grid.getCheckboxFieldPosition()) {
                            configuration.value = !!field._allSelected;
                        } else configuration.value = field.sortDirection;
                    }
                    return this.members[this.grid.getLocalFieldNum(fieldNum)];
                }

                return this.Super("getChildFromLocatorSubstring", arguments);
            }


        }, properties);
    // if cantabToHeader is false, suppress tabbing to the header!
    if (!canTabToHeader) {
        headerProps.tabIndex = -1;
    }
    if (this.headerButtonConstructor != null)
        headerProps.buttonConstructor = this.headerButtonConstructor;

    var header = this.createAutoChild("header", headerProps,
        
        isc.Toolbar);

    // if the canReorderFields is true, observe the reorderItem method of the header
    if (header.canReorderItems && !header.dontObserve) {
        this.observe(header, "itemDragReordered", function (itemNum, newPosition) {
            this.headerDragReordered(itemNum, newPosition, header);
        });
        // NOTE: we don't actually do anything in the LV until reorder completes in the header
    }

    // if canResizeFields is true, observe the resizeItem and dragResize* methods of the header
    if (header.canResizeItems && !header.dontObserve) this._observeHeaderResize(header);

    if (this.headerSpans) this._addHeaderSpans(properties.buttons, header);
    return header;
},

// If we're showing overflow:"visible" header buttons (for auto-fitting to titles), we need to
// react to them resizing due to a title change (such as showing the sort arrow!)
headerButtonResized : function (button) {
    if (this._suppressAutoFitToTitle) return;
    
    if (this._dragResizingField) return;
    
    // If we're being called directly from setFieldWidth/setFieldWidths, don't react
    // to the resize. Upstream code should handle this
    if (this._settingHeaderFieldWidths) return;
    
    // If we're doing an "autoFit" to the field content - this is similar to a drag-resize - no need to react.
    if (this._autoFittingField != null && this._autoFittingField == this.getField(button.name)) {
        return;
    }
    
    // Clear the appliedInitialAutoFitWidth flag and run field width resize logic
    
    this.fields._appliedInitialAutoFitWidth = false;
    
    this._updateFieldWidths("header button resized");
},

// If a developer declares header-spans, fields that are spanned by the same header need to be
// next to each other (obviously).
// This means we may need to reorder the fields array as specified in the code.
// If we actually change anything let's log a warning - developers may be confused as to why
// the fields are not matching the specified positions.

reorderFieldsForHeaderSpans : function (spans) {
    if (spans == null) spans = this.headerSpans;
    if (spans == null) return;
    var orderChanged = false;
    for (var i = 0; i < spans.length; i++) {
        var span = spans[i],
            fields = this.getSpannedFields(span);
        if (fields == null || fields.length == 0 || fields.length == 1) continue;

        var gridFields = this.fields,
            length = fields.length,
            positions = [],
            frozen = null;

        for (var ii = 0; ii < length; ii++) {
            var pos = this.completeFields.findIndex("name", fields[ii]);
            // fieldName may not be present (due to setFields call etc)
            if (pos == -1) continue;

            // Frozen fields - currently we just warn if the developer attempted to
            // mix frozen and unfrozen fields within a span.
            if (frozen == null) {
                frozen = !!(this.completeFields[pos].frozen);
            } else {
                if (frozen != !!(this.completeFields[pos].frozen)) {
                    this.logWarn("HeaderSpan with title:" + span.title +
                        " has both frozen and unfrozen fields specified. This is not supported.");
                    
                }
            }
            positions.add({
                field:fields[ii],
                pos:this.completeFields.findIndex("name", fields[ii])
            });
        }

        positions.sortByProperty("pos", Array.ASCENDING);

        if (positions.length > 0 &&
            (positions.last().pos - positions.first().pos) > (positions.length-1))
        {
            this.logWarn("HeaderSpan with title " + span.title
                + " spans fields that are not adjacent in the specified fields array. "
                + "Reordering fields such that they are adjacent and can be spanned.");
            // We don't attempt to maintain the relative order specified in the fields array.
            // This would be difficult with nested spans since we'd potentially have to
            // reorder inner-spans within the parent depending on where fields were defined in the
            // fields array.
            var targetPos = positions.first().pos;
            for (var ii = 0; ii < length; ii++) {
                var field = fields[ii],
                    currentPos = this.completeFields.findIndex("name", field);
                
                if (currentPos == -1) continue;

                if (targetPos != currentPos) {
                    orderChanged = true;
                    this.completeFields.slide(currentPos, targetPos);
                }
                targetPos += 1;
            }
        // This implies that the fields are all adjacent.
        // Howeve if we have *nested* spans we also need to verify they're adjacent within
        // their various inner-spans
        } else if (span.spans) {
            orderChanged = this.reorderFieldsForHeaderSpans(span.spans);
        }
    }
    return orderChanged;
},

// Make a reverse map of fieldNames to header spans so we can look up
// the span (hierarchy) for a field rapidly.

buildSpanMap : function (spans, parentSpan, forPrinting, spanMap) {
    if (spanMap == null) spanMap = {};
    if (spans == null) spans = this.headerSpans;

    for (var i = 0; i < spans.length; i++) {
        var headerSpanConfig = spans[i];
        if (parentSpan) headerSpanConfig.parentSpan = parentSpan;
        if (headerSpanConfig.spans) {
            this.buildSpanMap(headerSpanConfig.spans, headerSpanConfig, forPrinting, spanMap);
        } else if (headerSpanConfig.fields) {
            // If we're printing, filter out the fields that should not be printed.
            if (forPrinting == true) {
                headerSpanConfig = isc.addProperties({}, headerSpanConfig);
                headerSpanConfig.fields = headerSpanConfig.fields.duplicate();
                for (var j = 0; j < headerSpanConfig.fields.length; ){
                    var fieldName = headerSpanConfig.fields[j];
                    var field = this.getField(fieldName);
                    if (field == null || field.shouldPrint == false) {
                        headerSpanConfig.fields.removeAt(j);
                        // don't increment `j'
                    } else {
                        ++j;
                    }
                }
                headerSpanConfig.fields.removeAll(headerSpanConfig.fields.findAll("shouldPrint", false));
            }
            for (var j = 0; j < headerSpanConfig.fields.length; j++) {
                spanMap[headerSpanConfig.fields[j]] = headerSpanConfig;
            }
        } else {
            this.logWarn("ListGrid passed unexpected header span object with " +
                "neither fields nor spans specified:" + this.echo(headerSpanConfig));
        }
    }

    return spanMap;
},


getSpannedFields : function (span, canHideFieldsOnly) {
    
    if (span == null) return [];

    if (span.fields) {
        var fields = span.fields;
        // This method is used by the column picker menu - if passed the
        // canHideFieldsOnly flag, ignore any fields marked as canHide:false
        if (canHideFieldsOnly) {
            var finalFields = [];
            for (var i = 0; i < span.fields.length; i++) {
                var fieldObj = (this.completeFields || this.fields).find("name", span.fields[i]);
                if (!fieldObj || fieldObj.canHide == false) {
                    continue;
                }
                finalFields.add(span.fields[i]);
            }
            fields = finalFields;
        }
        return fields;
    }

    var fields = [];
    if (span.spans) {
        for (var i = 0; i < span.spans.length; i++) {
            fields.addList(this.getSpannedFields(span.spans[i], canHideFieldsOnly));
        }
    }
    return fields;
},


_headerSpanVisible : function (fieldNames, span) {
    if (span.spans) {
        for (var i = 0; i < span.spans.length; i++) {
            if (this._headerSpanVisible(fieldNames, span.spans[i])) return true;
        }
        return false;
    } else {
        return (fieldNames.intersect(span.fields).length > 0)
    }
},


// Called recursively to create header-span-buttons and to layout
_addHeaderSpans : function (fields, header, headerSpans, parentSpan) {

    // For convenience, allow calling directly for top level spans.
    if (headerSpans == null) headerSpans = this.headerSpans;

    // find headerSpans that match our set of fields
    var fieldNames = fields.getProperty(this.fieldIdProperty);

// so headerSpans will now be an array of all the spans we actually care about,
// with the inner spans first in the list....

    for (var i = 0; i < headerSpans.length; i++) {
        var headerSpanConfig = headerSpans[i];

        // We don't support both fields and spans on a span - if we hit this
        // warn and drop the fields.
        if (headerSpanConfig.fields != null && headerSpanConfig.spans != null) {
            this.logWarn("ListGrid specified with headerSpan config object containing both " +
                "spans and fields. This is not supported - spanned fields must be all frozen or " +
                "all not frozen. Span Configuration:\n" +
                    this.echo(headerSpanConfig));

            headerSpanConfig.fields = null;
        }

        // If the header span doesn't match any visible fields, skip it
        if (!this._headerSpanVisible(fieldNames, headerSpans[i])) continue;

        // allow a canvas to be passed in

        // default to using the same component that header buttons are made of - this
        // way we get a consistent cross-skin look that's a reasonable default
        var grid = this,
            span = this.createHeaderSpan(header, headerSpanConfig);

        header.addSpan(span);

        // recursively build nested spans and add them to the header as well.
        if (span.spans) {
            this._addHeaderSpans(fields, header, span.spans, span);
        }
    }
},

createHeaderSpan : function (header, headerSpanConfig) {
    var grid = this,
        span = headerSpanConfig.liveObject;
    // If the span is destroyed or destroying, rebuild it.
    
    if (span == null || span.destroyed || span.destroying || span._pendingDestroy) {
        var config = headerSpanConfig,
            dynamicProperties = isc.addProperties(this.getButtonProperties(), {
                _constructor: header.buttonConstructor,
                height: this.headerSpanHeight,
                // typical to align the span text in the center
                align: "center",
                valign: this.headerSpanVAlign,
                showRollOver: false,
                showContextMenu : function () {
                    return grid.headerSpanContextClick(this);
                },
                // Suppress the title-clipper if we're auto-size:true
                
                shouldClipTitle : function (span) {
                    if (grid.autoSizeHeaderSpans) return false;
                    return this.Super("shouldClipTitle", arguments);
                }
            }, config)
        ;

        // Support custom per-span styling:

        // title style useful for stretchImgButtons
        // Note that if you have stretchImgButton based headers, in order to customize
        // appearance you'd probably also want to specify custom src and capSize
        // This is actually supported in both ListGridFields and HeaderSpans, but
        // not explicitly documented.
        if (config.headerTitleStyle) {
            dynamicProperties.titleStyle = config.headerTitleStyle;
        }

        // BaseStyle for simple buttons (more recent skins)
        if (config.headerBaseStyle != null) {
            dynamicProperties.baseStyle = config.headerBaseStyle;
        }

        // override the liveObject title with headerTitle, if it's present
        if (config.headerTitle != null) dynamicProperties.title = config.headerTitle;
        span = config.liveObject = this.createAutoChild("headerSpan", dynamicProperties);

        // auto-size span height unless an explicit height is set somewhere
        var height = config.height ||
                     (this.headerSpanProperties ? this.headerSpanProperties.height : null) ||
                     (this.headerSpanDefaults ? this.headerSpanDefaults.height : null) ||
                     this.headerSpanHeight;

        span._spanAutoSizeHeight = (height == null);
    }

    
    span._spansFields = {};
    var fields = this.getSpannedFields(headerSpanConfig);
    for (var ii = 0; ii < fields.length; ii++) {
        span._spansFields[fields[ii]] = true;
    }

    // drop the cached live buttons we actually span - we'll lazily regenerate when they're required.
    span._spansButtons = null;

    span.spanConfig = headerSpanConfig;

    return span;
},

_removeHeaderSpans : function (buttons, header) {
    // find headerSpans that match our set of fields
    var headerSpans = [],
        fieldNames = buttons.getProperty(this.fieldIdProperty)
    ;
    for (var i = 0; i < fieldNames.length; i++) {
        var span = this.spanMap[fieldNames[i]];
        while (span != null && span.liveObject != null) {
            span.liveObject._spansButtons = null;
            span = span.parentSpan;
        }
    }

    // no need to actually remove the span from the header - we'll lazily hide it as part of
    // this._sizeSpans()
},


//> @attr listGrid.showHeaderSpanTitlesInFormulaBuilder (Boolean : true : IRW)
// If this grid has specified +link{listGrid.headerSpans,headerSpans}, should field titles be
// prefixed with the titles of the headerSpans in which they are contained when
// using the +link{FormulaBuilder} or +link{SummaryBuilder}.
// @see listGrid.formulaBuilderSpanTitleSeparator
// @visibility external
//<
showHeaderSpanTitlesInFormulaBuilder:true,

//> @attr listGrid.formulaBuilderSpanTitleSeparator (String : " - " : IRW)
// If this grid has specified +link{listGrid.headerSpans,headerSpans}, and
// +link{showHeaderSpanTitlesInFormulaBuilder,showHeaderSpanTitlesInFormulaBuilder} is true,
// this string will be inserted between the headerSpan title(s) and the field title in the
// field chooser grid in the +link{FormulaBuilder} and +link{SummaryBuilder}.
// @group i18nMessages
// @visibility external
//<
formulaBuilderSpanTitleSeparator:" - ",

//> @attr listGrid.showHeaderSpanTitlesInSortEditor (Boolean : true : IRW)
// If this grid has specified +link{listGrid.headerSpans,headerSpans}, should field titles be
// prefixed with the titles of the headerSpans in which they are contained when
// using the +link{MultiSortDialog,multi-sort editor}.
// @see listGrid.sortEditorSpanTitleSeparator
// @visibility external
//<
showHeaderSpanTitlesInSortEditor:true,

//> @attr listGrid.sortEditorSpanTitleSeparator (String : " - " : IRW)
// If this grid has specified +link{listGrid.headerSpans,headerSpans}, and
// +link{showHeaderSpanTitlesInSortEditor,showHeaderSpanTitlesInSortEditor} is true, this
// string will be inserted between the headerSpan title(s) and the field title in the field
// chooser grid on the +link{MultiSortDialog,multi-sort editor}
// @group i18nMessages
// @visibility external
//<
sortEditorSpanTitleSeparator:" - ",

//> @attr listGrid.showHeaderSpanTitlesInHiliteEditor (Boolean : true : IRW)
// If this grid has specified +link{listGrid.headerSpans}, should field titles be
// prefixed with the titles of the headerSpans in which they are contained when
// using the +link{databoundComponent.editHilites,hilite editor}.
// @see listGrid.hiliteEditorSpanTitleSeparator
// @visibility external
//<
showHeaderSpanTitlesInHiliteEditor:true,

//> @attr listGrid.hiliteEditorSpanTitleSeparator (String : " - " : IRW)
// If this grid has specified +link{listGrid.headerSpans}, and
// +link{showHeaderSpanTitlesInHiliteEditor} is true, this string will be inserted
// between the headerSpan title and the field title in the hiliteEditor field chooser
// grid.
// @group i18nMessages
// @visibility external
//<
hiliteEditorSpanTitleSeparator:" - ",

// When getting the set of fields to show in a hilite editor, prefix with
// header span titles where applicable.
getHiliteCriteriaFields : function () {

    var fields = this.Super("getAllFields", arguments);
    if (!fields) return;
    fields = fields.duplicate();
    if (this.showHeaderSpanTitlesInHiliteEditor && this.headerSpans != null) {
        for (var i = 0; i < fields.length; i++) {
            var span = this.spanMap[fields[i].name],
                isSpanned = false,
                spans = [{title:this.getFieldTitle(fields[i])}];
            while (span != null) {
                isSpanned = true;
                spans.addAt(span, 0);
                span = span.parentSpan;
            }
            if (isSpanned) {
                var title = spans.getProperty("title").join(this.hiliteEditorSpanTitleSeparator);
                
                fields[i] = isc.addProperties({}, fields[i],
                    {title:title});
            }
        }
    }
    return fields;
},

//> @method listGrid.dirtyHeader()  (A)
//          let the header know that it should redraw when we get a chance
//      @group  gridHeader
//<
dirtyHeader : function () {
    if (this.header) this.header.markForRedraw();
},

// update an existing header to match the current set of fields.
updateHeader : function () {

    // wipe out the old header if there was one
    var oldHeader = this.frozenHeader ? this.headerLayout : this.header;

    if (oldHeader) {
        // defer destruction to prevent possible IE slow script dialogs for large number of columns
        oldHeader.markForDestroy();
        // need to clear out IDs to prevent ID collision warnings as we recreate the header (it
        // will have the same ID).

        
        
        oldHeader.clear();
        if (this.showHeader) {
            var toolbars = [this.frozenHeader,this.header];
            for (var i = 0; i < toolbars.length; i++) {
                if (toolbars[i] == null) continue;
                if (toolbars[i]._spans != null) {
                    for (var ii = 0; ii < toolbars[i]._spans.length; ii++) {
                        var span = toolbars[i]._spans[ii];
                        if (span) {
                            span.deparent();
                            
                            if (this._autoDestroySpans) span.destroy();
                        }
                    }
                }
            }
            delete this._autoDestroySpans;
        }
        
        oldHeader.clearIDs();

        // clear the pointer to the headerMenuButton (if present) because it is going to be destroyed
        this.headerMenuButton = null;
    }

    this.header = this.frozenHeader = this.headerLayout = null;

    // create a new header if so configured
    var showHeader = this.showHeader,
        headerIndex;
    if (showHeader) {
        headerIndex = this.gridComponents.indexOf(this._$header);
        if (headerIndex == -1) {
            showHeader = false;
            this.logWarn("showHeader set to true, but header not included in grid header components." +
                " The header will not be shown.");
        }
    }
    if (showHeader) {
        // If we're auto-fitting fields to their titles vertically this process may change
        // the header height - drop the cached header heights now.
        // This means that getHeaderHeight() will lazily recalculate the correct value and
        // we'll reflow to accommodate it.
        if (this.autoFitHeaderHeights) {
            this.dropCachedHeaderButtonHeights();
        }

        this.makeHeader();
        // createChildren builds the standard grid components and adds them as members.
        // If this has already occurred, we'll need to explicitly add the header as
        // a member here. Note that calling code typically will cause a resize, etc via
        // a call to layoutChildren or _updateFieldWidths()
        this.updateGridComponents();

    // We're hiding the sorter here, since _updateFieldWidths handles positioning and showing
    // the sorter if appropriate
    // sorter may be undef (if showSorter is false)
    } else if (this.sorter) {
        this.sorter.hide();
    }

    
},

//> @method listGrid.setHeaderHeight()
// Modify the height of a listGrid. To hide the header set height to zero.
// @param height (number) new height for the header
// @visibility external
// @group sizing, gridHeader
//<
_$headerHeightChanged:"header height changed",
setHeaderHeight : function (height) {
    var oldHeight = this.headerHeight;

    if (oldHeight == height) return;

    this.headerHeight = height;

    this._updateHeaderHeight(oldHeight == 0);
},

_updateHeaderHeight : function (wasHidden) {
    // No need to update the header if we're not showing it.
    if (this.showHeader == false) return;

    if (!this.header && this.getHeaderHeight() > 0) {
        // Don't build the header if it's not included in the gridComponents array!
        var headerIndex = this.gridComponents.indexOf("header");
        if (headerIndex == -1) {
            return;
        }
        // If we're not drawn the header will get created when we get drawn
        // Otherwise create and draw it now.
        if (this.isDrawn()) {
            this.updateGridComponents();
        }
    } else {
        
        if (wasHidden) this.updateHeader();
        // handles resizing (and showing/hiding if appropriate)
        this.layoutChildren(this._$headerHeightChanged)
    }

    this.updateSorter();
    if (this.headerSpans) {
        
        this.header._adjustSpans(true);
    }
},

//> @method listGrid.setShowHeader()
// Show or hide the ListGrid header.
// @param show (boolean) true to show the header, false to hide it.
// @visibility external
// @group gridHeader
//<
_$headerVisibilityChanged:"header visibility changed",
setShowHeader : function (show) {
    if (show == this.showHeader) return;

    this.showHeader = show;

    this.updateHeader();
    this.layoutChildren(this._$headerVisibilityChanged);
},

// Header Menu button
// -------------------------------------------------------------------------------------------

shouldShowHeaderMenuButton : function (header, skipTouchEventCheck, updateItems) {
    
    if (!skipTouchEventCheck && this.ns.EH._handlingTouchEventSequence()) return false;

    var shouldShow;
    if (header.showDefaultContextMenu == false) {
        shouldShow = false;
    }
    
    else if (header.showHeaderContextMenuButton != null) {
        shouldShow = header.showHeaderContextMenuButton;
    } else {
        shouldShow = this.showHeaderMenuButton;
    }
    
    if (this.showHeaderContextMenu && shouldShow && header.masterIndex != null) {
        // suppress the headerContextMenuButton if we won't actually show the headerContextMenu
        if (updateItems) {
            
            header._menuItems = this.getHeaderContextMenuItems(header.masterIndex) || [];
        }
        return (header._menuItems && header._menuItems.length > 0);
    }
    return false;
},

// getHeaderMenuButton
// creates the headerMenuButton autoChild. Lazily creates the button if it hasn't been shown yet
getHeaderMenuButton : function (button) {
    // after certain column operations like freeze, the headerMenuButton may be destroyed
    // so recreate it if so.
    if (!this.headerMenuButton || this.headerMenuButton.destroyed) {
        var dynamicDefaults = {
            snapTo:(this.isRTL() ? "L" : "R"),
            resizeFrom:(this.isRTL() ? "L" : "R")
        };

        // don't default anything to explicit null!
        if (this.headerMenuButtonHeight) dynamicDefaults.height = this.headerMenuButtonHeight;
        if (this.headerMenuButtonWidth) dynamicDefaults.width = this.headerMenuButtonWidth;
        if (this.headerMenuButtonIcon) dynamicDefaults.icon = this.headerMenuButtonIcon;
        if (this.headerMenuButtonIconHeight) {
            dynamicDefaults.iconHeight = this.headerMenuButtonIconHeight;
        }
        if (this.headerMenuButtonIconWidth) {
            dynamicDefaults.iconWidth = this.headerMenuButtonIconWidth;
        }
        if (this.headerMenuButtonBaseStyle) {
            dynamicDefaults.baseStyle = this.headerMenuButtonBaseStyle;
        }
        if (this.headerMenuButtonTitleStyle) {
            dynamicDefaults.titleStyle = this.headerMenuButtonTitleStyle;
        }
        if (this.headerMenuButtonSrc) dynamicDefaults.src = this.headerMenuButtonSrc;

        this.createAutoChild("headerMenuButton", dynamicDefaults, "Button", true);
    }

    

    this.headerMenuButton.masterIndex = button.masterIndex;

    // correct the position of the header menu button so that it is not obscured by
    // the sorter button or any length of the button on the right that is clipped by
    // the viewport.
    var hmbSnapOffsetLeft = 0,
        fieldIsFrozen = this.fieldIsFrozen(button.masterIndex);
    if (!fieldIsFrozen && this.body != null) {
        var viewportWidth = this.body.getViewportWidth(),
            buttonScrollWidth = button.getScrollWidth();
        if (this.isRTL()) {
            
        } else {
            var buttonLeft = button.getLeft(),
                offset = buttonLeft - this.body.getScrollLeft(),
                hiddenLength = offset + buttonScrollWidth - viewportWidth;
            if (this._showSortButton()) hiddenLength += this._getSorterWidth();
            if (this.body.vscrollOn) hiddenLength -= this.body.getScrollbarSize();
            if (hiddenLength > 0) {
                hmbSnapOffsetLeft = -hiddenLength;
            }
        }
    } else if (fieldIsFrozen && this.frozenBody != null) {
        var viewportWidth = this.getViewportWidth(),
            buttonScrollWidth = button.getScrollWidth();
        
        if (this.isRTL()) {
            
        } else {
            var hiddenLength;
            if (this.sorter != null && this._showSortButton()) {
                hiddenLength = button.getPageLeft() + buttonScrollWidth - this.sorter.getPageLeft();
            } else {
                hiddenLength = button.getLeft() + buttonScrollWidth - viewportWidth;
                if (this.frozenBody.vscrollOn) hiddenLength -= this.frozenBody.getScrollbarSize();
            }

            if (hiddenLength > 0) {
                hmbSnapOffsetLeft = -hiddenLength;
            }
        }
    }
    this.headerMenuButton.setSnapOffsetLeft(hmbSnapOffsetLeft);

    this.headerMenuButton.canDragResize = (button.canDragResize != null
                                           ? button.canDragResize && this.canResizeFields
                                           : this.canResizeFields);
    return this.headerMenuButton;
},

headerMenuButtonDefaults: {
    // Default the title to explicit null rather than the default Button.title property
    // (EG "Untitled Button")
    title:null,
    iconSpacing:0,
    showDisabled:false,
    showDisabledIcon:false,

    click : function () {
        this.creator.headerMenuButtonClick();
    },
    doubleClick : function () {
        this.creator.headerMenuButtonDoubleClick();
    },
    mouseOut : function () {
        var EH = this.ns.EH;
        if (!isc.Browser.isTouch) {
            var target = EH.getTarget();
            if (!target || !this.parentElement.contains(target)) {
                this.hide();
            }
        }

        // call Super to reset 'over' state
        this.Super("mouseOut", arguments);
    },
    visibilityChanged : function (isVisible) {
        if (!isVisible && this.parentElement != null) this.parentElement.markForRedraw();
    }
},

// called from a click on the header menu button
headerMenuButtonClick : function () {
    var header = this.header,
        buttonIndex = header.containsEvent() ? header.getMouseOverButtonIndex() : -1;
    if (buttonIndex < 0 && this.frozenHeader) {
        header = this.frozenHeader;
        buttonIndex = header.getMouseOverButtonIndex();
    }
    if (buttonIndex == -1 || !this.headerMenuButton) return;

    var headerButton = header.getMember(buttonIndex),
        menuTop = headerButton.getPageBottom(),
        menuWidth = this._cornerMenu ? this._cornerMenu.getVisibleWidth()
                                     : isc.Menu.getPrototype().defaultWidth,
        headerLeft = headerButton.getPageLeft(),
        headerMenuButtonRight = this.headerMenuButton.getPageRight(),
        menuLeft = this.isRTL() ?
                   Math.min(headerLeft, headerMenuButtonRight - menuWidth) :
                   Math.max(headerLeft, headerMenuButtonRight - menuWidth);
    this.displayHeaderContextMenu(
                this.headerMenuButton,
                [menuLeft,menuTop]
            );
    // unmask the hmb -- if a double click occurs on it we want to auto-fit
    this.headerMenuButton.bringToFront();
},

// called from a double click on the header menu button
headerMenuButtonDoubleClick : function () {
    var header = this.header,
        buttonIndex = header.getMouseOverButtonIndex();
    if (buttonIndex == -1 && this.frozenHeader) {
        header = this.frozenHeader;
        buttonIndex = header.getMouseOverButtonIndex();
    }
    if (buttonIndex == -1) return;

    if (this.frozenFields && header == this.header) {
        // headerDoubleClick expects a master field index, not a localised one
        buttonIndex += this.frozenFields.length;
    }

    // we showed the header menu on click - hide it now
    // otherwise when the field resized it shows up in the wrong place...
    isc.Menu.hideAllMenus();
    
    return this.headerDoubleClick(buttonIndex, header);
},

_showHeaderMenuButton : function (headerButton) {
    var hmb = this.getHeaderMenuButton(headerButton);
    if (hmb.masterElement != null) hmb.masterElement.markForRedraw();
    headerButton.addPeer(hmb);
    hmb.enable();
    
    hmb.addProperties({
        dragTarget: headerButton
    });
    // bringToFront if necessary
    if (headerButton.zIndex > hmb.zIndex) hmb.bringToFront();
    if (!hmb.isVisible()) {
        hmb.show();
    }
    headerButton.markForRedraw();
    return hmb;
},

_hideHeaderMenuButton : function (headerButton) {
    var hmb = this.headerMenuButton;
    if (hmb != null && hmb.isVisible()) {
        var hmbMasterElement = hmb.masterElement;
        if (headerButton == null) headerButton = hmbMasterElement;

        if (hmbMasterElement == headerButton) {
            hmb.hide();
            if (hmbMasterElement != null) hmbMasterElement.markForRedraw();
        }
    }
},

// Header Buttons
// --------------------------------------------------------------------------------------------

_shouldClipHeaderTitle : function (fieldNum) {
    var field = this.fields[fieldNum];
    if (this.autoFitHeaderHeights) return false;

    
    if (field.wrap == true) return false;
    if (field.wrap == null && this.wrapHeaderTitles) return false;

    var shouldAutoFit = this.shouldAutoFitField(field);
    if (shouldAutoFit) {
        var approach = this.getAutoFitWidthApproach(field);

        if (approach == "title" || approach == "both") {
            return false;
        }
    }
    return true;
},

_$titleClipper:"_titleClipper",
_getHeaderTitleClipperID : function (field) {
    if (!field || !field.name) return null;
    return this._getDOMID(field.name + this._$titleClipper);
},

//> @method listGrid.headerTitleClipped() (A)
// Is the field title for the specified field clipped?
//
// @param fieldNum (number) field number for the header button title to test
// @return (boolean) whether the field title for the specified field is clipped
// @see attr:ListGrid.clipHeaderTitles
// @group gridHeader
// @visibility external
//<
headerTitleClipped : function (fieldNum) {
    var field = this.fields[fieldNum],
        titleClipperID = this._getHeaderTitleClipperID(field);
    if (titleClipperID == null) return false;
    var titleClipperHandle = isc.Element.get(titleClipperID);
    if (titleClipperHandle == null) return false;

    
    if (isc.Browser.isChrome ||
        (isc.Browser.isMoz && isc.Browser.version >= 7))
    {
        var range = this.getDocument().createRange();
        range.selectNodeContents(titleClipperHandle);
        var contentsBCR = range.getBoundingClientRect();
        var bcr = titleClipperHandle.getBoundingClientRect();
        return bcr.width < contentsBCR.width;

    } else {
        return isc.Element.getClientWidth(titleClipperHandle) < titleClipperHandle.scrollWidth;
    }
},

//> @method listGrid.getHeaderButtonTitle() (A)
// Given a header button (or column number), returns the title for that header button.
// @group   drawing, gridHeader
// @param   button      (number)
// @return  (string)    HTML for header button contents
// @visibility internal
//<

getHeaderButtonTitle : function (button, clipTitle) {
    var fieldNum = button;
    // passed a header button or field
    if (isc.isA.Object(button)) fieldNum = button.masterIndex;
    else {
        button = this.getFieldHeaderButton(fieldNum);
    }

    var field = this.fields[fieldNum];
    if (!field) return ""; // if field is null, we've shrunk the number of columns, so forget it

    var fieldName = field[this.fieldIdProperty],
        isSortField = this.isSortField(fieldName),
        showSortArrow = (isSortField) &&
                        (!this.showSortArrow || this.showSortArrow == isc.ListGrid.FIELD ||
                         this.showSortArrow == isc.ListGrid.BOTH),
        showSortNumeral = (this.showSortNumerals == false ? false :
            isSortField && this.getSortFieldCount() > 1);

    var sortIndex;
    if (showSortNumeral) {
        var specifier = this.getSortSpecifier(fieldName);
        sortIndex = specifier.sortIndex;
    }

    var title = field.showTitle == false ? "" :
            (field.headerTitle != null ? field.headerTitle : this.getFieldTitle(fieldNum)),
        fullTitle = isc.StringBuffer.create(),
        isRTL = this.isRTL(),
        align = this.getFieldCellAlign(fieldNum, isRTL);

    if (clipTitle == null) clipTitle = this._shouldClipHeaderTitle(fieldNum);

    // If the button is wrapped, then we want to float the sort arrow and sort numeral. The
    // sort numeral should be placed first, then the sort arrow, then the title so that (in text order)
    // the title will be visible, then the sort arrow, and then the sort numeral.
    // Floating the sort arrow fixes the issue that the arrow would wrap with the title text.
    
    if (field.wrap || (field.wrap == null && this.wrapHeaderTitles)) {
        if (showSortNumeral) {
            fullTitle.append("<a style='display:inline-block;",
                             (isRTL ? "float:left;margin-right:" : "float:right;margin-left:"),
                             "4px'>", this.getSortNumeralHTML(fieldName, sortIndex), "</a>");
        }
        if (showSortArrow) {
            fullTitle.append(this.getSortArrowImage(fieldNum, false, false, true));
        }

        fullTitle.append(title);

    } else if (!clipTitle || !this.clipHeaderTitles) {
        fullTitle.append(title);
        if (showSortArrow) fullTitle.append(isc.nbsp, this.getSortArrowImage(fieldNum));
        if (showSortNumeral) {
            fullTitle.append(isc.nbsp, this.getSortNumeralHTML(fieldName, sortIndex));
        }

        // append a spacer after the title text if we're showing the headerMenuButtton for this
        // field. That means that if the title is right-aligned, or if we're auto-fitting the field,
        // we leave space for the headerMenuButton to show without occluding the title.
        if (!clipTitle && button && this.shouldLeaveHeaderMenuButtonSpace(field) &&
            this.shouldShowHeaderMenuButton(button))
        {
            fullTitle.append(isc.Canvas.spacerHTML(this.headerMenuButtonWidth, 1));
        }
    } else {
        fullTitle.append("<div style='display:inline-block;max-width:100%;text-align:", 
            align, ";vertical-align:middle'>");
        var extraRightWidth = 0;
        if (showSortNumeral) {
            
            var sortNumeralHTMLWidth = (sortIndex >= 9 ? 12 : 6);
            extraRightWidth += 4 + sortNumeralHTMLWidth;
            fullTitle.append("<a style='",
                (isRTL ? "float:left;margin-right:" : "float:right;margin-left:"),
                "4px;width:", sortNumeralHTMLWidth, "px;overflow:hidden'>", 
                this.getSortNumeralHTML(fieldName, sortIndex), "</a>")
            ;
        }
        if (showSortArrow) {
            var img = this.getSortArrowImage(fieldNum, true, clipTitle);
            if (img != null) {
                extraRightWidth += 4 + img.width;
                fullTitle.append(this.getSortArrowImage(fieldNum, false, clipTitle));
            }
        }
        fullTitle.append("<div");
        var titleClipperID = this._getHeaderTitleClipperID(field);
        if (titleClipperID != null) {
            fullTitle.append(" id='", titleClipperID, "'");
        }
        fullTitle.append(" style='overflow:hidden;",
            isc.Browser._textOverflowPropertyName, ":ellipsis;white-space:nowrap");
        if (isc.Browser.isMoz) fullTitle.append(isRTL ? ";margin-left:" : ";margin-right:", extraRightWidth, "px");
        fullTitle.append("'>", title, "</div>", "</div>");
    }

    return fullTitle.release(false);
},

shouldLeaveHeaderMenuButtonSpace : function (field) {
    if (field.leaveHeaderMenuButtonSpace != null) return field.leaveHeaderMenuButtonSpace;
    if (this.leaveHeaderMenuButtonSpace != null) return this.leaveHeaderMenuButtonSpace;
    return field.align != "center";
},

_setCheckboxHeaderState : function (state) {
    var fieldNum = this.getCheckboxFieldPosition(),
        field = this.fields[fieldNum];

    // sanity check only - this shouldn't happen if we are showing a checkbox field
    if (!this.isCheckboxField(field)) return;
    // if (field._allSelected == state) return;

    var title = (this.canSelectAll == false || this.selectionType == "single") ? isc.nbsp
                 : this._getCheckboxValueIconHTML(state, false, true, false, field);

    this.setFieldTitle(fieldNum, title);
    field._allSelected = state;
},

updateCheckboxHeaderState : function () {


    
    var data = this.getOriginalData();
    var validData = (isc.isAn.Array(data) || 
                    (isc.isA.ResultSet(data) && data.allMatchingRowsCached()));

    if (validData) {
        var records = this.isGrouped ? this.getAllRecordsFromGroupTree() : data;
        
        var allSelected = true;
        for (var i = 0, recordsLength = records.getLength(); i < recordsLength; ++i) {
            var record = records.get(i);
            if (this.selection._canSelectItem(record) && 
                !this.selection.isSelected(record))
            {
                allSelected = false;
                break;
            }
        }
        this._setCheckboxHeaderState(allSelected);
//    } else {
//        this.logWarn('Not updating header checkbox as data is not "valid data" (contains unloaded rows, etc)');
    }
},

defaultHeaderHoverHTML : function (fieldNum) {

    var field = this.fields[fieldNum];
    if (field == null) return null;
    if (field.prompt != null) return field.prompt;

        
    var showTitle = this.clipHeaderTitles && this.showClippedHeaderTitlesOnHover &&
                    this.headerTitleClipped(fieldNum);
    
    if (showTitle) {
        return field.headerTitle != null ? field.headerTitle
                                     : this.getFieldTitle(fieldNum);
    }
    return null;
},

//> @method listGrid.headerHoverHTML() (A)
// Returns the HTML that is displayed by the default +link{ListGrid.headerHover(),headerHover}
// handler. Return null or an empty string to cancel the hover.
// <smartgwt><p>Use <code>setHeaderHoverFormatter()</code> to provide a custom
// implementation.</smartgwt>
//
// @param fieldNum (number) field number for the header that was hovered
// @param defaultHTML (HTMLString) the HTML that would have been displayed by default
// @return (HTMLString) HTML to be displayed in the hover. If null or an empty string, then the hover
// is canceled.
// @see attr:ListGrid.showClippedHeaderTitlesOnHover
// @see attr:ListGrid.clipHeaderTitles
// @group hovers
// @group gridHeader
// @visibility external
//<
headerHoverHTML : function (fieldNum, defaultHTML) {
    return defaultHTML;
},

//> @attr listGrid.headerHoverStyle (CSSStyleName : null : IRW)
// This property may be set to customize the css style for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverAlign (Alignment : null : IRW)
// This property may be set to customize the alignment for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverVAlign (VerticalAlignment : null : IRW)
// This property may be set to customize the vertical alignment for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverOpacity (Integer : null : IRW)
// This property may be set to customize the opacity for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverHeight (Integer : null : IRW)
// Optional default height for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverWidth (Integer : null : IRW)
// Optional default width for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverWrap (Boolean : null : IRW)
// This property may be set to customize the <code>wrap</code> attribute for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

_showHeaderHover : function (fieldNum, HTML) {
    var field = this.fields[fieldNum];
    if (HTML && !isc.is.emptyString(HTML)) {
        var properties = this._getHeaderHoverProperties(field);
        isc.Hover.show(HTML, properties, (field.hoverRect || this.headerHoverRect));
    } else isc.Hover.clear();
},

_getHeaderHoverProperties : function (field) {
    var props = {};
    if (field) {
        props = isc.addProperties({}, {
            align: (field.hoverAlign != null ? field.hoverAlign : this.headerHoverAlign),
            baseStyle: (field.hoverStyle != null ? field.hoverStyle : this.headerHoverStyle),
            height: (field.hoverHeight != null ? field.hoverHeight : this.headerHoverHeight),
            hoverDelay: (field.headerHoverDelay != null ? field.headerHoverDelay :
                        field.hoverDelay != null ? field.hoverDelay : this.headerHoverDelay),
            moveWithMouse: (field.hoverMoveWithMouse != null ? field.hoverMoveWithMouse :
                        this.headerHoverMoveWithMouse),
            opacity: (field.hoverOpacity != null ? field.hoverOpacity : this.headerHoverOpacity),
            valign: (field.hoverVAlign != null ? field.hoverVAlign : this.headerHoverVAlign),
            width: (field.hoverWidth != null ? field.hoverWidth : this.headerHoverWidth),
            wrap: (field.hoverWrap != null ? field.hoverWrap : this.headerHoverWrap)
        });
    } else {
        props = isc.addProperties({}, {
            align: this.headerHoverAlign,
            baseStyle: this.headerHoverStyle,
            height: this.headerHoverHeight,
            hoverDelay: this.headerHoverDelay,
            moveWithMouse: this.headerHoverMoveWithMouse,
            opacity: this.headerHoverOpacity,
            valign: this.headerHoverVAlign,
            width: this.headerHoverWidth,
            wrap: this.headerHoverWrap
        });
    }

    return props;
},

// _headerClick - maps the local fieldNum within the header to the master index before
// calling the public headerClick method
_headerClick : function (headerFieldNum, header) {
    var fieldNum = header.getMember(headerFieldNum).masterIndex;
    //this.logWarn("click on field: " + headerFieldNum + " in header: " + header +
    //             " maps to field: " + fieldNum);
    return this.headerClick(fieldNum, header);
},

//> @method listGrid.headerClick()  (A)
// Handle a click in the list header.
// <P>
// By default, calls +link{sort()} to sort by the field that was clicked, if
// +link{listGrid.canSort,sorting is enabled}, and calls +link{autoFitField()} if
// +link{canAutoFitFields} is true and +link{headerAutoFitEvent} is set to <code>"click"</code>.
//
// @param fieldNum (number) field number for the header that was clicked
// @group sorting
// @group events
// @group gridHeader
// @visibility external
//<
headerClick : function (fieldNum, header) {
    //>EditMode
    if (this.editingOn && this.editProxy && this.editProxy.headerClick) {
        this.editProxy.headerClick(fieldNum, header);
        return;
    }
    //<EditMode

    // 'onHeaderClick' stringMethod can intercept the header click
    
    if (this.onHeaderClick && (this.onHeaderClick(fieldNum,header) == false)) {
        return;
    }

    var field = this.fields[fieldNum];
    // check if the checkbox column header was clicked
    if (this.isCheckboxField(field) && this.selectionType != "single" && this.canSelectAll != false) {
        if (field._allSelected) {
            this.deselectAllRecords();
            this._setCheckboxHeaderState(false);
        } else {
            this.userSelectAllRecords();
            // Note that due to canSelectRecord() this may not actually select all
            // so call the method to determine whether the checkboxHeaderState should
            // be checked or not.
            this.updateCheckboxHeaderState();
        }
        return false;
    }

    // If canAutoFit is true, autoFit the field on click if headerAutoFitEvent is 'click'
    if (field && this.canAutoFitField(field) && this.headerAutoFitEvent == "click") {
        this.autoFitField(fieldNum);
    }

    // if the list's canSort is false, the field wasn't defined or the field's 'canSort' property is
    // false, return false
    if (!this._canSort(field)) return false;

    var fieldName = field[this.fieldIdProperty],
        specifier = this.isSortField(fieldName) ? this.getSortSpecifier(fieldName) : null,
        EH = isc.EventHandler,
        key = EH.getKey(),
        shiftDown = EH.shiftKeyDown(),
        globalSortDir = this._baseSortDirection,
        sortDir = field.sortDirection
    ;

    if (shiftDown && this._canMultiSort() && this._canSortData(field)) {
        // add this field to the sort-configuration, or alter it if it's already sorted
        if (this.isSortField(fieldName)) {
            if (sortDir == globalSortDir || this.canUnsort == false) {
                // reverse the sort-direction of this field
                this.toggleSort(fieldName);
            } else {
                // unsort the field - if this is the only sorted field, or the last field in
                // a multiSort arrangement, no visual resort will occur - otherwise, a visual
                // resort occurs to reapply remaining sort-specifiers
                this.toggleSort(fieldName, "unsort");
            }
        } else {
            // add this field to the sort-configuration
            this._addSort(field);
        }
    } else {
        if (this.isSortField(fieldName) && this.getSortFieldCount() == 1) {
            if (sortDir == globalSortDir || this.canUnsort == false) {
                // toggle the sortDirection on this field
                this.toggleSort(fieldName);
            } else {
                // unsort this field
                this.toggleSort(fieldName, "unsort");
            }
        } else {
            var fieldSortDir = this._getFieldSortDirection(field);
            this.setSort([{
                property: fieldName,
                direction: fieldSortDir
            }]);
        }
    }

    // return false to stop further event processing
    // if we don't do this, clicks in the header will sometimes select items in the list
    return false;
},

// _headerDoubleClick - maps the local fieldNum within the header to the master index before
// calling the public headerDoubleClick method
_headerDoubleClick : function (headerFieldNum, header) {
    if (this.data && this.data.lengthIsKnown && !this.data.lengthIsKnown()) {
        // we only want to run auto-sizing code if the data has already arrived - bail now
        // and set a flag to have dataArrived re-run do the auto-sizing
        this._autoSizeOnDataArrived = true;
        this._autoSizeHeaderFieldNum = headerFieldNum;
        this._autoSizeHeader = header;
        return;
    }
    return this.headerMenuButtonDoubleClick();
},



//> @method listGrid.headerDoubleClick()    (A)
// Handle a double click in the list header.
// <P>
// By default, calls +link{autoFitField()} if +link{canAutoFitFields} is true and
// +link{headerAutoFitEvent} is <code>"doubleClick"</code>.
//
// @param fieldNum (number) field number for the header that was clicked
// @group events
// @group gridHeader
// @visibility external
//<
headerDoubleClick : function (fieldNum, header) {

    var field = this.fields[fieldNum];
    if (this.isCheckboxField(field)) return;

    // If canAutoFit is true, autoFit the field on click if headerAutoFitEvent is 'doubleClick'
    if (field && this.canAutoFitField(field) && this.headerAutoFitEvent == "doubleClick") {
        this.autoFitField(fieldNum);
    }

    // return false to stop further event processing
    return false;
},

// Field Drag Resize
// --------------------------------------------------------------------------------------------

//> @method listGrid.fieldDragResizeStart() (A)
// Event sent when header column starts drag-resizing.
// <p>
// Current implementation creates a drag line and sizes it to the height of the list body.
// <p>
// Observed from this.header.dragResizeStart()
//
//      @group  dragging
//<
fieldDragResizeStart : function () {
    this._dragResizingField = true;
    // Turn off the logic that expands one field to fill the viewport if autoFitFields is
    // enabled
    
    this.autoFitFieldsFillViewport = false;
    // make sure the drag line is set up
    this.makeDragLine();

    // and resize it to cover the entire height of the listGrid
    this._dragLine.resizeTo(2,
         this.getVisibleHeight() - (this.body.hscrollOn ? this.body.getScrollbarSize() : 0));

    // set the overflow of the header being dragged to hidden so that the user can clip the title
    // text if he chooses.
    var dt = this.ns.EH.dragTarget;

    // ensure we no longer attempt to autoFit
    var field = this.getField(dt.masterIndex);
    if (field) {
        field.autoFitWidth = false;
        
        var wrap = field.wrap;
        if (wrap == null) wrap = this.wrapHeaderTitles;
        if (wrap != dt.wrap) {
            dt.setWrap(wrap);
        }
    }

    dt.setWidth(dt.getVisibleWidth());
    dt.setOverflow("hidden");
},

//> @method listGrid.fieldDragResizeMove()  (A)
//      Event sent when header column is drag-resizing.
//
//      Current implementation moves the dragLine to show the new boundary.
//
//      Observed from this.header.dragResizeMove()
//      @group  dragging, drawing
//<
fieldDragResizeMove : function () {
    var EH = this.ns.EH,
        resizingField = EH.dragTarget;

    if (this.autoSizeHeaderSpans != null) {
        this._autoSizeHeaderSpans = this.autoSizeHeaderSpans;
        this.autoSizeHeaderSpans = false;
    }

    // move the drag line to show the new field boundary
    var colNum = this.header._resizePosition;
    this.showDragLineForField(colNum);
    // if we're supposed to resize fields as they're dragging
    if (this.resizeFieldsInRealTime) {
        this.realtimeFieldResize(colNum);

    }

    // make sure that the header menu button snapOffsetLeft is 0 to prevent the user from
    // seeing an offset if the column is narrowed to the point where an offset is unnecessary.
    if (this.headerMenuButton && this.headerMenuButton.snapOffsetLeft != 0) {
        this.headerMenuButton.setSnapOffsetLeft(0);
    }
},

realtimeFieldResize : function (colNum) {

    // change the width of the field and redraw
    var EH = isc.EH,
        width = EH.dragResizeWidth,
        minWidth = this.getMinFieldWidth(this.fields[colNum], true);
    // Disallow shrinking below minWidth
    if (width < minWidth) width = minWidth;

    this._fieldWidths[colNum] = width;

    

    // Ensure the body's h-scroll position is synced with that of the header before
    // resizing body fields
    
    if (this._delayingBodyScrolling) {
        this.syncBodyScrolling();
    }


    this._settingBodyFieldWidths = true;
    this.setBodyFieldWidths(this._fieldWidths);
    // While resizing fields in real time we want the body's incremental rendering system
    // to use the 'quick' draw ahead ratio.
    this.body.useQuickDrawAheadRatio = true;
    this.body.redraw("fieldDragResize");
    delete this.body.useQuickDrawAheadRatio;
    delete this._settingBodyFieldWidths;

    // if we're scrolled, as the body shrinks it's scroll position may become invalid,
    // so it scrolls back, and the header needs to match
    
    if (!this.isRTL()) {
        var bodyScrollLeft = this.body.getScrollLeft();
        if (bodyScrollLeft > 0) {
            this.header.scrollTo(bodyScrollLeft, null, "headerResize");
        }

    
    } else {
        if (this.header.getScrollLeft() < this.header.getLeft()) {
            this.header.scrollTo(this.header.getLeft());
        }
    }
},

//> @method listGrid.fieldDragResizeStop()  (A)
//      Event sent when header column is done drag-resizing.
//
//      Current implementation hides the dragLine.
//
//      Observed from this.header.dragResizeStop()
//      @group  dragging, drawing
//<
fieldDragResizeStop : function () {
    if (this._autoSizeHeaderSpans != null) {
        this.autoSizeHeaderSpans = this._autoSizeHeaderSpans;
        delete this._autoSizeHeaderSpans;
    }

    this.hideDragLine();
},



// Reorder / Resize Field APIs
// --------------------------------------------------------------------------------------------

headerDragReordered : function (fieldNum, moveToPosition, header) {
    var masterFieldNum = header.getMember(fieldNum).masterIndex,
        masterMoveToPosition = header.getMember(moveToPosition).masterIndex;
    //this.logWarn("reorder of header field from " + fieldNum +
    //             " to " + moveToPosition + " on header: " + header +
    //             " will move master field from " + masterFieldNum +
    //             " to : " + masterMoveToPosition);
    this.reorderField(masterFieldNum, masterMoveToPosition);
},

//> @method listGrid.reorderField() (A)
// Reorder a particular field
//
// @param   fieldNum        (number)    Number of the field to reorder
// @param   moveToPosition  (number)    New position for that field
//
// @visibility external
//<
reorderField : function (fieldNum, moveToPosition) {
    this.reorderFields(fieldNum, fieldNum+1, moveToPosition - fieldNum);
},

//> @method listGrid.reorderFields()    (A)
// Reorder a set of adjacent fields, from start to end exclusive at the end, by distance
// moveDelta.<br><br>
//
// NOTE: start and end coordinates are in terms of the currently visible fields, not the full set of
// fields.
//
// @param    start     (number) Start of the range of fields to move, inclusive
// @param    end       (number) End of the range of fields to move, non-inclusive
// @param    moveDelta (number) Distance to move by
//
// @visibility external
//<
reorderFields : function (start, end, moveDelta) {

    // Note this method is public and can be called programmatically - avoid crashing
    // if various things that get set up on draw, such as _fieldWidths or filterEditor aren't
    // yet present.

    // reorder the fields in the filterEditor if showing
    
    if (this.showFilterEditor && this.filterEditor != null) {
        this.filterEditor.reorderFields(start, end, moveDelta);
    }

    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow.reorderFields(start,end,moveDelta);
    }

    var startField = this.fields[start],
        endField = this.fields[end -1],
        targetIndex = start + moveDelta,
        targetField = this.fields[targetIndex];


    // preserve the sorted field
    var sortFieldNum = this._getSortFieldNum(),
        sortField = this.fields[sortFieldNum];
    // reorder the field widths for the moved field range
    if (this._fieldWidths != null) this._fieldWidths.slideRange(start, end, start+moveDelta);


    // update this.completeFields, rather than this.fields.
    // Note that we may have hidden fields, so we have to recalculate start, end and target.
    if (this.completeFields == null) this.setFields(this.fields);
    if (this.completeFields.contains(targetField)) {
        var cfStart = this.completeFields.indexOf(startField),
            cfEnd = this.completeFields.indexOf(endField) + 1,
            cfTargetIndex = this.completeFields.indexOf(targetField);
        //this.logWarn("start, end, targetIndex of: " + [start,end,targetIndex] +
        //             " translated to: " + [cfStart, cfEnd, cfTargetIndex] +
        //             " fields: " + this.completeFields.getProperty("name"));
        this.completeFields.slideRange(cfStart, cfEnd, cfTargetIndex);
        //this.logWarn("after slideRange, fields: " +
        //             this.completeFields.getProperty("name"));
    }

    // set the visibleFields based on newly reordered complete set of fields
    this.deriveVisibleFields();

    // update the sortFieldNum to reflect the slide
    if (sortFieldNum != null) {
        sortFieldNum = this.fields.indexOf(sortField);
        // field no longer visible
        if (sortFieldNum == -1) sortFieldNum = null;
        this._setSortFieldNum(sortFieldNum);
    }

    // find the header for this field
    var header;

    if (!this.frozenFields) {
        header = this.getFieldHeader(start);
        // reorder the header items
        if (header) {
            header.reorderItems(this.getLocalFieldNum(start), this.getLocalFieldNum(end),
                                this.getLocalFieldNum(start+moveDelta));
        }

    } else {
        // for frozen fields, just rebuild for freeze
        
        header = this.getFieldHeader(start);
        this.rebuildForFreeze();
        // re-sync the header with the current position of the body
        this.syncHeaderScrolling(this.body.getScrollLeft());
    }

    // tell that toolbar button to show the sort
    if (sortFieldNum != null && header && this.selectHeaderOnSort) {
        this.selectSortFieldHeaderButton();
    }

    // if necessary, preserve the edit field
    var editorShowing = this._editorShowing;
    if (editorShowing) {
        // If the editor is showing, we will need to update the editForm in 2 ways:
        // - the colNum property for each item must be updated
        // - the form items should be reordered so the items are in order wrt to the new
        //   field order.
        // When this has been accomplished, we can rely on the body redraw to handle writing
        // out the appropriate HTML, setting the values of the form items, and updating focus
        // if required.
        var editForm = this._editRowForm,
            editRowNum = this.getEditRow(),
            editField = this.getEditField(),
            newItemsArray = []
        for (var i = 0; i < editForm.items.length; i++) {
            var item = editForm.items[i];
            item.colNum = this.fields.findIndex(this.fieldIdProperty, item.getFieldName());
            for (var j = 0; j <= newItemsArray.length; j++) {
                if (newItemsArray[j] == null || newItemsArray[j].colNum > item.colNum) {
                    newItemsArray.addAt(item, j);
                    break;
                }
            }
        }

        // Update the items array to match the reordered version of itself
        editForm.items.setArray(newItemsArray);
        // Update the 'editColNum' to reflect the repositioned edit field.
        this._editColNum = this.fields.indexOf(editField);
    }

    // We want to remap embedded components to catch the cell change
    // for any components embedded by cell.
    // Note we don't expect a simple reorder of fields to impact frozen/unfrozen
    // state so we need to update either the frozen or unfrozen body embedded
    // columns only
    var body = this.body;
    if (this.frozenFields && start < this.frozenFields.length) {
        body = this.frozenBody;
    }

    if (body) {
        // this may not all be necessary if we rebuilt for freeze.
        this.body.fields = this.normalFields || this.fields;
        if (this.frozenBody) this.frozenBody.fields = this.frozenFields;

        // give the bodies the reordered field widths
        this.setBodyFieldWidths(this._fieldWidths);

        if (body._embeddedComponents != null) {
            this._remapEmbeddedComponentColumns(body);
        }

        // redraw (may be required if fields had matching widths)
        if (!body.isDirty()) this._markBodyForRedraw("reorderFields");
    }

    this.handleFieldStateChanged();
},

// Ensure that the .colNum property is up to date on our editors

remapEditFieldsForFreeze : function () {
    if (this._editorShowing) {
        var form = this.getEditForm(),
            items = form.getItems();
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            item.colNum = this.fields.findIndex(this.fieldIdProperty, item.getFieldName());
            var field = this.fields[item.colNum];

            if (!this._suppressedFrozenFields && field.frozen) item.containerWidget = this.frozenBody;
            else item.containerWidget = this.body;
        }
    }
},

headerDragResized : function (fieldNum, newWidth, header) {
    var masterFieldNum = header.getMember(fieldNum).masterIndex;
    //this.logWarn("resize of header field: " + fieldNum + " on header: " + header +
    //             " will resize master fieldNum: " + masterFieldNum);

    // Once the user has drag resized a field in the grid, we'll reflow to 
    // accommodate the new size.
    // Temporarily suppress *all* dynamic sizing for any fields.
    // In other words, don't reflow "*"/"%" sized fields, or autoFit fields.
    // This means if autoFitHeaderHeights is true, and the horizontal resize of
    // a header changed wrapping, we may end up changing the height of the
    // header as a whole. We don't want the toolbar to then jarringly rerun layout
    // policy logic and change things from your dragged size(s).
    // However make this temporary! If the widget as a whole resizes subsequently,
    // we want the "*" etc sizes to be recalculated
    
    for (var i = 0; i < this.fields.length; i++) {
        if (i == masterFieldNum) continue;
        this.fields[i]._origWidth = this.fields[i].width;
        this.fields[i]._origAutoFit = this.fields[i].autoFitWidth
        this.fields[i].width = this.getFieldWidth(i);
        this.fields[i].autoFitWidth = false;
        var button = this.getFieldHeaderButton(i);
        if (button) {
            button._prevUserWidth = button._userWidth;
            button._userWidth = this.fields[i].width;
        }
    }
    this.resizeField(masterFieldNum, newWidth, true);
    // Reset dynamic sizes ("*", "n%", etc) so subsequent reflows will respect them.
    for (var i = 0; i < this.fields.length; i++) {

        if (i == masterFieldNum) continue;

        this.fields[i].width = this.fields[i]._origWidth;
        delete this.fields[i]._origWidth;

        this.fields[i].autoFitWidth = this.fields[i]._origAutoFit
        delete this.fields[i]._origAutoFit;

        var button = this.getFieldHeaderButton(i);
        if (button) {
            button._userWidth = button._prevUserWidth;
            delete button._prevUserWidth;
        }
    }

    // clear the _dragResizingField flag set up on drag start and ensure scrolling is
    // all in sync
    this._dragResizingField = false;
    var left = this.body.getScrollLeft();
    this.syncHeaderScrolling(left, top);
    this.syncFilterEditorScrolling(left, top);
    this.syncSummaryRowScrolling(left,top);



},

//> @method ListGrid.setCanResizeFields()
// Setter method for updating +link{ListGrid.canResizeFields} at runtime.
// @param canResize (boolean) new value for this.canResizeFields
// @visibility external
//<
setCanResizeFields : function (canResize) {
    if (this.canResizeFields == canResize) return;
    this.canResizeFields = canResize;
    if(canResize==false) this.canAutoFitFields=false;
    if (this.header) this.header.setCanResizeItems(canResize);
    if (this.frozenHeader) this.frozenHeader.setCanResizeItems(canResize);
    if (this.headerMenuButton) this.headerMenuButton.canDragResize = canResize;
    if (canResize) {
        if (this.header && !this.header.dontObserve) this._observeHeaderResize(this.header);
        if (this.frozenHeader && !this.frozenHeader.dontObserve)
            this._observeHeaderResize(this.frozenHeader);
    } else {
        if (this.header) this._ignoreHeaderResize(this.header);
        if (this.frozenHeader) this._ignoreHeaderResize(this.frozenHeader);
    }
},

_observeHeaderResize : function (header) {
    this.observe(header, "itemDragResized", function (itemNum, newSize) {
        this.headerDragResized(itemNum, newSize, header);
    });
    this.observe(header, "dragResizeMemberStart", function () { this.fieldDragResizeStart(); });
    this.observe(header, "dragResizeMemberMove", function () { this.fieldDragResizeMove(); });
    this.observe(header, "dragResizeMemberStop", function () { this.fieldDragResizeStop(); });
},

_ignoreHeaderResize : function (header) {
    if (this.isObserving(header, "itemDragResized"))
        this.ignore(header,"itemDragResized");
    if (this.isObserving(header, "dragResizeMemberStart"))
        this.ignore(header, "dragResizeMemberStart");
    if (this.isObserving(header, "dragResizeMemberMove"))
        this.ignore(header, "dragResizeMemberMove");
    if (this.isObserving(header, "dragResizeMemberStop"))
        this.ignore(header, "dragResizeMemberStop");
},

//> @method listGrid.resizeField()  (A)
// Resize a particular field to a new width. Note that this method
// will also set +link{listGridField.autoFitWidth} to false if it was previously true.
//
// @param   fieldNum    (number)    Number of the field to resize
// @param   newWidth    (number)    New width of the field
//
// @visibility external
//<
// @param storeWidth (boolean) Additional internal parameter - should we update field.width?
//  Updating field.width means if setFields() is called after init with an overlapping set
//  of field objects (typical use case: showing / hiding fields) - we retain the width set here.
//  Otherwise we resize the field but don't store the new width value
resizeField : function (fieldNum, newWidth, storeWidth) {
    this._resizeFields([fieldNum], [newWidth], [storeWidth]);
},
_resizeFields : function (fieldNums, newWidths, storeWidths) {
    for (var i = 0; i < fieldNums.length; i++) {
        var fieldNum = fieldNums[i];
        if (!isc.isA.Number(fieldNum)) fieldNum = this.getFieldNum(fieldNum);
        if (fieldNum == -1) {
            fieldNums.removeAt(i);
            newWidths.removeAt(i);
            storeWidths.removeAt(i);
            i--;
        } else {
            // store the normalized value in case we were passed a name
            fieldNums[i] = fieldNum;

            var minWidth = this.getMinFieldWidth(this.fields[fieldNum], true);
            if (minWidth > newWidths[i]) {
                newWidths[i] = minWidth;
            }
        }
    }
    if (fieldNums.length == 0) return;

    // adjust the header for this field, if we have a header
    var adjustHeader = this.header && this.header.isDrawn();
    if (adjustHeader) {
        // Suppress instant relayout of the header for each field we resize
        
        var instantRelayout = this.header.instantRelayout,
            frozenInstantRelayout = this.frozenHeader ? this.frozenHeader.instantRelayout
                                                        : null;
        this.header.instantRelayout = false;
        if (this.frozenHeader) this.frozenHeader.instantRelayout = false;
    }

    // This flag prevents headerButtonResized from attempting to reflow the header, etc
    // to the resize.
    
    this._settingHeaderFieldWidths = true;
    for (var i = 0; i < fieldNums.length; i++) {
        var fieldNum = fieldNums[i],
            newWidth = newWidths[i];
        if (adjustHeader) {
            var header = this.getFieldHeader(fieldNum),
                headerFieldNum = this.getLocalFieldNum(fieldNum);

            
            header.getMember(headerFieldNum).setOverflow("hidden");
            header.getMember(headerFieldNum).setWidth(newWidth);
        }

        var storeWidth = storeWidths[i];
        if (storeWidth == null || storeWidth) {
            this.fields[fieldNum].width = newWidth;
            this.fields[fieldNum].autoFitWidth = false;
        }

        // update the body column widths
        if (this._fieldWidths != null) {
            this._fieldWidths[fieldNum] = newWidth;
        }
    }
    delete this._settingFieldWidths;

    if (adjustHeader) {

        this.header.instantRelayout = instantRelayout;
        this.header.reflowNow("resized headers");
        if (this.frozenHeader) {
            this.frozenHeader.instantRelayout = frozenInstantRelayout;
            this.frozenHeader.reflowNow("resized headers");
        }
    }


    // don't crash if not drawn
    if (!this.isDrawn()) return;

    this._settingBodyFieldWidths = true;
    this.setBodyFieldWidths(this._fieldWidths);
    


    // force an immediate redraw of the body - this will enable us to check the
    // _settingBodyFieldWidths flag in updateFieldWidths
    
    if (this.body.isDirty()) {
        this.body.redraw("setting body field widths");
    }
    delete this._settingBodyFieldWidths;

    // Field widths can effect rendered heights of titles due to wrapping/reflow
    // if we're autoFitting to header heights we may need to recalculate now.
    
    if (!this._autoFittingFields && this.header && this.autoFitHeaderHeights) {
        this.dropCachedHeaderButtonHeights();
        this._updateHeaderHeight();
    }
    if (this.isRTL() && this.header != null) {
        this.syncBodyScrolling();
    }

    if (this.showFilterEditor && this.filterEditor) {
        this.filterEditor._resizeFields(fieldNums, newWidths, storeWidths);
    }
    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow._resizeFields(fieldNums, newWidths, storeWidths);
    }

    this.handleFieldStateChanged(true);
},

// Sorter (corner button)
// --------------------------------------------------------------------------------------------

// should we draw the corner sort button in the header?
_showSortButton : function () {
    var showSort = this.showSortArrow;
    if (showSort != null) {
        return (showSort == isc.ListGrid.CORNER || showSort == isc.ListGrid.BOTH);
    }
    // If we haven't been explicitly set to show the corner sort button, show it if we're
    // leaving a gap for the scrollbar.
    return this._shouldLeaveScrollbarGap();
},

// predictScrollbarGap - internal but non obfuscated flag - if true, when leaveScrollbarGap is false
// we predict whether the body will show a vertical scrollbar based on cellHeight and number of
// rows.
// This allows us to render the body at the appropriate width to accommodate a vertical scrollbar
// rather than waiting for the vertical scrollbar to be rendered (which may also introduce a
// horizontal scrollbar), then resizing.
predictScrollbarGap:true,

_shouldLeaveScrollbarGap : function (vscrollOn) {
    var verticalAutoFit = (this.autoFitData == isc.Canvas.VERTICAL || this.autoFitData == isc.Canvas.BOTH);
    if (this.leaveScrollbarGap && !verticalAutoFit) return true;
    if (!this.body || this.isEmpty()) return false;
    
    if (vscrollOn == null) vscrollOn = this.body.vscrollOn;
    if (vscrollOn) return true;

    var body = this.body,
        
        headerHeight = this.getHeaderHeight(),
        
        bodyHeight = this.getInnerHeight() - this.body.getVMarginBorder() -
                        (this.showHeader ? headerHeight : 0);

    // exception case - when we're auto-fitting to content the body will be allowed to expand
    if (verticalAutoFit) {
        bodyHeight = (this.getTotalRows() * this.cellHeight);
        var maxHeight = this.getAutoFitMaxBodyHeight();
        if (maxHeight && maxHeight < bodyHeight) {
            bodyHeight = maxHeight;
        }
        if (this.autoFitMaxRows && (this.autoFitMaxRows * this.cellHeight) > bodyHeight) {
            bodyHeight = (this.autoFitMaxRows * this.cellHeight);
        }
    }
    //this.logWarn("predicting gap: bodyHeight: " + bodyHeight +
    //             ", rows: " + this.getTotalRows() +
    //             ", rowsHeight: " + (this.getTotalRows() * this.cellHeight))

    
    if (bodyHeight <= 0) return false;

    return this.predictScrollbarGap && this.bodyOverflow == isc.Canvas.AUTO &&
           (this.getTotalRows() * this.cellHeight > bodyHeight);
},

// The sorter is implemented as a child (not a member) that we float at the right edge of the
// header (Which we size small enough to accommodate it).

getSorterTop : function () {
    
    return (this.headerLayout || this.header).getTop();
},
getSorterLeft : function () {
    if (this.isRTL()) {
        return this.getLeftMargin() + this.getLeftBorderSize() + this.getLeftPadding();;
    } else {
        // clamp the sorter to the right of the header (or header-layout)
        var headerLayout = (this.headerLayout || this.header);
        var left = headerLayout.getWidth() + headerLayout.getLeft() - this._getSorterWidth();
        if (this._shouldLeaveScrollbarGap()) {
            left += this.body != null ? this.body.getScrollbarSize() : this.getScrollbarSize();
        }
        return left;
    }
},

_getSorterWidth : function (recompute) {
    var sorter = this.sorter;
    if (recompute || sorter == null) {
        var scrollbarSize = this.body != null ? this.body.getScrollbarSize() : this.getScrollbarSize(),
            sorterWidth;
        if (scrollbarSize <= 0) sorterWidth = 16;
        else sorterWidth = Math.max(5, scrollbarSize);
        return sorterWidth;
    } else {
        return sorter.getWidth();
    }
},

//> @method listGrid.makeCornerSortButton() (A)
// Make the sorter button
// @group drawing
//<
makeCornerSortButton : function () {
    

    this.sorter = this.createAutoChild("sorter",
        isc.addProperties(this.getButtonProperties(),
            // Explicitly lay sorterDefaults on top of the buttonProperties.
            // If we didn't do this, sorterDefaults would be picked up as defaults but would
            // be overridden by the standard button properties, which means headerDefaults
            // would override sorterDefaults for the button
            this.sorterDefaults,
            {
                ID:this.getID()+"_sorter",
                width:this._getSorterWidth(),
                height:this.getHeaderHeight(),
                
                backgroundColor:this.headerBackgroundColor,
                imgDir:this.widgetImgDir,
                visibility:(this._showSortButton() ? isc.Canvas.INHERIT : isc.Canvas.HIDDEN),
                ariaState: { label: this.sorterButtonTitle }
            }
        )
    );
    this.addChild(this.sorter, "sorter", false);
},

//> @method listGrid.sorterContextClick() (A)
// Notification method fired when the user right-clicks on the corner
// +link{listGrid.sorterConstructor, sort button}.  Return false to suppress the default
// behavior of showing the sorter's context menu.
//
// @return (boolean) return false to suppress the context menu
// @group events, sorting
// @visibility external
//<

_sorterContextClick : function () {
    // Returning false from sorterContextClick suppresses both the
    // custom context menu and the native context menu
    
    if (this.sorterContextClick && !this.sorterContextClick()) return false;

    var showContextMenu = this.showHeaderContextMenu;
    //>!BackCompat 2007.02.02
    // If the old showCornerContextMenu attr is defined, have it take precedence
    if (this.showCornerContextMenu != null) showContextMenu = this.showCornerContextMenu;
    //<!BackCompat
    if (showContextMenu) return this.displayHeaderContextMenu(this.sorter);
},

// if the header context menu is enabled, also show it on the headerBar
headerBarContextClick : function (header) {
    var showContextMenu = this.showHeaderContextMenu;
    //>!BackCompat 2007.02.02
    // If the old showCornerContextMenu attr is defined, have it take precedence
    if (this.showCornerContextMenu != null) showContextMenu = this.showCornerContextMenu;
    //<!BackCompat
    if (showContextMenu && (isc.EH.isKeyEvent() || header.containsEvent())) {
        var index = isc.EH.isKeyEvent() ? header.getFocusButtonIndex() :
                                          header.getMouseOverButtonIndex();
        return this.displayHeaderContextMenu(header.getMember(index));
    }
},

headerSpanContextClick : function (span) {
    var menuItems = this.getHeaderSpanContextMenuItems(span);
    if (!menuItems || menuItems.length == 0) return false;
    if (!this.spanContextMenu) {
        this.spanContextMenu = this.createAutoChild(
            "spanContextMenu",
            {
                items: menuItems,
                autoFitFieldWidths: true
            },
            this.getMenuConstructor());
    } else {
       this.spanContextMenu.setItems(menuItems);
    }
    this.spanContextMenu.showContextMenu();
    return false;
},


//> @method ListGrid.displayHeaderContextMenu()
// If +link{attr:listGrid.showHeaderContextMenu} is <code>true</code> this method is fired
// when the user right-clicks on the header for this grid.<br>
// Default implementation will display a menu with entries derived from
// +link{listGrid.getHeaderContextMenuItems()} for the appropriate column.
// @param target (Canvas) which button in the header received the right-click event
//                        (may be the sorter button or header menu button)
// @param [position] (Array) Optional 2-element array specifying position at which the menu should
//                           be shown. If this is not passed in the menu will be shown at the
//                           mouseEvent position (default context menu behavior).
// @visibility external
// @group gridHeader
// @see listGrid.showHeaderContextMenu
//<
displayHeaderContextMenu : function (headerButton, position) {
    // headerButton will be null when contextClick appears on header background
    if (!headerButton) return;
    // don't display a header context menu for the checkbox column
    var field = this.fields[headerButton.masterIndex];
    if (field && field.showDefaultContextMenu == false) return false;
    // Determine the items to show
    var items = this.getHeaderContextMenuItems(headerButton.masterIndex);
    // If there are no items don't show the menu
    if (items.length == 0) return;

    if (!this._cornerMenu) this._cornerMenu = this.getHeaderContextMenu(headerButton);
    this._cornerMenu.setData(items);
    this._showingHeaderContextMenu = true;
    if (position != null && position.length > 0) {
        var cornerMenu = this._cornerMenu;
        cornerMenu.target = headerButton;
        cornerMenu = cornerMenu._navStackContainer || cornerMenu._navStack || cornerMenu;
        cornerMenu.setVisibility("hidden");
        if (cornerMenu !== this._cornerMenu) {
            if (!cornerMenu.isDrawn()) cornerMenu.draw();
        } else {
            cornerMenu.moveTo(0, 0);
            if (!cornerMenu.isDrawn()) {
                cornerMenu.draw();
            } else {
                cornerMenu.redraw();
            }
            cornerMenu.placeNear(position[0], position[1]);
        }
        this._cornerMenu.show();
        return false;
    } else {
        return this._cornerMenu.showContextMenu(headerButton);
    }
},



//> @attr ListGrid.sortFieldAscendingText (string : "Sort Ascending" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, this
// attribute will be shown as the menu item title to sort a field in ascending order.
// @group i18nMessages
// @visibility external
//<
sortFieldAscendingText: "Sort Ascending",

//> @attr ListGrid.sortFieldDescendingText (string : "Sort Descending" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, this
// attribute will be shown as the menu item title to sort a field in descending order.
// @group i18nMessages
// @visibility external
//<
sortFieldDescendingText: "Sort Descending",

//> @attr ListGrid.clearSortFieldText (string : "Clear Sort" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, this
// attribute will be shown as the menu item title to clear an existing sort on this field.
// @group i18nMessages
// @visibility external
//<
clearSortFieldText: "Clear Sort",

//> @attr ListGrid.clearAllSortingText (string : "Clear All Sorting" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, this
// attribute will be shown as the menu item title to clear any existing sort on all fields.  This
// menu-item is displayed only in the context menu for the sorter button.
// @group i18nMessages
// @visibility external
//<
clearAllSortingText: "Clear All Sorting",

//> @attr ListGrid.clearFilterText (string : "Clear Filter" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and a +link{listGrid.showFilterEditor, filter-editor} is visible, this
// attribute will be shown as the menu item title to clear any existing filter.  This
// menu-item is displayed only in the context menu for the sorter button.
// @group i18nMessages
// @visibility external
//<
clearFilterText: "Clear Filter",

//> @attr ListGrid.configureSortText (string : "Configure Sort..." : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and multi-sorting is enabled, this attribute is used as the title for a menu item that opens
// a +link{class:MultiSortDialog} to configure the sort-specification for this grid.  This
// menu-item is displayed only in the context menu for the sorter button.
// @group i18nMessages
// @visibility external
//<
configureSortText: "Configure Sort...",

//> @attr ListGrid.configureGroupingText (string : "Configure Grouping..." : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and multi-grouping is enabled, this attribute is used as the title for a menu item that opens
// a +link{class:MultiGroupDialog} to configure the grouping for this grid.
//
// @group i18nMessages
// @visibility external
//<
configureGroupingText: "Configure Grouping...",

//> @attr ListGrid.autoFitFieldText (string : "Auto Fit" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and user-driven auto fit of fields is enabled via +link{listGridField.canAutoFitWidth} or 
// +link{listGrid.canAutoFitFields}, this attribute will be shown as the menu
// item title for an item to perform a one-time autoFit of the field to its title or content
// via a call to +link{listGrid.autoFitField()}.
// @group i18nMessages
// @group autoFitFields
// @visibility external
//<
autoFitFieldText: "Auto Fit",

//> @attr ListGrid.autoFitAllText (string : "Auto Fit All Columns" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and +link{listGrid.canAutoFitFields} is true, this attribute will be shown as the menu
// item title for an item to perform a one-time autoFit of all visible fields via
// the +link{listGrid.autoFitField()} method.
// @group i18nMessages
// @group autoFitFields
// @visibility external
//<
autoFitAllText: "Auto Fit All Columns",

//> @attr ListGrid.fieldVisibilitySubmenuTitle (string : "Columns" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, and
// +link{listGrid.canPickFields,this.canPickFields} is true, this
// attribute will be shown as the title for the menu item which contains a submenu with items
// allowing the user to show and hide fields in the grid.
// @group i18nMessages
// @visibility external
//<
fieldVisibilitySubmenuTitle: "Columns",

//> @attr listGrid.freezeFieldText (HTMLString : "Freeze ${title}" : IRWA)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canFreezeFields,this.canFreezeFields} is true, this string will be shown as the
// title for the menu item to freeze a currently unfrozen field.
// <P>
// This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code
// when the message is displayed, with <code>title</code> available as a variable containing
// the field title.
// <P>
// Default value returns "Freeze " + the field's summary title.
// @group i18nMessages
// @visibility external
//<
freezeFieldText:"Freeze ${title}",

//> @attr listGrid.unfreezeFieldText (HTMLString : "Unfreeze ${title}" : IRWA)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canFreezeFields,this.canFreezeFields} is true, this string will be shown as the
// title for the menu item to unfreeze a currently frozen field.
// <P>
// This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code
// when the message is displayed, with <code>title</code> available as a variable containing
// the field title.
// <P>
// Default value returns "Unfreeze " + the field's summary title.
// @group i18nMessages
// @visibility external
//<
unfreezeFieldText:"Unfreeze ${title}",

//> @method listGrid.getToggleFreezeText()
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canFreezeFields,this.canFreezeFields} is true, this string will be shown as the
// title for the menu item to toggle whether a field is frozen or unfrozen.
// <P>
// Default implementation evaluates and returns +link{ListGrid.freezeFieldText} or
// +link{ListGrid.unfreezeFieldText} depending on whether the field is currently frozen.
// @param field (ListGridField) field to get the menu item title for
// @return (HTMLString) Title to show in the menu item
// @group i18nMessages
// @visibility external
//<
getToggleFreezeText : function (field, span) {
    var messageArgs = {
        viewer:this,
        title: span ? span.title : this.getSummaryTitle(field)
    };
    return (!this._suppressedFrozenFields && field.frozen)
            ? this.unfreezeFieldText.evalDynamicString(this, messageArgs)
            : this.freezeFieldText.evalDynamicString(this, messageArgs);
},

//> @attr listGrid.groupByText (HTMLString : "Group by ${title}" : IRWA)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canGroupBy,this.canGroupBy} is true, this string will be shown as the
// title for the menu item to toggle the group by setting for a field.
// <P>
// This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code
// when the message is displayed, with <code>title</code> available as a variable containing
// the field title.
// <P>
// Default value returns "Group by " + the field's summary title.
// @group i18nMessages
// @visibility external
//<
groupByText : "Group by ${title}",

//> @method listGrid.getGroupByText()
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canGroupBy,this.canGroupBy} is true, this string will be shown as the
// title for the menu item to toggle the group by setting for a field.<br>
// Default implementation evaluates and returns the dynamic +link{listGrid.groupByText}
// string.
// @param field (ListGridField) field to get the menu item title for
// @return (HTMLString) Title to show in the menu item
// @group i18nMessages
// @visibility external
//<
getGroupByText : function (field) {
    var messageArgs = {
        field:field,
        title: this.getSummaryTitle(field),
        viewer:this
    }
    return this.groupByText.evalDynamicString(this, messageArgs);
},




//> @attr ListGrid.ungroupText (string : "Ungroup" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, and
// +link{listGrid.isGrouped,this.isGrouped} is true, this
// attribute will be shown as the title for the menu item to ungroup the grid.
// @group i18nMessages
// @visibility external
//<
ungroupText: "Ungroup",


_shouldGroupByField : function (field) {
    var field = this.getField(field);
    return !!(field && this._canGroupByField(field) &&
              this.data.getLength() <= this.groupByMaxRecords);
},
_canGroupByField : function (field) {
    var field = this.getUnderlyingField(field);
    return !!(field &&
              ((this.canGroupBy == true && field.canGroupBy != false) ||
               (this.canGroupBy != false && field.canGroupBy == true) ||
               (this.editingOn && this.editProxy && this.editProxy.canGroupBy)));
},



//> @method listGrid.getHeaderSpanContextMenuItems()
// Return the menus items that should be shown in a menu triggered from a
// +link{listGrid.headerSpans,headerSpan}.
//
// @param headerSpan (HeaderSpan) the component representing the headerSpan.  This component will
//                            have all the properties specified via +link{listGrid.headerSpans}.
// @return (Array of MenuItem) return false instead to avoid showing a menu
//
// @group headerSpan
// @visibility external
//<
getHeaderSpanContextMenuItems : function (span) {
    if (!this.showTreeColumnPicker && !this.showHeaderSpanContextMenu) return false;

    var menuItems = [];
    if (this.canPickFields) {
        menuItems[0] = {
            title: this.fieldVisibilitySubmenuTitle,
            submenu: this.getColumnPickerItems(),
            icon: "[SKINIMG]actions/column_preferences.png"
        };
    }

    var grid = this,
        fields = this.getSpannedFields(span),
        frozen
    ;
    if (fields) {
        for (var i = 0; i < fields.length; i++) {
            var fieldName = fields[i],
                field = this.getField(fieldName)
            ;
            if (field && !this._suppressedFrozenFields && field.frozen) {
                frozen = true;
                break;
            }
        }
    }

    // show menu for freezing and unfreezing spans.  Don't allow all fields to be frozen.
    if (this.canFreezeFields && this.fields.length > 1 && !span.parentSpan) {
        // can't freeze the last unfrozen field etc.
        if (frozen || this.frozenFields == null || this.normalFields.length > fields.length) {
            if (menuItems.length > 0) menuItems.add({isSeparator: true});
            menuItems.add({
            // method to get field from completeFields?
                title: this.getToggleFreezeText(
                        this.completeFields.find(this.fieldIdProperty,fields[0]),
                        span),
                grid:this,
                spanFields:fields,
                frozen: frozen,
                icon:(frozen ? "[SKINIMG]actions/unfreeze.png" :
                                    "[SKINIMG]actions/freezeLeft.png"),
                click: function () {
                    var spanFields = this.spanFields;
                    for (var i = 0; i < spanFields.length; i++) {
                        grid.completeFields.find(grid.fieldIdProperty, spanFields[i]).frozen = !this.frozen;
                    }
                    grid.rebuildForFreeze();
                }
            });
        }
    }

    return menuItems;
},

shouldShowColumnPicker : function (fld) {
    // don't allow hiding treeField columns or those marked canHide: false (now includes the checkboxField)
    // - it doesn't make much sense and is not currently supported
    if (fld.treeField || fld.canHide === false) return false;

    var title = this.getSummaryTitle(fld);

    // don't allow hiding columns with no title (because the menu item would then appear
    // blank as well)
    if (title == null || isc.isAn.emptyString(title)) return false;

    return true;
},

getColumnPickerItems : function () {
    var showColumns = [],
        grid = this
    ;

    // create show/hide columns menu items
    for (var i = 0; i < this.completeFields.length ; i++) {
        var fld = this.completeFields[i];
        if (!this.shouldShowColumnPicker(fld)) continue;

        var title = this.getSummaryTitle(fld);

        var spanConfig = this.spanMap ? this.spanMap[fld.name] : null;
        if (this.showTreeColumnPicker && spanConfig) {
            var spanHierarchy = [spanConfig],
                parentSpan = spanConfig.parentSpan;

            while (parentSpan != null) {
                spanHierarchy.add(parentSpan);
                parentSpan = parentSpan.parentSpan;
            }
            var indent = "";
            for (var ii = spanHierarchy.length-1; ii >= 0; ii--) {
                var itemConfig = spanHierarchy[ii];
                // If we're already stuck the span into the menu skip it.
                if (!showColumns.find("spanConfig",itemConfig)) {

                    // Otherwise output span toggle if we haven't already

                    // Interaction with canHide:false fields: If an item spans
                    // canHide:false fields only, omit it from the menu entirely.
                    // If it spans a mixture of canHide:false / canHide:true fields,
                    // show the item and have it toggle just the canHide:true fields.
                    // If all fields are hidden other than canHide:false fields, show
                    // the checkbox (the span *is* visible after all), but have a click
                    // on the item show the other fields.
                    showColumns.add({
                        title: indent + itemConfig.title,
                        // don't auto-dismiss, so that users can show and hide multiple columns at once
                        autoDismiss: false,
                        
                        spanConfig: itemConfig,
                        click : function spanMenu_click (target, item, menu) {
                            var spannedFields = grid.getSpannedFields(item.spanConfig, true);
                            var hide = item.anySpannedFieldsVisible(true);
                            
                            if (hide) grid.hideFields(spannedFields.duplicate())
                            else grid.showFields(spannedFields.duplicate());
                            menu.body.delayCall("markForRedraw");
                        },
                        anySpannedFieldsVisible :function spanMenu_anySpannedFieldsVisible (canHideOnly) {
                            var spannedFields = grid.getSpannedFields(this.spanConfig, canHideOnly);
                            for (var i = 0; i < spannedFields.length; i++) {
                                if (grid.fieldIsVisible(spannedFields[i])) return true;
                            }
                            return false;
                        },
                        enableIf : function spanMenu_enableIf (target, menu, item) {
                            var itemConfig = item.spanConfig;
                            // enabled if any fields *not* in the span are visible
                            var spannedFields = grid.getSpannedFields(itemConfig);
                            for (var i = 0; i < menu.data.length; i++) {
                                var item = menu.data[i];
                                if (item.fieldName && grid.fieldIsVisible(item.fieldName) &&
                                    !spannedFields.contains(item.fieldName)) return true;
                            }
                            return false;
                        },
                        checkIf : function (target, menu, item) {
                            return item.anySpannedFieldsVisible();
                        }
                    });
                }
                
                indent += "&nbsp;&nbsp;&nbsp;&nbsp;"
            }
            title = indent + title;
        }

        showColumns.add({
            title: title,
            fieldName: fld.name,
            prompt: fld.prompt,
            // don't auto-dismiss, so that users can show and hide multiple columns at once
            autoDismiss: false,
            checkIf : function (target, menu, item) {
                return grid.fieldIsVisible(item.fieldName);
            },
            enableIf : function (target, menu, item) {
                var currentlyVisibleFields = 0;

                for (var i = 0; i < grid.fields.length; i++) {
                    var field = grid.fields[i];
                    // If this field is visible and its an actual field object and not
                    // a special field such as the row number, checkbox or delete column,
                    // then lets count it as a visible field.
                    if (grid.fieldIsVisible(field) && field._isFieldObject) {
                        currentlyVisibleFields++;
                    }
                }

                return !(currentlyVisibleFields === 1 && grid.fieldIsVisible(item.fieldName));
            },
            click : function (target,item,menu) {
                // if we're being shown as a submenu of the grouping menu, disable group
                // item if it is the same as the item who will no longer be visible
                var  parentMenu = menu._parentMenu,
                     groupItemIndex = parentMenu ?
                                     parentMenu.data.findIndex("groupItem", true) : null,
                     groupItem = parentMenu ? parentMenu.data[groupItemIndex] : null,
                     togglingCurrentField = (groupItem && groupItem.fieldName == item.fieldName)
                ;

                if (grid.fieldIsVisible(item.fieldName)) {
                    // make sure length of fields doesn't count checkbox field
                    var fieldsLen = grid.fields.length;
                    if (grid.getCurrentCheckboxField() != null) fieldsLen -= 1;
                    // Don't hide the last visible field
                    if (fieldsLen > 1) {
                        grid.hideField(item.fieldName);
                    }
                    // Disable the last checked column, as we don't want it to be able to be
                    // hidden
                    if (fieldsLen == 1) {
                        var visibleItem = menu.data.find("fieldName", grid.fields[0].name);
                        menu.setItemEnabled(visibleItem, false);
                        this._disabledItem = visibleItem;
                    }
                } else {
                    grid.showField(item.fieldName);
                    // if there is a disabled item, enable it, because now we're guaranteed that
                    // its no longer the last item
                    if (this._disabledItem) {
                        menu.setItemEnabled(this._disabledItem, true);
                        this._disabledItem = null;
                    }
                }
                if (togglingCurrentField) {
                    parentMenu.setItemEnabled(groupItemIndex,
                                              grid._shouldGroupByField(groupItem.fieldName));
                }
                menu.body.delayCall("markForRedraw");

            }
        });
    }
    
    return showColumns;
},

getColumnPickerMenu : function (showColumns) {
    var showColumnsMenu = {
        canHover:true,
        showIcons:true,
        showHover:true,
        cellHoverHTML:function (record) {
            return record.prompt;
        },
        items:showColumns
    };

    return {
        title: this.fieldVisibilitySubmenuTitle,
        submenu: showColumnsMenu,
        icon: "[SKINIMG]actions/column_preferences.png"
    }
},

filterOperatorMenuDefaults: {
    _constructor: "Menu",
    height: 10, minHeight: 10,
    keepInParentRect: true
},
getFilterOperatorMenuItem : function (field, flatMenu) {
    var item = {
        title: this.filterUsingText,
        fieldName: field.name,
        targetField: field,
        prompt: field.prompt,
        icon: "[SKINIMG]actions/filter.png",
        canSelectParent: false,
        submenu: flatMenu ? null : this.getFilterOperatorMenuItems(field)
    };
    return item;
},

getFilterOperatorMenuItems : function (field, includeTitleItem) {
    var ds = this.getDataSource(),
        grid = this,
        form = this.getFilterEditor().getEditForm(),
        formItem = form.getItem(field.name),
        menuItems = []
    ;
    
    if (!formItem) return;

    var addFilterMenuItem = function (operator) {
        menuItems.add({
            title: operator.titleProperty ? isc.Operators[operator.titleProperty] : operator.title,
            grid: grid,
            targetField: field,
            fieldName: field.name,
            operator: operator,
            checked: (field.filterOperator || formItem.getOperator()) == operator.ID,
            click: function(target, item, menu) {
                this.grid.setFieldSearchOperator(this.targetField, this.operator)
            }
        });
    }

    if (includeTitleItem) {
        // include the "Filter using..." item as a non-interactive "title" item
        var titleItem = this.getFilterOperatorMenuItem(field, true);
        titleItem.showRollOver = false;
        titleItem.canSelect = false;
        menuItems.add(titleItem);
        menuItems.add({ isSeparator: true });
    }

    // show the default operator at the top, with an i18n suffix "(default)", and a separator
    var defaultOpId = formItem._defaultOperator || formItem.getDefaultOperator(),
        defaultOp = isc.shallowClone(isc.DS._operators[defaultOpId]),
        title = defaultOp.titleProperty ? isc.Operators[defaultOp.titleProperty] : defaultOp.title
    ;
    title += " " + this.defaultFilterOperatorSuffix;
    defaultOp.title = title;
    defaultOp.titleProperty = null;
    // add a flag that can automatically hide the operatorIcon when the default is selected
    defaultOp.isFieldDefault = true;

    addFilterMenuItem(defaultOp);
    menuItems.add({ isSeparator: true });

    var ops = ds && ds.getFieldOperatorMap(field, null, "fieldType"),
        op
    ;
    // specifically add iContainsPattern, isNull and notNull if they're not already included
    if (!ops["iContainsPattern"]) ops["iContainsPattern"] = {};
    if (!ops["isNull"]) ops["isNull"] = {};
    if (!ops["notNull"]) ops["notNull"] = {};
    for (var opID in ops) {
        op = ds.getSearchOperator(opID) || ops[opID];
        if (op.ID != defaultOpId || formItem.getOperator() != defaultOpId) {
            addFilterMenuItem(op);
        }
    }
    return menuItems;
},
getFieldSearchOperator : function (field) {
    var ds = this.getDataSource();
    if (!ds) return;
    
    var f = this.getFieldByName(field.name);
    var operator = f.operator || f.filterOperator ? ds.getSearchOperator(f.operator || f.filterOperator) : null;
    return operator;
},
setFieldSearchOperator : function (field, operator) {
    var ds = this.getDataSource();
    if (!ds) return;

    if (isc.isA.String(field)) field = this.getFieldByName(field);
    
    if (!operator || operator.isFieldDefault) {
        this.clearFieldSearchOperator(field);
        return;
    }
    
    var editor = this.getFilterEditor(),
        form = editor.getEditForm(),
        item = form.getItem(field.name)
    ;

    if (isc.isA.String(operator)) operator = ds.getSearchOperator(operator);
    if (!isc.isAn.Object(operator)) {
        if (this.shouldAlwaysShowOperatorIcon(field, item)) item.showIcon("operatorIcon", false);
        return;
    }
    
    var oldOp = this.getFieldSearchOperator(field),
        sameValueType = (!oldOp || oldOp.valueType == operator.valueType),
        disableItem = false
    ;
    if (item) {
        // clear the value if the valueType changed or there's a valueMap that no longer 
        // contains the value
        if (!sameValueType) {
            // different 
            item.clearValue();
        } else if (item.optionDataSource || item.getValueMap() && 
                (item._valueInValueMap && !item._valueInValueMap(item.getValue()))) 
        {
            item.clearValue();
        }
    }
    this.updateOperatorIcon(field, item, operator);
    if (operator.valueType == "none") {
        // operators with valueType:"none" expect to have no value specified - currently, these
        // operators are "isNull" and "notNull" - disable input in the formItem 
        if (item.getCanEdit()) {
            if (!item.readOnlyDisplay) item.readOnlyDisplay = "disabled";
            item.setCanEdit(false);
        }
    } else {
        if (!item.getCanEdit()) {
            item.setCanEdit(true);
        }
        this.focusInFilterEditor(field.name);
    }
},

clearFieldSearchOperator : function (field) {
    field = this.getFieldByName(field);
    var editor = this.getFilterEditor(),
        form = editor.getEditForm(),
        item = form.getItem(field.name)
    ;
    
    this.updateOperatorIcon(field, item, null);
},

updateOperatorIcon : function (field, item, operator) {
    var icon = item.getIcon("operatorIcon"),
        shouldClear = false
    ;

    if (!operator) {
        operator = isc.DS._operators[item._defaultOperator];
        // hide the operatorIcon unless field or grid make it always visible
        if (!this.shouldAlwaysShowOperatorIcon(field, item)) shouldClear = true;
    }

    if (shouldClear) {
        item.operator = item._defaultOperator;
        this.getField(field.name).operator = item.operator;
        item.hideIcon("operatorIcon", false);
        if (!item.getCanEdit()) {
            // re-enable the item (it must have previously had an op of valueType: "none")
            item.setCanEdit(true);
        }
    } else {
        icon.prompt = isc.Operators[operator.titleProperty];
        icon.text = operator.symbol;
        item.operator = operator.ID;
        this.getField(field.name).operator = operator.ID;
        item.showIcon("operatorIcon", false);
    }

    item.redraw();
},

operatorIconStyle: "filterOperatorIcon",
operatorIconDefaults: {
    name: "operatorIcon",
    inline: true,
    inlineIconAlign: "left",
    align: "center",
    hspace: 1,
    width: 16,
    disableOnReadOnly: false,
    showOver: true
},
getOperatorIcon : function (field, operator) {
    // if no field was passed, bail
    if (!field) return;
    if (isc.isA.String(operator)) {
        // map an operatorId to an operator
        operator = this.getDataSource().getSearchOperator(operator);
    }
    if (!operator) {
        // get the default operator from the field
        operator = this.getDataSource().getSearchOperator(field.filterOperator);
    }
    var icon = isc.addProperties({}, this.operatorIconDefaults, this.operatorIconProperties,
        { 
            grid: this,
            field: field,
            fieldName: field.name,
            hidden: true,
            showIf: "false",
            text: operator ? operator.symbol : "",
            prompt: operator ? isc.Operators[operator.titleProperty] : "",
            baseStyle: this.operatorIconStyle || this.header.getButton(0).baseStyle,
            click : function (form, item, icon) {
                var grid = icon.grid,
                    items = grid.getFilterOperatorMenuItems(icon.field),
                    menu = grid.filterOperatorMenu
                ;
                if (!menu) {
                    menu = grid.filterOperatorMenu = grid.createAutoChild("filterOperatorMenu");
                }
                menu.setItems(items);
                var button = grid.getFieldHeaderButton(grid.getFieldNum(this.field));
                menu.moveTo(0, -9999);
                menu.show();
                menu.placeNear(button.getPageLeft(), button.getPageTop());
            }
        }
    );
    return icon;
},

//> @method ListGrid.getHeaderContextMenuItems()
// If +link{attr:listGrid.showHeaderContextMenu} is <code>true</code> this method returns
// the menu items to be displayed in the default header context menu.
// <P>
// This method is called at various times, including during redraws, as the mouse moves over a
// ListGrid header button and each time the menu is actually displayed - this allows for 
// dynamic content depending on the current state of the grid and its fields.
// <P>
// Consequently, this method should not instantiate any classes, because they'll be re-created
// on each call, resulting in a leak - your implementation should return an array of menuItem 
// config-blocks only, so you shouldn't instantiate actual Menu instances to apply as the 
// +link{menuItem.subMenu, submenu) of items - instead, set submenu to a simple array of
// menuItems.  If your use-case necessitates that class instances are created, because specific
// submenus have a different Menu class, for example, you should keep a reference to them and 
// either, if their content is dynamic, destroy and recreate them with the new items, or just
// return the existing instances otherwise. 
// <P>
// The default set of menu items includes items for built-in ListGrid features like showing 
// and hiding fields, freezing fields or grouping by them, and other functions.
//
// @param [fieldNum] (integer) Index of the field the user clicked in the
//    +link{listgrid.fields,fields} array. <b>Note:</b> if the user right-clicked the sorter button
//    this parameter will be <code>null</code>.
//
// @return (Array of MenuItem)
// @group gridHeader
// @visibility external
//<
getHeaderContextMenuItems : function (fieldNum) {
    var field = this.getField(fieldNum);

    var menuItems = [],
        needSeparator = false
    ;

    var canSort = this._canSort(field);

    if (canSort || !field) {
        if (field) {
            var sortFieldNum = fieldNum != null ? fieldNum : this._getSortFieldNum();
            menuItems[0] = {
                title: this.sortFieldAscendingText,
                icon: "[SKINIMG]actions/sort_ascending.png",
                click: "menu.doSort(" + sortFieldNum + ", 'ascending')"
            };
            menuItems[1] = {
                title: this.sortFieldDescendingText,
                icon: "[SKINIMG]actions/sort_descending.png",
                click: "menu.doSort(" + sortFieldNum + ", 'descending')"
            };
            needSeparator = true;
        }
        if (this._canMultiSort()) {
            menuItems.add({
                title: this.configureSortText,
                field: field,
                click : function (target, item, menu) {
                    menu.grid.askForSort(this.field == null ? null : this.field[menu.grid.fieldIdProperty]);
                }
            });
            needSeparator = true;
            if (!field || this.isSortField(field[this.fieldIdProperty])) {

                menuItems.add({
                    title: field ? this.clearSortFieldText : this.clearAllSortingText,
                    field: field,
                    enableIf : function (target, menu, item) {
                        return (field || (!field && menu.grid.getSortFieldCount() > 0));
                    },
                    click: field ? "menu.doSort(" + sortFieldNum + ", 'unsort')" :
                        "menu.grid.clearSort();"
                });
                needSeparator = true;
            }
        }
    }

    // Note if autoFitWidth is already set on this field we still want to show the
    // option to force a re-run of the autofit logic. This is required to handle the
    // case where we autoFit to the rendered rows but the user scrolls new rows into
    // view which aren't in the draw area and are clipped. In this case we want the user to
    // have the option to re-auto-fit
    
    var showAutoFit = (field && this.canAutoFitField(field));
    if (showAutoFit) {
        if (this.canAutoFitFields) {
            menuItems.add({
                title:this.autoFitAllText,
                click:"menu.grid.autoFitFields()"
            });
        }
        menuItems.add({
            title: this.autoFitFieldText,
            click: "menu.grid.autoFitField(" + fieldNum + ",true);"
        });
    }

    if (!field && this.showFilterEditor) {
        if (needSeparator) menuItems.add({ isSeparator: true });
        menuItems.add({
            title: this.clearFilterText,
            click: "menu.grid.clearFilterItemClick();"
        });
        needSeparator = true;
    }
    // add column visibility chooser
    if (this.canPickFields && this.completeFields.length > 1) {
        if (this.useAdvancedFieldPicker &&
            this.completeFields.length >= this.advancedFieldPickerThreshold)
        {
            menuItems.add(this.createFieldPickerWindowMenuItem(
                this.fieldVisibilitySubmenuTitle + "..."));

        } else {
            var showColumns = this.getColumnPickerItems();
            if (showColumns.length > 0) {
                // Never allow the user to hide the last visible field in the grid.
                // If we can toggle visibility on more than one field, show the picker
                var show = showColumns.length > 1;
                // Otherwise only show the picker if there's at least 1 additional
                // (canHide:false) field visible. 
                // This prevents the user from hiding all fields in the grid.
                if (!show) {
                    var fieldName = showColumns[0].fieldName;
                    for (var i = 0; i < this.fields.length; i++) {
                        if (this.fields[i].name != fieldName) {
                            show = true;
                            break;
                        }
                    }
                }
                if (show) {
                    if (needSeparator) menuItems.add({ isSeparator: true } );
                    menuItems.add(this.getColumnPickerMenu(showColumns));
                    needSeparator = true;
                }
            }
        }
    }
    // add group option
    // canGroupBy a field if:
    // - this.canGroupBy is true and field.canGroupBy is not false
    // - this.canGroupBy is unset and field.canGroupBy is true
    var canGroupBy = field && this._canGroupByField(field),
        // only consider grouped if current field is not marked canGroupBy: false.
        // this makes no grouping/ungrouping options show up for the field.
        isGrouped = (this.canGroupBy != false) && field && field.canGroupBy != false
                    && this.isGrouped;
    if (needSeparator && (isGrouped || canGroupBy)) {
        menuItems.add({ isSeparator: true } );
    }

    // filterOperators menuItem
    if (field && this.shouldAllowFilterOperators(field)) {
        var filterEditor = this.getFilterEditor();
        var filterForm = filterEditor && filterEditor.getEditForm();
        // if allowFilterOperators is set, add a "Filter using" menuItem with a submenu 
        // listing all operators that apply to this field, and are valueType: "fieldType"
        menuItems.add({
            title: this.filterUsingText,
            fieldName: field.name,
            targetField: field,
            prompt: field.prompt,
            icon: "[SKINIMG]actions/filter.png",
            canSelectParent: false,
            submenu: filterForm ? this.getFilterOperatorMenuItems(field) : []
        });
    }

    if (canGroupBy) {

        // if there is no custom getGroupValue defined, check if there is a custom groupingModes
        // or else fallback to the default simpleType one - if using the simpleType and it has
        // a getGroupingModes() method, run that, otherwise, just assume groupingModes
        var groupingModes = field.groupingModes ? field.groupingModes :
            (!field.getGroupValue ? ( field._simpleType ? (field._simpleType.getGroupingModes ?
                                                           field._simpleType.getGroupingModes() :
                                                           field._simpleType.groupingModes) : false )
             : false);

        var groupBySubmenu = null;
        if (groupingModes) {
            groupBySubmenu = [];
            var addSubmenuItem = function (mode, title) {
                if (!title) title = mode;
                groupBySubmenu.add({
                    title: title,
                    groupType: mode,
                    targetField: field,
                    fieldName: field.name,
                    prompt: field.prompt,
                    checked: field.groupingMode == mode,
                    //TODO> check if this field is actually grouped but with different option
                    click: function(target, item, menu) {
                        menu._parentMenu.groupField(item);
                    }
                });
            }
            // valueMap support: either an array or object of property bindings
            if (isc.isAn.Array(groupingModes)) {
                for (var i = 0; i < groupingModes.length; i++) {
                    addSubmenuItem(groupingModes[i]);
                }
            } else if (isc.isAn.Object(groupingModes)) {
                for (var property in groupingModes) {
                    addSubmenuItem(property, groupingModes[property]);
                }
            }
        }
        
        menuItems.add({
            groupItem: true,
            title: this.getGroupByText(field),
            fieldName: field.name,
            targetField: field,
            prompt: field.prompt,
            icon: "[SKINIMG]actions/groupby.png",
            click: function(target, item, menu) {
                menu.groupField(item);
            },
            enabled: this._shouldGroupByField(field),
            canSelectParent: true,
            submenu: groupBySubmenu
        });
        if (this.canMultiGroup) {
            var grid = this;
            menuItems.add({
                title: this.configureGroupingText,
                icon: "[SKINIMG]actions/groupby.png",
                targetField: field,
                click: function(target, item, menu) {
                    grid.configureGrouping(this.targetField);
                },
                enabled: this._shouldGroupByField(field)
            });
        }
        needSeparator = true;
    }
    // if grid is grouped, show ungroup option
    if (isGrouped) {
        menuItems.add({
            title: this.ungroupText,
            click: "menu.ungroup()",
            icon: "[SKINIMG]actions/ungroup.png"
        });
        needSeparator = true;
    }

    if (field) {
        // show menu for freezing and unfreezing fields.  Don't allow all fields to be frozen.
        if (this.canFreezeFields && this.fields.length > 1 &&
            (field.frozen ||
             (this.frozenFields == null || this.normalFields.length > 1)) &&
             // disallow freezing of spanned fields - can only freeze the whole spanned set
             // together
             !(this.spanMap && this.spanMap[field.name]) &&
             // allow listGridField.canFreeze to prevent freeze option from appearing in context menu
             field.canFreeze != false)
        {

            if (needSeparator) menuItems.add({ isSeparator: true });

            menuItems.add({
                title: this.getToggleFreezeText(field),
                grid: this,
                field: field,
                icon: (field.frozen ? "[SKINIMG]actions/unfreeze.png" : "[SKINIMG]actions/freezeLeft.png"),
                click: "item.grid.toggleFrozen(this.field,!this.field.frozen)"
            });
            
            needSeparator = true;
        }
    }

    var canAddFormulaFields = (this.canAddFormulaFields || (this.editingOn && this.editProxy && this.editProxy.canAddFormulaFields));

    if (canAddFormulaFields) {
        if (needSeparator) menuItems.add({ isSeparator: true });

        if (field && field.userFormula && field.canEditFormula != false) {
            menuItems.add({
                title: this.editFormulaFieldText,
                grid: this,
                field: field,
                click: "item.grid.editFormulaField(item.field)",
                icon: "[SKINIMG]ListGrid/formula_menuItem.png"
            });

            menuItems.add({
                title: this.removeFormulaFieldText,
                grid: this,
                field: field,
                click: "item.grid.removeField(item.field.name)",
                icon: "[SKINIMG]ListGrid/formula_menuItem.png"
            });
        }

        menuItems.add({
            title: this.addFormulaFieldText,
            grid: this,
            click: "item.grid.addFormulaField()",
            icon: "[SKINIMG]ListGrid/formula_menuItem.png"
        });
        needSeparator = true;
    }

    var canAddSummaryFields = (this.canAddSummaryFields || (this.editingOn && this.editProxy && this.editProxy.canAddSummaryFields));

    if (canAddSummaryFields) {
        if (needSeparator) menuItems.add({ isSeparator: true });

        if (field && field.userSummary && field.canEditSummary != false) {
            menuItems.add({
                title: this.editSummaryFieldText,
                grid: this,
                field: field,
                click: "item.grid.editSummaryField(item.field)",
                icon: "[SKINIMG]ListGrid/formula_menuItem.png"
            });

            menuItems.add({
                title: this.removeSummaryFieldText,
                grid: this,
                field: field,
                click: "item.grid.removeField(item.field.name)",
                icon: "[SKINIMG]ListGrid/formula_menuItem.png"
            });
        }

        menuItems.add({
            title: this.addSummaryFieldText,
            grid: this,
            click: "item.grid.addSummaryField()",
            icon: "[SKINIMG]ListGrid/formula_menuItem.png"
        });
        needSeparator = true;
    }

    var canEditHilites = (this.canEditHilites || (this.editingOn && this.editProxy && this.editProxy.canEditHilites));
    if (canEditHilites) {
        if (needSeparator) menuItems.add({ isSeparator: true });

        menuItems.add({
            title: this.editHilitesText,
            grid: this,
            click: "item.grid.editHilites()"
        });
    }

    return menuItems;
},
    
      
// Helper to determine whether a specific field should show the "autoFit" menu option
// and allow autoFit via the headerAutoFitEvent
canAutoFitField : function (field) {
    if (field.canDragResize == false) return false;
    if (this.canResizeFields == false) return false;
    if (field.canAutoFitWidth != null) return field.canAutoFitWidth;
    return !!this.canAutoFitFields;
},


// clearFilterItemClick - fired when the user clicks the "clear filter" menu item
clearFilterItemClick : function () {
    this.setFilterEditorCriteria(null);
    this.filterByEditor();
},

//> @method ListGrid.getHeaderContextMenu()
// If +link{attr:listGrid.showHeaderContextMenu} is <code>true</code> this method returns
// the menu to display when the user right-clicks on the header or corner sort button of
// this listGrid.<br>
// Default implementation displays the list of available columns, and allows the user to
// change the visibility of each column by selecting the appropriate fieldName.
// @group gridHeader
// @visibility internal
//<
// Leave this internal for now - If a developer wishes to display a custom header context menu
// they can override displayHeaderContextMenu() instead.
// Overriding this method is not as clean - the developer would also need to override
// getHeaderContextMenuItems(), [which will be called each time the menu is actually shown]
headerContextMenuConstructor:"Menu",
headerContextMenuDefaults:{
    // On Hide, if we're showing the headerMenuButton, hide it
    hide : function () {
        this.Super("hide", arguments);
        if (!isc.Browser.isTouch && this.grid) {
            this.grid._showingHeaderContextMenu = false;
            this.grid._hideHeaderMenuButton();
        }
    },
    // sorting
    doSort : function (fieldNum, direction) {
        if (direction == "unsort") this.grid.toggleSort(this.grid.getFieldName(fieldNum), direction);
        else this.grid.sort(fieldNum, direction);
    },
    canHover:true,
    showHover:true,
    cellHoverHTML : function(record,rowNum,colNum) { return record.prompt },
    groupField : function (item) {
        var grid = this.grid,
            gridGroupByFields = grid.getGroupByFields();
        if ((item.targetField && item.groupType) ||
            !(gridGroupByFields && gridGroupByFields.length == 1 && 
              gridGroupByFields.contains(item.fieldName)))
        {
            // make a GroupSpecifier for the menu-item and call setGroupSpecifiers()
            // if groupType is null, makeGroupSpecifier() will use the field/simpleType default
            var spec = grid.makeGroupSpecifier(item.fieldName, item.groupType, 
                    item.groupGranularity, item.groupPrecision);
            
            spec._oldGrouping = item.targetField.groupingMode || "none";
            item.targetField.groupingMode = item.groupType;
            grid.setGroupSpecifiers([spec]);
        }
    },

    ungroup : function () {
        this.grid.ungroup();
    }
},
getHeaderContextMenu : function () {
    return this.createAutoChild("headerContextMenu", {
        ID:this.getID() + "_cornerMenu",
        grid : this
    }, this.getMenuConstructor());
},

//> @method listGrid.getSortArrowImage() (A)
// Return the sort arrow image used in the sorter button and the current sort col header button.
// @group drawing
// @return (ImgProperties | HTMLString) HTML for sorter button
//<
getSortArrowImage : function (fieldNum, returnImg, clipTitle, wrap) {
    if (fieldNum == null) fieldNum = this._getSortFieldNum();
    var img = null;
    if (this.showSortArrow != false && fieldNum != null) {
        var field = this.getField(fieldNum);
        var fieldDirection = field && field.sortDirection;
        if (fieldDirection == null) fieldDirection = this.sortDirection;
        img = Array.shouldSortAscending(fieldDirection)
              ? this.sortAscendingImage
              : this.sortDescendingImage;
    }
    if (returnImg) return img;

    if (img != null) {
        return this.imgHTML(isc.addProperties({
            imgDir: this.widgetImgDir,
            extraCSSText: (clipTitle && this.clipHeaderTitles) || wrap
                          ? (this.isRTL() ? "float:left;margin-right:4px" : "float:right;margin-left:4px")
                          : null
        }, img));
    } else {
        return isc.Canvas.spacerHTML(1, 1);
    }
},

//> @method listGrid.sorterClick() (A)
// Notification method fired when the user clicks on the corner
// +link{listGrid.sorterConstructor, sort button}.  Return false to suppress the sort.
//
// @return (boolean) return false to suppress the sort
// @group events, sorting
// @visibility external
//<

_sorterClick : function () {
    if (this.sorterClick && !this.sorterClick()) return;

    var sortFieldNum = this._getSortFieldNum();

    // if the list can't sort, return false
    if (!this._canSort(sortFieldNum)) return false;

    if (sortFieldNum != null) {
        var sortField = this.getField(sortFieldNum),
            fieldName = sortField[this.fieldIdProperty],
            globalSortDir = this._baseSortDirection,
            sortDir = this._getFieldSortDirection(sortField)
        ;
        if (this.isSortField(fieldName)) {
            // we're already sorted - decide whether to toggle or unsort
            if (globalSortDir == sortDir || this.canUnsort == false) {
                this.toggleSort(fieldName);
            } else {
                this.toggleSort(fieldName, "unsort");
            }
        } else {
            this.setSort([{ property: fieldName, direction: globalSortDir }]);
        }
    } else {
        this.sort(
            sortFieldNum,
            (sortFieldNum != null ?
                !Array.shouldSortAscending(this.getField(sortFieldNum).sortDirection) :
                null)
        );
    }
},


shouldShowDragLineForRecord : function(recordNum) {
    return this.canReorderRecords && this.showDropLines != false;
},

// Drag Line
// --------------------------------------------------------------------------------------------
// Note that the row and column drag lines are the same Canvas

//> @method listGrid.showDragLineForRecord()    (A)
// Show the drag line relative to a particular record.
// <p>
// If no record number is passed, assumes the one under the mouse.
// <p>
// This is used to show feedback in reordering rows or to insert dragged records at a particular
// row.
//      @group  dragging, drawing
//<
showDragLineForRecord : function (recordNum, position) {
    if (!this.shouldShowDragLineForRecord(recordNum)) return;

    var body = this.body;

    // get the event record
    if (recordNum == null) recordNum = this.getEventRecordNum();

    // If 'recordNum' is -1, we're above the top of the list.
    // This is basically invalid - the user dragged over the header, so just bail.
    // Note: willAcceptDrop() will return false in this case - however
    // this method is called from dropMove() which is tripped by EH without checking
    // for the result of willAcceptDrop
    if (recordNum == -1) {
        if (this._dragLine) this._dragLine.hide();
        return;
    }

    // if 'recordNum' is -2 - we're in the blank area underneath the last record.  Show the
    // drop line underneath the last record.
    var lastVisibleRow = body.getVisibleRows()[1];
    if (recordNum == -2) recordNum = lastVisibleRow;

    // if the record is not enabled, you can't drop on it (unless you're trying to drop at the end
    // of the list, which is special)
    if (this._dragLine && recordNum != lastVisibleRow) {
        var record = this.getCellRecord(recordNum);
        if (!this.recordIsEnabled(record, recordNum)) {
            return this._dragLine.hide();
        }
    }

    // before, after (or over)?
    if (position == null) position = this.getRecordDropPosition(recordNum);
    // now move the dragLine to the proper place and show it
    var leftBody = this.getLeftBody();
    var left = leftBody.getPageLeft()
        + (this.isRTL() && leftBody.vscrollOn ? leftBody.getScrollbarSize() : 0);
    if (position == isc.ListGrid.BEFORE) {
        // drag line above record
        this.showHDragLine(left, body.getRowPageTop(recordNum));
        this._dragLine.afterRow = recordNum -1;
    } else if (position == isc.ListGrid.AFTER) {
        // drag line under record
        this.showHDragLine(left,
                           (body.getRowPageTop(recordNum) + body.getRowSize(recordNum)));
        this._dragLine.afterRow = recordNum;
    } else {
        // if we are not dropping before or after the record, hide the dragLine and bail.
        return this._dragLine.hide();
    }

    if (this.recordDropMove) {
        this.fireCallback("recordDropMove", "viewer,recordNum,record,position",
                          [this, recordNum, this.getRecord(recordNum), position])
    }

},

showHDragLine : function (pageLeft, pageTop) {
    // make sure the drag line is set up
    this.makeDragLine();
    // and resize it to span the viewport.  Note: needs to be based on the overall ListGrid,
    // not the body, since there may be multiple bodies with frozen columns.
    
    this._dragLine.resizeTo(
            this.getViewportWidth() - (this.body.vscrollOn ? this.body.getScrollbarSize() : 0), 2);

    // place it
    var bodyTop = this.body.getPageTop(),
        bodyBottom = bodyTop + this.body.getVisibleHeight();
    if (pageTop < bodyTop) pageTop = bodyTop;
    else if (pageTop > bodyBottom) pageTop = bodyBottom;
    this._dragLine.setPageRect(pageLeft, pageTop);

    // and show it
    this._dragLine.show();
    this._dragLine.bringToFront();
},


//> @method listGrid.showDragLineForField() (A)
//      Show the drag line relative to a particular field.
//      If no field number is passed, assumes the one under the mouse.
//
//      This is used to show feedback in resizing or moving fields (columns).
//
//      @param  [fieldNum]      (number)    Number of the field to show line for.
//                                          Default is the field under the mouse.
//      @param  [headerOnly]    (boolean)   Show in the header only (true), or over the entire
//                                          list?  Default is over the entire list (false).
//
//      @group  dragging, drawing
//<
showDragLineForField : function (fieldNum, headerOnly) {
    // make sure the drag line is set up
    this.makeDragLine();
    // and resize it to cover the entire height of the listGrid
    if (headerOnly == true || !this.body) {
        this._dragLine.resizeTo(2, this.getHeaderHeight());
    } else {
        
        this._dragLine.resizeTo(2, this.getHeaderHeight() + this.body.getVisibleHeight());
    }

    // get the event record
    if (fieldNum == null) fieldNum = this.getEventFieldNum();

    if (fieldNum < 0) {
        this._dragLine.hide();
        return;
    }

    // now move the dragLine to the proper place and show it

    // dragLine placement:
    // - we shouldn't use body.getColumnLeft() or similar because the body could be displaying
    //   the empty message
    // - resize is from right edge in LTR, left edge in RTL
    // - since the header object may not be doing live redraw, use dragResizeWidth rather than
    //   current header widget width
    // - adjust by 1px to center the 2px-wide drag line
    var resizingField = this.ns.EH.dragTarget,
        left = (!this.isRTL() ?
            // resize is from right edge
            resizingField.getPageLeft() + this.ns.EH.dragResizeWidth :
            // resize if from left edge
            resizingField.getPageRight() - this.ns.EH.dragResizeWidth) - 1;

    this._dragLine.setPageRect(left, this.getPageTop()
                                     + (this.showFilterEditor ? this.filterEditorHeight : 0));
    this._dragLine.bringToFront();
    this._dragLine.show();
},



// Sorting
// --------------------------------------------------------------------------------------------

//> @method listGrid.unsort()
// Turn sorting off, typically because data has changed and is no longer sorted.
// <p>
// Calling <code>unsort()</code> disables visual indication of which columns are sorted,
// and calls <code>unsort()</code> on the underlying dataset.
// <P>
// Note that a grid viewing a paged dataset may not be able to support <code>unsort()</code>
// because the sort order is what establishes the row numbering that allows data to be
// fetched in batches.
// <P>
// <code>unsort()</code> is automatically called when records are dropped or the
// +link{listGrid.setSort(), sort-configuration} is altered.
//
// @group   sorting
// @visibility external
//<
unsort : function () {
    this.setSort(null);
},

//> @method listGrid.resort()
// If a list has become unsorted due to data modification or a call to
// +link{ListGrid.unsort()}, this method will resort the list by the previous
// +link{listGrid.setSort, sort-specifier} array, if there is one, or by the previous
// sort-field and -direction.
//
// @group sorting
// @visibility external
//<
resort : function () {
    this._resorting = true;
    if (this._sortSpecifiers) return this.setSort(isc.shallowClone(this._sortSpecifiers));
    var sortFieldNum = this._getSortFieldNum();
    if (sortFieldNum != null) {
        var field = this.getField(sortFieldNum),
            sortDirection = this._getFieldSortDirection(field)
        ;

        return this.sort(sortFieldNum, sortDirection);
    }
},

//> @method listGrid.sort()   ([])
// Sort this grid's data, with the option to explicitly specify a single field to
// sort by and sort direction.
// <P>
// If sortField is not provided and listGrid.sortField is undefined, the data will be sorted
// by the first sortable column according to +link{ListGridField.sortDirection} if specified,
// or +link{ListGrid.sortDirection}.
// <P>
// ListGrids also support multiple-field sorting. See +link{listGrid.setSort()} for details.
// <P>
// Note that for editable grids, sorting is performed by underlying data values, not
// for unsaved +link{listGrid.getEditValues(),pending edit values}.
//
// @param [sortField] (string | number) the field name or column number to sort by
// @param [sortDirection] (SortDirection) the direction to sort in
// @return (Boolean) sorting worked
//
// @see type:SortDirection
// @group sorting
// @visibility external
//<
_$sort:"sort",
sort : function (sortFieldNum, sortDirection) {
    var sortFieldName,
        sortField
    ;

    if (isc.isA.String(sortFieldNum)) {
        // sortFieldNum is actually a sortFieldName
        sortFieldName = sortFieldNum;
        sortFieldNum = this.getFieldNum(sortFieldName);
        if (sortFieldNum < 0) {
            // the field isn't visible - it might still be in completeFields if specified
            // as hidden in lg.fields, or it might only appear in the DS
            sortField = this.getUnderlyingField(sortFieldName);
        }
    }

    if (!sortField) {
        // remember the current sortField num and direction for redrawing sorter images
        var oldSortFieldNum = this._getSortFieldNum(),
            oldSortDirection =
                (oldSortFieldNum != null ?
                            Array.shouldSortAscending(this.getField(oldSortFieldNum).sortDirection) :
                            null);

        // if no sortField was specified, assume sorting by the current sort field if there is
        // one, or the first sortable field otherwise.
        if (sortFieldNum == null) {
            if (oldSortFieldNum != null) {
                sortFieldNum = oldSortFieldNum;
            } else {
                // if this.sortFieldNum is null, default to the first sortable field
                for (var i = 0; i < this.fields.length; i++) {
                    if (this._canSortData(this.fields[i]) != false) {
                        sortFieldNum = i;
                        break;
                    }
                }
            }
        }
        // if sortFieldNum is still null, no fields are sortable and we should bail
        if (sortFieldNum == null) return false;

        sortField = this.getField(sortFieldNum);
    }

    // if we have no sortField, bail!
    if (sortField == null) {
        return;
    }

    if (sortDirection == null) {
        sortDirection = this._getFieldSortDirection(sortField);
    }

    // If we're already sorted in the specified direction by the specified field, bail!
    if (oldSortFieldNum == sortFieldNum && sortDirection == sortField.sortDirection) return;

    var specifier = {
            property: sortField[this.fieldIdProperty],
            direction: Array.shouldSortAscending(sortDirection) ? "ascending" : "descending"
        }
    ;
    return this.setSort([specifier]);
},

_getSortFieldNum : function () {
    if (this.sortFieldNum != null) return this.sortFieldNum;
    // sortField is doc'd, sortFieldNum is not. If sortField is set, resolve to a number,
    // store, and return the number
    if (this.sortField != null) {
        var fieldNum = this.getFieldNum(this.sortField);
        if (fieldNum == -1) fieldNum = null;
        this.sortFieldNum = fieldNum;
        // normalize the sortField attribute to a fieldName for consistency, in case it
        // was originally specified as a field index.
        var fieldName = this.getFieldName(this.sortFieldNum);
        if (fieldName) this.sortField = fieldName;
        return fieldNum;
    }
    return null;
},

_setSortFieldNum : function (fieldNum) {
    this.sortFieldNum = fieldNum;
    var fieldName = this.getFieldName(fieldNum);
    // update the public 'sortField' attribute in case anyone checks it.
    this.sortField = fieldName;
},

//> @method listGrid.getSortField()
// Returns the current sort field for this grid. Note that if +link{setSort()} has been
// used to sort by multiple fields, you can call +link{getSort()} to retrieve details about
// the complete sort applied to the grid.
//
// @return (string) sort field name
// @group sorting
// @visibility external
//<
getSortField : function () {
    return this.sortField;
},

// Multi-level Sorting
//> @attr listGrid.canMultiSort (Boolean : true : IRW)
// When true, indicates that this ListGrid supports sorting on multiple fields.  Note that even
// when set to true, multi-field sorting may not be available if the grid is databound and the
// +link{DataSource.canMultiSort,DataSource doesn't support multi-sort}, or if sorting for a
// field is +link{listGridField.canSortClientOnly,client-only} but not all data is available.
// @serverDS allowed
// @visibility external
//<
canMultiSort: true,

//> @attr listGrid.askForSort()
// @include dataBoundComponent.askForSort()
// @visibility external
//<

//> @attr listGrid.multiSortDialogDefaults (MultiSortDialog properties : null : IR)
// @include dataBoundComponent.multiSortDialogDefaults
// @visibility external
//<


//> @attr listGrid.multiSortDialogProperties (MultiSortDialog properties : null : IR)
// @include dataBoundComponent.multiSortDialogProperties
// @visibility external
//<

// Multi-level Grouping

//> @attr listGrid.canMultiGroup (boolean : false : IRW)
// When true, indicates that this ListGrid supports grouping on multiple fields.
// @serverDS allowed
// @visibility external
//<
canMultiGroup: false,

//> @attr listGrid.initialSort (Array of SortSpecifier : null : IR)
// An array of +link{SortSpecifier} objects used to set up the initial sort configuration for
// this grid. If specified, this will be used instead of any +link{listGrid.sortField} specified.
// @group sorting
// @visibility external
//<
//initialSort: null,

//> @method listGrid.toggleSort() (A)
//  Toggles the sort-direction of the field with the passed name and resorts the grid.
// @param fieldName (String) The name of a field, visible, hidden or existing only in the
//   dataSource
// @group sorting
// @visibility external
//<
toggleSort : function (fieldName, direction) {
    // get the current list of specifiers and the one for the passed fieldName
    var field = this.getSpecifiedField(fieldName),
        specifiers = this._sortSpecifiers ? isc.shallowClone(this._sortSpecifiers) : [],
        specifier = specifiers.find("property", fieldName)
    ;

    // if no existing sort-field, check by displayField
    if (!specifier && field.displayField) {
        specifier = specifiers.find("property", field.displayField);
        if (!specifier) return;
    }

    // if no direction passed in, work one out
    if (!direction)
        direction = Array.shouldSortAscending(specifier.direction) ?
            "descending" : "ascending";

    // if we're unsorting, remove the field from the specifiers array, otherwise set the direction
    if (direction == "unsort") specifiers.remove(specifier);
    else specifier.direction = direction;

    this.setSort(specifiers);
},

_addSort : function (sortField, sortDirection) {
    if (!isc.isAn.Object(sortField)) {
        sortField = this.getSpecifiedField(sortField);
    }
    var direction = sortDirection || this._getFieldSortDirection(sortField);
    this.addSort(
        {
            property: sortField[this.fieldIdProperty],
            direction: Array.shouldSortAscending(direction) ? "ascending" : "descending"
        }
    );
},

//> @method listGrid.addSort() (A)
//  Adds another +link{SortSpecifier} to this grid's sort configuration and resorts.
// @param sortSpecifier (SortSpecifier) A SortSpecifier object indicating an additional field
//    and direction to sort by
// @visibility external
//<
addSort : function (sortSpecifier) {
    var specifiers = this._sortSpecifiers ? isc.shallowClone(this._sortSpecifiers) : [];
    specifiers.add(sortSpecifier);
    this.setSort(specifiers);
},

//> @method listGrid.getSort()
// Returns the current +link{SortSpecifier,SortSpecifiers} for this ListGrid. Will return null if this grid
// has never been sorted (and has no specified +link{initialSort} or +link{sortField}).
// <P>
// Note that if sorting was applied via +link{sort()} [rather than +link{setSort()}] the
// sortSpecifiers returned will have been created based on the specified sort field / direction
// passed into +link{sort()}.
//
// @return (Array of SortSpecifier) current sort specifiers for this grid (may be null if
//  this grid is unsorted).
// @group sorting
// @visibility external
//<
getSort : function () {
    // once sort(), or setSort() has actually run this._sortSpecifiers will be set.
    // Always treat this as the definitive set of specifiers, if present
    if (this._sortSpecifiers) {
       return this.removeSortSpecifierMarkers(isc.shallowClone(this._sortSpecifiers));
    // we haven't sorted yet
    // Check for initialSort first (more recent, more advanced option, for multi-field sort)
    } else if (this.initialSort) {
        return isc.shallowClone(this.initialSort);
    // It could also be that we need to apply sort before draw, as @ http://forums.smartclient.com/showpost.php?p=131926&postcount=6
    } else if (this.sortState) {
        var sortState = this.evalViewState(this.sortState, "sortState") || {};
        return sortState.sortSpecifiers || sortState;
    // check for sortField / sortDirection being set
    } else {
        // support sortFieldNum and sortField (as a single fieldName or array of sortBy strings)
        var field;
        if (this.sortFieldNum != null) field = this.getField(this.sortFieldNum);
        if (!field && this.sortField != null) {
            // getUnderlyingField() will pick up the field from the
            // completeFields array or the dataSource fields if necessary
            field = this.getUnderlyingField(this.sortField);
        }
        if (field) {
            var direction = this._getFieldSortDirection(field);
            return [{property: field[this.fieldIdProperty], direction: direction }];
        }
    }
},


//> @method listGrid.getSortSpecifier() (A)
//  Returns the +link{SortSpecifier} for the passed fieldName, or null if the field is not
// sorted.
// @param fieldName (String) The name of a field, visible, hidden or existing only in the dataSource
// @return (SortSpecifier) for the passed fieldName, or null if the field is not sorted.
// @visibility external
//<
getSortSpecifier : function (fieldName) {
    var item = null;

    if (this._sortSpecifiers && this._sortSpecifiers.length > 0) {
        item = this._sortSpecifiers.find("property", fieldName);
        if (!item) {
            // see if we're sorted by displayField
            // if field.optionDataSource is specified, the display-field doesn't refer to a field
            // value on this data set.
            var field = this.getSpecifiedField(fieldName);
            if (field && field.displayField && !field.optionDataSource) {
                item = this._sortSpecifiers.find("property", field.displayField);
            }
        }
    }
    return item;
},

//> @method listGrid.getSortFieldCount() (A)
//  Returns the number of fields involved in this grid's current sort configuration.
// @return (Number) the number of fields this grid is currently sorted on.
// @visibility external
//<
getSortFieldCount : function () {
    return this._sortSpecifiers ? this._sortSpecifiers.length : 0;
},

//> @method listGrid.isSortField() (A)
//  Returns true if the passed fieldName is in the current sort-specification.
// @param fieldName (String) The name of a field, visible, hidden or existing only in the dataSource
// @return (Boolean) True if the passed field is sorted, false otherwise
// @visibility external
//<
isSortField : function (fieldName) {
    var result = this.getSortSpecifier(fieldName) ? true : false;
    if (!result) {
        // see if we're sorted by displayField
        var field = this.getSpecifiedField(fieldName);
        
        if (field && field.displayField && !field.optionDataSource) {
            result = this.getSortSpecifier(field.displayField) ? true : false;
        }
    }
    return result;
},

//> @attr listGrid.sortNumeralStyle (CSSStyleName : "sortNumeral" : [IRWA])
// When multiple fields are sorted, the Style to apply to the numeral that appears after the
// sort-arrows in the header-buttons of sorted fields.
// @visibility external
//<
sortNumeralStyle: "sortNumeral",

//> @attr listGrid.showSortNumerals (boolean : null : [IRWA])
// When multiple fields are sorted, set this to false to hide the sort-numeral
// displayed by default after the sort-arrows in the header-buttons of sorted fields.
// @visibility external
//<

//> @method listGrid.getSortNumeralHTML()
// When multiple fields are sorted, this method returns the HTML for the sort-numeral that
// appears after the sort-arrows in the header-buttons of sorted fields.  If you don't want
// sort-numerals in the header-buttons, you can override this
// method to return null or an empty string, or set +link{showSortNumerals} to false.
// <P>
// Note that the sortIndex passed in is zero based. The default implementation of this method
// returns an HTML element with the +link{sortNumeralStyle} applied to it, containing the
// specified sortIndex incremented by 1 (therefore showing the more user-friendly 1-based
// numbering system).
//
// @param fieldName (String) The name of a sort-field to get the
//  +link{listGrid.sortNumeralStyle, sortNumeral} HTML for.
// @param sortIndex (int) The sort index for the field.
// @return (HTMLString) The HTML for this field's sortNumeral
// @visibility external
//<

_$sortNumeralHTMLTemplate: [
    "<span class='",        // [0]
    ,                       // [1] this.sortNumeralStyle
    "'>",                   // [2]
    ,,,                     // [3-5] (sortIndex + 1)
    "</span>"               // [6]
],
getSortNumeralHTML : function (fieldName, sortIndex) {
    var template = this._$sortNumeralHTMLTemplate;
    template[1] = this.sortNumeralStyle;
    isc._fillNumber(template, (sortIndex + 1), 3, 3);
    return template.join(isc.emptyString);
},

//> @method listGrid.clearSort()    (A)
//  This method clears any existing sort on this grid by calling +link{listGrid.setSort} with
// a null parameter.  The internal list of +link{SortSpecifier}s is removed and the grid is
// unsorted.
// @visibility external
//<
clearSort : function () {
    this.setSort(null);
},

// add implicit sort specifiers to the given collection, as necessary and appropriate
_addImplicitSort : function(sortSpecifiers, groupByFields) {

    
    if (!groupByFields) groupByFields = this._groupByFields || this.getGroupByFields() || [];

    var modified = false,
        result = isc.shallowClone(sortSpecifiers);

    if (this.sortByGroupFirst && !groupByFields.isEmpty()) {

        this.logInfo("Evaluating implicit sort for grouping " + isc.echoAll(groupByFields), "sorting");

                
        
        //var defaultSortOrder = sortSpecifiers.isEmpty() ? "ascending" : sortSpecifiers[0].direction;
        //this._groupSortDirection = this.groupSortDirection || this._groupSortDirection || defaultSortOrder;

        var defaultSortOrder = sortSpecifiers.isEmpty() ? "ascending" : null;
        if (!sortSpecifiers.isEmpty() && !this.groupSortDirection) {
            // no groupSortDirection specified - sort the groups according to the direction of the primarySort
            for (var i = 0; i < sortSpecifiers.length; i++) {
                var spec = sortSpecifiers[i];
                if (!spec.sortedImplicitly) {
                    if (spec.direction != null) defaultSortOrder = spec.direction;
                    break;
                }
            }
        }
        this._groupSortDirection = this.groupSortDirection || defaultSortOrder;

        for (var i = 0; i < groupByFields.length; i++) {
            var name = groupByFields[i];

                    
            if (sortSpecifiers.find("property", name)) {
                this.logInfo("Existing sort specifier found for property '" + name +"'.  Skipping.", "sorting");
                continue;
            }
            var field = this.getUnderlyingField(name);

            
            if (field == null) continue;

            var specifier = {
                sortedImplicitly: true,
                context: this,
                // if the field isn't databound and no type was specified, default to "text"
                normalizer: this._getSortNormalizerForField(field) || "text",
                property: name,
                direction: this._groupSortDirection
            }
            result.addAt(specifier, i);
            modified = true;
        }
    }

    // If we have a sort specified for a binary field, sort by the fileName, 
    // not the binary field itself
    for (var i = 0; i < result.length; i++) {
        var spec = result[i];
        var field = this.getUnderlyingField(spec.property);
        if (this.sortBinaryByFileName && field && field.sortByField == null &&
            isc.SimpleType.inheritsFrom(field.type,"binary", this.getDataSource())) 
        {
            // duplicate the specified sort so we don't impact what the user sees
            spec = isc.addProperties({}, spec)
            // sort by the target field instead...
            spec.sortByProperty = this.getDataSource().getFilenameField(field);
            result[i] = spec;
            modified = true;
        }
    }

    if (modified) {
        this.logInfo("Returning augmented sort specifiers" + isc.echoAll(result), "sorting");
    } else {
        this.logInfo("Returning unmodified sort specifiers" + isc.echoAll(result), "sorting");
    }

    return result;
},

//> @method listGrid.getSortByGroupFirst()    (A)
// @visibility external
//<
getSortByGroupFirst : function() {
    return this.sortByGroupFirst;
},

//> @method listGrid.setSortByGroupFirst()    (A)
// @param sortByGroupFirst (Boolean) 
// @visibility external
//<
setSortByGroupFirst : function(sortByGroupFirst) {
    this.sortByGroupFirst = sortByGroupFirst;
},

_getSortNormalizerForField : function(field) {

    if (field.sortNormalizer) {
        // custom normalizer defined
        return field.sortNormalizer;
    }

    // for user fields, install a sort normalizer that tries to 
    // evaluate the formula/summary so we have something to sort
    var grid = this;
    if (field.userFormula) return function (record, field) {
        if (record._isGroup) return record.groupValue;
        return grid.getFormulaFieldValue(field, record);
    };
    if (field.userSummary) return function (record, field) {
        if (record._isGroup) return record.groupValue;
        return grid.getSummaryFieldValue(field, record);
    };

    if (field.valueMap 
        && (field.sortByMappedValue == null || field.sortByMappedValue == true)) {

        // if there's a valueMap, use it as the normalizer, so that with eg enums
        // we sort by the text name rather than the numeric order.
        return isc.isA.String(field.valueMap) ?
                this.getGlobalReference(field.valueMap) : field.valueMap;
    }

    if (field.type != null) {
        // if an explicit field type is declared, pass that in as a normalizer -
        // the sort method understands this.
        return field.type;
    }
},

//> @method listGrid.setSortHandler()  (A)
// Optional notification fired when either user or framework code calls 
// +link{listGrid.setSort(),setSort()}.  This notification fires before the default behavior; 
// <smartclient>return false from the handler</smartclient>
// <smartgwt>use <code>event.cancel()</code></smartgwt> to cancel the default behavior.  Note,
// the notification is fired before the default functionality, but <em>after</em> prechecks 
// have completed; your method will only be called if the default behavior would have been
// called.  For example, if there are pending edits and the user does not confirm that these 
// should be saved, normal sorting would not have gone ahead, so equally your handler will 
// not be called.
// <P>
// The default <code>setSort()</code> method does two things to reflect the set of 
// +link{object:sortSpecifier,sortSpecifier}s passed to it:<ul>
// <li>Change the grid UI (show directional arrows, numerals to indicate sort priority, etc)</li>
// <li>Actually sort the grid data</li>
// </ul>
// If your reason for implementing a custom <code>setSortHandler()</code> is to inhibit or 
// replace one of those behaviors, you should cancel the default behavior and directly invoke
// just that part of it you require.  The following implementation will replicate the default
// behavior:<smartclient><pre>
//   setSortHander : function(sortSpecifiers) {
//       this.displaySort(sortSpecifiers);
//       this.applySortToData(sortSpecifiers);
//       return false;  // Prevent the framework from running its own default impl
//   }</pre></smartclient>
// <smartgwt><pre>
//   grid.addSetSortHander(new SetSortHandler() {
//       public void onSetSort(SetSortEvent event) {
//           displaySort(event.getSortSpecifiers());
//           applySortToData(event.getSortSpecifiers());
//           event.cancel();  // Prevent the framework from running its own default impl
//       }
//   });</pre></smartgwt>
//
// @param sortSpecifiers (Array of SortSpecifier) Array of +link{SortSpecifier} objects
// @return (boolean) return false to cancel the default setSort() behavior 
// @visibility external
//<

//> @method listGrid.setSort()  (A)
// Sort the grid on one or more fields.
// <P>
// Pass in an array of +link{SortSpecifier}s to have the grid's data sorted by the fields in
// each +link{sortSpecifier.property,specifier.property} and in the directions specified.  The
// grid can be sorted by any combination of fields, including fields specified in the fields
// array, whether visible or hidden, and +link{DataSource.fields, unused fields from the
// underlying dataSource}, if there is one.
// <P>
// If multiple fields are sorted, those that are visible show a directional icon and a small
// +link{listGrid.sortNumeralStyle, sort-numeral}
// indicating that field's index in the sort configuration.
// <P>
// See +link{listGrid.addSort, addSort()} and +link{listGrid.toggleSort, toggleSort()} APIs
// for information on making changes to the current sort configuration.
// <P>
// Note that for editable grids, sorting is performed by underlying data values, not
// for unsaved +link{listGrid.getEditValues(),pending edit values}.
//
// @param sortSpecifiers (Array of SortSpecifier) Array of +link{SortSpecifier} objects
// @visibility external
//<
_$setSort: "setSort",
setSort : function (sortSpecifiers) {
    if (this.logIsInfoEnabled("sorting")) this.logInfo("Entering setSort", "sorting");

    if (!this._resortingFlagStored) this._storeResortingFlag();

    // if we get passed something that isn't an array, wrap it in one
    if (sortSpecifiers && !isc.isAn.Array(sortSpecifiers)) sortSpecifiers = [sortSpecifiers];

    // if there are no fields arrays bail
    
    if (!this.fields && !this.getDataSource()) {
        
        this.initialSort = sortSpecifiers;
        if (this.logIsInfoEnabled("sorting")) {
            this.logInfo("setSort() not performing sort - no fields", "sorting");
        }
        return false;
    }

    // If we are databound, and we have pending edits, the sort may cause us to lose edit
    // values (because the rows get lost from the local cache). Catch this case and warn the
    // user if appropriate.
    if (this.confirmDiscardEdits && this.dataSource != null) {

        if (this.hasChanges() &&
            // If we have a complete cache, the sort will not drop any edit values
            // (and they will be re-associated with the appropriate rows via remapEditValues)
            isc.ResultSet && isc.isA.ResultSet(this.data) && !this.data.allMatchingRowsCached())
        {
            
            this.showLostEditsConfirmation({target:this, methodName:"_continueSort"},
                                               {target:this, methodName:"_cancelSort"});
            // this._sortArgs gets cleaned up by the callback methods above
            this._sortArgs = sortSpecifiers
            return;
        }
    }

    // get a list of specifiers that *were* in use but won't be after this setSort() call
    var sortSpecifiers = sortSpecifiers || [],
        removeThese = [],
        firstVisibleField
    ;

    if (this._sortSpecifiers) {
        // get a list of items that *were* in the sort-spec but aren't any more, so we can
        // update their header-states
        for (var i = 0; i < this._sortSpecifiers.length; i++) {
            var oldItem = this._sortSpecifiers[i],
                newItem = sortSpecifiers.find("property", oldItem.property)
            ;
            if (!newItem) {
                removeThese.add(isc.shallowClone(oldItem));
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In setSort - marking field "+oldItem.property+
                        " for removal", "sorting");
                }
            }
        }
    }

    if (!sortSpecifiers || sortSpecifiers.length==0) {
        // no sort-specifiers passed, we'll forcibly unsort
        if (this.logIsInfoEnabled("sorting")) {
            this.logInfo("null or zero-length sortSpecifiers - unsorting only", "sorting");
        }
    }

    var newSpecifiers = [];

    // handle the normalizer stuff that used to be done in sortData() for each sortSpecifier
    // and store a couple of useful vars on the item, sortIndex (for the numeral) and
    // primarySort, which indicates this is the first Visible field (and, thus, the sortFieldNum)
    sortSpecifiers.removeEmpty();
    for (var i = 0; i < sortSpecifiers.length; i++) {
        if (!sortSpecifiers[i]) continue;

        var item = sortSpecifiers[i],
            field = this.getUnderlyingField(item.property),
            visibleField = this.getField(item.property),
            normalizer=null
        ;

        if (field && field.sortByField) {
            item.sortByProperty = field.sortByField;
            field = this.getUnderlyingField(item.sortByProperty);
        }

        if (!field) {
            // if getUnderlyingField() didn't return a field, check for a field with
            // a displayField equal to item.property
            var fields = this.getAllFields();
            field = !fields ? null : fields.find("displayField", item.sortByProperty ? item.sortByProperty : item.property);
        }

        if (field) {
            if (!this._canSortData(field)) {
                // data in this field can't be sorted because the field specifies client-only
                // sort, but not all data is presently client-side.  Skip this specifier and
                // log a warning.
                this.logWarn("Removing field '" + field[this.fieldIdProperty] + "' from the " +
                    "sortSpecifier array because it specifies canSortClientOnly: true and all " +
                    "data is not yet client-side.", "sorting");
                continue;
            }

            // is this the first visible field? (this will be grid.sortFieldNum)
            if (visibleField) {
                if (!firstVisibleField) firstVisibleField = visibleField;
            }
            // set up a sortNormalizer
            if (!item.normalizer) {
                item.normalizer = this._getSortNormalizerForField(field);
            }
            // set the default sort-direction if none is provided
            if (item.direction == null) {
                item.direction = this._getFieldSortDirection(field);
            }
            if (firstVisibleField && firstVisibleField == visibleField) {
                item.primarySort = true;
            }
            // store the new sortDirection on the grid from the first sort specifier
            if (item.primarySort) {
                // normalize the sort direction to a boolean and store it on the grid
                this.sortDirection = Array.shouldSortAscending(item.direction);
            }
            if (!item.context) item.context = this;
            item.sortIndex = i;

            newSpecifiers.add(item);
        } else {
            this.logDebug("ListGrid sort specifier for property:" + item.property +
                            " has no associated field - ignoring", "sorting");
        }
    } 

    // store the old specifiers so we can decide whether to fire sortChanged() with the new ones
    this._oldSpecifiers = this._sortSpecifiers ? isc.shallowClone(this._sortSpecifiers) : [];

    // store the sortSpecifiers
    // Update initialization property to match new sort specifier state
    this.sortSpecifiers = this._sortSpecifiers = newSpecifiers;
    
    // Save for downstream processing, so we don't have to do it twice (once for UI update, 
    // once for the actual data sort)
    this._allSpecifiers = this._addImplicitSort(this._sortSpecifiers),
    this._sameSpecifiers = (this._allSpecifiers.length == this._oldSpecifiers.length);
    this._removeThese = removeThese;
    
    if (this._sameSpecifiers && this._oldSpecifiers.length > 0) {
     
        // if the new specifiers (including the implicit ones) are the same as the old ones,
        // we'll still (re)sort, but won't fire sortChanged()
        for (var i = 0; i < this._allSpecifiers.length; i++) {
            var item = this._allSpecifiers[i];
            var matchProps = {
                property : item.property,
                direction : item.direction
            };
            
            var defaultNormalizer = this.data.getDefaultNormalizer 
                                    ? this.data.getDefaultNormalizer(item.property) : null;
            
            
            if (item.normalizer != null && item.normalizer != defaultNormalizer) {
                matchProps.normalizer = item.normalizer;
            }
            var itemIndex = this._oldSpecifiers.findIndex(matchProps);
            if (itemIndex == null || itemIndex < 0) {
                this._sameSpecifiers = false;
                break;
            }
        }
    }

    // If there is a user-registered setSortHandler(), call it and allow it to cancel default
    // behavior by returning explicit false
    if (this.setSortHandler && this.setSortHandler(sortSpecifiers) === false) {
        this.logInfo("User-written setSortHandler() method returned false", "sorting");
        return false;
    }

    this.displaySort(sortSpecifiers);
    this.applySortToData(sortSpecifiers);

    // delete this flag once the sort operation finishes - otherwise, a call to resort() will
    // cause all future calls to setSort() to resort the data instead of applying a new spec
    delete this._resortingFlagStored;

    return true;
},

//> @method listGrid.displaySort()  (A)
// Modify the grid UI to reflect the parameter sortSpecifiers.  For a single sortSpecifier, 
// this consists of marking the field with a directional arrow in its header button (if it 
// visible).
// <P>
// If multiple fields are sorted, those that are visible show a directional icon and a small
// +link{listGrid.sortNumeralStyle, sort-numeral} indicating that field's index in the sort 
// configuration.
// <P>
// See +link{listGrid.addSort, addSort()} and +link{listGrid.toggleSort, toggleSort()} APIs
// for information on making changes to the current sort configuration.
// <p>
// <b>NOTE:</b> This method is primarily used by +link{listGrid.setSort()}; it is not intended 
// to be called by user code, unless you are implementing a custom 
// +link{listGrid.setSortHandler(),setSortHandler}).  For the normal use case, calling this 
// method directly will fail to execute vital pre-steps.  If you are not implementing a custom
// handler as described above, do not call this method directly - call <code>setSort()</code> 
// instead.
//
// @param sortSpecifiers (Array of SortSpecifier) Array of +link{SortSpecifier} objects
// @visibility external
//<
displaySort : function(sortSpecifiers) {
    if (this.logIsInfoEnabled("sorting")) this.logInfo("Entering displaySort", "sorting");

    var firstSpecifier = this._sortSpecifiers[0],
        sortFieldName = firstSpecifier ? firstSpecifier.property : null,
        visibleSortFieldNum = sortFieldName ? this.getFieldNum(sortFieldName) : null,
        sortField = sortFieldName ? this.getUnderlyingField(sortFieldName) : null,
        sortDirection = firstSpecifier ? Array.shouldSortAscending(firstSpecifier.direction) : null
    ;

    if (!sortField) {
        if (firstSpecifier) this.logWarn("sort: field does not exist: " + firstSpecifier.property);
    }

    if (visibleSortFieldNum >= 0) {
        this._setSortFieldNum(visibleSortFieldNum);
    } else {
        this._setSortFieldNum(null);
    }

    if (this.logIsInfoEnabled("sorting")) {
        this.logInfo("In displaySort - ready to change visible sort state for specifiers:\n"+
            isc.echoAll(this._sortSpecifiers), "sorting");
    }

    var allSpecifiers = this._allSpecifiers,
        oldSpecifiers = this._oldSpecifiers,
        sameSpecifiers = (allSpecifiers.length == oldSpecifiers.length),
        removeThese = this._removeThese
    ;

    // A note on edit-rows:
    // This sort will change the rowNums for records - if we have unsaved edits for any rows,
    // this means the 'rowNum' will have to be updated for that edit information.
    // We handle this via '_remapEditRows()' called in response to 'dataChanged()', so no need
    // to do any special handling for this here.  Note also that if we have embedded components,
    // these are remapped in the same way via '_remapEmbeddedComponents()'

    var hasHeader = (this.header && isc.isA.Toolbar(this.header));

    // remove the sort indicators from any fields that *were* sorted but now aren't and
    // are still visible
    if (removeThese) {
        if (removeThese.length > 0) {
            if (this.logIsInfoEnabled("sorting")) {
                this.logInfo("In displaySort - Removing sort-media from now unsorted fields:\n"+
                    isc.echoAll(removeThese), "sorting");
            }
        }

        for (var i=0; i<removeThese.length; i++) {
            var specifier = removeThese[i],
                field = this.getSpecifiedField(specifier.property),
                fieldsToSelect = []
            ;

            if (field) {
                fieldsToSelect.add(field);
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In displaySort, removing sort-media for fieldName '" +
                        field.name + "'", "sorting");
                }
            }

            var fields = this.getFields();
            if (fields) {
                var byDisplayField = fields.findAll("displayField", specifier.property);
                if (byDisplayField) {
                    // If displayField is specified with an optionDataSource this should
                    // not impact sort - the display field doesn't refer to field values in
                    // this data-set
                    byDisplayField.removeUnless("optionDataSource", null);
                    if (byDisplayField.length > 0) {
                        fieldsToSelect.addList(byDisplayField);
                        if (this.logIsInfoEnabled("sorting")) {
                            this.logInfo("In displaySort, removing sort-media for fields with displayField " +
                                "'" + field.name + "' - these are: " +
                                isc.echoFull(byDisplayField.getProperty("name").join(", ")), "sorting");
                        }
                    }
                }
            }

            for (var j=0; j<fieldsToSelect.length; j++) {
                var localField = fieldsToSelect[j],
                    fieldNum = this.getFieldNum(localField.name)
                ;

                if (localField) {
                    localField.sortDirection = localField.originalSortDirection;
                }

                if (fieldNum>=0 && hasHeader) {
                    // select the appropriate button
                    var sortButton = this.getFieldHeaderButton(fieldNum);

                    if (sortButton && sortButton.setTitle) sortButton.setTitle(sortButton.getTitle());
                }
            }
        }
    }

    // set sort indicators on the current set of sort fields.
    if (this._sortSpecifiers && this._sortSpecifiers.length > 0) {
        this.logInfo("In displaySort - Setting sort-media for sorted fields:\n"+
                isc.echoAll(this._sortSpecifiers), "sorting");

        var headerSelected = false;
        // set the sort indicators on any fields that are sorted and are visible
        for (var i=0; i<this._sortSpecifiers.length; i++) {
            var specifier = this._sortSpecifiers[i],
                field = this.getSpecifiedField(specifier.property),
                fieldsToSelect = []
            ;

            if (field) {
                fieldsToSelect.add(field);
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In displaySort, adding sort-media for fieldName '" +
                        field.name + "'", "sorting");
                }
            }

            var fields = this.getFields();
            if (fields) {
                var byDisplayField = fields.findAll("displayField", specifier.property);
                if (byDisplayField) {
                    fieldsToSelect.addList(byDisplayField);
                    if (this.logIsInfoEnabled("sorting")) {
                        this.logInfo("In displaySort, adding sort-media for fields with displayField " +
                            "'" + field.name + "' - these are: " +
                            isc.echoFull(byDisplayField.getProperty("name").join(", ")), "sorting");
                    }
                }
            }

            for (var j=0; j<fieldsToSelect.length; j++) {
                var localField = fieldsToSelect[j],
                    fieldNum = this.getFieldNum(localField.name)
                ;

                if (localField) {
                    if (localField.sortDirection && !localField.originalSortDirection) {
                        localField.originalSortDirection = localField.sortDirection;
                    }
                    localField.sortDirection = specifier.direction;
                }
                if (hasHeader && fieldNum>=0) {
                    // select the appropriate button
                    var sortHeader = this.getFieldHeader(fieldNum),
                        sortButton = this.getFieldHeaderButton(fieldNum);

                    if (sortButton) {
                        if (!headerSelected && this.selectHeaderOnSort) {
                            sortHeader.selectButton(sortButton);
                            if (isc.Browser.isTouch && this.shouldShowHeaderMenuButton(sortButton, true)) {
                                this._showHeaderMenuButton(sortButton);
                            }
                            headerSelected = true;
                        }
                        if (sortButton.setTitle) sortButton.setTitle(this.getHeaderButtonTitle(sortButton));
                    }
                }
            }
        }
    } else if (hasHeader && this.selectHeaderOnSort) {
        // when unsorting, deselect the selected header-button, if there is one
        var selectedButton;
        if (this.header) {
            selectedButton = this.header.getSelectedButton();
            if (selectedButton) {
                selectedButton.deselect();
                this._hideHeaderMenuButton(selectedButton);
            }
        }
        if (this.frozenHeader) {
            selectedButton = this.frozenHeader.getSelectedButton();
            if (selectedButton) selectedButton.deselect();
        }
    }

    if (visibleSortFieldNum >= 0) {
        if (this.logIsInfoEnabled("sorting")) {
            this.logInfo("In displaySort - _setSortFieldNum called with fieldNum: "+visibleSortFieldNum+
                " - sortField is now: "+this.sortField+"\ngetSortState() now returns: "+
                isc.echoAll(this.getSortState()), "sorting");
        }
    }

    // if there's a sorter button, redraw that
    if (this.sorter && this.sorter.setTitle) {
        this.sorter.setTitle(this.sorter.getTitle());
    }

    if (this.logIsInfoEnabled("sorting")) this.logInfo("Leaving displaySort", "sorting");

    return true;
},


//> @method listGrid.applySortToData()  (A)
// Sort the grid's data to reflect the parameter sortSpecifiers.
// <p>
// <b>NOTE:</b> This method is primarily used by +link{listGrid.setSort()}; it is not intended 
// to be called by user code, unless you are implementing a custom 
// +link{listGrid.setSortHandler(),setSortHandler}).  For the normal use case, calling this 
// method directly will fail to execute vital pre-steps.  If you are not implementing a custom
// handler as described above, do not call this method directly - call <code>setSort()</code> 
// instead.
//
// @param sortSpecifiers (Array of SortSpecifier) Array of +link{SortSpecifier} objects
// @visibility external
//<
applySortToData : function (sortSpecifiers) {
    if (this.logIsInfoEnabled("sorting")) this.logInfo("Entering applySortToData", "sorting");

    var firstSpecifier = this._sortSpecifiers[0],
        allSpecifiers = this._allSpecifiers,
        data = this.data 
    ;

    if (allSpecifiers && allSpecifiers.length > 0) {
        //var originalData = this.getOriginalData();
        //var needsRegroup = (data != originalData);
        if (this._calledFromResort && data && data.resort && data._sortSpecifiers) {
            // if called from resort() and the data has a resort() method (ResultSet), AND
            // the data has already been sorted, call resort() instead of setSort() (which
            // will no-op for the same specifiers)
            data.resort();
        } else if (data &&
            (data.setSort || data.length > 0
                || isc.isA.ResultTree(data) || isc.isA.Tree(data)))
        {
            // do the actual sorting
            if (data.setSort) {
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In applySortToData -  Calling data.setSort with specifiers:\n"
                        +isc.echoAll(allSpecifiers), "sorting");
                }
                    data.setSort(allSpecifiers);
            } else if (data.sortByProperty) {
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In applySortToData - Calling data.sortByProperty with specifier:\n"+
                        isc.echoAll(firstSpecifier), "sorting");
                }
                data.sortByProperty(
                    firstSpecifier.sortByProperty ? firstSpecifier.sortByProperty : firstSpecifier.property,
                    Array.shouldSortAscending(firstSpecifier.direction),
                    firstSpecifier.normalizer,
                    firstSpecifier.context
                );
            }
        } else {
            if (this.logIsInfoEnabled("sorting")) {
                this.logInfo("In applySortToData - not sorting:\nthis.data is " + this.echoAll(data),
                    "sorting");
            }
        }
    } else {
        
        if (data) {
            if (data.setSort != null) data.setSort([]);
            else if (data.unsort) data.unsort();
        }

        if (this.invalidateCacheOnUnsort) {
            this.invalidateCache();
        }
    }

    if (this.body && this.showRecordComponents) delete this.body._oldDrawArea;

    // and mark the list as dirty so it will be redrawn
    this._markBodyForRedraw(this._$setSort);

    if (!this._sameSpecifiers && !this._initializing && !this._firstDraw) {
        this.handleSortChanged(this._sortSpecifiers);
    }

    if (this.logIsInfoEnabled("sorting")) this.logInfo("Leaving applySortToData", "sorting");
    
    return true;
},

    
// Store the resorting flag - moved out from setSort() when it was split into two methods
_storeResortingFlag : function () {
    // store and clear the flag that gets set in resort()
    this._calledFromResort = this._resorting;
    delete this._resorting;
    this._resortingFlagStored = true;
    return this._calledFromResort;
},

// sort change notification - documented in register string-methods.
handleSortChanged : function (sortSpecifiers) {
    this.sortChanged(this.removeSortSpecifierMarkers(isc.shallowClone(sortSpecifiers)));
    this.handleFieldStateChanged(true);
},
sortChanged : function (sortSpecifiers) {
},

// Callback methods fired when the user attempted to sort this grid and was prompted to save
// pending edits.
// _continueSort will finish the sort (fired when the user has discarded or saved edits)
// _cancelSort simply cleans up the temp '_sortArgs' object. Fired if the user chooses to cancel
// the sort to continue editing.
_continueSort : function () {
    var args = this._sortArgs;
    delete this._sortArgs;
    this.displaySort(args);
    this.applySortToData(args);
},

_cancelSort : function () {
    var primarySort;
    var primarySort = this._sortArgs ? this._sortArgs[0] : null;
    delete this._sortArgs;
    // if the user clicked a header button to perform the sort, then abandoned it,
    // deselect that header button now.
    if (primarySort != null) {
        var sortFieldNum = this.getFieldNum(primarySort.property);
        if (sortFieldNum != -1 && this.sortFieldNum != sortFieldNum) {
            this.header.deselectButton(sortFieldNum);
        }
    }
},

//> @method listGrid.sortData() (A)
//      @group  sorting
//          actually sort the data according to the sort characteristics of the list
//<
sortData : function () {
    // if the data or fields arrays haven't been defined, skip the sort
    if (!this.data || !this.fields) return;

    // get the field object
    var field = this.fields[this._getSortFieldNum()],
        normalizer = null;

    if (field == null) {
        // if field is null, we've shrunk the number of columns,
        //  sort re-set sort to column 0
        this._setSortFieldNum(0);
        field = this.fields[0];
    }

    if (field.sortNormalizer) {
        // custom normalizer defined
        normalizer = field.sortNormalizer;
    } else if (field.valueMap) {
        // if there's a valueMap, use it as the normalizer, so that with eg enums we sort by the
        // text name rather than the numeric order.
        normalizer = field.valueMap;
        if (isc.isA.String(field.valueMap)) normalizer = this.getGlobalReference(field.valueMap);

    // if an explicit field type is declared, pass that in as a normalizer - the sort method
    // understands this.
    } else if (field.type != null) {
        normalizer = field.type
    }
    // sort by that field's property
    // pass the grid in as the additional 'context' argument for the sort - this will then
    // be available to the normalizer
    this.data.sortByProperty(field[this.fieldIdProperty], field.sortDirection, normalizer, this);
},

// Embedded Components
// --------------------------------------------------------------------------------------------

// These methods actually implemented in GridRenderer

// helper to get the current count of embeddedComponents
getEmbeddedComponentCount : function (componentType) {
    var components = this.body ? this.body._embeddedComponents : null;
    if (this.frozenBody && this.frozenBody._embeddedComponents != null) {
        components = (components ? components.duplicate() : []).addList(this.frozenBody._embeddedComponents);
    }

    if (!components) return 0;

    if (componentType == "recordComponent") {
        components = components.findAll("isRecordComponent", true);
    } else if (componentType == "backgroundComponent") {
        components = components.findAll("isBackgroundComponent", true);
    }

    return components == null ? 0 : components.length;
},

//> @method listGrid.addEmbeddedComponent() [A]
// Attaches the component to the provided record. If <code>position</code> is specified as
// <code>"within"</code> +link{canvas.snapTo} and +link{canvas.snapOffsetLeft},
// +link{canvas.snapOffsetTop} may be set to specify where the component
// will render within the cell or record. If unset, for components embedded within a record
// we will default to embedding at the top/left coordinate, and for components embedded within
// a cell, we will respect the align / valign properties for the cell in question. Any
// percentage sizing will be interpreted as percentage of row size.
// <P>
// Otherwise it will appear to be embedded within the record, underneath the field values.
// <P>
// Embedded components become children of the grid and will stay attached to a record through
// scrolling, sorting and other operations that cause records to shift position.
// <P>
// If <code>position</code> is set to <code>"expand"</code>, embedded components may offer a
// resize interface, eg, by setting +link{listGridField.canDragResize,canDragResize}:true,
// and the grid will react accordingly, growing or shrinking the record to match the embedded
// component's new extents.
// <P>
// Embedded components can be explicitly removed with +link{removeEmbeddedComponent()}.
// <P>
// If a record is removed from the dataset or is replaced in the dataset, for example, it is
// eliminated through filtering (removes record) or is successfully edited in a databound grid
// (replaces record), the component is cleared but not logically removed from the grid. It is the
// responsibility of code that sets up the embedded component to remove it if the record is removed
// from the dataSet.
// <P>
// When embedding components will result in variable height records,
// you should switch on +link{listGrid.virtualScrolling, virtualScrolling}.
//
// @param component (Canvas) component to embed
// @param record (ListGridRecord) record to attach the component to
// @param [rowNum] (Integer) rowNum of the record to attach the component to
// @param [colNum] (Integer) colNum in which to embed the component
// @param [position] (EmbeddedPosition) positioning with respect to the record or cell (Defaults to "expand").
// @visibility external
//<
addEmbeddedComponent : function (component, record, rowNum, colNum, position) {
    
    if (colNum == null && component._currentFieldName != null) {
        colNum = this.getFieldNum(component._currentFieldName);
    }
    // get the local body before localizing the colNum
    var body = this.getFieldBody(colNum);
    colNum = this.getLocalFieldNum(colNum);
    position = position || component.embeddedPosition
    if (rowNum == null) rowNum = this.getRecordIndex(record);

    

    body.addEmbeddedComponent(component, record, rowNum, colNum, position);

    // If we have 2 bodies, adding an embedded component to one of them will effect the
    // height of both (the rows "span" both bodies of course and we want them to match up).
    if (this.frozenBody != null) {
        var otherBody = body == this.frozenBody ? this.body : this.frozenBody;
        var isFrozenBody = otherBody == this.frozenBody ? 1 : 0;

        if (rowNum >= 0 && otherBody.isDrawn() && !otherBody.isDirty()) {
            var expectedRowHeight = otherBody.getRowHeight(record,rowNum,isFrozenBody);
            if (expectedRowHeight != body.getRowSize(rowNum)) {
                
                otherBody.markForRedraw();
            }
        }
    }

},

//> @method listGrid.removeEmbeddedComponent() [A]
// Removes an embedded component previously associated with the provided record. If a Canvas
// is passed as the <code>record</code> parameter, it is assumed to be a component and the
// record is detected automatically from it.  If
// <code>destroyOnUnEmbed</code> is <code>true</code> for the component, it will also be
// destroyed.
//
// @param record (ListGridRecord | Canvas) record that the component was previously attached
//     to or the component itself
// @param [component] (Integer | Canvas) component to unembed, or the colNum in which it appears
// @visibility external
//<
removeEmbeddedComponent : function (record, component, suppressRedraw) {
    var body;

    // support component passed as the "record" param - collect the record from the component
    if (isc.isA.Canvas(record)) {
        component = record;
        record = component.embeddedRecord;
    }

    // support a colNum passed as the "component" param
    if (isc.isA.Number(component)) {
        body = this.getFieldBody(component);
        component = this.getLocalFieldNum(component);
    } else {
        if (!component) {
            // no component passed - assume the first one on the record, if there are any
            // or bail otherwise
            if (!this._hasEmbeddedComponents(record)) return;
            component = this._getEmbeddedComponents(record)[0];
        }
        body = isc.Canvas.getById(component._embedBody);
    }
    
    if (body == null) {
        return;
    }
    body.removeEmbeddedComponent(record, component, suppressRedraw);
},

//> @method listGrid.getEmbeddedComponent() [A]
// Gets an embedded component previously associated with the provided record.
//
// @param record (ListGridRecord) record that the component was previously attached to
// @param colNum (Number) column in the grid from which to retrieve the component
// @return (Object) the embeddedComponent
// @visibility embeddedComponents
//<
getEmbeddedComponent : function (record, colNum) {
    var body;
    if (isc.isA.Number(colNum)) {
        body = this.getFieldBody(colNum);
        colNum = this.getLocalFieldNum(colNum);
    } else if (colNum == null) {
        // if no colNum was passed, assume this.body
        body = this.body;
    } else {
        // support "component" passed as an object
        body = isc.Canvas.getById(colNum._embedBody);
    }
    return body.getEmbeddedComponent(record, colNum);
},

//> @method listGrid.getRecordComponent()
// Retrieve the +link{showRecordComponents,recordComponent} currently being shown at the given
// coordinates.
// <p>
// <code>recordComponents</code> are dynamically assigned to row/cell coordinates and, depending
// on the +link{listGrid.recordComponentPoolingMode}, any kind of redraw of the containing
// ListGrid (due to sort change, scrolling, editing etc) may cause a
// <code>recordComponent</code> to be assigned to another row, +link{canvas.clear,clear()ed} or
// permanently +link{canvas.destroy,destroy()ed}.
// <p>
// Hence you should always call <code>getRecordComponent()</code> right before taking action on
// the <code>recordComponent</code> - don't cache the component associated with row/cell
// coordinate.  Similarly, it's invalid to call <code>getRecordComponent()</code> during a redraw
// (for example, from +link{listGridField.formatCellValue,formatting} code).
// <p>
// It's always invalid to try to use a <code>recordComponent</code> outside of a ListGrid (by eg
// adding it to some other layout).
// <p>
// If +link{showRecordComponentsByCell} is true and the colNum parameter is not passed, the call
// will return the first component in the passed rowNum.
// <p>
// Returns null if there is no component at the specified coordinates.
//
// @param rowNum (int) row number to get record component for
// @param [colNum] (integer) optional column number to get the record component for
// @return (Canvas) record component, or null if none is shown at these coordintes
// @visibility external
//<
getRecordComponent : function (rowNum, colNum) {
    var record = this.getRecord(rowNum);
    return this.getEmbeddedComponent(record, colNum);
},


// Embedded Editing
// --------------------------------------------------------------------------------------------
// "embedded editing" means editing with a complete DynamicForm as an embedded component
// appearing underneath the edited row.  This is distinct from "inline editing" where we place
// form items in individual cells, and can only edit the currently visible fields.

// get the DataSource for editing this record
getRecordDataSource : function (record) {
    return this.dataSource;
},

//> @method listGrid.openRecordEditor()           (A)
// Start editing a record, using an editor embedded in the row
//
// @param   record   (Object)            record whose detail records should be shown
// @visibility advancedInlineEdit
//<

openRecordEditor : function (record) {
    // don't allow more than one openRecord embedded component at once
    if (this._openRecord != null) this.closeRecord();

    
    var editValues = isc.addProperties({}, record);

    // create a form to edit the record
    var editor = this.ns.DynamicForm.create(
    this.recordEditorProperties,
    {
        autoDraw:false,
        dataSource : this.getRecordDataSource(record),
        numCols : 4,
        values : editValues,
        _embeddedEditRecord : record
    });
    // place it in a simple stack with a save button
    var component = this.ns.VStack.create({
        autoDraw:false,
        width:this.getAvailableFieldWidth() - this.embeddedComponentIndent,
        left:this.isRTL() ? 0 : this.embeddedComponentIndent,
        destroyOnUnEmbed:true,
        members:[
            editor,
            this.ns.Toolbar.create({
                autoDraw:false,
                width: 200,
                buttons : [
                    { title : this.recordEditorSaveButtonTitle,
                      click : this.getID() + ".embeddedSaveRecord(" + editor.getID() + ")",
                      extraSpace:10
                    },
                    { title : this.recordEditorCancelButtonTitle,
                      record : record,
                      grid : this,
                      click : function () {
                          var stack = this.parentElement.parentElement;
                          this.grid.closeRecord(this.record, stack);
                      }
                    }
                ]
            })
        ]
    });

    component.removeOnHideField = true;

    this.addEmbeddedComponent(component, record, this.data.indexOf(record));

    this._openRecord = record;
    this._openRecordComponent = component;
},

// when the user hits Save during embedded editing, tell the editor to save
embeddedSaveRecord : function (editor) {
    // hold onto the record via the context since we'll need it to get rid of the embedded editor
    editor.saveData({target:this, methodName:"embeddedEditComplete"},
                    {_embeddedEditRecord:editor._embeddedEditRecord,
                     _embeddedEditor:editor});
},

// when the save attempt completes, if there were no errors, remove the embedded editor.
// Otherwise leave it there to show validation errors and allow further editing
embeddedEditComplete : function (response, data, request) {
    if (response.status == 0) {
        this.removeEmbeddedComponent(request._embeddedEditRecord, request._embeddedEditor);
    }
},

//> @method listGrid.closeRecord()
// Close the currently shown embedded component.
//
// @visibility nestedGrid
//<
closeRecord : function (record, component) {
    if (!record) record = this._openRecord;
    if (!component) component = this._openRecordComponent;
    this.removeEmbeddedComponent(record, component);
    this._openRecord = null;
    this._openRecordComponent = null;
},

// Nested Master-Detail
// --------------------------------------------------------------------------------------------

//> @method listGrid.openRecordDetailGrid() (A)
// Show records from another DataSource which are related to this record, in a nested
// ListGrid.
// <P>
// This is often called a "master-detail" view.  The classic example is salesOrder records
// which contain lineItems.
// <P>
// The <code>childDS</code> should be a DataSource that declares a foreignKey relationship to
// the DataSource the current grid is viewing.
//
// @param   record   (Object)            record whose detail records should be shown
// @param   childDS  (DataSource or ID)  dataSource to retrieve detail records from
// @visibility nestedGrid
//<
openRecordDetailGrid : function (record, childDS) {
    // don't allow more than one openRecord embedded component at once
    if (this._openRecord != null) this.closeRecord();

    var subGrid = this.getRecordDetailGrid(record, childDS);
    // and embed it in the target record
    var component = isc.VLayout.create({
        autoDraw:false,
        destroyOnUnEmbed:true,
        height:this.cellHeight, // since the Layout is overflow:visible this is just a minimum
        left:this.isRTL() ? 0 : this.embeddedComponentIndent,
        width:this.getAvailableFieldWidth() - this.embeddedComponentIndent,
        resizeBarSize:4,
        members:[subGrid],
        removeOnHideField: true
    });

    this.addEmbeddedComponent(component, record, this.data.indexOf(record));

    var childDS = isc.DataSource.getDataSource(subGrid.dataSource);
    subGrid.fetchRelatedData(record, this.getRecordDataSource(record));

    this._openRecord = record;
    this._openRecordComponent = component;
},

//> @method listGrid.getRecordDetailGrid()  (A)
// Returns a ListGrid to show the records from another DataSource which are related to this
// record via a child dataSource
//
// @param   record   (Object)            record whose detail records should be shown
// @param   childDS  (DataSource or ID)  dataSource to retrieve detail records from
// @visibility internal
//<
getRecordDetailGrid : function (record, childDS) {

    childDS = isc.DataSource.getDataSource(childDS);

    // create a ListGrid to show them
    var subGrid =
        isc.ListGrid.create(
            this.recordDetailGridProperties,
            {
                autoDraw:false,
                dataSource:childDS,
                showResizeBar:true,
                // XXX the embedded grid needs to inherit a lot of properties from it's parent grid -
                // this particular one is critical because otherwise context menu events will bubble to
                // this grid, and it will show non-sequitur context menus on the embedded grid.
                showCellContextMenus:this.showCellContextMenus
            }, this.nestedGridDefaults
        );

    return subGrid;
},

// Charting
// ---------------------------------------------------------------------------------------

// types of charting:
// - take any single row and plot it as a single series
//   - field names label the values
// - take any single column and plot it as a single series
//   - values from another column label the values
// - take a set of rows and a set of columns and plot it as a multi-series
//   - dataset is 2d: both field names *and* values from another column label the values

//> @method listGrid.chartData()
// Chart the data in this listGrid as a multi-series chart.
// <P>
// Each row provides a series of data.  Each series of data is labeled by a value from one
// column, called the <code>labelField</code>.
// <P>
// For example, cell values are sales figures, and fields are "Product", "August",
// "September", "October".  In this case each row gives a series: sales figures for each of 3
// months.  The <code>labelField</code> in this case is the "Product" field, meaning each row
// represents sales figures for each of 3 months for a particular product.  This dataset
// can be charted via any multi-series chart: stacked or clustered bar or column chart, line
// chart with multiple lines, or area chart (stacked lines).
// <P>
// By default, all visible fields other than the label field are assumed to be labels for
// series values, but an explicit list of fields can be provided as <code>dataFields</code>.
// <P>
// By default, all data is charted if all data is loaded, otherwise, data visible in the
// viewport is charted.  An explicit set of rows can be provided via <code>dataRows</code>.
//
// @param labelField (String) name of the field
// @param [dataFields] (Array of String) optional list of fields to use as labels.  By
//      default, all fields are used.
// @param [dataRows] (Array of ListGridRecord) set of records to chart.  Can be obtained by eg
//      +link{ResultSet.getRange,grid.data.getRange()}.
// @param [chartProperties] (FacetChart Properties) properties to pass to the created chart
// @param [labelFieldFirst] (boolean) if true, use the labelField as the "first" set of labels,
//      for example, as the bar labels in a stacked bar chart, whereas the second set of labels
//      would appear as the legend.
//
// @return (FacetChart) created Chart instance
//
// @visibility external
// @example gridCharting
//<
chartData : function (labelField, dataFields, dataRows, properties, labelFieldFirst) {

    // verify the chartConstructor maps to a valid class (if not typically implies some module is
    // missing).
    this.checkChartConstructor();

    if (labelField) labelField = this.getField(labelField);
    if (dataFields) dataFields = this.map("getField", dataFields);
    else {
        // assume all fields other than a labelField contain values
        dataFields = this.fields.duplicate();
        dataFields.remove(labelField);
    }

    // default for dataRows: all rows, or visible rows if paging
    if (!dataRows) {
        if (!isc.ResultSet || !isc.isA.ResultSet(this.data)) {
            dataRows = this.data;
        } else if (this.data.allMatchingRowsCached()) {
            dataRows = this.data.getAllRows();
        } else {
            var visibleRows = this.getVisibleRows();
            dataRows = this.data.getRange(visibleRows[0], visibleRows[1]);
        }
    }

    // form a facet representing the column headers, aka, the fields.  This is an inlinedFacet,
    // meaning it has multiple values per record under property names indicated by its
    // facet.values
    var rowFacet, columnFacet;
    if (dataFields.length >= 1) {
        // give chart a simplified copy of the fields
        
        for (var i = 0; i < dataFields.length; i++) {
            var field = dataFields[i];
            dataFields[i] = {
                id: field.name,
                title: this.htmlUnescapeExportFieldValue(field.title),
                type: field.type
            }
        }
        columnFacet = {
            id:"columnFacet",
            title:this.valueTitle,
            values: dataFields,
            inlinedValues:true
        };
    }

    // form a facet representing row headers, aka, one column of data intended as labels
    if (dataRows.length >= 1 && labelField) {
        rowFacet = { id: labelField.name };
    }

    // remove unspecified facets to allow just single row or single column charting
    var facets = [columnFacet,rowFacet];
    facets.removeAll([null]);

    // for multi-series charts, allow specifying which facet comes first (eg, for stacked bar
    // charts, appears as a bar label (first) or appears as a legend labeling colors (second)
    if (labelFieldFirst) facets.reverse();

    var props = isc.addProperties({
        data: dataRows,
        facets: facets,
        title: this.chartTitle,
        chartType: this.chartType
    }, properties);

    // single column charting: the (singular) dataField holds the value
    if (rowFacet && !columnFacet) props.valueProperty = dataFields[0].name;
    // otherwise, we have an "inlinedValues" facet: there is no single valueProperty, rather
    // each record contains multiple values stored under the ids of the inlinedFacet's values

    return this.createAutoChild("chart", props, this.chartConstructor);
},

//> @attr listGrid.chartConstructor (Classname : "FacetChart" : IR)
// Name of the SmartClient Class to be used when creating charts.  Must support the
// +link{Chart} interface.
//
// @visibility external
//<
chartConstructor: "FacetChart",

// Helper method to verify that the chartConstructor is set to a valid Chart-based class name.
// Allows us to log a helpful warning when the developer attempts to chartData (or setEnableCharting
// for CubeGrids) if the chartConstructor is set to an unloaded class name.
checkChartConstructor : function () {
    var chartConstructor = this.chartConstructor;
    if (isc.isA.String(chartConstructor)) {
        chartConstructor = window.isc[this.chartConstructor];
    }

    if (chartConstructor == null) {

        this.logWarn('Component chartConstructor attribute set to "' + this.chartConstructor +
            '" - this cannot be resolved to a valid SmartClient class. Verify that all ' +
            'appropriate modules are loaded and that this class exists.');

    // In some cases if all required modules are not loaded,
    // we load a placeholder class to avoid actual JS errors.
    // In this case we mark the class object as "invalid" and provide a custom error message to
    // display
    
    } else if (chartConstructor.invalidClass) {
        var errorMessage = 'Component chartConstructor attribute set to "' + this.chartConstructor
                    + '". ';

        if (chartConstructor.invalidErrorMessage) errorMessage += chartConstructor.invalidErrorMessage;
        else errorMessage += ".This class is invalid - verify all appropriate modules are loaded.";

        this.logWarn(errorMessage);
    }

},


//> @attr listGrid.chartType (ChartType : "Column" : IRW)
// Default type of chart to plot.
//
// @visibility external
//<
chartType: "Column",


//> @method listGrid.chartRow()
// Chart a single row of data, with each cell value labeled by the column header.
//
// @param rowNum (Number) row to chart
// @param [dataFields] (Array of String) optional list of fields to use as labels.  By
//      default, all fields are used.
// @param [chartProperties] (Chart Properties) properties to pass to the created chart
// @return (Chart) created Chart instance
//
// @visibility external
//<
chartRow : function (rowNum, dataFields, chartProperties) {
    return this.chartData(null, dataFields, [this.getRecord(rowNum)], chartProperties);
},

//> @method listGrid.chartColumn()
// Chart a single column of data, with each cell value labeled by a value from another
// column.
//
// @param dataColumn (String) name of the ListGridField to use as a data
// @param labelColumn (String) name of the ListGridField to use as labels for data
// @param [chartProperties] (Chart Properties) properties to pass to the created chart
// @return (Chart) created Chart instance
//
// @visibility external
//<
chartColumn : function (dataColumn, labelColumn, chartProperties) {
    return this.chartData(labelColumn, [dataColumn], null, chartProperties);
},

// Grouping
// --------------------------------------------------------------------------------------------
// perform the actual operation of grouping the grid. Takes listgrid.data as input,
// and rewrites it (it is also an output); it stores the original object reference in
// listgrid.originalData.


groupIdField: "groupId",
groupParentIdField: "groupParentId",


//> @method listGrid.regroup()
// Programmatically regroup the grid according to the current grouping configuration.
//
// @see listGrid.groupBy()
// @visibility external
//<

regroup : function (fromSetData) {
    
    
    var asyncRegroupInProgress = this._asyncRegroupInProgress,
        currData;

    // This function is responsible for knowing if grouping ought to be performed.
    // Check all reasonable things here.
    // don't enforce canGroupBy here, so that programmatic grouping can take place
    // even if canGroupBy is false
    var isGrouped = this._isGrouped || this.isGrouped,
        groupFields = isGrouped && (this._groupByFields || this.getGroupByFields()),
        setOriginalDataToCurrData = false;

    if (!isGrouped ||
        groupFields == null || groupFields.length == 0 ||
        this.inhibitRegroup || !(this.originalData || this.data) ||
        // sanity check in case regroup is somehow triggered when data has not been loaded yet
        !this.data)
    {
        currData = null;
    } else {
        // if this.data already contains a grouped grid, use the original source
        // data instead.
        if (this.data.isGroupedOutput && this.originalData) {
            currData = this.originalData;
        } else {
            currData = this.data;

            // this.originalData will be set to currData after the (possibly asynchronous)
            // regroup has finished.
            setOriginalDataToCurrData = true;
        }
    }

    if (currData != null) {
        // Ensure all rows are read and available.
        var len = currData.getLength();
        if (isc.ResultSet && isc.isA.ResultSet(currData)
            && (!currData.lengthIsKnown() ||
                (len <= this.groupByMaxRecords && !currData.rangeIsLoaded(0, len - 1))))
        {
            // getRange will kick off the fetch to pick up a full set of data then _markForRegroup
            // ensures we regroup.
            currData.getRange(0, len);
            this._setMarkForRegroup(true, false, true, false, false, groupFields);
            this.logInfo("postponing grouping until data is loaded", "grouping");
            if (setOriginalDataToCurrData) {
                this.originalData = currData;
            }
            this._suppressRedrawOnDataChanged = true;
            return;
        } else if (len > this.groupByMaxRecords) {
            // If there are too many rows, don't group and display the original data.
            this.logInfo("Results too numerous - disabling grouping.", "grouping");
            if (asyncRegroupInProgress) {
                // Cancel the timer and clear the prompt.
                delete this._asyncRegroupInProgress;
                delete this._asyncRegroupBaton;

                isc.Timer.clear(this._regroupTimerEvent);
                delete this._regroupTimerEvent;
                isc.clearPrompt();

                // Setting of two properties were postponed until the
                // asynchronous regroup finished and now they need to be set.
                this.setGroupByFieldSummaries(this._newGroupByFieldSummaries);
                this.setShowGroupSummary(this._newShowGroupSummary);
                
            }
            this.clearGroupBy();
            if (setOriginalDataToCurrData) {
                this.originalData = currData;
            }
            if (!this.selection || (this.data != this.selection.data)) {
                this.createSelectionModel();
            }
            
            // Fire the groupByComplete notification to let the dev know that
            // a grouping attempt failed (or was undone by extra data)
            if (this.groupByComplete != null) this.groupByComplete([]);
            
            return;
        }
    } else {
        if (asyncRegroupInProgress) {
            // regroup() was called while another asynchronous regroup was running.
            // Clear the timer and prompt.
            delete this._asyncRegroupInProgress;
            delete this._asyncRegroupBaton;

            isc.Timer.clear(this._regroupTimerEvent);
            delete this._regroupTimerEvent;
            isc.clearPrompt();

            // Setting of two properties were postponed until the
            // asynchronous regroup finished and now they need to be set.
            this.setGroupByFieldSummaries(this._newGroupByFieldSummaries);
            this.setShowGroupSummary(this._newShowGroupSummary);
        }
        return;
    }
    this._setMarkForRegroup(false, false, true, false, false);
    // If this regroup was caused by a call to groupBy() then the `fields` argument will be
    // saved in the `_groupByCompleteFieldsAfterRegroup` property.
    var fields = this._groupByCompleteFieldsAfterRegroup;
    
    delete this._suppressRedrawOnDataChanged;

    var async = (currData.getLength() > this.groupByAsyncThreshold);
    if (asyncRegroupInProgress && async) {
        // An asynchronous regroup has already begun but regroup() has now been
        // called before it completed.  Cancel the timer but keep the prompt.
        // The flag this._asyncRegroupInProgress is still true.
        isc.Timer.clear(this._regroupTimerEvent);
        delete this._asyncRegroupBaton;
        delete this._regroupTimerEvent;
    } else if (asyncRegroupInProgress && !async) {
        // An asynchronous regroup has already begun but regroup() has now
        // been called before it completed.  The current regrouping will
        // be performed synchronously so cancel the timer and clear the prompt.
        delete this._asyncRegroupInProgress;
        delete this._asyncRegroupBaton;

        isc.Timer.clear(this._regroupTimerEvent);
        delete this._regroupTimerEvent;
        isc.clearPrompt();

        // Setting of two properties were postponed until the
        // asynchronous regroup finished and now they need to be set.
        this.setGroupByFieldSummaries(this._newGroupByFieldSummaries);
        this.setShowGroupSummary(this._newShowGroupSummary);
    } else if (!asyncRegroupInProgress && async) {
        // A new asynchronous regrouping will be started - so, unless showAsynchGroupingPrompt
        // is false, set the prompt
        if (this.showAsynchGroupingPrompt != false) isc.showPrompt(this.asynchGroupingPrompt);
        this._asyncRegroupInProgress = true;

        // Save the current settings of two properties that affect whether
        // group summary rows will be shown in the groupTree.  When the
        // _asyncRegroupInProgress flag is cleared then these two properties
        // will be checked again to see if the group summary rows need
        // to be updated.
        this._newShowGroupSummary = this.showGroupSummary;
        this._newGroupByFieldSummaries = this.groupByFieldSummaries;
    }

    // Assemble the list of field names to group by.
    var groupByField = this.groupByField,
        groupByFieldGroupingModes = null;
    if (fields != null) {
        
        groupByField = [];
        groupByFieldGroupingModes = [];
        for (var i = 0; i < fields.length; i++) {
            // Don't allow the checkbox field to be grouped; Shouldn't be possible, but check
            // just in case.
            if (this.isCheckboxField(fields[i])) continue;
            var hasProperty = fields[i].property,
                fieldName, field;
            if (hasProperty) {
                // If the field has a displayField and no optionDataSource, use the
                // displayField instead of the actual field passed in.
                fieldName = fields[i].property;
                field = this.getUnderlyingField(fieldName);
            } else {
                // If the field has a displayField and no optionDataSource, use the
                // displayField instead of the actual field passed in.
                fieldName = fields[i];
                field = this.getUnderlyingField(fieldName);
            }
            if (field && field.displayField != null && field.optionDataSource == null) {
                var fieldToDisplay = this.getField(field.displayField);
                if (fieldToDisplay) {
                    field = fieldToDisplay;
                    if (field.displayField != null) fieldName = field.displayField;
                    else fieldName = field.name;
                }
            }
            groupByField.add(fieldName);
            var specifier;
            if (field && this._groupSpecifiers) {
                specifier = this._groupSpecifiers.find("property", fields[i]);
                if (specifier) {
                    // there's a groupSpecifier for the fieldName - set its properties on the field
                    field.groupingMode = specifier.grouping;
                    field.groupGranularity = specifier.granularity;
                    field.groupPrecision = specifier.precision;
                }
            }
            // Initialize groupingMode if groupingModes is defined.
            var groupingMode = (hasProperty ? fields[i].grouping : null);
            if (field) {
                if (!hasProperty) {
                    groupingMode = field.groupingMode;
                }
                var groupingModes = field.groupingModes ||
                        (field._simpleType ? (field._simpleType.getGroupingModes ?
                                             field._simpleType.getGroupingModes() :
                                             field._simpleType.groupingModes) : null )
                ;
                if (groupingMode == null && groupingModes != null) {
                    var defaultMode = field.defaultGroupingMode || 
                            (field._simpleType && field._simpleType.defaultGroupingMode);
                    if (isc.isAn.Array(groupingModes)) {
                        if (groupingModes.contains(defaultMode)) groupingMode = defaultMode;
                        else if (groupingModes.length > 0)       groupingMode = groupingModes[0];
                    } else if (isc.isAn.Object(groupingModes)) {
                        if (groupingModes[defaultMode] != null)  groupingMode = defaultMode;
                    }
                    // Note that the `groupingMode` is not saved to the field until
                    // _regroupFinish() is called.
                }
            }
            groupByFieldGroupingModes.push(groupingMode);
        }
    }
    var groupByFields = (
            groupByField != null && !isc.isAn.Array(groupByField) ?
                [groupByField] : groupByField),
        groupingMode = null;
    // If groupingModes is present, make sure to clear groupingMode.
    if (groupByFields != null) {
        for (var i = 0; i < groupByFields.length; i++) {
            var field = this.getUnderlyingField(groupByFields[i]),
                fieldGroupingMode = (
                    (groupByFieldGroupingModes != null &&
                        groupByFieldGroupingModes[i] != null) ?
                            groupByFieldGroupingModes[i] : field.groupingMode);
            if (fieldGroupingMode && 
                    (!isc.isAn.Array(groupByField) ? field.name == groupByField :
                    groupByField.contains(field.name))) 
            {
                groupingMode = fieldGroupingMode;
            }
        }
    }

    
    var baton = {
        applyFormulaAfterSummary: this.applyFormulaAfterSummary,
        emptyCellValue: this.emptyCellValue,
        gridSummaryRecordProperty: this.gridSummaryRecordProperty,
        groupByFieldSummaries: (
            isc.isAn.Array(this.groupByFieldSummaries) ?
                this.groupByFieldSummaries.duplicate() : null),
        groupNodeBaseStyle: this.groupNodeBaseStyle,
        groupNodeStyle: this.groupNodeStyle,
        groupStartOpen: (
            isc.isAn.Array(this.groupStartOpen) ?
                this.groupStartOpen.duplicate() : this.groupStartOpen),
        groupSummaryRecordProperty: this.groupSummaryRecordProperty,
        includeInSummaryProperty: this.includeInSummaryProperty,
        nullGroupTitle: this.nullGroupTitle,
        recordBaseStyleProperty: this.recordBaseStyleProperty,
        recordCustomStyleProperty: this.recordCustomStyleProperty,
        recordEditProperty: this.recordEditProperty,
        showCollapsedGroupSummary: this.showCollapsedGroupSummary,
        showGroupSummary: this.showGroupSummary,
        showGroupSummaryInHeader: this.showGroupSummaryInHeader,
        singleCellValueProperty: this.singleCellValueProperty,

        // Use this instead of `this.getGroupByFields()` during regrouping:
        groupByField: groupByField,
        groupByFields: groupByFields,
        groupByFieldGroupingModes: groupByFieldGroupingModes,
        groupingMode: groupingMode,

        currData: currData,
        setOriginalDataToCurrData: setOriginalDataToCurrData,

        
        sortSpecifiers: isc.isAn.Array(this._sortSpecifiers) ? 
                 this._addImplicitSort(this._sortSpecifiers.duplicate(), groupByFields) : null
    };
    this._asyncRegroupBaton = baton;
    
    
    // Also save all mutable state of the ListGridFields that can be referenced during
    // asynchronous regrouping.
    var fieldsHaveUserFormulas = new Array(this.fields.getLength()),
        fieldsHaveUserSummaries = new Array(this.fields.getLength());
        for (var i = fieldsHaveUserFormulas.length; i--; ) {
            var field = this.fields[i];
            fieldsHaveUserFormulas[i] = field && field.userFormula != null;
            fieldsHaveUserSummaries[i] = field && field.userSummary != null;
        }
    baton.fieldsHaveUserFormulas = fieldsHaveUserFormulas;
    baton.fieldsHaveUserSummaries = fieldsHaveUserSummaries;
    var groupByFieldUserFormulas = new Array(groupByFields.length),
        groupByFieldUserSummaries = new Array(groupByFields.length),
        groupByFieldDisplayFields = new Array(groupByFields.length),
        groupByFieldValueMaps = new Array(groupByFields.length);
    for (var i = groupByFields.length; i--; ) {
        var field = this.getUnderlyingField(groupByFields[i]);
        if (field) {
            groupByFieldUserFormulas[i] = isc.clone(field.userFormula);
            groupByFieldUserSummaries[i] = isc.clone(field.userSummary);
            groupByFieldDisplayFields[i] = field.displayField;

            var valueMap = field.valueMap;
            if (isc.isAn.Array(valueMap)) {
                groupByFieldValueMaps[i] = valueMap.duplicate();
            } else {
                groupByFieldValueMaps[i] = isc.shallowClone(valueMap);
            }
        }
    }
    baton.groupByFieldUserFormulas = groupByFieldUserFormulas;
    baton.groupByFieldUserSummaries = groupByFieldUserSummaries;
    baton.groupByFieldDisplayFields = groupByFieldDisplayFields;
    baton.groupByFieldValueMaps = groupByFieldValueMaps;

    // Regrouping is performed with a sequence of function calls:
    // _regroupRestoreOpenFolder(), _regroupAddNodeToOpenState(),
    // _regroupCreateGroupTree(), _regroupAddRecordsToGroup(),
    // _regroupAddSummaryChildren(), _regroupProcessGroupHeaderNode(),
    // _regroupOpenInitialGroups(), _regroupCreateSelectionModel(),
    // _regroupGetGroupTreeLength(), _regroupCacheSelectionModel(),
    // and finally _regroupFinish().
    // If async is true, then the methods may run asynchronously to
    // perform work in batches of size groupByAsyncThreshold.
    // Each method calls itself with delay 0 until its work is completed
    // and then it calls the next method in the sequence.
    // Each function in the sequence passes the baton object
    // through the next asynchronous call (it is storage for variable
    // assignments that will be needed later in the sequence).
    this._regroupRestoreOpenFolders(async, baton, fromSetData);
},

_regroupRestoreOpenFolders : function (async, baton, fromSetData) {
    
    var restoreOpenFolders;
    if (this.groupTree) {
        // If we have valid data already, and haven't changed our set of group-by-fields, we'll
        // want to retain our current folder open/closed state
        // Suppress this if canCollapseGroup is false as in that case we always want to open
        // all group members.
        // Also suppress if coming from setData() since we'll have a new data set and should
        // initialize it with standard open state.
        
        var treeGroupField = this.groupTree._groupByField,
            sameGroupByFields = (treeGroupField == baton.groupByField)
        ;
        if (isc.isAn.Array(treeGroupField)) {
            var batonFields = baton.groupByField.duplicate(),
                groupTreeFields = treeGroupField.duplicate()
            ;
            if (batonFields.length != groupTreeFields.length) sameGroupByFields = false;
            else {
                batonFields.removeList(groupTreeFields);
                sameGroupByFields = (batonFields.length == 0)
            }
        }
        if (!fromSetData && this.canCollapseGroup &&
            this.retainOpenStateOnRegroup &&
            (this.groupTree.getLength() > 0) &&
            (sameGroupByFields))
        {
            // if grouping mode had been changed for our groupField we should not persist
            // open/close state for folders
            if (this.groupTree._groupingMode == baton.groupingMode) {
                restoreOpenFolders = [];

                var tree = this.groupTree,
                    node = tree.getRoot();
                if (tree.isOpen(node) && tree.isLoaded(node)) {
                    var stack = [[tree.getFolders(node)], [0]];
                    if (async) {
                        this._regroupTimerEvent = this.delayCall(
                            "_regroupAddNodeToOpenState",
                            [async, baton, stack, tree, restoreOpenFolders], 0);
                    } else {
                        this._regroupAddNodeToOpenState(
                            async, baton, stack, tree, restoreOpenFolders);
                    }

                    // _regroupAddNodeToOpenState() will call _regroupCreateGroupTree().
                    return;
                }
            }
        }
    }

    this._regroupCreateGroupTree(async, baton, baton.currData, restoreOpenFolders);
},

// Similar to ListGrid._addNodeToOpenState(), but rewritten to work asynchronously in batches
// of size groupByAsyncThreshold.
_regroupAddNodeToOpenState : function (async, baton, stack, tree, openState) {
    
    var childrenStack = stack[0],
        indexStack = stack[1],
        stackCount = childrenStack.length,
        recordCount = 0;

    while (stackCount > 0) {
        var children = childrenStack.pop(),
            i = indexStack.pop();
        --stackCount;

        for (var len = children.length; i < len; ++i, ++recordCount) {
            if (async && recordCount > this.groupByAsyncThreshold) {
                childrenStack.push(children);
                indexStack.push(i);
                this._regroupTimerEvent = this.delayCall(
                    "_regroupAddNodeToOpenState",
                    [async, baton, stack, tree, openState], 0);
                return;
            }

            var node = children[i];
            if (tree.isOpen(node) && tree.isLoaded(node)) {
                var folderInfo = {};
                folderInfo[node.groupName] = node.groupValue;
                openState.add(folderInfo);

                var grandChildren = tree.getFolders(node);
                if (grandChildren != null) {
                    childrenStack.push(children);
                    indexStack.push(i + 1);
                    ++stackCount;

                    children = grandChildren;
                    i = -1;
                    len = children.length;
                }
            }
        }
    }

    if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupCreateGroupTree",
            [async, baton, baton.currData, openState], 0);
    } else {
        this._regroupCreateGroupTree(async, baton, baton.currData, openState);
    }
},

_regroupCreateGroupTree : function (async, baton, currData, restoreOpenFolders) {
    
    
    
        var groupTree = this.createAutoChild("groupTree", {

        // specify idField and parentIdField explicitly
        // Note these field values are arbitrary as we explicitly add nodes to the tree
        idField:this.groupIdField,
        parentIdField: this.groupParentIdField,
        titleProperty: "groupValue",
        childrenProperty: "groupMembers",
        parentProperty: "_groupTree_" + this.ID,
        showRoot: false,
        isGroupedOutput: true,
        nameProperty:"_name",
        
        // _groupByField is used when sorting - we skip sorting on group headers unless sorting
        // by the group-by-field. Implemented in Tree.js
        // Exception - if showing summaries in headers we want to allow the user to sort the
        // group headers
        
        alwaysSortGroupHeaders: (baton.showGroupSummary && baton.showGroupSummaryInHeader),
        _groupByField: baton.groupByField,
        _groupByFields: baton.groupByFields,
        _groupingMode: baton.groupingMode,
        separateFolders: true,

        // Define a property used to flag the summary records
        _summaryRecordFlag: "_summaryRecordFlag",
        _summaryTargetNode: "_summaryTargetNode",

        // copy sort specifiers across
        
        _sortSpecifiers: baton.sortSpecifiers,

        // Implement 'getCriteria()' so "getCriteria()" on the grid as a whole works.
        // Note that DBC.updateDataModel handles applying criteria directly to the underlying
        // resultSet and regrouping so the "originalData" object always has the
        // most current criteria applied to it.
        getCriteria: function () {
            var originalData = this.creator.originalData;
            if (originalData && originalData.getCriteria) return originalData.getCriteria();
            return null;
        },

        // Given a group, returns the live records within it. Handles nested groups by reaching
        // into the sub-tree for outer groups.
        getRecordsInGroup : function (node) {
            var groupByFields = this._groupByFields,
                group = node.groupName,
                children = this.getChildren(node),
                records = [];

            if (group == groupByFields[groupByFields.length-1]) {
                if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                    for (var i = children.getLength(); i--; ) {
                        var child = children.getCachedRow(i);
                        if (child != null && child[this._summaryRecordFlag] !== true) {
                            records.add(child);
                        }
                    }
                }
            } else if (children != null) {
                if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                    for (var i = 0, length = children.getLength(); i < length; ++i) {
                        var child = children.getCachedRow(i);
                        if (child != null) {
                            var subRecords = this.getRecordsInGroup(child);
                            if (subRecords != null && subRecords.length > 0) {
                                records.addList(subRecords);
                            }
                        }
                    }
                }
            }
            return records;
        },

        combineWithEditVals : function (children) {
            var grid = this.creator,
                summaryChildren = [];
            summaryChildren.addList(children);

            // if the grid has any edited rows, pass the 'edited' record objects to
            // the summary function so we pick up user edits
            var editRows = grid.getAllEditRows();
            if (editRows.length > 0) {
                var editedInGroup;
                for (var i = 0; i < summaryChildren.length; i++) {
                    var editSession = grid.getEditSession(summaryChildren[i]);
                    if (editSession) {
                        
                        var editedRecord = isc.addProperties({},
                                                            summaryChildren[i],
                                                            editSession._editValues);
                        summaryChildren[i] = editedRecord;
                    }
                }
            }
            return summaryChildren;
        },

        // override indexOf to handle being passed primary keys!
        primaryKeyFields:this.dataSource?this.getDataSource().getPrimaryKeyFieldNames():null,
        indexOf : function (node, pos, endPos) {
            // This can be called in inner for loops (for example during regrouping).
            
            var openList = this._getOpenList(),
                findKeys, hasKeys,
                index = -1;
            
            if (this.primaryKeyFields != null) {
                
                var keyFields = this.primaryKeyFields;
                findKeys = {};
                
                for (var i = 0; i < keyFields.length; i++) {
                    var keyField = keyFields[i];
                    if (node[keyField] == null) {
                        hasKeys = false;
                        break;
                    } else {
                        hasKeys = true;
                        findKeys[keyField] = node[keyField];
                    }
                }
            }
            
            if (hasKeys) {
                // go through the recordSet looking for a record with the same values for 
                // the primary keys
                index = openList.findNextIndex(pos, findKeys, null, endPos);
            } else {
                index = openList.indexOf(node, pos, endPos);
            }
            return index;
        },

        // An asynchronous version of Tree.openAll() which operates in batches of
        // size batchSize.
        _openAllAsync : function (node, callback, batchSize, timerEventPropName) {
            if (!node) node = this.root;

            var getDescendantsAsyncCallback = function (nodeList, i) {
                if (i == null) {
                    i = 0;
                }
                for (var j = 0, length = nodeList.length; j < batchSize && i < length; ++i, ++j) {
                    // if the node is not already set to the newState
                    if (!this.isOpen(nodeList[i])) {
                        // call the dataChanged method to notify anyone who's observing it
                        this.changeDataVisibility(nodeList[i], true);
                    }
                }
                if (i < length) {
                    getDescendantsAsyncCallback.apply(this, [nodeList, i]);
                } else {
                    // make the node itself open
                    this.changeDataVisibility(node, true);
                    callback.apply(this, []);
                }
            };

            this._getDescendantsAsync(node, isc.Tree.FOLDERS_ONLY, null, getDescendantsAsyncCallback, batchSize, timerEventPropName);
        },

        // An asynchronous version of Tree.getDescendants() that works in batches of size batchSize.
        // node, displayNodeType, and condition are the original arguments, and callback, batchSize,
        // timerEventPropName, list, stack are additional arguments.  The callback is called after
        // all work is performed.  The total work performed by this method is split into batches of
        // work proportional to batchSize.  The list argument holds the eventual return value.
        // The stack argument holds iteration state that is passed between asynchronous invocations
        // of this method.  timerEventPropName identifies a property of the list grid in which to
        // store any timer events created.
        _getDescendantsAsync : function (node, displayNodeType, condition, callback, batchSize, timerEventPropName, list, stack) {
            var childrenStack, indexStack;
            if (list == null) {
                if (!node) node = this.root;

                // create an array to hold the descendants
                list = [];

                // if condition wasn't passed in, set it to an always true condition
                // XXX convert this to a function if a string, similar to getChildren()
                if (!condition) condition = function(){return true};

                // if the node is a leaf, return the empty list
                if (this.isLeaf(node)) {
                    callback.apply(this, [list]);
                    return;
                }

                // iterate through all the children of the node
                // Note that this can't depend on getChildren() to subset the nodes,
                //    because a folder may have children that meet the criteria but not meet the criteria itself.
                var children = this.getChildren(node);
                if (!children) {
                    callback.apply(this, [list]);
                    return;
                }

                childrenStack = [children];
                indexStack = [0];
                stack = { childrenStack: childrenStack, indexStack: indexStack };
            } else {
                childrenStack = stack.childrenStack;
                indexStack = stack.indexStack;
            }
            var stackCount = childrenStack.length,
                recordCount = 0;

            while (stackCount > 0) {
                var children = childrenStack.pop(),
                    i = indexStack.pop();
                --stackCount;

                // for each child
                if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                    for (var length = children.getLength(); i < length; ++i, ++recordCount) {

                        if (recordCount > batchSize) {
                            childrenStack.push(children);
                            indexStack.push(i);
                            this.creator[timerEventPropName] = this.delayCall(
                                "_getDescendantsAsync",
                                [node, displayNodeType, condition, callback, batchSize, timerEventPropName, list, stack], 0);
                            return;
                        }

                        // get a pointer to the child
                        var child = children.getCachedRow(i);

                        if (child != null) {
                            // if that child is a folder
                            if (this.isFolder(child)) {
                                // if we're not exluding folders, add the child
                                if (displayNodeType != isc.Tree.LEAVES_ONLY && condition(child))
                                    list[list.length] = child;

                                // now concatenate the list with the descendants of the child
                                var grandChildren = this.getChildren(child);
                                if (grandChildren) {
                                    childrenStack.push(children);
                                    indexStack.push(i + 1);
                                    ++stackCount;
                                    children = grandChildren;
                                    i = -1;
                                    length = children.getLength();
                                }
                            } else {
                                // if we're not excluding leaves, add the leaf to the list
                                if (displayNodeType != isc.Tree.FOLDERS_ONLY && condition(child)) {
                                    list[list.length] = child;
                                }
                            }
                        }
                    }
                }
            }

            // finally, return the entire list
            callback.apply(this, [list]);
        },

        addBeforeSummaries : function (record, currRoot) {
            var children = this.getChildren(currRoot);

            var targetIndex = children ? children.length : null;
            while (targetIndex > 0 &&
                   children && children[targetIndex-1][this._summaryRecordFlag])
            {
                targetIndex --;
            }
            this.add(record, currRoot, targetIndex);
        },

        
        _markForUpdateSummaryRows : function (groupNodes, fastChildren, nodeList) {
            if (!isc.isAn.Array(groupNodes)) groupNodes = [groupNodes];

            for (var i = 0; i < groupNodes.length; i++) {
                var originalNode = groupNodes[i];
                
                if (originalNode != null && !originalNode._isGroup) {
                    originalNode = this.getParent(originalNode);
                }
                if (!originalNode || !originalNode._isGroup) continue;

                var parents = this.getParents(originalNode);
                parents.unshift(originalNode);
                for (var j = parents.length - 2; j >= 0; j--) {
                    var node   = parents[j];
                    if (node._refreshGroup == null) {
                        node._refreshGroup = true;
                        if (fastChildren) {
                            var parent = parents[j+1];
                            if (!parent._dirtyChildren) parent._dirtyChildren = [];
                            parent._dirtyChildren.add(node);
                        } else if (nodeList) {
                            nodeList.add(node);
                        }
                    }
                }
            }
            if (nodeList) return nodeList;
        },

        _getDirtyGroups : function (node) {
            var dirtyChildren = node._dirtyChildren;
            if (!dirtyChildren) return [];
            delete node._dirtyChildren;
            return dirtyChildren;
        }
    }, isc.Tree);

    this.logInfo("Adding " + currData.getLength() + " records to groups", "grouping");

    // Create grouped tree from flat data, set group titles (traversing the tree in level order),
    // then finish the grouping and redraw.
    if (async) {
        this._regroupTimerEvent = this.delayCall(
                "_regroupAddRecordsToGroup",
                [async, baton, groupTree, currData, 0, currData.getLength(), restoreOpenFolders], 0);
    } else {
        this._regroupAddRecordsToGroup(
            async, baton, groupTree, currData, 0, currData.getLength(), restoreOpenFolders);
    }
},

_regroupAddRecordsToGroup : function (async, baton, groupTree, currData, startIndex, endIndex, restoreOpenFolders) {
    
    
    var finalIndex = endIndex;
    if (async) {
        endIndex = Math.min(startIndex + this.groupByAsyncThreshold, finalIndex);
    }

    // create grouped tree from flat data
    var loadingMarker = (
            isc.ResultSet && isc.isA.ResultSet(currData) ?
                isc.ResultSet.getLoadingMarker() : null);
    
    var dataOpenList;
    if (this.groupTree == this.data) {
        dataOpenList = this.data._getOpenList();
    }    
    for (var i = startIndex; i < endIndex; ++i) {
        var record = currData.get(i);
        if (record != null && record != loadingMarker) {
            this.__addRecordToGroup(
                baton.groupByFields, this.data, baton.emptyCellValue,
                baton.groupSummaryRecordProperty, baton.gridSummaryRecordProperty,
                baton.fieldsHaveUserFormulas, baton.fieldsHaveUserSummaries,
                baton.applyFormulaAfterSummary, baton.groupByFieldUserFormulas,
                baton.groupByFieldUserSummaries, baton.groupByFieldDisplayFields,
                baton.groupByFieldValueMaps, baton.nullGroupTitle, baton.showGroupSummary,
                baton.showGroupSummaryInHeader, baton.recordBaseStyleProperty,
                baton.groupNodeBaseStyle, baton.recordCustomStyleProperty,
                baton.groupNodeStyle, baton.recordEditProperty, baton.singleCellValueProperty,
                groupTree, record, false, restoreOpenFolders, dataOpenList);
        }
    }

    if (async && endIndex < finalIndex) {
        this._regroupTimerEvent = this.delayCall(
                "_regroupAddRecordsToGroup",
                [async, baton, groupTree, currData, endIndex, finalIndex, restoreOpenFolders], 0);

    } else if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupAddSummaryChildren", [async, baton, groupTree], 0);
    } else {
        this._regroupAddSummaryChildren(async, baton, groupTree);
    }
},

// Adds the initial group summary rows, if any, to the groupTree.
_regroupAddSummaryChildren : function (async, baton, groupTree) {
    
    this.__updateSummaryRows(
        baton.showGroupSummaryInHeader, baton.groupByFields, baton.showCollapsedGroupSummary,
        baton.includeInSummaryProperty, baton.applyFormulaAfterSummary,
        baton.groupSummaryRecordProperty, baton.fieldsHaveUserFormulas, groupTree, null,
        baton.showGroupSummary, [], baton.groupByFieldSummaries);
    if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupProcessGroupHeaderNode", [async, baton, groupTree], 0);
    } else {
        this._regroupProcessGroupHeaderNode(async, baton, groupTree);
    }
},

// Helper method to add/update/remove group summary rows from the groupTree in response to
// changes to the showGroupSummary or groupByFieldSummaries properties of the ListGrid.
// Also handles refreshing summaries to react to data change (see refreshGroupSummary)
_updateSummaryRows : function (
    tree, prevShowGroupSummary, showGroupSummary,
    prevGroupByFieldSummaries, groupByFieldSummaries,
    refreshExisting, records, fields)
{
    return this.__updateSummaryRows(
        this.showGroupSummaryInHeader, this.getGroupByFields(), this.showCollapsedGroupSummary,
        this.includeInSummaryProperty, this.applyFormulaAfterSummary,
        this.groupSummaryRecordProperty, null, tree, prevShowGroupSummary, showGroupSummary,
        prevGroupByFieldSummaries, groupByFieldSummaries, refreshExisting, records, fields);
},
__updateSummaryRows : function (
    showGroupSummaryInHeader, groupByFields, showCollapsedGroupSummary,
    includeInSummaryProperty, applyFormulaAfterSummary, groupSummaryRecordProperty,
    fieldsHaveUserFormulas, tree, prevShowGroupSummary, showGroupSummary,
    prevGroupByFieldSummaries, groupByFieldSummaries, refreshExisting, records, fields)
{
    if (showGroupSummaryInHeader) {
        // In this case the group summaries are not displayed as extra leaves in the tree
        // and so there are no summary rows that need to be added/updated.
        return;
    }

    // A null setting of groupByFieldSummaries means that summaries for all of the groupBy
    // fields should be calculated.
    if (!isc.isAn.Array(prevGroupByFieldSummaries)) {
        prevGroupByFieldSummaries = groupByFields;
    }
    if (!isc.isAn.Array(groupByFieldSummaries)) {
        groupByFieldSummaries = groupByFields;
    }

    // Determine if there is a change in the showGroupSummary property that
    // would require the groupTree to be traversed to add/remove summary rows.
    var addedSummaries,
        removedSummaries,
        refreshSummaries;
    if (!(prevShowGroupSummary || showGroupSummary)) {
        // No group summary rows are currently showing or need to be shown, so
        // there is nothing to do.
        return;
    // Were showing, no longer are...
    } else if (prevShowGroupSummary && !showGroupSummary) {
        removedSummaries = prevGroupByFieldSummaries;
    // Were not showing, but are now
    } else if (!prevShowGroupSummary && showGroupSummary) {
        addedSummaries = groupByFieldSummaries;
    // Were showing, and still are (but may be different fields)
    } else {
        removedSummaries = [];
        if (groupByFieldSummaries) {
            for (var i = prevGroupByFieldSummaries.length; i--; ) {
                var summary = prevGroupByFieldSummaries[i];
                if (!groupByFieldSummaries.contains(summary)) {
                    removedSummaries.push(summary);
                }
            }
        }

        addedSummaries = [];
        refreshSummaries = [];
        for (var i = groupByFieldSummaries.length; i--; ) {
            var summary = groupByFieldSummaries[i];
            if (!prevGroupByFieldSummaries.contains(summary)) {
                addedSummaries.push(summary);
            } else if (refreshExisting) {
                refreshSummaries.push(summary);
            }
        }
    }
    if (!(addedSummaries && addedSummaries.length > 0) &&
        !(removedSummaries && removedSummaries.length > 0) &&
        !(refreshSummaries && refreshSummaries.length > 0)
       )
    {
        // There is nothing to do.
        return;
    }

    // If showCollapsedGroupSummary is true, add summary rows as
    // siblings of the group header rather than children. This ensures
    // they show up after the group members if the group is expanded, and
    // after the group header if the group is collapsed.
    
    var summariesAreSiblings = showCollapsedGroupSummary,
        fastChildren = records != null && !summariesAreSiblings;

    if (records != null) tree._markForUpdateSummaryRows(records, fastChildren);

    var root = tree.getRoot(),
        rootChildren = null;
    if (root && tree.isFolder(root)) {
        rootChildren = fastChildren ? tree._getDirtyGroups(root) : tree.getChildren(root);
    }
    if (!(root && rootChildren && !rootChildren.isEmpty())) {
        return;
    }

    
    
    var flag = tree._summaryRecordFlag,
        targetNodeFlag = tree._summaryTargetNode,
        skipSortFlag = Array.excludeFromSortProperty,
        parentStack = [root],
        siblingsStack = [rootChildren],
        indexStack = [0];

    
    var dataChanged = false;
    tree._deferDataChanged = true;

    while (indexStack.length > 0) {
        var parent = parentStack.pop(),
            siblings = siblingsStack.pop(),
            i = indexStack.pop();

        // we need to know the length, so skip a result set with in-progress operation
        if (isc.isA.ResultSet(siblings) && !siblings.lengthIsKnown()) continue;

        var len = siblings.getLength();
        for (; i < len; ++i) {
            var node = siblings.getCachedRow(i);
            if (!node) {
                continue;
            }
            if (records != null) {
                if (node._refreshGroup) delete node._refreshGroup;
                else                  continue;
            }

            var group = node.groupName,
                add = addedSummaries && addedSummaries.contains(group),
                remove = removedSummaries && removedSummaries.contains(group),
                children = tree.getChildren(node);

            // Handle "refresh" as remove then re-add.
            if (refreshSummaries && !add && !remove) {
                add = refreshSummaries.contains(group);
                remove = refreshSummaries.contains(group);
            }
            // assert !(add && remove)

            if (remove) {
                // Remove the summary rows, which are the last children.
                if (!summariesAreSiblings) {
                    if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                        var summaryChildren = [];
                        for (var j = children.getLength(); j-- > 0; ) {
                            var child = children.getCachedRow(j);
                            if (child[flag] === true) {
                                summaryChildren.push(child);
                            } else {
                                break;
                            }
                        }
                        dataChanged |= tree.removeList(summaryChildren);
                    }
                } else {
                    var summaries = [],
                        j = 0;
                    for (;;) {
                        var s = siblings.getCachedRow(i + j + 1);
                        if (s && s[flag] == true) {
                            summaries.add(s);
                            ++j;
                        } else {
                            break;
                        }
                    }
                    dataChanged |= tree.removeList(summaries);
                    len -= summaries.length;
                }
            }
            if (add) {
                // We want to call 'getGroupSummaryData' and pass in live records to pick up
                // the summary row(s) based on the actual data.
                // If there are multiple layers of nesting this means we'll have to reach into
                // the sub-tree to get the ultimate descendants (the live records), rather than
                // just looking at the children of the current node (which would be a set of
                // header-nodes unless this is the innermost group).
                var summaryChildren = tree.getRecordsInGroup(node);

                summaryChildren = tree.combineWithEditVals(summaryChildren);

                var summaryRecords = this._getGroupSummaryData(
                        includeInSummaryProperty, applyFormulaAfterSummary,
                        groupSummaryRecordProperty, fieldsHaveUserFormulas,
                        summaryChildren, node, fields);
                if (summaryRecords != null) {
                    if (!isc.isAn.Array(summaryRecords)) {
                        summaryRecords[flag]         = true;
                        summaryRecords[skipSortFlag] = true;
                        if (!summariesAreSiblings) {
                            dataChanged |= tree.add(summaryRecords, node)      != null;
                        } else {
                            dataChanged |= tree.add(summaryRecords, parent, i) != null;
                            i+=1;
                            len+=1;
                        }
                    } else {
                        for (var k = summaryRecords.length; k--; ) {
                            summaryRecords[k][flag]         = true;
                            summaryRecords[k][skipSortFlag] = true;
                            
                            if (summariesAreSiblings) {
                                summaryRecords[k][targetNodeFlag] = node;
                            }
                        }
                        if (!summariesAreSiblings) {
                            dataChanged |= tree.addList(summaryRecords, node)        != null;
                        } else {
                            dataChanged |= tree.addList(summaryRecords, parent, i+1) != null;
                            i+=summaryRecords.length;
                            len+=summaryRecords.length;
                        }
                    }
                }
            }

            if (fastChildren) children = tree._getDirtyGroups(node);

            // Siblings in the groupTree should have the same type (folder or leaf).
            // Check the type of the first child.  This method calculates summaries
            // over folders so skip over the leaves.
            var childrenAreFolders = (children && !children.isEmpty() &&
                                      tree.isFolder(children.first()));
            if (childrenAreFolders) {
                // Recurse
                parentStack.push(parent);
                siblingsStack.push(siblings);
                indexStack.push(i + 1);
                parent = node;
                siblings = children;
                len = siblings.getLength();
                i = -1;
            }
        }
    }

    
    delete tree._deferDataChanged;
    if (dataChanged) {
        tree._clearNodeCache(true);
        tree.dataChanged();
    }
},

// Iterate through the tree recursively from root, for as many layers of nesting as
// required by the specified groupFields, applying group title and group summary info
// to the header nodes.
_regroupProcessGroupHeaderNode : function (async, baton, tree, state) {
    
    if (state == null) {
        state = {
            i: 0,
            children: tree.getChildren(tree.getRoot()),
            groupsVisited: 0,
            indexStack: [],
            childrenStack: []
        };
    }

    var groupFields = baton.groupByFields || [],
        i = state.i,
        children = state.children || [],
        groupsVisited = state.groupsVisited == null ? 0 : state.groupsVisited,
        indexStack = state.indexStack || [],
        childrenStack = state.childrenStack || [],
        recordCount = 0;
    if (groupFields.length > 0) {
        for (;;) {
            if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                // We know there's a layer of grouping below us, so process each child as a header
                // node as well.
                for ( ; i < children.getLength(); ++i, ++recordCount) {

                    if (async && recordCount > this.groupByAsyncThreshold) {
                        state.i = i;
                        state.children = children;
                        state.groupsVisited = groupsVisited;
                        this._regroupTimerEvent = this.delayCall(
                            "_regroupProcessGroupHeaderNode", [async, baton, tree, state], 0);
                        return;
                    }

                    var currNode = children.getCachedRow(i);
                    if (currNode != null) {
                        var fld = this.getUnderlyingField(groupFields[groupsVisited]),
                            groupTitle = this._getGroupTitle(
                                tree, baton.groupByFields, baton.groupByFieldValueMaps,
                                baton.singleCellValueProperty, currNode, fld);

                        // don't set singleCellValue if groupTitleField is set, in which case we want
                        // the groupTitle to be contained within a specific cell
                        if (!this._singleCellGroupHeaders(
                                baton.showGroupSummary, baton.showGroupSummaryInHeader))
                        {
                            currNode.groupTitle = groupTitle;
                        } else currNode[baton.singleCellValueProperty] = groupTitle;

                        if (baton.showGroupSummary && baton.showGroupSummaryInHeader) {
                            recordCount += this._applyGroupSummaryToHeader(
                                baton.groupByFieldSummaries, baton.includeInSummaryProperty,
                                baton.applyFormulaAfterSummary,
                                baton.groupSummaryRecordProperty, baton.fieldsHaveUserFormulas,
                                tree, currNode);
                        }

                        if (groupsVisited + 1 < groupFields.length) {
                            ++groupsVisited;
                            indexStack.push(i + 1);
                            childrenStack.push(children);
                            i = -1; // i will be incremented to zero before the start of the loop
                            children = tree.getChildren(currNode) || [];
                        }
                    }
                }
            }
            if (indexStack.length > 0) {
                --groupsVisited;
                i = indexStack.pop();
                children = childrenStack.pop();
            } else {
                break;
            }
        }
    }

    if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupOpenInitialGroups", [async, baton, tree, baton.restoreOpenFolders], 0);
    } else {
        this._regroupOpenInitialGroups(async, baton, tree, baton.restoreOpenFolders);
    }
},

_regroupOpenInitialGroups : function (async, baton, tree, restoreOpenFolders) {
    
    // If restoreOpenFolders is non null we will have passed it to 'addRecordToGroup'
    // and lazily instantiated the folders with the appropriate open property
    // Otherwise group fields have changed and we need to reset to initial open state
    if (!restoreOpenFolders) {
        var groupStartOpen = baton.groupStartOpen;

        if (!async) {
            this._openInitialGroups(groupStartOpen, tree);
        } else {
            var callback = function () {
                    // 'this' refers to the groupTree AutoChild, so this.creator is the ListGrid.
                    this.creator._regroupCreateSelectionModel(
                        async, baton, baton.currData, baton.setOriginalDataToCurrData, tree);
                };

            // group open options
            
            var batchSize = 250;
            if (isc.isAn.Array(groupStartOpen)) {
                // specific field values
                var children = tree.getChildren(tree.getRoot());
                for (var i = 0; i < groupStartOpen.length; i++) {
                    var value = groupStartOpen[i];
                    var folder = children.find("groupValue", value);
                    if (folder) tree.openFolder(folder);
                }
            } else if (groupStartOpen == "all") {
                tree._openAllAsync(null, callback, batchSize, "_regroupTimerEvent");
                return;
            } else if (groupStartOpen == "first") {
                tree._openAllAsync(tree.getChildren(tree.getRoot()).first(), callback, 
                                   batchSize, "_regroupTimerEvent");
                return;
            }
        }
    }

    if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupCreateSelectionModel",
            [async, baton, baton.currData, baton.setOriginalDataToCurrData, tree],
            0
        );
    } else {
        this._regroupCreateSelectionModel(
            async, baton, baton.currData, baton.setOriginalDataToCurrData, tree);
    }
},

_regroupCreateSelectionModel : function (async, baton, currData, setOriginalDataToCurrData, tree) {
    
    if (setOriginalDataToCurrData) {
        this.originalData = currData;
    }

    // Clean up the previous groupTree, then switch to the current working groupTree.
    if (this.groupTree) {
        this.ignore(this.groupTree, "changeDataVisibility");
        this.groupTree.destroy();
    }
    this.groupTree = tree;

    // Set .data directly, because this may be called from setData() anyway.
    // Note that this also avoids us worrying about 'preserveEditsOnSetData'
    this.data = tree;
    this._observeGroupData(this.data);
    // reset the selection model so the user can select items in the tree
    this.createSelectionModel();

    if (async) {
        // In an asynchronous regroup, pre-calculate the cache length of the
        // groupTree then have this.selection create its internal cache
        // now instead of lazily because it can be expensive to compute.
        // _regroupGetGroupTreeLength() will call _regroupCacheSelectionModel()
        // which will then call _regroupFinish().
        this._regroupTimerEvent = this.delayCall(
            "_regroupGetGroupTreeLength", [async, baton], 0);
    } else {
        this._regroupFinish(async, baton);
    }
},

_regroupGetGroupTreeLength : function (async, baton) {
    // assert async
    // assert this.data == this.groupTree
    var batchSize = 4000;
    this.data._getLengthAsync(this, "_regroupTimerEvent", batchSize, function (length) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupCacheSelectionModel", [async, baton], 0);
    });
},

_regroupCacheSelectionModel : function (async, baton) {
    // assert async
    // assert this.data.getNewSelection == null
    // assert isc.isA.Selection(this.selection) || isc.isA.CellSelection(this.selection)

    var callback = function () {
        this._regroupTimerEvent = this.delayCall("_regroupFinish", [async, baton], 0);
    };

    if (isc.isA.Selection(this.selection)) {
        var batchSize = 4000;
        this.selection._cacheSelectionAsync(this, "_regroupTimerEvent", batchSize, callback);

    } else if (isc.isA.CellSelection(this.selection)) {
        this.selection.getSelectedCells();
        this._regroupTimerEvent = this.delayCall("_regroupFinish", [async, baton], 0);
    }
},

_regroupFinish : function (async, baton) {
    
    delete this._asyncRegroupBaton;
    
    // Store grouped fields for future reference.
    var groupByFields = baton.groupByFields;
    this.groupByField = groupByFields;
    if (baton.groupByFieldGroupingModes != null) {
        for (var i = groupByFields.length; i--; ) {
            var groupingMode = baton.groupByFieldGroupingModes[i];
            if (groupingMode != null) {
                var field = this.fields.find(this.fieldIdProperty, groupByFields[i]);
                if (field) field.groupingMode = groupingMode;
            }
        }
    }
    this.isGrouped = true;
    // Fire the group/viewStateChanged notification here.
    this.handleGroupStateChanged();
    
    // restore the selected state after a grouping operation
    if (this._lastStoredSelectedState) {
        this.setSelectedState(this._lastStoredSelectedState);
        delete this._lastStoredSelectedState;
    }
    // If we're showing the special 'groupTitleColumn', force it to refresh its width now
    
    if (this.fields.find("_isGroupTitleColumn", true) != null) {
        this.updateFieldWidthsForAutoFitValue("regroup with group title column showing");
    }

    this.markForRedraw("regroup");

    // Clear the asynchGroupingPrompt message that was set in regroup().
    if (async) {
        delete this._asyncRegroupInProgress;
        delete this._regroupTimerEvent;
        isc.clearPrompt();

        // Setting of two properties were postponed until the
        // asynchronous regroup finished and now they need to be set.
        this.setGroupByFieldSummaries(this._newGroupByFieldSummaries);
        this.setShowGroupSummary(this._newShowGroupSummary);
    }

    var fields = this._groupByCompleteFieldsAfterRegroup,
        undef;
    if (this.groupByComplete != null && fields !== undef) {
        this.groupByComplete(fields);
    }
},


retainOpenStateOnRegroup: true,

// Update grouping of the grid for a single changed record. Originally in
// _fireCellChanged.
// NOTE: originalRecord must be a TreeNode from this.data.
_incrementalRegroup : function (record, originalRecord, newValues) {
    
    // If changes are made locally, this code is responsible for updating
    // groups and records. If this grid is databound, the server update will
    // reset this.data to the new values, and regroup() (called from dataChanged())
    // will update the groups.

    var wasSuppressed = this._suppressFolderToggleRedraw;
    this._suppressFolderToggleRedraw = true;
    
    var storedSelectedState = false;
    if (this._lastStoredSelectedState == null) {
        storedSelectedState = true; 
        this._lastStoredSelectedState = this.getSelectedState(true);
    }
    
    // first remove record
    var groups = originalRecord ? this.data.getParents(originalRecord) : [],
        removeSucceeded = originalRecord ? this.data.remove(originalRecord) : false,
        originalGroupNode = null
    ;

    // next recalc group titles and remove empty groups
    for (var i = 0; i < groups.length - 1; i++) {
        var currGroup = groups[i],
            members = currGroup.groupMembers,
            checkForSummaryChildren = this.showGroupSummary && !this.showCollapsedGroupSummary;
        if (checkForSummaryChildren ? !members.find("isGroupSummary", null) : 
                                       members.getLength() == 0) 
        {
            this.data.remove(currGroup);
        } else {
            var fld = (this.completeFields||this.fields).find(this.fieldIdProperty, currGroup);
            
            if (this.singleCellGroupHeaders()) {
                currGroup[this.singleCellValueProperty] = this.getGroupTitle(currGroup, fld);
            } else {
                currGroup.groupTitle = this.getGroupTitle(currGroup,fld);
            }
            if (!originalGroupNode) originalGroupNode = currGroup;
        }
    }

    // re-add record to group.
    // record may be null if eg adding a new record to unbound data. If it is,
    // add the new values instead - they represent what was added.
    // if original remove failed and we had data to begin with, don't add -
    // it's already been added elsewhere
    if (!(originalRecord && !removeSucceeded) && (record || newValues)) {
        this._addRecordToGroup(this.groupTree, record || newValues, true, true);
    }

    // reset this flag so that future calls to toggleFolder() don't bail 
    this._suppressFolderToggleRedraw = wasSuppressed;
    
    
    if (this.showGroupSummary) {
        var recordsToRefresh = [record || newValues];
        if (originalGroupNode) recordsToRefresh.add(originalGroupNode);
        this.refreshGroupSummary(recordsToRefresh);
    }
    // restore the selected state if we removed anything from the tree.
    // This will handle re-selecting a node updated to sit in a new group.
    if (storedSelectedState) {
        if (removeSucceeded) {
            this.setSelectedState(this._lastStoredSelectedState);
        }
        delete this._lastStoredSelectedState;
    }
},

_openInitialGroups : function (groupStartOpen, tree) {
    // group open options
    
    if (isc.isAn.Array(groupStartOpen)) {
        // specific field values
        var children = tree.getChildren(tree.getRoot());
        for (var i = 0; i < groupStartOpen.length; i++) {
            var value = groupStartOpen[i];
            var folder = children.find("groupValue", value);
            if (folder) tree.openFolder(folder);
        }
    } else if (groupStartOpen == "all") {
        tree.openAll();
    } else if (groupStartOpen == "first") {
        tree.openAll(tree.getChildren(tree.getRoot()).first());
    }
},

getGroupSpecifiers : function () {
    if (this._groupSpecifiers) return isc.shallowClone(this._groupSpecifiers);
},

setGroupSpecifiers : function (groupSpecifiers) {
    if (groupSpecifiers) {
        if (!isc.isAn.Array(groupSpecifiers)) groupSpecifiers = [groupSpecifiers];
        if (isc.isA.String(groupSpecifiers[0])) {
            var newSpec = [];
            for (var i=0; i<groupSpecifiers.length; i++) {
                // get a GroupSpecifier for the passed fieldName - returns null if no field
                var spec = this.makeGroupSpecifier(groupSpecifiers[i]);
                if (spec) newSpec.add(spec);
            }
            groupSpecifiers = newSpec;
        }
        
        
        // groupBy() will now call this method if it gets passed strings - call it back now
        // with proper specifiers
        this.groupBy(groupSpecifiers);
    } else {
        delete this._groupSpecifiers;
        this._lastStoredSelectedState = this.getSelectedState(true);
        this.groupBy([]);
    }
},
makeGroupSpecifier : function (fieldName, mode, granularity, precision) {
    // make a GroupSpecifier object from the passed values - for missing values, check the
    // associated field for defaults
    var field = this.getFieldByName(fieldName);
    var spec = { property: fieldName };
    if (field) {
        var mode = mode || field.groupingMode || field.defaultGroupingMode || 
                  (field._simpleType && field._simpleType.defaultGroupingMode);
        if (mode != null) spec.grouping = mode;
        granularity = granularity || field.groupGranularity;
        if (granularity != null) spec.granularity = granularity;
        precision = precision || field.groupPrecision;
        if (precision != null) spec.precision = precision;
    }
    return spec;
},
clearGroupSpecifiers : function () {
    this.setGroupSpecifiers(null);
},
 
//> @method listGrid.groupBy()
// Display the current set of records grouped by their values for the given field or
// fields. With no arguments, disables all grouping.
// <P>
// Grouping transforms the current dataset into a Tree on the fly, then provides a familiar tree
// interface for exploring the grouped data. Note that for performance reasons grouping
// is only available for dataSets with less than +link{listGrid.groupByMaxRecords} entries.
// <P>
// Grouping works automatically with any dataset, providing simple default grouping based on
// each field's declared type - see +link{simpleType.groupingModes} for more information.  
// Additionally, you can use +link{listGridField.getGroupValue,field.getGroupValue()} 
// to control how records are grouped, and 
// +link{listGridField.getGroupTitle,field.getGroupTitle()} to control how groups are 
// titled.  You can affect multiple fields of the same data-type via the same-named APIs on an
// appropriate custom +link{simpleType.getGroupValue, SimpleType}.
// <P>
// Grouping can be performed programmatically via this API, or you can set
// +link{canGroupBy,grid.canGroupBy:true} to enable menus that allow the user to perform
// grouping. To group a grid automatically, instantiate the grid with a
//  +link{listGrid.groupByField} setting.  To take action when an end use requests grouping,
// see +link{handleGroupBy()}.
// <P>
// While grouped, the automatically created Tree is available as
// +link{groupTree,grid.groupTree} and the original dataset is available as
// +link{originalData,grid.originalData}.
// <p>
// Before grouping can be performed, all records that match current
// +link{listGrid.fetchData,criteria} must be loaded.  If +link{dataFetchMode,data paging} is
// in use, not all matching records are cached, and the 
// +link{resultSet.getLength,total rows available from the server} is less than
// +link{groupByMaxRecords}, the grid will automatically request all unloaded records from the
// server, then perform grouping once they arrive.
// <p>
// If the total number of rows available from the server exceeds +link{groupByMaxRecords},
// calling <code>groupBy</code> will have no effect, and menu items for grouping will appear
// disabled.
// <p>
// Grouping is often an asynchronous operation, both because of automatic loading of remaining
// rows, and because asynchronous processing is required to work around bugs in some browsers
// related to misdetection of "hung" scripts (see +link{groupByAsyncThreshold}).  To be
// notified when grouping is complete, see +link{groupByComplete}.
//
// @param   [arguments 0-N] (Array of String) name of fields to group by
// @visibility external
// @group grouping
// @example dynamicGrouping
//<

groupBy : function (passedArray) {
    // support passing an Array instead of passing as a series of arguments
    var fields = [];

    if (isc.isAn.Array(passedArray)) {
        fields = isc.shallowClone(passedArray);
    } else {
        for (var i = 0; i < arguments.length; i++) {
            fields[i] = arguments[i];
        }
    }

    // the GroupSpecifier objects to pass to handleGroupBy()
    var specifiers = [];

    if (fields.length > 0) {
        if (isc.isA.String(fields[0])) {
            
            this.setGroupSpecifiers(fields);
            return;
        } else if (isc.isAn.Object(fields[0])) {
            
            specifiers = fields.duplicate();
            fields = fields.getProperty("property");
        }
    }

    // If we are currently unbound / have no fields, we'll actually group lazily when fields and
    // data are available
    if (!this.fields) {
        this.groupState = fields.join(",");
        
        this._markForRegroup = true;
        return;
    }

    for (var i = 0; i < fields.length; i++) {
        if (fields[i] != null && !this.getUnderlyingField(fields[i])) {
            this.logWarn("groupBy() passed field:" + fields[i] + " - this is not a valid field" +
                " within this grid - ignoring", "grouping");
            return;
        }
    }
    if (fields.length > 0 && fields[0] == null) {
        
        fields = [];
    }

    // fire handleGroupBy notification, if installed, and allow grouping to be cancelled
    if (this.handleGroupBy != null && this.handleGroupBy(fields, specifiers) == false) {
        
        for (var i=0; i<specifiers.length; i++) {
            var spec = specifiers[i];
            if (spec._oldGrouping) {
                var specField = this.getFieldByName(spec.property);
                if (spec._oldGrouping == "none") delete specField.groupingMode;
                else specField.groupingMode = spec._oldGrouping;
                delete spec._oldGrouping;
            }
        }
        return;
    }

    
    this._groupSpecifiers = isc.shallowClone(specifiers);

    // if arguments are null, return to original grouping
    if (fields.length == 0) {
        this.clearGroupBy();
        // fire the groupStateChanged / viewStateChanged notification here
        this.handleGroupStateChanged();
        // Fire the groupByComplete() notification.
        if (this.groupByComplete != null) {
            this.groupByComplete(fields);
        }
        return;
    }

    
    var groupByFields = [];
    for (var i = 0; i < fields.length; i++) {
        if (this.isCheckboxField(fields[i])) continue;
        var fieldName = (fields[i].property || fields[i]),
            field = this.getUnderlyingField(fieldName);
        if (field && field.displayField != null && field.optionDataSource == null &&
            this.getField(field.displayField))
        {
            fieldName = field.displayField;
        }
        groupByFields.add(fieldName);
    }
    this.logInfo("groupBy: " + groupByFields, "grouping");

    var origIsGrouped = this.isGrouped;
    this.isGrouped = true;
    // add the special groupTitleColumn if necessary - note that we have to do this after setting
    // isGrouped so getGroupTitleColumnPositon gives us back the position we want
    if (this.showGroupSummary && this.showGroupSummaryInHeader && this.showGroupTitleColumn &&
            this.getGroupTitleField() == null)
    {
        if (this.groupTitleColumn == null) {
            this.groupTitleColumn = this.getGroupTitleColumn();
        }
        if (this.fields.indexOf(this.groupTitleColumn) == -1) {
            this.addField(this.groupTitleColumn, this.getGroupTitleColumnPosition());
        }
    }
    // `isGrouped` will eventually be set to true in _regroupFinish().
    this.isGrouped = origIsGrouped;

    this._setMarkForRegroup(true, true, false, false, false, fields, groupByFields);

    this.dataChanged();
},

// Actually clears groupByFields / this.isGrouped and resets to original (ungrouped) data.
clearGroupBy : function () {
    this._setMarkForRegroup(false, false, false, true, false);

    this.logInfo("ungrouping", "grouping");

    if (this._asyncRegroupInProgress) {
        delete this._asyncRegroupInProgress;
        delete this._asyncRegroupBaton;

        isc.Timer.clear(this._regroupTimerEvent);
        delete this._regroupTimerEvent;
        isc.clearPrompt();
    }

    // if groupingModes is present, make sure to clear groupingMode
    var groupByFields = this.getGroupByFields();
    if (groupByFields != null) for (var i = 0; i < groupByFields.length; i++) {
        var field = this.getUnderlyingField(groupByFields[i]);
        if (field) field.groupingMode = null;
    }

    this.isGrouped = false;
    // Should we Fire the group/viewStateChanged notification here.?
    this._provideIsGroupedToRuleContext();

    if (this.originalData) {

        
        if (this.groupByField) this.groupByField = null;

        var pose = this.preserveEditsOnSetData;
        this.preserveEditsOnSetData = true;
        this.setData(this.originalData, true);
        this.preserveEditsOnSetData = pose;
        delete this.originalData;

        // Clear our pointer to this.groupTree if we have one.
        // Note: setData will actually destroy the groupTree if it's currently being shown
        // (As it destroys this.data)
        delete this.groupTree;
    }

    // in the case where showGroupSummaryInHeader is true we may have created a
    // default summary title column - clear this from our fields array now.
    if (this.groupTitleColumn != null) {
        var completeFields = this.completeFields || this.fields,
            index = completeFields.indexOf(this.groupTitleColumn);
        if (index != -1) {
            // duplicate the array, dropping the auto generated title column
            var newFields = [];
            for (var i = 0; i < completeFields.length; i++) {
                if (i == index) continue;
                newFields[newFields.length] = completeFields[i];
            }
            this.setFields(newFields);
        }
    }
},

groupIconPadding: 5,
// Returns group title for node. If field.getGroupTitle() exists, use that. Otherwise determines
// the groupTitle from the computed group value.
getGroupTitle : function (node, field) {
    return this._getGroupTitle(
        this.data, this.getGroupByFields(), null, this.singleCellValueProperty, node, field);
},
_getGroupTitle : function (data, groupFields, groupFieldValueMaps, singleCellValueProperty, node, field) {
    
    if (!field && groupFields) {
        // If no field specified, use indentation level of node to index into groupByField
        var groupLevel = data.getLevel(node) - 1,
            field = this.getUnderlyingField(groupFields[groupLevel]);
    }
    if (field == null) {
        
        return;
    }

    var value;

    if (field.getGroupTitle) {
        return field.getGroupTitle(node.groupValue, node, field, field.name, this);
    }
    else if (!field.getGroupValue && field._simpleType && field._simpleType.getGroupTitle) {
        // Only pick up default groupingModes / groupTitle if getGroupValue has not been
        // overridden. Standard groupingModes will have no meaning to a custom getGroupValue()
        // method. Note that the inverse is not true: groupingModes or getGroupTitle() may be
        // modified for EG localization, but rely on the standard getGroupValue behavior
        return field._simpleType.getGroupTitle(node.groupValue, node, field, field.name, this);
    } else {
        value = node.groupValue;
    }

    // if there's a valueMap, pick up the display value.
    // Note that this handles optionDataSource + displayField / valueField as these
    // automatically build and apply a field valueMap
    var k = (groupFieldValueMaps == null ? -1 : groupFieldValueMaps.indexOf(field)),
        fieldValueMap = (k == -1 ? field.valueMap : groupFieldValueMaps[k]);
    if (fieldValueMap) {
        value = this.resolveValueMap(value, fieldValueMap);
    // In this case there's a display field but no option dataSource.
    } else if (field.displayField && node[field.displayField] != null) {
        value = node[field.displayField];
    }

    if (field.escapeHTML && isc.isA.String(value) && value != this._$nbsp) {
        value = value.asHTML();
    }

    return value;
},

//> @method listGrid.getGroupNodeHTML
// Returns the HTML code necessary to render a group node, including icon, title, and padding.
// The amount of the padding is at least +link{listGrid.groupLeadingIndent} pixels, and
// an additional +link{listGrid.groupIndentSize} pixels for each increasing level of the
// node.
// @param node (Object) Specified group node
// @visibility external
//<
getGroupNodeHTML : function (node, gridBody) {
    
    var isFrozenBody = this.frozenBody === gridBody;
    
    var hasFrozenBody = this.frozenFields && this.frozenFields.length > 0;
    // If we're rendering one single cell value across the row only render it
    // in the frozen body.
    if (hasFrozenBody && !isFrozenBody && this.singleCellGroupHeaders()) {
        return this.emptyCellValue;
    }
    
    
    if (!isc.isA.Tree(this.data)) return this.emptyCellValue;
    
    var isOpen = this.data.isOpen(node),
        state = isOpen ? "opened" : "closed",
        url = isc.Img.urlForState(this.groupIcon, null, null, state),
        iconIndent = isc.Canvas.spacerHTML(this.groupIconPadding, 1),
        groupIndent =
            isc.Canvas.spacerHTML((this.data.getLevel(node) - 1) * this.groupIndentSize +
                                  this.groupLeadingIndent, 1),
        groupTitle = this.getGroupTitle(node);
    
    var imgConfig = {
            src:url,
            width:this.groupIconSize,
            height:this.groupIconSize,
            align:"middle"
        },
        img = this.imgHTML(imgConfig, null, null, null, "eventPart='opener'", null, null,
                isc.Canvas._generateSpanForBlankImgHTML);
    var retStr = (this.canCollapseGroup ? groupIndent + img
                                        : groupIndent) +
                 iconIndent + groupTitle;
    return retStr;
},

// Override shouldCascadeSelection - if we're grouped we want cascading selection
// If "canSelectGroups" is true, this is required to allow users to select group data by
// selecting the headers.
// If false, it's useful for getGroupTreeSelection to be able to tell devs which groups are
// selected (either fully or in part).
_shouldCascadeSelection : function () {
    
    if (this.canSelectGroups && this.groupTree != null && (this.groupTree == this.data)) return true;
    return this.Super("_shouldCascadeSelection", arguments);
},

//> @method listGrid.getGroupTreeSelection()
// If this grid +link{listGrid.isGrouped,is grouped}, this method will return the
// current selection. Unlike the standard +link{listGrid.getSelection(),getSelection method},
// this method will return +link{listGrid.isGroupNode(),group nodes} in addition to standard
// +link{ListGridRecord}s within the grid's data.
// @param [excludePartialSelection] (boolean) By default a group header node is considered
//   selected if any members of the group are selected. If this flag is passed in, only
//   header nodes where <b>all</b> members of the group are selected will be included
//   in the returned results.
// @param [groupNodesOnly] (boolean) If this parameter is passed as <code>true</code>, 
//   this method will return just the group header nodes from the group tree. If omitted
//   or false, both header nodes and data records will be returned.
// @return (Array of ListGridRecord) Selected group header nodes and record data objects.
//   If this grid is not grouped, standard +link{listGrid.getSelection(),listGrid selection}
//   will be returned.
// @visibility external
//<
getGroupTreeSelection : function (excludePartialSelection, groupNodesOnly) {
    var selection = this.getSelection(excludePartialSelection, true);
    if (groupNodesOnly && this.isGrouped) {
        var finalArray = [];
        for (var i = 0; i < selection.length; i++) {
            if (selection[i]._isGroup) finalArray.add(selection[i]);
        }
        selection = finalArray;
    }
    return selection;
},

//> @method listGrid.getSelection()
// Returns all selected records in this grid. If this grid is
// +link{listGrid.isGrouped,grouped}, group header nodes will not be included in the 
// returned array. Developers can make use of +link{getGroupTreeSelection()} to 
// get the selection including the selected group header nodes.
// <p>
// <strong>NOTE:</strong> Records in the returned array should be treated as read-only and not
// modified.
// @param [excludePartialSelections] (Boolean) When true, partially selected records will not be returned.
//                                   Otherwise, both fully and partially selected records are
//                                   returned.
// @return (Array of ListGridRecord) array of selected records, which will be empty if no record
// is selected.
// @group  selection
// @visibility external
// @example databoundRemove
//<

// Override getSelection() to avoid returning group tree nodes if we can select groups
// since the dev calling this API only really wants real records.
getSelection : function (excludePartialSelection, includeGroupNodes, dontSort) {
    var selection = this.Super("getSelection", arguments);
    // don't return group nodes as part of the selection
    // Undocumented "includeGroupNodes" param negates this, used by getGroupTreeSelection()
    if (!includeGroupNodes && selection && selection.length > 0 && this.isGrouped) {
        var trimmedSelection = [];
        for (var i = 0; i < selection.length; i++) {
            if (selection[i]._isGroup) continue;
            trimmedSelection.add(selection[i]);
        }
        selection = trimmedSelection;
    }
    return selection;
},

// As with getSelection() - overridden to omit group-header-nodes for grouped grids
getSelectedRecord : function () {
    var selection = this.getSelection();
    return (selection.length > 0 ? selection[0] : null);
},

// internal method to determine the group value for the supplied record
_getGroupValue : function (fieldValue, record, field, fieldName, 
    userFormula, userSummary, displayField, valueMap, nullGroupTitle)
{
    var currentUserFormula = field.userFormula,
        currentUserSummary = field.userSummary;

    // typically set if called by __addRecordToGroup() - null otherwise
    if (userFormula  == null) userFormula  = currentUserFormula;
    if (userSummary  == null) userSummary  = currentUserSummary;
    if (displayField == null) displayField = field.displayField;
    if (valueMap     == null) valueMap     = field.valueMap;

    if (field.getGroupValue) {
        fieldValue = field.getGroupValue(fieldValue, record, field, fieldName, this);
    } else if (userFormula) {
        field.userFormula = userFormula;
        fieldValue = this.getFormulaFieldValue(field, record);
        field.userFormula = currentUserFormula;
    } else if (userSummary) {
        field.userSummary = userSummary;
        fieldValue = this.getSummaryFieldValue(field, record);
        field.userSummary = currentUserSummary;
    } else {
        if (displayField) {
            var displayValue = this._getDisplayValue(
                field, valueMap, displayField, fieldValue, record);
            if (displayValue) {
                fieldValue = displayValue;
            }
        } else if (field._simpleType && field._simpleType.getGroupValue) {
            fieldValue = field._simpleType.getGroupValue(
                fieldValue, record, field, fieldName, this);
        }
    }
    if (valueMap && valueMap[fieldValue]) {
        fieldValue = valueMap[fieldValue];
    }
    if (fieldValue == null || isc.isAn.emptyString(fieldValue)) {
        fieldValue = nullGroupTitle || this.nullGroupTitle;
    }
    return fieldValue;
},

// helper function for adding a record to an existing group, or creating a new group
_addRecordToGroup : function (groupTree, record, setGroupTitles, openFolders) {
    return this.__addRecordToGroup(
        this.getGroupByFields(), this.data, this.emptyCellValue,
        this.groupSummaryRecordProperty, this.gridSummaryRecordProperty, null, null,
        this.applyFormulaAfterSummary, null, null, null, null, this.nullGroupTitle,
        this.showGroupSummary, this.showGroupSummaryInHeader, this.recordBaseStyleProperty,
        this.groupNodeBaseStyle, this.recordCustomStyleProperty, this.groupNodeStyle,
        this.recordEditProperty, this.singleCellValueProperty, groupTree, record,
        setGroupTitles, openFolders);
},
__addRecordToGroup : function (
    groupFields, data, emptyCellValue, groupSummaryRecordProperty, gridSummaryRecordProperty,
    fieldsHaveUserFormulas, fieldsHaveUserSummaries, applyFormulaAfterSummary,
    groupByFieldUserFormulas, groupByFieldUserSummaries, groupByFieldDisplayFields,
    groupByFieldValueMaps, nullGroupTitle, showGroupSummary, showGroupSummaryInHeader,
    recordBaseStyleProperty, groupNodeBaseStyle, recordCustomStyleProperty, groupNodeStyle,
    recordEditProperty, singleCellValueProperty, groupTree, record, setGroupTitles,
    openFolders, dataOpenList)
{
    var singleCellGroupHeaders = this._singleCellGroupHeaders(
            showGroupSummary, showGroupSummaryInHeader),
        currRoot = groupTree.getRoot(),
        node;
    

    for (var i = 0; i < groupFields.length; i++) {
        // find index of field w/ fieldName
        var fieldName = groupFields[i],
            field = this.getUnderlyingField(fieldName),
            recordNum;
        
        // recordNum passed to 'getRawCellValue' should be position of data in this.data
        // in order for things like edit-values to behave as expected.
        // Note that this may not reflect the position in the 'currData' [this.originalData]
        // and indeed can legitimately be -1 at this point if we're reacing to
        // a record being added to our dataSet.
        
        if (dataOpenList != null) {
            recordNum = dataOpenList.indexOf(record);
        } else {
            recordNum = data.indexOf(record);
        }
        
        var userFormula = groupByFieldUserFormulas == null ?
                field.userFormula : groupByFieldUserFormulas[i],
            userSummary = groupByFieldUserSummaries == null ?
                field.userSummary : groupByFieldUserSummaries[i],
            displayField = groupByFieldDisplayFields == null ? 
                field.displayField : groupByFieldDisplayFields[i],
            valueMap = groupByFieldValueMaps == null ? 
                field.valueMap : groupByFieldValueMaps[i],

            fieldValue = this._getRawCellValue(
                emptyCellValue, groupSummaryRecordProperty, gridSummaryRecordProperty,
                fieldsHaveUserFormulas, fieldsHaveUserSummaries, data,
                applyFormulaAfterSummary, (userFormula != null), userFormula,
                (userSummary != null), userSummary, record, recordNum, fieldName, true)
        ;

        // compute the group value from the raw cell value and record
        var originalValue = fieldValue;
        fieldValue = this._getGroupValue(fieldValue, record, field, fieldName,
            userFormula, userSummary, displayField, valueMap, nullGroupTitle);

        // find the group, if it exists
        var nodeChildren = groupTree.getChildren(currRoot);
        if (nodeChildren == null) node = null;
        else node = nodeChildren.find('groupValue', fieldValue,
                                    field.type == "datetime" ? Array.DATETIME_VALUES : null);
        if (!node) { // add new group
            node = {
                groupName: fieldName,
                groupValue: fieldValue, _isGroup: true, canDrag: false
                // Note: We disable user-selection unless canSelectGroups is true
                // in canSelectRecord()
            };
            
            // If a displayField is set, copy the displayField value from the record to
            // the node. The assumption here is that it will match for each record in the
            // group.
            if (field.optionDataSource == null && field.displayField != null) {
                node[field.displayField] = record[field.displayField];
            }

            // make sorting work - use the original value - date-grouping and sorting won't 
            // work otherwise (groupValue will be a number based on one of a number of 
            // groupingModes, not a date)
            node[fieldName] = originalValue;
            // set group style
            node[recordBaseStyleProperty] = groupNodeBaseStyle;
            node[recordCustomStyleProperty] = groupNodeStyle;
            // set non-editable
            node[recordEditProperty] = false
            // if openFolders property is passed respect it now.
            // this allows us to lazily recreate the open/closed state of folders when rebuilding
            // a groupTree with the same set of groupByFields
            if (openFolders != null) {
                node[groupTree.openProperty] = isc.isA.List(openFolders) ? 
                    openFolders.find(fieldName, fieldValue) : !!openFolders;
            }

            // add to the current group
            if (showGroupSummary) groupTree.addBeforeSummaries(node, currRoot);
            else                  groupTree.add               (node, currRoot);
        }
        // move to next group
        currRoot = node;
    }
    // add record to group
    if (showGroupSummary) groupTree.addBeforeSummaries(record, currRoot);
    else                  groupTree.add               (record, currRoot);

    // set the group titles if need be, mainly for dragging records in
    // start with the topmost group
    if (setGroupTitles) {
        var groups = groupTree.getParents(record);
        for (var i = groups.length - 2, j = 0; i >= 0; i--, j++) {
            var groupTitle = this._getGroupTitle(
                    groupTree, groupFields, groupByFieldValueMaps, singleCellValueProperty,
                    groups[i], null);

            if (!singleCellGroupHeaders) groups[i].groupTitle = groupTitle;
            else groups[i][singleCellValueProperty] = groupTitle;
        }
    }
},

//> @method listGrid.isGroupNode()
// If this listGrid is +link{listGrid.groupBy(),grouped}, is the record
// passed in a group header node.
// @param record (ListGridRecord) record to test
// @return (boolean) returns true if the record passed in is a group header node
// @visibility external
//<
isGroupNode : function (record) {
    if (record == null) return false;
    return !!record._isGroup;
},

applyGroupSummaryToHeader : function (tree, headerNode, fields) {
    return this._applyGroupSummaryToHeader(
        this.groupByFieldSummaries, this.includeInSummaryProperty,
        this.applyFormulaAfterSummary, this.groupSummaryRecordProperty, null,
        tree, headerNode, fields);
},
_applyGroupSummaryToHeader : function (
    groupByFieldSummaries, includeInSummaryProperty, applyFormulaAfterSummary,
    groupSummaryRecordProperty, fieldsHaveUserFormulas, tree, headerNode, fields)
{
    // Skip this if groupByFieldSummaries explicitly excludes this group
    var group = headerNode.groupName;
    if (groupByFieldSummaries != null && !groupByFieldSummaries.contains(group)) {
        return;
    }

    // If we're showing the group summary in the header node, call the
    // method to get group summary data, and copy the relevant properties across
    // [from the first record only - we don't currently support multiple summary lines
    // in the group header...]
    var summaryRecords = tree.combineWithEditVals(tree.getRecordsInGroup(headerNode)),
        summaryData = this._getGroupSummaryData(
            includeInSummaryProperty, applyFormulaAfterSummary, groupSummaryRecordProperty,
            fieldsHaveUserFormulas, summaryRecords, headerNode, fields);

    if (isc.isAn.Array(summaryData)) summaryData = summaryData[0];

    // bail if there's no summary data to process (no auto-summaries based on SimpleType or
    // fields with summary functions)
    if (!summaryData) return 0;

    // We want to apply all our fields (complete, not just visible, and the
    // includeInSummary and isGroupSummary values.
    // We don't want to do a blind 'addProperties' - this picks up additional meta data
    // enabled:false which we shouldn't apply to the header node.
    var fields = this.completeFields || this.fields;
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        var summaryFunc = this.getGridSummaryFunction(field);
        if (summaryFunc && isc.isAn.Array(summaryFunc)) summaryFunc = summaryFunc[0];
        if (summaryFunc == "count") {
            var array = headerNode[this.recordApplyPluralTitleProperty] || [];
            array.add(field.name);
            headerNode[this.recordApplyPluralTitleProperty] = array;
        }
        // don't clobber the groupTitle node value - we need that to display our title value
        var name = fields[i].name;
        if (name == "groupTitle") continue;
        headerNode[name] = summaryData[name];

    }
    headerNode[groupSummaryRecordProperty] = true;

    // Return the number of records in the summary to help determine how
    // to break up the computation of a regroup into asynchronously-run
    // batches.
    return summaryRecords.length;
},

//> @method listGrid.setShowGroupSummaryInHeader()
// Setter for +link{listGrid.showGroupSummaryInHeader}
// @param showGroupSummaryInHeader (boolean) new showGroupSummaryInHeader state
// @visibility external
//<
setShowGroupSummaryInHeader : function (showGroupSummaryInHeader) {
    if (this.showGroupSummaryInHeader == showGroupSummaryInHeader) return;
    this.showGroupSummaryInHeader = showGroupSummaryInHeader;
    var fields = this.getGroupByFields();
    this.ungroup();
    if (fields != null && fields.length > 0) {
        this.groupBy(fields);
    }
},

//> @method listGrid.setShowCollapsedGroupSummary()
// Setter for +link{listGrid.showCollapsedGroupSummary}
// @param showCollapsedGroupSummary (boolean) new showCollapsedGroupSummary value
// @visibility external
//<
setShowCollapsedGroupSummary : function (showCollapsed) {
    if (this.showCollapsedGroupSummary == showCollapsed) return;
    this.showCollapsedGroupSummary = showCollapsed;
    var fields = this.getGroupByFields();
    this.ungroup();
    if (fields != null && fields.length > 0) {
        this.groupBy(fields);
    }
},

//> @method listGrid.ungroup()
// Removes the grouping from the listGrid, restoring its original data
//
// @visibility external
//<
ungroup : function () {
    this._lastStoredSelectedState = this.getSelectedState(true);
    this.groupBy(null);
},

//> @method listGrid.setHeaderSpans()
// Update the headerSpans configuration on the grid dynamically.
//
// @param headerSpans (Array of HeaderSpan) same configuration block as that passed to
//                                          +link{listGrid.headerSpans}.
//
// @group headerSpan
// @visibility external
//<
setHeaderSpans : function (headerSpans, skipSetFields) {
    this.headerSpans = headerSpans;
    // when headerSpans changes, updateHeader() will orphan the span objects in
    // the old header._spans - this flag tells updateHeader() that headerSpans 
    // have changed, causing it to destroy spans as it deparent()s them
    this._autoDestroySpans = true;
    // if the second parameter is set, bail - TimelineView uses this
    if (skipSetFields) return;
    // re-run setFields. This will reorder the fields to match the order
    // specified by the spans if necessary!
    if (this.completeFields) this.setFields(this.completeFields);
    this.layoutChildren("headerSpans changed");
},


//> @method listGrid.setHeaderSpanTitle()
// Update the title of a +link{listGrid.headerSpans,headerSpan} dynamically.
//
// @param name (String) name of the headerSpan, as specified via +link{headerSpan.name}.
// @param newTitle (String) new title for the headerSpan
//
// @group headerSpan
// @visibility external
//<
setHeaderSpanTitle : function (name, newTitle) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanTitle() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    spanConfig.title = newTitle;
    if (spanConfig.liveObject && spanConfig.headerTitle == null) {
        spanConfig.liveObject.setTitle(newTitle);
    }
},

//> @method listGrid.setHeaderSpanHeaderTitle()
// Update the headerTitle of a +link{listGrid.headerSpans,headerSpan} dynamically.
//
// @param name (String) name of the headerSpan, as specified via +link{headerSpan.name}.
// @param newTitle (String) new headerTitle for the headerSpan
//
// @group headerSpan
// @visibility external
//<
setHeaderSpanHeaderTitle : function (name, newTitle) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanHeaderTitle() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    spanConfig.headerTitle = newTitle;
    if (spanConfig.liveObject) spanConfig.liveObject.setTitle(newTitle);
},

//> @method listGrid.setHeaderSpanBaseStyle()
// Update the +link{headerSpan.headerBaseStyle} for a span within the grid at runtime.
// @param name (String) name of the headerSpan, as specified via +link{headerSpan.name}.
// @param newStyle (CSSClass) new baseStyle for the headerSpan
// @visibility external
//<
setHeaderSpanBaseStyle : function (name, baseStyle) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanBaseStyle() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    spanConfig.headerBaseStyle = baseStyle;

    if (spanConfig.liveObject == null) return;

    // Treat being passed null as an attempt to revert to default base style.
    if (baseStyle == null) {
        var spannedFields = this.getSpannedFields(spanConfig),
            field = spannedFields[0];

        var buttonProperties = this.getHeaderButtonProperties();
        if (field.frozen && buttonProperties.frozenBaseStyle) {
            baseStyle = buttonProperties.frozenBaseStyle;
        } else if (buttonProperties.baseStyle) {
            baseStyle = buttonProperties.baseStyle;
        }

        if (baseStyle == null) {
            baseStyle = spanConfig.liveObject.getClass().getPrototype().baseStyle;
        }

    }
    spanConfig.liveObject.setBaseStyle(baseStyle);
},

//> @method listGrid.setHeaderSpanTitleStyle()
// Update the +link{headerSpan.headerTitleStyle} for a span within the grid at runtime.
// @param name (String) name of the headerSpan, as specified via +link{headerSpan.name}.
// @param newTitle (CSSClass) new titleStyle for the headerSpan
// @visibility external
//<
setHeaderSpanTitleStyle : function (name, titleStyle) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanTitleStyle() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    spanConfig.headerTitleStyle = titleStyle;

    if (spanConfig.liveObject == null) return;

    if (titleStyle == null) {
        var spannedFields = this.getSpannedFields(spanConfig),
            field = spannedFields[0];

        var buttonProperties = this.getHeaderButtonProperties();
        if (field.frozen && buttonProperties.frozenTitleStyle) {
            titleStyle = buttonProperties.frozenTitleStyle;
        } else if (buttonProperties.titleStyle) {
            titleStyle = buttonProperties.titleStyle;
        }
        if (titleStyle == null) {
            titleStyle = spanConfig.liveObject.getClass().getPrototype().titleStyle;
        }
    }
    spanConfig.liveObject.setTitleStyle(titleStyle);
},

// group summaries

//> @attr listGrid.showGroupSummary (Boolean : false : IRW)
// If this listGrid supports +link{listGrid.canGroupBy,grouping}, setting this property will cause
// the grid to render an extra row at the end of each group when grouped, containing summary
// information for the fields.
// Summary information will be calculated by the +link{listGridField.getGroupSummary()} method
// if specified, otherwise via the specified +link{listGridField.summaryFunction}.
// @see listGrid.groupByFieldSummaries
// @visibility external
//<
showGroupSummary:false,

//> @attr listGrid.groupByFieldSummaries (Array of String : null : IRWA)
// If this grid is +link{listGrid.groupByField,grouped}, and
// +link{listGrid.showGroupSummary} is true, this attribute may be set to an array of
// groupBy field names for which group summaries should appear.
// <P>
// This is particularly useful for listGrids grouped by more than one field as it allows developers
// to display the group summary for a particular nested group without showing a summary for every
// level of the tree.
// @see listGrid.showGroupSummary
// @visibility external
//<


//> @attr listGrid.groupSummaryStyle (CSSStyleName : "gridSummaryCell" : IR)
// +link{listGridRecord.customStyle} for the group-level summary row displayed when
// +link{listGrid.showGroupSummary} is true.
// @visibility external
//<

groupSummaryStyle: "gridSummaryCell",


//> @method listGrid.setShowGroupSummary()
// Setter for the +link{listGrid.showGroupSummary} attribute
// @param showGroupSummary (boolean) new value for this.showGroupSummary
// @visibility external
//<
setShowGroupSummary : function (showGroupSummary) {
    if (this._asyncRegroupInProgress) {
        // Postpone the change in showGroupSummary until after the
        // asynchronous regroup.
        this._newShowGroupSummary = showGroupSummary;
        return;
    }

    var changed = (this.showGroupSummary != showGroupSummary);
    if (changed && this.groupTree) {
        var sums = this.groupByFieldSummaries;
        this._updateSummaryRows(
            this.groupTree,
            this.showGroupSummary, showGroupSummary,
            sums, sums);
    }
    this.showGroupSummary = showGroupSummary;
},

//> @method listGrid.setGroupByFieldSummaries()
// Setter for the +link{listGrid.groupByFieldSummaries} attribute
// @param groupByFieldSummaries (Array of String) new value for this.groupByFieldSummaries
// @visibility external
//<
setGroupByFieldSummaries : function (groupByFieldSummaries) {

    if (this._asynchRegroupInProgress) {
        // Postpone the change in groupByFieldSummaries until after the
        // asynchronous regroup.
        this._newGroupByFieldSummaries = groupByFieldSummaries;
        return;
    }

    // Determine if the new value of groupByFieldSummaries is different from the
    // old value.
    var changed = (this.groupByFieldSummaries != groupByFieldSummaries);
    if (!changed) {
        var isArray = isc.isAn.Array(groupByFieldSummaries);
        changed = (isArray != isc.isAn.Array(this.groupByFieldSummaries));
        if (!changed && isArray) {
            var length = groupByFieldSummaries.length;
            changed = (length == this.groupByFieldSummaries.length);
            if (!changed) {
                for (var i = length; !changed && i--; ) {
                    changed = !this.groupByFieldSummaries.contains(groupByFieldSummaries[i]);
                }
            }
        }
    }

    if (changed && this.groupTree) {
        var show = this.showGroupSummary;
        this._updateSummaryRows(
            this.groupTree,
            show, show,
            this.groupByFieldSummaries, groupByFieldSummaries);
    }
    this.groupByFieldSummaries = groupByFieldSummaries;
},

// Method to refresh the group summary row for some record
refreshGroupSummary : function (records, fields) {

    if (!this.isGrouped || !this.showGroupSummary || !this.groupTree) return;

    // allow a row number to be provided, which we map into node
    if (isc.isA.Number(records)) records = this.groupTree.get(records);

    // If we're showing the summary in the header we have to refresh the header node
    // with the new summary field values (and refresh the row).
    if (this.showGroupSummaryInHeader) {
        if (records != null) {
            var headerNodes = this.groupTree._markForUpdateSummaryRows(records, false, []);
            for (var i = headerNodes.length - 1; i >= 0; i--) {
                var headerNode = headerNodes[i];
                this.applyGroupSummaryToHeader(this.groupTree, headerNode, fields);
                this.refreshRow(this.groupTree.indexOf(headerNode));
                delete headerNode._refreshGroup;
            }
        } else {
            var headerNodes = this.groupTree.findAll("_isGroup", true);
            if (headerNodes != null) {
                for (var i = 0; i < headerNodes.length; i++) {
                    this.applyGroupSummaryToHeader(this.groupTree, headerNodes[i], fields);
                }
            }
            this.markForRedraw("refresh group summaries");
        }

    // Otherwise we have to rerun 'getChildren()' and refresh the relevant group's set of drawn
    // rows.
    } else {

        
        this._updateSummaryRows(this.groupTree,
            this.showGroupSummary, this.showGroupSummary,
            this.groupByFieldSummaries, this.groupByFieldSummaries,
            true, records, fields);
    }
},

//> @method listGrid.configureGrouping()
// Open a MultiGroupDialog to configure the fields used for grouping.
//
// @visibility external
//<
configureGrouping : function (targetField) {
    var grid = this,
        groupFields = this.getGroupByFields()
    ;
    if (targetField && (!groupFields || groupFields.length == 0)) {
        groupFields = [targetField[this.fieldIdProperty]];
    }
    isc.MultiGroupDialog.askForGrouping(
        this, groupFields,
        function (groupLevels) {
            if (groupLevels) grid.setGroupSpecifiers(groupLevels);
        }
    );
},

// GridRenderer / ListGrid API routing
// --------------------------------------------------------------------------------------------

// if this LV defines any of the GridRenderer's APIs, route those methods through to the LV.  See
// LV.classInit()
addBodyPassthroughMethods : function (body) {
    // if the body hasn't been created yet, bail - we always add the passthrough methods when we
    // create the body
    if (this.body) this._addBodyPassthroughMethods(this.body);
    if (this.frozenBody) this._addBodyPassthroughMethods(this.frozenBody);
},

_addBodyPassthroughMethods : function (body) {

    var body2LGMethods = {},
        methodNames = isc.getKeys(isc.ListGrid._passthroughMethods);

    for (var i = 0; i < methodNames.length; i++) {
        var methodName = methodNames[i],
            methodOnListGrid = this[methodName];

        // the cellContextClick stringMethod is specially overridden
        // - The GR.cellContextClick method is overridden to fire LG._cellContextClick()
        //   That will handle creating the context menu, as well as firing any developer-defined
        //   'cellContextClick' stringMethod.
        if (methodName == "cellContextClick") continue;

        // If the method is being cleared out, ensure we clear out any passthrough method
        // we may have previously set up
        if (methodOnListGrid == null) {
            
            body2LGMethods[methodName] = body.getClass().getPrototype()[methodName];

        // If the method on the listGrid is something other than a passBack method,
        // ensure the method on the GridBody actually calls it unless:
        // - the gridBody method is allready a passthrough (no need to do anything)
        // - the method on the gridBody has been overridden to be something other than
        //   the instance default
        } else if (methodOnListGrid != isc.ListGrid._passBackMethods[methodName] &&
                  !((body[methodName] != null) && 
                    (body[methodName]._isPassthroughMethod ||
                    (body[methodName] != body.getClass().getPrototype()[methodName]))) 
                  ) 
        {
            // install a passthrough method on the body to call the LG
            body2LGMethods[methodName] = isc.ListGrid._passthroughMethods[methodName];
        }
        
    }
    body.addMethods(body2LGMethods);
},

// anytime methods are added on the fly to a ListGrid instance, install passthrough functions
// on the body.  This makes sure that if you eg add a cellHover function on the fly, we notice
// and set up a passthrough from the body.

addProperties : function (methods) {
    this.Super("addProperties", arguments);
    this.addBodyPassthroughMethods();
},

addMethods : function (methods) {
    this.Super("addMethods", arguments);
    this.addBodyPassthroughMethods();
},

// React to 'setProperties()' modifying drag related properties by updating
// 'canDrag' / 'canAcceptDrop' / etc
_$dragProperties : {
    canDragSelect:true,
    canDragSelectText:true,
    canDragRecordsOut:true,
    canReorderRecords:true,
    canAcceptDroppedRecords:true
},
// React to changes to 'alternateRecordStyles', 'fixedRecordHeights', et al by
// changing the related property ('alternateRowStyles', etc) on the body.
_$gridPropertyRenames : {

        // We have an explicit setBodyOverflow so no need to catch this case
        // overflow:this.bodyOverflow,
        bodyBackgroundColor:"backgroundColor",
        bodyStyleName:"styleName",

        // Note updating fixedRowHeights on the body is required in addition to the fact
        // we pass our "shouldFixRowHeight()" method through to the body.
        // That method has no effect if fixedRowHeights is false on the GridRenderer.
        fixedRecordHeights:"fixedRowHeights",

        fixedFieldWidths:"fixedColumnWidths",
        alternateRecordStyles:"alternateRowStyles",
        alternateRecordFrequency:"alternateRowFrequency",
        showAllRecords:"showAllRows",

        canSelectText:"canDragSelectText"
},
// propertyChanged - fired by setProperties for each modified property.
propertyChanged : function (propName, value) {
    this.invokeSuper(isc.ListGrid, "propertyChanged", propName, value);
    if (this._$dragProperties[propName]) this._dragPropertyChanged = true;
    if (this.body == null) return;
    if (isc.ListGrid._gridPassthroughProperties.contains(propName)) {
        this.body[propName] = value;
    }
    if (this._$gridPropertyRenames[propName] != null) {
        this.body.setProperty(this._$gridPropertyRenames[propName], value);
        // markForRedraw to display the changes
        
        this.markForRedraw();
    }
    //>EditMode
    if (this.editingOn && this.editProxy && propName == "initialCriteria") {
        this.setCriteria(this.initialCriteria);
    }
    //<EditMode
},

// doneSettingProperties - fired after all the properties have been updated.
doneSettingProperties : function () {
    if (this._dragPropertyChanged) this._setUpDragProperties();
},

//>EditMode

// EditMode
// ---------------------------------------------------------------------------------------
setChildEditableProperties : function (liveObject, properties, editNode, editContext) {
    var schema = isc.DS.get(editNode.type);
    if (!schema || !schema.inheritsSchema("ListGridField")) {
        return this.Super("setChildEditableProperties", arguments);
    }

    // Special case to handle VB editing of LGF with change to hidden property.
    if (!properties.hidden && liveObject.showIf == "false") liveObject.showIf = null;

    // the fields will need to be refreshed via setFields(); grab them here
    var fields = this.completeFields || this.fields;

    if (isc.EditContext.testNodeSchemaFieldProperty(editNode, "rebuildOnChange", properties)) {
        editNode.liveObject = isc.addProperties({
            editContext: editContext, editNode: editNode}, editNode.defaults);
        fields = fields.map(function (field) {
            return field == liveObject ? editNode.liveObject : field;
        });
    } else {
        isc.addProperties(liveObject, properties);
    }
        
    // fields list now final
    this.setFields(fields);
},

//<EditMode

// ---------------------------------------------------------------------------------------
getExportFieldValue : function (record, fieldName, fieldIndex) {
    // Checkbox icons (and generally all other icons) are a no-no for exported data.
    // If the display value would return a checkbox icon, use the raw cell value instead.
    var field = this.getSpecifiedField(fieldName);
    if (this.isCheckboxField(field)
        || field.valueIcons
        || this._formatBooleanFieldAsImages(field))
    {
        // getCellValue() is avoided in this code path to avoid its icon handling,
        // but there is some code there that must be duplicated here
        var useDisplayFieldValue = (field.displayField != null && !field.valueMap &&
            !field.getCellValue && this._useDisplayFieldValue(field));

        var recordNum = this.getRecordIndex(record),
            value;

        value = this.getRawCellValue(record, recordNum,
            useDisplayFieldValue ? field.displayField : fieldName,
            true);

        var hiliteAfterFormat = field.hiliteHTMLAfterFormat;
        if (hiliteAfterFormat == null) hiliteAfterFormat = this.hiliteHTMLAfterFormat;
        if (hiliteAfterFormat == null) hiliteAfterFormat = true;
        var hilites = this.getFieldHilites(record, field);

        if (!hiliteAfterFormat) {
            // Note that hilites can == 0, so if (hilites) doesn't work
            if (hilites != null) value = this.applyHiliteHTML(hilites, value);
            value = this._formatCellValue(value, record, field, recordNum, fieldIndex);
        } else {
            value = this._formatCellValue(value, record, field, recordNum, fieldIndex);
            if (hilites != null) value = this.applyHiliteHTML(hilites, value);
        }
        return this.htmlUnescapeExportFieldTitle(value.toString());
    }

    return this.Super("getExportFieldValue", arguments);
},

//> @method listGrid.getOriginalData()
// Returns the original, ungrouped data in the grid. If the grid is ungrouped,
// returns +link{listGrid.getData()}.
// @group grouping
//
// @return (object) The ungrouped data that is being displayed and observed
// @visibility external
//<
getOriginalData : function () {
    return (this.isGrouped && this.originalData) ? this.originalData : this.getData();
},

//> @groupDef excelPasting
// +link{DataSource.recordsAsText()} can export a set of DataSource records in
// tab-separated-values format so that it can be copied and pasted into a Microsoft Excel
// spreadsheet.
// <P>
// However, be aware that Excel does a bunch of type guessing on pasted data:
// <ul>
// <li> values that look like dates (eg 1-2-2011 and even just 1-2) will become true date-valued
//      cells (as indicated by Excel rendering them as eg 2-Jan).  Note that the month-day-year
//      interpretation is <b>locale-dependent</b> so be sure text is exported
// <li> values that look numeric, eg "5.0" become true number values (as indicated by Excel
//      showing just "5")
// <li> values that look like times, eg "5:30", will be converted to times (as indicated by
//      Excel showing 5:30:00 AM when editing the value)
// <li> values with a leading "=" will be treated as formulas
// </ul>
// Unfortunately, when these behaviors are undesirable, there is no means of turning them off
// that doesn't have any drawbacks.  You can:
// <ul>
// <li> adding a leading space or other char (but this changes the cell value).
// <li> turning the cell into a trivial formula, eg ="literal value".  But this means that when
//     the cell is edited, it's value is a formula.
// <li> format the cells as text in Excel before pasting data onto them
// </ul>
// The first or second approach can be enabled when exporting text - see
// +link{DataSource.recordsAsText()} and +link{DataSourceField.exportForceText}.
//
// @title Copy and Paste with Excel
//<


//> @method listGrid.getSelectedCellData()
// Returns the selected cells as a series of Records where each field value is stored under
// it's offset from the top-left of the selection.  For example, a 2x2 cell selection starting
// from the first column would return two Records, each with two values stored under the names
// "0" and "1".
// <P>
// If +link{canSelectCells} is not enabled, this API always returns null.
//
// @return (RecordList) list of Records as described above
// @visibility external
//<
getSelectedCellData : function (copyDownFromTopRow, copyRightFromLeftColumn) {
    if (this.canSelectCells) {
        var records = [],
            values = {},
            undef;

        var selection = this.selection.getSelectedCells();
        if (selection.length == 0) return [];

        var value, index = 0,
            origCol = selection[index][1];

        while (index < selection.length) {

            var record = {},
                addRecord = false,
                firstRow = selection[index][0],
                firstCol = selection[index][1];

            while (index < selection.length) {
                var row = selection[index][0];
                var col = selection[index][1];
                if (row != firstRow) break;

                if (col == firstCol || !copyRightFromLeftColumn) {
                    var gridRecord = this.getCellRecord(row, col);
                    if (this.shouldShowRecordComponent(gridRecord, col)) {
                        value = this.getRawCellValue(gridRecord, row, col);
                        // to assign to record, we must first map undef to null
                        if (value === undef && this.copyEmptyCells) value = null;
                        // cell is shown; row matters
                        addRecord = true;
                    } else value = undef;
                }
                var targetCol = col - origCol;
                if (copyDownFromTopRow) {
                    var binding = values[targetCol];
                    if (binding !== undef) value = binding;
                    else values[targetCol] = value;
                }
                if (value !== undef) record[targetCol] = value;
                index++;
            }
            if (addRecord) records.add(record);
        }
        return records;
    }
    return null;
},

//> @method listGrid.applyCellData()
// Applies a set of Records containing coordinate-based data as returned by
// +link{getSelectedCellData()} and applies the data at the current selection.
// <P>
// For consistency with Excel, given a record in the cellData, after the data value with the
// most negative column index is found, the rest of the values in the record are applied
// contiguously to the right of it, using the positional data for ordering only.
// <P>
// Will only modify cells in the grid which are editable, and changes will be applied
// as editValues, exactly as though the user had typed the values in (see
// +link{group:editing,Grid Editing Overview}).
// <P>
// See also +link{applyRecordData()}.
//
// @param cellData (RecordList) list of Records as described above
// @visibility external
//<

applyCellData : function (cellData, preserveOffsets, targetCells) {
    if (!this.canSelectCells || !cellData) return;

    if (!targetCells) targetCells = this.selection.getSelectedCells().slice(0,1);
    if (targetCells.length == 0) return;

    var origCol = targetCells[0][1],
        nTotalRows = this.getTotalRows();

    var rowIterator = isc.CellListIterator.create({cells: targetCells});
    for (var i = 0, row = rowIterator.getNextRow(); i < cellData.length && row < nTotalRows;
             i++,   row = rowIterator.getNextRow()) {

        while (!this._isValidRowForApplyGridData(row)) { row = rowIterator.getNextRow(); }
        if (row >= nTotalRows) break;

        var col,
            record = cellData[i];

        var indices = isc.ListGrid._getCoordinateList(record, !preserveOffsets);
        for (var j = 0; j < indices.length; j++) {
            if (j == 0 || preserveOffsets) col = origCol + indices[j];
            else                           col++;

            for (var field = null; col >= 0 && col < this.getTotalCols(); col++) {
                field = this._getFieldIfNonGenerated(col);
                if (field || preserveOffsets) break;
            }
            if (field && this.canEditCell(row, col)) {
                this.setEditValue(row, col, record[indices[j]]);
            }
        }
    }
},

//> @method listGrid.applyRecordData()
// Applies a list of Records as changes to the current selection.
// <P>
// Values found in each of the passed records will be applied to the same-named fields in the
// Records starting from the top-left of the current selection, in order.
// <P>
// Will only modify cells in the grid which are editable, and changes will be applied
// as editValues, exactly as though the user had typed the values in (see
// +link{group:editing,Grid Editing Overview}).
// <P>
// See also +link{applyCellData()}.
//
// @param recordData (RecordList) list of Records as described above
// @visibility external
//<
applyRecordData : function (recordData) {
    if (!this.canSelectCells || !recordData) return;

    var targetCells = this.selection.getSelectedCells();
    if (targetCells.length == 0) return;

    var undef,
        baseRow = targetCells[0][0],
        nTotalRows = this.getTotalRows();

    for (var i = 0, row = baseRow; i < recordData.length && row < nTotalRows; i++, row++) {

        while (!this._isValidRowForApplyGridData(row)) { row++; }
        if (row >= nTotalRows) break;

        var record = recordData[i];
        for (var name in record) {
            if (record.hasOwnProperty(name)) {
                var value = record[name];
                if (value !== undef) {
                    var column = this.getFieldNum(name);
                    var field  = this.getField(column);
                    if (field && this.canEditCell(row, column)) {
                        this.setEditValue(row, column, value);
                    }
                }
            }
        }
    }
},

_getFieldIfNonGenerated : function (fieldIndex) {
    var field = this.getField(fieldIndex);
    if (!field || field.userFormula || field.userSummary ||
         field.type == this._$summary) return null;
    return field;
},

_isValidRowForApplyGridData : function (row) {
    var record = this.getCellRecord(row);
    if (record == null) return true;
    return !record._isGroup && !record[this.isSeparatorProperty] &&
           !record[this.groupSummaryRecordProperty];
},

_invokeKeyboardCopyPasteShortcut : function (keyName) {

    if (!this.useCopyPasteShortcuts || !this.canSelectCells) return true;

    switch (keyName) {
        case "D":
            this.applyCellData(this.getSelectedCellData(true, null), true,
                               this.selection.getSelectedCells());
            break;
        case "R":
            this.applyCellData(this.getSelectedCellData(null, true), true,
                               this.selection.getSelectedCells());
            break;
        case "C":
            isc.ListGrid._cellClipboard = this.getSelectedCellData();
            break;
        case "V":
            this.applyCellData(isc.ListGrid._cellClipboard);
           break;
    }
    return false;
},

// Advanced Field Picker
// ---------------------------------------------------------------------------------------

//> @attr listGrid.useAdvancedFieldPicker (Boolean : false : IR)
// If set to true, an advanced field picker based on the +link{FieldPicker} will be shown instead
// of the column picker submenu if there are more fields in the grid than
// +link{advancedFieldPickerThreshold}.
// <P>
// When there are large numbers of available fields, the FieldPicker-based interface is more
// usable for both defining visible fields and defining field order.
// @visibility external
//<
useAdvancedFieldPicker: false,

//> @attr listGrid.canEditTitles (boolean : false : IRW)
// If set to true, the +link{listGrid.useAdvancedFieldPicker,advanced field picker} provides
// an interface allowing users to modify fields' titles.
// <P>
// Note that when enabled, the +link{getFieldState(),field state} for this component
// will include field titles.
//
// @visibility external
//<
canEditTitles:false,

//> @attr listGrid.fieldPickerWindow (AutoChild FieldPickerWindow : null : IR)
// Instance of +link{FieldPickerWindow} used if +link{useAdvancedFieldPicker} is set.
// @visibility external
//<

fieldPickerWindowDefaults : {
    autoParent: "none",
    _constructor: "FieldPickerWindow"
},

//> @attr listGrid.fieldPickerFieldProperties (Array of String : null : IR)
// Names of properties on +link{ListGridField} for which the +link{fieldPicker} should
// show an editing interface, for convenience.
// <P>
// For example, specify ["frozen", "decimalPrecision"] to allow end users to modify
// +link{listGridField.frozen} and +link{listGridField.decimalPrecision} respectively.
// @visibility external
//<
fieldPickerFieldProperties: null,

//> @attr listGrid.advancedFieldPickerThreshold (int : 25 : IR)
// When +link{useAdvancedFieldPicker} is set, total number of available fields that must be
// present in the grid before the advanced field picker interface is used instead of the normal
// columns submenu.
// <P>
// Set to 0 to have the advanced picker always used (when useAdvancedFieldPicker is true).
// @visibility external
//<
advancedFieldPickerThreshold: 25,

//> @attr listGrid.fieldPickerShowSampleValues (Boolean : true : IR)
// When set to false, sample values of the FieldPicker are never shown. This property applies to the entire FieldPicker.
// @visibility external
//<
fieldPickerShowSampleValues: true,

// ruleScope
// ---------------------------------------------------------------------------------------

_provideEditRecordToRuleContext : function (newValues) {
    if (this.ruleScope || this.isRuleScope) {
        var rowNum = (this.getEditSession(this.getEditRow()) ? this.getEditRow() : null),
            values = (rowNum != null ? this.getEditedRecord(rowNum, null, true) : null),
            hasChanges = (rowNum != null ? this.rowHasChanges(rowNum, false) : null),
            ds = this.getDataSource(),
            hasStableID = this.hasStableLocalID() || (this.editNode != null)
        ;

        if (newValues) {
            for (var key in newValues) {
                if (ds) this.provideRuleContext(ds.getID() + "." + key, newValues[key], this, hasStableID);
                if (hasStableID) this.provideRuleContext(this.getLocalId() + ".values." + key, newValues[key], this, true);
            }
        } else {
            if (values) {
                if (this.selection) delete values[this.selection.selectionProperty];
                delete values.__ref;
            }
            if (ds) this.provideRuleContext(ds.getID() , values, this, hasStableID);
            if (hasStableID) this.provideRuleContext(this.getLocalId() + ".values", values, this, true);
        }
        if (hasStableID) this.provideRuleContext(this.getLocalId() + ".hasChanges", hasChanges, this);
    }
},

_provideEditFocusToRuleContext : function (item) {
    if (!this.hasStableLocalID() && this.editNode == null) return;
    var path = this.getLocalId() + ".focusField",
        value = (item ? item.name : null),
        currentValue = this._getFromRuleContext(path)
    ;
    if (value != currentValue) this.provideRuleContext(path, value, this);
},

_provideIsGroupedToRuleContext : function () {
    if (!this.hasStableLocalID() && this.editNode == null) return;
    var path = this.getLocalId() + ".isGrouped",
        value = this.isGrouped,
        currentValue = this._getFromRuleContext(path)
    ;
    if (value != currentValue) this.provideRuleContext(path, value, this);
},

_observeRuleContextChanged : function () {
    var grid = this,
        ruleScopeComponent = this.getRuleScopeComponent();

    if (!this.isObserving(ruleScopeComponent, "ruleContextChanged")) {
        this.observe(ruleScopeComponent, "ruleContextChanged", function (newContext) {
            var currentCriteria = grid.getCriteria() || grid.getInitialCriteria();
            if (currentCriteria && isc.DS._criteriaHasValuePath(currentCriteria)) {
                grid.fetchData(currentCriteria);
            }
        });
    }
},

_removeFromRuleScope : function () {
    if (this.ruleScope) {
     // remove any ruleContext values for this grid 
        var ds = isc.DS.get(this.getDataSource()),
            hasStableID = this.hasStableLocalID() || (this.editNode != null)
        ;
        if (ds) this.provideRuleContext(ds.getID(), null, this, hasStableID);
        if (hasStableID) this.provideRuleContext(this.getLocalId(), null, this);
    }

    var ruleScopeComponent = this.getRuleScopeComponent();
    if (ruleScopeComponent && this.isObserving(ruleScopeComponent, "ruleContextChanged")) {
        this.ignore(ruleScopeComponent, "ruleContextChanged");
    }
    this.Super("_removeFromRuleScope", arguments);
}


});

//
// Register 'stringMethods' for ListGrid instances
// NOTE: all GridRenderer StringMethods are available on the LV too; see classInit()

isc.ListGrid.registerStringMethods(isc.GridRenderer._gridAPIs);
isc.ListGrid.registerStringMethods({
    // XXX the list of variables available for an expression is good here, but as method signatures
    // these look wacky.  Should probably be:
    // recordClick:"record,field,value,rawValue,rowNum,colNum"
    recordClick : "viewer,record,recordNum,field,fieldNum,value,rawValue",
    recordDoubleClick : "viewer,record,recordNum,field,fieldNum,value,rawValue",

    
    recordsDropped : "records,rowNum,viewer,sourceWidget",
    recordDropMove : "viewer,recordNum,record,position",

    //>!BackCompat 2004.12.10
    //> @method listGrid.editValueChanged
    // Callback fired when an edit modifies the value of a cell (before attempting to save that
    // value permanently)
    //
    // @param   rowNum     (number) row number for the cell
    // @param   fieldName   (string)    name of the edited field
    // @param   newValue   (any)    new value for the cell
    // @param   oldValue   (any)    old value for the cell
    // @visibility internal
    // @deprecated  As of SmartClient 5.5, use +link{listGrid.editorChange}.
    //  @group  editing
    //<
    editValueChanged : "rowNum,fieldName,newValue,oldValue",
    //<!BackCompat

    //> @method listGrid.editorChange
    // Callback fired when an edit modifies the value of a cell (before attempting to save that
    // value permanently)
    //
    // @param   record      (ListGridRecord)    record being edited (null if this is a new row)
    // @param   newValue   (any)    new value for the cell
    // @param   oldValue   (any)    old value for the cell
    // @param   rowNum     (number) row number for the cell
    // @param   colNum      (number) column number of the cell
    // @visibility advancedInlineEdit
    //  @group  editing
    // @example calculatedCellValue
    //<
    editorChange : "record,newValue,oldValue,rowNum,colNum",

    //> @method listGrid.cellChanged
    // Fires after user edits have been successfully saved to the server, only for cells where the
    // value was actually modified.
    // <p>
    // If you want immediate notification of a changes <b>before</b> changes has been saved to the
    // server, implement +link{listGridField.change,field.change()} or
    // +link{listGridField.changed(),field.changed()} instead.
    // <P>
    // You can alternatively use +link{listGridField.cellChanged} to get notification only of
    // saved changes for a specific field.  If both a listGridField and the containing listGrid
    // have a handler for this event, only the handler defined on the field is called.
    //
    // @param   record     (ListGridRecord) record for the cell being changed
    // @param   newValue   (any)    new value for the cell
    // @param   oldValue   (any)    old value for the cell
    // @param   rowNum     (number) row number for the cell
    // @param   colNum     (number) column number of the cell
    // @param   grid       (ListGrid)   grid where cell was changed.  Also available as "this"
    // @group  editing
    //
    // @see listGridField.cellChanged()
    // @visibility external
    //<
    // NOTE: extra recordNum/fieldNum parameters allow limited backward compatibility, since any
    // time a string expression is provided, parameter order doesn't matter.
    // old signature: recordNum,fieldNum,newValue,oldValue
    
    cellChanged : "record,newValue,oldValue,rowNum,colNum,grid,recordNum,fieldNum",


    

    //> @method listGrid.editComplete()
    // Callback fired when inline edits have been successfully saved.
    // <P>
    // No default implementation.
    //
    //  @group  editing
    //
    // @param rowNum (number) current index of the row that was saved
    // @param colNum (number) index of the column that was saved, if applicable
    // @param newValues (Object | Record) new values that were saved
    // @param oldValues (Record) the complete original values from before the save occurred
    // @param editCompletionEvent (editCompletionEvent) Event that led to the save
    // @param [dsResponse] (DSResponse) for DataSource saves, DSResponse object returned
    // @visibility external
    //<
    editComplete : "rowNum,colNum,newValues,oldValues,editCompletionEvent,dsResponse",

    //> @method listGrid.editFailed()
    // Called when an attempt to save inline edits fails, due to a validation error or other
    // server error.
    // <P>
    // The default implementation of editFailed does nothing for normal validation errors,
    // which are displayed before editFailed() is called.  For any other errors, the default
    // implementation will call +link{classMethod:RPCManager.handleError()}, which by default
    // will result in a warning dialog.
    //
    //  @group  editing
    //
    // @param rowNum (number) current index of the row we attempted to save
    // @param colNum (number) index of the column where the edit failed, if applicable
    // @param newValues (Object | Record) new values that we attempted to save
    // @param oldValues (Record) the complete original values from before the save occurred
    // @param editCompletionEvent (editCompletionEvent) Edit completion event that led to the save
    //                                                  attempt
    // @param [dsResponse]   (DSResponse)    DSResponse, for saves through a DataSource
    //
    // @visibility external
    //<
    editFailed : "rowNum,colNum,newValues,oldValues,editCompletionEvent,dsResponse,dsRequest",

    //> @method listGrid.editorEnter()
    // Callback fired when the user starts editing a new cell.
    // <P>
    // This callback is typically used to establish dynamic default values via
    // +link{setEditValue()} or +link{setEditValues()}.
    // <P>
    // Can also be overridden on a per-field basis via
    // +link{listGridField.editorEnter,field.editorEnter}.
    //
    // @param record (ListGridRecord) record for the cell being edited.  <b>Will be null</b>
    //                                for a new, unsaved record.
    // @param value (any) value for the cell being edited
    // @param rowNum (int)  row number for the cell
    // @param colNum (int)  column number of the cell
    // @group editing
    // @see listGridField.editorEnter()
    // @visibility external
    //<
    editorEnter : "record,value,rowNum,colNum",

    //> @method listGrid.rowEditorEnter()
    // Callback fired when the user starts editing a new row.
    //
    // @param   record     (ListGridField)  record for the cell being edited
    // @param   editValues  (object)    edit values for the current row
    // @param   rowNum     (number) row number for the cell
    //  @group  editing
    //  @see listGrid.editorEnter()
    // @visibility external
    //<
    rowEditorEnter : "record,editValues,rowNum",

    //> @method listGrid.editorExit()
    // Callback fired when the user attempts to navigate away from the current edit cell,
    // or complete the current edit.
    // <P>
    // Return false from this method to cancel the default behavior (Saving / cancelling the
    // current edit / moving to the next edit cell).
    // <P>
    // This callback is typically used to dynamically update values or value maps for related
    // fields (via +link{setEditValue()} and +link{setEditorValueMap()} respectively, or to
    // implement custom navigation (via +link{startEditing(), startEditing(rowNum,colNum)}.
    // <P>
    // Can be overridden at the field level as field.editorExit.
    //
    // @param editCompletionEvent   (EditCompletionEvent) How was the edit completion fired?
    // @param   record     (ListGridRecord) record for the cell being edited
    // @param   newValue   (any)    new value for the cell being edited
    // @param   rowNum     (number) row number for the cell
    // @param   colNum     (number) column number of the cell
    //  @group  editing
    // @return  (boolean)   Returning false from this method will cancel the default behavior
    //                      (for example saving the row) and leave the editor visible and focus
    //                      in this edit cell.
    //  @see listGridField.editorExit()
    // @visibility external
    //<
    
    editorExit : "editCompletionEvent,record,newValue,rowNum,colNum",

    //> @method listGrid.rowEditorExit()
    // Callback fired when the user attempts to navigate away from the current edit row,
    // or complete the current edit.
    // <P>
    // Return false from this method to cancel the default behavior (Saving / cancelling the
    // current edit / moving to the next edit cell).
    //
    // @param editCompletionEvent   (EditCompletionEvent) How was the edit completion fired?
    // @param   record     (ListGridRecord) record for the cell being edited
    // @param   newValues  (object)    new values for the record [Note that fields that have
    //                                 not been edited will not be included in this object]
    // @param   rowNum     (number) row number for the row being left
    //  @group  editing
    // @return  (boolean)   Returning false from this method will cancel the default behavior
    //                      (for example saving the row) and leave the editor visible and focus
    //                      in this edit cell.
    //  @see listGridField.editorExit()
    // @visibility external
    //<
    rowEditorExit : "editCompletionEvent,record,newValues,rowNum",

    // JS doc comments by default implementation of validateCellValue and validateFieldValue
    validateCellValue : "rowNum,colNum,newValue,oldValue",
    validateFieldValue : "newValue,oldValue,record,field,rowNum,colNum",

    //> @method listGrid.formatCellValue()
    // Formatter to apply to values displayed within cells.
    // <P>
    // The value passed to this method is either the field value found in the cell record
    // or, if there are unsaved edits, the current user-entered value for the cell.
    // <b>NOTE:</b> unsaved user edits may contain nulls, bad values or values of the wrong
    // type, so formatters used for editable data should be bulletproof.  For example, if you
    // have a function "myNumberFormatter" that should only be passed actual Numbers, you might
    // define formatCellValue like so:
    // <pre>
    //     isc.isA.Number(parseInt(value)) ?
    //            myNumberFormatter(parseInt(value)) : value
    // </pre>
    // Note that this formatter will not be applied to the value displayed within editors for
    // cells - use <code>formatEditorValue</code> to achieve this.
    // <P>
    // If <code>formatCellValue</code> is defined at the field level for some cell being edited,
    // the field level method will be used to format the edit value and this method will not
    // be called for that cell.<br>
    //
    // @group display_values
    //
    // @param   value    (any)   raw value for the cell being
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter.
    // @param   rowNum   (number)    row number for the cell
    // @param   colNum   (number)    column number for the cell.
    // @return  (HTMLString) formatted value to display in the cell.
    // @see listGridField.formatCellValue()
    // @see listGrid.formatEditorValue()
    // @visibility external
    //<
    formatCellValue : "value,record,rowNum,colNum",

    //> @method listGrid.formatEditorValue()
    // Formatter to apply to values displayed within editors while a cell is being edited.
    // The value passed to this method is the raw value for the cell.<br>
    // If <code>formatEditorValue</code> is defined at the field level for some cell being edited,
    // the field level method will be used to format the edit value and this method will not
    // be called for that cell.<br>
    // To convert the formatted value displayed within an editor back to a raw value, the
    // <code>parseEditorValue</code> method is used.
    //
    // @group editing
    //
    // @param   value (any)   raw value for the cell being edited
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved,
    //   it has no associated record object. In this case the edit values will
    //   be passed in as this parameter.
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @return  (any)   formatted value to display in the editor
    // @see listGridField.formatEditorValue()
    // @see listGrid.parseEditorValue()
    // @visibility external
    //<
    
    formatEditorValue : "value,record,rowNum,colNum",

    //> @method listGrid.parseEditorValue
    // Method used to convert the value displayed in an editor for some cell being edited into
    // a raw value for saving.<br>
    // If <code>parseEditorValue</code> is defined at the field level for some cell being edited,
    // the field level method will be used to parse the edit value and this method will not
    // be called for that cell.<br>
    //
    // @group editing
    //
    // @param   value (any)   value displayed in the editor for the cell
    // @param   record (ListGridRecord) record object for the row being edited. May be null if this
    //                          is a new row being added to the end of the list.
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @return  (any)   value in raw format
    // @see listGridField.parseEditorValue()
    // @see listGrid.formatEditorValue()
    // @visibility external
    //<
    parseEditorValue : "value,record,rowNum,colNum",

    //> @method listGrid.sortChanged
    // Notification method executed when the +link{listGrid.setSort(),sort specifiers} change
    // for this grid.
    // @param sortSpecifiers (Array of SortSpecifier) new sort specifiers - may be empty indicating
    //   the grid was unsorted
    // @visibility external
    //<
    sortChanged:"sortSpecifiers",

    //> @method listGrid.fieldStateChanged
    // Notification method executed when columns are resized or reordered, or fields are
    // shown or hidden. Has no default implementation.
    //
    // @visibility external
    // @group fieldState
    //<
    fieldStateChanged : "",

    //> @method listGrid.groupStateChanged
    // Notification method executed whenever the groupState of this grid changes.
    // Group state is accessible via +link{listGrid.getGroupState()}, and contains group state
    // information.
    //
    // @visibility external
    //<
    groupStateChanged : "",

    //> @method listGrid.viewStateChanged
    // Notification method executed whenever the viewState of this grid changes.
    // View state is accessible via +link{listGrid.getViewState()}, and contains field state
    // information, sort information, selection information, hiliting information and
    // grouping information.
    //
    // @visibility external
    //<
    viewStateChanged : "",

    //> @method listGrid.dataArrived() (A)
    // Notification method fired when new data arrives from the server to be displayed in this
    // ListGrid, (for example in response to the user scrolling a new set of rows into view).
    // Only applies to databound listGrids where the +link{listGrid.data,data} attribute is a
    // +link{ResultSet}. This ResultSet may have been created manually and applied to the grid via
    // a call to +link{listGrid.setData()} or may have been created and automatically assigned if
    // +link{listGrid.fetchData()} was used to populate the grid.  This method is fired directly in
    // response to +link{ResultSet.dataArrived(),dataArrived()} firing on the data object.
    // @param startRow (int) starting index of the newly loaded set of rows
    // @param endRow (int) ending index of the newly loaded set of rows (non inclusive).
    // @visibility external
    //<
    dataArrived:"startRow,endRow",

    //> @method listGrid.headerHover() (A)
    // Handle a hover over a button in the header.
    //
    // @param fieldNum (number) field number for the header that was hovered
    // @see ListGrid.headerHoverHTML()
    // @group events, gridHeader, hovers
    // @visibility external
    //<
    headerHover:"fieldNum",

    // doc'd above
    headerClick:"fieldNum",

    //> @method listGrid.onHeaderClick()
    // Handler fired when the user clicks a header in this listGrid before any other processing
    // occurs.
    // Return false to suppress the default header click handling
    // @param fieldNum (int) index of the field on which the click occurred.
    // @return (boolean) return false to cancel the default header click behavior
    // @visibility sgwt
    //<
    
    onHeaderClick:"fieldNum",

    //> @method listGrid.onRecordDrop()
    // @param dropRecords (Array[] of ListGridRecord) records being dropped
    // @param targetRecord (ListGridRecord) record being dropped on.  May be null
    // @param index (int) index of record being dropped on
    // @param dropPosition (RecordDropPosition) position with respect to the target record
    // @param sourceWidget (Canvas) widget where dragging began
    // @return (boolean) return false to cancel the default record drop handling
    // @include ListGrid.recordDrop
    // @visibility sgwt
    //<
    
    onRecordDrop:"dropRecords,targetRecord,index,dropPosition,sourceWidget",

    //> @method listGrid.onExpandRecord()
    // Handler fired when a record is expanded in a grid with <code>canExpandRecords</code> set to
    // true. Allows the expansion to be cancelled.
    // @param record (ListGridRecord) record being expanded
    // @return (boolean) return false to cancel record expansion
    // @visibility sgwt
    //<
    
    onExpandRecord:"record",

    //> @method listGrid.onCollapseRecord()
    // Handler fired when a record is collapsed in a grid with <code>canExpandRecords</code> set to
    // true. Allows the collapse to be cancelled.
    // @param record (ListGridRecord) record being collapsed
    // @return (boolean) return false to cancel record collapse
    // @visibility sgwt
    //<
    
    onCollapseRecord:"record",

    //> @method listGrid.drawAreaChanged()  (A)
    //  Notification method that fires when the drawArea changes due to scrolling.  Receives
    // the previous drawArea co-ordinates as parameters.  Call +link{listGrid.getDrawArea()} to
    // get the new drawArea co-ordinates.
    // <P>
    // Note that if this grid is showing any +link{listGridField.frozen,frozen fields}, they
    // will not be included in the <code>oldStartCol</code>, <code>oldEndCol</code> range
    // reported by this method. Frozen fields are assumed never to be scrolled out of view.
    //
    // @param oldStartRow (number) the startRow from before the drawArea changed
    // @param oldEndRow (number) the endRow from before the drawArea changed
    // @param oldStartCol (number) the startCol from before the drawArea changed
    // @param oldEndCol (number) the endCol from before the drawArea changed
    // @visibility external
    //<
    drawAreaChanged:"oldStartRow,oldEndRow,oldStartCol,oldEndCol",

    //> @method listGrid.showRecordComponent()
    // When +link{listGrid.showRecordComponents} is true, return false from this method
    // to prevent the recordComponent system from processing the passed record or cell.
    // <P>
    // <b>If +link{listGrid.showRecordComponentsByCell, showRecordComponentsByCell} is true, 
    // it is important to implement this method</b> - especially if the grid has many fields - 
    // otherwise, the internal automatic detection will process every visible cell, checking,
    // for example, whether a component already exists for that cell, before eventually running 
    // +link{ListGrid.createRecordComponent} to check if one is required.  Implementing this
    // method avoids all that processing for cells that aren't expected to have components.
    // <P>
    // The second parameter is only applicable if +link{showRecordComponentsByCell} is true.
    //
    // @param record (ListGridRecord) record being processed
    // @param [colNum] (integer) column index of the cell in which the record component
    //   may be shown. Will be null unless showRecordComponentsByCell is true.
    // @return (boolean) return false to cancel showRecordComponent behavior
    // @visibility external
    //<
    showRecordComponent:"record,colNum",
    

    //> @method listGrid.createRecordComponent()
    // When +link{showRecordComponents} is true, this method is called to create
    // per-row or per-cell embedded components to display in the grid.
    // <p>
    // The colNum parameter is applicable only when
    // +link{listGrid.showRecordComponentsByCell} is true.
    // <p>
    // If this row should not have a <code>recordComponent</code>, return null.
    // <p>
    // This method should create and return a new component for the record passed in every
    // time it is called and never return the same Canvas instance twice.  To re-use components
    // with different rows, set +link{recordComponentPoolingMode} to "recycle".  In this mode,
    // in addition to implementing this method, developers should also implement
    // +link{listGrid.updateRecordComponent()} which allows already created components to be
    // altered for re-use in new records. See the +link{listGrid.showRecordComponents} overview
    // for more information.
    //
    // @param record (ListGridRecord) record to create a component for
    // @param colNum (Integer) cell to which the component applies
    // @return (Canvas) return the component to embed in the passed record
    // @visibility external
    //<
    createRecordComponent:"record,colNum",

    //> @method listGrid.updateRecordComponent()
    // When +link{listGrid.showRecordComponents} is true, this method is called to update
    // components created by +link{listGrid.createRecordComponent()} when they are to be
    // applied to a different record in the grid. See the
    // +link{listGrid.showRecordComponents, record components overview}
    // for more information on recordComponents.
    // <P>
    // The colNum parameter is applicable only when
    // +link{listGrid.showRecordComponentsByCell} is true. Note that if
    // +link{listGrid.poolComponentsPerColumn} is set to false, the component may have been generated
    // by a +link{listGrid.createRecordComponent()} call applied to a different field.
    // <P>
    // Return null to avoid re-adding the component to the row or cell.
    //
    // @param record (ListGridRecord) record to which the passed component applies
    // @param colNum (Integer) cell to which the passed component applies
    // @param component (Canvas) the component to update
    // @param recordChanged (boolean) was the passed component previously embedded in a
    //     different record?
    // @return (Canvas) return the component to embed in the passed record
    // @visibility external
    //<
    updateRecordComponent:"record,colNum,component,recordChanged",


    //> @method updateFilterEditorValues () [A]
    // If specified, and +link{ListGrid.showFilterEditor} is true, this stringMethod
    // will be called whenever fetchData() or filterData (or clearCriteria())
    // is called on this grid and should return a set of values to display in the
    // filterEditor.
    // @param currentCriteria (Criteria) Criteria being applied to the grid. May be null if
    //   the filter is being cleared
    // @return (Object) Values to display in the filter editor.
    // @visibility internal
    //<
    
    updateFilterEditorValues:"criteria",

    //> @method listGrid.filterEditorSubmit()
    // Optional notification fired when the user performs a filter using the
    // +link{showFilterEditor,Filter Editor}.  May fire as criteria values are being edited if 
    // +link{filterOnKeypress} is true, otherwise will fire when the user clicks the filter
    // button or presses the Enter key while focus is in the Filter Editor.
    // <p>
    // <smartgwt>Use event.cancel()</smartgwt>
    // <smartclient>Return false</smartclient>
    // to cancel the default behavior - you <b>must</b> cancel the default behavior if your
    // code is going to call +link{filterData()}, +link{setCriteria()} or any other API that
    // affects the criteria applied to the grid.
    // <P>
    // The <code>criteria</code> parameter contains the current criteria applied to the
    // grid including edits the user has just made using the Filter Editor.  This matches
    // what is returned if you call +link{getFilterEditorCriteria()}.
    // <P>
    // If you wish to access the <code>criteria</code> applied to the grid without picking
    // up any edits to the Filter Editor, use +link{getCriteria()} instead.
    // <P>
    // Developers may wish to perform a filter using the Filter Editor values from code
    // running outside the standard filterEditorSubmit flow.  For example, if you wanted a
    // confirmation dialog to be shown before filtering was performed, you would cancel the
    // default behavior as described above, but then need to replicate the default behavior
    // once the user confirms that they want to proceed.  To replicate the default behavior, 
    // just call:
    // <pre>
    //  grid.filterData(grid.getFilterEditorCriteria());
    // </pre>
    // or, to ensure the specified +link{listGrid.autoFetchTextMatchStyle} is picked up
    // <smartclient>
    // <pre>
    //  grid.filterData(grid.getFilterEditorCriteria(), 
    //          null, {textMatchStyle:grid.autoFetchTextMatchStyle});
    // </pre>
    // </smartclient>
    // <smartgwt>
    // <pre>
    //  DSRequest request = new DSRequest();
    //  request.setTextMatchStyle(grid.getAutoFetchTextMatchStyle());
    //  grid.filterData(grid.getFilterEditorCriteria(), null,
    //       request);
    // </pre>
    // </smartgwt>
    //
    // @param criteria (Criteria) criteria derived from the filter editor values
    // @return (boolean) returning false will suppress the filter from occurring
    // @visibility external
    //<
    filterEditorSubmit:"criteria",

    //> @method listGrid.handleGroupBy()
    // Callback fired when the user attempts to group or ungroup the listGrid, or when
    // +link{listGrid.groupBy()} is called programmatically.
    // <smartclient>Return false to cancel grouping.</smartclient>
    // <smartgwt>This event may be cancelled.</smartgwt>
    // <P>
    // This notification is fired before the +link{listGrid.groupTree,data} is updated to
    // reflect the grouping. See also +link{listGrid.groupByComplete()}.
    //
    // @param fields (Array of String) the list of ListGrid field-names by which the grid is 
    //                 about to be grouped.  If the grid is being ungrouped, this param will be
    //                 an empty array
    // @param specifiers (Array of GroupSpecifier) list of GroupSpecifier objects detailing
    //                 grouping specifics for each grouped field
    // @return (boolean) return false to cancel grouping on the passed specification
    // @visibility external
    //<
    handleGroupBy:"fields,specifiers",

    //> @method listGrid.groupByComplete()
    // Callback fired when the listGrid is grouped or ungrouped.
    // <P>
    // Unlike +link{listGrid.handleGroupBy()}, this notification will fire when grouping
    // is complete, and the +link{listGrid.data} object has been updated.
    // On successful grouping the <code>fields</code> argument will list the new 
    // grouping and the +link{listGrid.groupTree} will have been updated to reflect the
    // grouped data.
    // <P>
    // Note that the <code>fields</code> argument may be an empty array if the data
    // is not grouped. This implies that a user or developer explicitly ungrouped the
    // grid, or that a groupBy attempt failed due to the data length exceeding 
    // +link{listGrid.groupByMaxRecords}.
    //
    // @param fields (Array of String) ListGrid field names by which the grid is now
    //  grouped. If the grid is currently not grouped, this parameter will be an
    //  empty array.
    // @visibility external
    //<
    
    
    groupByComplete:"fields",

    //> @method listGrid.hilitesChanged()
    // Notification method executed whenever the end user uses the HiliteEditor to change
    // the set of hilites applied to this grid.  This method will not be called after
    // a purely programmatic change to the hilites made with a call to
    // +link{databoundComponent.setHilites(),setHilites()}.  The array of currently applied hilite objects is
    // accessible via +link{databoundComponent.getHilites(),getHilites()}.
    // @group hiliting
    // @visibility external
    //<
    hilitesChanged : "",

    //> @method listGrid.cellErrorIconHover() ([A])
    // Optional stringMethod to fire when the user hovers over the error icon of a cell with 
    // validation errors.  The default behavior is to show a hover canvas containing the
    // validation error message text. Return false to suppress this default behavior.
    //
    // @group events
    // @param record (ListGridRecord) cell record as returned by getCellRecord()
    // @param rowNum (number) row number for the cell
    // @param colNum (number) column number of the cell
    // @return (boolean) false to suppress the standard error message hover
    // @see showErrorIcons
    // @visibility external
    //<
    cellErrorIconHover : "record,rowNum,colNum"

});


isc.ListGrid._unskinnedHeaderDefaults =
    isc.addProperties({}, isc.ListGrid.getInstanceProperty("headerDefaults"));
isc.ListGrid._unskinnedHeaderButtonDefaults =
    isc.addProperties({}, isc.ListGrid.getInstanceProperty("headerButtonDefaults"));

isc.ListGrid.classInit();


// AutoTest subsystem supports some configuration of ListGrids
//> @attr ListGrid.locateRowsBy (string : null : IRW)
// When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
// +link{isc.AutoTest.getLocator()} for a cell in this grid, how should the row be identified?
// <br>
// Note that getLocator() will actually store all available information about the row in
// the generated string -- this attribute effects how a stored string will be parsed only.
// <P>
// Valid options area:
// <ul>
// <li><code>"primaryKey"</code> Only applies to databound grids: If the cell in question has
//  a primary key cell value, use it to identify cells in autoTest locator strings.</li>
// <li><code>"titleField"</code> If the cell in question has a value for the
//  +link{listGrid.getTitleField(),titleField}, use it to identify cells in autoTest
//  locator strings</li>
// <li><code>"targetCellValue"</code> Identify rows by storing the cell value for the target
//  row / field in autoTest locator strings</li>
// <li><code>"index"</code>The rowNum will be used to identify the row.</li>
// </ul>
// If unset, default behavior is to identify by primary key (if available), otherwise by
// titleField (if available), otherwise by cell value (if available), and lastly by index.
// @visibility external
// @group autoTest
//<

//> @attr ListGrid.locateColumnsBy (string : null : IRW)
// When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
// +link{isc.AutoTest.getLocator()} for a cell in this grid, how should the column be identified?
// <br>
// Note that getLocator() will actually store all available information about the column in
// the generated string -- this attribute effects how a stored string will be parsed only.
// <P>
// Valid options area:
// <ul>
// <li><code>"fieldName"</code> Attempt to identify by fieldName.</li>
// <li><code>"index"</code> Attempt to identify by colNum (index in the fields array).</li>
// </ul>
// If unset, default behavior is to identify by fieldName (if available), otherwise by index.
//
// @visibility external
// @group autoTest
//<


//

// LineEditor
// ---------------------------------------------------------------------------------------
// A minimum-height editor that expands as you add more rows
isc.defineClass("LineEditor", isc.ListGrid).addProperties({
    canEdit:true,
    editEvent: "click",
    editOnFocus: true,
    modalEditing:true,
    // allow new record entry
    enterKeyEditAction: "nextRowStart",
    listEndEditAction: "next",
    // be one row tall initially
    height:50,
    emptyMessage:"Click to add data",
    emptyMessageStyle: "normal", // just gets rid of padding
    // expand as data is added
    autoFitData:"vertical",
    leaveScrollbarGap:false,

    // start editing on a click with an initially empty grid
    click : function () {
        var record = this.getRecord(this.getEventRow());
        //this.logWarn("click call with record: " + this.echo(record));
        this.Super("click", arguments);
        if (record == null && isc.EH.lastEvent.target == this.body) this.startEditingNew();
    }
})


// UserFormula
// ---------------------------------------------------------------------------------------
// Definition of UserFormula object and related events.
// formulaUpdated() is triggered in DataBoundComponent.js
//

//> @object UserFormula
// An object representing a user-created and user-modifiable formula, which can be created and
// edited with a +link{FormulaBuilder} either directly or via the
// +link{ListGrid.canAddFormulaFields} behavior.
//
// @treeLocation Client Reference/Grids/ListGrid
// @visibility external
//<

//> @attr userFormula.text (String : null : IRW)
// Formula to be evaluated.
// <P>
// There are two contexts where a UserFormula is used: +link{listGridField.userFormula} and
// +link{formItem.formula} or +link{listGridField.editorFormula}. For the grid field formula
// all variables used by the formula must be single-letter capital characters (eg A). These
// are derived from field values for the record in question - see +link{formulaVars}.
// <P>
// In addition to these variables, the keyword <code>record</code> may be used to
// refer directly to the record for which the formula is being displayed.
// <P>
// In the second usage context variables are dot-separated (.) names representing the nested
// hierarchy path to the desired value within the +link{canvas.ruleScope,rule context}. No
// mapping with +link{formulaVars} is needed.
//
// @visibility external
//<

//> @attr userFormula.formulaVars (Map : null : IR)
// Object mapping from variable names to fieldNames.  All variable names must be single-letter
// capital characters (eg A).  For example, for a formula that should divide the field
// "population" over the field "area", the formula might be "E/L" and formula vars would be:
// <smartclient>
// <pre>
//   {
//       E: "population",
//       L: "area"
//   }
// </pre>
// </smartclient>
// <smartgwt>
// <pre>
//   Map vars = new HashMap();
//   vars.put("E", "population");
//   vars.put("L", "area");
// </pre>
// </smartgwt>
// <p>
// When used in +link{listGridField.userFormula} context, field names are evaluated against the
// grid record.
// <p>
// When used in +link{formItem.formula} or +link{listGridField.editorFormula} this property is
// not used for formula mapping. Instead, field names are evaluated directly against the
// current +link{canvas.ruleScope,rule context}.
//
// @visibility external
//<

//> @attr listGridField.userFormula (UserFormula : null : IRW)
// Formula definition for this field.
// <P>
// Advanced applications that wish to save formulas separately from a grid's
// +link{listGrid.getViewState(),viewState} can provide a +link{UserFormula} as part of the field
// definition, and may subsequently access the formula is updated via the
// +link{listGrid.formulaUpdated()} notification.
//
// @visibility external
//<

//> @attr listGridField.canEditFormula (Boolean : null : IR)
// Can formula be edited from header context menu? Setting attribute to
// <code>false</code> prevents editing. A <code>null</code> or <code>true</code>
// value allows editing.
// <P>
// Has no effect when +link{listGrid.canAddFormulaFields} is <code>false</code>.
// 
// @visibility external
//<

//> @method listGrid.formulaUpdated()
// Notification fired when a user either creates a new formula field or edits an existing formula field.
// @param field (ListGridField) the formula field
// @param formula (UserFormula) the new or updated formula definition
//
// @visibility external
//<

//> @attr listGridField.editorFormula (UserFormula : null : IR)
// Shortcut to configure a +link{FormItem.formula} for the +link{editorType,editor} used when this
// field is +link{listGrid.canEdit,edited}.
//
// @visibility external
//<

// UserSummary
// ---------------------------------------------------------------------------------------
// Definition of UserSummary object and related events.
// summaryUpdated() is triggered in DataBoundComponent.js
//

//> @object UserSummary
// An object representing a user-created and user-modifiable summary, which can be created and
// edited with a +link{SummaryBuilder} either directly or via the
// +link{ListGrid.canAddSummaryFields} behavior.
//
// @treeLocation Client Reference/Grids/ListGrid
// @visibility external
//<

//> @attr userSummary.text (String : null : IRW)
// Summary to be evaluated.
// <P>
// There are two contexts where a UserSummary is used: +link{listGridField.userSummary} and
// +link{formItem.textFormula}. For the grid field summary all variables used by the summary
// must be all-capital letter names surrounded by braces and escaped with a # sign (eg #{A}).
// These are derived from field values for the record in question - see +link{summaryVars}.
// <P>
// In the second usage context variables are dot-separated (.) names representing the nested
// hierarchy path to the desired value within the +link{canvas.ruleScope,rule context}. No
// mapping with +link{summaryVars} is needed.
//
// @visibility external
//<

//> @attr userSummary.summaryVars (Map : null : IR)
// Map from the all-capital letter names used as summary variables in the +link{UserSummary}
// String to the fieldNames these variables should represent in the context where the
// summary is evaluated.
// <p>
// When used in +link{listGridField.userSummary} context, field names are evaluated against the
// grid record.
// <p>
// When used in +link{formItem.textFormula} this property is not used for summary mapping.
// Instead, field names are evaluated directly against the current +link{canvas.ruleScope,rule context}.
//
// @visibility external
//<

//> @attr listGridField.userSummary (UserSummary : null : IRW)
// Summary definition for this field.
// <P>
// Advanced applications that wish to save summaries separately from a grid's
// +link{listGrid.getViewState(),viewState} can provide a +link{UserSummary} as part of the
// field definition, and may subsequently access the summary is updated via the
// +link{listGrid.summaryUpdated()} notification.
//
// @visibility external
//<

//> @attr listGridField.canEditSummary (Boolean : null : IR)
// Can summary be edited from header context menu? Setting attribute to
// <code>false</code> prevents editing. A <code>null</code> or <code>true</code>
// value allows editing.
// <P>
// Has no effect when +link{listGrid.canAddSummaryFields} is <code>false</code>.
// 
// @visibility external
//<

//> @method listGrid.summaryUpdated()
// Notification fired when a user either creates a new summary field or edits an existing
// summary field.
// @param field (ListGridField) the summary field
// @param summary (UserSummary) the new or updated summary definition
//
// @visibility external
//<
