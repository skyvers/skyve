package org.skyve.impl.dataaccess.sql;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

import org.junit.Test;
import org.skyve.impl.persistence.hibernate.dialect.SkyveDialect.RDBMS;

/**
 * Tests for StreamableConnection behaviour (fetch size and direction tuning).
 */
@SuppressWarnings({"resource"})
public class StreamableConnectionTest {
	// Simple stub Statement capturing fetch parameters
	static class CapturingStatement implements Statement {
		int fetchSize;
		int fetchDirection;

		@Override
		public void setFetchSize(int rows) throws SQLException { this.fetchSize = rows; }
		@Override
		public int getFetchSize() throws SQLException { return fetchSize; }
		@Override
		public void setFetchDirection(int direction) throws SQLException { this.fetchDirection = direction; }
		@Override
		public int getFetchDirection() throws SQLException { return fetchDirection; }

		// Minimal implementations to satisfy interface; unsupported operations throw
		@Override public ResultSet executeQuery(String sql) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public int executeUpdate(String sql) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public void close() throws SQLException { /* intentional no-op for stub */ }
		@Override public int getMaxFieldSize() throws SQLException { return 0; }
		@Override public void setMaxFieldSize(int max) throws SQLException { /* intentional no-op for stub */ }
		@Override public int getMaxRows() throws SQLException { return 0; }
		@Override public void setMaxRows(int max) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setEscapeProcessing(boolean enable) throws SQLException { /* intentional no-op for stub */ }
		@Override public int getQueryTimeout() throws SQLException { return 0; }
		@Override public void setQueryTimeout(int seconds) throws SQLException { /* intentional no-op for stub */ }
		@Override public void cancel() throws SQLException { /* intentional no-op for stub */ }
		@Override public SQLWarning getWarnings() throws SQLException { return null; }
		@Override public void clearWarnings() throws SQLException { /* intentional no-op for stub */ }
		@Override public void setCursorName(String name) throws SQLException { /* intentional no-op for stub */ }
		@Override public boolean execute(String sql) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public ResultSet getResultSet() throws SQLException { return null; }
		@Override public int getUpdateCount() throws SQLException { return 0; }
		@Override public boolean getMoreResults() throws SQLException { return false; }
		@Override public void addBatch(String sql) throws SQLException { /* intentional no-op for stub */ }
		@Override public void clearBatch() throws SQLException { /* intentional no-op for stub */ }
		@Override public int[] executeBatch() throws SQLException { return new int[0]; }
		@Override public Connection getConnection() throws SQLException { return null; }
		@Override public boolean getMoreResults(int current) throws SQLException { return false; }
		@Override public ResultSet getGeneratedKeys() throws SQLException { return null; }
		@Override public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public int executeUpdate(String sql, int[] columnIndexes) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public int executeUpdate(String sql, String[] columnNames) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public boolean execute(String sql, int autoGeneratedKeys) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public boolean execute(String sql, int[] columnIndexes) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public boolean execute(String sql, String[] columnNames) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public int getResultSetHoldability() throws SQLException { return ResultSet.HOLD_CURSORS_OVER_COMMIT; }
		@Override public int getResultSetConcurrency() throws SQLException { return ResultSet.CONCUR_READ_ONLY; }
		@Override public int getResultSetType() throws SQLException { return ResultSet.TYPE_FORWARD_ONLY; }
		@Override public void setPoolable(boolean poolable) throws SQLException { /* intentional no-op for stub */ }
		@Override public boolean isPoolable() throws SQLException { return false; }
		@Override public void closeOnCompletion() throws SQLException { /* intentional no-op for stub */ }
		@Override public boolean isCloseOnCompletion() throws SQLException { return false; }
		@Override public <T> T unwrap(Class<T> iface) throws SQLException { return null; }
		@Override public boolean isWrapperFor(Class<?> iface) throws SQLException { return false; }
		@Override public long getLargeUpdateCount() throws SQLException { return 0; }
		@Override public void setLargeMaxRows(long max) throws SQLException { /* intentional no-op for stub */ }
		@Override public long getLargeMaxRows() throws SQLException { return 0; }
		@Override public long[] executeLargeBatch() throws SQLException { return new long[0]; }
		@Override public long executeLargeUpdate(String sql) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException { throw new UnsupportedOperationException(); }
		@Override public boolean isClosed() throws SQLException { return false; }
	}

	// Simple stub PreparedStatement extending CapturingStatement
	static class CapturingPreparedStatement extends CapturingStatement implements PreparedStatement {
		@Override public ResultSet executeQuery() throws SQLException { throw new UnsupportedOperationException(); }
		@Override public int executeUpdate() throws SQLException { throw new UnsupportedOperationException(); }
		@Override public void setNull(int parameterIndex, int sqlType) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setBoolean(int parameterIndex, boolean x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setByte(int parameterIndex, byte x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setShort(int parameterIndex, short x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setInt(int parameterIndex, int x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setLong(int parameterIndex, long x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setFloat(int parameterIndex, float x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setDouble(int parameterIndex, double x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setBigDecimal(int parameterIndex, java.math.BigDecimal x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setString(int parameterIndex, String x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setBytes(int parameterIndex, byte[] x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setDate(int parameterIndex, java.sql.Date x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setTime(int parameterIndex, java.sql.Time x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setTimestamp(int parameterIndex, java.sql.Timestamp x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void clearParameters() throws SQLException { /* intentional no-op for stub */ }
		@Override public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setObject(int parameterIndex, Object x) throws SQLException { /* intentional no-op for stub */ }
		@Override public boolean execute() throws SQLException { throw new UnsupportedOperationException(); }
		@Override public void addBatch() throws SQLException { /* intentional no-op for stub */ }
		@Override public void setCharacterStream(int parameterIndex, java.io.Reader reader, int length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setRef(int parameterIndex, java.sql.Ref x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setBlob(int parameterIndex, Blob x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setClob(int parameterIndex, Clob x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setArray(int parameterIndex, Array x) throws SQLException { /* intentional no-op for stub */ }
		@Override public ResultSetMetaData getMetaData() throws SQLException { return null; }
		@Override public void setDate(int parameterIndex, java.sql.Date x, java.util.Calendar cal) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setTime(int parameterIndex, java.sql.Time x, java.util.Calendar cal) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setTimestamp(int parameterIndex, java.sql.Timestamp x, java.util.Calendar cal) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setURL(int parameterIndex, java.net.URL x) throws SQLException { /* intentional no-op for stub */ }
		@Override public ParameterMetaData getParameterMetaData() throws SQLException { return null; }
		@Override public void setRowId(int parameterIndex, java.sql.RowId x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setNString(int parameterIndex, String value) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setNCharacterStream(int parameterIndex, java.io.Reader value, long length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setNClob(int parameterIndex, NClob value) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setClob(int parameterIndex, java.io.Reader reader, long length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setBlob(int parameterIndex, java.io.InputStream inputStream, long length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setNClob(int parameterIndex, java.io.Reader reader, long length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setAsciiStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setBinaryStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setCharacterStream(int parameterIndex, java.io.Reader reader, long length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setBinaryStream(int parameterIndex, java.io.InputStream x, long length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setAsciiStream(int parameterIndex, java.io.InputStream x, long length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setNCharacterStream(int parameterIndex, java.io.Reader value) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setClob(int parameterIndex, java.io.Reader reader) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setBlob(int parameterIndex, java.io.InputStream inputStream) throws SQLException { /* intentional no-op for stub */ }
		@Override public long executeLargeUpdate() throws SQLException { throw new UnsupportedOperationException(); }
		// Add missing JDBC 4.0/4.1 overloads
		@Override public void setAsciiStream(int parameterIndex, java.io.InputStream x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setBinaryStream(int parameterIndex, java.io.InputStream x) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setCharacterStream(int parameterIndex, java.io.Reader reader) throws SQLException { /* intentional no-op for stub */ }
		// Implement deprecated and required abstract methods to satisfy interface
		@Override public void setUnicodeStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setNClob(int parameterIndex, java.io.Reader reader) throws SQLException { /* intentional no-op for stub */ }
	}

	// Simple stub Connection returning capturing statements/prepared statements
	static class CapturingConnection implements Connection {
		final CapturingStatement statement = new CapturingStatement();
		final CapturingPreparedStatement preparedStatement = new CapturingPreparedStatement();

		@Override public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException { return statement; }
		@Override public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { return statement; }
		@Override public Statement createStatement() throws SQLException { return statement; }
		@Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException { return preparedStatement; }
		@Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { return preparedStatement; }
		@Override public PreparedStatement prepareStatement(String sql) throws SQLException { return preparedStatement; }
		@Override public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException { return preparedStatement; }
		@Override public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException { return preparedStatement; }
		@Override public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException { return preparedStatement; }

		// Minimal implementations
		@Override public CallableStatement prepareCall(String sql) throws SQLException { return null; }
		@Override public String nativeSQL(String sql) throws SQLException { return null; }
		@Override public void setAutoCommit(boolean autoCommit) throws SQLException { /* intentional no-op for stub */ }
		@Override public boolean getAutoCommit() throws SQLException { return true; }
		@Override public void commit() throws SQLException { /* intentional no-op for stub */ }
		@Override public void rollback() throws SQLException { /* intentional no-op for stub */ }
		@Override public void close() throws SQLException { /* intentional no-op for stub */ }
		@Override public boolean isClosed() throws SQLException { return false; }
		@Override public DatabaseMetaData getMetaData() throws SQLException { return null; }
		@Override public void setReadOnly(boolean readOnly) throws SQLException { /* intentional no-op for stub */ }
		@Override public boolean isReadOnly() throws SQLException { return false; }
		@Override public void setCatalog(String catalog) throws SQLException { /* intentional no-op for stub */ }
		@Override public String getCatalog() throws SQLException { return null; }
		@Override public void setTransactionIsolation(int level) throws SQLException { /* intentional no-op for stub */ }
		@Override public int getTransactionIsolation() throws SQLException { return Connection.TRANSACTION_READ_COMMITTED; }
		@Override public SQLWarning getWarnings() throws SQLException { return null; }
		@Override public void clearWarnings() throws SQLException { /* intentional no-op for stub */ }
		@Override public Map<String, Class<?>> getTypeMap() throws SQLException { return null; }
		@Override public void setTypeMap(Map<String, Class<?>> map) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setHoldability(int holdability) throws SQLException { /* intentional no-op for stub */ }
		@Override public int getHoldability() throws SQLException { return ResultSet.HOLD_CURSORS_OVER_COMMIT; }
		@Override public Savepoint setSavepoint() throws SQLException { return null; }
		@Override public Savepoint setSavepoint(String name) throws SQLException { return null; }
		@Override public void rollback(Savepoint savepoint) throws SQLException { /* intentional no-op for stub */ }
		@Override public void releaseSavepoint(Savepoint savepoint) throws SQLException { /* intentional no-op for stub */ }
		@Override public Clob createClob() throws SQLException { return null; }
		@Override public Blob createBlob() throws SQLException { return null; }
		@Override public NClob createNClob() throws SQLException { return null; }
		@Override public SQLXML createSQLXML() throws SQLException { return null; }
		@Override public boolean isValid(int timeout) throws SQLException { return true; }
		@Override public void setClientInfo(String name, String value) throws java.sql.SQLClientInfoException { /* intentional no-op for stub */ }
		@Override public void setClientInfo(Properties properties) throws java.sql.SQLClientInfoException { /* intentional no-op for stub */ }
		@Override public String getClientInfo(String name) throws SQLException { return null; }
		@Override public Properties getClientInfo() throws SQLException { return new Properties(); }
		@Override public Array createArrayOf(String typeName, Object[] elements) throws SQLException { return null; }
		@Override public Struct createStruct(String typeName, Object[] attributes) throws SQLException { return null; }
		@Override public void setSchema(String schema) throws SQLException { /* intentional no-op for stub */ }
		@Override public String getSchema() throws SQLException { return null; }
		@Override public void abort(Executor executor) throws SQLException { /* intentional no-op for stub */ }
		@Override public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException { /* intentional no-op for stub */ }
		@Override public int getNetworkTimeout() throws SQLException { return 0; }
		@Override public <T> T unwrap(Class<T> iface) throws SQLException { return null; }
		@Override public boolean isWrapperFor(Class<?> iface) throws SQLException { return false; }
		@Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException { return null; }
		@Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { return null; }
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void tunePreparedStatement_mysql_usesIntegerMinValue() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.mysql);
		PreparedStatement ps = conn.prepareStatement("select 1");
		CapturingPreparedStatement cps = (CapturingPreparedStatement) ps;
		assertEquals(Integer.MIN_VALUE, cps.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cps.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void tunePreparedStatement_other_usesDefault1000() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.postgresql);
		PreparedStatement ps = conn.prepareStatement("select 1");
		CapturingPreparedStatement cps = (CapturingPreparedStatement) ps;
		assertEquals(1000, cps.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cps.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void tuneStatement_mysql_usesIntegerMinValue() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.mysql);
		Statement s = conn.createStatement();
		CapturingStatement cs = (CapturingStatement) s;
		assertEquals(Integer.MIN_VALUE, cs.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cs.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void tuneStatement_other_usesDefault1000() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.sqlserver);
		Statement s = conn.createStatement();
		CapturingStatement cs = (CapturingStatement) s;
		assertEquals(1000, cs.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cs.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void prepareStatement_withAutoGeneratedKeys_appliesTuning_mysql() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.mysql);
		PreparedStatement ps = conn.prepareStatement("select 1", Statement.RETURN_GENERATED_KEYS);
		CapturingPreparedStatement cps = (CapturingPreparedStatement) ps;
		assertEquals(Integer.MIN_VALUE, cps.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cps.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void prepareStatement_withAutoGeneratedKeys_appliesTuning_other() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.postgresql);
		PreparedStatement ps = conn.prepareStatement("select 1", Statement.RETURN_GENERATED_KEYS);
		CapturingPreparedStatement cps = (CapturingPreparedStatement) ps;
		assertEquals(1000, cps.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cps.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void prepareStatement_withColumnIndexes_appliesTuning() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.sqlserver);
		PreparedStatement ps = conn.prepareStatement("select 1", new int[] {1, 2});
		CapturingPreparedStatement cps = (CapturingPreparedStatement) ps;
		assertEquals(1000, cps.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cps.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void prepareStatement_withColumnNames_appliesTuning() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.sqlserver);
		PreparedStatement ps = conn.prepareStatement("select 1", new String[] {"id", "code"});
		CapturingPreparedStatement cps = (CapturingPreparedStatement) ps;
		assertEquals(1000, cps.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cps.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void prepareStatement_withTypeConcurrency_appliesTuning() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.postgresql);
		PreparedStatement ps = conn.prepareStatement("select 1", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
		CapturingPreparedStatement cps = (CapturingPreparedStatement) ps;
		assertEquals(1000, cps.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cps.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void prepareStatement_withTypeConcurrencyHoldability_appliesTuning_mysql() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.mysql);
		PreparedStatement ps = conn.prepareStatement("select 1", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
		CapturingPreparedStatement cps = (CapturingPreparedStatement) ps;
		assertEquals(Integer.MIN_VALUE, cps.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cps.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void createStatement_withTypeConcurrency_appliesTuning() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.postgresql);
		Statement s = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
		CapturingStatement cs = (CapturingStatement) s;
		assertEquals(1000, cs.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cs.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void createStatement_withTypeConcurrencyHoldability_appliesTuning_mysql() throws SQLException {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.mysql);
		Statement s = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
		CapturingStatement cs = (CapturingStatement) s;
		assertEquals(Integer.MIN_VALUE, cs.fetchSize);
		assertEquals(ResultSet.FETCH_FORWARD, cs.fetchDirection);
	}

	@Test
	@SuppressWarnings({"static-method"})
	public void coverAllDelegatedMethods() throws Exception {
		CapturingConnection base = new CapturingConnection();
		StreamableConnection conn = new StreamableConnection(base, RDBMS.postgresql);

		// unwrap/isWrapperFor
		assertNull(conn.unwrap(Object.class));
		assertFalse(conn.isWrapperFor(Object.class));

		// Callable statements and native SQL
		assertNull(conn.prepareCall("call x"));
		assertNull(conn.prepareCall("call x", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY));
		assertNull(conn.prepareCall("call x", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT));
		assertNull(conn.nativeSQL("select 1"));

		// Auto-commit, commit, rollback
		conn.setAutoCommit(true);
		assertTrue(conn.getAutoCommit());
		conn.commit();
		conn.rollback();

		// Close and isClosed
		conn.close();
		assertFalse(conn.isClosed());

		// Metadata
		assertNull(conn.getMetaData());

		// Read-only
		conn.setReadOnly(false);
		assertFalse(conn.isReadOnly());

		// Catalog
		conn.setCatalog("cat");
		assertNull(conn.getCatalog());

		// Transaction isolation
		conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
		assertEquals(Connection.TRANSACTION_READ_COMMITTED, conn.getTransactionIsolation());

		// Warnings
		assertNull(conn.getWarnings());
		conn.clearWarnings();

		// Type map
		assertNull(conn.getTypeMap());
		conn.setTypeMap(null);

		// Holdability
		conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
		assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, conn.getHoldability());

		// Savepoints
		assertNull(conn.setSavepoint());
		Savepoint sp = conn.setSavepoint("sp");
		assertNull(sp);
		conn.rollback(sp);
		conn.releaseSavepoint(sp);

		// LOB and SQLXML creation
		assertNull(conn.createClob());
		assertNull(conn.createBlob());
		assertNull(conn.createNClob());
		assertNull(conn.createSQLXML());

		// Valid
		assertTrue(conn.isValid(1));

		// Client info
		conn.setClientInfo("k", "v");
		Properties p = new Properties();
		p.setProperty("a", "b");
		conn.setClientInfo(p);
		assertNull(conn.getClientInfo("k"));
		assertNotNull(conn.getClientInfo());

		// Array/Struct
		assertNull(conn.createArrayOf("VARCHAR", new Object[] {"x"}));
		assertNull(conn.createStruct("S", new Object[] {"x"}));

		// Schema
		conn.setSchema("public");
		assertNull(conn.getSchema());

		// Abort and network timeout
		conn.abort(new Executor() { @Override public void execute(Runnable command) { command.run(); } });
		conn.setNetworkTimeout(new Executor() { @Override public void execute(Runnable command) { command.run(); } }, 10);
		assertEquals(0, conn.getNetworkTimeout());

		// Prepare statements and create statements across methods to ensure paths covered with current RDBMS
		PreparedStatement ps1 = conn.prepareStatement("select 1");
		PreparedStatement ps2 = conn.prepareStatement("select 1", Statement.RETURN_GENERATED_KEYS);
		PreparedStatement ps3 = conn.prepareStatement("select 1", new int[] {1});
		PreparedStatement ps4 = conn.prepareStatement("select 1", new String[] {"id"});
		PreparedStatement ps5 = conn.prepareStatement("select 1", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
		PreparedStatement ps6 = conn.prepareStatement("select 1", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
		assertNotNull(ps1);
		assertNotNull(ps2);
		assertNotNull(ps3);
		assertNotNull(ps4);
		assertNotNull(ps5);
		assertNotNull(ps6);

		Statement s1 = conn.createStatement();
		Statement s2 = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
		Statement s3 = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
		assertNotNull(s1);
		assertNotNull(s2);
		assertNotNull(s3);
	}
}