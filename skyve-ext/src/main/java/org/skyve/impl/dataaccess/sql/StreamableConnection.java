package org.skyve.impl.dataaccess.sql;

import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

import org.skyve.impl.persistence.hibernate.dialect.SkyveDialect.RDBMS;

/**
 * A Connection wrapper that tunes statements for forward-only, read-only, streaming ResultSets.
 *
 * <p>Purpose:
 * <ul>
 *   <li>Set a sensible fetch size and forward-only fetch direction on created statements to
 *       enable streaming of large result sets and reduce memory usage.</li>
 *   <li>Apply MySQL-specific streaming behavior by using {@code Integer.MIN_VALUE} as fetch size
 *       which instructs the MySQL JDBC driver to stream results rather than buffer them fully.</li>
 * </ul>
 *
 * <p>Behavior:
 * <ul>
 *   <li>For MySQL, fetch size = {@code Integer.MIN_VALUE}.</li>
 *   <li>For other RDBMS, a default fetch size of 1000 rows is used.</li>
 *   <li>Fetch direction is always {@link ResultSet#FETCH_FORWARD}.</li>
 *   <li>All other {@link Connection} methods delegate to the underlying connection unchanged.</li>
 * </ul>
 *
 * <p>Notes:
 * <ul>
 *   <li>Only tuning is applied to statements created via {@code prepareStatement(...)} and
 *       {@code createStatement(...)} methods. Callable statements are delegated directly as many
 *       drivers do not support fetch-size tuning on them.</li>
 *   <li>This wrapper is intended for read-mostly access paths where forward-only streaming is
 *       appropriate.</li>
 * </ul>
 */
public class StreamableConnection implements Connection {
	// The underlying JDBC connection.
	private final Connection delegate;
	
	// The fetch size applied to prepared and simple statements.
	private final int fetchSize;

	/**
	 * Construct a streamable connection wrapper.
	 *
	 * @param delegate the underlying JDBC connection to wrap
	 * @param rdbms the detected/target RDBMS, used to select an appropriate fetch-size policy
	 */
	public StreamableConnection(Connection delegate, RDBMS rdbms) {
		this.delegate = delegate;
		this.fetchSize = RDBMS.mysql.equals(rdbms) ? Integer.MIN_VALUE : 1000;
	}

	/**
	 * Apply tuning parameters to a prepared statement for streaming reads.
	 *
	 * @param ps the prepared statement to tune
	 * @return the tuned prepared statement (same instance)
	 * @throws SQLException if the driver rejects tuning options
	 */
	private PreparedStatement tune(PreparedStatement ps) throws SQLException {
		ps.setFetchSize(fetchSize);
		ps.setFetchDirection(ResultSet.FETCH_FORWARD);
		return ps;
	}
	
	/**
	 * Apply tuning parameters to a simple statement for streaming reads.
	 *
	 * @param s the statement to tune
	 * @return the tuned statement (same instance)
	 * @throws SQLException if the driver rejects tuning options
	 */
	private Statement tune(Statement s) throws SQLException {
		s.setFetchSize(fetchSize);
		s.setFetchDirection(ResultSet.FETCH_FORWARD);
		return s;
	}

	/**
	 * Apply tuning parameters to a callable statement for streaming reads.
	 *
	 * @param s the statement to tune
	 * @return the tuned statement (same instance)
	 * @throws SQLException if the driver rejects tuning options
	 */
	private CallableStatement tune(CallableStatement cs) throws SQLException {
		cs.setFetchSize(fetchSize);
		cs.setFetchDirection(ResultSet.FETCH_FORWARD);
		return cs;
	}

	/**
	 * Create a forward-only, read-only prepared statement tuned for streaming.
	 */
	@Override
	@SuppressWarnings("resource")
	public PreparedStatement prepareStatement(String sql) throws SQLException {
		return tune(delegate.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY));
	}

	/**
	 * Create a prepared statement tuned for streaming, returning auto-generated keys if requested.
	 */
	@Override
	@SuppressWarnings("resource")
	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
		return tune(delegate.prepareStatement(sql, autoGeneratedKeys));
	}

	/**
	 * Create a prepared statement tuned for streaming, targeting specified column indexes for keys.
	 */
	@Override
	@SuppressWarnings("resource")
	public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
		return tune(delegate.prepareStatement(sql, columnIndexes));
	}

	/**
	 * Create a prepared statement tuned for streaming, targeting specified column names for keys.
	 */
	@Override
	@SuppressWarnings("resource")
	public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
		return tune(delegate.prepareStatement(sql, columnNames));
	}

	/**
	 * Create a prepared statement tuned for streaming with explicit result set type/concurrency.
	 */
	@Override
	@SuppressWarnings("resource")
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
	throws SQLException {
		return tune(delegate.prepareStatement(sql, resultSetType, resultSetConcurrency));
	}

	/**
	 * Create a prepared statement tuned for streaming with explicit type/concurrency/holdability.
	 */
	@Override
	@SuppressWarnings("resource")
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)
	throws SQLException {
		return tune(delegate.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
	}

	/**
	 * Create a forward-only, read-only statement tuned for streaming.
	 */
	@Override
	@SuppressWarnings("resource")
	public Statement createStatement() throws SQLException {
		Statement result = delegate.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
		return tune(result);
	}

	/**
	 * Create a statement tuned for streaming with explicit result set type/concurrency.
	 */
	@Override
	@SuppressWarnings("resource")
	public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
		Statement result = delegate.createStatement(resultSetType, resultSetConcurrency);
		return tune(result);
	}

	/**
	 * Create a statement tuned for streaming with explicit type/concurrency/holdability.
	 */
	@Override
	@SuppressWarnings("resource")
	public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
	throws SQLException {
		Statement result = delegate.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
		return tune(result);
	}

	/**
	 * Unwrap this connection to the specified interface type.
	 * @param iface the class representing the interface to unwrap to
	 * @return the object implementing the specified interface
	 * @throws SQLException if the connection does not support unwrapping to the given iface
	 */
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return delegate.unwrap(iface);
	}

	/**
	 * Determine whether this connection is a wrapper for the given interface.
	 * @param iface the interface to test
	 * @return true if this is a wrapper for the specified interface
	 * @throws SQLException if an error occurs while determining wrapper status
	 */
	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return delegate.isWrapperFor(iface);
	}

	/**
	 * Prepare a callable statement.
	 * @param sql the SQL to compile for the stored procedure/function call
	 * @return a {@link CallableStatement}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	@SuppressWarnings("resource")
	public CallableStatement prepareCall(String sql) throws SQLException {
		CallableStatement result = delegate.prepareCall(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
		return tune(result);
	}

	/**
	 * Prepare a callable statement with the given result set type and concurrency.
	 * @param sql the SQL to compile
	 * @param resultSetType the result set type
	 * @param resultSetConcurrency the result set concurrency
	 * @return a {@link CallableStatement}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	@SuppressWarnings("resource")
	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		return tune(delegate.prepareCall(sql, resultSetType, resultSetConcurrency));
	}

	/**
	 * Prepare a callable statement with the given type, concurrency, and holdability.
	 * @param sql the SQL to compile
	 * @param resultSetType the result set type
	 * @param resultSetConcurrency the result set concurrency
	 * @param resultSetHoldability the holdability
	 * @return a {@link CallableStatement}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	@SuppressWarnings("resource")
	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		return tune(delegate.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
	}

	/**
	 * Translate SQL into the native SQL syntax of the underlying database.
	 * @param sql an SQL statement
	 * @return the native form of the statement
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public String nativeSQL(String sql) throws SQLException {
		return delegate.nativeSQL(sql);
	}

	/**
	 * Set the auto-commit mode.
	 * @param autoCommit true to enable auto-commit; false to disable
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void setAutoCommit(boolean autoCommit) throws SQLException {
		delegate.setAutoCommit(autoCommit);
	}

	/**
	 * Get the current auto-commit mode.
	 * @return true if auto-commit is enabled; false otherwise
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public boolean getAutoCommit() throws SQLException {
		return delegate.getAutoCommit();
	}

	/**
	 * Commit the current transaction.
	 * @throws SQLException if a database access error occurs or auto-commit is enabled
	 */
	@Override
	public void commit() throws SQLException {
		delegate.commit();
	}

	/**
	 * Roll back the current transaction.
	 * @throws SQLException if a database access error occurs or auto-commit is enabled
	 */
	@Override
	public void rollback() throws SQLException {
		delegate.rollback();
	}

	/**
	 * Close this connection.
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void close() throws SQLException {
		delegate.close();
	}

	/**
	 * Check whether the connection is closed.
	 * @return true if closed; false otherwise
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public boolean isClosed() throws SQLException {
		return delegate.isClosed();
	}

	/**
	 * Get metadata for the database.
	 * @return the {@link DatabaseMetaData}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public DatabaseMetaData getMetaData() throws SQLException {
		return delegate.getMetaData();
	}

	/**
	 * Set the read-only flag for this connection.
	 * @param readOnly true to request read-only; false otherwise
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void setReadOnly(boolean readOnly) throws SQLException {
		delegate.setReadOnly(readOnly);
	}

	/**
	 * Determine whether this connection is flagged read-only.
	 * @return true if read-only; false otherwise
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public boolean isReadOnly() throws SQLException {
		return delegate.isReadOnly();
	}

	/**
	 * Set the current catalog.
	 * @param catalog the catalog name
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void setCatalog(String catalog) throws SQLException {
		delegate.setCatalog(catalog);
	}

	/**
	 * Get the current catalog.
	 * @return the catalog name
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public String getCatalog() throws SQLException {
		return delegate.getCatalog();
	}

	/**
	 * Set the transaction isolation level.
	 * @param level the isolation level constant
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void setTransactionIsolation(int level) throws SQLException {
		delegate.setTransactionIsolation(level);
	}

	/**
	 * Get the transaction isolation level.
	 * @return the isolation level constant
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public int getTransactionIsolation() throws SQLException {
		return delegate.getTransactionIsolation();
	}

	/**
	 * Retrieve the first warning reported by calls on this Connection.
	 * @return the first {@link SQLWarning}, or null if none
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public SQLWarning getWarnings() throws SQLException {
		return delegate.getWarnings();
	}

	/**
	 * Clear all warnings reported for this Connection.
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void clearWarnings() throws SQLException {
		delegate.clearWarnings();
	}

	/**
	 * Get this connection's type map.
	 * @return the type map
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public Map<String, Class<?>> getTypeMap() throws SQLException {
		return delegate.getTypeMap();
	}

	/**
	 * Set this connection's type map.
	 * @param map the new type map
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
		delegate.setTypeMap(map);
	}

	/**
	 * Set the holdability of ResultSets created using this connection.
	 * @param holdability the holdability constant
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void setHoldability(int holdability) throws SQLException {
		delegate.setHoldability(holdability);
	}

	/**
	 * Get the holdability of ResultSets created using this connection.
	 * @return the holdability constant
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public int getHoldability() throws SQLException {
		return delegate.getHoldability();
	}

	/**
	 * Create an unnamed savepoint in the current transaction.
	 * @return the new {@link Savepoint}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public Savepoint setSavepoint() throws SQLException {
		return delegate.setSavepoint();
	}

	/**
	 * Create a named savepoint in the current transaction.
	 * @param name the savepoint name
	 * @return the new {@link Savepoint}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public Savepoint setSavepoint(String name) throws SQLException {
		return delegate.setSavepoint(name);
	}

	/**
	 * Roll back to the specified savepoint.
	 * @param savepoint the savepoint to roll back to
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void rollback(Savepoint savepoint) throws SQLException {
		delegate.rollback(savepoint);
	}

	/**
	 * Remove the specified savepoint from the current transaction.
	 * @param savepoint the savepoint to release
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void releaseSavepoint(Savepoint savepoint) throws SQLException {
		delegate.releaseSavepoint(savepoint);
	}

	/**
	 * Create a CLOB value.
	 * @return a new {@link Clob}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public Clob createClob() throws SQLException {
		return delegate.createClob();
	}

	/**
	 * Create a BLOB value.
	 * @return a new {@link Blob}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public Blob createBlob() throws SQLException {
		return delegate.createBlob();
	}

	/**
	 * Create an NCLOB value.
	 * @return a new {@link NClob}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public NClob createNClob() throws SQLException {
		return delegate.createNClob();
	}

	/**
	 * Create an SQLXML value.
	 * @return a new {@link SQLXML}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public SQLXML createSQLXML() throws SQLException {
		return delegate.createSQLXML();
	}

	/**
	 * Test whether the connection is valid.
	 * @param timeout the timeout value in seconds
	 * @return true if valid within the timeout; false otherwise
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public boolean isValid(int timeout) throws SQLException {
		return delegate.isValid(timeout);
	}

	/**
	 * Set a client info property.
	 * @param name the property name
	 * @param value the property value
	 * @throws SQLClientInfoException if the client info properties cannot be set
	 */
	@Override
	public void setClientInfo(String name, String value) throws SQLClientInfoException {
		delegate.setClientInfo(name, value);
	}

	/**
	 * Set multiple client info properties.
	 * @param properties the properties to set
	 * @throws SQLClientInfoException if the client info properties cannot be set
	 */
	@Override
	public void setClientInfo(Properties properties) throws SQLClientInfoException {
		delegate.setClientInfo(properties);
	}

	/**
	 * Get a client info property.
	 * @param name the property name
	 * @return the property value or null if not set
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public String getClientInfo(String name) throws SQLException {
		return delegate.getClientInfo(name);
	}

	/**
	 * Get all client info properties.
	 * @return the properties
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public Properties getClientInfo() throws SQLException {
		return delegate.getClientInfo();
	}

	/**
	 * Create an SQL ARRAY value.
	 * @param typeName the SQL type name of the array elements
	 * @param elements the array elements
	 * @return the new {@link Array}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
		return delegate.createArrayOf(typeName, elements);
	}

	/**
	 * Create an SQL STRUCT value.
	 * @param typeName the SQL type name
	 * @param attributes the SQL attributes
	 * @return the new {@link Struct}
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
		return delegate.createStruct(typeName, attributes);
	}

	/**
	 * Set the current schema.
	 * @param schema the schema name
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void setSchema(String schema) throws SQLException {
		delegate.setSchema(schema);
	}

	/**
	 * Get the current schema.
	 * @return the schema name
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public String getSchema() throws SQLException {
		return delegate.getSchema();
	}

	/**
	 * Immediately aborts this connection's ongoing operations.
	 * @param executor the executor used to cancel work
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void abort(Executor executor) throws SQLException {
		delegate.abort(executor);
	}

	/**
	 * Set the network timeout for this connection.
	 * @param executor the executor used to cancel work
	 * @param milliseconds the timeout in milliseconds
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
		delegate.setNetworkTimeout(executor, milliseconds);
	}

	/**
	 * Get the network timeout for this connection.
	 * @return the timeout in milliseconds
	 * @throws SQLException if a database access error occurs
	 */
	@Override
	public int getNetworkTimeout() throws SQLException {
		return delegate.getNetworkTimeout();
	}
}
