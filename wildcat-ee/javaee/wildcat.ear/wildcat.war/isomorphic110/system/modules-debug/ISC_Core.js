
/*

  SmartClient Ajax RIA system
  Version v11.0p_2016-03-31/LGPL Deployment (2016-03-31)

  Copyright 2000 and beyond Isomorphic Software, Inc. All rights reserved.
  "SmartClient" is a trademark of Isomorphic Software, Inc.

  LICENSE NOTICE
     INSTALLATION OR USE OF THIS SOFTWARE INDICATES YOUR ACCEPTANCE OF
     ISOMORPHIC SOFTWARE LICENSE TERMS. If you have received this file
     without an accompanying Isomorphic Software license file, please
     contact licensing@isomorphic.com for details. Unauthorized copying and
     use of this software is a violation of international copyright law.

  DEVELOPMENT ONLY - DO NOT DEPLOY
     This software is provided for evaluation, training, and development
     purposes only. It may include supplementary components that are not
     licensed for deployment. The separate DEPLOY package for this release
     contains SmartClient components that are licensed for deployment.

  PROPRIETARY & PROTECTED MATERIAL
     This software contains proprietary materials that are protected by
     contract and intellectual property law. You are expressly prohibited
     from attempting to reverse engineer this software or modify this
     software for human readability.

  CONTACT ISOMORPHIC
     For more information regarding license rights and restrictions, or to
     report possible license violations, please contact Isomorphic Software
     by email (licensing@isomorphic.com) or web (www.isomorphic.com).

*/

var isc = window.isc ? window.isc : {};if(window.isc&&!window.isc.module_Core){isc.module_Core=1;isc._moduleStart=isc._Core_start=(isc.timestamp?isc.timestamp():new Date().getTime());if(isc._moduleEnd&&(!isc.Log||(isc.Log && isc.Log.logIsDebugEnabled('loadTime')))){isc._pTM={ message:'Core load/parse time: ' + (isc._moduleStart-isc._moduleEnd) + 'ms', category:'loadTime'};
if(isc.Log && isc.Log.logDebug)isc.Log.logDebug(isc._pTM.message,'loadTime');
else if(isc._preLog)isc._preLog[isc._preLog.length]=isc._pTM;
else isc._preLog=[isc._pTM]}isc.definingFramework=true;


//> @class isc
// The <code>isc</code> object contains global methods and objects of the Isomorphic SmartClient
// framework.
// <P>
// See also +link{group:simpleNamesMode,Simple Names mode}.
//
// @treeLocation Client Reference/System
// @visibility external
//<

//> @groupDef simpleNamesMode
// When SmartClient runs in "simple names" mode (the default), all ISC Classes and several
// global methods are installed as JavaScript global variables, that is, properties of the
// browser's "window" object.  When simple names mode is disabled (called "portal mode"),
// the framework uses only the global variable: "isc" and global variables prefixed with
// "isc_".
// <P>
// Portal mode is intended for applications which must integrate with fairly arbitrary
// JavaScript code written by third-party developers, and/or third party JavaScript frameworks,
// where it is important that each framework stays within it's own namespace.
// <P>
// <smartclient>
// In portal mode, all references to ISC classes and global functions must be prefixed with
// "isc.", for example:<pre>
//
//      Canvas.create(addProperties({}, myDefaults))
//
// </pre>would become<pre>
//
//      isc.Canvas.create(isc.addProperties({}, myDefaults));
//
// </pre>
// </smartclient>
// Portal mode is enabled by setting <code>window.isc_useSimpleNames = false</code> <b>before</b>
// SmartClient is loaded, generally inside the &lt;head&gt; element.
//
// @treeLocation Client Reference/System
// @title Simple Names mode
// @visibility external
//<





var isc = window.isc ? window.isc : {};
isc._start = new Date().getTime();

// versioning - values of the form ${value} are replaced with user-provided values at build time.
// Valid values are: version, date, project (not currently used)
isc.version = "v11.0p_2016-03-31/LGPL Deployment";
isc.versionNumber = "v11.0p_2016-03-31";
isc.buildDate = "2016-03-31";
isc.expirationDate = "";

isc.scVersion = "11.0p";
isc.scVersionNumber = "11.0";
isc.sgwtVersion = "6.0p";
isc.sgwtVersionNumber = "6.0";

// these reflect the latest stable version relative to the branch from which this build is
// created.  So for example for 11.0d/6.0d, this will be 10.1/5.1.  But for 10.0/5.0 this will
// be 10.0/5.0.
isc.scParityStableVersionNumber = "11.0";
isc.sgwtParityStableVersionNumber = "6.0";

// license template data
isc.licenseType = "LGPL";
isc.licenseCompany = "Isomorphic Software";
isc.licenseSerialNumber = "ISC_LGPL_NIGHTLY";
isc.licensingPage = "http://smartclient.com/product/";

isc._$debugModules = "debugModules";
isc._$nonDebugModules = "nonDebugModules";
isc.checkForDebugAndNonDebugModules = function () {
    if (isc.checkForDebugAndNonDebugModules._loggedWarning) return;
    var debugModules = isc['_' + this._$debugModules],
        haveDebugModules = debugModules != null && debugModules.length > 0,
        nonDebugModules = isc['_' + this._$nonDebugModules],
        haveNonDebugModules = nonDebugModules != null && nonDebugModules.length > 0;

    if (haveDebugModules && haveNonDebugModules) {
        isc.logWarn("Both Debug and non-Debug modules were loaded; the Debug versions of '" +
        debugModules.join("', '") + "' and the non-Debug versions of '" + nonDebugModules.join("', '") +
        "' were loaded. Mixing Debug and non-Debug modules is not supported and may lead to " +
        "JavaScript errors and/or unpredictable behavior. " +
        "To fix, ensure that only modules in the modules/ folder or the modules-debug/ " +
        "folder are loaded and clear the browser cache. If using Smart GWT, also clear the " +
        "GWT unit cache and recompile.");
        isc.checkForDebugAndNonDebugModules._loggedWarning = true;
    }
};

isc._optionalModules = {
    SCServer: {present: "false", name: "SmartClient Server", serverOnly: true, isPro: true},
    Drawing: {present: "true", name: "Drawing Module"},
    PluginBridges: {present: "true", name: "PluginBridges Module"},
    RichTextEditor: {present: "true", name: "RichTextEditor Module"},
    Calendar: {present: "true", name: "Calendar Module"},
    Analytics: {present: "false", name: "Analytics Module"},
    Charts: {present: "false", name: "Charts Module"},
    Tools: {present: "${includeTools}", name: "Dashboards and Tools Module"},
    NetworkPerformance: {present: "false", name: "Network Performance Module"},
    // alias for NetworkPerformance
    FileLoader: {present: "false", name: "Network Performance Module"},
    RealtimeMessaging: {present: "false", name: "RealtimeMessaging Module"},
    // Enterprise Features
    serverCriteria: {present: "false", name: "Server Advanced Filtering", serverOnly: true, isFeature: true},
    customSQL: {present: "false", name: "SQL Templating", serverOnly: true, isFeature: true},
    chaining: {present: "false", name: "Transaction Chaining", serverOnly: true, isFeature: true},
    batchDSGenerator: {present: "false", name: "Batch DS-Generator", serverOnly: true, isFeature: true},
    batchUploader: {present: "false", name: "Batch Uploader", serverOnly: true, isFeature: true},
    transactions: {present: "false", name: "Automatic Transaction Management", serverOnly: true, isFeature: true}
};
isc.canonicalizeModules = function (modules) {
    if (!modules) return null;

    // canonicalize to Array, split on comma
    if (isc.isA.String(modules)) {
        if (modules.indexOf(",") != -1) {
            modules = modules.split(",");
            var trimLeft = /^\s+/, trimRight = /\s+$/;
            for (var i=0; i<modules.length; i++) {
                modules[i] = modules[i].replace(trimLeft, "").replace(trimRight, "");
            }
        } else modules = [modules];
    }
    return modules;
};
isc.hasOptionalModules = function (modules) {
    // ease of use shortcut, null value means no optional module requirements
    if (!modules) return true;

    modules = isc.canonicalizeModules(modules);

    for (var i = 0; i < modules.length; i++) if (!isc.hasOptionalModule(modules[i])) return false;
    return true;
};
isc.getMissingModules = function (requiredModules) {
    var result = [];
    requiredModules = isc.canonicalizeModules(requiredModules);
    for (var i = 0; i < requiredModules.length; i++) {
        var module = requiredModules[i];
        if (!isc.hasOptionalModule(module)) result.add(isc._optionalModules[module]);
    }
    return result;
};
isc.hasOptionalModule = function (module) {
    var v = isc._optionalModules[module];
    if (!v) {
        if(isc.Log) isc.Log.logWarn("isc.hasOptionalModule - unknown module: " + module);
        return false;
    }
    // has module or devenv
    return v.present == "true" || v.present.charAt(0) == "$";
};
isc.getOptionalModule = function (module) {
    return isc._optionalModules[module];
};


isc.$a4b5c1c2d3 = function (moduleName) {
    if (this.hasOptionalModule(moduleName)) return;
    var moduleEntry = isc._optionalModules[moduleName];
    if (moduleEntry) moduleEntry.present = !!moduleName + "";
};

// default to "simple names" mode, where all ISC classes are defined as global variables
isc._useSimpleNames = window.isc_useSimpleNames;
if (isc._useSimpleNames == null) isc._useSimpleNames = true;

// register with the OpenAjax hub, if present
if (window.OpenAjax) {
    // OpenAjax insists on only numbers and dots.  This regex will convert eg 5.6b3 to 5.6.03,
    // which is not really accurate
    isc._numericVersion = isc.versionNumber.replace(/[a-zA-Z_]+/, ".0");
    OpenAjax.registerLibrary("SmartClient", "http://smartclient.com/SmartClient",
                             isc._numericVersion,
                             { namespacedMode : !isc._useSimpleNames,
                               iscVersion : isc.version,
                               buildDate : isc.buildDate,
                               licenseType : isc.licenseType,
                               licenseCompany : isc.licenseCompany,
                               licenseSerialNumber : isc.licenseSerialNumber });
    OpenAjax.registerGlobals("SmartClient", ["isc"]);
}


isc._longDOMIds = window.isc_useLongDOMIDs;

// add a property to global scope.  This property will always be available as "isc[propName]" and
// will also be available as "window[propName]" if we are in "simpleNames" mode.
// NOTE: even in simpleNames mode, where we assume it's OK to put things into global scope, we
// should still think carefully about creating globals.  Eg a variable like "params" which holds the
// current URL parameters (which we used to have) could easily get clobbered by some sloppy global
// JS, causing mysterious crashes.  Consider creating a class method (eg Page.getWidth()) or class
// property (Log.logViewer) instead, or making the variable isc.myMethod() or isc.myProperty.
isc._$iscPrefix = "isc.";
isc.addGlobal = function (propName, propValue) {
    if (propName.indexOf(isc._$iscPrefix) == 0) propName = propName.substring(4);
    isc[propName] = propValue;
    if (isc._useSimpleNames) window[propName] = propValue;
}





//>Offline

//XXX need to determine this flag correctly at load time
isc.onLine = true;

isc.isOffline = function () {
    return !isc.onLine;
};
isc.goOffline = function () { isc.onLine = false; };
isc.goOnline = function () { isc.onLine = true; };
if (window.addEventListener) {
    window.addEventListener("online", isc.goOnline, false);
    window.addEventListener("offline", isc.goOffline, false);
}
//<Offline


if (typeof isc.Packager != "object") {


} else {

    // log a message that attempted reload of isc.Packager occurred
    var priority = 4, // INFO; isc.Log may not be loaded
        category = "Packager",
        packageIndex = isc.Packager.packageIndex;

    var packageCount = 0;
    for (var loadedPackage in packageIndex) {
        if (packageIndex.hasOwnProperty(loadedPackage)) packageCount++;
    }

    var message  = "Ignoring attempt to redefine isc.Packager containing " +
        packageCount + " packages";


    if (isc.Log) {
        isc.Log.logMessage(priority, message, category);
    } else {
        if (!isc._preLog) isc._preLog = [];
        isc._preLog[isc._preLog.length] = {
            priority : priority, category: category, message: message, timestamp: new Date()
        };
    }
}






//> @class Browser
// The <code>Browser</code> class contains various class attributes that indicate basic properties
// of the browser and whether certain features are enabled.
// @treeLocation Client Reference/Foundation
// @visibility external
//<
isc.addGlobal("Browser", {
    isSupported: false


    ,_assert : function (b, message) {
        if (!b) {
            isc.logWarn("assertion failed" +
                        (message ? " with message: '" + message + "'" : "") +
                        ". Stack trace:" + (isc.Class.getStackTrace()));

        }
    }


});


// ----------------------------------------------------------------
// Detecting browser type
// ----------------------------------------------------------------

//>    @classAttr    Browser.isOpera        (boolean : ? : R)
//        Are we in Opera ?
//<

isc.Browser.isOpera = (navigator.appName == "Opera" ||
                    navigator.userAgent.indexOf("Opera") != -1);

//console.log("navigator.appName:" + navigator.appName
//            + ", navigator.userAgent:" + navigator.userAgent);
//console.log("is opera?:" + isc.Browser.isOpera);

//>    @classAttr    Browser.isNS (boolean : ? : R)
//        Are we in Netscape (including Navigator 4+, NS6 & 7, and Mozilla)
//      Note: Safari also reports itself as Netscape, so isNS is true for Safari.
//<
isc.Browser.isNS = (navigator.appName == "Netscape" && !isc.Browser.isOpera);
//console.log("is NS?:" + isc.Browser.isNS);

//>    @classAttr    Browser.isIE        (boolean : ? : R)
//        Are we in Internet Explorer?
//<
isc.Browser.isIE = (navigator.appName == "Microsoft Internet Explorer" &&
                    !isc.Browser.isOpera) ||
                   navigator.userAgent.indexOf("Trident/") != -1;
//console.log("is IE?:" + isc.Browser.isIE);

//>    @classAttr    Browser.isMSN        (boolean : ? : R)
//      Are we in the MSN browser (based on MSIE, so isIE will be true in this case)
//<
isc.Browser.isMSN = (isc.Browser.isIE && navigator.userAgent.indexOf("MSN") != -1);
//console.log("is MSN?:" + isc.Browser.isMSN);


//>    @classAttr    Browser.isMoz        (boolean : ? : R)
//        Are we in any Mozilla-derived browser, that is, a browser based on Netscape's Gecko
//      engine? (includes Mozilla and Netscape 6+)
//<
isc.Browser.isMoz = (navigator.userAgent.indexOf("Gecko") != -1) &&
    // NOTE: Safari sends "(like Gecko)", but behaves differently from Moz in many ways

    (navigator.userAgent.indexOf("Safari") == -1) &&
    (navigator.userAgent.indexOf("AppleWebKit") == -1) &&
    !isc.Browser.isIE;
//console.log("is Moz?:" + isc.Browser.isMoz);

//>    @classAttr    Browser.isCamino (boolean : false : R)
//  Are we in Mozilla Camino?
//<
isc.Browser.isCamino = (isc.Browser.isMoz && navigator.userAgent.indexOf("Camino/") != -1);
//console.log("is Camino?:" + isc.Browser.isCamino);


//>    @classAttr    Browser.isFirefox (boolean : false : R)
//  Are we in Mozilla Firefox?
//<
isc.Browser.isFirefox = (isc.Browser.isMoz && navigator.userAgent.indexOf("Firefox/") != -1);
//console.log("is Fire Fox?:" + isc.Browser.isFirefox);


//> @classAttr  Browser.isAIR    (boolean : ? : R)
// Is this application running in the Adobe AIR environment?
//<
isc.Browser.isAIR = (navigator.userAgent.indexOf("AdobeAIR") != -1);
//console.log("is AIR?:" + isc.Browser.isAIR);


//>    @classAttr    Browser.isWebKit (boolean : ? : R)
// Are we in a WebKit-based browser (Safari, Chrome, mobile Safari and Android, others).
//<
isc.Browser.isWebKit = navigator.userAgent.indexOf("WebKit") != -1;
//console.log("is webkit?:" + isc.Browser.isWebKit);


//>    @classAttr    Browser.isSafari (boolean : ? : R)
// Are we in Apple's "Safari" browser? Note that this property will also be set for other
// WebKit based browsers (such as Google Chrome).
//<
// As far as we know all "true" Safari implementations idenify themselves in the userAgent with
// the string "Safari".
// However the GWT hosted mode browser on OSX is also based on apple webkit and should be treated
// like Safari but is not a Safari browser and doesn't identify itself as such in the useragent
// Reported UserAgent:
//  Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_5; en-us) AppleWebKit/525.18 (KHTML, like Gecko)
isc.Browser.isSafari = isc.Browser.isAIR || navigator.userAgent.indexOf("Safari") != -1 ||
                        navigator.userAgent.indexOf("AppleWebKit") != -1;
//console.log("is Safari?:" + isc.Browser.isSafari);

//> @classAttr Browser.isEdge (boolean : ? : R)
// Are we in the Microsoft Edge browser?
//<

isc.Browser.isEdge = isc.Browser.isSafari && (navigator.userAgent.indexOf("Edge/") != -1);
//console.log("is Edge?:" + isc.Browser.isEdge);


//> @classAttr Browser.isChrome (boolean : ? : R)
// Are we in the Google Chrome browser?
//<
// Behaves like Safari in most ways.  Note: do not detect Edge as Chrome - causes odd scrollbar
// misrenderings.  As of 7/30/2015 appears to work better with the isSafari codepaths
isc.Browser.isChrome = isc.Browser.isSafari && !isc.Browser.isEdge && (navigator.userAgent.indexOf("Chrome/") != -1);
//console.log("is Chrome?:" + isc.Browser.isChrome);



if (!isc.Browser.isIE && !isc.Browser.isOpera && !isc.Browser.isMoz &&
    !isc.Browser.isAIR && !isc.Browser.isWebkit && !isc.Browser.isSafari)
{
    if (navigator.appVersion.indexOf("MSIE") != -1) {
        isc.Browser.isIE = true;
        //console.log("is IE (inside embedded browser, etc)?:" + isc.Browser.isIE);

    }
}

// ----------------------------------------------------------------
// END Detecting browser type
// ----------------------------------------------------------------


//>    @classAttr Browser.minorVersion        (number : ? : R)
//        Browser version, with minor revision included (4.7, 5.5, etc).
//
// NOTE: In Firefox 16+, Browser.minorVersion will equal Browser.version by design. See
// Firefox +externalLink{https://bugzilla.mozilla.org/show_bug.cgi?id=728831,Bug 728831}.
//<
if (navigator.userAgent.indexOf("Trident/") >= 0 &&
    navigator.userAgent.lastIndexOf("rv:") >= 0)
{

    isc.Browser.minorVersion = parseFloat(navigator.userAgent.substring(navigator.userAgent.lastIndexOf("rv:") + "rv:".length));
} else {
    isc.Browser.minorVersion = parseFloat(isc.Browser.isIE
                                      ? navigator.appVersion.substring(navigator.appVersion.indexOf("MSIE") + 5)
                                      : navigator.appVersion );
}

if (isc.Browser.isIE) {
    // IE won't allow a documentMode higher than the version you are on.

    if (document.documentMode != null) {
        isc.Browser.minorVersion = Math.max( isc.Browser.minorVersion, document.documentMode );
    }
} else (function () {



    var needle, pos;
    if (navigator.appVersion) {
        // Safari
        needle = "Version/";
        pos = navigator.appVersion.indexOf(needle);
        if (pos >= 0) {
            isc.Browser.minorVersion = parseFloat(navigator.appVersion.substring(pos + needle.length));
            return;
        }
    }

    var ua = navigator.userAgent;

    needle = "Chrome/";
    pos = ua.indexOf(needle);
    if (pos >= 0) {
        isc.Browser.minorVersion = parseFloat(ua.substring(pos + needle.length));
        return;
    }

    // Handle Camino before Firefox because Camino includes "(like Firefox/x.x.x)" in the UA.
    needle = "Camino/";
    pos = ua.indexOf(needle);
    if (pos >= 0) {
        isc.Browser.minorVersion = parseFloat(ua.substring(pos + needle.length));
        return;
    }

    needle = "Firefox/";
    pos = ua.indexOf(needle);
    if (pos >= 0) {
        isc.Browser.minorVersion = parseFloat(ua.substring(pos + needle.length));
        return;
    }

    if (ua.indexOf("Opera/") >= 0) {
        needle = "Version/";
        pos = ua.indexOf(needle);
        if (pos >= 0) {
            isc.Browser.minorVersion = parseFloat(ua.substring(pos + needle.length));
            return;
        } else {
            // Opera 9.64
            needle = "Opera/";
            pos = ua.indexOf(needle);
            isc.Browser.minorVersion = parseFloat(ua.substring(pos + needle.length));
            return;
        }
    }
})();

//>    @classAttr    Browser.version        (number : ? : R)
//        Browser major version number (integer: 4, 5, etc).
//<
isc.Browser.version = parseInt(isc.Browser.minorVersion);

// actually means IE6 or earlier, which requires radically different optimization techniques
isc.Browser.isIE6 = isc.Browser.isIE && isc.Browser.version <= 6;


//>    @classAttr    Browser.caminoVersion (string : ? : R)
//        For Camino-based browsers, the Camino version number.
//<
if (isc.Browser.isCamino) {
    // Camino Version is the last thing in the userAgent
    isc.Browser.caminoVersion =
        navigator.userAgent.substring(navigator.userAgent.indexOf("Camino/") +7);
}

if (isc.Browser.isFirefox) {
//>    @classAttr    Browser.firefoxVersion (string : ? : R)
//        For Firefox-based browsers, the Firefox version number.
//          - 0.10.1    is Firefox PR 1
//      After this the version numbers reported match those in the about dialog
//          - 1.0       is Firefox 1.0
//          - 1.0.2     is Firefox 1.0.2
//          - 1.5.0.3   is Firefox 1.5.0.3
//<
    var userAgent = navigator.userAgent,
        firefoxVersion = userAgent.substring(userAgent.indexOf("Firefox/")+ 8),
        majorMinorVersion = firefoxVersion.replace(/([^.]+\.[^.]+)\..*/, "$1");
    isc.Browser.firefoxVersion          = firefoxVersion;
    isc.Browser.firefoxMajorMinorNumber = parseFloat(majorMinorVersion);
}

//>    @classAttr    Browser.geckoVersion (integer : ? : R)
//        For Gecko-based browsers, the Gecko version number.
//      Looks like a datestamp:
//          - 20011019 is Netscape 6.2
//          - 20020530 is Mozilla 1.0
//          - 20020823 is Netscape 7.0
//          - 20020826 is Mozilla 1.1
//          - 20021126 is Mozilla 1.2
//          - 20030312 is Mozilla 1.3
//          - 20030624 is Mozilla 1.4
//          - 20031007 is Mozilla 1.5
//          - 20031120 is Mozilla 1.5.1 (Mac only release)
//          - 20040113 is Mozilla 1.6
//          - 20040616 is Mozilla 1.7
//          - 20040910 is Mozilla 1.73
//          - 20041001 is Mozilla Firefox PR1 (-- also see firefox version)
//          - 20041107 is Mozilla Firefox 1.0
//          - 20050915 is Mozilla Firefox 1.0.7
//          - 20051107 is Mozilla Firefox 1.5 RC2
//          - 20051111 is Mozilla Firefox 1.5 final
//          - 20060426 is Mozilla Firefox 1.5.0.3
//          - 20061010 is Mozilla Firefox 2.0
//          - 20070321 is Netscape 8.1.3 - LIES - really based on Firefox 1.0 codebase
//          - 20071109 is Firefox 3.0 beta 1
//          - 20080529 is Firefox 3.0
//          - 20100101 is Firefox 4.0.1
//<

if (isc.Browser.isMoz) {
    isc.Browser._geckoVIndex = navigator.userAgent.indexOf("Gecko/") + 6;
    // The 'parseInt' actually means we could just grab everything from the
    // end of "Gecko/" on, as we know that even if the gecko version is followed
    // by something, there will be a space before the next part of the UA string
    // However, we know the length, so just use it
    isc.Browser.geckoVersion = parseInt(
        navigator.userAgent.substring(
            isc.Browser._geckoVIndex, isc.Browser._geckoVIndex+8
        )
    );



    if (isc.Browser.isFirefox) {
        // clamp 1.0.x series to last known pre 1.5 version (1.0.7)
        if (isc.Browser.firefoxVersion.match(/^1\.0/)) isc.Browser.geckoVersion = 20050915;
        // clamp 2.0.x series to one day before near-final FF3 beta
        else if (isc.Browser.firefoxVersion.match(/^2\.0/)) isc.Browser.geckoVersion = 20071108;
    }


    if (isc.Browser.version >= 17) isc.Browser.geckoVersion = 20121121;
}

// Doctypes
//  Are we in strict standards mode.  This applies to IE6+ and all Moz 1.0+.
//
//  In strict mode, browsers attempt to behave in a more standards-compliant manner.  Of course,
//  standards interpretation varies pretty drastically between browser makers, so this is in effect
//  just another fairly arbitrary set of behaviors which continues to vary across browser makers,
//  and now also across modes within the same browser.
//
// Traditionally, we have essentially 3 cases to consider:
// - BackCompat / Quirks mode. This is the rendering used if docType is not specified, or if
//   specified as 'Transitional' or 'Frameset' / with no URI
//   (EG: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">)
//   This is the default mode.
// - Strict. Completely standards complient.
//   Triggered by
//   <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
// - "Almost Strict" (AKA Transitional).
//   In IE this matches Strict mode completely.
//   In Moz it matches strict mode except for rendering of images within tables - see
//   http://developer.mozilla.org/en/docs/Images%2C_Tables%2C_and_Mysterious_Gaps
//   Triggered "transitional" doctype with URI
//   Reports document.compatMode as "CSS1Compat"
// - http://developer.mozilla.org/en/docs/Gecko%27s_%22Almost_Standards%22_Mode
// - http://www.htmlhelp.com/reference/html40/html/doctype.html
// - http://developer.mozilla.org/en/docs/Mozilla%27s_DOCTYPE_sniffing
//
// - we also have the HTML5 doctype to consider - <!DOCTYPE html>. Only applies to modern
//   browsers, and required for some of our more recent features (EG some drawing approaches)
//   We don't explicitly have a flag to differentiate between this and "isStrict"

//> @classAttr  Browser.isStrict    (boolean : ? : R)
//  Are we in strict standards mode.
//<
// HACK: Netscape6 does not report document.compatMode, so we can't tell that a DOCTYPE has been
// specified, but Netscape6 IS affected by a DOCTYPE.  So, in Netscape6, assume we're always in
// strict mode.  At the moment (3/30/03) all strict mode workarounds have identical behavior in
// normal mode.

isc.Browser.isStrict = document.compatMode == "CSS1Compat";
if (isc.Browser.isStrict && isc.Browser.isMoz) {

    isc.Browser._docTypePublicID = document.doctype.publicId;
    isc.Browser._docTypeSystemID = document.doctype.systemId;

}

// See http://developer.mozilla.org/en/docs/Mozilla%27s_DOCTYPE_sniffing
// See Drawing.test.html for some test cases
isc.Browser.isTransitional = /.*(Transitional|Frameset)/.test((document.all && document.all[0] && document.all[0].nodeValue) || (document.doctype && document.doctype.publicId));

isc.Browser.isIE7 = isc.Browser.isIE && isc.Browser.version == 7;

//> @classAttr Browser.isIE8 (boolean : ? : R)
// Returns true if we're running IE8 and we're in IE8 mode
// IE8 has a 'back-compat' type mode whereby it can run using IE7 rendering logic.
// This is explicitly controlled via the meta tags:
//
//    &lt;meta http-equiv="X-UA-Compatible" content="IE=8" /&gt;
// or
//    &lt;meta http-equiv="X-UA-Compatible" content="IE=7" /&gt;
//
// In beta versions IE8 reported itself version 7 and ran in IE7 mode unless the explicit IE8
// tag was present
// In final versions (observed on 8.0.6001.18702) it reports a browser version of 8 and runs
// in IE8 mode by default - but can be switched into IE7 mode via the explicit IE=7 tag.
//
// We therefore want to check the document.documentMode tag rather than just the standard
// browser version when checking for IE8
//<
isc.Browser.isIE8 = isc.Browser.isIE && isc.Browser.version>=8 && document.documentMode == 8;

//<
//> @classAttr Browser.isIE8Strict (boolean : ? : R)
// Are we in IE8 [or greater] strict mode.
// <P>
// In IE8 when the meta tag is present to trigger IE7 / IE8 mode the document is in
//
//    &lt;meta http-equiv="X-UA-Compatible" content="IE=8" /&gt;
//    &lt;meta http-equiv="X-UA-Compatible" content="IE=7" /&gt;
//
// If this tag is present, the document is in strict mode even if no DOCTYPE was present.
// The presence of this tag can be detected as document.documentMode being 8 rather than 7.
// document.compatMode still reports "CSS1Compat" as with earlier IE.
//<
// IE9 running in IE9 mode will report as IE8Strict:true. This makes sense since rendering quirks
// introduced in IE8 Strict, such as requiring explicit "overflow:hidden" in addition
// to table-layout-fixed in order to clip cells horizontally in tables apply in both places.
// For cases where we really need to distinguish we can check isc.Browser.version or isc.Browser.isIE9

isc.Browser.isIE8Strict = isc.Browser.isIE &&
                            (isc.Browser.isStrict && document.documentMode ==8) ||
                            document.documentMode > 8;

//> @classAttr Browser.isIE9 (boolean : ? : R)
// True if we're running IE9 or later, actually running in the IE9+ documentMode.
//<

isc.Browser.isIE9 = isc.Browser.isIE && isc.Browser.version>=9 && document.documentMode >= 9;

isc.Browser.isIE10 = isc.Browser.isIE && isc.Browser.version >= 10;

isc.Browser.isIE11 = isc.Browser.isIE && isc.Browser.version >= 11;

//> @classAttr  Browser.AIRVersion (string : ? : R)
// If this application running in the Adobe AIR environment, what version of AIR is
// running. Will be a string, like "1.0".
//<
isc.Browser.AIRVersion = (isc.Browser.isAIR ? navigator.userAgent.substring(navigator.userAgent.indexOf("AdobeAir/") + 9) : null);


//>    @classAttr    Browser.safariVersion (number : ? : R)
//        in Safari, what is is the reported version number
//<

if (isc.Browser.isSafari) {

    if (isc.Browser.isAIR) {

        isc.Browser.safariVersion = 530;
    } else {
        if (navigator.userAgent.indexOf("Safari/") != -1) {
            isc.Browser.rawSafariVersion = navigator.userAgent.substring(
                        navigator.userAgent.indexOf("Safari/") + 7
            );
        } else if (navigator.userAgent.indexOf("AppleWebKit/") != -1) {
            isc.Browser.rawSafariVersion = navigator.userAgent.substring(
                        navigator.userAgent.indexOf("AppleWebKit/") + 12
            );

        } else {
            isc.Browser.rawSafariVersion = "530"
        }



        isc.Browser.safariVersion = (function () {
            var rawVersion = isc.Browser.rawSafariVersion,
                currentDot = rawVersion.indexOf(".");

            if (currentDot == -1) return parseInt(rawVersion);
            var version = rawVersion.substring(0,currentDot+1),
                nextDot;
            while (currentDot != -1) {
                // Check AFTER the dot
                currentDot += 1;
                nextDot = rawVersion.indexOf(".", currentDot);
                version += rawVersion.substring(currentDot,
                                                (nextDot == -1 ? rawVersion.length: nextDot));
                currentDot = nextDot;
            }
            return parseFloat(version);
        })();
    }
}

// -------------------------------------------------------------------
// Platform information
// -------------------------------------------------------------------

//>    @classAttr    Browser.isWin        (boolean : ? : R)
//        Is this a Windows computer ?
//<
isc.Browser.isWin = navigator.platform.toLowerCase().indexOf("win") > -1;
// NT 5.0 is Win2k, NT5.0.1 is Win2k SP1
isc.Browser.isWin2k = navigator.userAgent.match(/NT 5.01?/) != null;

//>    @classAttr    Browser.isMac        (boolean : ? : R)
//        Is this a Macintosh computer ?
//<
isc.Browser.isMac = navigator.platform.toLowerCase().indexOf("mac") > -1;

isc.Browser.isUnix = (!isc.Browser.isMac &&! isc.Browser.isWin);

//> @groupDef mobileDevelopment
// SmartClient is designed to automatically adapt to smaller screen sizes and the lower
// accuracy of touch-based interfaces.
// <p>
// In general, a SmartClient application written with complete ignorance of mobile development
// will still be highly usable on tablet or handset-sized touch devices.  This topic explains
// all the automatic behaviors that make this possible, and the few areas developers need to
// consider in order to optimize the mobile experience, the most important being:
// <p>
// <ul>
// <li> read about potential issues created by the automatically shown and hidden browser
//      toolbars in Safari on iOS7+, discussed under "minimal-ui" below.  SmartClient
//      automatically handles this, but most applications will want to create a non-interactive
//      banner to fill the blank screen area that is rendered unusable by iOS' behavior
// <li> read about "Automatic touch scrolling" below - if your application does not already
//      have alternative UIs for performing drag operations (as is required anyway for
//      +link{group:accessibility,accessibility reasons}), this section discusses options for
//      controlling drag scrolling vs dragging of data
// <li> review your application for the rare screen that has a fixed, very wide width and
//      doesn't allow scrolling.  Such screens would already be unusable for narrow desktop
//      browsers but are more of a problem for fixed-size mobile screens.  The section
//      "Exceptionally wide screens" below explains strategies for dealing with this.
// </ul>
// <p>
// <h3>Supported Browsers</h3>
// <P>
// <ul>
// <li> Safari on iOS devices (iPad, iPhone, iPod Touch)
// <li> Android's default (WebKit-based) browser <b>*</b>
// <li> Windows Phone default browser, latest release only <b>**</b>
// <li> Blackberry 10+ default (WekKit-based) browser <b>**</b>
// </ul>
// <b>*</b>: Android issues that occur <i>exclusively</i> on rare devices (under a certain
// percent of market share) will not normally be covered by a Support plan.  This is a
// necessity because highly customized versions of Android are used for a variety of niche
// devices (even microsatellites)<br>
// <b>**</b>: These browsers generally work and bug reports are accepted, but they do not yet
// fall under the normal Enterprise+ Support guarantee of fixing every confirmed bug
// <p>
// If you would like to check whether a specific device falls under normal Support, or would
// like a quote for a Support plan that would include a specific device or platform,
// +externalLink{http://smartclient.com/company/contact.jsp,contact Isomorphic here}.
// <P>
// <h3>Adaptive Components</h3>
// <p>
// Many SmartClient components automatically change their behavior and/or appearance when used
// with touch devices in general, or tablets and handsets specifically.  There are too many
// adaptations to comprehensively list, but some of the more obvious behaviors are listed below:
// <ul>
// <li> +link{SelectItem} and +link{ComboBoxItem} controls automatically fill the entire screen
//      or a major portion of the screen when activated, and add a control to dismiss the
//      full-screen interface.  See +link{ComboBoxItem.pickListPlacement} for details
// <li> +link{Menu} components likewise fill the entire screen or a major portion, and offer
//      submenu navigation via a slide-in animation and back button instead of displaying the
//      origin menu and submenu simultaneously
// <li> +link{Calendar.minimalUI,Calendar} eliminates the tabs normally used to switch between
//      Day, Week and Month view, instead using device pivot to switch between Day and Week
//      views and offering a compact link to Month view
// <li> Windows and Dialogs fill the screen by default and remove rounded edges to save space
// <li> many controls implement an expanded hit area for clicks or drags so that finger touches
//      that are technically outside of the drawn area of the control still activate the
//      control.  This accomodates the imprecision of finger touches as compared to mouse
//      clicks, while still showing the same compact appearance as is used for desktop
//      interfaces.  This includes the +link{Slider} thumb, +link{Window.headerControls},
//      +link{canvas.resizeFrom,edge-based resizing}, and many other controls.
// <li> +link{SpinnerItem} switches to side-by-side +/- controls instead of the very small,
//      vertically stacked +/- control typical of desktop interfaces
// <li> +link{AdaptiveMenu} can either display menu items inline, or in a drop-down,
//        or mix the two modes according to available space.
// </ul>
// <p>
// In addition to automatic behavior, SmartClient offers Adaptive Layout whereby a +link{Layout}
// member may be <i>designed</i> to render itself at multiple possible sizes, in order to fit
// into the amount of space available in the Layout.  Unlike simply indicating a flexible size
// on a member, setting an adaptive width or height indicates that the member has two (or more)
// different <i>ways</i> of rendering itself with different <i>discrete</I> sizes, but does not
// have the ability to use every additional available pixel.
// <p>
// For more guidance, see the documentation under +link{canvas.canAdaptWidth} and the
// +explorerExample{inlinedMenuMobileSample, Inlined Menu Mobile} and
// +explorerExample{adaptiveMenuMobileSample, Adaptive Menu} samples.
// <p>
// <h3>Finger / touch event handling</h3>
// <P>
// Mobile and touch devices support "touch events" that correspond to finger actions on the
// screen.  By default, SmartClient simply sends touch events to UI components as normal mouse
// events.  Specifically:
// <ul>
// <li> a finger tap gesture will trigger mouseDown, mouseUp and click events
// <li> a touch-and-slide interaction will trigger drag and drop, firing the normal SmartClient
//      sequence of dragStart, dragMove, and dragStop
// <li> a touch-and-hold interaction will trigger a contextMenu event, and will trigger a hover
//      if no contextMenu is shown
// </ul>
// This means that most applications that are written with mouse interaction in mind will
// function with a touch-based UI without special efforts.  Some interfaces which rely heavily
// on mouse hovers may want to display instructions to explicitly tell the user that they have
// to touch a given element to see more information.
// <p>
// <h3>Automatic touch scrolling</h3>
// <p>
// Components that normally show scrollbars on desktop browsers will, by default, hide
// scrollbars and allow scrolling via finger dragging instead.
// <p>
// If you are using drag and drop features such as +link{listGrid.canReorderRecords}, this
// obviously conflicts with using finger drags for scrolling.  There are two options:
// <p>
// <ol>
// <li> Leave touch scrolling active for the grid, but provide additional controls, such as
//      buttons, that enable users to perform the drag operation in a different way.
//      Optionally display scrollbars <em>in addition to</em> leaving touch scrolling active
//      by setting +link{Canvas.alwaysShowScrollbars} to <code>true</code>.
// <li> Set +link{canvas.useTouchScrolling,useTouchScrolling} to <code>false</code> on the component.
//      Scrollbars will be shown, and finger drags will no longer cause scrolling, so that
//      finger drags can now be used for the drag and drop operation configured on the
//      component
// </ol>
// Option #1 above is generally preferred, since it is also considered an
// +link{group:accessibility} violation if drag and drop is the sole way to trigger an
// operation (keyboard-only users cannot use drag and drop), and also because scrollbars are
// not usually found in touch interfaces.
// <p>
// If your application is not required to be keyboard accessible, and you prefer to show
// scrollbars and use finger drags for normal drag operations, you can use
// +link{Canvas.disableTouchScrollingForDrag} to make this choice system-wide or on a
// per-component-type basis.
// <p>
// <h3>Exceptionally wide screens / forms</h3>
// <p>
// If you have designed a screen for desktop use and it is too wide to fit on a handset or
// tablet-sized screen, there are several possible strategies:
// <ul>
// <li> <b>use +link{SplitPane}</b>: any time you have two or more panes where a choice in one
//      pane decides what is displayed in the other.  See the "SplitPane" section further down
//      for details
// <li> <b>rely on horizontal scrolling</b>: if you have something like a +link{DynamicForm}
//      that has 3 columns of input fields, as long as the form itself or some parent has
//      +link{canvas.overflow,overflow:"auto"} set, horizontal touch scrolling will be
//      available to reach fields that initially render offscreen.  Most of the time, there is
//      already an <code>overflow:"auto"</code> parent component as a result of default
//      framework behaviors or application settings that also make sense for desktop mode,
//      so nothing needs to be done.
//      <p>
//      However, consider whether scrolling is already in use for other purposes: if you have a
//      grid plus an adjacent component to the right, if the adjacent component is entirely
//      offscreen, attempting touch scrollng on the grid will just scroll the grid as such and
//      won't reveal the adjacent component.  In this kind of situation, you can:
//   <ul>
//   <li> <i>use +link{SplitPane}</i> as described above, a grid with something adjacent is
//        frequently a good candidate for conversion to <code>SplitPane</code>
//   <li> <i>make the scrolling component smaller or flexible size</i>.  Whether it's a grid or
//        other scrollable component on the left, this situation usually arises because an
//        inappropriately large fixed size has been set, instead of a
//        +link{canvas.width,flexible size}.
//   <li> <i>leave some blank space</i> above or below the grid - this gives the user somewhere
//        to use touch scrolling to move both the grid and adjacent component
//   <li> <i>force scrollbars to appear</i> by setting
//        +link{canvas.useTouchScrolling,useTouchScrolling} to false.  This is another way to
//        give the user a place they can touch in order to scroll the both the grid and
//        adjacent component together
//   </ul>
// <li> <b>use +link{FlowLayout}</b>: a <code>FlowLayout</code> can automatically take two
//      side-by-side elements and switch them to vertical stacking when the screen is narrow
// </ul>
// <p>
// <h3>SplitPane</h3>
// <p>
// The +link{SplitPane} component implements the common pattern of rendering
// two or three panes simultaneously on desktop machines and on tablets in landscape
// orientation, while switching to showing a single pane for handset-sized devices or tablets
// in portrait orientation.
// <p>
// Use <code>SplitPane</code> anywhere you have two or more panes in your application where a
// choice in one pane decides what is displayed in the other pane.  For example, you may have a
// list of Records where details of a single selected Record are shown next to the list.  A
// <code>SplitPane</code> is well-suited to this interface since it provides automatic "Back"
// navigation and a place to show the title of the selected record when only the detail view is
// showing.
// <p>
// Note that you do not need to use a <code>SplitPane</code> as your top-level component
// containing the whole application, and it <i>does</i> makes sense to use multiple
// <code>SplitPane</code> components in a single application.  For example, your top-level
// container component might be a +link{TabSet}, and a +link{SplitPane} would be used to manage
// components in tabs which normally show 2 panes side-by-side on desktop browsers.
// <P>
// <h3>Device type and overriding</h3>
// <p>
// In most cases SmartClient will correctly detect the device running your application, and set
// the flags +link{Browser.isTouch}, +link{Browser.isHandset}, +link{Browser.isTablet} and
// +link{Browser.isDesktop} appropriately.
// <p>
// For any uncommon device for which these variables are not set correctly, you can use
// +link{Browser.setIsTablet()}, +link{Browser.setIsHandset()} and +link{Browser.setIsTouch()}
// to override the auto-detected settings.  If you use these APIs, call them <b>before</b>
// creating or drawing any SmartClient components or using any other SmartClient APIs.
// <p>
// Note that the various automatic behaviors triggered by flags on the +link{Browser} class can
// be overriden at a fine-grained level on individual components.  For example,
// +link{SplitPane} will use 2-pane display when a tablet is detected, however, for a
// particularly large, high-resolution tablet device, you could instead use 3-pane display by
// setting +link{SplitPane.deviceMode} to "desktop".
// <p>
// <h3>Mobile look and feel</h3>
// <P>
// We recommend using either the Enterprise, EnterpriseBlue or Graphite skins for applications
// that support mobile (or a custom skin based on one of these skins).  These skins make
// maximum use of CSS3 to minimize the number of images that need to be loaded and the number
// of DOM elements used to create components.
// <p>
// We also do <b>not</b> recommend attempting to mimic the native UI of each particular mobile
// platform, because:
// <ul>
// <li> if users access the same application via desktop and mobile browsers, consistent
// appearance and behavior between the desktop and mobile rendering of the application is more
// important for familiarity than looking similar to other applications on the mobile device
// <li> mobile platform design overhauls, such as the major changes from iOS6 to iOS7, can
// easily invalidate efforts to look like native applications on the device
// <li> there is no single consistent appearance across Android devices because different
// manufacturers customize the platform a great deal, so efforts to closely mimic any one
// device won't yield any real consistency
// </ul>
// <P>
// <h3>iOS 7, browser toolbars and "minimal-ui" setting</h3>
// <p>
// Safari in iOS 7.0 will automatically hide and show browser toolbars as the user scrolls
// around a normal web page, pivots, or touches near edges of the screen.  This creates serious
// problems for web applications, partly because notifications are not reliably fired when
// toolbars are shown and hidden, and partly because it introduces "dead zones" where an
// application cannot place interactive controls, since touching there shows browser toolbars
// instead.
// <p>
// iOS 7.1 introduces a "minimal-ui" setting on the viewport <code>meta</code> tag which
// eliminates most of these problems, by requiring that the user specifically touch the
// URL bar to reveal browser toolbars.  Even with this setting, the top 20px of space <i>in
// landscape orientation only</i> is still a "dead zone".
// <p>
// SmartClient automatically uses the minimal-ui setting whenever iOS is detected, and also
// sets +link{canvas.defaultPageSpace} to 20px in landscape orientation to avoid components
// being placed in the dead zone.  These default behaviors can be disabled by defining the
// <code>isc_useMinimalUI</code> global variable with the value <code>false</code> before the
// framework is loaded:
// <pre> &lt;script type="text/javascript"&gt;
// window.isc_useMinimalUI = false;
// &lt;/script&gt;</pre>
// <p>
// Whether minimal-ui is used or not, it is recommend to place some kind of non-interactive
// widget or content in the dead zones created by browser toolbars, for example, a +link{Label}
// showing your company name or application name.  When using +link{canvas.defaultPageSpace} to have
// all components avoid a dead zone at the top of the page, you can set
// +link{canvas.leavePageSpace,leavePageSpace:0} to allow individual components to place
// themselves in a dead zone.
// <p>
// <h3>Configuring the viewport</h3>
// <p>
// When a SmartClient application loads, by default a viewport &ltmeta&gt; tag is added to the
// page which, on touch devices, fixes the page zoom to 100% and disables the pinch-zoom gesture.
// This is usually the expected behavior of a touch-enabled web application because it makes
// the application look and feel more like a native app. This default setting can be disabled
// by defining the <code>isc_useDefaultViewport</code> global variable with the value
// <code>false</code> before the framework is loaded:
// <pre> &lt;script type="text/javascript"&gt;
// window.isc_useDefaultViewport = false;
// &lt;/script&gt;</pre>
// For more information on the mobile device viewport, see:
// <ul>
// <li>+externalLink{http://developer.apple.com/safari/library/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html,Configuring the Viewport - Safari Web Content Guide}</li>
// <li>+externalLink{https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag,Using the viewport meta tag to control layout on mobile browsers - MDN}</li>
// </ul>
// <p>
// <h3>Orientation Change &amp; Screen Size</h3>
// <P>
// When orientation changes, this is treated identically to resizing the browser on a desktop
// machine.  If you've already created a UI that fills the browser and makes good use of
// available screen space for desktop browsers, the same behaviors will automatically apply
// when your application runs on mobile devices and the device is pivoted.
// <P>
// If you want to build specialized interfaces that respond to device orientation, the
// +link{Page.getOrientation()} API may be used to determine the current orientation of the
// application, and +link{pageEvent,the page orientationChange event} will fire whenever the
// user rotates the screen allowing applications or components to directly respond to the user
// pivoting their device.
// <p>
// <h3>Launching native helper apps (phone, facetime, maps..)</h3>
// <p>
// Generally, all that's required to launch native mobile apps is to create an ordinary HTML
// hyperlink (<code>&lt;a&gt;</code> tag) with a special prefix for the URL specified in the
// <code>href</code> attribute.  For example, the following HTML link will place a call when
// the user finger-taps it:
// <pre>
//   &lt;a href="tel:8675309"&gt;Call Jenny&lt;/a&gt;</pre>
// You can provide HTML like this as +link{HTMLFlow.contents}.  Or use a field of
// +link{type:FieldType,type:"link"} to cause various
// +link{DataBoundComponent,DataBoundComponents} to render a DataSourceField value as a
// clickable URL.
// <p>
// The URL prefixes that are valid for iOS are documented
// +externalLink{https://developer.apple.com/library/ios/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899-CH1-SW1,at Apple.com}.
// Typically, the same prefixes also work for Android, Windows Phone and others.
// <p>
// <h3>Configure the soft keyboard</h3>
// <p>
// +link{TextItem.browserInputType} can be set to various values such as "email" or "tel"
// (telephone number) to hint to mobile devices to use a different software keyboard with
// specialized keys appropriate for entering certain types of data values.
// <p>
// <h3>Note on mobile platform performance</h3>
// <p>
// When the first modern smartphones were released, it was necessary to use tiny,
// mobile-specific frameworks to get adequate performance for mobile web applications.
// <p>
// The situation is now completely different: through a combination of hardware improvements,
// optimizations in mobile browsers and vastly improved network speeds, typical mobile devices
// are easily able to run applications built with full-featured web platforms like SmartClient.
// For an application that supports both desktop and mobile interfaces, the worst case scenario
// for platform performance is often <b>not</b> a mobile phone, but an older desktop machine
// running Internet Explorer.
// <p>
// Unfortunately, there is a lot of out-of-date advice on the web about mobile web development
// that still advises using ultra-light, feature-poor frameworks for performance reasons.
// Carefully consider the source and recency of any such advice - the reality is that using
// such feature-poor frameworks means you will under-deliver with both your desktop <i>and</i>
// mobile interfaces.
// <p>
// For more background on choosing the right technologies for mobile and desktop web
// applications, see the
// +externalLink{http://smartclient.com/product/mobileStrategy.jsp,Mobile Strategy Page} at
// smartclient.com.
// <P>
// <h3>Offline Operation</h3>
// <P>
// SmartClient applications support "offline" operation (continuing to work without network
// access).
// <P>
// Permanent caching of resources such as .js, .css files and images are handled via the standard
// +externalLink{https://www.google.com/search?q=html5+manifest,HTML5 Manifest} - just list all
// the static files your application needs in a manifest file and mobile browsers will cache
// those resources.
// <P>
// Dynamic data is handled via the +link{Offline} APIs as well as special DataSource support
// enabled by +link{DataSource.useOfflineStorage}.
// <P>
// The end result is that you can bookmark a SmartClient application to a phone's home screen
// and use it offline with cached data, much like an installed native application.
// <P>
// <h2>Packaging as a native application</h2>
// <P>
// Via "packaging" technologies such as PhoneGap/Cordova and Titanium, a SmartClient web application
// can be packaged as an installable native application that can be delivered via the "App Store"
// for the target mobile platform.  Applications packaged in this way have access to phone-specific
// data and services such as contacts stored on the phone, or the ability to invoke the device's camera.
// <P>
// Both Titanium and PhoneGap provide access to the underlying native device APIs such as the
// accelerometer, geolocation, and UI. Both frameworks enable application development using
// only JavaScript, CSS and HTML. Additionally they provide development environments that work
// across a wide variety of devices.
// <P>
// PhoneGap has good support for native device APIs as noted +externalLink{http://www.phonegap.com/about/feature,here}.
// Titanium has similar support. There are differences between the two environments and how they
// expose their APIs, though both provide Xcode-compatible projects that can be compiled and run from the Xcode IDE.
// See +link{titaniumIntegration,Integration with Titanium} and +link{phonegapIntegration,Integration with PhoneGap}
// for more information.
//
// @title Mobile Application Development
// @treeLocation Concepts
// @visibility external
//<


//> @groupDef titaniumIntegration
// Titanium provides an extensive Javascript API to access a native device's UI, phone, camera, geolocation, etc.
// Documentation, getting started, programming guides are +externalLink{http://developer.appcelerator.com/documentation,here}.
// Titanium provides a consistent API across devices including the ability to mix webviews with native controls.
// <P>
// The Titanium sample application provides an example of accessing a device's Contacts db using SmartClient.
// The application presents 2 tabs 'Customers' and 'Contacts' and allows the user to import Customer contacts into
// his/her contacts db resident on the device. Selecting a Customer's Contact address will show a map of the contact.
// Selecting a Customer's phone number will call the customer or prompt to import the contact into the user's
// contacts. The latter option is default behavior on the iPad. Calling the customer contact is default behavior for
// devices such as the iPhone or Android.
// <P>
// The Titanium Contact object holds the following properties:
// <ul>
// <li>URL</li>
// <li>address</li>
// <li>birthday</li>
// <li>created</li>
// <li>date</li>
// <li>department</li>
// <li>email</li>
// <li>firstName</li>
// <li>firstPhonetic</li>
// <li>fullName</li>
// <li>image</li>
// <li>instantMessage</li>
// <li>jobTitle</li>
// <li>kind</li>
// <li>lastName</li>
// <li>lastPhonetic</li>
// <li>middleName</li>
// <li>middlePhonetic</li>
// <li>modified</li>
// <li>nickname</li>
// <li>note</li>
// <li>organization</li>
// <li>phone</li>
// <li>prefix</li>
// <li>relatedNames</li>
// <li>suffix</li>
// </ul>
// <P>
// The following Titanium API's are used:
// <ul>
// <li>Titanium.App.addEventListener</li>
// <li>Titanium.App.fireEvent</li>
// <li>Titanium.Contacts.getAllPeople</li>
// <li>Titanium.Geolocation.forwardGeocoder</li>
// <li>Titanium.Map.STANDARD_TYPE,</li>
// <li>Titanium.Map.createView</li>
// <li>Titanium.UI.createTab</li>
// <li>Titanium.UI.createTabGroup</li>
// <li>Titanium.UI.createWebView</li>
// <li>Titanium.UI.createWindow</li>
// <li>Titanium.UI.setBackgroundColor</li>
// </ul>
// <P>
// The following SmartClient Components are used
// <ul>
// <li>isc.DataSource</li>
// <li>isc.ListGrid</li>
// </ul>
// <P>
// The following SmartClient Resources are bundled in the Titanium application
// <ul>
// <li>ISC_Containers.js</li>
// <li>ISC_Core.js</li>
// <li>ISC_DataBinding.js</li>
// <li>ISC_Foundation.js</li>
// <li>ISC_Grids.js</li>
// <li>load_skin.js</li>
// <li>skins/Mobile/images/black.gif</li>
// <li>skins/Mobile/images/blank.gif</li>
// <li>skins/Mobile/images/checked.png</li>
// <li>skins/Mobile/images/formula_menuItem.png</li>
// <li>skins/Mobile/images/grid.gif</li>
// <li>skins/Mobile/images/group_closed.gif</li>
// <li>skins/Mobile/images/group_opened.gif</li>
// <li>skins/Mobile/images/headerMenuButton_icon.gif</li>
// <li>skins/Mobile/images/loading.gif</li>
// <li>skins/Mobile/images/loadingSmall.gif</li>
// <li>skins/Mobile/images/opacity.png</li>
// <li>skins/Mobile/images/pinstripes.png</li>
// <li>skins/Mobile/images/row_collapsed.gif</li>
// <li>skins/Mobile/images/row_expanded.gif</li>
// <li>skins/Mobile/images/sort_ascending.gif</li>
// <li>skins/Mobile/images/sort_descending.gif</li>
// <li>skins/Mobile/skin_styles.css</li>
// </ul>
//
// @title Integration with Titanium
// @treeLocation Concepts/Mobile Application Development
// @visibility external
//<

//> @groupDef phonegapIntegration
// <P>
// PhoneGap documentation, quick start information, and programming guides are available at +externalLink{http://phonegap.com,http://phonegap.com}.
// <P>
// PhoneGap exposes a Contacts API which allows one to find, create and remove contacts from the device's contacts database.
// Unlike Titanium, which provides many native UI components, PhoneGap relies on 3rd party frameworks for
// UI components. Additionally, PhoneGap provides no transitions or other animation effects normally
// accessible in native applications.
// <P>
// <em>In the following guide, the name "MyMobileApp" refers to a SmartClient mobile application.
// The instructions are intended to be general, and applicable to other apps by simply substituting
// the application name and the few other app-specific details.</em>
//
// <h3>Installing PhoneGap</h3>
// Beginning with PhoneGap 2.9.0, PhoneGap is an NPM (Node.js Packager Manager) package.
// You will need to install Node.js first in order to install PhoneGap. (<b>Tip for Mac users:</b>
// +externalLink{http://brew.sh,Homebrew} is a simple and easy way
// to install the latest version of Node.js and npm: <code>brew install node</code>)
//
// <p>Once Node.js is installed, see +externalLink{http://phonegap.com/install/,http://phonegap.com/install/} for
// instructions on installing PhoneGap.
//
// <h3>Creating the PhoneGap Project</h3>
// Use the +externalLink{http://docs.phonegap.com/en/edge/guide_cli_index.md.html,<code>phonegap</code> command line utility}
// to create a new folder containing the project files:
//
// <pre style="white-space:nowrap">phonegap create --id com.mycompany.apps.MyMobileApp --name "MyMobileApp" path/to/project_folder</pre>
//
// <p>The project ID and name should be changed for your app.
//
// <h3>General Instructions</h3>
// Within the project folder, PhoneGap creates a special <code>www/</code> folder which contains
// the application JavaScript code and other assets. Within this folder, only <code>config.xml</code>
// is needed. All other files of the default "Hello PhoneGap" app can be deleted.
//
// <p>You will need to open the application's main HTML file in a text editor to make a few changes:
// <ul>
//   <li>Change the DOCTYPE to the HTML5 DOCTYPE: <code>&lt;!DOCTYPE html&gt;</code></li>
//   <li>Add a <code>&lt;script&gt;</code> tag to the <code>&lt;head&gt;</code> element to load <code>cordova.js</code>:
//       <pre>&lt;script type="text/javascript" charset="UTF-8" src="cordova.js"&gt;&lt;/script&gt;</pre>
//
//       <p><b>NOTE:</b> The <code>www/</code> folder should not contain <code>cordova.js</code>.
//       In other words, don't try to copy <code>cordova.js</code> into the <code>www/</code> folder.
//       PhoneGap automatically adds the appropriate version of this script, which is different for
//       each platform.</li>
//   <li>Ensure that the following <code>&lt;meta&gt;</code> tags are used, also in the <code>&lt;head&gt;</code> element:
//       <pre>&lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt;
//&lt;meta name="format-detection" content="telephone=no"&gt;
//&lt;meta name="viewport" content="initial-scale=1, width=device-width, user-scalable=no, minimum-scale=1, maximum-scale=1"&gt;</pre></li>
// </ul>
//
// <p>After making those changes, you will need to defer starting the application until the
//    <code>+externalLink{http://docs.phonegap.com/en/edge/cordova_events_events.md.html#deviceready,deviceready}</code> event has fired,
//    particularly if your application invokes any PhoneGap API function.
//
//        <smartclient>In SmartClient, deferring the application can be accomplished by wrapping all application code within a 'deviceready' listener:
//        <pre class="sourcefile">&lt;script type="text/javascript"&gt;
//document.addEventListener("deviceready", function onDeviceReady() {
//    // application code goes here
//}, false);
//&lt;/script&gt;</pre></smartclient>
//
//        <smartgwt>To accomplish this in Smart&nbsp;GWT, it is helpful to use a utility class together with a bit of JavaScript.
//
// <p>The following utility class can be used to defer the <code>onModuleLoad</code> code until PhoneGap is ready:
//
// <pre class="sourcefile">package com.mycompany.client;
//
//import com.google.gwt.core.client.EntryPoint;
//
//public abstract class CordovaEntryPoint implements EntryPoint {
//
//    &#x40;Override
//    public final native void onModuleLoad() &#x2F;*-{
//        var self = this;
//        if ($wnd.isDeviceReady) self.&#x40;com.mycompany.client.CordovaEntryPoint::onDeviceReady()();
//        else {
//            var listener = $entry(function () {
//                $doc.removeEventListener("deviceready", listener, false);
//                self.&#x40;com.mycompany.client.CordovaEntryPoint::onDeviceReady()();
//            });
//            $doc.addEventListener("deviceready", listener, false);
//        }
//    }-*&#x2F;;
//
//    protected abstract void onDeviceReady();
//}</pre>
//
// <p>The <code>CordovaEntryPoint</code> class is used in conjunction with the following JavaScript,
//        which should be added before the closing <code>&lt/body&gt;</code> tag:
//
//     <pre class="sourcefile">&lt;script type="text/javascript"&gt;
//document.addEventListener("deviceready", function onDeviceReady() {
//    window.isDeviceReady = true;
//    document.removeEventListener("deviceready", onDeviceReady, false);
//}, false);
//&lt;/script&gt;</pre>
//
// <p>After compiling your application with PhoneGap/Cordova support, copy the compiled Smart&nbsp;GWT
// application to the <code>www/</code> folder.
// </smartgwt>
//
// <h3>iOS Platform (iPhone &amp; iPad)</h3>
//
// <ol>
// <li>Open <b>Terminal</b>, <code>cd</code> into the project folder, and run:
// <pre>phonegap build ios</pre></li>
// <li>Within the newly-created <code>platforms/ios/</code> folder, open the Xcode project <code>MyMobileApp.xcodeproj</code>.</li>
// <li>In Xcode, set the active scheme to <b>MyMobileApp &gt; iPhone Retina (4-inch) &gt; iOS 7.0</b> or some other simulator destination.
//     Then click the <b>Run</b> button. Xcode will start the iPhone Simulator and run the app.</li>
// <li>When you are finished testing the application in the simulator, click the <b>Stop</b> button.</li>
// </ol>
//
// <p>It is helpful to pay attention to the output window when testing the app within iOS Simulator.
// The output window contains all logs to <code>+externalLink{https://developer.mozilla.org/en-US/docs/Web/API/console,window.console}</code> and messages from the Cordova
// framework itself. One common issue is <code>ERROR whitelist rejection: url='SOMEURL'</code>,
// which means that SOMEURL has not been added to <code>&lt;access origin="..."/&gt;</code> in <code>config.xml</code>.
// Refer to the +externalLink{http://docs.phonegap.com/en/edge/guide_whitelist_index.md.html#Domain%20Whitelist%20Guide,Domain Whitelist Guide}
// for more information.
//
// <p>Once you have completely tested the application within the simulator, you should test the app on
// real hardware. Refer to Apple's +externalLink{https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html,App Distribution Guide} for complete instructions on provisioning the app for testing devices, in particular, the section titled
// +externalLink{https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/TestingYouriOSApp/TestingYouriOSApp.html#//apple_ref/doc/uid/TP40012582-CH8-SW1,Beta Testing Your iOS App}.
//
// <h3>Android Platform</h3>
// To begin targeting Android devices, follow the instructions on the
// +externalLink{http://docs.phonegap.com/en/edge/guide_platforms_android_index.md.html,Android Platform Guide}.
//
// <p>It is helpful to monitor the LogCat view in Eclipse to verify that your application is working correctly.
// Common errors include:
// <ul>
// <li><code>Application Error The protocol is not supported. (gap://ready)</code>
//     <p>This means that the incorrect <code>cordova.js</code> script is being used. You
//     must use the <code>cordova.js</code> for Android.<!-- http://community.phonegap.com/nitobi/topics/error_starting_app_on_android -->
//     <p>Try updating the 'android' platform to fix the problem:
//     <pre>phonegap platform update android</pre>
//     </li>
// <li><code>Data exceeds UNCOMPRESS_DATA_MAX</code>
//     <p>In older versions of Android (pre-2.3.3), there is a 1 Megabyte limit on the size of individual
//        Android app assets. This error message means that one asset file exceeds this limit.
//        You should see a popup alert dialog containing the name of the problematic file, and then the app will crash.
//     <p>The "Data exceeds UNCOMPRESS_DATA_MAX" error can be seen if, for example, the SmartGWT.mobile application
//        was compiled in DETAILED or PRETTY mode.
//     </li>
// </ul>
//
// <h3>Samples</h3>
// <smartclient>
// <p>The SmartClient SDK package has a sample application called MyContacts which demonstrates how
// to work with the PhoneGap API in a SmartClient app. The main SmartClient code is located in
// <code>smartclientSDK/examples/phonegap/MyContacts</code>. An Xcode project used to package the app for iOS
// devices is located at <code>smartclientSDK/examples/phonegap/MyContacts-iOS</code>. An Eclipse project used
// to package the app for Android devices is located at <code>smartclientSDK/examples/phonegap/MyContacts-Android</code>.
// </smartclient><smartgwt>
// <p>The Smart&nbsp;GWT Google Code project has a sample application called
// +externalLink{https://github.com/isomorphic-software/smartgwt/tree/master/samples/phonegap/MyContacts,MyContacts}
// which demonstrates how to work with the PhoneGap API in a Smart&nbsp;GWT app. The main Smart&nbsp;GWT code is located at
// <code>+externalLink{https://github.com/isomorphic-software/smartgwt/tree/master/samples/phonegap/MyContacts,trunk/samples/phonegap/MyContacts}</code>.
// An Xcode project used to package the app for iOS devices is located at <code>
// +externalLink{https://github.com/isomorphic-software/smartgwt/tree/master/samples/phonegap/MyContacts-iOS,trunk/samples/phonegap/MyContacts-iOS}</code>.
// An Eclipse project used to package the app for Android devices is located at <code>
// +externalLink{https://github.com/isomorphic-software/smartgwt/tree/master/samples/phonegap/MyContacts-Android,trunk/samples/phonegap/MyContacts-Android}</code>.
//
// <p>This sample application utilizes the script changer technique to load the correct <code>cordova.js</code>.
// Additionally, GWT's +externalLink{http://www.gwtproject.org/doc/latest/DevGuideCodingBasicsOverlay.html,JavaScript overlay types}
// feature is used to easily wrap the PhoneGap Contacts API for use by the Smart&nbsp;GWT app.
// </smartgwt>
//
// @title Integration with PhoneGap
// @treeLocation Concepts/Mobile Application Development
// @visibility external
//<

isc.Browser.isAndroid = navigator.userAgent.indexOf("Android") > -1;

if (isc.Browser.isAndroid) {
    var pos = navigator.userAgent.indexOf("Android");
    if (pos >= 0) {
        isc.Browser.androidMinorVersion = parseFloat(navigator.userAgent.substring(pos + "Android".length));
        // Firefox for Android does not say which version of Android it's running on.
        // See also:
        // - https://developer.mozilla.org/en/Gecko_user_agent_string_reference#Mobile_and_Tablet_indicators
        // - Bug 625238 - Add device info to User-Agent
        //   https://bugzilla.mozilla.org/show_bug.cgi?id=625238
        if (window.isNaN(isc.Browser.androidMinorVersion)) delete isc.Browser.androidMinorVersion;
    }

    // Is the browser a WebView? This is true for the stock Android Browser and third-party apps'
    // WebViews (such as when using Cordova/PhoneGap), but should be false for other Android browsers.
    // From https://developers.google.com/chrome/mobile/docs/webview/overview#what_is_the_default_user-agent
    // "If you're attempting to differentiate between the WebView and Chrome for Android, you
    // should look for the presence of the Version/X.X string in the WebView user-agent string.
    // Don't rely on the specific Chrome version number, 30.0.0.0 as this may change with future
    // releases."
    isc.Browser.isAndroidWebView = navigator.userAgent.indexOf("Version/") >= 0;
}


isc.Browser.isRIM = isc.Browser.isBlackBerry =
    navigator.userAgent.indexOf("BlackBerry") > -1 || navigator.userAgent.indexOf("PlayBook") > -1;

isc.Browser.isMobileIE = navigator.userAgent.indexOf("IEMobile") > -1;

// Is the browser Mobile Firefox?
// https://wiki.mozilla.org/Compatibility/UADetectionLibraries
// https://developer.mozilla.org/en-US/docs/Gecko_user_agent_string_reference#Mobile_and_Tablet_indicators
isc.Browser.isMobileFirefox = isc.Browser.isFirefox && (navigator.userAgent.indexOf("Mobile") > -1 ||
                                                        navigator.userAgent.indexOf("Tablet") > -1);


isc.Browser.isMobileWebkit = (isc.Browser.isSafari && navigator.userAgent.indexOf(" Mobile/") > -1
    || isc.Browser.isAndroid
    || isc.Browser.isBlackBerry) && !isc.Browser.isFirefox;

// intended for general mobile changes (performance, etc)
isc.Browser.isMobile = (isc.Browser.isMobileFirefox ||
                        isc.Browser.isMobileIE ||
                        isc.Browser.isMobileWebkit);

//> @classAttr browser.isTouch (boolean : auto-detected based on device : RW)
// Is the application running on a touch device (e.g. iPhone, iPad, Android device, etc.)?
// <p>
// SmartClient's auto-detected value for <code>isTouch</code> can be overridden via
// +link{Browser.setIsTouch()}.
//
// @visibility external
//<

isc.Browser.isTouch = (isc.Browser.isMobileFirefox ||
                       isc.Browser.isMobileIE ||
                       isc.Browser.isMobileWebkit);

//> @classMethod browser.setIsTouch() (A)
// Setter for +link{Browser.isTouch} to allow this global variable to be changed at runtime.
// This advanced method is provided to override SmartClient's auto-detection logic, since the
// framework can only detect touch devices that existed at the time the platform was released.
// Any change to +link{Browser.isTouch} must be made before any component is created;
// <strong>it is an application error</strong> to attempt to change <code>isTouch</code> after
// components have been created.
// <p>
// Note that setting <code>Browser.isTouch</code> might affect the values of
// +link{Browser.isDesktop}, +link{Browser.isTablet}, and/or +link{Browser.isHandset}.
//
// @param isTouch (boolean) new setting for <code>Browser.isTablet</code>.
// @visibility external
//<
isc.Browser.setIsTouch = function (isTouch) {
    isTouch = isc.Browser.isTouch = !!isTouch;

    if (isc.Browser.isDesktop) {
        isc.Browser.isHandset = false;
        isc.Browser.isTablet = false;
    } else {
        isc.Browser.isHandset = isTouch && !isc.Browser.isTablet;
        isc.Browser.isTablet = !isc.Browser.isHandset;
    }

    isc.Browser.hasNativeDrag = !isTouch && "draggable" in document.documentElement && !isc.Browser.isIE;

    isc.Browser.nativeMouseMoveOnCanvasScroll = !isTouch && (isc.Browser.isSafari || isc.Browser.isChrome);


};

// iPhone OS including iPad.  Search for iPad or iPhone.

isc.Browser.isIPhone = (isc.Browser.isMobileWebkit &&
                        (navigator.userAgent.indexOf("iPhone") > -1 ||
                         navigator.userAgent.indexOf("iPad") > -1));

if (isc.Browser.isIPhone) {
    // adapted from SmartGWT.mobile
    var match = navigator.userAgent.match(/CPU\s+(?:iPhone\s+)?OS\s*([0-9_]+)/i);
    if (match != null) {
        isc.Browser.iOSMinorVersion = window.parseFloat(match[1].replace('_', '.'));
        isc.Browser.iOSVersion = isc.Browser.iOSMinorVersion << 0;
    }

    // The UIWebView user agent is different from the Mobile Safari user agent in that it does
    // not contain the word "Safari".
    isc.Browser.isUIWebView = navigator.userAgent.indexOf("Safari") < 0;

    isc.Browser.isMobileSafari = !isc.Browser.isUIWebView &&
                                 // Exclude Chrome for iOS
                                 // https://developers.google.com/chrome/mobile/docs/user-agent#chrome_for_ios_user-agent
                                 navigator.userAgent.indexOf("CriOS/") < 0;
}

// iPad.  Checks for "iPhone" OS + "iPad" in UA String.
isc.Browser.isIPad = (isc.Browser.isIPhone &&
                        navigator.userAgent.indexOf("iPad") > -1);

isc.Browser.isWindowsPhone = navigator.userAgent.indexOf("Windows Phone") > -1;


if (isc.Browser.isIPad && isc.Browser.isMobileSafari && isc.Browser.iOSVersion == 7) {

    var iOS7IPadStyleSheetID = "isc_iOS7IPadStyleSheet";
    if (document.getElementById(iOS7IPadStyleSheetID) == null) {
        var styleElement = document.createElement("style");
        styleElement.id = iOS7IPadStyleSheetID;
        document.head.appendChild(styleElement);
        var s = styleElement.sheet;
        s.insertRule("\n@media (orientation:landscape) {\n" +
                         "html {" +
                             "position: fixed;" +
                             "bottom: 0px;" +
                             "width: 100%;" +
                             "height: 672px;" +
                         "}" +
                         "body {" +
                             "position: fixed;" +
                             "top: 0px;" +
                             "margin: 0px;" +
                             "padding: 0px;" +
                             "width: 100%;" +
                             "height: 672px;" +
                         "}\n" +
                     "}\n", 0);
    }


    (function () {
        var isFormItemElement = function (element) {
            if (element == null) return false;
            var tagName = element.tagName;
            return (tagName === "INPUT" ||
                    tagName === "SELECT" ||
                    tagName === "TEXTAREA");
        };

        var scrollToTopTimerID = null;
        window.addEventListener("scroll", function () {
            if (document.body == null) return;
            var scrollTop = document.body.scrollTop;
            if (scrollTop == 0) return;

            var activeElement = document.activeElement;
            if (isFormItemElement(activeElement)) {
                var onBlur = function onBlur(blurEvent) {
                    activeElement.removeEventListener("blur", onBlur, true);

                    if (scrollToTopTimerID != null) clearTimeout(scrollToTopTimerID);
                    scrollToTopTimerID = setTimeout(function () {
                        scrollToTopTimerID = null;

                        activeElement = document.activeElement;

                        // If another form item element is active, then wait for that element to lose focus.
                        if (activeElement !== blurEvent.target && isFormItemElement(activeElement)) {
                            activeElement.addEventListener("blur", onBlur, true);

                        } else {
                            document.body.scrollTop = 0;
                        }
                    }, 1);
                };
                activeElement.addEventListener("blur", onBlur, true);
            } else {
                document.body.scrollTop = 0;
            }
        }, false);
    })();
}


//> @type DeviceMode
// Possible layout modes for UI components that are sensitive to the device type being used
// (a.k.a. "responsive design").  See for example +link{SplitPane.deviceMode}.
// @value "handset" mode intended for handset-size devices (phones).  Generally only one UI
//                  panel will be shown at a time.
// @value "tablet" mode intended for tablet-size devices.  Generally, up to two panels are
//                 shown side by side in "landscape" +link{type:PageOrientation}, and only one
//                 panel is shown in "portrait" orientation.
// @value "desktop" mode intended for desktop browsers.  Three or more panels may be shown
//                  simultaneously.
// @visibility external
//<

//> @classAttr browser.isTablet (boolean : auto-detected based on device : RW)
// Is the application running on a tablet device (e.g. iPad, Nexus 7)?
// <p>
// SmartClient can correctly determine whether the device is a tablet in most cases. On any
// uncommon device for which this variable is incorrect, you can define the <code>isc_isTablet</code>
// global with the correct value, and SmartClient will use <code>isc_isTablet</code> for
// <code>Browser.isTablet</code> instead of its own detection logic. Alternatively, you can use
// +link{Browser.setIsTablet()} to change this global variable before any components are
// created.
// <p>
// The value of this variable is only meaningful on touch devices.
//
// @setter setIsTablet()
// @visibility external
//<

if (window.isc_isTablet != null) {
    isc.Browser.isTablet = !!window.isc_isTablet;
} else {
    isc.Browser.isTablet = isc.Browser.isIPad ||
                           (isc.Browser.isRIM && navigator.userAgent.indexOf("Tablet") > -1) ||
                           (isc.Browser.isAndroid && navigator.userAgent.indexOf("Mobile") == -1);
}
isc.Browser._origIsTablet = isc.Browser.isTablet;

//> @classMethod browser.setIsTablet() (A)
// Setter for +link{Browser.isTablet} to allow this global variable to be changed at runtime.
// This advanced method is provided to override SmartClient's detection of devices, since the
// framework can only detect devices that existed at the time the platform was released. Any
// changes to +link{Browser.isDesktop}, +link{Browser.isHandset}, or +link{Browser.isTablet}
// must be made before any component is created;
// <strong>it is an application error</strong> to attempt to change <code>isDesktop</code>,
// <code>isHandset</code>, or <code>isTablet</code> after components have been created.
// <p>
// Note that setting <code>Browser.isTablet</code> might affect the values of
// +link{Browser.isDesktop} and +link{Browser.isHandset}.
//
// @param isTablet (boolean) new setting for <code>Browser.isTablet</code>.
// @visibility external
//<
isc.Browser.setIsTablet = function (isTablet) {
    isTablet = isc.Browser.isTablet = !!isTablet;
    isc.Browser.isHandset = (isc.Browser.isTouch && !isc.Browser.isTablet);
    isc.Browser.isDesktop = (!isc.Browser.isTablet && !isc.Browser.isHandset);


};

//> @classAttr browser.isHandset (boolean : auto-detected based on device: RW)
// Is the application running on a handset-sized device, with a typical screen width of around
// 3-4 inches?
// <p>
// This typically implies that the application will be working with only 300-400 pixels.
//
// @setter setIsHandset()
// @visibility external
//<

isc.Browser.isHandset = (isc.Browser.isTouch && !isc.Browser.isTablet);

//> @classMethod browser.setIsHandset() (A)
// Setter for +link{Browser.isHandset} to allow this global variable to be changed at runtime.
// This advanced method is provided to override SmartClient's detection of devices, since the
// framework can only detect devices that existed at the time the platform was released. Any
// changes to +link{Browser.isDesktop}, +link{Browser.isHandset}, or +link{Browser.isTablet}
// must be made before any component is created;
// <strong>it is an application error</strong> to attempt to change <code>isDesktop</code>,
// <code>isHandset</code>, or <code>isTablet</code> after components have been created.
// <p>
// Note that setting <code>Browser.isHandset</code> might affect the values of
// +link{Browser.isDesktop} and +link{Browser.isTablet}.
//
// @param isHandset (boolean) new setting for <code>Browser.isHandset</code>.
// @visibility external
//<
isc.Browser.setIsHandset = function (isHandset) {
    isHandset = isc.Browser.isHandset = !!isHandset;
    isc.Browser.isTablet = (isc.Browser.isTouch && !isc.Browser.isHandset);
    isc.Browser.isDesktop = (!isc.Browser.isTablet && !isc.Browser.isHandset);


};

//> @classAttr browser.isDesktop (boolean : auto-detected based on device : RW)
// Is the application running in a desktop browser? This is true if +link{Browser.isTablet}
// and +link{Browser.isHandset} are both <code>false</code>.
//
// @setter setIsDesktop()
// @visibility external
//<

isc.Browser.isDesktop = (!isc.Browser.isTablet && !isc.Browser.isHandset);

//> @classMethod browser.setIsDesktop() (A)
// Setter for +link{Browser.isDesktop} to allow this global variable to be changed at runtime.
// This advanced method is provided to override SmartClient's detection of devices, since the
// framework can only detect devices that existed at the time the platform was released. Any
// changes to +link{Browser.isDesktop}, +link{Browser.isHandset}, or +link{Browser.isTablet}
// must be made before any component is created;
// <strong>it is an application error</strong> to attempt to change <code>isDesktop</code>,
// <code>isHandset</code>, or <code>isTablet</code> after components have been created.
// <p>
// Note that setting <code>Browser.isDesktop</code> might affect the values of
// +link{Browser.isHandset} and +link{Browser.isTablet}.
//
// @param isDesktop (boolean) new setting for <code>Browser.isDesktop</code>.
// @visibility external
//<
isc.Browser.setIsDesktop = function (isDesktop) {
    isDesktop = isc.Browser.isDesktop = !!isDesktop;
    if (isDesktop) {
        isc.Browser.isHandset = false;
        isc.Browser.isTablet = false;
    } else {
        isc.Browser.isTablet = isc.Browser._origIsTablet;
        isc.Browser.isHandset = !isc.Browser.isTablet;
    }


};

//> @classAttr  Browser.isBorderBox    (boolean : ? : R)
// Do divs render out with "border-box" sizing by default.
//<
// See comments in Canvas.adjustHandleSize() for a discussion of border-box vs content-box sizing

isc.Browser.isBorderBox = (isc.Browser.isIE && !isc.Browser.isStrict);

//>    @classAttr    Browser.lineFeed    (string : ? : RA)
//        Linefeed for this platform
//<

isc.Browser.lineFeed = (isc.Browser.isWin ? "\r\n" : "\n");

//>    @classAttr    Browser._supportsMethodTimeout    (string : ? : RA)
//        setTimeout() requires text string parameter in MacIE or IE 4
//<
isc.Browser._supportsMethodTimeout = false;//!(isc.Browser.isIE && (isc.Browser.isMac || isc.Browser.version == 4));

//>    @classAttr    Browser.isDOM (string : ? : RA)
//        Whether this is a DOM-compliant browser.  Indicates general compliance with DOM standards,
//      not perfect compliance.
//<
isc.Browser.isDOM = (isc.Browser.isMoz || isc.Browser.isOpera ||
                     isc.Browser.isSafari || (isc.Browser.isIE && isc.Browser.version >= 5));

//> @classAttr browser.isSupported (boolean : auto-detected based on browser : R)
// Whether SmartClient supports the current browser.
// <P>
// Note that this flag will only be available on browsers that at least support basic
// JavaScript.
//
// @visibility external
//<
isc.Browser.isSupported = (
    // we support all versions of IE 5.5 and greater on Windows only
    (isc.Browser.isIE && isc.Browser.minorVersion >= 5.5 && isc.Browser.isWin) ||
    // Mozilla and Netscape 6, all platforms
    isc.Browser.isMoz ||
    isc.Browser.isOpera ||
    isc.Browser.isSafari || // NB: really means "is Webkit", so includes Chrome, mobile Safari
    isc.Browser.isAIR
);


isc.Browser.nativeMouseMoveOnCanvasScroll =
    !isc.Browser.isTouch && (isc.Browser.isSafari || isc.Browser.isChrome);

//> @classAttr Browser.seleniumPresent (boolean : varies : R)
// Whether current page has been loaded by Selenium RC/WebDriver.
//<
isc.Browser.seleniumPresent = (function () {
    var match = location.href.match(/[?&](?:sc_selenium)=([^&#]*)/);
    return match && match.length > 1 && "true" == match[1];
})();

//> @type Autotest
// @value Browser.SHOWCASE autotest is targeting SmartClient or SGWT showcases
isc.Browser.SHOWCASE = "showcase";
// @value Browser.RUNNER autotest is targeting TestRunner-based JS tests
isc.Browser.RUNNER = "runner";
//<

//> @classAttr Browser.autotest (Autotest : varies : R)
// The current mode of the autotest system (null if not in autotest mode)
//<
isc.Browser.autotest = (function () {
    var match = location.href.match(/[?&](?:autotest)=([^&#]*)/);
    return match && match.length > 1 ? match[1] : null;
})();

//>    @classAttr    Browser.allowsXSXHR    (boolean : ? : RA)
//    Traditionally, web browsers reject attempts to make an XmlHttpRequest of a server other than the origin
//  server. However, some more recent browsers allow cross-site XmlHttpRequests to be made, relying on the
//  server to accept or reject them depending on what the origin server is.
//<
isc.Browser.allowsXSXHR = (
    (isc.Browser.isFirefox && isc.Browser.firefoxMajorMinorNumber >= 3.5) ||
    // Chrome auto-updates to latest stable version every time you start it, and there is no option to prevent
    // this from happening, so there's no point in querying version
    (isc.Browser.isChrome) ||
    (isc.Browser.isSafari && isc.Browser.safariVersion >= 531)
);

//> @classAttr Browser.useCSSFilters (boolean : ? : R)
// Whether the current browser supports gradients and whether SmartClient is
// configured to use gradients (via the setting of window.isc_useGradientsPreIE9).
//<


var isc_useGradientsPreIE9 = window.isc_useGradientsPreIE9;
isc.Browser.useCSSFilters =
    !isc.Browser.isIE || isc.Browser.isIE9 || isc_useGradientsPreIE9 != false;

//> @classAttr Browser.isSGWT (boolean : ? : RA)
// Are we running in SGWT.
// This is set up by SmartGWT wrapper code in JsObject.init().
// Obviously only applies to internal SmartClient code since developer code for an SGWT app
// would be written in Java and there'd be no need to check this var!
// @visibility internal
//<

//> @classAttr browser.useCSS3 (boolean : see below : R)
// Whether the current browser supports CSS3 and whether SmartClient is configured to use
// CSS3 features (via the setting of window.isc_css3Mode).
// <P>
// If isc_css3Mode is "on" then useCSS3 is set to true.  If isc_css3Mode is set to
// "supported", "partialSupport", or is unset, then useCSS3 is set to true only if the browser
// is a WebKit-based browser, Firefox, IE 9 in standards mode, or IE 10+.  If isc_css3Mode is set
// to "off" then useCSS3 is set to false.
// @visibility external
//<
var isc_css3Mode = window.isc_css3Mode;
if (isc_css3Mode == "on") {
    isc.Browser.useCSS3 = true;
} else if (isc_css3Mode == "off") {
    isc.Browser.useCSS3 = false;
} else if (isc_css3Mode == "supported" ||
           isc_css3Mode == "partialSupport" ||
           (typeof isc_css3Mode) === "undefined")
{
    isc.Browser.useCSS3 = isc.Browser.isWebKit ||
                          isc.Browser.isFirefox ||
                          (isc.Browser.isIE && (isc.Browser.isIE9 || isc.Browser.version >= 10));
} else {
    isc.Browser.useCSS3 = false;
}

var isc_spriting = window.isc_spriting;
if (isc_spriting == "off") {
    isc.Browser.useSpriting = false;
} else {
    isc.Browser.useSpriting = (!isc.Browser.isIE || isc.Browser.version >= 7);
}

isc.Browser.useInsertAdjacentHTML = !!document.documentElement.insertAdjacentHTML;


isc.Browser.useInsertAdjacentHTMLForSVG = (function () {
    if (!!document.createElementNS) {
        var svgGElem = document.createElementNS("http://www.w3.org/2000/svg", "g");
        if ((typeof svgGElem.insertAdjacentHTML) === "function") {
            try {
                svgGElem.insertAdjacentHTML("beforeend", "<rect/><ellipse/>");
                return (svgGElem.childNodes.length == 2 &&
                        svgGElem.childNodes[1].namespaceURI === "http://www.w3.org/2000/svg");
            } catch (e) {
                // ignored
            }
        }
    }
    return false;
})();

// Test for availability of the Range.getBoundingClientRect() method which was added to
// CSSOM View as of the 04 August 2009 Working Draft.
// http://www.w3.org/TR/2009/WD-cssom-view-20090804/

isc.Browser.hasNativeGetRect = (!isc.Browser.isIE &&
                                (!isc.Browser.isSafari || !isc.Browser.isMac || isc.Browser.version >= 6) &&
                                !!document.createRange &&
                                !!(document.createRange().getBoundingClientRect));


isc.Browser._useNewSingleDivSizing = !((isc.Browser.isIE && isc.Browser.version < 10 && !isc.Browser.isIE9) ||
                                       (isc.Browser.isWebKit && !(parseFloat(isc.Browser.rawSafariVersion) >= 532.3)));
isc.Browser.useClipDiv = !isc.Browser._useNewSingleDivSizing;


isc.Browser.hasTextOverflowEllipsis = (!isc.Browser.isMoz || isc.Browser.version >= 7) &&
                                      (!isc.Browser.isOpera || isc.Browser.version >= 9);

// https://developer.mozilla.org/en-US/docs/CSS/text-overflow
isc.Browser._textOverflowPropertyName = (!isc.Browser.isOpera || isc.Browser.version >= 11 ? "text-overflow" : "-o-text-overflow");


isc.Browser._hasGetBCR = !isc.Browser.isSafari || isc.Browser.version >= 4;


isc.Browser._hasElementPointerEvents = ("pointerEvents" in document.documentElement.style &&
                                        !isc.Browser.isOpera &&
                                        (!isc.Browser.isIE || isc.Browser.version >= 11));

// Does the browser support HTML5 drag and drop?
// http://caniuse.com/#feat=dragndrop
// http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd
//
// This is set to false in IE because cross-window drags are not possible.

isc.Browser.hasNativeDrag = !isc.Browser.isTouch && "draggable" in document.documentElement && !isc.Browser.isIE;

// http://dom.spec.whatwg.org/#ranges
isc.Browser._hasDOMRanges = !!(window.getSelection && document.createRange && window.Range);

// Whether the browser supports Range.createContextualFragment() generally.

isc.Browser._supportsCreateContextualFragment = isc.Browser._hasDOMRanges && !!document.createRange().createContextualFragment;

// Whether the browser supports Range.createContextualFragment() in SVG contexts.

isc.Browser._supportsSVGCreateContextualFragment = ((isc.Browser.isMoz && isc.Browser.version >= 36) ||
                                                    (isc.Browser.isChrome && isc.Browser.version >= 42));

// Whether the browser supports the CSS `background-size' property.
// https://developer.mozilla.org/en-US/docs/Web/CSS/background-size
isc.Browser._supportsBackgroundSize = "backgroundSize" in document.documentElement.style;

// Does the browser support CSS3 transitions?
// http://caniuse.com/#feat=css-transitions
// Note: No need to check for "msTransition" because IE10 was the first version of IE to have
// CSS3 transitions support and this is unprefixed.

isc.Browser._supportsCSSTransitions = (("transition" in document.documentElement.style ||
                                        "WebkitTransition" in document.documentElement.style ||
                                        "OTransition" in document.documentElement.style) &&
                                       (!isc.Browser.isMoz ||
                                        (!isc.Browser.isTouch && isc.Browser.version >= 34)));


isc.Browser._transitionEndEventType = ("WebkitTransition" in document.documentElement.style
                                       ? "webkitTransitionEnd"
                                       : ("OTransition" in document.documentElement.style
                                          ? (isc.Browser.isOpera && isc.Browser.version >= 12 ? "otransitionend" : "oTransitionEnd")
                                          : "transitionend"));

// Whether the browser supports native touch scrolling.
// This is a classMethod rather than a classAttr because it depends on isTouch, which is settable
// by the application any time up to creation of the first widget. See setIsTouch().
isc.Browser._getSupportsNativeTouchScrolling = function () {
    return (this.isTouch &&
            (!(this.isIPhone || this.isIPad) || this.iOSVersion >= 6));
};

isc.Browser._supportsWebkitOverflowScrolling = ("WebkitOverflowScrolling" in document.documentElement.style &&
                                                isc.Browser.iOSVersion >= 6);

// Does the browser support CanvasRenderingContext2D.isPointInStroke()?
isc.Browser._supportsCanvasIsPointInStroke = (function () {
    var canvas = document.createElement("canvas");
    if (canvas.getContext != null) {
        var context = canvas.getContext("2d");
        return !!context.isPointInStroke;
    }
    return false;
})();


isc.Browser._supportsNativeNodeContains = ("contains" in document.documentElement);
// Node.contains() was introduced in Gecko 9.
if (!isc.Browser._supportsNativeNodeContains && window.Node != null) {
    Node.prototype.contains = function (otherNode) {
        for (; otherNode != null; otherNode = otherNode.parentNode) {
            if (this === otherNode) return true;
        }
        return false;
    };
}


isc.Browser._supportsMinimalUI = (isc.Browser.isIPhone && !isc.Browser.isIPad &&
                                  isc.Browser.isMobileSafari &&
                                  7.1 == isc.Browser.iOSMinorVersion);


isc.Browser._svgElementsHaveParentElement = (!!document.createElementNS && "parentElement" in document.createElementNS("http://www.w3.org/2000/svg", "svg"));
if (!isc.Browser._svgElementsHaveParentElement && window.SVGElement != null && Object.defineProperty) {
    Object.defineProperty(SVGElement.prototype, "parentElement", {
        enumerable: true,
        "get" : function () {
            var parentElement = this.parentNode;
            while (parentElement != null && parentElement.nodeType != 1) {
                parentElement = parentElement.parentNode;
            }
            return parentElement;
        }
    });
}

isc.Browser._svgElementsHaveContains = (!!document.createElementNS && "contains" in document.createElementNS("http://www.w3.org/2000/svg", "svg"));
if (!isc.Browser._svgElementsHaveContains && window.SVGElement != null) {
    SVGElement.prototype.contains = function (otherNode) {
        for (; otherNode != null; otherNode = otherNode.parentNode) {
            if (this === otherNode) return true;
        }
        return false;
    };
}

// Does the browser support the HTML5 'placeholder' attribute?

isc.Browser._supportsPlaceholderAttribute = ("placeholder" in document.createElement("input") &&
                                             "placeholder" in document.createElement("textarea"));

isc.Browser._supportsIOSTabs = isc.Browser.isMobileWebkit && "webkitMaskBoxImage" in document.documentElement.style;

// Does the browser support the Screen Orientation API?
// https://w3c.github.io/screen-orientation/
// http://caniuse.com/#feat=screen-orientation

isc.Browser._supportsScreenOrientationAPI = (window.screen != null && "orientation" in screen && "type" in screen.orientation);

// Does the browser support the SVGSVGElement.getIntersectionList() SVG 1.1 DOM method?

isc.Browser._supportsSVGGetIntersectionList = (!isc.Browser.isSafari &&
                                               !isc.Browser.isChrome &&
                                               !!document.createElementNS &&
                                               "getIntersectionList" in document.createElementNS("http://www.w3.org/2000/svg", "svg") &&
                                               "createSVGRect" in document.createElementNS("http://www.w3.org/2000/svg", "svg"));

isc.Browser._supportsJSONObject = (window.JSON != null &&
                                   typeof window.JSON.parse === "function" &&
                                   typeof window.JSON.stringify === "function" &&
                                   window.JSON.stringify("\u0013") === "\"\\u0013\"");



isc.Browser.canUseAggressiveGridTimings = !isc.Browser.isAndroid;
isc.useHighPerformanceGridTimings = window.isc_useHighPerformanceGridTimings == null ?
    isc.Browser.canUseAggressiveGridTimings : window.isc_useHighPerformanceGridTimings && isc.Browser.canUseAggressiveGridTimings;




isc.noOp = function isc_noOp() {};
isc.emptyObject = {};
isc._emptyArray = [];
// normal and obfuscatable name
isc.emptyString = isc._emptyString = "";
isc.space = " ";
isc.dot = ".";
isc.semi = ";";
isc.colon = ":";
isc.slash = "/";
isc.star = "*";
isc.apos = "'";
isc.auto = "auto";
isc.px = "px";
isc.nbsp = "&nbsp;";
isc.xnbsp = "&amp;nbsp;"; // XHTML
isc._false = "false";
isc._falseUC = "FALSE";
isc._underscore = "_";
isc._dollar = "$";
isc._obsPrefix = "_$observed_";
isc._superProtoPrefix = "_$SuperProto_";

isc.gwtRef = "__ref";
isc.gwtModule = "__module";

//> @classMethod isc.logWarn()
// Same as +link{classMethod:Log.logWarn}.
//
// @param message    (String)  message to log
// @param [category]   (String)  category to log in, defaults to "Log"
//
// @visibility external
//<
isc.logWarn = function isc_logWarn(message, category) { isc.Log.logWarn(message, category) };

//> @classMethod isc.echo()
// Same as +link{classMethod:Log.echo}.
//
// @param value    (any)  object to echo
// @return (string) a short string representation of the object
//
// @visibility external
//<
isc.echo = function isc_echo(value) { return isc.Log.echo(value) };

//> @classMethod isc.echoAll()
// Same as +link{classMethod:Log.echoAll}.
//
// @param value    (any)  object to echo
// @return (string) a short string representation of the object
//
// @visibility external
//<
isc.echoAll = function isc_echoAll(value) { return isc.Log.echoAll(value) };

//> @classMethod isc.echoLeaf()
// Same as +link{classMethod:Log.echoLeaf}.
//
// @param value    (any)  object to echo
// @return (string) a short string representation of the object
//
// @visibility external
//<
isc.echoLeaf = function isc_echoLeaf(value) { return isc.Log.echoLeaf(value) };

isc.echoFull = function isc_echoFull(value) { return isc.Log.echoFull(value) };

//> @classMethod isc.logEcho()
// Logs the echoed object (using +link{classMethod:isc.echo}) as a warning, prefixed with an
// optional message.
//
//     @param value    (any)  object to echo
//     @param message    (String)  message to log
//
// @see Log.logWarn() for logging info
// @visibility external
//<
isc.logEcho = function isc_logEcho(value, message) {
    if (message) message += ": ";
    isc.Log.logWarn((message || isc._emptyString) + isc.echo(value))
}

//> @classMethod isc.logEchoAll()
// Logs the echoed object (using +link{classMethod:isc.echoAll}) as a warning, prefixed with an
// optional message.
//
//     @param value    (any)  object to echo
//     @param message    (String)  message to log
//
// @see Log.logWarn() for logging info
// @visibility external
//<
isc.logEchoAll = function isc_logEchoAll(value, message) {
    if (message) message += ": ";
    isc.Log.logWarn((message || isc._emptyString) + isc.echoAll(value))
}

// OutputAsString / StackWalking / Tracing
// ---------------------------------------------------------------------------------------







isc._makeFunction = function isc__makeFunction(args, script) {

    var code = script || args;

    var returnVal;
    if (script == null) {
        returnVal = new Function(code);
        returnVal._argString = isc._emptyString;
    } else {
        returnVal = new Function(args, code);
    }
    return returnVal;
};


isc.doEval = function isc_doEval(code) {
    // transform code and eval inline
    if (isc.Browser.isMoz) return isc._transformCode(code);
    //return isc._transformCode(code);

    if (!isc._evalSet) isc._evalSet = [];
    isc._evalSet[isc._evalSet.length] = code;
    return null;
}
// called at module end
isc.finalEval = function isc_finalEval() {
    //!OBFUSCATEOK
    if (isc._evalSet) {
        if (isc.Browser.isMoz) {
            for (var i = 0; i < isc._evalSet.length; i++) {
                isc.eval(isc._evalSet[i]);
            }
        }
        var code = isc._evalSet.join("");

        if (isc.Browser.isSafari) code = isc._transformCode(code);
        // uncomment to use catch/rethrow stacks in IE as well
        //else if (isc.Browser.isIE) code = isc._transformCode(code);

        if (isc.Browser.isIE) {
            if (window.execScript != null) {
                window.execScript(code, "javascript");
            } else {
                window.eval(code);
            }

        // Safari
        } else {
            isc.eval(code);
        }

        // Init pipelining: set a timeout to eval so that the module init time takes place
        // while the next module is being downloaded (except for the last module)
        // Can't be used for real until
        /*
        var evalFunc = function () {
        if (isc.Browser.isIE) {
            if (window.execScript != null) {
                window.execScript(code, "javascript");
            } else {
                window.eval(code);
            }

        // Safari
        } else {
            isc.eval(code);
        }
        };

        if (isc.module_DataBinding != 1) {
            //if (isc.Log) isc.Log.logWarn("delaying eval");
            setTimeout(evalFunc, 0)
        } else {
            evalFunc();
        }
        */
    }
    isc._evalSet = null;
}

//isc._eitherMarker = /\/\/\$[01]/;
isc._startMarker = "//$0";
isc._endMarker = "//$1";
isc._totalTransformTime = 0;
// code transform time, all modules
//    - Moz: about 140ms
//      - NOTE: overall init time rises by about 400ms, the balance is due to slower parsing
//        because of the added try/catch constructs.  This can be demonstrated by doing the
//        split/join, but just restoring the markers
//    - Safari: about 300ms
//    - IE: 266ms
// - NOTE: some key advantages of this approach as compared to server-side generation *aside
//   from* not hosing IE's ability to do full stack traces w/o try/catch:
//    - allows arbitrary start/end code to be added with only client-side changes
//    - can be conditional per load
//    - much smaller code size impact: could ship w/o local vars for production use

isc._addCallouts = true;
isc._transformCode = function isc__transformCode(code) {
    // set flag indicating stack walking is enabled so that we will also add try..catch to
    // generated functions
    isc._stackWalkEnabled = true;

    var start = isc.timeStamp ? isc.timeStamp() : new Date().getTime();

    var startCode = isc._tryBlock, endCode = isc._evalFromCatchBlock;
    if (isc._addCallouts) startCode = isc._methodEnter + startCode;

    var chunks = code.split(isc._eitherMarker),
        finalCode = [];

    var chunks = code.split(isc._startMarker);
    code = chunks.join(startCode);
    chunks = code.split(isc._endMarker);
    code = chunks.join(endCode);

    if (isc._addCallouts) {
        chunks = code.split("//$2");
        code = chunks.join(isc._methodExit);
    }

    /*
    // approach of single split and join to cut down on String churn.
    // Problem is that because of nested functions, markers do not alternate.  Would need to
    // detect which kind of marker is needed for a given slot, by eg checking the next char
    // over, which might be expensive enough to wipe out any advantage; untested.
    var pos = 0;
    for (var i = 0; i < chunks.length; i++) {
        finalCode[pos++] = chunks[i];
        if (i < chunks.length-1) {
            finalCode[pos++] = i % 2 == 0 ? isc._tryBlock : isc._evalFromCatchBlock;
        }
    }
    finalCode = finalCode.join("");

    try {
        window.isc.eval(finalCode);
    } catch (e) {
        //if (!this._alerted) alert(finalCode.substring(0,5000));
        //this._alerted = true;
        document.write("chunks<br><TEXTAREA style='width:760px;height:400px'>" +
                        chunks.join("\n***") + "</" + "TEXTAREA>");
        document.write("finalCode<br><TEXTAREA style='width:760px;height:400px'>" +
                        finalCode + "</" + "TEXTAREA>");
        throw e;
    }
    //return finalCode;
    */

    var end = isc.timeStamp ? isc.timeStamp() : new Date().getTime();
    isc._totalTransformTime += (end-start);
    return code;
}

isc._evalFromCatchBlock = "}catch(_e){isc.eval(isc._handleError(";
isc._handleError = function isc__handleError(varList) {
    var code = "var _ = {";
    if (varList != "") {
        var varNames = varList.split(",");
        for (var i = 0; i < varNames.length; i++) {
            var varName = varNames[i];
            code += varName + ":" + varName;
            if (i < varNames.length-1) code += ",";
        }
    }
    code += "};";
    code += "if(isc.Log)isc.Log._reportJSError(_e,arguments,this,_);throw _e;";
    return code;
}



// fillList - utility to concat a number of individual arguments into an array
// ---------------------------------------------------------------------------------------
isc.fillList = function isc_fillList(array, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z) {

    if (array == null) array = [];
    else array.length = 0;

    var undef;
    // avoid touching the arguments object if possible

    if (X === undef && Y === undef && Z === undef) {
        array[0] = A;
        array[1] = B;
        array[2] = C;
        array[3] = D;
        array[4] = E;
        array[5] = F;
        array[6] = G;
        array[7] = H;
        array[8] = I;
        array[9] = J;
        array[10] = K;
        array[11] = L;
        array[12] = M;
        array[13] = N;
        array[14] = O;
        array[15] = P;
        array[16] = Q;
        array[17] = R;
        array[18] = S;
        array[19] = T;
        array[20] = U;
        array[21] = V;
        array[22] = W;
    } else {
        for (var i = 1; i < arguments.length; i++) {
            array[i-1] = arguments[i];
        }
    }

    return array;
}



//>    @classMethod isc.addProperties()
//
// Add all properties and methods from any number of objects to a destination object,
// overwriting properties in the destination object.
// <p>
// Common uses of <code>addProperties</code> include creating a shallow copy of an object:<pre>
//
//     isc.addProperties({}, someObject);
//
// </pre>Combining settings in order of precedence:<pre>
//
//     isc.addProperties({}, defaults, overrides, skinOverrides);
//
// </pre>
// <P>
// <b>NOTES</b>:<ul>
// <li>Do not use <code>addProperties</code> to add defaults to an ISC class.
// Use +link{classMethod:Class.addProperties()}, as in:
// <i>MyClassName</i><code>.addProperties()</code>.
// <li>You may find it more convenient to use the instance method +link{class.addProperties()},
// as in: <i>myClassInstance</i><code>.addProperties()</code>, but there's no functional
// difference from using this method.
// </ul>
//
// @see classMethod:Class.addProperties()
// @see Class.addProperties()
//
//    @param    destination            (object)    object to add properties to
//    @param    [(arguments 1-N)]    (object)    objects to obtain properties from.  Properties of all
//                                            arguments other than destination are applied in turn.
// @return (object) returns the destination object
// @visibility external
//<

/*
// code to count all methods according to what they are added to
isc.methodCount = 0;
isc.classMethodCount = 0;
isc.otherMethods = 0;
isc.otherMethodTargets = [];
*/

isc._sourceList = [];

isc.addGlobal(
"addProperties", function isc_addProperties(destination, A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z) {
    var undef,
        sourceList = isc._sourceList;

    if (X === undef && Y=== undef && Z === undef) {
        isc.fillList(sourceList, A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z);

    } else {
        sourceList.length = 0;
        for (var i = 1; i < arguments.length; i++) {
            sourceList[i -1] = arguments[i];
        }
    }

    var result = isc.addPropertyList(destination, sourceList);
    // reset the sourceList so we don't hang onto the objects in memory unnecessarily
    sourceList.length = 0;
    return result;
});


isc._interfaceInstanceProps = {};
isc._interfaceClassProps = {};
isc._getInterfaceProps = function isc__getInterfaceProps(destination) {
    var className = destination.Class,
        props;
    if (isc.isA.ClassObject(destination)) {
        props = isc._interfaceClassProps[className] =
                    isc._interfaceClassProps[className] || [];
    } else if (isc.isAn.InstancePrototype(destination)) {
        props = isc._interfaceInstanceProps[className] =
                    isc._interfaceInstanceProps[className] || [];
    }
    return props;
}

//>    @method ClassFactory.addPropertyList() or isc.addPropertyList()
//
// Add all properties from any number of objects to a destination object.
//
// This differs from addProperties() in that it takes an array as it's second argument,
// applying each object in the array as properties in turn.
//
//    @param    destination            (object)    object to add properties to
//    @param    sourceList            (array)        array of objects with properties to add
//  @return                     (object)    the object after properties have been added to it
//<
isc.addPropertyList = function isc_addPropertyList(destination, sourceList, warnAboutEmptySharedInstanceArrays) {
    // Don't JS error if passed a null destination

    if (destination == null) {
        if (isc.Log) isc.Log.logWarn("Attempt to add properties to a null object. " +
                                     "Creating a new object for the list of properties."

                                     );
        destination = {};
    }

    var methods,
        // detect functions being added as properties.  Doesn't work until after "isA" has
        // initialized
        checkFunctions = (isc.isA != null),
        // get the registry of string methods on the destination object
        registry = (isc.isAn && isc.isAn.Instance(destination) ?
                    destination.getClass()._stringMethodRegistry :
                    destination._stringMethodRegistry);
    if (registry == null) registry = isc.emptyObject;

    var props = destination._isInterface ? isc._getInterfaceProps(destination) : null;

    var undef;
    for (var i = 0, l = sourceList.length; i < l; i++) {

        // add it's properties to the destination
        var source = sourceList[i];
        // if <code>source</code> is null, skip it.
        if (source == null) continue;

        // copy properties from source to destination
        for (var propName in source) {

            var propValue = source[propName];
            // if any of source's properties are functions
            // or any of the source's properties are registered as stringMethods on the
            //          destination object
            // use addMethods to copy these properties



            var propIsAFunction = checkFunctions && isc.isA.Function(propValue);
            // Check for functions / stringMethods as appropriate.

            if (registry[propName] !== undef || propIsAFunction)
            {
                if (methods == null) methods = {};
                methods[propName] = propValue;

            // don't copy an identical property
            // NOTE: unsafe: a subclass may wish to set a property to the same value as the
            //       default for its superclass, and have the subclass value remain unchanged
            //       if the superclass default is changed.
            //} else if (!(source[property] === destination[property])) {
            } else {
                // property is not a function and this slot is not a StringMethod

                // for Interfaces, keep track of all properties added to them
                if (props != null) props[props.length] = propName;

                // check for clobbering a function with a non-function value, eg setting
                // Canvas.enable:false.
                var destinationProp = destination[propName];
                if (!propIsAFunction && destinationProp != null &&
                    isc.isA.Function(destinationProp) && !isc._allowDeleteFuncProperty)
                {
                    if (isc.Log != null) {
                        isc.Log.logWarn("method " + propName + " on " + destination +
                                        " overridden with non-function: '" + propValue + "'");
                    }
                }

                destination[propName] = propValue;

            /*
            } else {

                if (destination.Class && isc.Log &&
                    (!isc.isAn.Instance(destination) ||
                     destination._scPrototype === destination))
                {
                    isc.Log.logWarn("needless override on class: " + destination.Class +
                                    ": " + propName + "->" + propValue);
                }

            */
            }
        }
    }
    if (methods != null) isc.addMethods(destination, methods);
    return destination;
}

//>    @method isc.addMethods()
//
//    Add all named methods from <code>source</code> to <code>destination</code>
//
//    @see addProperties()
//
//    @param    destination    (object)    object to add methods to
//    @param    source        (object)    object to get methods from
//  @return             (object)    the object after methods have been added to it
//
//<
// NOTE: not externally documented since there is essentially no legitimate reason for author
// code to use this instead of Class.addMethods().

isc._$string = "string";
isc._$function = "function";
isc._$constructor = "constructor";
isc._$object = "object";
isc.addGlobal("addMethods", function isc_addMethods(destination, source) {
    if (!destination || !source) return destination;



    var props = destination._isInterface ? isc._getInterfaceProps(destination) : null;

    if (!isc.__remap) isc.__remap = {};

    for (var name in source) {

        if (props != null) props[props.length] = name;
        var method = source[name];

        // if a method was specified as a string or an action-object, see if the
        // destination defines this as a legal string method.
        // NOTE: check typeof object to support Actions, but check non-null because
        // typeof null == "object" and null specified for a method should wipe it out.
        if (isc.isA.instanceMethodsAdded && method != null &&
            (typeof method == isc._$string || typeof method == isc._$object))
        {
            var registry = (isc.isAn.Instance(destination) ?
                                (destination.getClass != null ?
                                    destination.getClass()._stringMethodRegistry : null) :
                            destination._stringMethodRegistry);
            var undef; // check for undefined rather than null
            if (registry && !(registry[name] === undef) &&

                name != isc._$constructor)
            {
                method = isc.Func.expressionToFunction(registry[name], source[name]);
            }
            // XXX If it's not a function or a stringMethod, assume it's ok to add it using the
            // addMethods logic rather than booting back to addProperties
        }

        // If someone's observing this method, the actual method will be stored under a different
        // name
        var observers = destination._observers,
            finalName = (observers != null && observers[name] != null ? isc._obsPrefix + name : name);

        // If the method is already in the correct slot, we're done.
        if (method !== destination[finalName]) {

            if (method != null) {
                //>DEBUG take the opportunity to label the function with a name for debug
                // purposes.
                this._nameMethod(method, name, destination) //<DEBUG




            }

            destination[finalName] = method;

            if (method != null) {



                // if the method was previously assigned an obfuscated name, make sure the function is
                // available under the obfuscated name in the object it's being mixed into
                if (isc.__remap[name]) {
                    // same check for observation applies here
                    var finalObfName = (destination._observers != null &&
                                        destination._observers[isc.__remap[name]] != null ?
                                        isc._obsPrefix + isc.__remap[name] : isc.__remap[name]);
                    destination[finalObfName] = method;
                }
            }
        //} else {
        //    alert("skipped identical assignment in slot: " + finalName + " of " + method);
        }
    }

    return destination;
});

// Function naming
// ---------------------------------------------------------------------------------------
//>DEBUG _nameMethod: labels a function with a name for debug purposes.



isc._allFuncs = []
isc._allFuncs._maxIndex = 0;
isc._funcClasses = new Array(5000);

isc._nameMethod = function isc__nameMethod(method, name, destination) {

    if (typeof method != isc._$function) return;

    // if not being added to a class, just use the property name as the function name
    if (destination.Class == null) return method._name = name;

    // destination is either:
    // - a class Object (eg isc.ListGrid)
    // - an instancePrototype (isc.ListGrid._instancePrototype)
    // - an instance
    // - a handful of other objects on which we've added the Class property, including isc.isA,
    //   ClassFactory, and native prototypes (eg window.Array)


    // only for instance prototypes and class objects, not for instances
    if (isc.isA != null && isc.isA.instanceMethodsAdded &&
        (isc.isAn.InstancePrototype(destination) || isc.isA.ClassObject(destination)))
    {
        var allFuncs = isc._allFuncs;
        // NOTE: functions installed twice, eg interface methods, will appear twice with
        // different classnames, but the first entry will be the one used, so interface methods
        // retain the interface name even when added to other classes.
        allFuncs[allFuncs._maxIndex] = method;
        isc._funcClasses[allFuncs._maxIndex] = destination.Class;
        allFuncs._maxIndex++;
        return;
    }

    // debug: capture all non-Class/Instance methods (eg isA, String extensions, ClassFactory
    // and other bootstrap)
    //if (isc._otherFuncs == null) isc._otherFuncs = [];
    //isc._otherFuncs[isc._otherFuncs.length] = method;

    // special case isA because isA.Class is a method which detects class objects!
    // We need to use a property other than Class for the className.
    var className = (destination == isc.isA ? "isA" : destination.Class);

    method._className = className;


    if (isc[destination.Class] == null) method._name = name;

    if (isc.isA != null && isc.isA.instanceMethodsAdded && isc.isAn.Instance(destination) &&
        !isc.isAn.InstancePrototype(destination))
    {
        // instance methods need to be labelled with their name since we don't want to store a
        // list of instance IDs for function name lookups (it would grow indefinitely)
        method._name = name;
        // this method is an instance-specific override (using an instance as an anonymous
        // class).  Mark it as such.
        method._instanceSpecific = true;
        // if there's already a method on the destination with the same name,
        // this is also an override (as opposed to just a method that was added)
        if (destination[name] != null) method._isOverride = true;
    }
    // XXX Note: we could use a check like the following to detect and label class
    // methods vs instance methods
    // if (ClassFactroy.getClass(destination.Class) === destination) {
}

//<DEBUG










//> @type Object
// An ordinary JavaScript as obtained by "new Object()" or via
// +link{type:ObjectLiteral,Object Literal} syntax.
// <P>
// Methods that return Objects or take Objects as parameters make use of the ability of a
// JavaScript Object to contain an arbitrary set of named properties, without requiring
// declaration in advance.  This capability makes it possible to use a JavaScript Object much
// like a HashMap in Java or .NET, but without the need to call get() or set() to create and
// retrieve properties.
// <P>
// For example if you created an Object using +link{type:ObjectLiteral,Object Literal} syntax
// like so:
// <pre>
//    var request = {
//        actionURL : "/foo.do",
//        showPrompt:false
//    };
// </pre>
// You could then access it's properties like so:
// <pre>
//    var myActionURL = request.actionURL;
//    var myShowPrompt = request.showPrompt;
// </pre>
// .. and you could assign new values to those properties like so:
// <pre>
//    request.actionURL = "<i>newActionURL</i>";
//    request.showPrompt = <i>newShowPromptSetting</i>;
// </pre>
// Note that while JavaScript allows you to get and set properties in this way on any Object,
// SmartClient components require that if a setter or getter exists, it must be called, or no
// action will occur.  For example, if you had a +link{ListGrid} and you wanted to change the
// +link{listGrid.showHeader,showHeader} property:
// <pre>
//     myListGrid.setShowHeader(false); // correct
//     myListGrid.showHeader = false; // incorrect (nothing happens)
// </pre>
// All documented attributes have +link{group:flags,flags} (eg IRW) that indicate when direct
// property access is allowed or not.
//
// @visibility external
//<


// Utility methods for any JavaScript Object
// ---------------------------------------------------------------------------------------

//>    @classMethod isc.getKeys()
//
//    Return all keys (property names) of a given object
//
//    @param    object            (object)    object to get properties from
//    @return                    (Array) String names of all properties.  NOTE: never null
// @visibility external
//<
isc.addGlobal("getKeys", function isc_getKeys(object) {
    var list = [];
    if (object != null) {
        for (var key in object) {
            list[list.length] = key;
        }
    }
    return list;
});

//> @classMethod isc.firstKey()
// Return the first property name in a given Object, according to for..in iteration order.
//
// @param object (Object) Object to get properties from
// @return (String) first property name, or null if Object has no properties
// @visibility external
//<
isc.addGlobal("firstKey", function isc_firstKey(object) {
    for (var key in object) return key;
});

//>    @classMethod isc.getValues()
//
//    Return all values of a given object
//
//    @param    object            (object) object to get properties from
//    @return                    (Array) values of all properties.  NOTE: never null
// @visibility external
//<
isc.addGlobal("getValues", function isc_getValues(object) {
    var list = [];
    if (object != null) {
        for (var key in object) {
            list[list.length] = object[key];
        }
    }
    return list;
});

//> @classMethod isc.sortObject()
// Given a simple javascript object, return that object sorted by keys, such that when iterating
// through the properties of the object, they will show up in sorted order.<br>
// Usage example - may be used to sort a +link{FormItem.valueMap, formItem valueMap} defined
// as an object.
// @param object (object) Object to sort
// @param [comparator] (function) Comparator function to use when sorting the objects keys
// @return (object) sorted version of the object passed in.
// @visibility external
//<
isc.addGlobal("sortObject", function isc_sortObject(object, sortComparator) {
    if (!isc.isA.Object(object)) return object;
    if (isc.isAn.Array(object)) {
        if (sortComparator != null) return object.sort(sortComparator);
        return object.sort();
    }
    var keys = isc.getKeys(object);
    keys = (sortComparator == null ? keys.sort() : keys.sort(sortComparator));
    var sortedObject = {};
    for (var i = 0; i < keys.length; i++) {
        sortedObject[keys[i]] = object[keys[i]];

    }
    return sortedObject
});

//> @classMethod isc.sortObjectByProperties()
// Given a simple javascript object, return that object sorted by properties, such that when
// iterating through the properties of the object, values will show up in sorted order.<br>
// Usage example - may be used to sort a +link{FormItem.valueMap, formItem valueMap} defined
// as an object by display value.
// @param object (object) Object to sort
// @param [comparator] (function) Comparator function to use when sorting the object properties
// @return (object) sorted version of the object passed in.
// @visibility external
//<
isc.addGlobal("sortObjectByProperties", function isc_sortObjectByProperties(object, sortComparator) {
    if (!isc.isA.Object(object)) return object;
    if (isc.isAn.Array(object)) {
        if (sortComparator != null) return object.sort(sortComparator);
        return object.sort();
    }
    var values = isc.getValues(object);
    values = (sortComparator == null ? values.sort() : values.sort(sortComparator));
    var sortedObject = {};

    for (var i = 0; i < values.length; i++) {
        var value = values[i];
        for (var key in object) {
            if (object[key] === value) {
                sortedObject[key] = object[key];
                continue;
            }
        }
    }
    return sortedObject
});

//> @classMethod isc.addDefaults()
//
// Copy any properties that do not already have a value in destination.  Null and zero values
// are not overwritten, but 'undef' values will be.
//
// @param destination (Object) Object to which properties will be added.
// @param source (Object) Object from which properties will be added.
// @return (Object) The destination object is returned.
// @visibility external
//<
isc.addGlobal("addDefaults", function isc_addDefaults(destination, source) {
    if (destination == null) return;
    var undef;
    for (var propName in source) {
        if (destination[propName] === undef) destination[propName] = source[propName];
    }
    return destination;
});


//> @classMethod isc.addDefaultsRecursively()
//
// Copy any properties that do not already have a value in destination.  Null and zero values
// are not overwritten, but 'undef' values will be.  This function operates recursively,
// applying defaults in a "deep" fashion (ie, we recurse into sub-objects and apply defaults
// at the lowest level, rather than applying the original sub-objects to the target object)
//
// @param destination (Object) Object to which properties will be added.
// @param source (Object) Object from which properties will be added.
// @return (Object) The destination object is returned.
// @visibility internal for now
//<
isc.addGlobal("addDefaultsRecursively", function isc_addDefaultsRecursively(destination, source, dupList) {
    if (destination == null) return destination;
    if (source == null || isc.isAn.emptyObject(source)) return destination;

    var undef;

    if (isc.isAn.Array(source)) {
        if (!isc.isAn.Array(destination)) {
            isc.logWarn("Error during addDefaultsRecursively: source is an array but destination " +
                        "is not.  Cannot continue");
            return;
        }
        for (var i = 0; i < source.length; i++) {
            var entry = source[i];
            if (isc.isA.Function(entry)) continue;
            if (isc.isAn.Instance(entry) || isc.isA.Class(entry)) continue;

            if (entry == null || isc.isA.String(entry) || isc.isA.Boolean(entry) ||
                isc.isA.Number(entry))
            {
                if (destination[i] === undef) destination[i] = entry;
            } else if (isc.isA.Date(entry)) {
                if (destination[i] === undef) destination[i] = new Date(entry.getTime());
            } else if (isc.isAn.Object(entry)) {
                if (destination[i] === undef) destination[i] = {};
                if (!isc.isAn.Object(destination[i])) {
                    isc.logWarn("Error during addDefaultsRecursively: entry number " + i +
                                " in the source array is an object, but the existing entry " +
                                i + " in the destination is not an object.  Skipping");
                    continue;
                }
                destination[i] = isc.addDefaultsRecursively(destination[i], entry, dupList);
            }
        }
        return destination;
    }

    var propertiesToSkip = {
        __ref: true,
        __module: true
    };

    if (!dupList) dupList = [];
    if (dupList.contains(source)) {
        destination = source;
        return destination;
    }
    dupList.add(source);

    for (var prop in source) {
        if (isc.isA.Function(source[prop])) continue;
        if (propertiesToSkip[prop] == true) continue;
        if (isc.isAn.Instance(source[prop]) || isc.isA.Class(source[prop])) continue;

        var propValue = source[prop];
        if (isc.isA.Date(propValue)) {
            if (destination[prop] === undef) {
                destination[prop] = propValue.duplicate();
            }
        } else if (isc.isAn.Array(propValue)) {
            if (destination[prop] === undef) destination[prop] = [];
            if (!isc.isAn.Array(destination[prop])) {
                isc.logWarn("Error during addDefaultsRecursively: source property '" +
                            prop + "' is an array, but the target object has an existing " +
                            "property of the same name that is not an array.  Skipping");
                continue;
            }
            if (dupList.contains(propValue)) {
                destination[prop] = propValue;
                continue;
            }
            dupList.add(propValue);
            isc.addDefaultsRecursively(destination[prop], propValue, dupList);
        } else if (isc.isAn.Object(propValue)) {
            if (dupList.contains(propValue)) {
                destination[prop] = propValue;
                continue;
            }
            if (destination[prop] === undef) destination[prop] = {};
            if (!isc.isAn.Object(destination[prop])) {
                isc.logWarn("Error during addDefaultsRecursively: source property '" +
                            prop + "' is a sub-object, but the target object has an existing " +
                            "property of the same name that is not an object.  Skipping");
                continue;
            }
            isc.addDefaultsRecursively(destination[prop], propValue, dupList);
        } else {
            if (destination[prop] === undef) destination[prop] = source[prop];
        }

    }
    return destination;
});


//>    @classMethod isc.propertyDefined()
//
//    Is some property specified on the object passed in?  This will return true if
//  <code>object[propertyName]</code> has ever been set to any value, and not deleted.<br>
//  May return true even if <code>object[propertyName] === undefined</code> if the property
//  is present on the object and has been explicitly set to undefined.
//
// @param object (object) Object to test
// @param propertyName (string) Which property is being tested for?
// @return (boolean) true if property is defined
//  @visibility external
//<
isc.addGlobal("propertyDefined", function isc_propertyDefined(object, propertyName) {
    if (object == null) return false;

    var undef;
    if (object[propertyName] !== undef) return true;


    var properties = isc.getKeys(object);
    return (properties.contains(propertyName));
});

isc.addGlobal("objectsAreEqual", function isc_objectsAreEqual(object1, object2) {
    // match -> return true

    if (object1 === object2) return true;

    else if (isc.isAn.Object(object1) && isc.isAn.Object(object2)) {
        if (isc.isA.Date(object1)) {
            return isc.isA.Date(object2) && (Date.compareDates(object1,object2) == 0);
        } else if (isc.isAn.Array(object1)) {
            if (isc.isAn.Array(object2) && object1.length == object2.length) {
                for (var i = 0; i < object1.length; i++) {
                    if (!isc.objectsAreEqual(object1[i], object2[i])) return false;
                }
                return true;
            }
            return false;
        } else {
            if (isc.isAn.Array(object2)) return false;
            var numProps = 0;
            for (var prop in object1) {
                if (prop == isc.gwtRef || prop == isc.gwtModule) continue;
                if (!isc.objectsAreEqual(object1[prop],object2[prop])) return false;
                numProps ++;
            }
            var numProps2 = 0;
            for (var prop2 in object2) {
                if (prop == isc.gwtRef || prop == isc.gwtModule) continue;
                numProps2++;
                if (numProps2 > numProps) return false;
            }
            if (numProps2 != numProps) return false;

            return true;
        }
    } else {
        return false;
    }
});


// combineObject() - like addProperties() except it handles nested object data structures
// so if an attribute of the source is an object, properties from that object will be
// combined across to the destination, rather than simply clobbering the previous attribute value
// for the field.
// Note the goal here isn't to avoid the destination pointing to the same objects as the source
// (like a duplicate), it's just to merge field values in for nested objects
isc.addGlobal("combineObjects", function isc_combineObjects(destination, source) {
    if (destination == null || !isc.isAn.Object(destination)) return source;
    if (source == null || !isc.isAn.Object(source)) return destination;

    for (var prop in source) {
        var destProp = destination[prop],
            sourceProp = source[prop];
        // If both the source and destination contain simple objects, iterate through the
        // attributes on the source property object and copy them across to the destination property
        // object
        if (isc.isAn.Object(destProp) && !isc.isAn.Array(destProp) && !isc.isA.Date(destProp)
            && isc.isAn.Object(sourceProp) && !isc.isAn.Array(sourceProp) &&
            !isc.isA.Date(sourceProp))
        {
            isc.combineObjects(destProp, sourceProp);
        // Otherwise we can just copy the value across as with standard addProperties
        } else {
            destination[prop] = sourceProp;
        }

    }
});


//> @method isc.applyMask()
// Create a copy of an Object or Array of Objects that has been trimmed to a specified set of
// properties.
// <p>
// <code>mask</code> is the list of properties to return.  Can be an array of strings or an object.
// If an object, the properties returned will be those that are present in the object.  NOTE: this
// includes properties that exist because they've been explicitly set to null.
// <p>
// If no mask is specified, returns a duplicate of the input
// If no inputs are specified, returns an empty object.
//
// @param input   (Object or Array)   object to be masked
// @param mask    (Object or Array)   set of properties to limit output to
//
//<
// NOTE: not external because behavior is a little odd:
// - returns non-null for null input
// - if mask is null and provided an Array, returns an Object instead of a dup'd Array
// we need to check out the framework uses of applyMask and makes sure changing the behavior is
// OK
//
// XXX if applyMask with the input as an empty Array, you will get an empty Array as output.
// So applyMask cannot be used to filter properties that exist on an Array instance.
isc.applyMask = function isc_applyMask(input, mask) {
    var output = {};

    // if no input passed in, return empty output
    if (input == null) return output;

    // if no mask passed in, return all fields from input
    if (mask == null) {
        return isc.addProperties(output, input);
    }

    var inputWasSingle = false;
    if (!isc.isAn.Array(input)) {
        inputWasSingle = true;
        input = [input];
    }

    // convert the mask to an Array of property names if it's an object
    if (!isc.isAn.Array(mask)) mask = isc.getKeys(mask);

    var output = [],
        inputObj, outputObj,
        key, undef;
    for (var i = 0; i < input.length; i++) {
        inputObj = input[i];
        outputObj = output[i] = {};
        // return only the specified properties
        for (var j = 0; j < mask.length; j++) {
            key = mask[j];
            if (inputObj[key] === undef) continue;
            outputObj[key] = inputObj[key];
        }
    }
    return (inputWasSingle ? output[0] : output);
}

isc.getProperties = function isc_getProperties(input, propertyList, output) {
    if (input == null) return null;

    output = output || {};
    if (propertyList == null) return output;
    for (var i = 0; i < propertyList.length; i++) {
        var propName = propertyList[i];
        output[propName] = input[propName];
    }
    return output;
}

isc._digits = {};
isc._floor = Math.floor;
isc._$minus = "-";

for (isc._iterator = 0; isc._iterator < 10; isc._iterator++)
    isc._digits[isc._iterator] = isc._iterator.toString();

isc._fillNumber = function isc__fillNumber(template, number, startSlot, numSlots, nullRemainingSlots) {



    var lastSlot = startSlot + numSlots - 1,
        origNumber = number,
        didntFit = false,
        negative;

    if (number < 0) {
        negative = true;
        number = -number;
        template[startSlot] = this._$minus;
        startSlot += 1;
        numSlots -= 1;
    }

    while (number > 9) {
        // reduce by 10x, round off last digit and subtract to find what it was
        var newNumber = this._floor(number/10),
            lastDigit = number - (newNumber*10);
        // fill slots last first
        template[lastSlot] = this._digits[lastDigit];
        number = newNumber;

        if (lastSlot == (startSlot+1) && number > 9) {
            // number to large for allocated number of slots
            isc.Log.logWarn("fillNumber: number too large: " + origNumber +
                            isc.Log.getStackTrace());
            didntFit = true;
            break;
        }
        lastSlot -= 1;
    }

    if (didntFit) {

        lastSlot = startSlot + numSlots - 1
        template[lastSlot--] = (!negative ? origNumber : -origNumber);
    } else {
        template[lastSlot--] = this._digits[number];
    }

    // null out remaining slots
    for (var i = lastSlot; i >= startSlot; i--) {
        template[i] = null;
    }
};
if (!isc.Browser.isIE || isc.Browser.version > 7) {

    isc._fillNumber = function isc__fillNumber(template, number, startSlot, numSlots, nullRemainingSlots) {
        template[startSlot] = number;
        if (nullRemainingSlots) {
            var endI = startSlot + numSlots;
            for (var i = startSlot + 1; i < endI; ++i) {
                template[i] = null;
            }
        }
    };
}


// try to interpolate different types as a boolean
//
// returns default if value is undefined or null
// returns false if value is
//   - the string "false" or "FALSE"
//   - the number 0
//   - the boolean value false
// otherwise returns true
isc.booleanValue = function isc_booleanValue(value, def) {
    // if the value is unset, return the specified default (so,
    if (value == null) return def;

    if (isc.isA.String(value)) return value != isc._false && value != isc._falseUC;
    return value ? true : false;
}

// isc.objectToLocaleString()
// Centralized, customizable toLocaleString() formatter for objects.
isc.iscToLocaleString = function isc_iscToLocaleString(object) {
    if (object != null) {
        return object.iscToLocaleString ? object.iscToLocaleString() :
                    (object.toLocaleString ? object.toLocaleString() :
                        (object.toString ? object.toString() : isc.emptyString + object));
    }
    return isc.emptyString + object;
}

isc._$toolSkinNames = ["ToolSkin","ToolSkinNative"];

isc.setCurrentSkin = function isc_setCurrentSkin(skinName) {
    // store the current skin so we can detect multiple skins being loaded
    if (isc.currentSkin && !isc._$toolSkinNames.contains(skinName)) {
        isc.logWarn("Detected loading of more than one skin - '" + skinName + "' was loaded " +
            "when '" + isc.currentSkin + "' was already loaded.  See the QuickStart Guide " +
            "for instructions on correctly changing the current skin");
    }
    isc.currentSkin = skinName;
}









//>    @object    isA
//
//    A library of functions for determining the types of other objects.<br><br>
//
//  The "isA" methods for the basic JavaScript types are much faster and more consistent across
//  platforms than JavaScript's "typeof" operator.<br><br>
//
//  An isA method is automatically created for every ISC Class and Interface definition, for
//  example, isA.Canvas().<br><br>
//
//    @example    <code>if (isA.Number(myVariable)) ...</code>
//
//    Note: <code>is</code> and <code>isAn</code> are synonyms of <code>isA</code> and can be used
//            interchangably when it looks better syntactically, eg:
//                <code>if (myObject == null) ...</code>
//            or
//                <code>if (isAn.Array(myObject)) ...</code>
// @treeLocation Client Reference/System
// @visibility external
//<
// create the "isA", "isAn" and "is" objects
isc.addGlobal("isA", {});
isc.addGlobal("isAn", isc.isA);
isc.addGlobal("is", isc.isA);

  //>DEBUG
// give it a class name so that methods added to it get labelled
isc.isA.Class = "isA";
  //<DEBUG

isc.isA.isc = isc.isA; // so you can do isc.isA.isc.Canvas(object)


Function.__nativeType = 1;
Array.__nativeType = 2;
Date.__nativeType = 3;
String.__nativeType = 4;
Number.__nativeType = 5;
Boolean.__nativeType = 6;
RegExp.__nativeType = 7;
Object.__nativeType = 8;



Function.prototype.__nativeType = 1;


// add methods to determine the type of various simple objects
isc.addMethods(isc.isA, {
    useTypeOf : isc.Browser.isMoz || isc.Browser.isSafari,

    //>    @classMethod isA.emptyString()
    //
    //    Is <code>object</code> the empty string?<br><br>
    //
    //    NOTE: if you prefer, you can call this as <code>isAn.emptyString()</code>
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a null string
    //    @visibility external
    //<
    emptyString : function (object) {return isc.isA.String(object) && object == isc.emptyString},


    //>    @classMethod isA.nonemptyString()
    //
    //    Is <code>object</code> a non-empty String?<br><br>
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a non-empty string
    //    @visibility external
    //<
    nonemptyString : function (object) {return isc.isA.String(object) && object != isc.emptyString},


    //>    @classMethod isA.Object()
    // Returns whether the passed value is a non-null Object.
    // <p>
    // Returns false for values that are Numbers, Strings, Booleans, Functions or are null or
    // undefined.
    // <p>
    // Returns true for Object, Array, Regular Expression, Date and other kinds of
    // native objects which are considered to extend from window.Object.
    //
    // @param object (any) value to test for whether it's an object
    // @return (boolean) whether passed value is an Object
    // @visibility external
    //<
    //  With the exception of returning false for the null value, this function's return value
    //  matches the ECMA spec for the typeof operator.  It also seems to be a reasonable expected
    //  implementation of this method as it guarantees the programmer can work with properties of
    //  the object as with a standard Object returned by "new Object()".
    _$object:"object",
    _$String :"String",
    Object : function (object) {
        if (object == null) return false;


        if (isc.Browser.isIE && typeof object == this._$function) return false;


        if (this.useTypeOf) {
            var objType = typeof object;
            return (objType == "object" || objType == "array" || objType == "date" ||

                    (isc.Browser.isMoz && objType == "function" && isc.isA.RegularExpression(object)));
        }

        if (object.constructor && object.constructor.__nativeType != null) {
            var type = object.constructor.__nativeType;
            if (type == 1) {

            } else {
                // Object, RegExp, Date, Array
                return (type == 8 || type == 7 || type == 3 || type == 2);
            }
        }

        // Workaround for a core GWT bug, fixed as of GWT 2.5.
        // http://code.google.com/p/google-web-toolkit/issues/detail?id=4301
        if (object.Class != null && object.Class == this._$String) return false;


        if (typeof object == this._$object) {
            if (isc.Browser.isIE && isc.isA.Function(object)) return false;
            else return true;
        } else return false;
    },

    //>    @classMethod isA.emptyObject()
    //
    // Is <code>object</code> an object with no properties (i.e.: <code>{}</code>)?
    // <P>
    // Note that an object that has properties with null values is considered non-empty, eg
    // <code>{ propName:null }</code> is non-empty.
    // <P>
    // NOTE: if you prefer, you can call this as <code>isAn.emptyObject()</code>
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is the empty object
    //    @visibility external
    //<
    emptyObject : function (object) {
        if (!isc.isAn.Object(object)) return false;
        for (var i in object) {
            // if we have a single property we're non-empty!
            return false;
        }
        return true;
    },

    //>    @classMethod isA.emptyArray()
    //
    // Is <code>object</code> an Array with no items?
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is an empty array
    //    @visibility external
    //<
    emptyArray : function (object) {
        return isc.isAn.Array(object) && object.length == 0;
    },

    //>    @classMethod    isA.String()
    //
    //    Is <code>object</code> a String object?
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a String
    //    @visibility external
    //<
    // ==========================================================================================
    // IMPORTANT: If you update this function, also update its copy in FileLoader.js
    // ==========================================================================================
    String : function (object) {
        if (object == null) return false;


        if (this.useTypeOf) {
            return typeof object == "string" ||
                (object.Class != null && object.Class == this._$String);
        }


        //if (typeof object == this._$function) return false;
        if (object.constructor && object.constructor.__nativeType != null) {
            return object.constructor.__nativeType == 4;
        }

        // Workaround for a core GWT bug
        // http://code.google.com/p/google-web-toolkit/issues/detail?id=4301
        if (object.Class != null && object.Class == this._$String) return true;

        return typeof object == "string";
    },

    //>    @classMethod    isA.Array()
    //
    //    Is <code>object</code> an Array object?<br><br>
    //
    //    NOTE: if you prefer, you can call this as <code>isAn.Array()</code>
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is an Array
    //    @visibility external
    //<
    Array : function (object) {
        if (object == null) return false;


        if (this.useTypeOf && typeof object == "array") return true;


        if (typeof object == this._$function) return false;
        if (object.constructor && object.constructor.__nativeType != null) {
            return object.constructor.__nativeType == 2;
        }



        if (isc.Browser.isSafari) {
            var spliceString = "" + object.splice;
            return (spliceString ==  "function splice() {\n    [native code]\n}" ||
                    spliceString == "(Internal function)");
        }
        return ""+object.constructor == ""+Array;
    },

    //>    @classMethod    isA.Function()
    //
    //    Is <code>object</code> a Function object?
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a Function
    //    @visibility external
    //<
    _$function : "function",
    Function : function (object) {
        if (object == null) return false;


        if (isc.Browser.isIE && typeof object == this._$function) return true;

        // In IE9, attempting to access the "constructor" attribute of a window
        // can lead to an odd crash. If we're passed a native window, return false immediately.

        if (isc.Browser.isIE && (
                (object == window) ||
                (object.document != null && (object.toString != null) &&
                    object.toString().contains("Window") )
            )
           )
        {
            return false;
        }

        var cons = object.constructor;
        if (cons && cons.__nativeType != null) {
            // eliminate known non-functions from an ISC frame
            if (cons.__nativeType != 1) return false;
            // eliminate functions from this frame
            if (cons === Function) return true;

        }


        //if (!object.constructor) isc.Log.logWarn("obj without cons: " + isc.Log.echo(object));
//        isc.logWarn("obj:" + object + "cons:" + isc.emptyString + object.constructor);

        return isc.Browser.isIE ? (isc.emptyString+object.constructor == Function.toString()) :
                                  (typeof object == this._$function);
    },

    //>    @classMethod    isA.Number()
    //
    //    Is <code>object</code> a Number object?<br><br>
    //
    //    NOTE: this returns false if <code>object</code> is an invalid number (<code>isNaN(object) == true</code>)
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a Number
    //    @visibility external
    //<
    Number : function (object) {
        if (object == null) return false;


        if (this.useTypeOf && typeof object == "number") {
            // it's a number, now check if it's a valid number
            return !isNaN(object) &&
                object != Number.POSITIVE_INFINITY &&
                object != Number.NEGATIVE_INFINITY;
        }

        if (object.constructor && object.constructor.__nativeType != null) {
            if (object.constructor.__nativeType != 5) return false;
        } else {
            if (typeof object != "number") return false;
        }
        // it's a number, now check if it's a valid number
        return !isNaN(object) &&
            object != Number.POSITIVE_INFINITY &&
            object != Number.NEGATIVE_INFINITY;
    },

    SpecialNumber : function (object) {
        // NOTE: we do need to first determine if it's a number because isNaN({}) is true
        if (object == null) return false;
        if (object.constructor && object.constructor.__nativeType != null) {
            if (object.constructor.__nativeType != 5) return false;
        } else {
            if (typeof object != "number") return false;
        }
        return (isNaN(object) || object == Number.POSITIVE_INFINITY ||
                object == Number.NEGATIVE_INFINITY);
    },

    //>    @classMethod    isA.Boolean()
    //
    //    Is <code>object</code> a Boolean object?
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a Boolean
    //    @visibility external
    //<
    Boolean    : function (object) {
        if (object == null) return false;
        if (object.constructor && object.constructor.__nativeType != null) {
            return object.constructor.__nativeType == 6;
        }
        return typeof object == "boolean";
    },

    //>    @classMethod    isA.Date()
    //
    //    Is <code>object</code> a Date object?
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a Date
    //    @visibility external
    //<
    Date : function (object) {
        if (object == null) return false;
        if (object.constructor && object.constructor.__nativeType != null) {
            return object.constructor.__nativeType == 3;
        }
        return (""+object.constructor) == (""+Date) &&
                // if the Date constructor is passed a string it doesn't understand, it returns a
                // sort of pseudo date object, which returns bad values from getYear(), etc.
                object.getDate && isc.isA.Number(object.getDate());
    },

    //>    @classMethod    isA.RegularExpression()
    //
    //    Is <code>object</code> a Regular Expression (RegExp) object?
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a Boolean
    //    @visibility external
    //<
    RegularExpression : function (object) {
        if (object == null) return false;
        if (object.constructor && object.constructor.__nativeType != null) {
            return object.constructor.__nativeType == 7;
        }
        return (""+object.constructor) == (""+RegExp);
    },


    _$textXML : "text/xml",
    XMLNode : function (object) {
        if (object == null) return false;
        if (isc.Browser.isIE) {
            return object.specified != null && object.parsed != null &&
                   object.nodeType != null && object.hasChildNodes != null;
        }
        var doc = object.ownerDocument;
        if (doc == null) return false;
        return doc.contentType == this._$textXML;
    },


    // ---------------------------------------------------------------------------------------
    // NOTE: the following few functions are used strictly in expressionToFunction(), are not
    // i18n-safe, and should not be externally visible
    // ---------------------------------------------------------------------------------------

     //> @classMethod isA.AlphaChar()
     //
     //  Is the character passed in an alpha character?
     //
     //  @param  char    (string)        character to test
     //  @return                 (boolean)       true == character is alpha
     //<
     AlphaChar : function (character) {
         // XXX: does not yet deal with unicode characters or extended ASCII characters.
         var code = character.charCodeAt(0);
         return ((code >= 65 &&
                  code <= 90) ||
                 (code >= 97 &&
                  code <= 122))
     },

     //> @classMethod isA.NumChar()
     //
     //  Is the character passed in a Decimal (0-9) character?
     //
     //  @param  char    (string)        character to test
     //  @return                 (boolean)       true == character is a decimal character
     //<
     NumChar : function (character) {
         // XXX: does not yet deal with unicode characters
         var code = character.charCodeAt(0)
         return (code >= 48 &&
                 code <= 57)
     },

     //> @classMethod isA.AlphaNumericChar()
     //
     //  Is the character passed in alphanumeric?
     //
     //  @param  char    (string)        character to test
     //  @return                 (boolean)       true == character is alphanumeric
     //<
     AlphaNumericChar : function (character) {
        return (isc.isA.AlphaChar(character) || isc.isA.NumChar(character))
    },

     //> @classMethod isA.WhitespaceChar()
     //
     //  Is the character passed in a whitespace character?
     //  This method considers any ascii character from 0-32 to be a whitespace character.
     //
     //  @param  char    (string)        character to test
     //  @return                 (boolean)       true == character is a whitespace character
     //<
     WhitespaceChar : function (character) {
         // XXX: does not yet deal with unicode characters
         var code = character.charCodeAt(0)
         return (code >= 0 &&
                code <= 32)
     },

    //>@classMethod isA.color
    //  Is this a valid css color.  Used by the isColor() validator
    //<

    color : function (object) {
        if (!isc.isA.String(object)) return false;

        if (!this._cssColorRegexp) {
            this._cssColorRegexp = new RegExp(
                            // hex:         "#D3D3D3", etc
                            "^(#([\\dA-F]{2}){3}|" +
                            // rgb:         "rgb(255,255,255)", etc.

                                "rgb\\((\\s*[\\d]{1,3}\\s*,\\s*){2}\\s*[\\d]{1,3}\\s*\\)|" +
                            // colorname:   "white", "black", "pink", etc.

                                "[a-z]+)$",

                            // Case insensitive
                            "i"
            );
        }


        return this._cssColorRegexp.test(object);
    },

    // Module Dependencies:
    // ResultSet / ResultTree are both defined as part of the Databinding module but are frequently
    // checked for within grids.
    // Implement default isA functions for these classes so we can check isc.isA.ResultSet() without
    // needing an explicit check for the function being present
    ResultSet : function (data) {
        return false;
    },
    ResultTree : function (data) {
        return false;
    },

    // Overridding isA.className methods:
    // We provide custom isc.isA implementations for the following class names which we don't
    // want to be clobberred when the class method is defined

    _customClassIsA:{
        SelectItem:true,
        Time:true
    },

    // SelectItem IsA Overrides
    // ---------------------------------------------------------------------------------------

    // isc.isA.SelectItem() default implementation would come from the definition of the
    // selectItem class.
    // However we want this method to return true for NativeSelectItems (not a subclass of
    // SelectItem).
    SelectItem : function (item) {
        if (!item || !isc.isA.FormItem(item)) return false;
        var itemClass = item.getClass();
        return (itemClass == isc.SelectItem || itemClass == isc.NativeSelectItem);
    },

    // Support 'isA.SelectOtherItem()' to test for SelectItems or NativeSelectItems where
    // isSelectOther is true.
    SelectOtherItem : function (item) {
        if (!item || !isc.isA.FormItem(item)) return false;
        var itemClass = item.getClass();
        return ((itemClass == isc.SelectItem || itemClass == isc.NativeSelectItem)
                && item.isSelectOther);
    },

    // SmartClient stores Times in JavaScript Date objects so make isA.Time a synonym for isA.Date
    Time : function (object) {
        return isc.isA.Date(object);
    }

});

if (Array.isArray) {
    isc.addMethods(isc.isA, {

        Array : Array.isArray
    });
}


//    @end @object isA






//>    @object    ClassFactory
//
//    Sets up a real inheritance structure for Javascript objects.
//    We separate out class objects from prototypes, so each gets its own inheritance chain.
//    This allows us to set up superclass calls, maintain class vs. instance variables and more!
//
//    The ClassFactory is a singleton object that holds the miscellaneous pieces of our inheritance
//    mechanism.
//
//    Your main interaction with the ClassFactory is to create new classes:
//        <code>ClassFactory.defineClass("MyClass", "mySuperClass");</code>
//
//    @see class:Class
//
//    @visibility external
// @treeLocation Client Reference/System
//<

//
//    create the ClassFactory singleton object
//
//
isc.addGlobal("ClassFactory", {});

  //>DEBUG
// give it a class name so that methods added to it get labelled
isc.ClassFactory.Class = "ClassFactory";
  //<DEBUG

// ClassFactory defines the notion of an "Instance", "ClassObject" and an "Interface".  Add methods
// to isA for recognizing these objects.
isc.addMethods(isc.isA, {
    //>    @classMethod    isA.Instance()
    //
    //    Is <code>object</code> an instance of some class?
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is an instance of some class
    //    @visibility external
    //<
    Instance : function (object) {    return (object != null && object._scPrototype != null)},

    //>    @classMethod    isA.ClassObject()
    //
    //    Is <code>object</code> a class object?
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a Class Object
    //    @visibility external
    //<
    ClassObject : function (object) {    return (object != null && object._isClassObject == true)},

    //>    @classMethod    isA.Interface()
    //
    //    Is <code>object</code> an interface object?
    //
    //    @param    object    (object)    object to test
    //    @return            (boolean)    true == <code>object</code> is a Interface Object
    //    @visibility external
    //<
    Interface : function (object) {    return (object != null && object._isInterface == true)},

    InstancePrototype : function (object) {
        return (isc.isAn.Instance(object) && object._scPrototype == object)
    }
});


isc.isA.instanceMethodsAdded = true;

//
// add methods to the ClassFactory
//
isc.addMethods(isc.ClassFactory, {
    //>    @classMethod    ClassFactory.defineClass()
    //
    // Create a new SmartClient class, which can then be used to create instances of this
    // object type, via +link{Class.create()}.
    // <P>
    // The new Class is returned by <code>defineClass</code>, is available as
    // <code>isc.<i>ClassName</i></code> and is also available in global scope if not in
    // +link{class:isc,portal mode}.  Typically, +link{classMethod:class.addProperties()} is then
    // called to establish different defaults in the new class, or to add methods.  For
    // example:
    // <pre>
    //    isc.defineClass("MyListGrid", "ListGrid").addProperties({
    //        headerHeight : 40, // change default for listGrid.headerHeight
    //
    //        // override listGrid.recordClick
    //        recordClick : function (viewer, record) {
    //           isc.say(record.description);
    //        }
    //    })
    //    isc.MyListGrid.create(); // create an instance of the new class
    // </pre>
    // <P>
    // See also +link{class.Super,Super()} for calling superclass methods.
    // <P>
    // NOTE: <code>isc.defineClass()</code> also creates a new function
    // <code>+link{isA,class:isA}.<i>ClassName()</i></code> object for identifying instances of
    // this Class.
    //
    //    @param    className        (string)    Name for the new class.
    //    @param    [superClass]    (Class)        Optional SuperClass Class object or name
    //    @return                    (Class)        Returns the new Class object.
    //
    //    @visibility external
    //<
    // Internal notes:
    //  Every ClassObject has:
    //  {
    //     Class : [string className],
    //     _isClassObject : true,
    //     _instancePrototype : [instance prototype for class],
    //
    //     _superClass : [pointer to superClass ClassObject (if this class is not a root class)]
    //
    //     _subClassConstructor : [constructor function that creates subclass ClassObjects]
    //  }
    //
    //  Every InstancePrototype (and Instance) has:
    //  {
    //     Class : [string className]
    //     _instanceConstructor : [constructor function that creates instances]
    //     _classObject : [ClassObject for this class]
    //    ._scPrototype : [the instance prototype (this same object)]
    //  }
    defineClass : function (className, superClass, interfaces, suppressSimpleNames) {
        return this._defineNonRootClass(className, superClass, interfaces, null, suppressSimpleNames);
    },

    //>    @classMethod    ClassFactory.overwriteClass()
    //
    // Intentionally clobber an existing SmartClient Class, if it already exists.  Works
    // identically to +link{ClassFactory.defineClass}, except that no warning is logged to the
    // console.
    //
    // @visibility external
    //<
    overwriteClass : function (className, superClass, interfaces, suppressSimpleNames) {
        return this._defineNonRootClass(className, superClass, interfaces, null, suppressSimpleNames, true);
    },

    //>    @classMethod    ClassFactory.defineInterface()
    //
    //    An "Interface" is an API definition plus a skeletal implementation of that API.
    //
    //  Interfaces are "mixed in" to another class in order to allow the target class to "support"
    //  the interface.  Interfaces typically require the target class to provide one or two core
    //  methods, and then the interface itself provides the many convenience methods and method
    //  variations that can be written in terms of the core methods.
    //
    //  For example, a List interface could require only get(index) and getLength() from the target
    //  class, and could provide getRange(), indexOf() and other standard List operations.  If the
    //  target class has a more efficient way of supporting getRange() than the generic
    //  implementation in the List interface, the target class can directly implement getRange(),
    //  and the target class' version of getRange() takes precedence.
    //
    //  Comparison to other languages:
    //  - in Java, an "interface" is just an API definition, with no implementation.  The SmartClient
    //    notion of interfaces is closer to an "abstract class", except that in Java you can only
    //    inherit from one abstract class, whereas in SmartClient you can mixin as many Interfaces
    //    as you want.  Also, in SmartClient an Interface can contain both instance and class (aka
    //    "static") methods.
    //  - in Ruby, a Mix-in module corresponds exactly to the SmartClient Interface concept.
    //
    //  Writing Interfaces:
    //  - If you are writing an interface and want to indicate that a method must be implemented in
    //      the target class in order for your interface to work, use addMethods to add a method with
    //      the special value ClassFactory.TARGET_IMPLEMENTS.  If the target class does not
    //      implement the method and it gets called, an error will be logged.
    //  - you can subclass an interface to create another interface, but you can't use Super to
    //      call superclass methods within the interface inheritance chain
    //  - you can define a special initInterface method and it will be called just prior to the
    //    init method on the class that the interface is mixed into
    //  - you can define a special destroyInterface method and it will be called by the destroy
    //    method on the class that the interface is mixed into.  Note that unlike other
    //    languages, javascript does not have a concept of a destructor.  You have to
    //    explicitly call destroy() in order for this logic to run.  But in many cases you
    //    don't have to worry about this because Canvas subclasses cascade the destroy() call
    //    automatically to all children/members/etc.
    //    - if you declare a method in an interface, and mix the interface into a class, you can't
    //      call Super() and get the interface method -- the one you place in your instance will
    //      override the one from the interface.
    //
    //      To make this work, you have to create an intermediate class, then subclass that.  Eg:
    //
    //        CF.defineInterface("face1");
    //        face1.addMethods({ foo:function() {} });
    //
    //        CF.defineClass("class1");
    //        CF.mixInInterface("class1", "face1");
    //
    //        class1.addMethods({
    //            foo : function () {
    //                // NOTE: a Super() call here will NOT go to the face1.foo method
    //            }
    //        })
    //
    //        CF.defineClass("class2", "class1");
    //        class2.addMethods({
    //            foo : function () {
    //                // NOTE: a Super() call WOULD go to the face1.foo method
    //                //             (assuming class1.foo was not present)
    //            }
    //        })
    //
    //<
    defineInterface : function (className, superClass) {
        return this._defineNonRootClass(className, superClass, null, true);
    },

    //>    @classMethod    ClassFactory.defineRootClass()
    //
    //     Variant of defineClass for creating a root class (a class with no superclass).
    //
    //    @param    className        (string)    Name for the new class
    //<
    defineRootClass : function (className) {
        return this._defineClass(className, null);
    },

    //>    @classMethod    ClassFactory._defineNonRootClass()
    //
    //  Define a class or interface which is assumed not to be a root class, that is, either the
    //  superclass must be valid or there must be a valid ClassFactory.defaultSuperClass.
    //<
    _defineNonRootClass : function (className, superClass, interfaces, asInterface, suppressSimpleNames, overwrite) {
        // if no superClass was specified, use the default rootClass
        superClass = (superClass || isc.ClassFactory.defaultSuperClass);
        // if we didn't find a superClass, something went wrong -- bail
        if (!superClass) {
            //>DEBUG
            isc.Log.logWarn("isc.ClassFactory.defineClass(" + className + ") called with null"
                        + " superClass and no ClassFactory.defaultRootClass is defined.");
            //<DEBUG
            return null;
        }
        //If the super class is a framework class, then the child should also be marked as a framework class
        isc.overridingFrameworkClass = isc.isA.ClassObject(superClass) && superClass.isFrameworkClass;
        return this._defineClass(className, superClass, interfaces, asInterface, suppressSimpleNames, overwrite);
    },


    _$Set: "Set",
    _$Window: "Window",
    _$Selection: "Selection",
    _$DataView: "DataView",
    _ignoredGlobalOverrides: {},
    _$simpleNamesWarning: "\nThis conflict would be avoided by disabling " +
                          "ISC Simple Names mode.  See documentation for " +
                          "further information.",
    _installIgnoredGlobalOverrides : function () {
        var browser = isc.Browser,
            ignored = this._ignoredGlobalOverrides;

        if (browser.isChrome || browser.isIE || browser.isMoz || browser.isSafari) {
            ignored[this._$Set]       = true;
            ignored[this._$Window]    = true;
            ignored[this._$Selection] = true;
            ignored[this._$DataView]  = true;
        }
    },

    //>    @classMethod    ClassFactory._defineClass()
    //
    // Internal method to actually create a class or interface.  <code>superclass</code> must
    // already be valid.
    //<
    _$iscPrefix: "isc.",
    _classTimes: {},
    _defineClass : function (className, superClass, interfaces, asInterface, suppressSimpleNames, overwrite)
    {


        // Accept superClasses defined as strings rather than references to the class object
        superClass = this.getClass(superClass);

        var definingFramework = (isc.definingFramework == true || isc.overridingFrameworkClass == true);


        if (!definingFramework && superClass && superClass._vbOnly && !isc.isVisualBuilderSDK) {
            var hasDefaultSuperClass = !!(isc.ClassFactory.defaultSuperClass);

            var errorMsg = "The framework class " + superClass.getClassName() + " is only available for subclassing if " +
                "isc.licenseType is \"Enterprise\" or \"Eval\".  " +
                (hasDefaultSuperClass ? "Continuing with the default super class." :
                "Returning null as there is no ClassFactory.defaultSuperClass specified.");

            isc.logWarn(errorMsg);
            if (!superClass._vbOnlyWarning) {
                // Only present an alert once per superclass
                superClass._vbOnlyWarning = true;
                isc.warn(errorMsg);
            }

            if (hasDefaultSuperClass) {
                superClass = this.getClass(isc.ClassFactory.defaultSuperClass);
            } else {
                return null;
            }
        }

        // If we have an ID collision, and the caller didn't pass true for the "overwrite"
        // param, warn the user before clobbering the existing object
        var existingObject, inISCSpace,
            ignoreGlobalOverride = this._ignoredGlobalOverrides[className],
            useSimpleNames = (isc._useSimpleNames && !suppressSimpleNames);
        existingObject = isc[className];
        if (existingObject != null) inISCSpace = true
        else if (useSimpleNames && !ignoreGlobalOverride)  {
            existingObject = window[className];
        }

        if (existingObject != null

            && className != "IButton"
            && overwrite != true
            // don't warn if a framework component schema is overridden ("componentSchema" flag is
            // automatically set by LoadSystemSchemaTag).  Without this check, we get warnings at VB
            // startup when eg the VisualBuilder class clobbers the VisualBuilder component schema.
            // Component Schema don't really need to be globals as framework code always looks them up
            // with DataSource.get().
            && !(isc.isA.DataSource(existingObject) && existingObject.componentSchema)
            )
        {

            var errorString = "New Class ID: '" + className + "' collides with ID of existing " +
                                // NOTE: this check is required in case there is a collision on
                                // window.Class.  At that moment, isc.isA.Class is not a
                                // function, but the String "isA"
                                (isc.isA && isc.isA.Function(isc.isA.Class) && isc.isA.Class(existingObject) ?
                                    "Class object '" :
                                    "object with value '") +
                                existingObject + "'.  Existing object will be replaced.";
            if (!inISCSpace) errorString += this._$simpleNamesWarning;

            // Note: If the Log class hasn't loaded yet, we don't warn about this collision.
            // This should be ok in almost every case as Log loads early during the smartClient
            // libs, but if this proves to be an issue, we could hang onto the error string and
            // wait until after Log has loaded to log a warning.
            if (window.isc.Log) isc.Log.logWarn(errorString);
        }

        // create a new instance of the superClass to use as a prototype for this new class
        //    note: instancePrototype.init() is deliberately not called here
        var instancePrototype =
            (superClass ? new superClass._instancePrototype._instanceConstructor() : {});

        // create the class object for the new class: an object whose lookup pointer is the
        // superclass' ClassObject.
        var classObject = this._makeSubClass(superClass);

        // a constructor function that creates objects whose lookup pointer will be
        // instancePrototype.  These created objects are instances of "subClass"
        instancePrototype._instanceConstructor =
                this._getConstructorFunction(instancePrototype, className);

        // setup the class object
        classObject.Class = className;
        classObject._isClassObject = true;

        // Is this a core ISC class (defined during standard SmartClient init) or is this
        // a class added after the SC libraries have been loaded?
        // Useful for debugging / AutoTest locator APIs

        if (definingFramework) classObject.isFrameworkClass = true;
        else classObject.isFrameworkClass = false;
        if (!classObject.isFrameworkClass) {
            var scClass = superClass;
            while (scClass && !scClass.isFrameworkClass) {
                scClass = scClass.getSuperClass();
            }
            if (scClass) classObject._scClass = scClass.Class;
        }

        if (!classObject._scClass) classObject._scClass = classObject.Class;

        // NOTE: important that we always assign _isInterface so that concrete subclasses of
        // interfaces have _isInterface:false
        classObject._isInterface = instancePrototype._isInterface = !!asInterface;
        classObject._superClass = superClass;
        // crosslink the instance prototype and class object
        classObject._instancePrototype = instancePrototype;

        // setup the instance prototype: these properties appear on all instances
        instancePrototype.Class = className;
        // crosslink the instance prototype and class object
        instancePrototype._classObject = classObject;
        // this exists mostly so that instances can reference their prototype
        instancePrototype._scPrototype = instancePrototype;

        // copy the scClass information across too
        instancePrototype.isFrameworkClass = classObject.isFrameworkClass;
        instancePrototype._scClass = classObject._scClass;

        // put all Classes in the special "isc" object
        isc[className] = classObject;
        // if we're in simple names mode (eg, not worried about name collisions), make the class
        // available as a global variable
        if (useSimpleNames) {
            if (ignoreGlobalOverride) {
                var success = this.tryBindingGlobalID(window, className, classObject);
                if (!success && window.isc.Log) {
                    isc.Log.logWarn("We expected to override global " + className +
                                    " without any trouble, but were unable to replace it." +
                                    this._$simpleNamesWarning);
                }
            } else window[className] = classObject;
        }

        this.classList[this.classList.length] = className

        // create a function in the isA singleton object to tell if an object is an instance of
        // this Class, eg, isA.ListGrid()
        // Exception - the _customClassIsA object is used to track cases where isc.isA has
        // already been given a custom method which we don't want to clobber
        if (!(isc.isA._customClassIsA[className] && isc.isA[className])) {
            isc.isA[className] = this.makeIsAFunc(className);
        }

        // as a convenience, mix in a list of interfaces as part of the class definition
        if (interfaces != null) {
            if (!isc.isAn.Array(interfaces)) interfaces = [interfaces];
            for (var i = 0; i < interfaces.length; i++) {
                //alert("Mixing " + interfaces[i] + " into " + className);
                this.mixInInterface(className, interfaces[i]);
            }
        }

        return classObject;
    },


    makeIsAFunc : function (className) {


        return function (object) {
            if (object == null || object.isA == null || object.ns == null || object.ns.isA == null || object.isA === object.ns.isA) {
                return false;
            }
            return object.isA(className);
        };
    },

    // make a class object for a new subclass of superClass
    _makeSubClass : function (superClass) {
        if (!superClass) return {};

        // get the superClass' subclass constructor.  The subclass constructor creates objects
        // whose lookup pointer will be superClass.  It is created on the fly the first time a
        // class acquires a subclass (otherwise all leaf classes would have unnecessary
        // subclass constructors)
        var superSuperClass = superClass._superClass,
            subClassConstructor = superClass._subClassConstructor;
        if (!
            // if the superClass already has a subClassConstructor that differs from the
            // super-super class, use it
            (subClassConstructor &&
             (superSuperClass == null ||
              subClassConstructor !== superSuperClass._subClassConstructor))
            )
        {
            // otherwise we make it
            subClassConstructor = superClass._subClassConstructor =
                    this._getConstructorFunction(superClass, (superClass.Class || "unknown") + "Class");
        }
        return new subClassConstructor();
    },

    //>    @classMethod    ClassFactory.getClass()
    //
    //    Given a class name, return a pointer to the Class object for that class
    //
    //    @param    className    (string)    name of a class
    //    @return                (Class)        Class object, or null if not found
    //    @visibility external
    //<
    getClass : function (className, warnOnFailure) {
        // if it's a string, assume it's a className
        if (isc.isA.String(className)) {
            // see if isc[className] holds a ClassObject or an SGWTFactory
            var classObject = isc[className];
            if (classObject) {
                if (isc.isA.ClassObject(classObject)) return classObject;
                // SGWTFactory might not be defined yet ...
                if (isc.isA.SGWTFactoryObject && isc.isA.SGWTFactoryObject(classObject)) return classObject;
            }
        }
        // if it's a class object or an SGWTFactory, just return it
        if (isc.isA.ClassObject(className)) return className;
        // SGWTFactory might not be defined yet ...
        if (isc.isA.SGWTFactoryObject && isc.isA.SGWTFactoryObject(className)) return className;

        // if it's an instance of some class, return the class object for the class
        if (isc.isAn.Instance(className)) return className._classObject;
        if (isc.Log && warnOnFailure) {
            isc.Log.logWarn("ClassFactory.getClass() couldn't find class: " + className +
                            "; defined classes are: " + this.classList.sort());
        }
        return null;
    },

    //>    @classMethod    ClassFactory.newInstance
    //
    // Given the name of a class, create an instance of that class.
    //
    //        @param    className    (string)        Name of a class.
    //                            (ClassObject)    Actual class object to use.
    //        @param    [props]        (object)        Properties to apply to the instance.
    //        @param    [props2]    (object)        More properties to apply to the instance.
    //        @param    [props3]    (object)        Yet more properties to apply to the instance.
    //
    //    @return                (class)        Pointer to the new class.
    //    @visibility external
    //<
    // NOTE: ability to pass _constructor not documented until we have a more reasonable name for
    // this property.
    newInstance : function (className, props, props2, props3, props4, props5) {

        var classObject = this.getClass(className);

        // if we didn't get a classObject from getClass above,
        // and the first parameter is an object,
        // see if any of the properties objects passed have a ._constructor property,
        // which we'll treat as the classname
        if (classObject == null && isc.isAn.Object(className)) {

            var cons;
            for (var i = 0; i < arguments.length; i++) {
                var propsObj = arguments[i];
                // Note: ._constructor is used rather than .constructor to resolve a
                // number of JS issues, as constructor is present by default on native
                // JS objects.
                // In the long run we want to rename this to something more elegant, like 'class'
                // and modify the css class-specific code to look for 'style' or 'baseStyle' rather
                // than className (or even getClass()).
                if (propsObj != null && propsObj._constructor != null)
                {
                    cons = propsObj._constructor;
                }
            }

            // now fix up the props objects to include the first object
            //    as a set of properties instead of just the class name
            props5 = props4;
            props4 = props3;
            props3 = props2;
            props2 = props;
            props = className;

            className = cons;

            // Safari and Mozilla both JS Error if the 'constructor' property set to a string
            // (typically because a user is trying to specify the className to use. (it's ok in IE)
            // Note: the 'constructor' property exists as a native function on a number of standard
            // JS objects, so we can't just check for constructor == null
            if (isc.isA.String(props.constructor)) {
                // If we don't yet have a constructor className, make use of this property - then
                // log a warning and remove it.
                if (className == null) className = props.constructor;
                isc.Log.logWarn("ClassFactory.newInstance() passed an object with illegal 'constructor' " +
                             "property - removing this property from the final object. " +
                             "To avoid seeing this message in the future, " +
                             "specify the object's class using '_constructor'.", "ClassFactory");
                props.constructor = null;
            }

            classObject = this.getClass(cons);
        }

        if (classObject == null) {
            //>DEBUG
            isc.Log.logWarn("newInstance(" + className + "): class not found", "ClassFactory");
            if (isc.isA.String(className) && className.contains(".")) {
                isc.Log.logWarn("Did you make the SmartGWT class reflectable? See http://www.smartclient.com/smartgwt/javadoc/com/smartgwt/client/docs/Reflection.html", "ClassFactory");
            }
            //<DEBUG
            return null;
        }

        return classObject.newInstance(props, props2, props3, props4, props5);
    },

    //>    @classMethod    ClassFactory._getConstructorFunction
    //
    //    Given a <code>prototype</code> object, create a new constructor function that will
    //    reference this prototype.  This allows us to say <code>new constructor()</code> to
    //    create a new object that is effectively a subclass of the original <code>prototype</code>.
    //
    //    @param    proto    (object)    Object to use as the prototype for new objects.
    //    @param    [className]    (identifier)    Name of the class.
    //    @return            (function)    Function that can be used to create new objects
    //                                based on the prototype.
    //<
    _getConstructorFunction : function (proto, className) {
        //!OBFUSCATEOK

        var cons;

        if (isc.Browser.isSafari) {
            cons = function () {};
        } else {

            cons = new Function();
        }
        cons.prototype = proto;
        return cons;
    },

    tryBindingGlobalID : function (wd, id, object) {
        try {
            wd[id] = object;
        } catch (e) {
            return false;
        }
        // attempting to override some keywords (for example window.document) will not
        // throw an error but simply fail to pick up the new value - catch this case as
        // well
        if (wd[id] != object) {
            return false;
        }
        return true;
    },

    //>    @classMethod    ClassFactory.addGlobalID()
    //
    // Given an <code>object</code>, declare a unique global variable and link it to object so
    // object can be addressed in the global scope.<br><br>
    // <P>
    // If the object already has an 'ID' property, it will be used. Note that if you pass an
    // object.ID, it's up to you to ensure it is unique in the global scope. If window[<i>ID</i>]
    // is already assigned to something else a warning will be logged using the developer console,
    // and the existing reference will be replaced.
    // <P>
    // If the object does not have an explicitly specified ID property already, one will be
    // automatically generated. Note that automatically generated global IDs may be reused if
    // the instance they originally referenced has been +link{Class.destroy(),destroyed}.
    //
    //    @param    object    (object)    Object to add global ID to.
    //<
    _reservedWords: {
        toolbar:true,
        parent:true,
        window:true,
        top:true,
        opener:true,
        event:true // due to window.event in IE
    },

    addGlobalID : function (object, ID, dontWarn) {
        // if an ID was passed, use that
        object.ID = ID || object.ID;

        var wd = this.getWindow();

        // in keepGlobals mode only certain objects are allowed to actually keep their declared
        // global IDs.  Anything else is given the declared global ID temporarily, then retains
        // only its auto-generated global ID after the eval ends.
        if (isc.keepGlobals && object.ID != null) {
            if (!isc.keepGlobals.contains(object.ID) &&
                !(isc.DataSource && isc.isA.DataSource(object)))
            {
                var tempID = object._localId = object.ID;
                object.ID = null;
                isc.globalsSnapshot[tempID] = wd[tempID];
                wd[tempID] = object;
                // track temporary globals with auto-assigned IDs so IDs can be released later
                if (object._autoAssignedID) {
                    var className = object.AUTOIDClass || object.Class;

                    isc.autoAssignedTempGlobals[tempID] = className;
                }
            }
        }

        if (object.ID == null) {
            object.ID = this.getNextGlobalID(object);
            object._autoAssignedID = true;
        }


        if (isc._loadingComponentXML && isc.createLevel == 1) {
            object._screenEligible = true;
        }

        // if the ID is already taken, log a warning
        var isKeyword, checkForKeyword;
        if (wd[object.ID] != null) {
            var instance = isc.isA.BaseWidget(wd[object.ID]);
            if (!(isc.isA.DataSource(wd[object.ID]) && wd[object.ID].componentSchema)) {

                if (!dontWarn) {


                    var widgetCollisionString =
                        "ID '{0}' collides with ID of existing widget '{1}'. The pre-existing widget will be destroyed.";
                    var otherCollisionString =
                        "ID '{0}' for object '{1}' collides with the ID of an existing object. This can occur when the " +
                        "specified ID for a new SmartClient Canvas is the same as a native attribute of 'window', or " +
                        "another variable already assigned in global scope. The global reference to this object will be replaced. " +
                        "Consider instead using a different ID to avoid this collision altogether, especially if the colliding " +
                        "ID is a native attribute of window.  Replacing such objects often has serious and " +
                        "unintended consequences. In this case, the current value of window['{0}'] is: \n\n {2} \n ";

                    var errorString = instance ? widgetCollisionString : otherCollisionString;

                    isc.Log.logWarn(String.format(errorString, object.ID, object, isc.echoAll(wd[object.ID])));

                }
            }
            if (instance) {
                if (!isc.isA.ClassObject(wd[object.ID])) wd[object.ID].destroy();
            }
            // If the attribute is not a pointer to a widget instance it may be a
            // a reserved browser keyword or native window attribute which may be non overrideable.
            // Catch the cases we know about (stored in an explicit list)
            // Otherwise use a try...catch block when assigning the property to ensure we don't
            // crash

            if (!instance) {
                if (this._reservedWords[object.ID]) isKeyword = true;
                else                          checkForKeyword = true;
            }
        }

        // now assign the object under that ID globally so anyone can call it
        if (!isKeyword) {
            if (checkForKeyword) {
                if (!this.tryBindingGlobalID(wd, object.ID, object)) isKeyword = true
            } else {
                wd[object.ID] = object;
            }
        }
        // simple mechanism for instrumenting globals capture.  Simply set isc.globalsSnapshot to an
        // array and we'll fill it here.

        if (isc.globalsSnapshot) {
            if (isc.isAn.Array(isc.globalsSnapshot)) {
                // just store all globals that are established
                isc.globalsSnapshot.add(object.ID);
            } else {
                // store a mapping from new globals to original value to allow them to be
                // restored
                isc.globalsSnapshot[object.ID] = wd[object.ID];
            }
        }

        // refuse to use keywords and log a warning
        if (isKeyword) {
            var newID = this.getNextGlobalID(object);
            isc.logWarn("ClassFactory.addGlobalID: ID specified as:"+  object.ID +
                         ". This is a reserved word in Javascript or a native property of the" +
                         " browser window object and can not be used as an ID." +
                         " Setting ID to " + newID + " instead.");
            object.ID = newID;
            object._autoAssignedID = true;
            wd[object.ID] = object;
        }

    },

    _$isc_OID_ : "isc_OID_",
    _$isc_ : "isc_",
    _$underscore : "_",
    _joinBuffer : [],
    _perClassIDs:{},

    getNextGlobalID : function (object) {
        var classString;
        if (object != null && (object.AUTOIDClass != null || object.Class != null)) {
            classString = object.AUTOIDClass || object.Class;
        }
        return this.getNextGlobalIDForClass(classString);
    },
    getNextGlobalIDForClass : function (classString) {
        if (classString) {
            var freed = this._freedGlobalIDs[classString];
            if (freed && freed.length > 0) {
                var ID = freed[freed.length-1];
                freed.length = freed.length-1;
                return ID;
            }
            var idCount;
            if (this._perClassIDs[classString] == null) this._perClassIDs[classString] = 0;
            idCount = this._perClassIDs[classString]++;

            var buffer = this._joinBuffer;
            buffer[0] = this._$isc_;
            buffer[1] = classString;
            buffer[2] = this._$underscore;
            isc._fillNumber(buffer, idCount, 3,5);

            var result = buffer.join(isc.emptyString);
            return result;
        }
        return this._$isc_OID_ + this._globalObjectID++;
    },
    // dereferenceGlobalID()
    // - frees the window[ID] pointer to an object
    // - allows the global ID to be re-used within this page
    dereferenceGlobalID : function (object) {
        // remove the window.ID pointer to the object.
        // NOTE: don't destroy the global variable if it no longer points to this widget
        // (this might happen if you create a new widget with the same ID)
        if (window[object.ID] == object) {

            if (!isc.Browser.isIE || isc.Browser.isIE9) {
                try {
                    delete window[object.ID];
                } catch (e) {
                    isc.logWarn("ClassFactory.dereferenceGlobalID(): Failed to delete the '" +
                                object.ID + "' global.");
                }
                if (window[object.ID] != null) window[object.ID] = null;
            } else {
                window[object.ID] = null;
            }

            // update globals capture data structure

            if (isc.globalsSnapshot) {
                if (isc.isAn.Array(isc.globalsSnapshot)) isc.globalsSnapshot.remove(object.ID);
                else                                     delete isc.globalsSnapshot[object.ID];
            }

            if (object._autoAssignedID && (object.AUTOIDClass != null || object.Class != null)) {
                this.releaseGlobalID(object.AUTOIDClass || object.Class, object.ID);
            }

            // Don't actually delete the object.ID property - This method is typically called
            // as part of destroy() and if for some reason we have a pointer to a destroyed object
            // it's helpful to know the ID for debugging.
        }
    },

    // Maintain a pool of global IDs that are no longer in use due to destroy() calls
    // and reuse them rather than creating new IDs where possible


    // GlobalIDs are of the form isc_ClassName_int (isc_StaticTextItem_24, etc)
    // We maintain a cache of previously used global IDs indexed by className, set up each time we
    // call dereferenceGlobalID(). Then autoAssignGlobalID() can re-use IDs from the cache for
    // the appropriate object className
    reuseGlobalIDs:true,
    globalIDClassPoolSize:1000,
    _freedGlobalIDs:{
    },
    releaseGlobalID : function (className, ID) {

        if (!this.reuseGlobalIDs) return;
        var freed = this._freedGlobalIDs[className];
        if (!freed) this._freedGlobalIDs[className] = [ID];
        else if (freed.length <= this.globalIDClassPoolSize) {
            if (!freed.contains(ID)) freed[freed.length] = ID;
        }
    },

    _domIDCount:0,
    _$isc_:"isc_",
    _simpleDOMIDTemplate:[null, "_", null],

    // DOM ID Cacheing logic

    // Maintain a cache of generated DOM ID strings that are no longer in use and re-use them when
    // we need a new arbitrary DOM ID.
    // Canvii may notify us when DOM IDs are no longer in use by calling releaseDOMID()
    // Behavior may be disabled by setting reuseDOMIDs to false
    // Note that reuseDOMIDs may also be set to false on individual Canvii - see
    // Canvas._releaseDOMIDs
    reuseDOMIDs:false,
    DOMIDPoolSize:10000,
    _freedDOMIDs:[],
    releaseDOMID : function (ID) {
        if (!this.reuseDOMIDs || this._freedDOMIDs.length > this.DOMIDPoolSize) return;
        this._freedDOMIDs[this._freedDOMIDs.length] = ID;
    },

    // getDOMID() - return a unique string to be used as a DOM Id.
    //
    // Has 2 modes:
    // If isc._longDOMIds is false (production mode), the returned IDs are arbitrary short
    // strings
    // If isc._longDOMIds is true (development mode), the IDs will be generated based on the
    // ID and suffix passed into this method - useful for debugging as the DOM IDs obviously relate
    // to the canvases that created them.
    getDOMID  : function (ID, suffix) {

        // By default we return a unique but uninformative ID like "isc_1A"

        if (!isc._longDOMIds || !ID || !suffix) {

            // by preference we'll reuse a DOM ID we know has been freed
            var freedIDs = this._freedDOMIDs.length;
            if (freedIDs > 0) {
                var ID = this._freedDOMIDs[freedIDs-1];
                this._freedDOMIDs.length = freedIDs-1;
                return ID;
            }

            var number = this._domIDCount++;
            return this._convertToBase36(number, this._$isc_);
        }



        // In simpleDOMIDMode, create an ID that incorporates the ID / suffix passed to us
        // We're making an assumption that the ID / suffix passed in is already unique

        this._simpleDOMIDTemplate[0] = ID;
        this._simpleDOMIDTemplate[2] = suffix;
        return this._simpleDOMIDTemplate.join(isc.emptyString);
    },

    _base36Digits:["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K",
                   "L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"],
    _base36Arr:[],
    _convertToBase36 : function (number, prefix) {
        var digits = this._base36Digits,
            resultsArr = this._base36Arr;

        resultsArr.length = 0;

        // We use this to prefix with "isc_"
        if (prefix) resultsArr[0] = prefix;

        var totalDigits = 3;

        if (number > 46655) {
            while (Math.pow(36,totalDigits) <= number) totalDigits += 1;
        }

        // convert number to base 36
        while (number >= 36) {
            var remainder = number % 36;
            // always add to the end slot, so we get 100 rather than 001
            resultsArr[totalDigits-(prefix ? 0 : 1)] = digits[remainder];
            totalDigits -=1;

            number = Math.floor(number / 36);
        }
        resultsArr[totalDigits-(prefix ? 0 : 1)] = digits[number];

        return resultsArr.join(isc.emptyString);

    },

    //>    @classMethod    ClassFactory.mixInInterface()    (A)
    //
    // Add the methods of a given Interface to a Class so the class implements the methods.
    // If the class has already defined a method with the same name as the one specified
    // in the interface, the class' method will be retained.
    //
    //    @param    className        (String)    Name of the Class to add methods to.
    //    @param    interfaceName    (String)    Name of the Interface to get methods from.
    //<
    mixInInterface : function (className, interfaceName) {
        var theInterface = this.getClass(interfaceName),
            theClass = this.getClass(className)
        ;
        if (!theInterface || !theClass) return null;

        if (!theInterface._isInterface) {
            //>DEBUG
            isc.Log.logWarn("ClassFactory.mixInInterface asked to mixin a class which was not"
                        + " declared as an Interface: "+interfaceName+ " onto "+className);
            //<DEBUG
            return;
        }

        // mark the class as implementing the interface
        if (!theClass._implements) theClass._implements = [];
        // ensure the interface doesn't apply to a superClass
        else theClass._implements = theClass._implements.duplicate();

        // install all properties and methods added to this interface, and any superInterfaces
        while (theInterface) {
            // mix in class properties and methods
            this._mixInProperties(theInterface, theClass, true);
            // mix in instance properties and methods
            this._mixInProperties(theInterface, theClass);

            theClass._implements[theClass._implements.length] = interfaceName;

            theInterface = theInterface.getSuperClass();
            if (theInterface && !theInterface._isInterface) break;
        }
    },

    _initInterfaceMethodName: "initInterface",
    _destroyInterfaceMethodName: "destroyInterface",
    _mixInProperties : function (source, destination, asClassProperties) {
        var props,
             destinationClass = destination
        ;
        if (asClassProperties) {
            props = isc._interfaceClassProps[source.Class];
        } else {
            props = isc._interfaceInstanceProps[source.Class];
            source = source.getPrototype();
            destination = destination.getPrototype();
        }

        if (props == null) return;

        for (var i = 0; i < props.length; i++) {
            var propName = props[i];

            // skip any properties already defined in the target
            if (destination[propName] != null) continue;

            var propValue = source[propName];

            // the interface declared that the target class must implement a method, and it's not
            // there
            if (isc.isA.String(propValue) && propValue == this.TARGET_IMPLEMENTS) {
                //>DEBUG
                var message = (asClassProperties ? "Class" : "Instance") + " method "
                    + propName + " of Interface " + source.Class + " must be implemented by "
                    + "class " + destination.Class;
                // Don't complain about interface methods not being implemented b/c it's
                // perfectly normal to mix in interfaces before adding properties to the
                // class.  In fact that may be the case most of the time b/c showing the
                // interfaces at class definition is very useful
                // (e.g: defineClass("Foo", "Bar", "SomeInterface")
                //
                //isc.Log.logWarn(message + ", is not yet implemented");

                // but it will be an error if this method is ever called, so install a function
                // that will complain
                destination[propName] = function () {
                    this.logError(message);
                };
                //<DEBUG
            } else if (propName == this._initInterfaceMethodName && !asClassProperties) {
                // patch any initInterface() methods onto a special array on the classObject to
                // be called at class creation.
                if (destinationClass._initInterfaceMethods == null) destinationClass._initInterfaceMethods = [];
                destinationClass._initInterfaceMethods[destinationClass._initInterfaceMethods.length] = propValue;
            } else if (propName == this._destroyInterfaceMethodName && !asClassProperties) {
                // patch any destroyInterface() methods onto a special array on the classObject to
                // be called at class destruction.
                if (destinationClass._destroyInterfaceMethods == null) destinationClass._destroyInterfaceMethods = [];
                destinationClass._destroyInterfaceMethods[destinationClass._destroyInterfaceMethods.length] = propValue;
            } else {
                //isc.Log.logWarn("adding property " + propName +
                //                " from interface " + source.Class);
                destination[propName] = propValue;
            }
        }
    },

    //>    @classMethod    ClassFactory.makePassthroughMethods()    (A)
    //
    // Create methods that call through to a related object stored under property
    // <code>propName</code>.  This enables easy implementation of the Delegate design
    // pattern, where one object implements part of its APIs by having another object respond
    // to them.
    //
    //    @param    methodNames    (array of strings)    list of methods names
    //    @param    propName    (string)            Property name where the target object is stored.
    //<
    _$argList : "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p",
    makePassthroughMethods : function (methodNames, propName, addNullCheck, nullCheckWarning,
                                       inheritedProperty)
    {
        if (!propName) propName = "parentElement";

        var funcTemplate;
        if (!addNullCheck) {
            funcTemplate = this._funcTemplate;
            if (funcTemplate == null) {
                funcTemplate = this._funcTemplate = ["return this.",,".",,"("+this._$argList+")"];
            }
        } else {
            funcTemplate = this._nullCheckFuncTemplate;
            if (funcTemplate == null) {
                funcTemplate = this._nullCheckFuncTemplate =
                    ["if(this.",,"==null){\n",
                     ,// optionally log a warning
                     "return;}\n",,"return this.",,".",,"("+this._$argList+")"];
            }
        }

        var methods = {};

        for (var i = 0; i < methodNames.length; i++) {
            var methodName = methodNames[i];

            // create a function that routes a function call to the target object
            if (addNullCheck) {
                funcTemplate[1] = propName;
                if (nullCheckWarning != null) {
                    var messageArgs = {
                        methodName:methodName,
                        propName:propName
                    };
                    var warning = nullCheckWarning.evalDynamicString(this, messageArgs);

                    funcTemplate[3] = "isc.logWarn(\"" + warning + "\");";
                }
                if (inheritedProperty != null) {
                    funcTemplate[5] = "this." + propName + "." + inheritedProperty + "=" +
                                      "this." +                  inheritedProperty + ";\n";
                }
                funcTemplate[7] = propName;
                funcTemplate[9] = methodName;

            } else {
                funcTemplate[1] = propName;
                funcTemplate[3] = methodName;
            }
            methods[methodName] =
                isc._makeFunction(this._$argList, funcTemplate.join(isc.emptyString));
        }

        return methods;
    },

    //>    @classMethod    ClassFactory.writePassthroughFunctions()    (A)
    //
    // Install methods in <code>destinationClass</code> which will call the same-named function
    // on a related object stored under the property name <code>memberName</code> on instances
    // of <code>destinationClass</code>.
    //
    //    @example    <code>ClassFactory.writePassthroughFunctions(
    //                    ListGrid, "selection", ["select","selectAll",..."]
    //                );</code>
    //
    //                after this, you can call
    //                    listGrid.selectRecord()
    //                rather than
    //                    listGrid.selection.selectRecord()
    //<
    writePassthroughFunctions : function (destinationClass, memberName, methodNames) {
        var methods = this.makePassthroughMethods(methodNames, memberName);
        destinationClass.addMethods(methods);
    }

});    // END isc.addMethods(isc.ClassFactory)

//
// add properties to the ClassFactory object
//
isc.addProperties(isc.ClassFactory, {
    // when defining interfaces, use this constant as a marker value indicating that a method
    // must be implemented by any class your interface is mixed in to
    TARGET_IMPLEMENTS : "TARGET_IMPLEMENTS",

    //>    @attr    ClassFactory.defaultSuperClass  (Class : null : [IA])
    // Class to use as the default superClass if none is specified
    //<

    // Counter which is used to generate unique object IDs
    _globalObjectID : 0,

    // Classes created with ClassFactory.defineClass
    classList : []
});

//> @classMethod isc.defineClass
// Shortcut for <code>isc.ClassFactory.defineClass()</code>.
// @include classMethod:ClassFactory.defineClass
// @see ClassFactory.defineClass()
// @visibility external
//<
isc.defineClass = function (className, superClass, interfaces, suppressSimpleName) {
    return isc.ClassFactory.defineClass(className, superClass, interfaces, suppressSimpleName);
}

//> @classMethod isc.overwriteClass
// Shortcut for <code>isc.ClassFactory.overwriteClass()</code>.
// @include classMethod:ClassFactory.overwriteClass
// @see ClassFactory.overwriteClass()
// @visibility external
//<
isc.overwriteClass = function (className, superClass, interfaces, suppressSimpleName) {
    return isc.ClassFactory.overwriteClass(className, superClass, interfaces, suppressSimpleName);
}

isc.defineInterface = function (className, superClass) {
    return isc.ClassFactory.defineInterface(className, superClass);
}

//> @type SCClassName
// Name of a SmartClient Class, that is, a Class that has been created via
// +link{classMethod:isc.defineClass()}, including Classes built into SmartClient, such as "ListGrid".
//
// @visibility external
//<

isc.defer = function (code) {
    var lastClass = isc.ClassFactory.getClass(isc.ClassFactory.classList.last(), true),
        existingCode = lastClass._deferredCode;
    isc.Log.logDebug("deferred code being placed on class: " + lastClass);
    // first time
    if (!existingCode) lastClass._deferredCode = [code];
    // more times
    else existingCode.add(code);
}

// install names that are expected to collide
isc.ClassFactory._installIgnoredGlobalOverrides();





if (!isc.Browser.isSafari) {
    isc._window = window;
    isc._document = window.document;
}


if (window.isc_enableCrossWindowCallbacks && isc.Browser.isIE) {
   isc.enableCrossWindowCallbacks = true;
   Object._window = window;
}



//>    @class    Class
//
// The Class object is root of the Isomorphic SmartClient inheritance tree -- it includes
// functionality for creating instances, adding methods and properties, getting prototypes,
// etc.<br><br>
//
// To add functionality to ALL classes, add them to Class.<br><br>
//
// To create a Class, call <code>ClassFactory.defineClass("MyClass", "MySuperClass")</code>
// <P>
// <code>defineClass</code> will return the created class, and make it available as
// <code>isc.MyClass</code>, and as the global variable <code>MyClass</code> if not in
// +link{class:isc,portal mode}.
// <P>
// You can then:
// <UL>
//        <LI>add class-level (static) properties and methods to the class:
//                <code>MyClass.addClassProperties()</code>
//            these methods and properties are accessed through the Class variable itself, eg:
//                <code>MyClass.someStaticMethod()</code> or <code>MyClass.someStaticProperty</code>
//
//        <LI>add default instance properties and methods to the class:
//                <code>MyClass.addProperties()</code>
//            these methods and properties are accessed through a class instance, eg:
//                <code>var myInstance = MyClass.create();</code>
//                <code>myInstance.someInstanceMethod()</code>
//
//        <LI>create new instances of this class:
//                <code>var myInstance = MyClass.create()</code>
// </UL>
// NOTE: as a convention, all class names begin with a capital letter and all instances begin
// with a lower case letter.
//
//  @treeLocation Client Reference/System
//    @visibility external
//<
isc.ClassFactory.defineRootClass('Class');

//
// set Class as the default superclass for classes defined by ClassFactory.defineClass()
//
isc.ClassFactory.defaultSuperClass = isc.Class;

//
//    add static methods to all classes defined with our system
//
//    call on the Class object itself, as:   Class.method()
//

//  First we install the methods that allow us to addMethods to a class as a method call on the
//  class (eg Class.addClassMethods(methods) rather than addMethods(Class, methods);.
isc.addMethods(isc.Class, {

    //>    @classMethod    Class.addClassMethods()
    //
    //    Add static (Class-level) methods to this object.<br><br>
    //
    //    These methods can then be called as MyClass.method().  The value for "this" will be the
    //    class object for the class.
    //
    //    @param    [arguments 0-N] (object)    objects with methods to add (think named parameters).
    //                                        all the methods of each argument will be applied
    //                                        as class-level methods.
    //    @visibility internal
    //<

    addClassMethods : function () {
        for (var i = 0; i < arguments.length; i++)
            isc.addMethods(this, arguments[i]);
    }


});

isc.Class.addClassMethods({

    //>    @classMethod Class.create()
    //
    // Create an instance of this class.
    // <P>
    // All arguments passed to this method are passed on to the +link{Class.init()} instance
    // method.  Unless +link{class.addPropertiesOnCreate} is set to <code>false</code>, all
    // arguments passed to this method must be Objects and all properties on those
    // objects will be copied to the newly created instance before +link{Class.init()} is
    // called.  If there are overlapping properties in the passed arguments, the last wins.
    // <p>
    // Any return value from +link{Class.init()} is thrown away.
    // <p>
    // Note: Generally, you would not override this method.  If you want to specify a
    // constructor for your class, provide an override for +link{Class.init()} for generic
    // classes or +link{canvas.initWidget()} for any subclasses of UI components
    // (i.e. descendants of +link{Canvas}).
    //
    //    @param    [arguments 0-N]    (any)
    //      Any arguments passed will be passed along to the init() routine of the instance.
    //      Unless +link{class.addPropertiesOnCreate} is set to false, any arguments passed to
    //      this method must be of type Object.
    //    @return                     (object)
    //      New instance of this class, whose init() routine has already been called
    //
    //    @example    <code>var myInstance = MyClass.create()</code>
    //  @example    create
    //    @visibility external
    //<
    create : function (A,B,C,D,E,F,G,H,I,J,K,L,M) {
        var newInstance = this.createRaw();

        if (newInstance != null) {
            newInstance = newInstance.completeCreation(A,B,C,D,E,F,G,H,I,J,K,L,M);
        }

        // return the new instance
        return newInstance
    },




    _initializedClasses : {},
    createRaw : function () {

        if (this._vbOnly && !isc.isVisualBuilderSDK) {
            var errorMsg = "Attempt to create " + this.getClassName() + ".  This class requires the " +
                           "Dashboards & Tools framework which is only included with Enterprise " +
                           "licenses.";
            isc.logWarn(errorMsg);
            if (!this._vbOnlyWarning) {
                // Only present alert once per class
                try {
                    isc.warn(errorMsg);
                    this._vbOnlyWarning = true;
                } catch (e) {
                    // ignore: possible crash when attempting to show a dialog before <body>
                    // tag is written on page
                }
            }

            return null;
        }

        if (!this.initialized()) this.init();

        // create a new instance based on the class's instancePrototype

        var newInstance = new this._instancePrototype._instanceConstructor();

        // install the appropriate namespace on the instance
        newInstance.ns = this.ns;

        return newInstance;
    },

    // class-level init
    init : function () {
        //!OBFUSCATEOK
        //this.logWarn("uninitialized class");

        // init superclass chain
        var superClass = this.getSuperClass();
        if (superClass != null && !superClass.initialized()) superClass.init();

        // execute any deferred class definition
        var deferredCode = this._deferredCode;
        if (deferredCode != null) {
            //this.logWarn("eval'ing deferred code");
            this._deferredCode = null;

            var captureDefaults = isc.captureDefaults;
            if (captureDefaults) isc.captureDefaults = false;

            deferredCode.map(function (expression) {
                //!OBFUSCATEOK
                isc.eval(expression);
            });

            if (captureDefaults) isc.captureDefaults = true;
        }



        if (this.autoDupMethods) {
            isc.Class.duplicateMethods(this, this.autoDupMethods);
        }

        this._initializedClasses[this.Class] = true;
    },

    //> @classMethod Class.modifyFrameworkStart()
    // Notifies the SmartClient Class system that any new classes created, or changes made
    // to existing classes should be treated as part of the framework. This ensures that
    // +link{Class.isFrameworkClass} will be set to true on any classes defined after this
    // method call, until +link{Class.modifyFrameworkDone()} is called.
    // <P>
    // Developers may call this method before applying changes which should be considered
    // part of the core framework, rather than application code, for example in <i>load_skin.js</i>
    // files. When changes are complete, +link{modifyFrameworkDone()} should be called.
    // Note that this is an alternative approach to calling +link{markAsFrameworkClass()}
    // directly on specific classes.
    //
    // @visibility external
    //<
    modifyFrameworkStart : function () {
        isc.definingFramework = true;
    },

    //> @classMethod Class.modifyFrameworkDone()
    // Notifies the SmartClient Class system that the developer is done making changes
    // to the SmartClient framework (as originally indicated by a call to
    // +link{modifyFrameworkStart()}).
    // <P>
    // New classes created or changes made to existing classes after this method call
    // will be considered application code. This ensures that
    // +link{Class.isFrameworkClass} will not be set to true on Classes defined after
    // this method call.
    // @visibility external
    //<
    modifyFrameworkDone : function () {
        isc.definingFramework = false;
    },

    // to get around native browser limitations with stack traces being unable to proceed
    // through recursively called methods, create duplicates of certain key functions on every
    // class and instance.

    duplicateMethods : function (target, methodNames) {
        // skip certain ultralight classes
        if (target.Class && this.dontDup[target.Class]) return;

        for (var i = 0; i < methodNames.length; i++) {
            var methodName = methodNames[i];

            this.duplicateMethod(methodName, target);
        }
    },
    duplicateMethod : function (methodName, target) {
        if (!target) target = this;

        var method = target[methodName];

        if (method == null) return;

        // avoid duplicating a duplicate, which would force Super() to follow multiple
        // _originalMethod links to discover the true original method.
        if (method._originalMethod) {
            while (method._originalMethod) method = method._originalMethod;
            //this.logWarn("double dup: " + methodName + " on target: " + target);
        }

        //!DONTOBFUSCATE
        var dup;
        if (method.toSource == null) { // IE, Safari
            dup = eval("dup = " + method.toString());
        } else {
            dup = eval(method.toSource());
        }

        // figure out the method's name
        if (!method._fullName) isc.Func.getName(method, true);
            /*
            name = (isc.isA.ClassObject(target) ? "[c]" : "") +
                    (target.Class ? target.Class : "") +
                    "." + methodName + "[d]";
            */
        dup._fullName = method._fullName + "[d]";

        // to allow Super() to do correct comparisons with superclass implementations
        dup._originalMethod = method;

        target[methodName] = dup;

        return dup;
    },
    dontDup : {
        StringBuffer : true,
        Action : true,
        MathFunction : true,
        JSONEncoder : true
    },
    // class-level auto-dups
    //autoDupMethods: [ "fireCallback" ],

    _createUnsupportedMethodImpl : function (messageTemplate, methodName) {
        // Closure variable to keep track of whether this unsupported method was called before
        // (by class name).
        var alreadyLoggedWarningForClass = {};

        var newMethod = function () {
            var className = this.getClassName();

            if (alreadyLoggedWarningForClass[className]) return;

            var message = messageTemplate.replace(/(\$?)\$(class|method)/g, function (match, p1, p2, offset, messageTemplate) {
                if (p1 === "$") return "$" + p2;
                else if (p2 === "class") return className;
                else if (p2 === "method") return methodName;


            });

            this.logWarn(message);
            alreadyLoggedWarningForClass[className] = true;


        };
        newMethod._isUnsupportedMethod = true;

        // Copy the argString of the original method.
        var origMethod = this._instancePrototype[methodName];
        if (isc.isA.Function(origMethod)) {
            newMethod._argString = isc.Func.getArgString(origMethod);
        }

        return newMethod;
    },

    //> @classMethod class.markUnsupportedMethods() (A)
    // Replaces each of the methods named in <code>methodNames</code> with a new implementation
    // that simply logs a warning the first time the method is called, and nothing else. This can
    // be used to mark methods of derived classes which do not support certain parent class
    // methods as unsupported.
    // <p>
    // The <code>messageTemplate</code> parameter is a template for the warning message logged
    // when the unsupported method is first called. The following variables in the template
    // are substituted as follows:
    // <table border="1">
    // <tr>
    //   <th>Variable</th>
    //   <th>Substitution</th>
    // </tr>
    // <tr>
    //   <td><code>$class</code></td>
    //   <td>The +link{getClassName(),class name}.</td>
    // </tr>
    // <tr>
    //   <td><code>$method</code></td>
    //   <td>The name of the method.</td>
    // </tr>
    // </table>
    // <p>
    // If you want the literal string of a substitution variable to appear in the warning message,
    // you can escape it by prefixing with a dollar sign. For example, to include "$class" in the
    // warning message, use "$$class" in the template.
    // @param [messageTemplate] (String) template for the warning message logged when first called.
    // If null, the default template string "$class does not support the $method() method." is used.
    // @param methodNames (Array of identifier) the method names to mark as unsupported.
    // @see Class.isMethodSupported()
    // @visibility external
    //<
    markUnsupportedMethods : function (messageTemplate, methodNames) {
        if (messageTemplate == null) messageTemplate = "$class does not support the $method() method.";
        for (var i = 0; i < methodNames.length; ++i) {
            var methodName = methodNames[i];
            this._instancePrototype[methodName] = this._createUnsupportedMethodImpl(messageTemplate, methodName);
        }
    },

    //> @classMethod class.isMethodSupported() (A)
    // Returns true if the method is supported by this class, meaning that it is not null and
    // was not replaced by +link{Class.markUnsupportedMethods()}.
    // @param methodName (identifier) the name of a method to test.
    // @return (boolean) true if the method is not null and is not an unsupported method; false otherwise.
    // @visibility external
    //<
    isMethodSupported : function (methodName) {
        var method = this._instancePrototype[methodName];
        return method != null && !method._isUnsupportedMethod;
    },

    isMethodUnsupported : function (methodName) {
        return !this.isMethodSupported(methodName);
    },

    // NOTE: we have to use a structure like this instead of just checking a property on the
    // class object (eg this._initialized) because any property would be inherited from
    // superclass class objects.
    initialized : function () { return this._initializedClasses[this.Class] },

    //>    @classMethod Class.getClassName()
    //
    //    Gets the name of this class as a string.
    //
    //    @return (string)    name of the class
    //    @visibility external
    //<
    getClassName : function () {
        return this.Class;
    },

    //> @classMethod Class.getScClassName()
    //
    //  Gets the name of this class as a string, if the class is a SmartClient Framework class.
    //  Otherwise, gets the name of the SmartClient Framework class which this class extends.
    //
    //  @return (string) name of the SmartClient Framework class
    //<
    getScClassName : function () {
        return this.isFrameworkClass ? this.Class : this._scClass;
    },

    //> @classMethod Class.compareScClassName()
    //
    // Compares the scClassName supplied with that of the of the class instance.
    // Useful in writing code such as:
    //     canvasList.findAll(isc.Class.compareScClassName, "Button")
    //
    // @return (boolean) whether instance has the supplied scClassName
    //<
    compareScClassName : function (instance, scClassName) {
        return instance.getScClassName() == scClassName;
    },

    //>    @classMethod Class.getSuperClass()
    //
    //    Gets a pointer to the superClass' Class object.
    //
    //    @return (Class)        Class object for superclass.
    //    @visibility external
    //<
    getSuperClass : function () {
        return this._superClass;
    },

    //>    @classMethod Class.getPrototype
    //
    //    Gets a pointer to the prototype object for this class.
    //
    //    This is the object that you should install methods/properties into
    //    to have them apply to each instance.  Generally, you should use
    //    +link{Class.addProperties()} to do this
    //    rather than affecting the prototype directly
    //
    //    @return    (object)    Prototype for all objects instances.
    //<
    // NOTE: not external because customers shouldn't muck with the prototype directly
    getPrototype : function () {
        return this._instancePrototype;
    },

    //> @classMethod Class.addMethods()
    //
    // Helper method for adding method definitions to all instances of this class.<P>
    //
    // The added methods can be called as myInstance.method().<P>
    //
    // Functionally equivalent to +link{class.addProperties}, which works with both properties
    // and methods.
    //
    // @param [arguments 0-N] (object) objects with methods to add (think named parameters).
    //                                  all the methods of each argument will be applied
    //                                  as instance-level methods.
    // @return (object) the class after methods have been added to it
    // @visibility external
    //<

    addMethods : function () {
        if (this._isInterface) {
            this.logWarn("Use addInterfaceMethods() to add methods to interface " + this);
        }
        for (var i = 0; i < arguments.length; i++)
            isc.addMethods(this._instancePrototype, arguments[i]);
        return this._instancePrototype;
    },

    addInterfaceMethods : function () {
        for (var i = 0; i < arguments.length; i++)
            isc.addMethods(this._instancePrototype, arguments[i]);
    },
    addInterfaceProperties : function () {
        isc.addPropertyList(this._instancePrototype, arguments, true);
    },


    //>    @classMethod Class.registerStringMethods()
    //
    //    Register a method, or set of methods, that can be provided to instances of this class as
    //    Strings (containing a JavaScript expression) and will be automatically converted into
    //    functions.
    //  <p>
    //  For example:
    //  <pre>
    //  isc.MyClass.registerStringMethods({
    //      myStringMethod: "arg1, arg2"
    //  });
    //  </pre>
    //
    //    @param    methodName (object)        If this is a string, name of the property to register
    //                                  If this is an object, assume passing in a set of name/value
    //                                  pairs to register
    //  @param  argumentString (string) named arguments for the property in a comma separated string
    //                                  (not used if methodName is an object)
    // @see group:stringMethods
    //    @visibility external
    //<
    registerStringMethods : function (methodName, argumentString) {

        // If we haven't already done so, override the method argument registry
        // from the super class (otherwise we'll affect other classes with our changes)
        var registry = this._stringMethodRegistry;
        if (!this.isOverridden("_stringMethodRegistry")) {

            //if (registry._entries != null) {
            //    this.logWarn("Methods being registered on: " + this.Class +
            //                 " causing copy of superclass " + this._superClass.Class +
            //                 " registry");
            //}
            var registryClone = {},
                entries = registryClone._entries = (registry._entries ?
                                                    registry._entries.duplicate() : []);
            for (var i = 0; i < entries.length; i++) {
                registryClone[entries[i]] = registry[entries[i]];
            }
            this._stringMethodRegistry = registry = registryClone;
        }

        // If it's an object, rather than a string, assume it's a list of multiple methodName
        // to argument mappings to register at once.
        if (!isc.isA.String(methodName)) {
            var newMethods = methodName;

            // if it's not an object, bail - we don't know how to deal with this
            if (!isc.isAn.Object(newMethods)) {
                this.logWarn("registerStringMethods() called with a bad argument: " +
                             methodName);
                return false;
            }

            for (var methodName in newMethods) {
                registry[methodName] = newMethods[methodName]
                registry._entries.add(methodName);
            }

        } else {
            // in the registry, the distinction between null and undefined is important.
            // If the second parameter is currently undefined, set it to null
            // (this allows the second param. to be optional).
            if (argumentString == null) argumentString = null;

            registry[methodName] = argumentString;
            registry._entries.add(methodName);
        }

        // return true for success
        return true;
    },

    //> @classMethod Class.registerDupProperties() [A]
    // A common requirement in SmartClient development is to the ability have an attribute
    // be set to a "standard" type of object or array for every instance of a class.
    // <P>
    // An example might be a special subclass of TabSet which always shows a particular set
    // of tabs.<br>
    // In this case the most convenient approach would be to simply call
    // <P>
    // <code>setProperties({  tabs: <i>[array of standard tab object]</i> });</code>
    // <P>
    // However the developer does not want each instance he creates to point to <b>the same</b>
    // array of objects - instead each instance should have a separate array containing separate
    // objects with the same set of standard attributes.
    // <P>
    // This method provides an easy way to handle this case. By calling
    // +link{registerDupProperties()} the developer is notifying a class that every time
    // a new instance is generated via a call to +link{Class.create()}, the attribute
    // in question should be cloned onto the generated instance.
    // <P>
    // The <code>AutoChild</code> subsystem also respects registered properties for duplication.
    // When +link{class.addAutoChild()} or +link{class.createAutoChild()} is called, if
    // a property is set in the <code><i>autoChild</i>Defaults</code> block for the auto child,
    // that property will be cloned onto the instance rather than copied over by reference if
    // it's registered as a property for duplication via this method.
    // <P>
    // NOTE: This subsystem will only handle cloning simple javascript objects and arrays.
    // If an attribute name has been registered via this method, calling
    // <code>addProperties()</code> on the class object and passing in a live SmartClient
    // widget is not supported. If you need a standard SmartClient component to show up
    // in a class we recommend you use the +link{group:autoChildUsage,AutoChild subsystem} to
    // define a constructor and defaults for the widget and then set the attribute to
    // <code>"autoChild:<i>&lt;autoChildName&gt;</i>"</code>.
    //
    // @param attributeName (string)
    //    attribute name to register for duplication on instance creation for this class
    // @param [subAttributes] (Array of string)
    //    This parameter allows targetted support for deeper cloning.
    //    The issue is that for some attributes - for example sectionStack.sections, we know
    //    certain properties will also need cloning (sectionStack section.items).
    //    We want to use 'shallowClone()' to duplicate the objects on init rather than clone
    //    as clone is dangerous and can lead to stack overflow errors if the target happens
    //    to point to certain objects.
    //    Therefore allow developers to register properties of an attr value to also be
    //    cloned.
    //    To use this feature a developer would pass in an array of sub-properties
    //    as a second param (EG registerDupProperties("sections", ["items"]);
    // @visibility dupProperties
    //<
    registerDupProperties : function (attributeName, subAttributes) {


        if (this._dupAttrs == null || this._dupAttrs._className != this.getClassName()) {
            if (this._dupAttrs != null) {
                var dupAttrs = this._dupAttrs;
                this._dupAttrs = this._dupAttrs.duplicate();
                if (dupAttrs._subAttrs != null) {
                    this._dupAttrs._subAttrs = isc.shallowClone(dupAttrs._subAttrs);
                }
            } else {
                this._dupAttrs = [];
            }

            this._dupAttrs._className = this.getClassName();
        }
        if (!this._dupAttrs.contains(attributeName)) {
            this._dupAttrs.add(attributeName);
        }

        // support targetted deep-cloning.
        // (See JS Doc for subAttributes param)
        //
        // When given a sub attribute to explicitly dup, store it directly on the
        // registered dupAttrs array in an object of the format:
        // {attributeName:[ Array of sub attributes for cloning ] }
        if (subAttributes != null) {

            //this.logWarn("sub attribute! " + subAttr);

            var dupSubAttrs = this._dupAttrs._subAttrs || {};
            dupSubAttrs[attributeName] = subAttributes;

            this._dupAttrs._subAttrs = dupSubAttrs;
        }

    },

    //> @classMethod Class.isDupProperty()
    // Returns true if the specified attribute was registered as a property for duplication
    // at the instance level via +link{Class.registerDupProperties()}
    // @param attributeName
    // @visibility dupProperties
    //<
    isDupProperty : function (attributeName) {
        return this._dupAttrs != null && this._dupAttrs.contains(attributeName);
    },

    cloneDupPropertyValue : function (attributeName, value) {

        // We want to warn if the property is set to a Canvas instance which we can't readily
        // clone.
        // Explicitly catch arrays and run each entry through this method to also warn in the
        // case where we have an array containing live canvii.


        if (isc.isA.Array(value)) {
            var newArr = [];
            for (var i = 0; i < value.length; i++) {
                newArr[i] = this.cloneDupPropertyValue(attributeName, value[i]);
            }
            return newArr;
        }

        if (isc.Canvas && isc.isA.Canvas(value)) {
            this.logWarn("Default value for property '" + attributeName
                + "' is set to a live Canvas (with ID '"+value.getID()+"') at the Class or AutoChild-defaults level. "
                + "SmartClient cannot clone a live widget, so each instance of this "
                + "class may end up pointing to the same live component. "
                + "To avoid unpredictable behavior and suppress this warning, use the "
                + "AutoChild subsystem to set up re-usable default properties for sub-components.");
            return value;
        }

        var clonedVal = isc.shallowClone(value);

        // Support also cloning certain attribute values - see 'subAttrs' param of
        // registerDupProperties
        var dupArr = this._dupAttrs;
        if (dupArr._subAttrs != null && dupArr._subAttrs[attributeName] != null &&
            clonedVal != null)
        {
            //this.logWarn("iteratin?:" + dupArr._subAttrs[attributeName]);

            for (var i = 0; i < dupArr._subAttrs[attributeName].length; i++) {
                var subAttrName = dupArr._subAttrs[attributeName][i];
                //this.logWarn("Name:" + subAttrName + ", val:" + clonedVal[subAttrName]);
                if (clonedVal[subAttrName] != null) {
                    clonedVal[subAttrName] = isc.shallowClone(clonedVal[subAttrName]);
                }
            }
        }
        return clonedVal;
    },



    //>    @classMethod Class.evaluate()
    // Evaluate a string of script and return the result.
    // <P>
    // This method is a wrapper around the native javascript method <code>eval()</code>. It
    // papers over some native issues to ensure evaluation of script behaves consistently across
    // browsers
    //
    // @param expression (string) the expression to be evaluated
    // @param evalArgs (object) Optional mapping of argument names to values - each key will
    //      be available as a local variable when the script is executed.
    // @return (any) the result of the eval
    // @visibility external
    //<

    evaluate : function (expression, evalArgs, globalScope, hiddenIFrameEval, strictJSON, reviverFunction) {
        //!OBFUSCATEOK


        if (strictJSON) {
            //this.logWarn("is strict");
            return this.parseStrictJSON(expression, reviverFunction);
        }

        // Set a flag so we know an eval is executing

        if (!isc._evalRunning) isc._evalRunning = 0;
        isc._evalRunning ++;
        var returnVal;

        if (hiddenIFrameEval && isc.Browser.isIE && !globalScope && isc.Page.isLoaded()) {

            returnVal = this.evalInIFrame(expression, evalArgs);
        } else {
            //this.logWarn("args and stuff");


            if (evalArgs) {
                with (evalArgs) {
                    if (globalScope) returnVal = window.eval(expression)
                    else returnVal = eval(expression);
                }
            } else {
                if (globalScope) returnVal = window.eval(expression)
                else returnVal = eval(expression);
            }
        }

        // Decrement / clear the evalRunning flag

        if (isc._evalRunning != null) isc._evalRunning --;
        if (isc._evalRunning == 0) delete isc._evalRunning;
        return returnVal;
    },


    parseStrictJSON : function (script, reviverFunction, suppressNativeMethod, allowLoose) {

        var parseFunc;
        if (suppressNativeMethod || allowLoose || !isc.Browser._supportsJSONObject) {
            parseFunc = this.getJSONParseFunc();
        } else {
            parseFunc = window.JSON.parse;
        }
        return parseFunc(script, reviverFunction, allowLoose);
    },


    // Helper - create a JSON parsing function for browsers that don't natively
    // have support for JSON.parse
    // Note that this has the same restrictions on format as true JSON.parse() - otherwise
    // we'd have browser inconsistency over whether strict JSON response format was
    // required. We also will need to use the "reviver" function if specified to handle
    // custom conversions.
    _cx:/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,


    useHiddenFrameInJSONParseFunction:true,
    getJSONParseFunc : function () {

        if (this._jsonParseFunc) return this._jsonParseFunc;

        this.logInfo("No native JSON.parse() available in this browser." +
            " Creating strict JSON parsing function.", "jsonEval");


        var _this = this,
            cx = this._cx;

        this._walkFunc = function (holder, key, reviver, objRefs, objPath) {
            var undef;
            // The walk method is used to recursively walk the resulting structure so
            // that modifications can be made.

            var k, v, value = holder[key];
            // Don't drill into objects we know aren't simple JSON
            // window
            // isc
            // instance or class objects
            if (value && typeof value === 'object' && value != window &&
                value != window.isc && !isc.isA.Class(value) && !isc.isAn.Instance(value))
            {

                // Infinite loops can of course cause a crash here.
                // We already have logic to avoid this in the JSONEncoder class
                // so let's use the same approach.

                var alreadySeen = false;
                var prevPath = isc.JSONEncoder._serialize_alreadyReferenced(objRefs, value);
                if (prevPath != null && objPath.contains(prevPath)) {
                    var nextChar = objPath.substring(prevPath.length, prevPath.length+1);
                    //this.logWarn("backref: prevPath: " + prevPath + ", current: " + context.objPath +
                    //             ", char after prevPath: " + nextChar);
                    if (nextChar == "." || nextChar == "[" || nextChar == "]") {
                        alreadySeen = true;
                    }
                }
                if (!alreadySeen) {

                    isc.JSONEncoder._serialize_remember(objRefs, value, objPath);

                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            var objPath = isc.JSONEncoder._serialize_addToPath(objPath, k);
                            v = _this._walkFunc(value, k, reviver, objRefs, objPath);
                            if (v !== undef) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        };

        this._jsonParseFunc = function (text, reviver, loose) {
        //!OBFUSCATEOK

            // The parse method takes a text and an optional reviver function, and returns
            // a JavaScript value if the text is a valid JSON text.

            var j;

            // Parsing happens in four stages. In the first stage, we replace certain
            // Unicode characters with escape sequences. JavaScript handles many characters
            // incorrectly, either silently deleting them, or treating them as line endings.

            // Skip this if we're not enforcing script JSON format

            var invalidExpression = false;
            if (loose == null) loose = isc.Class._useLooseJSONParsePatch;
            if (!loose) {
                text = String(text);
                cx.lastIndex = 0;
                if (cx.test(text)) {
                    text = text.replace(cx, function (a) {
                        return '\\u' +
                            ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                    });
                }

                // In the second stage, we run the text against regular expressions that look
                // for non-JSON patterns. We are especially concerned with '()' and 'new'
                // because they can cause invocation, and '=' because it can cause mutation.
                // But just to be safe, we want to reject all unexpected forms.

                // Also skip this for the mode where we're not enforcing script JSON Format

                // We split the second stage into 4 regexp operations in order to work around
                // crippling inefficiencies in IE's and Safari's regexp engines. First we
                // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
                // replace all simple value tokens with ']' characters. Third, we delete all
                // open brackets that follow a colon or comma or that begin the text. Finally,
                // we look to see that the remaining characters are only whitespace or ']' or
                // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.
                if (!(/^[\],:{}\s]*$/
                        .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                            .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                            .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) )
                {
                    invalidExpression = true;
                }
            }
            if (invalidExpression) {
                // If the text is not JSON parseable, then a SyntaxError is thrown.
                throw new SyntaxError('JSON.parse error');
            }

            // In the third stage we use the eval function to compile the text into a
            // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
            // in JavaScript: it can begin a block or an object literal. We wrap the text
            // in parens to eliminate the ambiguity.

            // Note - we're evaluating in a hidden frame by default to avoid
            // IE9's memory leaks.
            // This should never lead to the classic "Can't execute code from a freed script"
            // javascript error since strict JSON will never directly create any
            // Date or function objects. (See comments around isc.RPCManager.allowIE9Leak
            // for more on that error).
            //
            // Exceptions
            // - In "loose" mode we may be parsing code which includes method calls etc, so
            //   don't attempt to evaluate in an iframe.
            // - Have a flag to disable trying to eval in an iframe in case we hit any
            //   edge cases that trip the JS error (or other issues such as performance
            //   concerns, etc)
            j = isc.eval('(' + text + ')',
                         !loose && isc.Class.useHiddenFrameInJSONParseFunction);

            // In the optional fourth stage, we recursively walk the new structure, passing
            // each name/value pair to a reviver function for possible transformation.
            return typeof reviver === 'function'
                ? _this._walkFunc({'':j}, '', reviver, {obj:[],path:[]}, "")
                : j;
        }

        return this._jsonParseFunc;
    },


    evalFrameResetInterval: 100,
    evalInIFrame : function (expression, evalArgs) {
        if (this.logIsDebugEnabled("iframeEval")) {
            this.logDebug("Using iframe for evaluation:\n" + expression, "iframeEval");
        }

        if (this.evalFrame == null || this._domain != document.domain) {
            this.makeEvalFrame();
        }

        if (this.evalFrame.evalCount > this.evalFrameResetInterval ||
            this.evalFrame.frame == null) {
            this.resetEvalFrame();
        }

        if (this.evalFrame.frame == null) this.logInfo("Temporarily unable to " +
            "evaluate in a HiddenFrame for domain " + document.domain + "; " +
            "falling back to a simpler evaluate that may leak memory");
        return this.evalFrame.frame == null ? this.evaluate(expression, evalArgs) :
                                      this.evalFrame.doEval(expression, evalArgs);
    },

    makeEvalFrame : function () {
        this.evalFrame = isc.HiddenFrame.create(this.evalFrameDefaults);
        // we'll rebuild if document.domain mismatches
        this._domain = document.domain;
        // Draw should be synchronous (not loading any content)
        this.evalFrame.draw();

        if (document.domain == location.hostname && this.evalFrame.getFrameDocument() == null)
        {
            var props = isc.addProperties({ location: isc.Page.getURL("[HELPERS]empty.html")},
                                          this.evalFrameDefaults);
            this.evalFrame = isc.HiddenFrame.create(props);
            this.evalFrame.draw();
        }
    },

    evalFrameDefaults: {
        useHtmlfile: false,
        doEval : function (expression, evalArgs) {
            this.evalCount++;
            return this.getHandle().doEval(expression, evalArgs);
        }
    },

    evalFrameHTML: [
                  "<html><body><script>" +
                  // Apply native object class extensions
                  "var nativeObjTypes = ['Array', 'String', 'Date'];",
                  "for (var i = 0; i < nativeObjTypes.length; i++) {" +
                    "var proto = window[nativeObjTypes[i]].prototype," +
                        "sourceProto = window.parent[nativeObjTypes[i]].prototype;" +
                  // Only attributes we've added are iterable, so just copy them
                  // across.
                    "for (var attr in sourceProto) {" +
                        "proto[attr] = sourceProto[attr];" +
                    "}" +

                  "}" +
                  // Copy ISC across so anything called directly from there is available
                  // here too.
                  "window.isc = window.parent.isc;" +

                  // Eval function to actually evaluate expression.
                  "function doEval(exp, args) {" +
                    "try{" +
                        // Use a try...catch block - if the eval fails, attempt in the main
                        // frame - there may have been an issue with scoping after all.
                        "if (args) {" +
                            "with (args) { " +
                                "return eval(exp);" +
                            "}" +
                        "} else {" +
                            "return eval(exp);" +
                        "}" +
                    "} catch (e) {" +
                        "window.parent.isc.Log.logInfo(" +
                            "'Attempt to evaluate in eval-frame threw error:' + e " +
                            "+ '. Attempting eval in main window.'," +
                            "'iframeEval');" +
                        "if (args) {" +
                            "with (args) { " +
                                "return window.parent.eval(exp);" +
                            "}" +
                        "} else {" +
                            "return window.parent.eval(exp);" +
                        "}" +
                    "}" +
                  "}" +
                  "</script></body></html>"
    ],

    resetEvalFrame : function () {
        if (this.logIsInfoEnabled("iframeEval")) {
            this.logInfo("Using iframe for evaluation - resetting iframe.", "iframeEval");
        }
        this.evalFrame.evalCount = 0;


        var frame = this.evalFrame.frame = this.evalFrame.getFrameDocument();
        if (frame != null) {
            frame.open();
            var domainString = this.evalFrame._domain ?
                "document.domain = '" + this.evalFrame._domain + "';" : "";
            frame.write(this.evalFrameHTML[0] + domainString + this.evalFrameHTML[1]);
            frame.close();
        } else {
            this.evalFrame._domain = document.domain;
        }
    },

    //>    @classMethod Class.addClassProperties()
    //
    //    Add static (Class-level) properties and methods to this object<br><br>
    //
    //    These properties can then be accessed as MyClass.property, or for functions, called as
    //  MyClass.methodName()
    //
    //    @param    [arguments 0-N] (object)    objects with properties to add (think named parameters).
    //                                        all the properties of each argument will be applied
    //                                        as class-level properties.
    //  @return                 (object)    the class after properties have been added to it
    //    @visibility external
    //<
    addClassProperties : function () {
        isc.addPropertyList(this, arguments);
        return this;
    },


    //> @classAttr Class.isFrameworkClass (boolean : varies : RWA)
    // Is this a core SmartClient class (part of the SmartClient framework)?
    // This attribute may be used for debugging, and by the AutoTest subsystem to
    // differentiate between SmartClient classes (part of the smartClient framework) and
    // subclasses created by specific applications
    // @setter Class.markAsFrameworkClass()
    // @visibility external
    // @group autoTest
    //<
    // Usually set at init time as part of ClassFactory.defineClass but we need to be able
    // to also set this at runtime for the cases where we replace core smartclient classes -
    // for example IButton

    //>    @classMethod Class.markAsFrameworkClass()
    // Mark this class as a framework class (member of the SmartClient framework).
    // Sets +link{Class.isFrameworkClass}. May be used in debugging and by the
    // AutoTest subsystem
    // @visibility external
    // @group autoTest
    //<
    markAsFrameworkClass : function () {
        this.isFrameworkClass = true;
        this._instancePrototype.isFrameworkClass = true;
        this._scClass = this.Class;
        this._instancePrototype._scClass = this.Class;
    },

    //>    @classMethod Class.addProperties()
    //
    //    Add default properties and methods to all instances of this class.<br><br>
    //
    //    These properties can then be accessed as <code>myInstance.property</code>,
    //  and methods can be called via <code>myInstance.methodName()</code>
    //
    //    @param    [arguments 0-N] (object)    objects with properties to add (think named parameters).
    //                                        all the properties of each argument will be applied
    //  @see Class.addProperties()
    //  @see isc.addProperties()
    //                                        as instance-level property defaults.
    //  @return                 (object)    the class after properties have been added to it
    //    @visibility external
    //<
    _deferredDefaults : {},
    addProperties : function () {

        if (this._isInterface) {
            this.logWarn("Use addInterfaceProperties() to add methods to interface " + this);
        }
        isc.addPropertyList(this._instancePrototype, arguments, true);
        return this;
    },

    //>    @classMethod Class.addPropertyList()
    //
    //    Add default properties to all instances of this class
    //
    //    @param    list (object[])        array of objects with properties to add
    //  @return      (object)       the class after properties have been added to it
    //
    //    @visibility external
    //<
    addPropertyList : function (list) {
        isc.addPropertyList(this._instancePrototype, list, true);
        return this;
    },

    //> @classMethod Class.changeDefaults() (A)
    //
    // Changes a set of defaults defined as a JavaScript Object.  For these kind of properties,
    // simply calling +link{Class.addProperties()} would replace the original Object
    // with yours, wiping out settings required for the basic functionality of the component.
    // This method instead applies your overrides over the existing properties, without
    // destroying non-overridden properties.
    // <p>
    // For example let's say you have a component that's defined as follows
    // <pre>
    // isc.defineClass("MyComponent");
    // isc.MyComponent.addProperties({
    //     simpleProperty: "some value",
    //     propertyBlock : {
    //       foo: "bar",
    //       zoo: "moo"
    //     }
    // }
    // </pre>
    // If you wanted to override simpleProperty, you can just call +link{Class.addProperties()}
    // like this:
    // <pre>
    // isc.MyComponent.addProperties({
    //     simpleProperty: "my override"
    // });
    // </pre>
    // If you want to override the value of <code>propertyBlock.moo</code> above,
    // but you don't want to clobber the value of <code>propertyBlock.zoo</code>.  If you use
    // the above pattern like so:
    // <pre>
    // isc.MyComponent.addProperties({
    //     propertyBlock: {
    //         foo: "new value",
    //         zoo: "moo"
    //     }
    // });
    // </pre>
    // You need to re-specify the value of <code>propertyBlock.zoo</code> which you didn't want
    // to override.  Failing to re-specify it would destroy the value.
    // <p>
    // Instead of re-specifying the value, you can use this method to modify the value of
    // <code>foo</code> - like this:
    // <pre>
    // isc.MyComponent.changeDefaults("propertyBlock", {
    //     foo: "new value"
    // });
    // </pre>
    // <p>
    // See also the +link{AutoChild} system for information about standard sets of defaults
    // that are available for customization.
    //
    // @param defaultsName (String) name of the property to change
    // @param newDefaults (Object) overrides for defaults
    //
    // @visibility external
    //<
    changeDefaults : function (defaultsName, newDefaults) {
        // get existing defaults
        var defaults = this._getDefaults(defaultsName),
            mustAssign = false;

        // if we have a superclass with the same defaults, copy them so the superclass is not
        // affected
        var mySuper = this.getSuperClass();
        if (mySuper) {
            var superDefaults = mySuper._getDefaults(defaultsName);
            if (superDefaults != null && superDefaults == defaults) {
                //this.logWarn("copying defaults for property: " + defaultsName +
                //             " on class: " + this);
                defaults = isc.addProperties({}, defaults);
                mustAssign = true;
            }
        }

        // if defaults don't exist, create an empty object for them
        if (defaults == null) {
            defaults = newDefaults || {};
            mustAssign = true;
        } else {
            // otherwise add the specified defaults to the existing defaults
            isc.addProperties(defaults, newDefaults);
        }

        // if we created a new defaults object (because there were no existing defaults, or we
        // had to duplicate a superclass' defaults) override the slot on this class
        if (mustAssign) {
            //this.logWarn("had to assign when overriding property: " + defaultsName +
            //             " on class: " + this);
            var props = {};
            props[defaultsName] = defaults;
            this.addProperties(props);
        }
    },

    _getDefaults : function (defaultsName) {
        var deferredDefaults = this._deferredDefaults[this.Class],
            defaults = this.getInstanceProperty(defaultsName, true) ||
                        (deferredDefaults ? deferredDefaults[defaultsName] : null);
        return defaults;
    },

    // backcompat: briefly exposed as visibility external in 5.5 beta builds
    replaceDefaults : function (defaultsName, newDefaults) {
        this.changeDefaults(defaultsName, newDefaults);
    },

    //>    @classMethod Class.setProperties()
    //    Apply a set of properties to a class object, calling the appropriate setter class methods if
    //    any are found.
    //
    //    @param    [arguments 0-N] (object)    objects with properties to add (think named parameters).
    //                                        all the properties of each argument will be applied one after another
    //                                        so later properties will override
    //    @visibility external
    //<
    setProperties : function () {

        var propertyBlock;

        // If passed multiple arguments, combine them down to a single object.
        // (Step required as setProperties() on this instance prototype doesn't take an array,
        // and we don't know how many arguments we have).
        if (arguments.length == 1) {
            propertyBlock = arguments[0];
        } else {
            propertyBlock = {};

            for (var i = 0; i < arguments.length; i++) {
                isc.addProperties(propertyBlock, arguments[i]);
            }
        }

        // set properties on the instance prototype
        this._instancePrototype.setProperties(propertyBlock);
    },

    //>    @classMethod Class.isOverridden()
    //    Determine whether we've overridden a specified class property or method from our superClass
    //
    //    @param    property    (string)    property to check
    //
    //  @return             (boolean)   true if the property has been overridden
    //<
    isOverridden : function (property) {
        // XXX Note - need another function to check for a class overriding the properties of the
        // instance prototype
        return (!(this[property] === this._superClass[property]));
    },

    //> @classMethod Class.isA()
    //
    // Returns whether this class object is the provided class or is a subclass of the provided
    // class, or implements the provided interface.
    //
    // @param  className (string)        Class name to test against
    //
    // @return           (boolean)       true == this Class is a subclass of the provided classname
    // @visibility external
    //<
    isA : function (className) {
        if (className == null) return false;

        // handle being passed Class Objects and instances of classes
        if (!isc.isA.String(className)) {
            className = className.Class;
            if (!isc.isA.String(className)) return false;
        }

        if (isc.startsWith(className, isc.ClassFactory._$iscPrefix)) {
            className = className.substring(4);
        }
        // walk the class object inheritance chain
        var superClass = this;
        while (superClass) {
            if (superClass.Class == className) return true;
            superClass = superClass._superClass;
        }

        // walk the interface inheritance chain
        if (this._implements) {
            for (var i = 0; i < this._implements.length; i++) {
                var superInterface = isc.ClassFactory.getClass(this._implements[i]);
                while (superInterface) {
                    if (superInterface.Class == className) return true;
                    superInterface = superInterface._superClass;
                }
            }
        }

        return false;
    },

    _getNextImplementingSuper : function (methodCallingSuper, superClassProto, methodName,
                                          staticSuper)
    {
        var superClassImpl;
        for (;;) {
            if (superClassProto == null) {
                // no superclass provides a differing implementation - error
                superClassImpl = null;
                break;
            }


            var superClassImpl = isc.Class._getOriginalMethod(methodName, superClassProto);

            // function is not defined in any superclass further up the chain - error
            if (superClassImpl == null) break;

            // found a superclass implementation that differs - success!
            if (methodCallingSuper != superClassImpl) {
                //this.logWarn("found differing superClass implementation: " +
                //             this.echoLeaf(superClassImpl) +
                //             " on prototype: " + superClassProto);
                break;
            }

            // go up the chain to the prototype of the superClass
            if (staticSuper) {
                superClassProto = superClassProto._superClass;
            } else {
                superClassProto = superClassProto._classObject._superClass._instancePrototype;
            }
        }
        if (superClassImpl != null) return superClassProto;
        return null;
    },

    //>    @classMethod Class.Super()
    //
    //    Call the SuperClass implementation of a class method.
    //
    //    @param methodName   (string)    name of the superclass method to call
    //    @param args         (arguments or Array) native "arguments" object, or array of
    //                                           arguments to pass to the Super call
    //    @param [nativeArgs] (arguments) native "arguments" object, required if an Array is
    //                                  passed for the "args" parameter in lieu of the native
    //                                  arguments object
    //
    //    @return                    (any)        return value of the superclass call
    //
    // @visibility external
    //<
    //    @param     [nativeArguments] (Arguments) native "arguments" object.  Required only if
    //                                        calling Super() with a substitute set of
    //                                        arguments

    Super : function (methodName, args, nativeArguments) {
        if (isc._traceMarkers) arguments.__this = this;

        // see Class.duplicateMethods() - Super is dup'd once at init, then dup'd on the fly
        // each time it's called so that recursive super calls on the same instance can be
        // traced through
        if (this.autoDupMethods && isc.isAn.Instance(this)) {
            this.duplicateMethod("Super");
        }

        // if args is clearly not an Array or Arguments object, make it an Array.  NOTE: you
        // can still fool us by passing an object with a .length property which is neither an
        // Array or Arguments object - to avoid this we'd have to be able to reliably
        // cross-platform tell the difference between an Arguments object and a normal Object.
        // The simplest way to do this would probably be to check the callee property, which is
        // very unlikely to be set to a function on some random object being passed as params.
        if (args != null && (args.length == null || isc.isA.String(args))) args = [args];

        if (args == null) args = isc._emptyArray;


        this._nativeArguments = nativeArguments || args;
        this._argsToSuper = args;
        //if (nativeArguments == null && nativeArguments != false && args && args.constructor &&
        //    args.constructor.nativeType == 2)
        //{
        //    this.logWarn("substitute arguments passed, but native arguments object " +
        //                 "not passed as third parameter");
        //}

        // overall plan: look through the inheritance chain for a method that differs from the
        // implementation in this instance, and call that

        // get the prototype for the last method of this name that called Super().  Null for
        // the first call to Super
        this._lastProto = isc.Class._getLastProto(methodName, this);
        // set flag to tell invokeSuper it's being called by external Super and needs to pick
        // up extra arguments from instance flags
        this._externalSuper = true;

        return this.invokeSuper(null, methodName);
    },


    _delayedSuper : function (methodName, args, nativeArguments, delay, delayUnits) {
        if (args != null && (args.length == null || isc.isA.String(args))) args = [args];

        if (args == null) args = isc._emptyArray;

        nativeArguments = nativeArguments || args;
        var argsToSuper = args;
        var lastProto = isc.Class._getLastProto(methodName, this);

        var self = this;
        return isc.Timer.setTimeout(function () {
            if (isc._traceMarkers) arguments.__this = self;

            if (self.autoDupMethods && isc.isAn.Instance(self)) {
                self.duplicateMethod("Super");
            }

            self._nativeArguments = nativeArguments;
            self._argsToSuper = argsToSuper;
            self._lastProto = lastProto;
            self._externalSuper = true;

            self.invokeSuper(null, methodName);
        }, delay, delayUnits);
    },

    // observation and timers may replace a function with a generated function, storing the
    // original function in another slot.  We need to find the original function because
    // otherwise, when we look up the superclass chain to find a differing implementation, we'd
    // be using the auto-generated function, and so think all superclasses had differing
    // implementations.
    // Note that both observation and timing indirects can be installed on classes as well as
    // instances.
    _getOriginalMethod : function (methodName, theProto) {
        var method = theProto[methodName];

        while (method != null && method._origMethodSlot) {
            //this.logWarn("indirect installed on: " + theProto + ": " + this.echoLeaf(method));
            method = theProto[method._origMethodSlot];
        }


        if (method != null && method._originalMethod != null) method = method._originalMethod;

        return method;
    },

    // high speed implementation of Super used by internal callers, where the class and method
    // of the calling function are directly passed in.  Calls to external Super can be freely
    // mixed with calls to invokeSuper because they store the same state.
    //
    // Extremely critical path code sometimes calls Super like so:
    //    isc.StatefulCanvas._instancePrototype.initWidget.call(this);
    // This is safe only if there are no calls to external Super() in any superclass
    // implementations.  If there are, with the lack of any stored lastProto, inter-recursion
    // will be falsely detected and the leaf implementation will be called.
    invokeSuper : function (clazz, methodName, a,b,c,d,e,f,g,h,i,j,lastArg) {

        if (this.autoDupMethods && isc.isAn.Instance(this)) {
            this.duplicateMethod("invokeSuper");
        }

        // static mode (class methods calling Super)
        var staticSuper = this._isClassObject;


        var externalSuper = this._externalSuper;
        this._externalSuper = null;
        var nativeArguments = this._nativeArguments;
        this._nativeArguments = null;
        var argsToSuper = this._argsToSuper;
        this._argsToSuper = null;


        var lastProto;
        if (externalSuper) {
            lastProto = this._lastProto;
            this._lastProto = null;
        } else {
            // for framework code calling invokeSuper, null indicates instance override
            if (clazz != null) {
                // in static mode, protos are class objects
                lastProto = staticSuper ? clazz : clazz._instancePrototype;
            }
        }

        // figure out the method that is calling Super in order to compare the implementation
        // against superclass implementation to find out when a superclass implementation differs
        var methodCallingSuper, nextProto;
        if (lastProto == null) {

            methodCallingSuper = isc.Class._getOriginalMethod(methodName, this);

            // in static mode, there's no such thing as an instance override
            nextProto = staticSuper ? this : this.getPrototype();
            //if (methodName == "draw") {
            //    this.logWarn("new Super call, method calling super: " +
            //                 this.echoLeaf(methodCallingSuper));
            //}
        } else {

            methodCallingSuper = isc.Class._getOriginalMethod(methodName, lastProto);

            if (staticSuper) {
                // static mode - get superclass classObject
                nextProto = lastProto._superClass;
            } else {
                // instance mode - get superclass instancePrototype
                nextProto = lastProto._classObject._superClass._instancePrototype;
            }


            if (nativeArguments && nativeArguments.callee != null &&
                nativeArguments.callee != methodCallingSuper)
            {
                //this.logWarn("recursion detected: to continue current super chain caller" +
                //             " should be: " + this.echoLeaf(methodCallingSuper) +
                //             " but caller is: " + this.echoLeaf(nativeArguments.callee));
                methodCallingSuper = isc.Class._getOriginalMethod(methodName, this);
                nextProto = staticSuper ? this : this.getPrototype();
            }
        }

        // count all calls to externalSuper
        //if (externalSuper) {
        //    var callCounts = isc._superCallCount = isc._superCallCount || [],
        //        fullName = isc.Func.getName(methodCallingSuper);
        //
        //    var record = callCounts.find("fullName", fullName);
        //    if (record) record.callCount++;
        //    else callCounts.add({fullName:fullName, callCount:1});
        //}

        //this.logWarn("methodCallingSuper: " + this.echoLeaf(methodCallingSuper) +
        //             ", lastProto: " + lastProto +
        //             ", nextProto: " + nextProto);

        // find the next superclass implementation
        nextProto = isc.Class._getNextImplementingSuper(methodCallingSuper, nextProto,
                                                        methodName, staticSuper);

        if (nextProto == null) {
            // failed to find a superclass implementation
            if (isc.Log) isc.Log.logWarn("Call to Super for method: " + methodName +
                                         " failed on: " + this +
                                         ": couldn't find a superclass implementation of : " +
                                         (lastProto ? lastProto.Class : this.Class) +
                                         "." + methodName +
                                         this.getStackTrace());
            return null;
        }

        // we found a superclass implementation
        var superClassImpl = nextProto[methodName];

        //if (methodName == "draw") {
        //    this.logWarn("about to call: " + this.echoLeaf(superClassImpl) +
        //                 ", call chain: " + superCallChains);
        //}


        isc.Class._addProto(methodName, nextProto, this);

        // NOTE: it's normal that we're invoke an indirect (an observation or timer for
        // instance), which will invoke the original method for us - it's just when comparing
        // methods that we have to avoid using the indirects
        //if (superClassImpl._origMethodSlot) {
        //    this.logWarn("invoking indirect: " + this.echoLeaf(superClassImpl) +
        //                 " found on prototype: " + nextProto);
        //}

        // call the superclass implementation on "this"
        var returnVal;
        if (externalSuper) {
            // for external callers, use apply() in order to preserve arguments.length just in
            // case external code contains a function that uses arguments.length and gets
            // called as Super
            if (argsToSuper != null || nativeArguments != null) {
                returnVal = superClassImpl.apply(this, argsToSuper == null ?
                                                       nativeArguments : argsToSuper);
            } else {
                returnVal = superClassImpl.apply(this);
            }
        } else {


            returnVal = superClassImpl.call(this, a,b,c,d,e,f,g,h,i,j);
        }

        isc.Class._clearLastProto(methodName, this);

        // and return the value returned from the apply
        return returnVal;
    },

    _getLastProto : function (methodName, obj) {
        var superCalls = obj._superCalls,
            protoList = superCalls == null ? null : superCalls[methodName];

        //this.logWarn("for method: " + methodName + " chain is: " + protoList);

        if (isc.isAn.Array(protoList)) return protoList.last();
        return protoList;
    },

    _clearLastProto : function (methodName, obj) {
        var superCalls = obj._superCalls,
            protoList = superCalls[methodName];
        if (protoList == null) {

            return;
        }
        // clear single item
        if (!protoList.__isArray) {

            superCalls[methodName] = null;
        } else {
            // shorten array, then remove if zero length
            protoList.length = Math.max(0, protoList.length-1);
            if (protoList.length == 0) superCalls[methodName] = null;
        }
    },

    _addProto : function (methodName, newProto, obj) {
        var superCalls = obj._superCalls = obj._superCalls || {},
            protoList = superCalls[methodName];
        if (protoList == null) {
            superCalls[methodName] = newProto;
        } else {
            if (isc.isAn.Array(protoList)) protoList.add(newProto);
            else {
                superCalls[methodName] = [protoList, newProto];

                superCalls[methodName].__isArray = true;
            }
        }
    },

    //>    @classMethod Class.map()
    //
    // Call <code>method</code> on each item in <code>argsList</code> and return the Array of results.
    //
    //    @param    methodName (string)
    //      Name of the method on this instance which should be called on each element of the Array
    //    @param    items      (Array)
    //      Array of items to call the method on
    //
    //    @return            (Array) Array of results, one per element in the passed "items" Array
    // @visibility external
    //<
    map : function (methodName, items, arg1, arg2, arg3, arg4, arg5) {
        if (methodName == null) return items;
        var results = [];
        for (var i = 0; i < items.length; i++) {
            results.add(this[methodName](items[i], arg1, arg2, arg3, arg4, arg5));
        }
        return results;
    },

    //>    @classMethod Class.getInstanceProperty()
    //
    //    Gets a named property from the instance defaults for this object.
    //
    //    @param property    (string)    name of the property to return
    // @visibility external
    //<
    getInstanceProperty : function (property, skipInit) {

        if (!this.initialized() && !skipInit) this.init();

        var value = this._instancePrototype[property];

        return value;
    },

    //>    @classMethod Class.setInstanceProperty()
    //
    //    Sets a named property from the instance defaults for this object.
    //
    //    @param property    (string)    name of the property to return
    //    @param value    (any)        value to set to
    // @visibility external
    //<
    setInstanceProperty : function (property, value) {
        this._instancePrototype[property] = value;
    },

    getArgString : function (methodName) {
        // check for a string method definition
        var argString = this._stringMethodRegistry[methodName];
        var undef;
        if (argString !== undef) return argString || isc.emptyString;

        // get the arguments from the method definition (very very slow!)
        var method = this.getInstanceProperty(methodName);
        //if (method == null || !isc.isA.Function(method)) return "";
        if (method == null) return "";
        return isc.Func.getArgString(method);
    },

    // Callbacks and eval()ing
    // ---------------------------------------------------------------------------------------

    //> @type Callback
    // A <code>Callback</code> is an arbitrary action to be fired - usually passed into a
    // method to be fired asynchronously as a notificaction of some event.<br>
    // The <code>callback</code> can be defined in the following formats:<ul>
    // <li>a function</li>
    // <li>A string containing an expression to evaluate</li>
    // <li>An object with the following properties:<br>
    //     - target: fire in the scope of this target - when the action fires,
    //       the target will be available as <code>this</code>.<br>
    //     - methodName: if specified we'll check for a method on the target object with this
    //       name.<br>
    //  </li></ul>
    // <code>Callbacks</code> are fired via the +link{classMethod:Class.fireCallback()} method, which allows
    // named parameters to be passed into the callback at runtime. If the Callback was specified
    // as a string of script, these parameters are available as local variables at eval time.<br>
    // For specific SmartClient methods that make use of <code>Callback</code> objects, see
    // local documentation for information on parameters and scope.
    // @visibility external
    //<


    //>    @classMethod    Class.fireCallback()
    //
    // Fire some arbitrary action specified as a +link{type:Callback}.
    // Returns the value returned by the action.
    //
    // @param callback (Callback) Action to fire.
    // @param [argNames] (string) Comma separated string of variable names. If the callback
    //                            passed in was a string of script, any arguments passed to the
    //                            callback will be available as local variables with these names.
    // @param [args] (array)    Array of arguments to pass to the method. Note that the number
    //                          of arguments should match the number of argNames.
    // @param [target] (object) If specified the callback will be evaluated in the scope of this
    //                          object - the <code>this</code> keyword will be a pointer to this
    //                          target when the callback is fired.
    // @return (any)   returns the value returned by the callback method passed in.
    // @visibility external
    //<

    fireCallback : function (callback, argNames, args, target, catchErrors) {
        arguments.__this = this;
        if (callback == null) return;


        var undef;
        if (argNames == null) argNames = undef;

        var method = callback;
        if (isc.isA.String(callback)) {
            // callback specified as the name of a method on a known target
            if (target != null && isc.isA.Function(target[callback])) method = target[callback];
            // callback is a String expression
            else method = this._makeCallbackFunction(callback, argNames);

        } else if (isc.isAn.Object(callback) && !isc.isA.Function(callback)) {
            // Object containing (possibly) target, and either methodName or action to fire

            if (callback.caller != null) target = callback.caller;
            else if (callback.target != null) target = callback.target;

            // Pick up arguments from the callback directly, if passed that way.
            if (callback.args) args = callback.args;
            if (callback.argNames) argNames = callback.argNames;

            if (callback.method) method = callback.method;


            else if (callback.methodName && target != null) method = target[callback.methodName];
            else if (callback.action)
                method = this._makeCallbackFunction(callback.action, argNames);
        }

        // At this point the target (if one was passed in) is available under 'target', and
        // we've converted the callback to a function, if possible.
        if (!isc.isA.Function(method)) {
            this.logWarn("fireCallback() unable to convert callback: " + this.echo(callback) +
                         " to a function.  target: " + target + ", argNames: " + argNames +
                         ", args: " + args);
            return;
        }

        // If no target was specified, fire it in the global scope

        if (target == null) target = window;
        // If the target has been destroyed, abort!
        else if (target.destroyed) {
            // NOTE: this isn't a warning scenario: destruction is normal, and callbacks are
            // commonly timers to do visual refreshes which don't matter if a component is
            // destroyed
            if (this.logIsInfoEnabled("callbacks")) {
                this.logInfo("aborting attempt to fire callback on destroyed target:"+ target +
                             ". Callback:"+ isc.Log.echo(callback) +
                              ",\n stack:" + this.getStackTrace());
            }
            return;
        }

        // this causes anonymous callback functions to be labelled "callback" in stack traces.
        // Non-anonymous callbacks still show their usual name
        method._isCallback = true;

        if (args == null) args = [];



        if (isc.enableCrossWindowCallbacks && isc.Browser.isIE) {
            var targetWindow = target.constructor ? target.constructor._window : target;
            if (targetWindow && targetWindow != window && targetWindow.isc) {
                var newArgs = targetWindow.Array.newInstance();
                for (var i = 0; i < args.length; i++) newArgs[i] = args[i];
                args = newArgs;
            }
        }

        var returnVal;

        if ((!catchErrors && !isc.Log.rethrowErrors) || isc.Log.supportsOnError) {
            returnVal = method.apply(target, args);
        } else {
            try {
                returnVal = method.apply(target, args);
            } catch (e) {
                if (catchErrors) isc.Log._reportJSError(e);
                else             isc.Log._onRethrowError(e);

                throw e;;
            }
        }

        return returnVal;
    },

    //> @classMethod Class.delayCall()
    //  This is a helper to delay a call to a method on some target by a specified
    //  amount of time.  Can be used to delay a call to a static method on this class by
    //  omitting the <code>target</code> parameter.
    // @param methodName (string) name of the method to call
    // @param [arrayArgs] (array) array of arguments to pass to the method in question
    // @param [time] (number) Number of ms to delay the call by - defaults to zero (so just pulls
    //                        execution of the method out of the current execution thread.
    // @param [target] (object) Target to fire the method on - if unspecified assume this is
    //                          a call to a classMethod on this Class.
    // @return (string) Timer ID for the delayed call - can be passed to
    //                      +link{Timer.clear()} to cancel the call before it executes
    // @visibility external
    //<
    delayCall : function (methodName, arrayArgs, time, target) {
        if (target == null) target = this;
        if (time == null) time = 0;

        return isc.Timer.setTimeout({target:target, methodName:methodName, args:arrayArgs}, time);
    },


    _makeCallbackFunction : function (callback, argNames) {


        //return isc.Func.expressionToFunction(argNames, callback);

        if (argNames == null) {
            var undef;
            argNames = undef;
        }
        var func = isc._makeFunction(argNames, callback);
        func._showBodyInTrace = true;
        return func;
    },

    // Fire on Pause
    // ---------------------------------------------------------------------------------------

    //> @classMethod Class.fireOnPause()
    // Given some repeatedly performed event (EG keypress, scroll, etc), set up an action
    // to fire when the events have stopped occurring for some set period.
    // @param id (string) arbitrary identifier for the action
    // @param callback (callback) action to fire on quiescence
    // @param [delay] (number) delay in ms - defaults to 200ms
    // @param [target] (object) if passed, the callback will be fired in this target's scope
    //<
    // additional instanceID parameter passed from instance method to support instance-level IDs
    fireOnPauseDelay:200,
    _$_fireActionsOnPause:"_fireActionsOnPause",
    _actionsOnPause:{},
    _actionOnPauseTimers:{},
    fireOnPause : function (id, callback, delay, target, instanceID) {

        if (!id) return;
        if (!delay) delay = this.fireOnPauseDelay;
        // If unset, default to this.getClassName() [not legal to have any instance with the
        // same ID as a SmartClient class].
        if (instanceID == null) instanceID = this.getClassName();
        // class _fireOnPause on the Class object

        return isc.Class._fireOnPause(id, callback, delay, target, instanceID);
    },
    _fireOnPause : function (id, callback, delay, target, instanceID) {

        // Note: If we have two separate instances calling the fireOnPause instance method with
        // the same ID, both actions need to fire -- the ID is essentially unique within the
        // instance only.
        // We use the instanceID parameter to create separate callbacks for the same ID used
        // on different instances.

        if (!this._actionsOnPause[id]) {
            this._actionsOnPause[id] = {};
        }

        this._actionsOnPause[id][instanceID] =
            {fireTime:delay, callback:callback, target:target};

        var stamp = isc.timeStamp(),
            elapsed = this._lastFireOnPause ? stamp - this._lastFireOnPause : null;
        this._lastFireOnPause = stamp;

        // If we're going to fire queue of actions before the delay passed in, we're done
        // Check for this._fireActionsOnPauseRunning -- if a callback from an existing
        // 'fireOnPause' sets up a new 'fireOnPause' we need to set a timer to execute it
        // as a separate flow.
        if (!this._fireActionsOnPauseRunning &&
            elapsed && this._fireOnPauseDelay != null &&
            delay >= (this._fireOnPauseDelay - elapsed))
        {
            return;
        }
        if (this._fireOnPauseTimer) isc.Timer.clearTimeout(this._fireOnPauseTimer);
        this._fireOnPauseTimer = this.delayCall(this._$_fireActionsOnPause,null, delay);

        this._fireOnPauseDelay = delay;
    },

    _fireActionsOnPause : function () {
        this._fireActionsOnPauseRunning = true;
        var fireAgainTime;
        // In theory this._fireOnPausedDelay ms have elapsed since the call to fireOnPause
        // (or the last call to this method).
        // In practice it's probably more accurate to check the elapsed time by comparing
        // timestamps
        var elapsed = isc.timeStamp() - this._lastFireOnPause,
            fireAgainTime;
        for (var id in this._actionsOnPause) {
            var actions = this._actionsOnPause[id];
            // Get the timer-id's now so if any callback sets up a new fireOnPause
            // and changes the 'actions' object we won't worry about it as part of this flow
            var iids = isc.getKeys(actions);
            for (var i = 0; i < iids.length; i++) {
                var iid = iids[i];
                var action = actions[iid];
                if (action.fireTime <= elapsed) {
                    // Wipe the action off the actions object before firing the callback
                    // in case the callback sets up a new fireOnPause with the same ID.
                    delete this._actionsOnPause[id][iid];
                    this.fireCallback(action.callback, null, null, action.target);
                } else {
                    action.fireTime -= elapsed;
                    if (fireAgainTime == null) fireAgainTime = action.fireTime;
                    else fireAgainTime = Math.min(fireAgainTime, action.fireTime);
                }
            }
            if (isc.isAn.emptyObject(this._actionsOnPause[id])) delete this._actionsOnPause[id];
        }
        if (fireAgainTime != null) {
            this._fireOnPauseDelay = fireAgainTime;
            this._lastFireOnPause = isc.timeStamp();
            this.delayCall(this._$_fireActionsOnPause, null, fireAgainTime);
        } else {
            this._fireOnPauseDelay = null;
            this._lastFireOnPause = null;
        }
        this._fireActionsOnPauseRunning = null;

    },

    // Eval() wrappers including globals capture
    // ---------------------------------------------------------------------------------------

    //>    @classMethod    Class.evalWithVars()
    //
    // Evaluates the given string with an arbitrary number of arguments on the specified target.
    // evalVars and target are optional.
    //
    // @param   evalString  the string to evaluate
    // @param   evalVars    Map of key-value pairs.  The keys are treated as argument names that are
    //                      then made available inside the eval body as variables.  The values of
    //                      these variables are the values assigned to the keys in evalVars.
    // @param   target      the target on which to apply the eval - it will be available as the
    //                      'this' variable inside the eval block.  If not specified, the evalString
    //                      is evaluated in global context.
    // @return  (any)       returns the result of eval(evalString)
    //<
    useFastEvalWithVars : isc.Browser.isMoz && isc.Browser.geckoVersion >= 20061010,
    evalWithVars : function (evalString, evalVars, target) {
        //!OBFUSCATEOK
        // if no target specified, eval in global scope
        if (!target) target = window;


        if (this.useFastEvalWithVars) {
            return this.evaluate.call(target, evalString, evalVars);
        }

        // create two arrays of the keys and values of the evalVars map
        var evalStringVarName = "_1";
        // Ensure that we don't step on any of the vars passed in in the evalVars object
        while (evalVars && isc.propertyDefined(evalVars, evalStringVarName)) {
            evalStringVarName += "1"
        }
        var argNames = [evalStringVarName];
        var argValues = [evalString];
        if (evalVars) {
            for (var argName in evalVars) {
                argNames.push(argName);
                argValues.push(evalVars[argName]);
            }
        }

        // make a function with argNames as arguments that evals evalString

        var theFunc = isc._makeFunction(argNames.join(","),
                                        "return eval(" + evalStringVarName + ")");

        // call the function on the target
        return theFunc.apply(target, argValues);
    },

    // calls evalWithVars(jsSrc, evalVars, target), and returns all globals created via
    // addGlobalID().  All other non-explicit globals are captured by the function body that's
    // created around the jsSrc.
    evalWithCapture : function (jsSrc, evalVars, target) {
        var globals = isc.globalsSnapshot = [];
        //
        // we need to create a function with the jsSrc as the body to avoid creating extraneous
        // globals - conveniently evalWithVars already does this for us.
        this.evalWithVars(jsSrc, evalVars, target);
        isc.globalsSnapshot = null;
        return globals;
    },

    // takes a list of global IDs and destroys them
    destroyGlobals : function (globals) {
        // avoid setting `undefined' to `null' in IE6, 7, and 8
        if (globals == null) return;

        if (!isc.isAn.Array(globals)) globals = [globals];

        for (var i = 0; i < globals.length; i++) {
            var global = globals[i];

            var val = window[global];
            // if the value is not already null (or a logical false value such as undefined)
            if (val) {
                // call destroy() on the global if it's defined
                if (isc.isA.Function(val.destroy)) val.destroy();
                else window[global] = null; // otherwise just null out the global ref
            }
        }
    },

    // Provides 'true' global eval - i.e. global vars actually stick to the window object when
    // eval'd in this manner vs a plain eval() which does not do that.
    //
    // Note: the eval logic here (separate approaches to actually perform the eval per browser)
    // duplicates FileLoader.delayedEval() - if you change this code, be sure to update that
    // method.
    // reportErrors optional param defaults to true
    globalEvalWithCapture : function (evalString, callback, evalVars, reportErrors) {

        if (reportErrors == null) reportErrors = true;
        //!OBFUSCATEOK

        // store these on these object - really for Safari's benefit, since it's the only one
        // requiring async execution.  This makes the Safari case below easier.
        this._globalEvalVars = evalVars;
        this._globalEvalCallback = callback;


        /*if ((isc.Browser.isSafari && isc.Browser.safariVersion<533.16) || (isc.Browser.isChrome && isc.Browser.safariVersion<537.4)) {

            evalString = "isc.Class.startGlobalsCapture();try {\n"
                         + "eval(" + evalString.asSource() +
                            ");\n} catch (e) { window._evalError = e; }\n"
                         +"isc.Class.endGlobalsCapture("
                         +"window._evalError," + !!reportErrors + ");";
            window.setTimeout(evalString,0);
            return;
        }*/

        // by default when globalEvalWithCapture is called with callback, the keepGlobals handling is set in globalEvalAndRestore
        // which requests startGlobalsCapture / endGlobalsCapture to run in keepGlobals mode. The globals however are restored in
        // globalEvalAndRestore, not in endGlobalsCapture() like should when startGlobalsCapture() / endGlobalsCapture() pair is called
        // standalone. To keep the globalEvalWithCapture's standalone functionality in sync with the case when callback is passed as
        // parameter, we specifically set keepGlobals (as otherwise startGlobalsCapture will be by default in keepGlobals mode)
        if (!callback) {
            var undef;
            this.startGlobalsCapture(null, isc.keepGlobals === undef ? null : isc.keepGlobals);
        } else {
            this.startGlobalsCapture();
        }
        // If an error occurs during eval, capture it and pass it to the completion block to be
        // provided to the user callback.
        var error;
        try {
            if (isc.Browser.isIE) {
                // execScript() - Special IE only function that exports to global scope -
                // can also be used to execute VBScript code. Before IE 9 no other mechanism
                // is known to work to evaluate code in the global scope. Starting
                // with IE 9, an indirect eval executes properly in the global
                // scope: http://msdn.microsoft.com/en-us/library/ie/gg622934.aspx
                // Also, execScript() is unavailable in IE11+:
                // http://msdn.microsoft.com/en-us/library/ie/ms536420.aspx
                if (window.execScript != null) {
                    window.execScript(evalString, "javascript");

                // Indirect eval
                // http://perfectionkills.com/global-eval-what-are-the-options/#windoweval
                } else {
                    window.eval(evalString);
                }
            } else {
                // pass in the 'globalScope' parameter so any defined vars get retained in global
                // scope after the eval
                isc.Class.evaluate(evalString, null, true);
            }
        } catch (e) {
            // If we have been asked to report errors, do so - also hang onto the error so
            // the callback can make use of it if necessary


            if (reportErrors) isc.Log._reportJSError(e, null, null, null,
                                                     "Problem during global eval()");
            error = e;
        }

        return this.endGlobalsCapture(error);
    },

    startGlobalsCapture : function (pEvalVars, keepGlobals) {
        var undef;



        // make sure we're not calling startGlobalsCapture without calling endGlobalsCapture first
        if (isc._startGlobalsCaptureCalled) {
            isc.logWarn("startGlobalsCapture() called again without endGlobalsCapture being called!");
            return;
        }

        isc._startGlobalsCaptureCalled = true;

        // if called standalone (not from globalEvalAndRestore), we need to set user-passed keepGlobals
        // but also consider the case when not passed at all, in which case we need to be in
        // keepGlobals mode
        if (!this._globalEvalCallback) {
            // if keepGlobals was not passed, assume we gonna need to restore the globals later
            // in the endGlobalsCapture(), so enable keepGlobals mode.
            if (keepGlobals === undef) {
                isc.keepGlobals = [];
            } else {
                isc.keepGlobals = keepGlobals;
            }
        }

        // evalVars must go onto the window object - make sure we don't overwrite existing
        // values by holding on to any conflicting refs so we can restore later
        var evalVars = this._globalEvalVars ? this._globalEvalVars : pEvalVars;
        this._restoreGlobals = {};
        if (evalVars) {
            for (var evalVar in evalVars) {
                var globalValue = window[evalVar];
                // need to be careful to preserve nulls, zeroes - so check that the value is
                // actually undefined.
                if (globalValue !== undef) this._restoreGlobals[evalVar] = globalValue;
                window[evalVar] = evalVars[evalVar];
            }
        }

        // track temporary globals with auto-assigned IDs
        isc.autoAssignedTempGlobals = {};

        // start globals capture.  See globalEvalAndRestore for 'keepGlobals' purpose
        isc.globalsSnapshot = isc.keepGlobals ? {} : [];
    },

    // revert window binding for globalId, and release globalId if it was auto-assigned
    _globalsCaptureRestoreGlobal : function (globalId, originalGlobals, idsToFree) {
        // if globalId was registered as auto-assigned, release it now
        var className = idsToFree[globalId];
        if (className) {
            delete idsToFree[globalId];
            isc.ClassFactory.releaseGlobalID(className, globalId);
        }
        // restore the original/previous window binding for globalId
        window[globalId] = originalGlobals[globalId];
    },

    endGlobalsCapture : function (error, reportErrors, restoreGlobals) {
        //!OBFUSCATEOK


        // check if we were called after startGlobalsCapture. If not, bail out with error
        if (!isc._startGlobalsCaptureCalled) {
            isc.logWarn("endGlobalsCapture() called before having a startGlobalsCapture() call!");
            return {globals:null, error:"endGlobalsCapture() called before having a startGlobalsCapture() call!"};
        }

        if (error != null && reportErrors) isc.Log._reportJSError(error, null, null, null,
                                                 "Problem during global eval()");
        // restore any conflicting globals and undefine any evalVars we set on the window object
        var undef, evalVars = this._globalEvalVars;
        if (evalVars) {
            for (var evalVar in evalVars) {
                var globalValue = this._restoreGlobals[evalVar];
                if (globalValue !== undef) window[evalVar] = this._restoreGlobals[evalVar];
                else window[evalVar] = undef; // can't delete window[evalVar] in IE!
            }
        }
        var callback = this._globalEvalCallback,
            globals = isc.globalsSnapshot,
            idsToFree = isc.autoAssignedTempGlobals;

        isc.globalsSnapshot = this._globalEvalCallback = this._globalEvalVars =
            this._restoreGlobals = window._evalError = isc.autoAssignedTempGlobals = null;
        isc._startGlobalsCaptureCalled = null;

        this.fireCallback(callback, "globals,error,idsToFree", [globals, error, idsToFree]);

        // if called in standalone mode, check if globals need to be restored
        if (!callback) {
            var keepGlobals = isc.keepGlobals;

            // globals can be restored only if we were in keepGlobals mode
            var undef;
            if (restoreGlobals === undef || restoreGlobals ) {
                if (keepGlobals) {
                    for (var globalId in globals) {
                        if (keepGlobals.contains(globalId)) {
                             continue;
                        }

                        this._globalsCaptureRestoreGlobal(globalId, globals, idsToFree);
                    }
                } else {
                   isc.logWarn("Cannot restore globals in endGlobalsCapture because " +
                               "non-keepGlobals mode was also required by caller");
                }
            }
            isc.keepGlobals = null;
        }

        return {globals: globals, error: error}
    },

    // eval code in the global scope, where only the listed IDs are allowed to become global.
    // Other widgets obtain a global ID only for the duration of the eval(), then become no
    // longer global.
    //
    // This allows widgets that interlink by global ID (eg layout.members) to find each other,
    // specifically, any inter-reference that is resolved either directly when the code eval()s
    // or by the time init()/initWidget() completes will work.
    //
    // Any code that tries to resolve an ID reference sometime after init, or stores the global
    // ID of a component during init (rather than a live reference) won't work with
    // globalEvalAndRestore().
    //
    // globalEvalAndRestore() does not prevent DataSources from registering such that they are
    // available from DataSource.get(), so in effect, all DataSources behave as if
    // dataSource.addGlobalId were false.
    //
    // Likewise globalEvalAndRestore() does not prevent other global registrations not related
    // to global IDs, such as SimpleType registration or WSDL / XML schema registrations by
    // namespace.

    globalEvalAndRestore : function (evalString, keepGlobals, callback, evalVars, reportErrors,
                                     updateLocalIds)
    {
        if (keepGlobals == null) keepGlobals = [];
        isc.keepGlobals = keepGlobals;

        return this.globalEvalWithCapture(evalString, function (globals, error, idsToFree) {
            isc.keepGlobals = null;


            var suppressedGlobals = {},
                topLevel = isc.Canvas._getTopLevelWidget(globals);

            // restore all captured globals to their original values, except the keepGlobals
            for (var globalId in globals) {
                if (keepGlobals.contains(globalId)) continue;

                // save the object temporarily ocuppied this global id, so we can pass it later
                // to the callback
                suppressedGlobals[globalId] = window[globalId];

                if (updateLocalIds) {
                    var obj = window[globalId];

                    if (obj && isc.isA.Canvas(obj)) {

                        if (topLevel) {
                            // store a mapping from globalId to widget on the detected top
                            // level widget (the "screen")
                            if (!topLevel._localIds) {
                                topLevel._localIds = {};
                            }
                            topLevel._localIds[globalId] = obj;
                            // on each widget, store a reference to the screen it's registered
                            // with
                            obj.setProperty("_screen", topLevel);
                        } else {
                            // Could happen in case of potential error in evaluated code. For
                            // example if topElement or masterElement was explicitely defined
                            // for object that otherwise should be topLevel object or overridden
                            // Canvas class were used which sets topElement or masterElement
                            // property during init method.
                            if (obj.topElement || obj.masterElement) {
                                isc.logWarn("Cannot find top level of " + obj);
                            }
                        }
                    }
                }

                isc.Class._globalsCaptureRestoreGlobal(globalId, globals, idsToFree);
            }

            isc.Class.fireCallback(callback, "globals,error,suppressedGlobals",
                                   [globals, error, suppressedGlobals]);

        }, evalVars, reportErrors);
    },

    // ---------------------------------------------------------------------------------------

    // _notifyFunctionComplete
    // Static method called when the notification function for some observed method completes.
    _notifyFunctionComplete : function (object, methodName, queue) {
        // Decrement the 'notifyStack' flag.
        // This flag tracks whether the observed function is currently being run.  We implement
        // this as a number indicating the depth of stacked calls to this method.

        queue._notifyStack -= 1;
        // if the notifyStack is greater than zero the top level notificationFunction hasn't
        // yet exited, so don't proceed to modify observers.
        if (queue._notifyStack) return;

        for (var i = 0; i < queue.length; i++) {
            var q = queue[i];
            // Clear any items that were 'ignored' while the notification function was running
            if (q._removedWhileNotificationRunning) {
                queue.removeItem(i);
                i--;
                continue;
            }

            // Clear any temp flags denoting observations set up while the notification function
            // was firing.
            if (q._addedWhileNotificationRunning) {
                delete q._addedWhileNotificationRunning;
            }
        }

        if (queue.length == 0) {
            var saveMethodName = isc._obsPrefix + methodName;
            // restore the original function to its original name
            object[methodName] = object[saveMethodName];
            // clear the new method slot
            delete object[saveMethodName];
            // remove the observer queue
            delete object._observers[methodName];
        }
    },

    // Arrays of definitions (TabBar tabs, Layout members, SectionStack sections, Wizard pages..)
    // ---------------------------------------------------------------------------------------
    _$ID : "ID",
    getArrayItem : function (id, array, idProperty) {
        if (array == null) return null;



        // Number: assume index.
        if (isc.isA.Number(id)) return array[id];

        // Object: return unchanged
        if (isc.isAn.Object(id)) return id;

        // String: assume id property of section descriptor object
        if (isc.isA.String(id)) return array.find(idProperty || this._$ID, id);


        // otherwise invalid
        return null;
    },

    getArrayItemIndex : function (id, array, idProperty) {
        if (isc.isA.Number(id)) return id;

        var item = isc.Class.getArrayItem(id, array, idProperty);

        return array.indexOf(item);
    },

    // Getting DOM objects (going through these APIs makes cross-frame installation possible)
    // ---------------------------------------------------------------------------------------

    getWindow : (
        isc.Browser.isSafari ? function () {
            return window;
        } : function () {
            return this.ns._window;
        }
    ),
    getDocument : (
        isc.Browser.isSafari ? function () {
            return window.document;
        } : function () {
            return this.ns._document;
        }
    ),


    getDocumentBody : function (suppressDocElement) {
        var getDocElement = (!suppressDocElement && isc.Browser.isIE && isc.Browser.isStrict);
        var body = (getDocElement ? this.ns._documentElement : this.ns._documentBody);
        if (body != null) return body;

        var doc = this.getDocument();
        if (getDocElement) {
            this.ns._documentElement = doc.documentElement;
            return this.ns._documentElement;
        }

        if (isc.Browser.isIE) {
            body = doc.body;
        } else {
            if (doc.body != null) body = doc.body;
            else {
                // XHTML: body not available via document.body (at least in FF 1.5)
                // Using the documentElement namespace future proofs us against future XHTML
                // versions
                var documentNS = doc.documentElement.namespaceURI;
                body = doc.getElementsByTagNameNS(documentNS, "body")[0];
                if (body == null) {
                    // XHTML: body not available via getElementsByTagNameNS() before page load
                    // in FF 1.5 (possibly others), but is available via DOM navigation
                    body = doc.documentElement.childNodes[1];
                    if (body != null && body.tagName != "body") body = null;
                }
                //this.logWarn("fetching body element: " + body);
                // don't cache failure to retrieve body, it should be available later until the
                // document is completely hosed
                if (!body) return null;
            }
        }
        this.ns._documentBody = body;
        return body;
    },
    getActiveElement : function () {

        try {
            return this.getDocument().activeElement;
        } catch (e) {
            this.logWarn("error accessing activeElement: " + e.message);
        }
        return null;
    },

    //> @classMethod class._makeNotifyFunction() (A)
    // Make a function to call the original method, then each recipient in turn.
    // @param methodName (string) name of the method to observe
    // @return (function) new function to call when method is fired
    // @group observation
    //<
    _actionRunnerCache: {},
    _makeNotifyFunction : function (methodName) {
        var notifyFunc = function observation() {
            if (isc._traceMarkers) arguments.__this = this;

            var returnVal = this[arguments.callee._origMethodSlot].apply(this, arguments);

            var queue = this._observers[methodName];

            // HACK: avoid crashing if we end up with an observation installed on an object
            // without the corresponding list of observers.  This can happen when we trace a
            // method on an entire class, in which case we install the observation method on
            // the instance prototype, but when the observation fires, it fires with each
            // individual instance's list of observers.
            if (!queue) return returnVal;

            queue._notifyStack = queue._notifyStack ? queue._notifyStack + 1 : 1;

            // call each observer
            var q,
                action;
            for (var i = 0, len = queue.length; i < len; ++i) {
                q = queue[i];

                // skip if the observer was added while this notify function is running.
                if (q._addedWhileNotificationRunning) continue;

                action = q.action;
                action._observer = q.target;
                action._observed = this;
                action._returnVal = returnVal;
                try {
                    action.apply(q.target, arguments);
                } finally {
                    action._observer = null;
                    action._observed = null;
                    action._returnVal = null;
                }
            }

            // Fire the 'complete' function - this will update any changes to observation made while
            // the notification function was running.

            if (isc.Browser.isSafari) {
                arguments.callee._ns.Class._notifyFunctionComplete(this, methodName, queue);
            } else {
                isc.Class._notifyFunctionComplete(this, methodName, queue);
            }

            // return the value returned by the original function
            return returnVal;
        };

        notifyFunc._isObservation = true;
        notifyFunc._fullName = methodName + "Observation";
        notifyFunc._origMethodSlot = isc._obsPrefix + methodName;

        // hang a pointer to the correct isc object onto the function in Safari.
        if (isc.Browser.isSafari) notifyFunc._ns = isc;

        return notifyFunc;
    },

    _makeThunkFunction : function (argString, action) {
        if (argString == null) argString = isc._emptyString;

        var code = "var observer = arguments.callee.caller._observer, it = observer, observed = this, returnVal = arguments.callee.caller._returnVal;\n";
        code += action;

        var cache = isc.Class._actionRunnerCache[argString];
        if (cache == null) cache = isc.Class._actionRunnerCache[argString] = {};
        var actionRunner = cache[action];
        if (actionRunner == null) {
            actionRunner = cache[action] = isc._makeFunction(argString, code);
            actionRunner._argString = argString;
        }

        return function thunk() {
            actionRunner.apply(arguments.callee._observed, arguments);
        };
    },




    _assert : function (b, message) {
        if (!b) {

            isc.logWarn("assertion failed" +
                        (message ? " with message: '" + message + "'" : "") +
                        ". Stack trace:" + (isc.Class.getStackTrace()));
            throw (message || "assertion failed");
        }
    }

});    // END addClassMethods(isc.Class)



isc.Class.addClassMethods({
    // synonym for backwards compatibility
    newInstance : isc.Class.create
});

// make the isc namespace available on all Class objects
isc.Class.ns = isc;

// retrofit the ClassFactory
isc.addProperties(isc.ClassFactory, {
    ns : isc,
    getWindow : isc.Class.getWindow,
    getDocument : isc.Class.getDocument
});

//
//    add methods to all instances of any Class or subclass
//
isc.Class.addMethods({
    //>    @method    class.init()    (A)
    //
    // Initialize a new instance of this Class.  This method is called automatically by
    // +link{Class.create()}.
    // <p>
    // Override this method to provide initialization logic for your class.  If your class is
    // a subclass of a UI component (i.e. descendant of +link{Canvas}), override
    // +link{canvas.initWidget()} instead.
    //
    // @param    [arguments 0-N] (any)    All arguments initially passed to +link{Class.create()}
    //
    // @visibility external
    //<
    init : function () {},

    // class-level destructor - call via Super() from any subclass
    //> @method class.destroy()    (A)
    // Permanently destroy a class instance and any automatically created resources,
    // recursively.
    // @see canvas.destroy()
    // @see group:memoryLeaks
    // @visibility external
    //<
    destroy : function (A,B,C,D,E,F,G,H,I,J,K,L,M) {
        var classObj = this.getClass();

        // call destroyInterface() on any member interfaces that define the method
        if (classObj._destroyInterfaceMethods) {
            for (var i = 0; i < classObj._destroyInterfaceMethods.length; i++) {
                classObj._destroyInterfaceMethods[i].call(this, A,B,C,D,E,F,G,H,I,J,K,L,M);
            }
        }

        // destroy any SGWT object wrapping this JS object

        var sgwtDestroy = this.__sgwtDestroy;
        if (sgwtDestroy) {
            delete this.__sgwtDestroy;
            sgwtDestroy.apply(this);
        }
    },

    //> @attr class.addPropertiesOnCreate (Boolean : undefined : RA)
    // Controls whether arguments passed to +link{classMethod:Class.create()} are assumed to be
    // Objects containing properties that should be added to the newly created instance.  This
    // behavior is how <code>create()</code> works with almost all SmartClient widgets and
    // other components, allowing the convenient shorthand of setting a batch of properties via
    // an +link{type:ObjectLiteral,JavaScript Object Literal} passed to create().
    // <P>
    // The setting defaults to true if unset.  To disable this behavior for a custom class,
    // such that <code>create()</code> works more like typical constructors found in Java and
    // other languages, use:
    // <pre>
    //     isc.[i]ClassName[/i].addProperties({ addPropertiesOnCreate:false })
    // </pre>
    // <P>
    // Note that it is not valid to disable this behavior for any subclass of +link{Canvas}
    // (Canvas relies on this property).
    // <p>
    // Regardless of the setting for <code>addPropertiesOnCreate</code>, all arguments passed to
    // +link{Class.create()} are still passed on to +link{Class.init()}.
    //
    // @visibility external
    //<


    completeCreation : function (A,B,C,D,E,F,G,H,I,J,K,L,M) {
        //!OBFUSCATEOK


        var       level = isc.createLevel;
        isc.createLevel = isc.keepGlobals ? (level == null ? 1 : level + 1) : null;


        //>EditMode
        var captureDefaults = isc.captureDefaults;
        if (captureDefaults) isc.captureDefaults = false;
        //<EditMode



        if (this.addPropertiesOnCreate != false) {
            //>EditMode capture clean initialization data, and don't construct the actual
            // instance.  This is used to load a set of components for editing.  NOTE:
            // currently only applies to classes that addPropertiesOnCreate (which includes
            // all Canvas subclasses)
            if (captureDefaults) {

                var component = {
                    type: this.Class,
                    defaults: isc.addProperties({}, A,B,C,D,E,F,G,H,I,J,K,L,M)
                }
                if (!isc.capturedComponents) isc.capturedComponents = [];
                isc.capturedComponents.add(component);

                if (component.defaults.ID) {
                    isc.ClassFactory.addGlobalID(component, component.defaults.ID);
                    //isc.Log.logWarn("adding global component: " + component.defaults.ID);
                }

                // restore original value of isc.captureDefaults
                if (captureDefaults) isc.captureDefaults = true;
                // restore original value of isc.createLevel
                isc.createLevel = level;

                return component;
            }
            //<EditMode

            isc.addProperties(this, A,B,C,D,E,F,G,H,I,J,K,L,M);
        }

        var classObj = this.getClass(),
            dupProps = classObj._dupAttrs;
        if (dupProps != null) {
            for (var i = 0; i < dupProps.length; i++) {
                var prop = dupProps[i];
                if (this[prop] == classObj._instancePrototype[prop]) {
                    this[prop] = classObj.cloneDupPropertyValue(prop, this[prop]);
                }
            }
        }

        // call initInterface() on any member interfaces that define the method
        if (classObj._initInterfaceMethods) {
            for (var i = 0; i < classObj._initInterfaceMethods.length; i++) {
                classObj._initInterfaceMethods[i].call(this, A,B,C,D,E,F,G,H,I,J,K,L,M);
            }
        }

        // call the init() routine on the new instance
        this.init(A,B,C,D,E,F,G,H,I,J,K,L,M);

        if (this.autoDupMethods) {
            isc.Class.duplicateMethods(this, this.autoDupMethods);
        }

        //>EditMode restore original value of isc.captureDefaults
        if (captureDefaults) isc.captureDefaults = true;
        //<EditMode
        // restore original value of isc.createLevel
        isc.createLevel = level;

        return this;
    },

    // instance-level auto-dups
    //autoDupMethods: [ "fireCallback", "Super", "invokeSuper", "getInnerHTML" ],
    duplicateMethod : function (methodName) {
        isc.Class.duplicateMethod(methodName, this);
    },

    //>    @method    class.getUniqueProperties
    //
    //    Gets all non-internal properties that are the different between this object and its
    //  prototype and returns a new object with those properties.
    //
    //    NOTE: this will also skip an object ID (object.ID)
    //        if it starts with our auto-generated ID string ("isc_OID_")
    //
    //    NOTE: if your object points to some complex object, the clone will pick that up... :-(
    //
    //    @param    [returnProperties]    (object)    If passed in, properties will be added to this object.
    //                                            If not passed, a new object will be created.
    //    @return (Object)    unique properties for this object
    //<
    // NOTE: not external because lots of random state is picked up, and lots of important
    // state is discarded.
    getUniqueProperties : function (returnProperties) {
        if (returnProperties == null) returnProperties = {};

        var proto = this.getPrototype();

        for (var property in this) {
            // ignore internal properties
            if (property.startsWith("_")) continue;

            // ignore the namespace pointer installed on every instance
            if (property == "ns") continue;

            // ignore ID if it's auto-generated
            if (property == "ID" && this.ID.startsWith("isc_OID_")) continue;

            var value = this[property];

            // don't pick up functions (NOTE: we probably don't want to try to serialize
            // functions in general, or at least, that would be a very advanced and separate
            // serialization system.  Also, note that if we don't ignore functions, we'd pick
            // up observations since observations replace the original function)
            if (isc.isA.Function(value)) continue;

            // if the property still has the default value for the class, ignore it
            if (value != proto[property]) {
                /*
                if (proto[property] != null) {
                    this.logWarn("property: " + property + ": value " +
                                 this.echoLeaf(this[property]) +
                                 " !== proto value " +
                                 this.echoLeaf(proto[property]));
                }
                */
                returnProperties[property] = this[property];
            }
        }
        return returnProperties;
    },

    //>    @method    class.clone
    //
    // Make a clone of this instance.
    // Gets all non-internal properties that are the different between this object and its
    // prototype and creates a new instance with those properties
    //
    //    NOTE: if your object points to some complex object, the clone will pick that up... :-(
    //
    //    @return (Class)    clone of this class
    //<
    // NOTE: not external because this doesn't work for almost all widgets and has many issues
    // before it could be supported (eg what to do with shared data models?)
    clone : function () {
        return this.getClass().create(this.getUniqueProperties());
    },

    // NOTE: not external.  Need to define what this should do, eg, just a dump of state for
    // debugging vs recreate component in current state / transmit between browsers
    serialize : function (indent) {
        return isc.Comm.serialize(this, indent);
    },

    xmlSerialize : function (indent) {
        return isc.Comm.xmlSerialize(this.getClassName(), this, indent);
    },

    // get the fields
    getSerializeableFields : function (removeFields, keepFields) {
        // see if we can obtain a schema for this class.  If a schema is available,
        // we'll use it to filter the set of fields that are serializeable.
        var schema = isc.DS ? isc.DS.getNearestSchema(this) : null;

        var uniqueProperties = this.getUniqueProperties();

        // instead of bailing out limit to simple types only?
        if (schema == null) {
            this.logDebug("No schema available for class" + this.getClassName());
            return uniqueProperties;
        } else {
            this.logDebug("Constraining serializeable fields for class: " + this.getClassName()
                          + " with schema : " + schema.ID);
        }

        // the list of valid fields is the intersection of datasource-declared fields and unique
        // properties.  This ensures that we don't pick up fields that are really internal
        // (e.g. starting with underscore)
        var serializeableFields = isc.applyMask(uniqueProperties, schema.getFields());

        // removeFields and keepFields are Arrays of fieldNames that subclasses can modify
        // before calling Super in order to suppress or keep fields
        removeFields = removeFields || [];
        keepFields = keepFields || [];

        // strip removeFields from the set of serializeable fields.
        removeFields.map(function(arg) { delete serializeableFields[arg]; });

        // ensure that the fields that specifically requested are in
        for (var i = 0; i < keepFields.length; i++) {
            serializeableFields[keepFields[i]] = this[keepFields[i]];
        }

        return serializeableFields;
    },

    //>    @method    class.getID()
    //            Return the global identifier for this object.
    //
    //        @return    (string)    global identifier for this canvas
    // @visibility external
    //<
    getID : function () {
        return this.ID;
    },

    //>    @method    class.getClass()
    //
    //    Gets a pointer to the class object for this instance
    //
    //    @return (Class)        Class object that was used to construct this object
    // @visibility external
    //<
    getClass : function () {
        return this._classObject;
    },


    //>    @method    class.getSuperClass()
    //
    //    Gets a pointer to the class object for this instance's superclass.
    //
    //    @return (Class)        Class object for superclass.
    // @visibility external
    //<
    getSuperClass : function () {
        return this._classObject._superClass;
    },


    //>    @method    class.getClassName()
    //
    //    Gets the name of this class as a string.
    //
    //    @return    (string)    String name of this instance's Class object.
    // @visibility external
    //<
    getClassName : function () {
        return this.getClass().getClassName();
    },

    //> @method Class.getScClassName()
    //
    //  Gets the name of this class as a string, if the class is a SmartClient Framework class.
    //  Otherwise, gets the name of the SmartClient Framework class which this class extends.
    //
    //  @return (string) name of the SmartClient Framework class
    //<
    getScClassName : function () {
        return this.getClass().getScClassName();
    },

    //>    @method    class.getPrototype()    (A)
    //
    //    Gets a pointer to the prototype of this instance.
    //
    //    @return (object)    prototype object for this instance
    //<
    getPrototype : function () {
        return this._scPrototype;
    },


    //>    @method    class.getGlobalReference()    (A)
    //
    //    Evaluate a reference in the global scope.  Within the eval,
    //        "this" will be a pointer to this instance.
    //
    //    @param    reference    (string)    String to get the reference from.  If anything other than
    //                                     a string is passed in, simply returns reference.
    //    @return (reference)        reference to evaluate
    //<
    getGlobalReference : function (reference) {
        //!OBFUSCATEOK
        if (typeof reference == "string") return this.evaluate(reference);
        return reference;
    },

    //>    @method    class.addMethods()
    //
    //    Add methods to this specific instance.  These can either be completely new methods or can
    //    have the same name as existing methods, in which case the new methods will override the
    //    existing methods.
    //
    // @param [arguments 0-N] (object)    Object containing name:method pairs to be added to this object
    // @return                (object)  the object after methods have been added to it
    // @visibility internal
    //<

    addMethods : function () {

        for (var i = 0; i < arguments.length; i++) {
            // call global addMethods()
            return isc.addMethods(this, arguments[i]);
        }
    },

    //>    @method    class.addProperties()
    //
    //     Add properties or methods to this specific instance.
    //    Properties with the same name as existing properties will override.
    //
    //  @see classMethod:Class.addProperties()
    //  @see isc.addProperties()
    //
    //    @param    [arguments 0-N] (object)    Object containing name:value pairs to be added to this object
    //  @return                 (object)    the object after properties have been added to it
    // @visibility external
    //<
    addProperties : function () {
        return isc.addPropertyList(this, arguments);
    },

    //>    @method    class.addPropertyList()
    //
    //    Add properties to this instance.
    //
    //    @param    list (object[])        array of objects with properties to add
    //  @return                 (object)    the object after properties have been added to it
    // @visibility external
    //<
    addPropertyList : function (list) {
        return isc.addPropertyList(this, list);
    },

    // Get / Set with automatic getter/setter
    // ---------------------------------------------------------------------------------------

    //>    @method    class._getSetter()    (A)
    //
    //    Get the setter for a particular property, if one exists
    //
    //    @param    propertyName (string)    name of the property to find the setter for
    //                                    eg: if propertyName == "contents", setter == "setContents"
    //
    //    @return    (string)                name of the setter for the property, or null if none found
    //
    //<
    _getSetter : function (propertyName) {
        var functionName = "set" + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
        return (isc.isA.Function(this[functionName]) ? functionName : null);
    },

    //>    @method    class._getGetter()    (A)
    //
    //    Get the getter for a particular property, if one exists
    //
    //    @param    propertyName (string)    name of the property to find the getter for
    //                                    eg: if propertyName == "contents", getter == "getContents"
    //
    //    @return    (string)                name of the getter for the property, or null if none found
    //
    //<
    _getGetter : function (propertyName) {
        var functionName = "get" + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
        return (isc.isA.Function(this[functionName]) ? functionName : null);
    },

    //>    @method    class.setProperty()
    // Set a property on this object, calling the setter method if it exists.
    // <p>
    // Whenever you set a property on an ISC component, you should call either the specific setter
    // for that property, or <code>setProperty()/setProperties()</code> if it doesn't have one.
    // This future-proofs your code against the later addition of required setters.
    //
    // @param propertyName (String) name of the property to set
    // @param newValue (any) new value for the property
    // @see method:class.setProperties()
    // @visibility external
    //<
    setProperty : function (propertyName, newValue) {
        // NOTE: this is inefficient but unlikely to be called very often, and doing it this way
        // means subclasses can override just setProperties()
        var props = {};
        props[propertyName] = newValue;
        this.setProperties(props);
    },

    //>    @method    class.setProperties()
    // Set multiple properties on an object, calling the appropriate setter methods if any are
    // found.
    // <p>
    // Whenever you set a property on an ISC component, you should call either the specific setter
    // for that property, or <code>setProperty()/setProperties()</code> if it doesn't have one.
    // This future-proofs your code against the later addition of required setters.
    // <p>
    // With <code>setProperties()</code> in particular, some classes may be able to take shortcuts
    // and be more efficient when 2 or more related properties are set at the same time.
    //
    //    @param    [arguments 0-N] (object)    objects with properties to add (think named parameters).
    //                                        all the properties of each argument will be applied one
    //                                        after another so later properties will override
    // @see method:class.setProperty()
    //  @visibility external
    //<
    setProperties : function () {

        var isA = isc.isA,
            propertyBlock,
            additionalProps = {};

        // if not passed any properties arguments, just bail
        if (arguments.length < 1) return;

        // Iterate through the (possibly just one) properties, combining them into a single
        // object.  We do this to avoid duplicate calls to setters, although another approach
        // would be to keep a mask of the properties we've set, starting from the last argument
        // to the first.
        if (arguments.length == 1) {
            propertyBlock = arguments[0];
            if (propertyBlock == null) return;
        } else {
            propertyBlock = {};

            for (var i = 0; i< arguments.length; i++) {
                isc.addProperties(propertyBlock, arguments[i]);
            }
        }

        for (var propertyName in propertyBlock) {
            var value = propertyBlock[propertyName],
                setter = this._getSetter(propertyName);
            if (isc.isA.StringMethod(value)) value = value.getValue();
            //this.logWarn("setting property: " + propertyName +
            //             " to value: " + this.echoLeaf(value) +
            //             " via setter: " + this.echoLeaf(setter));
            if (setter) {
                this[setter](value);
                if (this.propertyChanged) this.propertyChanged(propertyName, value);
            } else {
                additionalProps[propertyName] = value;
            }
        }
        // add any remaining properties via addProperties (will fall through to addMethods if
        // necessary)
        this.addProperties(additionalProps)

        // Fire the notification function for any properties that didn't have an explicit
        // setter
        if (this.propertyChanged) {
            for (var propertyName in additionalProps) {
                this.propertyChanged(propertyName, additionalProps[propertyName]);
            }
        }

        // Fire any "doneSettingProperties()" - allows the instance to respond to multiple
        // related properties being set without having to respond to each one.
        if (this.doneSettingProperties) this.doneSettingProperties(propertyBlock);
    },


    getProperty : function (propName) {
        var getter = this._getGetter(propName);
        if (getter) return this[getter]();
        return this[propName];
    },
    getPropertyValue : function (propName) {
        var getter = this._getGetter(propName);
        if (getter) return this[getter]();
        return this[propName];
    },


    //> @type Properties
    // When the type for a parameter mentions "properties" as in "ListGrid Properties" or
    // "RPCRequest Properties", it means that the expected value is a JavaScript Object
    // containing any set of properties generally legal when creating an object of that type.
    // <P>
    // For example, the first parameter of +link{RPCManager.sendRequest()} is of type
    // "RPCRequest Properties".  This means it should be called like:
    // <pre>
    //    isc.RPCManager.sendRequest({
    //        actionURL : "/foo.do",
    //        showPrompt:false
    //    });</pre>
    // +link{rpcRequest.actionURL,actionURL} and +link{rpcRequest.showPrompt,showPrompt} are
    // properties of +link{RPCRequest}.
    // <P>
    // Note that the notation shown above is an example of a
    // +link{type:ObjectLiteral,JavaScript object literal}.
    //
    // @visibility external
    //<

    //> @type ObjectLiteral
    // An "Object literal" is JavaScript shorthand for defining a JavaScript Object with a set
    // of properties.  For example, code like this:
    // <pre>
    //    var request = {
    //        actionURL : "/foo.do",
    //        showPrompt:false
    //    };</pre>
    // .. is equivalent to ..
    // <pre>
    //    var request = new Object();
    //    request.actionURL = "/foo.do";
    //    request.showPrompt = false;</pre>
    // In situations where a set of +link{type:Properties,properties} may be passed to a
    // method, the Object literal notation is much more compact.  For example:
    // <pre>
    //    isc.RPCManager.sendRequest({
    //        actionURL : "/foo.do",
    //        showPrompt:false
    //    });</pre>
    // <b>NOTE:</b> if you have a 'trailing comma' in an object literal, like so:
    // <pre>
    //    var request = {
    //        actionURL : "/foo.do",
    //        showPrompt:false, // TRAILING COMMA
    //    };</pre>
    // This is considered a syntax error by Internet Explorer, but not by Firefox.  This is by
    // far the #1 cause of Internet Explorer-specific errors that do not occur in other
    // browsers.  Pay special attention to this error, and, if you can, install the
    // JSSyntaxScannerFilter into your development environment (as described in the
    // +link{group:iscInstall,deployment instructions}).
    //
    // @visibility external
    //<

    // ---------------------------------------------------------------------------------------

    // useful for cascading defaults where 0 or "" is allowed so the pattern of
    // "value1 || value2 || value3" won't work.

    _firstNonNull : function (a,b,c,d,e,f) {
        return a != null ? a :
                (b != null ? b :
                    (c != null ? c :
                        (d != null ? d :
                            (e != null ? e : f)
                        )
                    )
                );
    },

    //>    @method    class.isA()
    //
    //    Returns whether this object is of a particular class by class name, either as a direct
    //    instance of that class or as subclass of that class, or by implementing an interface
    //  that has been mixed into the class.<br><br>
    //
    //    NOTE: this only applies to ISC's class system, eg:  <code>myInstance.isA("Object")</code> will be
    //    false.
    //
    //    @param    className    (string)    Class name to test against
    //
    //    @return                (boolean)    whether this object is of that Class
    //                                  or a subClass of that Class
    // @visibility external
    //<
    isA : function (className) {
        if (this.getClass().isA(className)) {
            return true;
        } else {
            // If not, also check the SGWT side
            if (this.getSGWTFactory) {
                var factory = this.getSGWTFactory();
                if (factory) return factory.isA(className);
            }
        }
        return false;
    },



    //> @groupDef stringMethods
    //
    // A method flagged as a String Method can be specified as a String containing a valid
    // JavaScript expression.  This expression will automatically be converted to a function with a
    // return value matching the value of the last statement.  Providing a String is not required -
    // you may use a real function instead.
    // <p>
    // For example - suppose you wanted to override the <code>leafClick()</code> method on
    // the TreeGrid.  Normally you would do so as follows:<br>
    //
    // <pre>
    // TreeGrid.create({
    //     ...
    //     leafClick : function(viewer, leaf, recordNum) {
    //         if(leaf.name == 'zoo') {
    //             alert(1);
    //         } else {
    //             alert(2);
    //         }
    //     }
    // });
    // </pre>
    //
    // Since leafClick is a stringMethod, however, you can shorten this to:<br>
    // <pre>
    // TreeGrid.create({
    //     ...
    //     leafClick : "if(leaf.name == 'zoo') { alert(1); } else { alert(2); }";
    // });
    // </pre>
    //
    // @title String Methods Overview
    // @treeLocation Client Reference/System
    //<

    //> @groupDef flags
    //
    // <ul>
    // <li> <b>I</b>: property can be initialized (provided in constructor block)
    // <li> <b>R</b>: property can be read.  If a getter method exists, it must be called.
    // <li> <b>W</b>: property can be written to after initialization.  If a setter method
    // exists, it must be called.  If no setter method exists,
    // +link{Class.setProperty,setProperty()} must be called.
    // </ul>
    //
    // @title Flag Abbreviations
    //<



    // Observation
    // ---------------------------------------------------------------------------------------

    //> @groupDef observation
    // Observation is the ability to take an action whenever a method is called.
    // @title Observation
    //<

    //>    @method        class.observe()
    // Take an arbitrary action whenever a method is called on an instance.<br><br>
    //
    // When you observe some method of another object, eg:<br>
    //            <code>thisObject.observe(thatObject, "someMethod", "observer.foo()")</code><br><br>
    //
    // When <code>thatObject.someMethod()</code> is called,<br>
    //            <code>thisObject.foo()</code> <br>
    // will be called automatically, after the observed method completes.<br><br>
    //
    // Action is typically a string expression.  Available variables:
    // <ul>
    //    <li> observed: target of the observation, that is, object passed to observe()
    //    <li> observer: object that observes, that is, object that observe() was called on
    //    <li> returnVal: return value of observed function
    // </ul>
    //
    // An unlimited number of observers can observe any message, they will all be notified
    // automatically in the order that the observations were set up.<br><br>
    //
    // NOTES:
    // - observation also works on JavaScript Array objects
    // - a method may trigger an observation of itself by another object, either through code
    //   within the method itself or within an observer's action.  In this case the observation
    //   will be set up, but the new observation action will not fire as part of this thread.
    //   When the method is called again in the future the newly added observer will be fired.
    //
    //
    //        @param    object        (object)    object to observe
    //        @param    methodName    (string)    name of the method to observe
    //        @param    [action]    (string)    String for the function to call.
    //                                        In this string,
    //                                            <code>observer</code> is the object that is observing,
    //                                            <code>this</code> is the object that is being observed
    //
    //                                        If <code>action</code> is not specified,
    //                                            <code>observer.methodName()</code> will be called.
    //
    //        @return    (boolean)    true == observation set up, false == observation not set up
    //      @see Class.ignore()
    //        @group    observation
    // @visibility external
    //<



    observe : function (object, methodName, action) {
        // if the object doesn't exist or doesn't implement a method with this name, return false to
        // indicate that the observation isn't going to work
        if (object == null) {
            //>DEBUG
            this.logWarn("Invalid observation: Target is not an object.  target: " + object +
                         ", methodName: " + methodName + ", action: '" + action + "'");
            //<DEBUG
            return false;
        }

        // If this property is not a method, or a methodString, log a warning and return false
        //  Note: we're calling the static isc.Func.convertToMethod(...) as we know this
        //  function exists and will return false if the object's class, and the object have
        //   no methodStringRegistry.
        if (!isc.Func.convertToMethod(object, methodName)) {
            //>DEBUG
            this.logWarn("Invalid observation: property: '" + methodName +
                         "' is not a method on " + object);
            //<DEBUG
            return false;
        }
        //this.logWarn("observing: " + methodName + " on " + object + " with action: " + action);

        // If this function has an obfuscated version, observe that also
        var obName = isc.__remap[methodName];
        if (object[obName]) this.observe(object, obName, action)

        // Now we're definitely working with a method
        var oldMethod = object[methodName], argStr;
        if (isc.isAn.Instance(object) && object.getClass().getInstanceProperty(methodName)) {
            argStr = object.getClass().getArgString(methodName);
        // NOTE: currently, there's no such thing as a classMethod that is a stringMethod
        } else {
            // this code path is needed for two cases:
            // * methods set in autoChildDefaults (caught by getInstanceProperty)
            // * class methods (caught by isAn.Instance())
            argStr = isc.Func.getArgString(oldMethod);
        }
        var args = argStr.split(",");

        // if no action was defined, set it to call the method on the target
        if (action == null || isc.is.emptyString(action)) {
            if (!this[methodName] || !this.convertToMethod(methodName)){
                //>DEBUG
                this.logWarn("Invalid Observation - no action specified, and observer: " + this +
                            " has no method '" + methodName + "', ignoring");
                //<DEBUG
                return false;
            }
            action = "it." + methodName + "(" + argStr + ")";
        }

        if (!isc.isA.Function(action)) {
            action = isc.Class._makeThunkFunction(argStr, action);
        }

        action._argString = argStr;

        //
        // add the observer and action to the object's observers list
        //

        // if there is no observers registry set up, create it.
        // object._observers is { methodName :
        //                           [{target:observingObject, action:codeString}]
        //                      }
        if (!object._observers) object._observers = {};

        // if there is not an observer queue for the method, create it
        if (!object._observers[methodName]) {
            var queue = object._observers[methodName] = [];
            if (args.length > 0) {
                // remember the args to the function for later
                queue.argStr = argStr;
            }
        // otherwise
        } else {
            // get the observer queue: the list of existing observers of this method
            var queue = object._observers[methodName];
            // see if this object is already observing this method
            for (var i = 0, len = queue.length; i < len; i++) {
                var q = queue[i];
                // if this object is found in the queue, return false since we're already observing
                // this method
                if (q.target == this) {
                    if (q._removedWhileNotificationRunning &&
                        !q._addedWhileNotificationRunning)
                    {
                        // special case: this observation was already ignored, but a re-
                        // observation is being done from inside the notified function.
                        // Disable _removedWhileNotificationRunning and update the
                        // action.
                        q._removedWhileNotificationRunning = false;
                        q._addedWhileNotificationRunning = true;
                        q.action = action;
                        return true;
                    }
                    //>DEBUG
                    this.logWarn("Observer: " + this + " is already observing method '" +
                                 methodName + "' on object '" + object + "', ignoring");
                    //<DEBUG
                    return false;
                }
            }
        }

        // Note whether we're currently running the notification function.

        var notificationRunning = !!queue._notifyStack;

        // add a reference to the observer to the observer queue for the method
        var q = {
            target: this,
            action: action,
            // Track whether this method was added while the notification function was
            // running - this allows us to avoid running this observer action until
            // after the method has completed.
            _addedWhileNotificationRunning: notificationRunning
        };
        queue.add(q);

        // get the name we're going to hide the original method under.  NOTE: important to name
        // this with a leading underscore, so getUniqueProperties ignores it.
        var saveMethodName = isc._obsPrefix + methodName;
        // if the object already has a method by that name, the same method we're trying to
        // observe is being observed by someone else.  We'll both call the original method by
        // the same name.
        if (object[saveMethodName] == null) {
            object[saveMethodName] = oldMethod;

        // If we are already observing the method,
        // if the slot contains a method that isn't a notification method, log a warning and
        // copy the new method into the 'saveMethodName' slot. This will happen if a developer
        // does someObject.methodName = function () {...} rather than using addProperties on
        // a method that is already being observed.
        } else if (!object[methodName]._isObservation) {
            this.logWarn("Observation error: method " + methodName
                + " is being observed on object " + object + " but the function appears to have "
                + "been directly overridden. This may lead to unexpected behavior - to avoid "
                + "seeing this message in the future, ensure the addMethods() or addProperties() "
                + "API is used to modify methods on live SmartClient instances, rather than simply "
                + "reassigning the method name to a new function instance.");
            object[saveMethodName] = object[methodName];
        }

        // replace the observed method with a new function that will call the original method
        // then call all the observers
        if (!notificationRunning && !object[methodName]._isObservation) {
            object[methodName] = isc.Class._makeNotifyFunction(methodName);
        }

        // return true that everything went OK
        return true;
    },

    //>    @method        class.ignore()    (A)
    //        Stop observing a method on some other object.
    //
    //        @param    object        (object)    object to observe
    //        @param    methodName    (string)    name of the method to ignore
    //
    //        @return    (boolean)    true == observation stopped, false == no change made
    //      @see Class.observe()
    //        @group    observation
    // @visibility external
    //<
    ignore : function (object, methodName) {
        var undef;
        // also ignore the obfuscated version if present
        var obName = isc.__remap[methodName];
        if (obName !== undef && object[obName]) this.ignore(object, obName);

        // get the name we would have squirreled the original method under
        var saveMethodName = isc._obsPrefix+methodName;
        // and if we can't find a method with that name, or the object has no observers
        //    return false to indicate that the object isn't currently being observed on this method
        if (!object[saveMethodName] || !object._observers) return false;

        // get a pointer to the message queue for the method
        var queue = object._observers[methodName],

            // Note: if the the observed function is currently being run, we want the observer
            // action to fire as normal in response to this thread, but not for subsequent
            // calls to the observed method.
            // To achieve this, we flag the observer action, then clear it out of the queue
            // when the observed method (actually the notification method) completes.

            notificationRunning = queue._notifyStack;


        // remove the object in the queue that points to this object
        var q;
        for (var i = 0, len = queue.length; i < len; i++) {
            q = queue[i];
            if (q.target == this) {

                if (notificationRunning) {
                    q._removedWhileNotificationRunning = true;
                } else {
                    queue.removeAt(i);
                }

                break;
            }
        }

        // if we've removed everything from the queue
        // restore the original method

        // Note - if the slot contains a non-notification function we're in an invalid state.
        // Basically this implies the developer clobbered the notification function by going
        //  someObject.methodName = function () {...}
        // on a method that was currently being observed.
        // Warn when we see this case, and assume the current function should be preserved if
        // possible.
        if (!object[methodName] || !object[methodName]._isObservation) {
            this.logWarn("Observation error caught in ignore(): Method " + methodName
                + " was being observed on object " + object + " but the function appears to have "
                + "been directly overridden. This may lead to unexpected behavior - to avoid "
                + "seeing this message in the future, ensure the addMethods() or addProperties() "
                + "API is used to modify methods on live SmartClient instances, rather than simply "
                + "reassigning the method name to a new function instance.");
            object[saveMethodName] = object[methodName];
        }

        if (queue.length == 0) {
            // restore the original function to its original name
            object[methodName] = object[saveMethodName];
            // clear the new method slot
            delete object[saveMethodName];
            // remove the observer queue
            delete object._observers[methodName];
        }

        // return true that everything went OK
        return true;
    },

    //>    @method        class.getObserversOf()    (A)
    //        @group    observation
    //            Return all targets observing a message of this object
    //
    //        @param    methodName    (string)    name of the method to observed
    //
    //        @return    (object[])    array of observing objects
    //<
    getObserversOf : function (methodName) {
        if (!this._observers || !this._observers[methodName]) return null;
        var queue = this._observers[methodName];
        for (var observers = [], i = 0; i < queue.length; i++) {
            observers[i] = (queue[i] ? queue[i].target : null);
        }
        return observers;
    },

    //>    @method        class.isObserving()    (A)
    //        @group    observation
    //        Return true if this object is already observing a method of another object
    //
    //        @param    object        (object)    object we may be observing
    //        @param    methodName    (string)    name of the method to observed
    //
    //        @return    (boolean)    true == already observing that method
    // @visibility external
    //<
    isObserving : function (object, methodName) {
        // if nothing is being observed on the object at all, forget it
        if (!object._observers) return false;

        // get the queue of observers of that method, bailing if none found
        var queue = object._observers[methodName];
        if (!queue) return false;

        // return true if we are one of the observers
        for (var i = 0; i < queue.length; i++) {
            if (queue[i].target == this) return true;
        }
        // otherwise return false 'cause we're not observing
        return false;
    },

    //>    @method    class.convertToMethod()
    //
    //    This takes the name of an instance property as a parameter, and (if legal) attempts to
    //  convert the property to a function.
    //  If the property's value is a function already, or the property is registered via
    //  class.registerStringMethods() as being a legitimate target to convert to a function,
    //  return true.
    //  Otherwise return false
    //
    //    @param    functionName     (string)    name of the property to convert to a string.
    //
    //    @return                    (boolean)   false if this is not a function and cannot be converted
    //                                      to one
    //
    //<
    convertToMethod : function (methodName) {
        // accessor for isc.Func.convertToMethod, rather than duplicating that code
        return isc.Func.convertToMethod(this, methodName);
    },

    //> @method class.evaluate()
    //
    // Evaluate a string of script in the scope of this instance (so <code>this</code>
    // is available as a pointer to the instance).
    //
    // @param expression (string) the expression to be evaluated
    // @param evalArgs (object) Optional mapping of argument names to values - each key will
    //      be available as a local variable when the script is executed.
    // @return (any) the result of the eval
    // @see classMethod:Class.evaluate
    // @visibility external
    //<
    evaluate : function (expression, evalVars) {
        return isc.Class.evaluate.apply(this, [expression, evalVars]);
    },


    //>    @method    class.fireCallback()
    //
    //    Method to fire a callback. Callback will be fired in the scope of the object on
    //  which this method is called.<br>
    //  Falls through to +link{classMethod:Class.fireCallback()}
    //
    //    @param    callback    (Callback) Callback to fire
    //  @param  [argNames]        (string)    comma separated string of variables
    //  @param  [args]            (array)     array of arguments to pass to the method
    //
    //  @return (any)   returns the value returned by the callback method passed in.
    //  @visibility external
    //<

    fireCallback : function (callback, argNames, args, catchErrors) {

        return this.getClass().fireCallback(callback, argNames, args, this, catchErrors);
    },

    //> @method class.delayCall()
    //  This is a helper to delay a call to some method on this object by some specified
    //  amount of time.
    // @param methodName (string) name of the method to call
    // @param [arrayArgs] (array) array of arguments to pass to the method in question
    // @param [time] (number) Number of ms to delay the call by - defaults to zero (so just pulls
    //                        execution of the method out of the current execution thread.
    // @return (string) Timer ID for the delayed call - can be passed to
    //                      +link{Timer.clear()} to cancel the call before it executes
    // @visibility external
    //<
    delayCall : function (methodName, arrayArgs, time) {
        return this.getClass().delayCall(methodName, arrayArgs, time, this);
    },


    //> @method Class.fireOnPause()
    // Given some repeatedly performed event (EG keypress, scroll, etc), set up an action
    // to fire when the events have stopped occurring for some set period.
    // @param id (string) arbitrary identifier for the action
    // @param callback (callback) action to fire on quiescence
    // @param [delay] (number) delay in ms - defaults to 200ms
    //<
    fireOnPause : function (id, callback, delay) {
        return this.getClass().fireOnPause(id, callback, delay, this, this.getID());
    },

    //> @method Class.pendingActionOnPause()
    // Returns true iff an action has been scheduled by fireOnPause() to fire when
    // events have stopped occurring for some set period,
    // @param id (string) arbitrary identifier for the action
    //<
    pendingActionOnPause : function (id) {
        var actions = this.getClass()._actionsOnPause[id],
            instanceID = this.getID() || this.getClassName();
        return actions ? !!actions[instanceID] : false;
    },

    //> @method Class.cancelActionOnPause()
    // Canels a pending action that has already been scheduled.
    // @param id (string) arbitrary identifier for the action
    //<

    cancelActionOnPause : function (id) {
        var actions = this.getClass()._actionsOnPause[id],
            instanceID = this.getID() || this.getClassName();
        if (actions[instanceID]) delete actions[instanceID];
    },

    //>    @method    class.evalWithVars()
    //
    // Same as the class method evalWithVars, but implicitly assigns the class on which this method
    // is called as the target.
    //
    // @see classMethod:Class.evalWithVars()
    //<
    evalWithVars : function (evalString, evalVars) {
        return isc.Class.evalWithVars(evalString, evalVars, this);
    },

    getWindow : (
        isc.Browser.isSafari ? function () {
            return window;
        } : function () {
            return this.ns._window;
        }
    ),
    getDocument : (
        isc.Browser.isSafari ? function () {
            return window.document;
        } : function () {
            return this.ns._document;
        }
    ),
    getDocumentBody : function (suppressDocElement) { return isc.Class.getDocumentBody(suppressDocElement); },
    getActiveElement : function () { return isc.Class.getActiveElement(); },

    // Auto Generated Named Children
    // ---------------------------------------------------------------------------------------
    // Subsystem for handling automatically creating the standard children of a compound widget
    // like a Window, which must create header, resizer, etc components.
    //
    // Not fully worked out or mechanisms not documented:
    // - dynamic defaults
    //   - creation via Arrays of String like (window.headerControls) prevents dynamic defaults
    //     from being passed
    //     - could be solved by a registerDynamicDefaults(autoChildName, defaults)
    //   - no way for subclasses to override dynamically provided defaults
    //     - could be solved by a registerDynamicDefaults(autoChildName, defaults, this.Class),
    //       where addAutoChild would traverse registered defaults in className order?
    //   - passthrough properties that are just renames should be declarative, not dynamic
    //     defaults.  Could have a special syntax, valid only for defaults, like:
    //        blahDefaults : {
    //           dataSource:"$creator.hiliteDS"
    //        }
    //     .. these defaults could be "compiled" to speed this up (cache prop names and
    //     assignment function).
    //   - super high-speed (createRaw()) creation
    //     - needs to be overridable (as with other dynamicDefaults), so not just a method in
    //       autoChildDefaults()
    //     - when overriding, don't want to have call Super
    //     - could use a pattern like [className]_configure_autoChildName(autoChild)?
    //     - _completeCreationWithDefaults() is an imperfect implementation of this.
    // - tabs and sections
    //   - "autoChild:blah" achieves lazy creation, but not lazy creation of a hierarchy of
    //     components
    //     - NOTE: edge case: when a tabSet sees "autoChild:blah", the use case may be:
    //       - subclassing TabSet and adding autoChildren, in which case the defaults are found
    //         on the TabSet itself OR
    //       - using a TabSet as one of your autoChildren and creating tab.panes as other
    //         autoChildren, in which case the defaults are on the TabSet's creator.
    //       The TabSet tries to "guess" by looking at whichever widget has [autoChild]Defaults
    //   - tabs, fields, items, sections etc out of reach of autoChild-based configuration
    // - plug-ins
    //   - want
    // - requirement of calling changeDefaults() awkward
    //   - class.init would keep changeDefaults() calls from having to be done in global scope
    //   - could have a specially interpreted property like autoChildDefaults
    // - default way of adding children
    //   - we could have a property like "defaultAutoParent" in order to allow eg Window to
    //     specify that autoChildren are added to the body instead.  If so, we'd need
    //     autoParent:"creator" to mean add to creator despite defaultAutoParent.
    // - for high performance creation of many similar objects, need an API that you can call
    //   that collapses properties and then re-uses then, or possibly even dynamically creates
    //   an ISC Class
    //
    // Internal (for now) usages
    // - providing dynamic properties via an override of
    //   getDynamicDefaults(autoChildName) in order to avoid manual calls to addAutoChild()
    // - widget.autoChildren can be an Array of autoChildren which will be created and added
    //   after initWidget().  This can be handy, but doesn't cleanly allow further subclassing
    //   as is
    //
    // - other best practices:
    //   - when defaults objects get very large consider replacing them with a class definition.
    //     This makes code faster since less properties are added on create(), however, it does
    //     make it less likely that application or patch code that tries to use a different
    //     constructor for that autoChild will succeed.  Splitting skinning-related properties
    //     into a class while retaining behavioral properties (like method overrides) is a good
    //     hedge.
    //
    // - cleanup
    //   - autoChildParentMap is obsoleted by autoParent setting and should be removed
    //   - _autoMaker functionality is probably obsoleted by getDynamicDefaults() and needs to
    //     be removed
    //   - several classes used the autoChild system before it was fully complete, and so have
    //     manual calls to createAutoChild() which are probably unnecessary
    //
    // - notes on design of this system
    //   - considered accepting just simple Strings as autoChild names anywhere Canvii are
    //     normally expected, eg tab.pane and section.items, but:
    //     - this conflicts with allowing globals to be specified as just a String in these
    //       spots.  Specifying strings for globals is actually useful for out-of-order
    //       creation, and when coming from XML, and is a likely newbie error when attempting
    //       to specify a global reference.  If we try to disambiguate via a check for eg
    //       [childName]Defaults and/or whether there is a global Canvas by that name, we still
    //       end up with weird cases where a global might surpress an autoChild or vice versa,
    //       like finding "footer" in window.items
    //     - the String isn't a complete definition of the autoChild anwyay, as in the case of
    //       section.items, the appropriate creator may be the SectionStack or some yet higher
    //       level parent

    //> @groupDef autoChildUsage
    // An AutoChild is an automatically generated subcomponent that a parent component creates to
    // handle part of its presentation or functionality.  An example is the +link{Window} component and
    // its subcomponent the +link{Window.header,header}.
    //
    // <smartclient>
    // <p>
    // AutoChildren support a standard set of properties that can be used to customize or skin
    // them.  The names of these properties are derived from the name of the AutoChild itself.
    // These properties will generally not be separately documented for every AutoChild unless
    // there are special usage instructions; the existence of the properties is implied whenever
    // you see an AutoChild documented.
    // <P>
    // The properties affecting AutoChildren are:
    // <dl>
    //
    // <dt> <b>"show" + name</b> (eg showHeader)
    // <dd> Controls whether the AutoChild should be created and shown at all. Note that the
    // first letter of the AutoChild name is uppercased for this property ("header" -> "Header").
    //
    // <dt> <b>name + "Properties"</b> (eg headerProperties)
    // <dd> Properties to apply to the autoChild created by this particular instance of the
    // parent component.  For example:
    // <pre>
    //        isc.Window.create({
    //            ID: "myWindow",
    //            headerProperties: { layoutMargin: 10 }
    //        });
    // </pre>
    // The above applies a +link{layout.layoutMargin,layoutMargin} of 10 to the header of <code>myWindow</code>,
    // increasing the empty space around the subcomponents of the header (buttons, title label,
    // etc).
    // <P>
    // Generally, *Properties is null.  <b>Do not</b> use the *Properties mechanism for
    // skinning.  See *Defaults next.
    //
    // <dt> <b>name + "Defaults"</b> (eg headerDefaults)
    // <dd> Defaults that will be applied to the AutoChild created by any instance of the
    // parent class.  *Defaults is used for skinning.  This property should never be set when
    // creating an instance of the parent component, as it will generally wipe out defaults
    // required for the component's operation.  Use +link{class.changeDefaults,changeDefaults()}
    // to alter defaults instead. This is generally as part of a custom skin and/or custom component
    // creation - see the +link{group:autoChildren,overview of AutoChildren for component development}
    // for details and examples.
    //
    // <dt> <b>name + "Constructor"</b> (eg headerConstructor)
    // <dd> SmartClient Class of the component to be created.  An advanced option, this
    // property should generally only be used when there is documentation encouraging you to do
    // so.  For example, +link{ListGrid} offers the ability to use simple CSS-based headers or
    // more complex +link{StretchImg} based headers via +link{listGrid.headerButtonConstructor}.
    // The constructor can also be specified using the <code>_constructor</code> property in the
    // defaults for the AutoChild.
    // </dl>
    // </smartclient><smartgwt>
    // <p>
    // AutoChildren support four standard configuration mechanisms that can be used to customize or skin
    // them. Note, however, that configuring AutoChildren in Smart&nbsp;GWT is advanced usage.
    // <p>
    // To determine which AutoChildren exist for a particular component type, search the class' Javadocs
    // for "AutoChild" as there is a getter for each AutoChild that is supported. In the case
    // of a +link{group:multiAutoChildren,MultiAutoChild}, the getter is non-functional (always
    // returns null) and exists only to make you aware that the MultiAutoChild exists.
    // <p>
    // The four different ways to configure AutoChildren in Smart&nbsp;GWT are:
    // <dl>
    // <dt> <b>Visibility</b>
    // <dd> Controls whether the AutoChild should be created and shown at all.  The
    // {@link com.smartgwt.client.widgets.Canvas#setAutoChildVisibility(String, boolean)} or
    // {@link com.smartgwt.client.widgets.form.fields.FormItem#setAutoChildVisibility(String, boolean)} API
    // as appropriate is used to change this property for the named AutoChild.
    //
    // <dt> <b>Properties</b>
    // <dd> Properties to apply to the AutoChild created by a particular instance of the
    // parent component. In the case of a +link{MultiAutoChild}, the properties are applied to each
    // instance created by the parent.
    // <P>
    // To change the properties of an AutoChild of a widget, the
    // {@link com.smartgwt.client.widgets.Canvas#setAutoChildProperties(String, com.smartgwt.client.widgets.Canvas)} or
    // {@link com.smartgwt.client.widgets.Canvas#setAutoChildProperties(String, FormItem)} API
    // is used. To change the properties of an AutoChild of a form item, the
    // {@link com.smartgwt.client.widgets.form.fields.FormItem#setAutoChildProperties(String, com.smartgwt.client.widgets.Canvas)} or
    // {@link com.smartgwt.client.widgets.form.fields.FormItem#setAutoChildProperties(String, FormItem)}
    // API is used. For example:
    // <pre>
    //        final Window myWindow = new Window();
    //        final Layout headerProperties = new Layout();
    //        headerProperties.setLayoutMargin(10);
    //        myWindow.setAutoChildProperties("header", headerProperties);
    // </pre>
    // The above applies a +link{layout.layoutMargin,layoutMargin} of 10 to the header of <code>myWindow</code>,
    // increasing the empty space around the subcomponents of the header (buttons, title label,
    // etc).
    // <P>
    // <b>Do not</b> use the Properties mechanism for skinning.  See Defaults next.
    //
    // <dt> <b>Defaults</b>
    // <dd> Defaults that will be applied to the AutoChild created by any instance of the
    // parent class.  Changing the defaults is used for skinning.  The <code>changeAutoChildDefaults()</code>
    // static method of the target Smart&nbsp;GWT class is used to change the defaults for all
    // instances of the class.  For example, to change the +link{Window.header,Window.header}
    // defaults, the {@link com.smartgwt.client.widgets.Window#changeAutoChildDefaults(String, com.smartgwt.client.widgets.Canvas)}
    // API is used passing "header" for the <code>autoChildName</code>.
    // <p>
    // <code>changeAutoChildDefaults()</code> must be called before any
    // components are created, and will generally be the first thing in your module's
    // <code>onModuleLoad()</code> function.  Alternatively, you can use the JavaScript equivalent
    // <code>Class.changeDefaults()</code> inside of a load_skin.js file - see <i>Skinning
    // AutoChildren</i> below.
    //
    // <dt> <b>Constructor</b>
    // <dd> &#83;martClient Class of the component to be created.  An advanced option, the
    // AutoChild constructor should generally only be changed when there is documentation encouraging
    // you to do so.  For example, +link{ListGrid} offers the ability to use simple CSS-based headers or
    // more complex +link{StretchImg} headers via
    // <code>listGridInstance.setAutoChildConstructor("headerButton", "StretchImg")</code>.
    // To change the constructor of AutoChildren, the
    // {@link com.smartgwt.client.widgets.Canvas#setAutoChildConstructor(String, String)} or
    // {@link com.smartgwt.client.widgets.form.fields.FormItem#setAutoChildConstructor(String, String)}
    // API is used.
    //
    // <p> In order for any class to be referenced within a constructor you must
    // register the class for reflection, and use the fully qualified name of the target
    // class. See +link{group:reflection,Reflection} for details.
    //
    // <p>
    // For some drastic customizations of an AutoChild where the constructor is changed, the
    // signature of the <code>get[AutoChild]()</code> method may have too specific a return type and the
    // {@link com.smartgwt.client.widgets.Canvas#getCanvasAutoChild(String)},
    // {@link com.smartgwt.client.widgets.Canvas#getFormItemAutoChild(String)},
    // {@link com.smartgwt.client.widgets.form.fields.FormItem#getCanvasAutoChild(String)}, or
    // {@link com.smartgwt.client.widgets.form.fields.FormItem#getFormItemAutoChild(String)} API
    // as appropriate would need to be used instead to retrieve the AutoChild instance.
    // </dl>
    // <p>
    // <b>NOTE:</b> When setting Properties or Defaults in Smart&nbsp;GWT, attributes and event
    // handlers can be set, but override points are not supported.
    // </smartgwt>
    //
    // <p>
    // The AutoChild system can be used to create both +link{canvas.children,direct children}
    // and indirect children (children of children).  For example, the
    // +link{window.minimizeButton,minimizeButton} of the Window is also an autoChild, even
    // though it is actually located within the window header.
    // <P>
    // <h4>Skinning AutoChildren</h4>
    // <P>
    // Skinning AutoChildren by changing the AutoChild defaults is typically done for two purposes:
    // <ul>
    // <li> Changing the default appearance or behavior of a component, for example, making all
    // Window headers shorter
    // <li> Creating a customized variation of an existing component <i>while retaining the
    // base component unchanged</i>.  For example, creating a subclass of Window called
    // "PaletteWindow" with a very compact appearance, while leaving the base Window class
    // unchanged so that warning dialogs and other core uses of Windows do not look like
    // PaletteWindows.
    // </ul>
    // The best code examples for skinning are in the load_skin.js file for the "&#83;martClient"
    // skin, in <code>isomorphic/skins/&#83;martClient/load_skin.js</code>.
    // <P>
    // <h4>Passthroughs (eg window.headerStyle)</h4>
    // <P>
    // In many cases a component will provide shortcuts to skinning or customizing its
    // AutoChildren, such as +link{window.headerStyle}, which becomes header.styleName.  When
    // these shortcuts exist, they must be used instead of the more general AutoChild skinning
    // system.
    // <P>
    // <h4>Safe Skinning</h4>
    // <P>
    // Before skinning an AutoChild consider the +link{group:safeSkinning,safe skinning guidelines}.
    // <P>
    // <h4>Accessing AutoChildren Dynamically</h4>
    // <P>
    // For a component "Window" with an AutoChild named "header", if you create a Window
    // called <code>myWindow</code>, the header AutoChild is available
    // <smartclient>as <code>myWindow.header</code></smartclient>
    // <smartgwt>via <code>myWindow.getHeader()</code></smartgwt>.
    // <P>
    // Unless documented otherwise, an AutoChild should be considered an internal part of a
    // component.  Always configure AutoChildren by APIs on the parent component when they
    // exist.  It makes sense to access an AutoChild for troubleshooting purposes or for
    // workarounds, but in general, an AutoChild's type, behavior, and internal structure are
    // subject to change without notice in future SmartClient versions.
    // <P>
    // Accessing an AutoChild may give you a way to make a dynamic change to a component that
    // is not otherwise supported by the parent component (for example, changing a text label
    // where there is no setter on the parent).  Before using this approach, consider whether
    // simply recreating the parent component from scratch is a viable option. This approach
    // is more than fast enough for most smaller components, and will not create a reliance on
    // unsupported APIs.
    //
    // @title Using AutoChildren
    // @treeLocation Concepts
    // @visibility external
    //<

    //> @type AutoChild
    // An autoChild is an automatically generated subcomponent that a component creates to
    // handle part of its presentation or functionality.  An example is the Window component and
    // its subcomponent the "header".
    // <P>
    // See +link{group:autoChildUsage,Using AutoChildren} for more information.
    //
    // @group autoChildren
    // @visibility external
    //<

    //> @type MultiAutoChild
    // @see group:multiAutoChildren
    // @visibility external
    //<

    // NOTE: the following groupDef appears only in SmartClient, not SmartGWT.
    //> @groupDef autoChildren
    // An autoChild is an automatically generated subcomponent that a component creates to
    // handle part of its presentation or functionality.
    // <P>
    // An example is the Window component and its subcomponent the "header".
    // <P>
    // AutoChildren support a standard set of properties that can be used to customize or skin
    // them.
    // <P>
    // This topic explains how to use the autoChild system when creating custom components in
    // order to create maximum flexibility.  To learn how to use the autoChild system with
    // pre-existing components, +link{group:autoChildUsage,go here}.
    // <P>
    // Before reading this topic, be sure you have read the +docTreeLink{QuickStart Guide}
    // material on creating custom components and have reviewed the provided examples.
    // <P>
    // <h3>Basics</h3>
    // <P>
    // The following is an example of creating subcomponents <b>without</b> using the AutoChild
    // pattern.  In this case a fictitious "Portlet" class is being created, which uses an
    // instance of isc.Label to serve as it's header.
    // <pre>
    // isc.defineClass("Portlet", "VLayout").addProperties({
    //     initWidget : function () {
    //         this.Super("initWidget", arguments);
    //
    //         this.headerLabel = isc.Label.create({
    //             autoDraw:false,
    //             contents: this.title,
    //             styleName: this.titleStyleName,
    //             portlet:this,
    //             click : function () { this.portlet.bringToFront() },
    //             wrap:false,
    //             overflow:"hidden",
    //             width:"100%"
    //         });
    //         this.addMember(this.headerLabel);
    //         ...
    // </pre>
    // While straightforward, this approach provides limited flexibility to someone using the
    // "Portlet" class.  There is no way to:
    // <ol>
    // <li> avoid creating the headerLabel, for a "headerless" portlet
    // <li> use a different, more advanced class as a header (eg, StretchImgButton or a custom
    // class)
    // <li> skin the headerLabel, other than CSS (rounded corners, animations, etc, wouldn't be
    // possible)
    // <li> change it's layout behavior (eg enable autoSize)
    // <li> add or override event handlers
    // </ol>
    // Let's imagine we wanted to add some of the above features.  We could change the code
    // like so:
    // <P>
    // <pre>
    // isc.defineClass("Portlet", "VLayout").addProperties({
    //     <b>showHeaderLabel:true,</b>
    //     <b>headerLabelConstructor:isc.Label,</b>
    //     initWidget : function () {
    //         this.Super("initWidget", arguments);
    //
    //         <b>if (this.showHeaderLabel) {</b>
    //             this.headerLabel = this.headerLabelConstructor.create({
    //                 autoDraw:false,
    //                 contents: this.title,
    //                 styleName: this.titleStyleName,
    //                 portlet:this,
    //                 click : function () { this.portlet.bringToFront() },
    //                 wrap:false,
    //                 overflow:"hidden",
    //                 width:"100%"
    //             }<b>, this.headerLabelProperties</b>);
    //             this.addMember(this.headerLabel);
    //         <b>}</b>
    //         ...
    // </pre>
    // Our additions solve our initial concerns:
    // <ul>
    // <li> <code>showHeaderLabel:false</code> can be set to suppress the header label
    // <li> <code>headerLabelConstructor</code> allows you to switch to a different class
    // <li> <code>headerLabelProperties</code> give you a means to add arbitrary properties
    // (skinning properties, sizing properties, event handlers, etc)
    // </ul>
    // However, the code is becoming more verbose and repetitive, and we've created a few
    // additional properties that now need documentation and testing.  This extra work is going
    // to be multiplied by every subcomponent we create where we want this kind of flexibility.
    // <P>
    // Enter the AutoChild system: the purpose of the AutoChild system is to define a standard
    // pattern for creating subcomponents with maximum flexibility.  This means:
    // <ul>
    // <li> developers creating custom components write less code, have less to test and less
    // to document
    // <li> developers can more easily understand each other's code for custom components,
    // because it follows a standard pattern
    // <li> developers <b>using</b> custom components have a standard pattern for
    // customization, instead of learning customization APIs for every component separately
    // </ul>
    // The code below uses the autoChild system to create the "headerLabel" subcomponent.  This
    // version of the code would still respect all of the customization properties from earlier
    // examples (<code>headerLabelProperties</code> et al) and offers several additional degrees
    // of flexibility still to be explained, yet it's significantly shorter.  More importantly,
    // this code is less redundant; the "boilerplate" code is gone and what's left is just the
    // actual settings for the headerLabel subcomponent.
    // <pre>
    // isc.defineClass("Portlet", "VLayout").addProperties({
    //     headerLabelDefaults : {
    //         _constructor:isc.Label,
    //         click : function () { this.creator.bringToFront() },
    //         wrap:false,
    //         overflow:"hidden",
    //         width:"100%"
    //     },
    //     initWidget : function () {
    //         this.Super("initWidget", arguments);
    //
    //         this.addAutoChild("headerLabel", {
    //             contents: this.title,
    //             styleName: this.titleStyleName
    //         });
    //         ...
    // </pre>
    // <P>
    // The documentation for +link{class.addAutoChild,addAutoChild()} explains why this code
    // will still respect the <code>showHeaderLabel</code> flag and other customization
    // properties even though they aren't mentioned specifically.
    // <P>
    // <h3>AutoChildren lifecycle</h3>
    // <P>
    // By default any auto-children created by +link{class.addAutoChild()} or
    // +link{class.createAutoChild()} will be +link{canvas.destroy(),destroyed} when the
    // canvas that created them is destroyed. You can suppress this behavior by setting
    // <code>dontAutoDestroy</code> to <code>true</code> on the auto child. To do this you
    // could add the property to the defaults or properties block for the autoChild, or
    // pass it into the creating method in the dynamic set of properties.
    // <p>
    // <h3>Subclassing a component with autoChildren</h3>
    // <P>
    // If you are subclassing a component that has an autoChild and you want to change
    // defaults for that autoChild, the correct way to do so is to use
    // +link{Class.changeDefaults,changeDefaults()}:
    // <pre>
    // isc.defineClass("MyWindow", "Window");
    // isc.MyWindow.changeDefaults("headerDefaults", { layoutMargin:10 });
    // isc.MyWindow.addProperties({
    //    ...
    // </pre>
    // <P>
    // <code>changeDefaults()</code> creates a copy of the superclass defaults and applies your
    // changes, which is important because you want to inherit the superclass behavior without
    // affecting the superclass, and yet apply overrides.
    // <P>
    // The following code sample indicates two common
    // <span style="color:red;font-weight:bold">incorrect</span> patterns for working with
    // defaults, and the consequences of each:
    // <pre>
    // isc.defineClass("MyWindow", "Window").addProperties({
    //     // NO.  Superclass behavior / settings for autoChild
    //     // won't be inherited.  Use changeDefaults() instead.
    //     headerDefaults : { ... },
    //
    //     initWidget : function () {
    //         this.Super("initWidget", arguments);
    //
    //         // NO.  "headerDefaults" object is shared across the class,
    //         // changing it affects all instances created from here on.
    //         // Pass dynamic defaults to addAutoChild() instead
    //         this.headerDefaults.myProperty = this.newValue;
    //         ...
    // });
    // </pre>
    // <b>defaults vs properties</b>
    // <P>
    // For AutoChildren, defaults and properties both provide similar means of adding
    // properties to an AutoChild, and the distinction between them is primarily one of
    // convention: a class that uses AutoChildren should never define a default value for
    // <i>autoChildName</i>Properties, so that instances can freely specify
    // <i>autoChildName</i>Properties without overriding built-in behavior.
    // <pre>
    // isc.defineClass("MyWindow", "Window").addProperties({
    //     // NO.  Any further use of "headerProperties", in
    //     // instances or in subclasses, would wipe out behavior
    //     headerProperties : { ... },
    // </pre>
    // <P>
    // By consistently using +link{Class.changeDefaults()} whenever you override autoChild
    // defaults in a subclass, you ensure that your classes can in turn be subclassed and
    // extended uniformly.
    // <P>
    // <h3>autoParents and creation order</h3>
    // <P>
    // The AutoChild pattern can create an entire hierarchy of generated subcomponents.  For
    // example, the +link{Window} class included with SmartClient uses several AutoChildren as
    // part of the overall header structure: separate autoChildren for the minimize button,
    // close button, and then the header itself, a Layout-derived class that contains all other
    // header controls.
    // <P>
    // To facilitate construction of hierarchies of autoChildren, the special
    // <code>autoParent</code> property may appear in either defaults or properties for an
    // autoChild, and indicates the name of another autoChild that should used as a parent.
    // For example, to create a "closeButton" autoChild that will be a member of the "header"
    // autoChild:
    // <P>
    // <pre>
    // isc.defineClass("Portlet", "VLayout").addProperties({
    //     headerDefaults : {
    //         _constructor:isc.HLayout,
    //         ...
    //     },
    //     closeButtonDefaults : {
    //         <b>autoParent:"header",</b>
    //         _constructor:isc.ImgButton,
    //         ...
    //     },
    //     initWidget : function () {
    //         this.Super("initWidget", arguments);
    //
    //         this.addAutoChild("header");
    //         this.addAutoChild("closeButton");
    //         ...
    // </pre>
    // <P>
    // In addition to cutting down on code and making inter-autoChild relationships clearer,
    // using <code>autoParent</code> rather than manual calls to addMember() allows a
    // subclass of your component to potentially completely rearrange the autoChildren you have
    // defined, while retaining their behavior.
    // <P>
    // When using <code>autoParent</code> to arrange autoChildren, create parents first, then
    // children.
    // <P>
    // <b>Tip:</b> if you want all of the behaviors of
    // +link{class.addAutoChild(),addAutoChild()} <i>except</i> automatically adding the
    // autoChild to a parent, set <code>autoParent:"none"</code>.
    // <P>
    // <b>special case: TabSets and SectionStacks</b>
    // <p>
    // An autoChild that appears as a +link{tab.pane} or
    // +link{SectionStackSection.items,section item} does not have a clear way to refer to it's
    // tab or section via the <code>autoParent</code> property.  For this special case, the
    // TabSet and SectionStack components allow tab.pane / section.items to contain the special
    // string "autoChild:<i>autoChildName</i>".  This will cause the corresponding autoChild to be
    // automatically created when the tab is selected or section expanded.
    // <P>
    // For example:
    // <pre>
    // isc.defineClass("Portlet", "VLayout").addProperties({
    //     ...
    //     mainTabsDefaults : {
    //         _constructor:isc.TabSet,
    //         tabs : [
    //             { title:"First Pane", pane:"autoChild:firstPane" }
    //         ]
    //     },
    //     firstPaneDefaults : {
    //         ...
    //     },
    //     initWidget : function () {
    //         this.Super("initWidget", arguments);
    //
    //         // this automatically creates firstPane as an autoChild
    //         this.addAutoChild("mainTabs");
    //         ...
    // </pre>
    //
    // @visibility external
    //<

    //> @groupDef multiAutoChildren
    // A MultiAutoChild is an +link{AutoChild} where the creating component usually creates more than
    // one, hence, unlike a normal AutoChild, the AutoChild is not accessible as <code>creator.[autoChildName]</code>.
    // <P>
    // See +link{group:autoChildUsage,Using AutoChildren} for more information on configuring a
    // MultiAutoChild.
    // @see Class.createAutoChild()
    // @visibility external
    //<

    // break this discussion into safe skinning (visuals only) and safe customization
    // (subclasses and autoChildren)?
    //> @groupDef safeSkinning
    // The skinning mechanism is extremely powerful and gives you the ability to change
    // internal functionality of components.  While this is useful for workarounds, you should
    // think through any properties you override, considering what will happen with future
    // versions of SmartClient, where the defaults may change or be expanded.
    // <P>
    // The following kinds of overrides are generally very safe:
    // <ul>
    // <li> Change +link{canvas.styleName,styleName} or +link{button.baseStyle,baseStyle} to
    // provide a custom CSS style or series of styles
    // <li> Change a media path such as the +link{Img.src,src} of the
    // +link{Window.minimizeButton}.
    // <li> Change the size of any part of the UI that has a fixed pixel size, such as
    // the height and width of the +link{Window.minimizeButton}, especially when this is done
    // to match the size of media you have created
    // <li> Set properties such as +link{button.showRollOver} that cause a component to
    // visually react to more or fewer UI states (disabled, over, down, etc)
    // </ul>
    // The following should be very carefully considered:
    // <ul>
    // <li> Adding custom behaviors by passing in event handlers such as
    // (eg +link{canvas.showContextMenu,showContextMenu()}).  If future versions of the
    // component add more functionality, you may prevent new features from functioning, cause
    // them to function only partially, or break.
    // <P>
    // If you want to ensure that you do not break new functionality added in future SmartClient
    // versions, be sure to call +link{class.Super,Super()} for methods you override, and do not
    // prevent events from bubbling.
    // <P>
    // If you want to ensure that <b>only</b> your custom behavior is used if a future version
    // of a SmartClient component adds functionality, override all methods involved in the
    // interaction, even if your methods do nothing.  For example, for a custom drop
    // interaction, override dropOver, dropMove, dropOut and drop, even if you do nothing on
    // dropMove().  Then, do not call Super() if there is no superclass behavior required for
    // the interaction you've implemented.  Also, for any event handlers (such as drop())
    // return false if you consider your code to have completely handled the event (no
    // parent component should react).
    // </ul>
    // The following are not recommended:
    // <ul>
    // <li> Providing a global +link{Canvas.ID,ID} to a subcomponent (only works once).
    // <li> Overriding +link{canvas.backgroundColor}, +link{canvas.border,border},
    // +link{canvas.margin,margin}, +link{canvas.padding,padding}, or in general any single
    // attribute otherwise controlled by CSS.  Future SmartClient versions may change the base
    // CSS style, rendering your single-property customization senseless.  Change the entire
    // CSS style via +link{canvas.styleName,styleName} instead.
    // </ul>
    //
    // @title Safe Skinning
    // @visibility external
    //<

    addAutoChildren : function (children, parent, position) {
        if (children == null) return;
        if (!isc.isAn.Array(children)) children = [children];
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (isc.isA.Canvas(child)) {
                parent = parent || this;
                this._addAutoChildToParent(child, parent, position);
                continue;
            }
            // string name, or block of properties specifying an autoChild
            this.addAutoChild(child, null, null, parent, position);
        }
    },

    //> @method class.addAutoChild()
    // Creates a component according to the "AutoChild" pattern, and adds it to this component.
    // <P>
    // See the +link{group:autoChildren,AutoChild usage overview} to understand the general
    // purpose and usage of this method.
    // <P>
    // <code>addAutoChild()</code> takes the following actions:
    // <ol>
    // <li> checks whether this.<i>autoChildName</i> is already populated, and returns it if so
    // <li> checks when there is a show<i>AutoChildName</i> with the value false, and if so
    // returns without creating a component
    // <li> calls +link{createAutoChild()} to create the component
    // <li> sets this.<i>autoChildName</i> to the created component
    // <li> adds the component either to this component, or to some other parent, specified
    // by the "autoParent" property in the autoChild's defaults.  The "autoParent" property may
    // be "none" indicating the autoChild should not be automatically added.
    // </ol>
    // <P>
    // When adding an autoChild to a +link{Layout} subclass,
    // +link{layout.addMember,addMember()} will be called instead of the normal
    // +link{Canvas.addChild,addChild()}.  To prevent this behavior,
    // <code>addAsChild:true</code> can be set in the autoChild defaults.  Similarly,
    // <code>addAsPeer:true</code> may be set to add an autoChild as a peer.
    // <P>
    // <b>Tip:</b> because <code>addAutoChild()</code>
    // checks specifically for show<i>AutoChildName</i>:false, you do not have to add
    // show<i>AutoChildName</i>:true in order for an autoChild to be shown by default; leaving
    // the property undefined is sufficient.
    // <P>
    // Note that by default the child created by this method will be destroyed when
    // +link{canvas.destroy(),destroy()} is called on this instance. To disable this behavior,
    // set <code>dontAutoDestroy</code> to true on the auto child.
    //
    // @param childName (String) name of the autoChild
    // @param defaults (Properties) dynamic properties for the autoChild
    // @return (Class) created autoChild
    //
    // @group autoChildren
    // @visibility external
    //<
    _$maker:"_autoMaker",
    addAutoChild : function (childName, dynamicProperties, defaultConstructor, parent, position) {
        var childValue = this[childName];
        // already created
        if (isc.isAn.Instance(childValue)) return childValue;


        // allow a properties object with autoChildName etc
        if (isc.isAn.Object(childName) && childName.autoChildName) {
            dynamicProperties = childName;
            defaultConstructor = dynamicProperties._constructor || defaultConstructor;
            childName = dynamicProperties.autoChildName;
        }

        // check to see if the value of the childName property is a string that is the global
        // ID of an existing instance (like { header : "myPreviouslyCreatedHeader" })
        if (isc.isA.String(childValue) && window[childValue]) {
            this[childName] = window[childValue];
            return this[childName];
        }

        // check flags, and existence of parents, before proceeding to create the child
        // NOTE: null check allows constructor blocks for unnamed autoChildren (automatically
        // created, but not skinnable)
        if (childName != null && !this.shouldCreateChild(childName)) return;

        // create the child
        // XXX autoMaker functionality is considered legacy; getDynamicDefaults() is believed
        // to handle all cases for which autoMaker was intended, and more cleanly
        // If this[childName]_autoMaker() is defined, call that to make the child, rather than
        // 'createAutoChild()'

        var child,
            makerName = childName + this._$maker;

        if (childName != null && this[makerName]) child = this[makerName](dynamicProperties);
        else {
            child = this.createAutoChild(childName, dynamicProperties, defaultConstructor, true);
        }
        // createAutoChild() may return null if we're not configured to create this child.
        // A custom maker function may return null if it wants to handle adding the child to
        // the appropriate parent itself (and assinging the child to the appropriate property
        // name)
        if (!child) return;

        // If we went through createAutoChild with the assignToSlot parameter, this is unnecessary
        // but if we ran the maker method, we have to actually assign this[childName] to the
        // generated object
        // Note: assignment to slot can be suppressed by the autoChild creation logic (e.g. for
        // spacer creation where assignment doesn't make sense)
        if (child._assignToSlot !== false) this[childName] = child;

        this._addToParent(childName, child, parent, position);

        return child;
    },

    _$creator:"creator",
    _addToParent : function (childName, child, parent, position) {
        // ways of specifying parent, in order of preference
        // - pass into addAutoChild / createAutoChild (becomes parent param here)
        // - as child.autoParent, for any source of properties
        // - define this.autoChildParentMap
        // - finally, "this" assumed
        if (parent == null) {
            parent = child.autoParent || this.getAutoChildParent(childName);
        }
        if (isc.isA.String(parent)) {
            // constant meaning no parent, eg, pop-up dialog
            if (parent == isc.Canvas.NONE) {
                if (this.isDrawn()) child.draw();
                return;
            }

            var canvasParent = this[parent] || window[parent] || parent;
            if (!isc.isA.Canvas(canvasParent)) {
                this.logWarn("no valid parent could be found for String '" + parent + "'");
            } else parent = canvasParent;
        }

        // do nothing if the created child is not a Canvas or derived parent isn't a canvas.
        if (!isc.isA.Canvas(child) || !isc.isA.Canvas(parent)) return;

        this._addAutoChildToParent(child, parent, position);
    },

    _addAutoChildToParent : function (child, parent, position) {
        // add to parent, as member or child
        if (child.addAsPeer || child.snapEdge) parent.addPeer(child);
        else if (isc.isA.Layout(parent) && !child.addAsChild && !child.snapTo) parent.addMember(child, position);
        else if (isc.TileLayout && isc.isA.TileLayout(parent) && !child.addAsChild && !child.snapTo) parent.addTile(child, position);

        else parent.addChild(child);
    },

    // defaults to creating child if this.show[ChildName] isn't explicitly set to false.  If the
    // child is declared to have a named parent, checks that the parent will be created too
    _$show : "show",
    shouldCreateChild : function (childName) {
        var showProperty = this._$show + childName.charAt(0).toUpperCase() + childName.substring(1);
        if (this[showProperty] != null && this[showProperty] == false) return false;

        // check whether the parent will be created
        var parentName = this._getAutoChildParentName(childName);
        if (parentName == null) return true;
        return (this.shouldCreateChild(parentName));
    },

    _$Constructor: "Constructor",
    // Determine what class the child should be.
    // - If there is an explicit [childName]Constructor property, use that specified class
    // - If the properties include an _constructor attribute, use that class
    // - Otherwise use the defaultConstructor passed in
    // - (back off to canvas if we failed to find a class)
    getAutoChildClass : function (childName, dynamicProperties, defaultConstructor,
                                  childDefaultsName, childPropertiesName) {
        // use childDefaultsName if passed, so it doesn't have to be recalc'd
        childDefaultsName = childDefaultsName || this._getDefaultsName(childName);
        var childDefaults = this[childDefaultsName];

        childPropertiesName = childPropertiesName || this._getPropertiesName(childName);
        var childProperties = this[childPropertiesName];

        return this[childName + this._$Constructor] ||
               (dynamicProperties ? dynamicProperties._constructor : null) ||
               (childProperties ? childProperties._constructor : null) ||
               (childDefaults ? childDefaults._constructor : null) ||
               defaultConstructor || isc.Canvas;
    },

    // get defaults for all auto children
    applyBaseDefaults : function (child, childName, dynamicDefaults) {
        child.autoDraw = false;
        child._generated = true;

        // special "creator" property obviates the need to pass "window:this" et al dynamically
        child.creator = this;
        // ability to rename the "creator" pointer for clarity
        var creatorName = this.creatorName;
        if (creatorName) child[creatorName] = this;

        // generate an ID for the autoChild based on it's name.  NOTE: can be suppressed by
        // passing ID:null in dynamicProperties
        var undef;
        if (dynamicDefaults == null || dynamicDefaults.ID === undef) {
            child.ID = this.getID() + isc._underscore + childName;
            // if the defaultID collides, uniquify it.  This allows createAutoChild() to be
            // called multiple times on the same config block
            if (window[child.ID]) {
                child.ID = child.ID + isc._underscore + isc.ClassFactory.getNextGlobalID();
            }
        }
    },

    getDynamicDefaults : function () {},

    _$Defaults: "Defaults",
    _getDefaultsName : function (childName) {
        var cache = isc.Class._defaultsCache;
        if (!cache) isc.Class._defaultsCache = cache = {};

        if (cache[childName]) return cache[childName];

        var defaultsName = childName + this._$Defaults;
        if (this[defaultsName]) cache[childName] = defaultsName;
        return defaultsName;
    },

    _$Properties: "Properties",
    _getPropertiesName : function (childName) {
        var cache = isc.Class._propertiesCache;
        if (!cache) isc.Class._propertiesCache = cache = {};

        if (cache[childName]) return cache[childName];

        var propertiesName = childName + this._$Properties;
        if (this[propertiesName]) cache[childName] = propertiesName;
        return propertiesName;
    },

    //> @method class.createAutoChild()
    // Unconditionally creates and returns a component created according to the "AutoChild"
    // pattern.
    // <P>
    // In addition to applying defaults and properties as described under the
    // +link{group:autoChildUsage,AutoChild overview}, the created autoChild:
    // <ul>
    // <li> is automatically <code>autoDraw:false</code>
    // <li> has a <code>creator</code> property that points to this component, for easy
    // authoring of event handlers (eg click:"this.creator.doSomething()")
    // </ul>
    // <P>
    // Unlike +link{addAutoChild()}, <code>createAutoChild()</code> does not create a
    // this.<i>autoChildName</i> reference to the component, check a show<i>AutoChildName</i>
    // flag, or automatically add the autoChild via +link{Canvas.addChild()}.
    // <P>
    // General you use <code>createAutoChild</code> rather than addAutoChild when:
    // <ul>
    // <li> you are going to create several autoChildren with a common set of defaults (for
    // example the +link{columnTree.column,column} autoChild of the +link{ColumnTree}).
    // <li> children need to be created before their parents (eg, for layout/auto-sizing
    // reasons)
    // </ul>
    // <P>
    // Note that by default the child created by this method will be destroyed when
    // +link{canvas.destroy(),destroy()} is called on this instance. To disable this behavior,
    // set <code>dontAutoDestroy</code> to true on the auto child.
    //
    // @param childName (String) name of the autoChild
    // @param defaults (Properties) dynamic properties for the autoChild
    // @return (Class) created autoChild
    //
    // @group autoChildren
    // @visibility external
    //<
    _$spacerChildPrefix: "spacer:", // also used by Canvas
    createAutoChild : function (childName, passedDynamicDefaults, defaultConstructor,
                                assignToSlot)
    {
        if (isc.startsWith(childName, this._$spacerChildPrefix)) {
            var spacerLength = childName.substring(this._$spacerChildPrefix.length);
            var lengthAttribute = "width";
            if (this.orientation == isc.Layout.VERTICAL) lengthAttribute = "height";
            var props = {autoDraw: false, _assignToSlot: false};
            props[lengthAttribute] = spacerLength;
            return isc.LayoutSpacer.create(props);
        }

        var dynamicDefaults = this.getDynamicDefaults(childName);

        // NOTE: dynamicDefaults: generally, you will *either* pass dynamic defaults to
        // addAutoChild() *or* implement getDynamicDefaults() for cases where you don't call
        // addAutoChild directly.  It would be weird to do both, so we make sure it works, but
        // it's not as fast.
        if (dynamicDefaults != null && passedDynamicDefaults != null) {
            dynamicDefaults = isc.addProperties({}, dynamicDefaults, passedDynamicDefaults);
        } else {
            dynamicDefaults = passedDynamicDefaults || dynamicDefaults;
        }


        // standard name for defaults (eg bodyDefaults)
        var childDefaultsName = this._getDefaultsName(childName),
            childDefaults = this[childDefaultsName],
            childPropertiesName = this._getPropertiesName(childName),
            childProperties = this[childPropertiesName],
            // pass childDefaultsName so it doesn't have to be recalc'd
            childClassName = this.getAutoChildClass(childName, dynamicDefaults,
                                                    defaultConstructor, childDefaultsName, childPropertiesName),
            childClass = isc.ClassFactory.getClass(childClassName)
        ;
        if (childClass == null) {
            this.logWarn("Unable to create autoChild '"+childName
                         +"' of type '"+childClassName+"' - no such class in runtime.");
            if (isc.isA.String(childClassName) && childClassName.contains(".")) {
                this.logWarn("Did you make the SmartGWT class reflectable? See http://www.smartclient.com/smartgwt/javadoc/com/smartgwt/client/docs/Reflection.html");
            }
            return null;
        }

        dynamicDefaults = this.applyDuplicateAutoChildDefaults(
                            childClass,
                            childDefaultsName,
                            dynamicDefaults
                          );

        var child = childClass.createRaw();

        // autoPassthroughs: mechanism for declaring that certain properties on an autoParent
        // should be passed-through to the same-named properties on children
        // DO NOT USE, this will probably be renamed
        var passthroughs = this.autoPassthroughs,
            passthroughValues,
            undef;
        if (passthroughs) {
            for (var propName in passthroughs) {
                var targetChildName = passthroughs[propName];
                if (childName == targetChildName && this[propName] !== undef) {
                    child[propName] = this[propName];
                }
            }
        }

        this.applyBaseDefaults(child, childName, passedDynamicDefaults);

        isc.addProperties(child,
                          this.autoChildDefaults,
                          childDefaults,
                          passthroughValues,
                          dynamicDefaults);

        // call configure methods if available.  These allow maximum speed dynamicDefaults
        // through direct property assignment on the half-created autoChild.  Different
        // autoChildren can be quickly identified (eg child == this.newButton), and sharing
        // defaults across different autoChildren is easier.  These APIs are very advanced
        // because caller needs to understand the half-initialized "raw" state.

        if (assignToSlot) this[childName] = child;
        if (child.autoConfigure) child.autoConfigure(this, childName);
        if (this.configureAutoChild) this.configureAutoChild(child, childName);
        isc.addProperties(child, this[childPropertiesName]);

        // call initInterface() on any member interfaces that define the method
        if (childClass._initInterfaceMethods) {
            for (var i = 0; i < childClass._initInterfaceMethods.length; i++) {
                childClass._initInterfaceMethods[i].call(child);
            }
        }

        child.init();

        // Possibly extract from a config block -- will return the child itself
        // if this isn't a SmartGWT config block
        child = isc.SGWTFactory.extractFromConfigBlock(child);
        // Re-assigning to slot in case we extracted the child from an SGWT config block
        if (assignToSlot) this[childName] = child;

        // Maintain a mapping between child name and generated auto children IDs
        // This allows us to auto-destroy autochildren on destroy
        // Also used by the AutoTest locator APIs
        if (!this._createdAutoChildren) this._createdAutoChildren = {};
        var ID = child.getID ? child.getID() : null;
        if (ID != null) {

            if (!isc.isAn.Array(this._createdAutoChildren[childName])) {
                if (this._createdAutoChildren[childName] != null) {
                    isc.logWarn(this + ".createAutoChild(): Creating auto child named:" + childName
                        + " appears to be replacing autoChild with same name...");
                }
                this._createdAutoChildren[childName] = [ID];

            } else {
                this._createdAutoChildren[childName].add(ID);
            }
        }

        return child;
    },

    // When creating an autoChild, clone attributes registered for duplication
    // from the class level defaults block (or the special 'autoChildDefaults' object) and
    // apply cloned versions to dynamic defaults
    // Returns dynamicDefaults passed in - may be null or a new object if the
    // dynamicDefaults were unset originally
    applyDuplicateAutoChildDefaults : function (childClass, childDefaultsName, dynamicDefaults) {
          // clone attributes from class level defaults block that are registered for duplication
        var dupProps = childClass._dupAttrs;
        if (dupProps && dupProps.length > 0) {

            var childDefaults = this[childDefaultsName];

            if (childDefaults != null || this.autoChildDefaults != null) {
                for (var i = 0; i < dupProps.length; i++) {
                    var attr = dupProps[i],
                        undef;

                    if (childDefaults != null && childDefaults[attr] != null) {

                        if (dynamicDefaults == null) dynamicDefaults = {};
                        if (dynamicDefaults[attr] === undef) {
                            dynamicDefaults[attr] = childClass.cloneDupPropertyValue(
                                                        attr, childDefaults[attr]
                                                    );
                        }
                    } else if (this.autoChildDefaults != null &&
                                this.autoChildDefaults[attr] != null)
                    {
                        if (dynamicDefaults == null) dynamicDefaults = {};
                        if (dynamicDefaults[attr] === undef) {
                            dynamicDefaults[attr] = childClass.cloneDupPropertyValue(
                                                        attr, this.autoChildDefaults[attr]
                                                    );
                        }
                    }
                }
            }
        }
        return dynamicDefaults;
    },


    _completeCreationWithDefaults : function (childName, child, dynamicDefaults) {
        this.applyBaseDefaults(child, childName, dynamicDefaults);

        var childDefaultsName = this._getDefaultsName(childName),
            childPropertiesName = this._getPropertiesName(childName)
        ;

        // duplicate properties from the defaults to the dynamicDefaults block if necessary
        var childClass = child.getClass();

        // Note that this won't do anything for SGWT config blocks. But that's OK,
        // because the proper properties will eventually be duplicated when the
        // real Smartclient object is created.
        dynamicDefaults = this.applyDuplicateAutoChildDefaults(
                                childClass,
                                childDefaultsName,
                                dynamicDefaults
                          );

        child.completeCreation(
            // defaults for all named children
            this.autoChildDefaults,
            // instance defaults (for skinning) (eg bodyDefaults)
            this[childDefaultsName],
            // dynamic defaults
            dynamicDefaults,
            // user-provided instance properties
            this[childPropertiesName]
        );
    },

    // parents of named children can be declared as a map "autoChildParentMap" from child name
    // to parent name, on the assumption the parent is also a named child.
    _getAutoChildParentName : function (childName) {
        var parentMap = this.autoChildParentMap;
        if (parentMap) return parentMap[childName];
    },

    getAutoChildParent : function (childName) {
        var parentName = this._getAutoChildParentName(childName);
        if (parentName) return this[parentName];
        return this;
    },

    // set a named child: normally, just evaluates or re-evaluates the show flag in order to create
    // or destroy the component.  Can also be used to replace a named child with a specified
    // component.
    setAutoChild : function (childName, dynamicProperties) {

        if (!this.shouldCreateChild(childName)) {
            if (this[childName]) this[childName].destroy();
            // clear our pointer to the destroyed child
            delete this[childName];
        } else {
            // If we're passed a widget, apply it directly (unless shouldCreateChild() returns
            // false in which case we ignore the widget)
            if (isc.isA.Canvas(dynamicProperties)) {
                var child = dynamicProperties;
                // set the child to a custom-provided widget
                if (this[childName]) this[childName].destroy();
                this[childName] = child;
                this._addToParent(childName, child);
                return;
            }

            return this.addAutoChild(childName, dynamicProperties);
        }
    },


    hasStableID : function () {
        return !this._autoAssignedID;
    },
    hasStableLocalID : function () {
        return this._localId != null || !this._autoAssignedID;
    },



    //>    @method    class.map()
    //
    // Call <code>method</code> on each item in <code>argsList</code> and return the Array of results.
    //
    //    @param    methodName (string)
    //      Name of the method on this instance which should be called on each element of the Array
    //    @param    items      (Array)
    //      Array of items to call the method on
    //
    //    @return            (Array) Array of results, one per element in the passed "items" Array
    // @visibility external
    //<
    map : isc.Class.map,

    //>    @method    class.Super()
    //
    // Call the SuperClass implementation of an instance method.  For example:
    // <pre>
    //    isc.defineClass("MyButton", "Button").addProperties({
    //        // this override causes no change in behavior because it just
    //        // calls Super and returns whatever the superclass would return
    //        getTitle : function () {
    //            return this.Super("getTitle", arguments);
    //        },
    //
    //        // this override would add "foo" to the titles of all buttons
    //        getTitle : function () {
    //            // add code here to take actions before the superclass method is invoked
    //
    //            var superResult = return this.Super("getTitle", arguments);
    //
    //            // add code here to take action after the superclass method is invoked
    //
    //            return superResult + "foo";
    //        }
    //
    //    })
    // </pre>
    // Note that Super is always called with the name of the current method.  You cannot call
    // the Super class implementation of another method directly.
    // <P>
    // It is <b>required</b> to always pass the native 'arguments' object to Super.  Arguments
    // is a JavaScript builtin that is available within any JavaScript function - see any
    // JavaScript Reference for details.
    // <P>
    // See also +link{ClassFactory.defineClass,defineClass()} and
    // +link{classMethod:class.addProperties,addProperties} for the basics of creating classes
    // and overriding methods.
    //
    //    @param methodName   (string)    name of the superclass method to call
    //    @param args         (arguments or Array) native "arguments" object, or array of
    //                                           arguments to pass to the Super call
    //    @param [nativeArgs] (arguments) native "arguments" object, required if an Array is
    //                                  passed for the "args" parameter in lieu of the native
    //                                  arguments object
    //
    //    @return                    (any)        return value of the superclass call
    //
    // @visibility external
    //<
    //    @param     [nativeArguments] (Arguments) native "arguments" object.  Required only if
    //                                        calling Super() with a substitute set of
    //                                        arguments
    Super : isc.Class.Super,
    _delayedSuper : isc.Class._delayedSuper,
    invokeSuper : isc.Class.invokeSuper,

    _assert : isc.Class._assert

});

// NOTE: toString functions CANNOT be added by addMethods, because a property named "toString"
// will not be enumerated by for..in.  This is actually part of the ECMAScript standard!



//>    @classMethod    Class.toString()
//
//  The default toString() for a ClassObject reports that you have a ClassObject and what class
//  it is.
// @visibility external
//<
isc.Class.toString = function () {
    return "[Class " + this.Class + "]";
}

//>    @method    class.toString()
//
//  The default toString() for instances reports that you have an instance of a class and prints
//  the instance ID if present.
// @visibility external
//<
isc.Class.getPrototype().toString = function () {
    return "[" + this.Class + " ID:" + this.ID + "]";
}

//
//  Add Class properties (useful static properties to be referenced by other code)
//
isc.Class.addClassProperties({


    // make the isc namespace available on all Class objects
    ns : isc,

    //>    @classAttr  Class.NO_OP    (function : {} : IA)
    //      An empty (no-op) function.  Used as a default setting for event
    //      handlers to allow observation to occur.
    //      Added as a class constant rather than class method, since this will not be directly
    //      called on the Class object (as in "Class.NO_OP()"), so does not need the logic
    //      usually required for methods.
    //
    // @group    events
    //
    //<
    NO_OP : function() {},

    RET_TRUE : function () {
        return true;
    },

    //>    @classAttr  Class._stringMethodRegistry (object : {} : IA)
    //      This object is a map of method names to strings of arguments.
    //      It serves a dual purpose
    //      1 - Any properties listed in here are instance methods of this class which can legally
    //          be assigned string values to eval.
    //      2 - Allows you to get at the set of parameter names used in the string value (for
    //          converting the string to a function).
    //
    //<
    _stringMethodRegistry: {},

    useChromeAPIToPrepareStackTrace: true

});     // END isc.Class addClassProperties()

//
// add the observation methods to the ClassFactory as well so we can use 'em there
//
isc.addMethods(isc.ClassFactory, {
    observe : isc.Class.getPrototype().observe,
    ignore : isc.Class.getPrototype().ignore
});


//> @classMethod isc.eval()
// Evaluate a string of script and return the result. Falls through to
// +link{classMethod:Class.evaluate(),Class.evaluate()}
//
// @param expression (string) Expression to evaluate
// @return (any) Result of evaluating the expression passed in
// @visibility external
//<
// Additional 'hiddenIFrameEval' param indicating that we're evaluating a JSON block
// rather than executing arbitrary script.
// Note: this differs from a straight call to the native eval function in that you lose scope.
// You can workaround this by using the instance method 'evaluate()', and passing in a mapping
// of variable names to values to be available when the string executes.

isc.eval = function (expression, hiddenIFrameEval) {
    return isc.Class.evaluate(expression, null, false, hiddenIFrameEval);
}








  //>DEBUG
// This lets us label methods with a name within addMethods
Function.prototype.Class = "Function";
  //<DEBUG




// Utility methods for exploring and manipulating functions and methods
isc.ClassFactory.defineClass("Func");

isc.Func.addClassMethods({

    // create the static regular expression we use to parse out the name of a function
    _nameExpression : new RegExp("function\\s+([\\w$]+)\\s*\\("),
    parseFunctionName : function (func) {
        // derive the name from the function definition using a regular expression

        var match = isc.Func._nameExpression.exec(func.toString());
        if (match) return match[1];
        // if the regex didn't match, it's an anonymous function
        // NOTE that new Function().toString() is "function anonymous() { }" on both Moz and IE
        else return "anonymous";
    },

    // gets the name of a function as a string.  Uses
    getName : function (func, dontReport) {
        if (func == Function.prototype.apply) return "Function.apply";
        if (func == Function.prototype.call) return "Function.call";
        if (!func) {
            var undef;
            if (!arguments.callee || arguments.callee.caller === undef) return "unknown";
            if (!arguments.callee.caller) return "none";
            func = arguments.callee.caller;
        }
        // if we've previously determined our name or been explicitly labelled with a name, return
        // that
        if (func._fullName == null) {

            if (func._className == null && isc._allFuncs) {
                var index = isc._allFuncs.indexOf(func);
                if (index != -1) {
                    for (var className = isc._funcClasses[index]; className == null; index--) {
                        className = isc._funcClasses[index];
                    }
                    func._className = className;
                } else {
                    // fallback approach uses the fact that we give a global name to all
                    // functions to figure out what they are - works for functions that somehow
                    // miss out on the _allFuncs index.
                    var functionName = this.parseFunctionName(func);
                    //isc.logWarn("function: " + functionName + " not in index");
                    var isClassMethod;
                    if (functionName.startsWith("isc_c_")) {
                        functionName = functionName.substring(6);
                        isClassMethod = true;
                    } else {
                        functionName = functionName.substring(4);
                    }
                    className = functionName.substring(0, functionName.indexOf("_"));
                    methodName = functionName.substring(className.length+1);
                    var clazz = isc.ClassFactory.getClass(className),
                        method = null;
                    if (clazz) {
                        method = isClassMethod ?
                            clazz[methodName] : clazz.getInstanceProperty(methodName);
                    }
                    //if (method != null) {
                    //    isc.logWarn("lookup up method: " + this.echoLeaf(method) +
                    //                " equals func: " + (method == func));
                    //}
                }
            }

            // if we have a className but no function name, search the class (and instance
            // prototype) for the function
            var name = func._name,
                isClassMethod;
            if (name == null && func._className != null) {
                var theProto;
                var classObj = isc.ClassFactory.getClass(func._className);
                if (classObj == null) {
                    // support lookups for non-Class singletons like isc.ClassFactory and
                    // isc.FileLoader, and native globals like Array and Function
                    //Log.logWarn("className is: " + func._className);
                    classObj = isc[func._className] || window[func._className];
                } else {
                    theProto = classObj.getPrototype();
                }
                // check instance methods first (more common)
                if (theProto != null) {
                    for (var methodName in theProto) {
                        if (theProto[methodName] === func) {
                            name = methodName;
                            break;
                        }
                    }
                }
                // then class methods
                if (name == null && classObj != null) {
                    for (var methodName in classObj) {
                        if (classObj[methodName] === func) {
                            name = methodName;
                            isClassMethod = true;
                            break;
                        }
                    }
                    // if this is a native object, check the prototype methods as well
                    if (name == null && !isc.isA.Class(classObj) && classObj.prototype != null) {
                        for (var methodName in classObj.prototype) {
                            if (classObj.prototype[methodName] === func) {
                                name = methodName;
                                break;
                            }
                        }
                    }
                }
            }

            if (name != null) {
                func._fullName = (func._instanceSpecific ?
                                  (func._isOverride ? "[o]" : "[a]") : isc._emptyString) +
                                 (isClassMethod ? "[c]" : isc._emptyString) +
                                 (func._className ? func._className + isc.dot : isc._emptyString) +
                                  name;
            } else {
                if (func._isCallback) func._fullName = "callback";
                else {
                    func._fullName = isc.Func.parseFunctionName(func);
                }
            }
            //this.logWarn("function acquired _fullName: " + func._fullName);
        }

        return func._fullName;
    },

    //>    @method    Func.getArgs()    (A)
    //
    //     Gets the arguments to the function as an array of strings
    //
    //  @param  func (function) Function to examine
    //    @return    (array)    argument names for the function (array of strings)
    //                    returns an empty array if the function has no arguments.
    //<
    getArgs : function (func) {
        var args = isc.Func.getArgString(func);
        if (args == "") return [];
        return args.split(",");
    },

    //>    @method    Func.getArgString()    (A)
    //
    //     Gets the arguments to the function as a string of comma separated values
    //
    //  @param  func (function) Function to examine
    //    @return    (string)    argument names for the function separated by commas
    //                    returns an empty string if the function has no arguments.
    //<
    getArgString : function (func) {
        if (func._argString != null) return func._argString;
        var string = func.toString(),
            lparenPosPlus1 = string.indexOf("(") + 1,
            args = string.substring(lparenPosPlus1, string.indexOf(")", lparenPosPlus1));
        args = args.replace(/\/\*.*?\*\/|\/\/.*$/gm, isc.space);
        args = args.replace(/\s+/g, isc.emptyString);
        func._argString = args;
        return args;
    },

    //>    @method    Func.getBody()    (A)
    //
    //     Gets the body of the function as a string.<br><br>
    //
    //    NOTE: This is the body of the function after it has been parsed -- all comments will
    //            have been removed, formatting may be changed from the original text, etc.
    //
    //  @param func (function) function to examine
    //    @return    (strings)    body of the function as a string, without leading "{" and trailing "}"
    //<
    getBody : function (func) {
        var string = func.toString();

        return string.substring(string.indexOf("{") + 1, string.lastIndexOf("}"));
    },


    //>    @method    Func.getShortBody()    (A)
    //
    //     Gets the body of the function as a string, removing all returns so it's more
    //     compact.<br><br>
    //
    //    NOTE: This is the body of the function after it has been parsed -- all comments will
    //    have been removed, formatting may be changed from the original text, etc.
    //
    //  @param func (function) function to examine
    //    @return    (string)    body of the function as a string, without leading "{" and trailing "}"
    //<
    getShortBody : function (func) {
        var string = func.toString();

        return string.substring(string.indexOf("{") + 1, string.lastIndexOf("}")).replace(/[\r\n\t]*/g, "");
    }
});


// -----------------------------------------------------------------------------------------------
// function.apply()
// This is a native method in most browsers.
// If it's not already defined, supply the "apply" function.
// If it is already defined, patch it so it will not JS error if explicitly passed
// <code>null</code> as the arguments (2nd) parameter.






//>    @method    function.apply()    (A)
//
// Applies this function to <code>targetObject</code>, as if the function was originally
// defined as a method of the object.
//
//    @param    targetObject    (object)            target to apply the function to.  Within the context
//                                                of the function as it evaluates, <code>this</code> == <code>targetObject</code>
//    @param    args            (array of objects)    list of arguments to pass to the function
//
//    @return                    (varies)            returns the normal return value of the function
//<
if (!Function.prototype.apply) {

    // temporary function number for generating a new function name
    isc.addMethods(Function.prototype, {
        apply :    function (targetObject, args) {

//!DONTOBFUSCATE
            if (targetObject == null) targetObject = window;
            // generate a temporary function name
            var tempFunctionName = "__TEMPF_" + Function.prototype._tempFuncNum++;
            var returnValue;

            // assign the function being apply'd (this) to the targetObject
            targetObject[tempFunctionName]=this;


            // if no argments passed, set args to an empty array
            if (!args) args = [];

            if (args.length <= 10) {
                // Note any undefined properties of the args array will simply be
                // undefined arguments of the function being invoked via apply, as
                // they should be.  The arguments.length of the function will be off, but so be it
                returnValue = targetObject[tempFunctionName](args[0],args[1],args[2],args[3],args[4],
                                                             args[5],args[6],args[7],args[8],args[9]);
            } else {
                // The function is being called with more than ten arguments.

                // Construct a string with the code necessary to call the function with
                // however many arguments were passed, then eval() it.
                var    functionString = 'targetObject[tempFunctionName](';
                for (var i = 0; i < args.length; i++) {
                    functionString += "args" + '[' + i + ']';
                    if (i + 1 < args.length) {
                        functionString += ',';
                    }
                }
                functionString += ');';
                isc.eval('returnValue =' + functionString);
            }
            // remove the temporary function from the targetObject
            delete targetObject[tempFunctionName];
            // and return the value returned by the function call
            return returnValue;
        }
    });
    // counter which is used to generate unique names for functions to be applied
    Function.prototype._tempFuncNum = 0;
}




// Add some static helper methods to the Func class
isc.Func.addClassMethods({

    // Helper properties
    _commentDelimeters : [["//", "\n"], ["//", "\\n"], ["/*", "*/"]],
    _stringDelimeters : ["\"", "\'"],
    _complexIdentifiers : ["switch", "while", "if", "return", "for", "var"],
    _multiLineDelimeters : ["(", ")", "[", "]", "{", "}", ":", "?", "!",
                            "+", "-", "/", "*", "=", ">", "<","|", "&", ",", "\\"],

    //>     @method isc.Func.expressionToFunction() (A)
    //
    //      Given an expression or conditional as a string, convert it into
    //              a Function object.   Used to create functions that need to return
    //              values where the user specifies a string.  These were formerly done
    //              via evals.
    //
    //      @params variables       (string)                Names of variables to pass into the new function
    //      @params expression      (string)                String expression to evaluate return
    //
    //      @return (function)      function that returns the conditional value
    //<
    expressionToFunction : function (variables, expression, comment) {






        var returnValue = this._expressionToFunction(variables, expression, comment);



        return returnValue;
    },
    _actionToExpressionTemplate: [
        // Map target to global ID if needed
        "var ID=\"",                        // 0
        ,                                   // 1 (ID of target)
        "\",canvas=isc.isA.FormItem(this)?this.containerWidget:this;", // 2
        "if(canvas&&canvas.getByLocalId){var obj=canvas.getByLocalId(ID);if(obj&&obj.ID)ID=obj.ID;}", // 3
        // Warn if we can't find the target
        "if (!window[ID]){",                // 4
        "var message='Component ID \"",     // 5
        ,                                   // 6 (ID of target)
        "\", target of action \"",          // 7
        ,                                   // 8 (action title)
        "\" does not exist';isc.Log.logWarn(message);if(isc.designTime)isc.say(message);return}", // 9
        // Call the method on the target
        "window[ID].",                      // 10
        ,                                   // 11 method name
        "(",                                // 12
        ,                                   // 13 arguments [as a ',' separated string]
        ")"                                 // then close with ")"
    ],
    _resolveAction : function (action) {
        if (isc.isA.StringMethod(action)) action = action.getValue();

        else if (action.Action && !action.target) action = action.Action;
        return action;
    },
    _actionToExpressionString : function (action) {
        var template = this._actionToExpressionTemplate;

        // Plug the ID of the target, and the method to call into the function string.
        template[1] = template[6] = action.target;
        template[11] = action.name;
        if (action.title) template[8] = action.title;
        else template[8] = "[No title specified]";

        // mapping is an array of expressions to pass in as parameters
        var mapping = action.mapping || [];
        if (!isc.isAn.Array(mapping)) template[12] = null;
        else template[13] = mapping.join(); // automatically puts commas between args

        return template.join(isc._emptyString);
    },
    _expressionToFunction : function (variables, expression, comment) {


        if (expression == null) {
            //>DEBUG
            isc.Log.logInfo("makeFunctionExpression() called with empty expression");
            //<DEBUG
            expression = "";
        }

        // Handle being passed an action type object.
        // This is an object of the format
        //   { target:"componentId", name:"fetchData", title:"click" }
        // or
        //  { target: "someForm", name : "editRecord", title:"itemChanged",
        //    // action method param name -> expression to populate it
        //    mapping : {
        //        record : "record",
        //        callback : "someExpression()" // something use manually entered
        //    }
        //  }
        if (isc.isAn.Object(expression)) {
            var varsArray = variables;
            if (isc.isA.String(varsArray)) varsArray= variables.split(",");
            else if (isc.isAn.Array(varsArray)) {
                variables = varsArray.join();
            }
            if (!isc.isAn.Array(varsArray)) varsArray = [];

            expression = isc.Func._resolveAction(expression);

            var expressionString;
            if (isc.isAn.Array(expression)) {
                var numExpressions = expression.length;
                var expressionStrings = [];
                for (var i = 0; i < numExpressions; ++i) {
                    expression[i] = isc.Func._resolveAction(expression[i]);
                    if (!expression[i]) continue;
                    expressionStrings.add(isc.Func._actionToExpressionString(expression[i]));
                }
                expressionString = expressionStrings.join(";\n");
            } else {
                expressionString = isc.Func._actionToExpressionString(expression);
            }

            var theFunc;
            try {
                theFunc = isc._makeFunction(variables, expressionString);
            } catch (e) {
                this.logWarn("invalid code: " + expressionString +
                             " generated from action: " + this.echo(expression));
                theFunc = function () {};
            }
            theFunc.iscAction = expression;

            return theFunc;

        }

        var complexIdStartChars = "swirfv";


        // if variables passed in as an array of strings,
        // convert to a single string of vars separated by commas.
        //
        if (isc.isAn.Array(variables)) {
            variables = variables.join();
        }


        var isSimpleExpression = true;

        // loop through expression character by character. if there is any
        // indication that it contains more than one statement or a complex
        // statement, set isSimpleExpression to false and break.

        var i = 0; // character index.
        var commentDelimiters = this._commentDelimeters;
        var stringDelimiters = this._stringDelimeters;

        // strings that identify that a string is more than a simple expression
        var complexIdentifiers = this._complexIdentifiers;

        // the set of characters that can end a line while allowing a statement to continue onto the
        // next line
        var multiLineDelimiters = this._multiLineDelimeters;

        // keeps track of whether we've seen a semicolon.  Once we've seen a semicolon, anything
        // other than whitespace and comments indicates a multi-statement expression
        var commentsOnly = false;

        // set up some variables to avoid a bunch of string allocation during loops
        var nullString = isc._emptyString,
            commentStart = isc.slash,
            eol = "\n",
            backslash = "\\",
            plusSign = "+",
            semicolon = isc.semi;

        // keeps track of the last non-whitespace character,
        // so we know what it was when we get to the end of a line.
        var lastChar = nullString;

        // keeps track of the next non-whitespace character.
        var nextChar = nullString;

        // loop through each character of the expression
        while (i < expression.length) {
            var currentChar = expression.charAt(i);

            // check if we're in a comment by seeing if the current characters match any comment
            // openers
            if (currentChar == commentStart) {
                for (var j = 0; j < commentDelimiters.length; j++) {
                    var delimiterSet = commentDelimiters[j],
                        opener = delimiterSet[0],
                        closer = delimiterSet[1]
                    ;
                    //if (expression.substring(i, i + opener.length) == opener) {
                    if (expression.indexOf(opener, i) == i) {
                        // we're in a comment.. skip until we find the comment closer
                        var k = i + opener.length;
                        while (k < expression.length) {
                            if (expression.substring(k, k + closer.length) == closer) {
                                k = k + closer.length;
                                break;
                            }
                            k++;
                        }
                        i = k;
                        lastChar = nullString;
                        nextChar = this._getNextNonWhitespaceChar(expression, i);
                    }
                }
            }

            // we've seen a semicolon.  From here on, if we find anything other than a comment or
            // whitespace, we've got a complex expression
            if (commentsOnly) {
                // if we only have whitespace until the end, we can break now.
                if (nextChar == nullString) {
                    break;
                } else {
                    if (isc.isA.WhitespaceChar(currentChar)) {
                        i++;
                        continue;
                    } else {
                        isSimpleExpression = false;
                        break;
                    }
                }
            }

            // check for the beginning of string
            for (var j = 0; j < stringDelimiters.length; j++) {
                var delim = stringDelimiters[j]
                if (currentChar == delim) {
                    // we're in a string; find the next unquoted delimeter of the same kind
                    var k = i + 1;
                    while (k < expression.length) {
                        if (expression.charAt(k) == backslash) k = k + 2; // skip over escapes
                        if (expression.charAt(k) == delim) {
                            k++;
                            break;
                        }
                        k++;
                    }
                    i = k;
                    lastChar = delim.charAt(0);
                    nextChar = this._getNextNonWhitespaceChar(expression, i);
                }
            }

            // check if we've reached the end of a line
            if (currentChar == eol) {
                // see if the last character on the line is one that would allow the statement to
                // continue onto another line
                var isMLD = false;
                for (var j = 0; j < multiLineDelimiters.length; j++) {
                    if (lastChar == multiLineDelimiters[j]) {
                        isMLD = true;
                        break;
                    }
                }
                if (isMLD || nextChar == plusSign) {
                    lastChar = nullString;
                } else {
                    // the last character on this line closed a statement, and there's more
                    // characters, so this has to be a multi-statement expression
                    isSimpleExpression = false;
                    break;
                }
            }

            // look for semicolon
            if (currentChar == semicolon) {
                // set the commentsOnly flag to switch modes: from here on, if we find anything
                // other than a comment or whitespace, we've got a complex expression
                commentsOnly = true;
            }

            // check for keywords that indicate that this is not a simple expression
            // Note: There's a bug in string.charAt() in IE4 whereby a negative index will
            // return the first char of the string.
            // Therefore explicitly check whether the keyword is present and either at the
            // beginning or end of the string, or delimited by non AlphaNumeric chars.
            // (IE: it is the keyword, not just a substring of a non-keyword)

            // _complexIdentifiers : ["switch", "while", "if", "return", "for", "var"],
            if (complexIdStartChars.indexOf(currentChar) != -1) {

            for (var j = 0; j < complexIdentifiers.length; j++) {
                var word = complexIdentifiers[j],
                    length = word.length;

                if (
                     // Don't check if there are not enough characters for the keyword
                     (i + length <= expression.length) &&
                     // Is the keyword present?
                     (expression.substring(i, i+length) == word) &&
                     // Is it at the end of the string, or followed by a non Alpha char?
                     (i + length == expression.length ||
                      !isc.isA.AlphaNumericChar(expression.charAt(i + length))) &&
                     // Is it at the beginning of the string, or preceded by a non Alpha char?
                     (i == 0 ||
                      !isc.isA.AlphaNumericChar(expression.charAt(i - 1)))

                ) {
                    isSimpleExpression = false;
                    break;
                }
            }

            }

            // if the current char isn't whitespace, set it as the last non-whitespace char
            if (!isc.isA.WhitespaceChar(currentChar)) lastChar = currentChar;

            // increment
            i++;

            // set up a new nextChar
            nextChar = this._getNextNonWhitespaceChar(expression, i);
        }

        if (isSimpleExpression) {
            expression = "return " + expression;
        }
        // add a comment (if one was passed in) to the function
        // this lets us label the functions if we want to
        if (comment) expression = "/" + "/" + comment + "\r\n" + expression;

        // now create the new function and return it.
        var theFunc = isc._makeFunction(variables, expression);
        return theFunc;
    },

    //>    @method    isc.Func._getNextNonWhitespaceChar()    (A)
    //
    //     subroutine used by expressionToFunction(). gets the next non-whitespace character
    //     after the given index.
    //
    //  @params expression      (string)        String expression to evaluate return
    //    @params    index            (number)        index after which to look for nextChar
    //<
    _getNextNonWhitespaceChar : function (expression, index) {
        // set up a new nextChar
        var nextChar = isc._emptyString;
        for (var j = (index + 1); j < expression.length; j++) {
            if (!isc.isA.WhitespaceChar(expression.charAt(j))) {
                nextChar = expression.charAt(j);
                break;
            }
        }
        // we searched to the end of the string.
        if (j >= expression.length) nextChar = isc._emptyString;
        return nextChar;
    },


    //>    @method    isc.Func.convertToMethod()
    //
    //  A static version of class.convertToMethod()
    //    This takes an object and the name of a property as parameters, and (if legal)
    //  attempts to convert the property to a function.
    //  If the property's value is a function already, or the property is registered via
    //  Class.registerStringMethods() as being a legitimate target to convert to a function,
    //  return true.
    //  Otherwise return false
    //
    //  @param  object          (object)    object with property to convert
    //    @param    functionName     (string)    name of the property to convert to a string.
    //
    //    @return                    (boolean)   false if this is not a function and cannot be converted
    //                                      to one
    //
    //<
    convertToMethod : function (object, methodName) {

        // Handle bad parameters
        // XXX How to log this better - we know nothing about object, so can't do getID() or
        //     whatever
        if (!isc.isAn.Object(object) || !isc.isA.nonemptyString(methodName)) {
            isc.Log.logWarn("convertToMethod() called with bad parameters.  Cannot convert " +
                            " property '" + methodName + "' on object " + object +
                            " to a function.  Returning false.");
            return false;
        }

        // If the value of this property is already a function - we don't need to make any
        // changes, and can assume it's a legal property value.
        if (object[methodName] && isc.isA.Function(object[methodName])) return true;

        // By default the _stringMethodregistry map object is a static property on the Class
        // of the object passed in.
        // If the object passed in is not a member of a subclass of 'Class', this is not the case.
        // In these cases assume the _stringMethodRegistry map has been assigned to the object
        // directly (for now)
        // XXX - Currently this is not really used anywhere in the code, but potentially could
        // be for stringMethods on (for example) the ListViewer data array.
        var registry = (isc.isAn.Instance(object) ? object.getClass()._stringMethodRegistry :
                                                object._stringMethodRegistry);
        // return false if there's no registry.
        if (registry == null) return false;

        var undef;
        var methodParamsString = registry[methodName];

        // If the value is not in the map, return false - this property can't legally be
        // converted to a function by us, so don't attempt it!
        // triple "=" - check for identity not equivalence, as having the argument string be
        // null is legitimate.

        // If this method is not listed in the stringMethodRegistry, we can't convert the
        // property value to a method.
        if (methodParamsString === undef) return false;

        // We're dealing with a valid string method - attempt to convert the property value.
        isc.Func.replaceWithMethod(object, methodName, methodParamsString);

        // and return true to indicate that this is a legal slot for a function and should now
        // contain a function (if the conversion was possible).
        return true;
    },


    //>    @method    isc.Func.replaceWithMethod()    (A)
    //
    //     Given an object with a string property, convert the string to a function
    //    and assign it to the same property name.
    //
    //    This is useful when you expect developers to pass a method (such as an event handler,
    //  etc) as a string, but you need to execute it as a function.
    //
    //    @params    object        (object)    Object containing the property
    //    @params    methodName    (string)    Names of the method to convert from string to a function
    //    @params    variables    (string)    Names of variables to pass into the new function
    //<
    replaceWithMethod : function (object, methodName, variables, comment) {

        // If no string has been provided for the stringMethod, create a function with the
        // correct signature.  Signature has to match so that you can observe an undefined
        // string method.
        if (object[methodName] == null) {
            object[methodName] = isc.is.emptyString(variables)
                    ? isc.Class.NO_OP
                    : isc._makeFunction(variables, isc._emptyString);
        }

        var stringMethod = object[methodName];

        // already converted
        if (isc.isA.Function(stringMethod)) return;

        var convertedMethod;

        if (isc.isA.String(stringMethod) || isc.isA.Object(stringMethod)) {
            // expressionToFunction can handle stringMethods and 'action' type objects
            convertedMethod = isc.Func.expressionToFunction(variables, stringMethod, comment);
        } else {

            isc.Log.logWarn("Property '" + methodName + "' on object " + object + " is of type " +
                            typeof stringMethod + ".  This can not be converted to a method.",
                            "Function");

            return;
        }

        // add the converted function to the object:
        var temp = {};
        temp[methodName] = convertedMethod;
        isc.addMethods(object, temp);
    }

});




//>    @object    Array
// Generic extensions to JavaScript Arrays.  You can call these on any Array.
// <P>
// JavaScript's native Array is retrofitted to support the <code>List</code> API.
//
// @implements List
// @see List
// @treeLocation Client Reference/System
// @visibility external
//<

// Internal notes: Array vs the List interface
// - List is an interface which the native JavaScript Array object is retrofitted to implement
// - When a given method can be implemented solely in terms of other parts of the List interface,
//   there is the possibility that Array and the List interface can share the actual JavaScript
//   function object.  When this is done, the method is first defined on Array (for load order
//   reasons).
// - on Array, several methods can be faster if they use various native functions (like splice()),
//   and so a unique implementation appears here
// - on List, in order to allow a valid List implementation with a minimum of effort, all methods
//   boil down to very simple primitives like addAt

// - public documentation for the List interface is in List.js

//> @groupDef dataChanged
// Operations that change the Array
// @title Data Changes
//<

//> @groupDef iteration
// Operations on entire Arrays at once
// @title Iteration
//<

//> @groupDef arrayMath
// Math operations on entire Arrays at once
// @title Array Math
//<

// add a "Class" property to the array prototype
//    so we can recognize Array instances
Array.prototype.Class = "Array";

//>    @classMethod        Array.newInstance()
//        Create a new array, adding any arguments passed in as properties.
//        Here so we can make standard newInstance() calls on arrays.
//
//        @param    [all arguments]    (object)    objects with properties to override from default
//        @return    (array)    new array.
//<
Array.newInstance = function () {
    var instance = [];
    isc.addPropertyList(instance, arguments);
    return instance;
}
Array.create = Array.newInstance;

//> @classMethod Array.duplicate()
// Return an array that is a shallow copy of the supplied array, that is, containing the same
// items.
//
// @param array (Array) array to duplicate
// @return      (Array) new array
//<
Array.duplicate = function (array) {
    return isc._emptyArray.concat(array);
},

//> @classMethod Array.createFromItemArgs()
// Return a new array consisting of the provided arguments as array items.
//
// @param [(arguments 1-N)] (object) objects to add as items of the new array
// @return (Array) new array
//<
Array.createFromItemArgs = function () {
    return Array.prototype.slice.call(arguments);
},

//> @classAttr Array.LOADING (String : "loading" : IRA)
// Marker value returned by Lists that manage remote datasets, indicating the requested data is
// being loaded. Note that the recommended test for loading data is to call +link{Array.isLoading()}
// rather than compare to this value directly.
// @visibility external
//<

Array.LOADING = "loading";

//> @classMethod Array.isLoading() (A)
// Is the object passed in a loading marker value? For use with Lists that manage remote
// datasets, to indicate that a record has not yet been retrieved from the server. A typical
// use case might be to check if a row has been loaded in a ListGrid - for example:
// <P>
// <code>
// if (Array.isLoading(myList.getRecord(0))) isc.warn("Please wait for the data to load.");
// </code>
// @param value (any) data to test.
// @visibility external
//<
Array.isLoading = function (row) {

    return row != null &&

            !isc.isAn.XMLNode(row) &&

            (row === Array.LOADING);
}

//> @classAttr Array.CASE_INSENSITIVE (Function : See below : R)
// This is a built-in comparator for the +link{array.find,find} and +link{array.findIndex,findIndex}
// methods of Array.  Passing this comparator to those methods will find case-insensitively,
// so, eg, <code>find("foo", "bar")</code> would find objects with a "foo" property set to
// "Bar", "BAR" or "bar"
// @visibility external
//<
Array.CASE_INSENSITIVE = function(arrayMemberProperty, comparisonProperty, propertyName) {
    return (
        arrayMemberProperty == comparisonProperty ||
        (isc.isA.String(arrayMemberProperty) &&
         isc.isA.String(comparisonProperty) &&
         arrayMemberProperty.toLowerCase() == comparisonProperty.toLowerCase()));
};

//> @classAttr Array.DATE_VALUES (Function : See below : R)
// This is a built-in comparator for the +link{array.find,find} and +link{array.findIndex,findIndex}
// methods of Array.  Passing this comparator to those methods will find instances where Dates
// in the search criteria match Dates in the array members (ordinarily, Javascript only regards
// Dates as equal if they refer to the exact same object).  This comparator compares <i>logical</i>
// dates; the time elements of the values being compared are ignored, so two Dates representing
// different times on the same day will be considered equal.
// @see Array.DATETIME_VALUES
// @visibility external
//<
Array.DATE_VALUES = function(arrayMemberProperty, comparisonProperty, propertyName) {
    return (
        arrayMemberProperty == comparisonProperty ||
        (isc.isA.Date(arrayMemberProperty) &&
         isc.isA.Date(comparisonProperty) &&
         Date.compareLogicalDates(arrayMemberProperty, comparisonProperty) == 0));
};

//> @classAttr Array.DATETIME_VALUES (Function : See below : R)
// This is a built-in comparator for the +link{array.find,find} and +link{array.findIndex,findIndex}
// methods of Array.  Passing this comparator to those methods will find instances where Dates
// in the search criteria match Dates in the array members (ordinarily, Javascript only regards
// Dates as equal if they refer to the exact same object).  This comparator compares entire
// date values, including the time elements of the values being compared, so two Dates
// representing different times on the same day (even if they are only a millisecond apart)
// will not be considered equal.
// @see Array.DATE_VALUES
// @visibility external
//<
Array.DATETIME_VALUES = function (arrayMemberProperty, comparisonProperty, propertyName) {

    return (
        arrayMemberProperty == comparisonProperty ||
        (isc.isA.Date(arrayMemberProperty) &&
         isc.isA.Date(comparisonProperty) &&
         Date.compareDates(arrayMemberProperty, comparisonProperty) == 0));
};


if (!Array.prototype.localeStringFormatter)
    Array.prototype.localeStringFormatter = "toString";

//> @classAttr Array.excludeFromSortProperty (String : "_excludeFromSort" : IRA)
// If this property is set on a record, calling +link{Array.add} won't trigger
// a sort even if +link{Array.sortProps} are set.
//<
Array.excludeFromSortProperty = "_excludeFromSort";

// add a bunch of methods to the Array prototype so all arrays can use them
isc.addMethods(Array.prototype, {

iscToLocaleString : function () {
    return this[this.localeStringFormatter]();
},

//>    @method        array.getPrototype()
//        Return the Array.prototype -- for conformity with the Class.getPrototype() method
//        Used in exporting arrays.
//<
getPrototype : function () {
    return Array.prototype;
},


//>    @method        array.newInstance()
//        Create a new array, adding any arguments passed in as properties.
//        Here so we can make standard newInstance() calls on arrays.
//
//        @param    [all arguments]    (object)    objects with properties to override from default
//        @return    (array)    new array.
//<
newInstance : Array.newInstance,
create : Array.newInstance,

// List Interface
// --------------------------------------------------------------------------------------------

//>    @method        array.get()
// @include list.get()
//<
get : function (pos) {
    return this[pos]
},

//>    @method        array.getLength()
// @include list.getLength()
//<
getLength : function () {
    return this.length
},

//>    @method        array.isEmpty()
// @include list.isEmpty()
//<
// NOTE: implementation stolen by List interface.  Must use only List API for internal access.
isEmpty : function () {
    return this.getLength() == 0;
},

//>    @method        array.first()
// @include list.first()
//<
first : function () {
    return this[0]
},

//>    @method        array.last()
// @include list.last()
//<
last : function () {
    return this[this.length-1]
},

nativeIndexOf : Array.prototype.indexOf,

//>    @method        array.indexOf()
// @include list.indexOf()
//<

indexOf : function (obj, pos, endPos, comparator) {
    var OBJ = Object(this),
        length = OBJ.length >>> 0;

    // normalize position to the start of the list
    if (pos == null) pos = 0;
    else if (pos < 0) pos = Math.max(0, length + pos);
    if (endPos == null) endPos = length - 1;

    var hasComparator = (comparator != null);
    for (var i = pos; i <= endPos; i++) {
        if (hasComparator ? comparator(OBJ[i], obj) : OBJ[i] == obj) {
            return i;
        }
    }

    // not found -- return the not found flag
    return -1;
},


fastIndexOf : function (obj, pos, endPos) {
    // normalize position to the start of the list
    if (pos == null) pos = 0;
    if (endPos == null) endPos = this.length - 1;

    for (var i = pos; i <= endPos; i++) {
        if (this[i] == obj) {
            return i;
        }
    }

    // not found -- return the not found flag
    return -1;
},

nativeLastIndexOf : Array.prototype.lastIndexOf,

//>    @method        array.lastIndexOf()
// @include list.lastIndexOf()
//<

lastIndexOf : function (obj, pos, endPos, comparator) {
    var OBJ = Object(this),
        length = OBJ.length >>> 0;

    // normalize position to the end of the list
    if (pos == null) pos = length - 1;
    else if (pos < 0) {
        pos = length + pos;
        if (pos < 0) return -1;
    }
    if (endPos == null) endPos = 0;

    var hasComparator = (comparator != null);
    for (var i = pos; i >= endPos; i--) {
        if (hasComparator ? comparator(OBJ[i], obj) : OBJ[i] == obj) {
            return i;
        }
    }

    // not found -- return the not found flag
    return -1;
},

//>    @method        array.contains()
// @include list.contains()
//<
// NOTE: implementation stolen by List interface.  Must use only List API for internal access.
contains : function (obj, pos, comparator) {
    return (this.indexOf(obj, pos, null, comparator) != -1);
},

_containsDuplicates : function (comparator) {
    for (var i = 0, len = this.length; i < len - 1; ++i) {
        var obj = this[i];
        if (this.contains(obj, i + 1, comparator)) return true;
    }
    return false;
},

// helper method for doing a substring search

containsSubstring : function (obj, startPos, endPos, ignoreCase, matchStyle) {
    if (obj == null) return true;
    if (matchStyle == null) matchStyle = "substring";
    var result = this.indexOf(obj, startPos, endPos, function (a, b) {
        var filter = b == null ? null : (isc.isA.String(b) ? b : b.toString()),
            value = a == null ? null : (isc.isA.String(a) ? a : a.toString())
        ;
        if (ignoreCase) {
            if (filter != null) filter = filter.toLowerCase();
            if (value != null) value = value.toLowerCase();
        }
        var r = false;
        if (value != null && filter != null) {
            if (value == filter) {
                r = true;
            } else if (matchStyle == "substring" &&
                                        value && value.contains && value.contains(filter))
            {
                r = true;
            } else if (matchStyle == "startsWith" &&
                                        value && value.startsWith && value.startsWith(filter))
            {
                r = true;
            }
        }
        return r;
    });

    return result >= 0;
},

//> @method     array.containsAll()
// @include list.containsAll()
//<
// NOTE: implementation stolen by List interface.  Must use only List API for internal access.
containsAll : function (list) {
    if (list == null) return true;
    var length = list.getLength();
    for (var i = 0; i < length; i++) {
        if (!this.contains(list.get(i))) return false;
    }
    return true;
},

// string-based method - substring search - returns true if all of the values from the passed
// list appear somewhere in the contents of the values in this list
containsAllSubstring : function (list, ignoreCase) {
    if (list == null) return true;
    var length = list.getLength();
    for (var i = 0; i < length; i++) {
        if (!this.containsSubstring(list.get(i), null, null, ignoreCase)) return false;
    }
    return true;
},

//>    @method        array.intersect()
// @include list.intersect()
//<
// NOTE: implementation stolen by List interface.  Must use only List API for internal access.
intersect : function () {
    var results = [];

    // for each element in this array
    for (var i = 0; i < this.length; i++) {
        // if the element is in each argument, add it to the results
        var item = this.get(i),
            isPresent = true;

        // skip null elements
        if (item == null) continue;

        // for each array passed in
        for (var a = 0; a < arguments.length; a++) {
            // if the item is not in that array
            if (!arguments[a].contains(item)) {
                // it hasn't been found
                isPresent = false;
                break;
            }
        }
        if (isPresent) results.add(item);
    }

    // return true
    return results;
},

// variant of intersect that specifically deals with arrays of dates, which need to be compared
// with compareDates() and compareLogicalDates()
intersectDates : function () {
    var results = [];

    // for each element in this array
    for (var i = 0; i < this.length; i++) {
        // if the element is in each argument, add it to the results
        var item = this.get(i),
            isPresent = true
        ;

        // skip null elements
        if (item == null) continue;

        var logicalDate = item.logicalDate;

            // for each array passed in
        for (var a = 0; a < arguments.length; a++) {
            var otherArray = arguments[a];
            var inOtherArray = false;
            if (!otherArray) continue;
            for (var b = 0; b < otherArray.length; b++) {
                var otherItem = otherArray[b];
                if (!otherItem) continue;
                if (logicalDate) {
                    if (Date.compareLogicalDates(item, otherItem) == 0) {
                        inOtherArray = true;
                        break;
                    }
                } else {
                    if (Date.compareDates(item, otherItem) == 0) {
                        inOtherArray = true;
                        break;
                    }
                }
            }
            if (!inOtherArray) {
                isPresent = false;
                break;
            }
        }
        if (isPresent) results.add(item);
    }

    return results;
},

// variant of intersect that compares arrays of values as strings - returns entries from this
// array that appear as a substring of at least one entry in each of the passed arrays

_intersectSubstringIgnoreCase: true,
intersectSubstring : function (lists, ignoreCase, matchStyle) {
    // If the "lists" param is not a list of lists, make it one
    if (!isc.isAn.Array(lists)) lists = [lists];
    if (!isc.isAn.Array(lists[0])) lists =[lists];
    var results = [];
    if (ignoreCase == null) ignoreCase = this._intersectSubstringIgnoreCase;
    ;

    // for each element in this array
    for (var i = 0; i < this.length; i++) {
        // if the element is in each argument, add it to the results
        var item = this.get(i),
            isPresent = true;

        // skip null elements
        if (!item) continue;

        // for each array passed in
        for (var a = 0; a < lists.length; a++) {
            var otherArray = lists[a];
            if (!otherArray) continue;

            // match if any of the elements in the passed array contains "item" as a substring
            if (!otherArray.containsSubstring(item, null, null, ignoreCase, matchStyle)) {
                isPresent = false;
                break;
            }
        }
        if (isPresent) results.add(item);
    }

    // return true
    return results;
},

//>    @method        array.equals()
// @include list.equals()
//<
// NOTE: implementation stolen by List interface.  Must use only List API for internal access.
equals : function (list) {
    if (list == null || !isc.isA.List(list)) return false;

    var length = list.getLength();

    // arrays of differing lengths cannot be equals
    if (length != this.getLength()) return false;

    for (var i = 0; i < length; i++) {
        if (list.get(i) != this.get(i)) return false;
    }
    return true;
},

//>    @method        array.getItems()
// @include list.getItems()
//<
// NOTE: implementation stolen by List interface.  Must use only List API for internal access.
getItems : function (itemList) {
    var length = itemList.getLength(),
        outputs = new Array(length);
    for (var i = 0; i < length; ++i) {
        outputs[i] = this.get(itemList.get(i));
    }
    return outputs;
},

//>    @method        array.getRange()
// @include list.getRange()
//<
getRange : function (start, end) {
    if (end == null) end = this.length - 1;
    return this.slice(start, end);
},

//>    @method        array.duplicate()    (A)
// @include list.duplicate()
//<

duplicate : function () {
    return isc._emptyArray.concat(this); // NOTE: concat creates a copy
},

// getData() from list - no analogous method

//>    @method        array.set()
// @include list.set()
//<
set : function (pos, item) {
    var result = this[pos];
    this[pos] = item;
    this.dataChanged();
    return result;
},

//>    @method        array.addAt()
// @include list.addAt()
//<
addAt : function (obj, pos) {
    if (pos == null) pos = 0;

    this.splice(pos, 0, obj);

    // call dataChanged in case anyone is observing it
    this.dataChanged();

    // return the object that was added
    return obj;
},

//>    @method        array.removeAt()
// @include list.removeAt()
//<
removeAt : function (pos) {
    // make sure the pos passed in is valid
    var length = this.length;
    if (pos >= length || pos < 0) return null;

    var removedList = this.splice(pos, 1);

    // call dataChanged in case anyone is observing it
    this.dataChanged();

    return removedList[0];
},

//>    @method        array.add()
// @include list.add()
//<
add : function (object, secondArg, disallowSortingOnLoadingMarker) {
    var undef;
    if (secondArg !== undef) {
        // support calling as add(index, object)
        return this.addAt(object, secondArg);
    }
    var pos;
    // if the list.sortUnique is true, we're only supposed to have each item once
    if (this.sortUnique) {
        // find the current position of the item in the list
        pos = this.indexOf(object);
        // if it wasn't found, put it at the end
        if (pos == -1) pos = this.length;
    } else {
        // otherwise we always put the item at the end
        pos = this.length;
    }
    // actually stick the object in the list
    this[pos] = object;

    // if we are currently sorted, maintain current sort

    if (!this._addListRunning) {
        if (this.sortProps && this.sortProps.length > 0 &&
            (object == null || !object[Array.excludeFromSortProperty]))
        {

            this.sortByProperties(
                this.sortProps, this.sortDirections, this.sortNormalizers, undef, undef,
                false, disallowSortingOnLoadingMarker);
        }

        // call dataChanged in case anyone is observing it
        this.dataChanged();
    }

    // return the object that was added
    return object;
},

//>    @method        array.addList()
// @include list.addList()
//<
// NOTE: implementation stolen by List interface.  Must use only List API for internal access.
addList : function (list, listStartRow, listEndRow) {
    if (list == null) return null;

    this._startChangingData();

    if (listStartRow == null) listStartRow = 0;
    if (listEndRow == null) listEndRow = list.getLength();

    var recursive = this._addListRunning;
    this._addListRunning = true;
    var mustResort = false;
    for (var pos = listStartRow; pos < listEndRow; pos++) {
        var object = list.get(pos)
        this.add(object);
        if (object != null && !object[Array.excludeFromSortProperty]) mustResort = true;
    }
    if (!recursive) delete this._addListRunning;

    if (this.sortProps && this.sortProps.length > 0 && mustResort) {

        var undef;
        this.sortByProperties(
            this.sortProps,
            this.sortDirections,
            this.sortNormalizers,
            undef,
            undef,
            false
        );
    }

    this._doneChangingData();

    // return the objects that were added
    return list;
},

//>    @method        array.setLength()
// @include list.setLength()
//<
setLength : function (length) {
    this.length = length;
},

//>    @method        array.addListAt()
// @include list.addListAt()
//<
addListAt : function (list, pos) {
    if (list == null) return null;

    // extract the tail of this array, from pos through the end
    var tail = this.splice(pos, this.length - pos);

    // add the new items in list
    this.push.apply(this, list);

    // add back the tail
    this.push.apply(this, tail);

    // call dataChanged in case anyone is observing it
    this.dataChanged();

    // return the list that was added
    return list;
},


//>    @method        array.remove()
// @include list.remove()
//<
remove : function (obj) {


    var index = this.indexOf(obj);
    if (index == -1) return false;

    this.removeAt(index);
    // removeAt() calls dataChanged().

    return true; // indicating object was removed, per java.util.Collection
},

//>    @method        array.removeList()
// @include list.removeList()
//<
removeList : function (list) {
    if (list == null) return null;

    // run through all the items, putting things we want to retain into new list output
    for (var output = [], i = 0, l = this.length;i < l;i++) {
        if (!list.contains(this[i])) output.add(this[i]);
    }
    // now set the items in this list to the items in output
    this.setArray(output);

    // return the list that was removed
    return list;
},

// useful in chaining expressions eg someList.removeEvery(null).getProperty(...)
// .. removeList/removeAll don't work in this circumstance
removeEvery : function (value) {
    this.removeList([value]);
    return this;
},

// methods to ensure dataChanged() fired only once when a series of changes are made: see List.js
_startChangingData : function () {
    var undef;
    if (this._dataChangeFlag === undef) this._dataChangeFlag = 0;
    this._dataChangeFlag++;
},

_doneChangingData : function () {
    if (--this._dataChangeFlag == 0) this.dataChanged();
},

//>    @method        array.dataChanged()    (A)
// @include list.dataChanged()
//<
dataChanged : function () {

    if (this.onDataChanged) this.onDataChanged()
},

// In some cases we want to perform a one-liner - call dataChanged unless we're inside a data
// changing loop
_isChangingData : function () {
    return (this._dataChangeFlag != null && this._dataChangeFlag > 0);
},

// End of List API
// --------------------------------------------------------------------------------------------

//>    @method        array.setArray()
// Completely change the contents of one array to the contents of another array.
// <P>
// This is useful if you have an external pointer to an array, but you want to change its
// contents, such as when you remove some items from the array.
//
//        @group    dataChanged
//
//        @param    (array)        array to set this array to
//<
setArray : function (list) {
    this.setLength(0);

    // fill slots
    this.push.apply(this, list);

    // call dataChanged in case someone is observing data in the list
    this.dataChanged();
},

//>    @method        array.addAsList()
// Add either a single object or a list of items to this array.
//
//        @group    dataChanged
//
//        @param    list    (array or object)        a single object or a list of items to add
//
//        @return    (list)                list of items that were added
//<
addAsList : function (list) {
    if (!isc.isAn.Array(list)) list = [list];
    // return the objects that were added
    return this.addList(list);
},

//>    @method        array.removeRange()
// Remove and return a range of elements from an array - same return value as array.slice(),
// but removes the slice from the array
//
//        @group    dataChanged
//
//        @param    startPos    (number)    start position of range to remove
//      @param  endPos      (number)    end position of range to remove
//
//      @return (array) array of items that were removed
//<
removeRange : function (startPos, endPos) {
    // fall through to splice
    var undef;
    if (startPos === undef) return this;    // no arguments
    if (!isc.isA.Number(startPos)) startPos = 0;
    if (!isc.isA.Number(endPos)) endPos = this.length;
    return this.splice(startPos, endPos - startPos);
},

//>    @method        array.removeWhere()
//            Remove all instances of object from this array
//        @group    dataChanged
//
//        @param    property    (string)    property to look for
//        @param    value        (string)    value to look for
//<
removeWhere : function (property, value) {
    for (var i = 0, newList = []; i < this.length; i++) {
        if (!this[i] || this[i][property] != value) {
            newList.add(this[i]);
        }
    }
    this.setArray(newList);
},

// Corollary to removeWhere - remove every item where some property is not set to some
// specified value.
removeUnless : function (property, value) {
    for (var i = 0, newList = []; i < this.length; i++) {
        if (this[i] && this[i][property] == value) {
            newList.add(this[i]);
        }
    }
    this.setArray(newList);
},

//>    @method        array.removeEmpty()
//            Remove all empty slots in this array (where array[n] == null)
//        @group    dataChanged
//<
removeEmpty : function (property, value) {
    for (var i = 0, newList = []; i < this.length; i++) {
        if (this[i] != null) {
            newList.add(this[i]);
        }
    }
    this.setArray(newList);
},

//> @method array.getProperty()
// @include list.getProperty
// @visibility external
//<
getProperty : function (property) {
    var output = new Array(this.length);
    for (var i = this.length; i--; ) {
        var entry = this[i];
        output[i] = (entry ? entry[property] : null);
    }
    return output;
},

//>@method array.getValueMap()
// @include list.getValueMap()
// @visibility external
//<
getValueMap : function (idField, displayField) {
    var valueMap = {},
        length = this.getLength()
    ;
    if (isc.isA.ResultSet(this) && !this.lengthIsKnown() && this.initialData) {
        // if this is a ResultSet of unknown length but with initialData, use the length of
        // the initialData - see similar code in ListGrid._updateValueMapFromODS
        length = this.initialData.getLength();
    }
    for (var i = 0, l = length; i < l; i++) {
        var item = this.get(i);
        // Don't attempt to pull properties from empty values / basic data types in the list.
        if (!isc.isAn.Object(item)) continue;
        if (item && item[idField] != null) {
            valueMap[item[idField]] = item[displayField];
        }
    }
    return valueMap;
},

//>    @method        array.map()
// Return an array where the value of item <code>i</code> is the result of calling the provided
// function on item <code>i</code> in this array.
// <P>
// The function to call can either be provided directly as a function object, in which case it
// is invoked with the item as the first argument, or can be provided as the String name of a
// method present on each item, which will be invoked.  In the latter case, if any item is null
// or lacks the named method, null will be returned for that item.
// <P>
// Examples:<PRE>
//    // line up widgets at 20 pixels from page edge
//    [widget1, widget2].map("setPageLeft", 20);
//
//    // find furthest right widget
//    [widget1, widget2].map("getPageRight").max();
// </PRE>
//
//        @group    iteration
//
//        @param    method  (string or function) function object, or name of method
//        @param    [arguments 1-N]    (any)         arguments to pass to the function or method
//                                           invoked on each item
//        @return    (array)        array of returned values
// @visibility external
//<
map : function (method, arg1, arg2, arg3, arg4, arg5) {
    var OBJ = Object(this),
        isFunc = isc.isA.Function(method);

    var undef,
        mimicNativeImp = isFunc &&
                        (arg1 === undef || isc.isAn.Object(arg1)) &&
                         arg2 === undef && arg3=== undef && arg4 === undef && arg5 === undef;

    var length;
    if (mimicNativeImp) {
        length = OBJ.length >>> 0;
    } else {
        length = OBJ.getLength();
    }

    var output = new Array(length);
    for (var i = 0; i < length; ++i) {
        var item;

        if (mimicNativeImp) {
            item = OBJ[i];
            output[i] = method.call(arg1, item, i, OBJ);

        } else {
            item = OBJ.get(i);
            if (isFunc) {
                output[i] = method(item, arg1, arg2, arg3, arg4, arg5);
            } else {
                output[i] = (item && item[method] != null ?
                             item[method](arg1, arg2, arg3, arg4, arg5) : null);
            }
        }
    }
    return output;
},

//>    @method        array.setProperty()
//    Set item[property] = value for each item in this array.
//        @group    iteration
//
//        @param    property    (string)    name of the property to set
//        @param    value        (any)        value to set to
// @visibility external
//<
setProperty : function (property, value) {
    for(var i = 0, l = this.length;i < l;i++)
        if (this[i]) this[i][property] = value;
},

//>    @method        array.clearProperty()
// Delete property in each item in this array.
//        @group    iteration
//
//        @param    property     (string)    name of the property to clear
// @return (boolean) returns true if any of the properties in the array had a value for the
//     specified property.
// @visibility external
//<
clearProperty : function (property) {
    var hadValue = false, undef;
    for(var i = 0, l = this.length;i < l;i++) {
        hadValue = hadValue || this[i] !== undef;
        if (this[i]) delete this[i][property];
    }
    return hadValue;
},


_extractProperty : function (property) {
    var hadValue = false,
        output = new Array(this.length),
        undef;
    for (var i = this.length; i--; ) {
        var record = this[i];
        hadValue = hadValue || (record !== undef);
        if (record) {
            output[i] = record[property];
            delete record[property];
        } else {
            output[i] = null;
        }
    }
    return (hadValue ? output : null);
},

//>    @method        array.getProperties()
// Return a copy of the array where each object has only the list of properties provided.
//        @group    iteration
//
//        @param    properties    (string[])    names of the properties you want to export
//                            (object)    object with the properties you want to export
//
//        @return    (Array)        new Array with each item limited to the specified properties
//<
getProperties : function (properties) {
    return isc.applyMask(this, properties);
},

//>    @method        array.getUniqueItems()
// Return a list of each unique item in this list exactly once.
// <P>
// Returns in the same order they were found in the list.
// <P>
// Usage example:<br>
// &nbsp;&nbsp;&nbsp;&nbsp;uniqueList = myArray.getProperty("foo").getUniqueItems();
//
//        @group    subset
//
//        @return    (array)    list of each unique item in the list
// @visibility external
//<
getUniqueItems : function () {
    for (var output = [], i = 0, l = this.length; i < l; i++) {
        if (!output.contains(this[i])) output[output.length] = this[i];
    }
    return output;
},

//>    @method        array.slice()
// Return a contiguous range of rows of the array.
// DOES NOT include element at position <code>end</code> (similar to .substring())
// <P>
// NOTE: uses browser's native implementation if one is provided
//
// @param    start    (number)    start index
// @param    [end]    (number)    end index, if not specified will be list.length
//
// @return    (array)    new array with items from start -> end-1 in it
// @group    subset
//<
slice :
    (Array.prototype.slice
        ? Array.prototype.slice
        : function (start, end) {
            if (end == null) end = this.length;
            for(var output = [], l = this.length; start < end && start < l;start++)
                output[output.length] = this[start];
            return output;
        }
    ),

//>    @method array.findIndex()
// @include list.findIndex
//<

findIndex : function (property, value, comparator) {
    if (!isc.isA.Function(property)) {
        return this.findNextIndex(0, property, value, null, comparator);
    } else if (isc.isA.List(this)) {
        // NOTE: implementation stolen by List interface.  Must use only List API for internal access.
        return this.findNextIndex(0, property, value, null, comparator);
    }
    var OBJ = Object(this);
    return Array.prototype.findNextIndex.call(OBJ, 0, property, value, null, comparator);
},

//>    @method array.findNextIndex()
// @include list.findNextIndex
//<
findNextIndex : function (start, property, value, endPos, comparator) {
    var OBJ = Object(this),
        len = OBJ.length >>> 0;
    if (start == null) start = 0;
    else if (start >= len) return -1;
    if (endPos == null) endPos = len - 1;

    if (property == null) return -1;

    var up = endPos >= start;

    if (isc.isA.String(property)) {
        // single property to match
        if (comparator) {
            for (var i = start; (up ? i <= endPos : i >= endPos) ; (up ? i++ : i--)) {
                if (this[i] && comparator(this[i][property], value, property)) return i;
            }
        } else {
            for (var i = start; (up ? i <= endPos : i >= endPos) ; (up ? i++ : i--)) {
                if (this[i] && this[i][property] == value) return i;
            }
        }
        return -1;


    } else if (isc.isA.Function(property)) {
        var predicate = property,
            thisArg = value;
        for (var i = start; (up ? i <= endPos : i >= endPos) ; (up ? i++ : i--)) {
            value = OBJ[i];
            if (predicate.call(thisArg, value, i, OBJ)) return i;
        }
        return -1;

    } else {
        // "property" is an object specifying a set of properties to match
        return this.findNextMatch(property, start, endPos, comparator);
    }
},

findAllIndices : function (property, value, comparitor) {
    var matches = [];
    var start = 0;
    var match;
    do {

        match = this.findNextIndex(start, property, value, null, comparitor);
        if (match != -1) {
            matches.add(match);
            start = match+1;
        }

    } while (match != -1);
    return matches;
},

// internal: assumes multiple properties
findNextMatch : function (properties, start, end, comparator) {
    if (properties._constructor == "AdvancedCriteria") {
        if (isc.DataSource == null) {
            isc.warn("DataBinding module not loaded, AdvancedCriteria not supported for find()/findAll()");
            return -1;
        }
        var dataSource = this.dataSource || isc.DataSource;
        var result = dataSource.applyFilter(this.getRange(start, end + 1), properties);
        if (result.size() != 0) return this.findIndex(result.get(0));
        else return -1;
    }

    var propertyNames = isc.getKeys(properties),
        up = end >= start;

    // This processing is largely duplicated, to avoid a check on comparator in the inner loop
    if (comparator) {
        for (var i = start; (up ? i <= end : i >= end); (up ? i++ : i--)) {
            var item = this.get(i);
            if (!item) continue;
            var found = true;
            for (var j = 0; j < propertyNames.length; j++) {
                var propertyName = propertyNames[j];
                if (!comparator(item[propertyName], properties[propertyName], propertyName)) {
                    found = false;
                    break;
                }
            }
            if (found) return i;
        }
    } else {
        for (var i = start; (up ? i <= end : i >= end); (up ? i++ : i--)) {
            var item = this.get(i);
            if (!item) continue;
            var found = true;
            for (var j = 0; j < propertyNames.length; j++) {
                var propertyName = propertyNames[j];
                if (item[propertyName] != properties[propertyName]) {
                    found = false;
                    break;
                }
            }
            if (found) return i;
        }
    }
    return -1;
},

//>    @method array.find()
// @include list.find
//<

find : function (property, value, comparator) {
    // NOTE: implementation stolen by List interface.  Must use only List API for internal access.
    if (!isc.isA.Function(property) || isc.isA.List(this)) {
        var index = this.findIndex(property, value, comparator);
        return (index != -1) ? this.get(index) : null;
    }
    var OBJ = Object(this),
        index = Array.prototype.findIndex.call(OBJ, property, value, comparator);

    // The native find() method returns `undefined' when the predicate does not return true for
    // any value.
    if (index == -1) {
        var undef;
        return undef;
    }
    return ("get" in OBJ ? OBJ.get(index) : OBJ[index]);
},

// given values for the primary key fields ("record"), find the _index of_ the unique
// matching record.
// Will automatically trim extra, non-key fields from "record"
findByKeys : function (record, dataSource, pos, endPos) {
    if (record == null) {
        //>DEBUG
        isc.Log.logWarn("findByKeys: passed null record");
        //<DEBUG
        return -1;
    }

    // get the values for all the primary key fields from the passed record
    var findKeys = {},
        keyFields = dataSource.getPrimaryKeyFields(),
        hasKeys = false;

    for (var keyField in keyFields) {
        hasKeys = true;
        if (record[keyField] == null) {
            //>DEBUG
            isc.Log.logWarn("findByKeys: passed record does not have a value for key field '"
                         + keyField + "'");
            //<DEBUG
            return -1;
        }
        findKeys[keyField] = record[keyField];
    }

    if (!hasKeys) {
        //>DEBUG
        isc.Log.logWarn("findByKeys: dataSource '" + dataSource.ID + "' does not have primary " +
                     "keys declared, can't find record");
        //<DEBUG
        return -1;
    }

    // go through the recordSet looking for a record with the same values for the primary keys
    return this.findNextIndex(pos, findKeys, null, endPos);
},

//>    @method        array.containsProperty()
//  Determine whether this array contains any members where the property passed in matches the value
//  passed in.
//
//        @group    find
//        @param    property    (string)    property to look for
//                            (object)    key:value pairs to look for
//        @param    [value]        (any)        value to compare against (if property is a string)
//
//        @return    (boolean)   true if this array contains an object with the appropriate property value
// @visibility external
//<
containsProperty : function (property, value) {
    var index = this.findIndex(property, value);
    return (index != -1);
},

//>    @method array.findAll()
// @include list.findAll
//<
findAll : function (property, value, comparator) {

    if (property == null) return null;

    if (isc.isA.String(property)) {
        var matches = null,
            l = this.length;

        // single property to match
        var multiVal = isc.isAn.Array(value),
            hasComparator = (comparator != null);
        for (var i = 0; i < l; i++) {
            var item = this[i];
            if (item && (multiVal ?
                    value.contains(item[property], null, comparator) :
                    (hasComparator ?
                        comparator(item[property], value) :
                        item[property] == value)))
            {
                if (matches == null) matches = [];
                matches.add(item);
            }
        }
        return matches;


    } else if (isc.isA.Function(property)) {
        var matches = null,
            l = this.length,
            iterator = property,
            context = value;

        for (var i = 0; i < l; i++) {
            var item = this[i];
            if (iterator(item, context)) {
                if (matches == null) matches = [];
                matches.add(item);
            }
        }
        return matches;
    } else {
        // "property" is an object specifying a set of properties to match
        return this.findAllMatches(property, comparator);
    }
},

// internal: assumes multiple properties
findAllMatches : function (properties, comparators) {
    var l = this.getLength(),
        propertyNames = isc.getKeys(properties),
        matches = null,
        hasComparators = (comparators != null),
        singleComparator = (hasComparators && !isc.isAn.Object(comparators) && comparators);

    if (properties._constructor == "AdvancedCriteria") {
        if (isc.DataSource == null) {
            isc.warn("DataBinding module not loaded, AdvancedCriteria not supported for find()/findAll()");
            return -1;
        }
        var dataSource = this.dataSource || isc.DataSource;
        return dataSource.applyFilter(this.getRange(0, this.getLength() + 1), properties);
    }
    for (var i = 0; i < l; i++) {
        var item = this.get(i);
        if (!item) continue;
        var found = true;
        for (var j = 0; j < propertyNames.length; j++) {
            var propertyName = propertyNames[j],
                comparator = (hasComparators && (singleComparator || comparators[propertyName])),
                itemValue = item[propertyName],
                propertiesValue = properties[propertyName];
            if (comparator ?
                !comparator(itemValue, propertiesValue) :
                (itemValue != propertiesValue))
            {
                found = false;
                break;
            }
        }
        if (found) {
            if (matches == null) matches = [];
            matches.add(item);
        }
    }
    return matches;
},

//>    @method        array.slide()    (A)
// Slide element at position start to position destination, moving all the other elements to cover
// the gap.
//
//        @param    start        (number)    start position
//        @param    destination    (number)    destination position for the value at start
// @visibility external
//<
slide : function (start, destination) {
    this.slideRange(start, start+1, destination);
},

//>    @method        array.slideRange()    (A)
// Slide a range of elements from start to end to position destination, moving all the other
// elements to cover the gap.
//
//        @param    start        (number)    start position
//        @param    end         (number)    end position (exclusive, like substring() and slice())
//        @param    destination    (number)    destination position for the range
// @visibility external
//<
slideRange : function (rangeStart, rangeEnd, destination) {
    if (rangeStart == destination) return;
    // remove the range to be moved
    var removed = this.splice(rangeStart, rangeEnd - rangeStart);
    // and add it at the destination
    this.addListAt(removed, destination);
},

//>    @method        array.slideList()    (A)
// Slide the array of rows list to position destination.
//
//        @param    start        (number)    start position
//        @param    destination    (number)    destination position for this[start]
//<
slideList : function (list, destination) {
    var output = [],
        i
    ;

//XXX if destination is negative, set to 0 (same effect, cleaner code below)
if (destination < 0) destination = 0;

    // take all the things from this table before destination that aren't in the list to be moved
    for(i = 0;i < destination;i++)
        if (!list.contains(this[i]))
            output.add(this[i]);

    // now put in all the things to be moved
    for(i = 0;i < list.length;i++)
        output.add(list[i]);

    // now put in all the things after destination that aren't in the list to be moved
    for(i = destination;i < this.length;i++)
        if (!list.contains(this[i]))
            output.add(this[i]);

    // now copy the reordered list back into this array
    this.setArray(output);
},

//>    @method        array.makeIndex()    (A)
// Make an index for the items in this Array by a particular property of each item.
// <P>
// Returns an Object with keys for each distinct listItem[property] value.  Each key will point
// to an array of items that share that property value.  The sub-array will be in the same order
// that they are in this list.
//
//        @param    property        (strings)            names of the property to index by
//        @param    alwaysMakeArray    (boolean : false)
//              if true, we always make an array for every index.  if false, we make an Array only
//              when more than one item has the same value for the index property
//        @return    (object)                    index object
// @visibility external
//<
// NOTE: we don't document the awkard -1 param to allow collisions
makeIndex : function (property, alwaysMakeArray, useIndexAsKey) {
    var index = {};
    var allowCollisions = (alwaysMakeArray == -1);
    alwaysMakeArray = (alwaysMakeArray != null && alwaysMakeArray != 0);
    for (var i = 0; i < this.length; i++) {
        var item = this[i],
            key = item[property]
        ;

        // if the item has no value for the key property
        if (key == null) {
            // either skip it..
            if (!useIndexAsKey) continue;
            // or place it in the index under its position in the array
            key = i;
        }

        if (allowCollisions) {
            index[key] = item;
            continue;
        }

        var existingValue = index[key];
        if (existingValue == null) {
            if (alwaysMakeArray) {
                // every entry should be an array
                index[key] = [item];
            } else {
                index[key] = item;
            }
        } else {
            if (alwaysMakeArray) {
                // any non-null value is an array we created the first time we found an item
                // with this key value
                index[key].add(item);
            } else {
                // if the existing value is an array, add to it, otherwise put the new and old
                // value together in a new array
                if (isc.isAn.Array(existingValue)) {
                    index[key].add(item);
                } else {
                    index[key] = [existingValue, item];
                }
            }
        }
    }

    return index;
},


//>    @method        array.arraysToObjects()    (A)
// Map an array of arrays to an array of objects.
// <P>
// Each array becomes one object, which will have as many properties as the number of property
// names passed as the "propertyList".  The values of the properties will be the values found
// in the Array, in order.
// <P>
// For example:
// <pre>
//    var arrays = [
//       ["Mickey", "Mouse"],
//       ["Donald", "Duck"],
//       ["Yosemite", "Sam"]
//    ];
//    var objects = arrays.arraysToObjects(["firstName", "lastName"]);
// </pre>
// <code>objects</code> is now:
// <pre>
//    [
//       { firstName:"Mickey", lastName:"Mouse" },
//       { firstName:"Donald", lastName:"Duck" },
//       { firstName:"Yosemite", lastName:"Sam" }
//    ]
// </pre>
//
//        @param    propertyList    (Array of String)        names of the properties to assign to
//
//        @return    (Array of Object)        corresponding array of objects
//<
arraysToObjects : function (propertyList) {
    // get the number of properties we're dealing with
    var propLength = propertyList.length;
    // for each item in this array
    var output = new Array(this.length);
    for (var i = this.length; i--; ) {
        // make a new object to hold the output
        var entry = this[i],
            it = output[i] = {};
        // for each property in the propertyList list
        for (var p = propLength; p--; ) {
            var property = propertyList[p];
            // assign that item in the array to the proper name of the new object
            it[property] = entry[p];
        }
    }
    // return the list that was generated
    return output;
},

//>    @method        array.objectsToArrays()    (A)
// Map an array of objects into an array of arrays.
// <P>
// Each object becomes one array, which contains the values of a list of properties from
// the source object.
// <P>
// For example:
// <pre>
//    var objects = [
//       { firstName:"Mickey", lastName:"Mouse" },
//       { firstName:"Donald", lastName:"Duck" },
//       { firstName:"Yosemite", lastName:"Sam" }
//    ]
//    var arrays = objects.objectsToArrays(["firstName", "lastName"]);
// </pre>
// <code>arrays</code> is now:
// <pre>
// [
//    ["Mickey", "Mouse"],
//    ["Donald", "Duck"],
//    ["Yosemite", "Sam"]
// ]
// </pre>
//
//        @param    propertyList    (Array of String)        names of the properties to output
//
//        @return    (Array of Object)        corresponding array of arrays
//<
objectsToArrays : function (propertyList) {
    // get the number of properties we're dealing with
    var propLength = propertyList.length;
    // for each item in this array
    var output = new Array(this.length);
    for (var i = this.length; i--; ) {
        // make a new object to hold the output
        var entry = this[i],
            it = output[i] = [];
        // for each property in the propertyList list
        for (var p = propLength; p--; ) {
            var property = propertyList[p];
            // assign that item in the array to the proper name of the new object
            it[p] = entry[property];
        }
    }
    // return the list that was generated
    return output;
},

//>    @method        array.spliceArray()
//             Like array.splice() but takes an array (to concat) as a third parameter,
//          rather than a number of additional parameters.
//
//        @param    startPos    (number)        starting position for the splice
//      @param  deleteCount (number)        Number of elements to delete from affected array
//      @param  newArray    (any[])         Array of elements to splice into existing array
//
//        @return    (any[])        array of removed elements
//<
spliceArray : function (startPos, deleteCount, newArray) {
    var undef;
    if (startPos === undef) return this.splice();
    if (deleteCount === undef) return this.splice(startPos);
    if (newArray === undef) return this.splice(startPos, deleteCount);
    if (!isc.isAn.Array(newArray)) {
        isc.Log.logWarn("spliceArray() method passed a non-array third parameter. Ignoring...", "Array");
        return this.splice(startPos, deleteCount);
    }

    // use 'apply' - allows you to pass in the arguments as an array!
    // xxx -
    // Note 1: Another syntax for this would be of this form
    // if(newArray.length <= 10) return this.splice(startPos, deleteCount, newArray[0], ...)
    // else return this.splice.apply(...)
    // but seems no better performance-wise, and since (at least in our overridden implementation of
    // splice for IE 5.0) we use arguments.length, is unreliable unless we have a plethora of
    // if ... then/s to pass in exactly the right number of arguments.
    //
    // Note 2: you have to use concat, rather than splice to put startPos / deleteCount  at the
    // beginning of newArray, as newArray points to an array object that may be being reused
    // elsewhere, so we can't modify it.
    //
    return this.splice.apply(this, [startPos, deleteCount].concat(newArray))

},

// stack peek method - returns the top item on the stack without removing it.
peek : function () {
    var item = this.pop();
    this.push(item);
    return item;
},

// see ResultSet.getCachedRow()
getCachedRow : function (rowNum) {
    return this[rowNum];
},

// Shuffles the elements of this array using the FisherYates shuffle algorithm:
// https://en.wikipedia.org/wiki/FisherYates_shuffle

shuffle : function () {
    var n = this.length;
    while (n > 0) {
        var i = Math.floor(Math.random() * n);
        n--;
        var tmp = this[n];
        this[n] = this[i];
        this[i] = tmp;
    }
},

//
// ----------------------------------------------------------------------------------
// add the observation methods to the Array.prototype as well so we can use 'em there
//

observe: isc.Class.getPrototype().observe,
ignore : isc.Class.getPrototype().ignore,

// Synonyms and backcompat
// --------------------------------------------------------------------------------------------

    //>!BackCompat 2004.6.15 for old ISC names
    removeItem : function (pos) { return this.removeAt(pos) },
    getItem : function (pos) { return this.get(pos) },
    setItem : function (pos) { return this.set(pos) },
    // NOTE: instead of calling clearAll(), setLength(0) should be called (which is much more
    // efficient), however clearAll() still exists to support the old behavior of returning the
    // removed items.
    clearAll : function (list) { return this.removeList(this) },
    //<!BackCompat

    // Support for java.util.List API
    size : function () { return this.getLength() },
    subList : function (start, end) { return this.getRange(start, end) },
    addAll : function (list) { return this.addList(list); },
    removeAll : function (list) {
        var origLength = this.getLength();
        this.removeList(list);
        return this.getLength() != origLength; // return whether list was changed
    },
    clear : function () { this.setLength(0); },
    toArray : function () { return this.duplicate(); }
    // NOTE: incomplete compatibility:
    // - no iterators.  This exists in Java largely for concurrent modification reasons.
    // - remove(int): in Java, the collision between remove(int) and remove(object) is
    //   implemented by method overloading.  In JS, we assume if you pass a number you want
    //   removal by index, but this means remove(5) cannot be used to remove the first instance
    //   of the number 5 from our List.
    // - retainAll: not yet implemented.  Similar to intersect, except the Java version
    //   requires the List to change in place instead of returning the intersection, in order
    //   to preserve the target List's class.
    // - toArray(): in Java, this means go to a native, non-modifiable Array

});


if (!isc.Browser.isIE || isc.Browser.isIE8Strict) {
    Array.prototype.duplicate = Array.prototype.slice;
}


if (isc.Browser.isIE) {

     [].fastIndexOf();
     [].fastIndexOf();
}

if (Array.prototype.nativeIndexOf != null) {
    Array.prototype.indexOf = function (obj, pos, endPos, comparator) {
        var OBJ = Object(this),
            length = OBJ.length >>> 0;
        if (pos == null) pos = 0;
        else if (pos < 0) pos = Math.max(0, length + pos);
        if (endPos == null) endPos = length - 1;

        var i;
        if (comparator != null) {
            for (i = pos; i <= endPos; ++i) {
                if (comparator(OBJ[i], obj)) return i;
            }
        } else {
            if (isc.isAn.Instance(obj)) {
                i = Array.prototype.nativeIndexOf.call(OBJ, obj, pos);
                if (i > endPos) i = -1;
                return i;
            }

            for (i = pos; i <= endPos; ++i) {
                if (OBJ[i] == obj) return i;
            }
        }

        return -1;
    };
} else {
    // native indexOf() doesn't exist in IE <= 8
    Array.prototype.nativeIndexOf = Array.prototype.indexOf;
}


if (isc.Browser.isFirefox || isc.Browser.isSafari) {
    Array.prototype.fastIndexOf = Array.prototype.nativeIndexOf;
}

// Fixes to splice() in older browsers.




//>IE8
// filter() doesn't exist in IE <= 8
if (Array.prototype.filter == null) {

    isc.addMethods(Array.prototype, {

        filter : function (callback, thisObject) {
            var result = [],
                initialLength = this.length; // scan original elements only
            for (var i = 0; i < initialLength; i++) {
                // skip positions for which no elements have been defined
                if (i in this && callback.call(thisObject, this[i])) {
                    result.add(this[i]);
                }
            }
            return result;
        }
    });

}
//<IE8

// Array helpers
isc.Array = {
    // Rotates the range of the array `arr` from `i` to `j` (inclusive) in-place by `n` places
    // to the right (or by `-n` places to the left if `n` is negative).
    _rotate : function (arr, i, j, n) {

        if (arr.length < 2) {
            return;
        }

        var m = j - i + 1;
        if (m > 1) {
            n = (m + (n % m)) % m;
            var gcd = isc.Math._gcd(n, m),
                s = (m / gcd);

            for (var p = gcd; p--; ) {
                var kPrime = i + n,
                    k = i + p,
                    temp = arr[k];
                for (var q = s - 1; q--; ) {
                    var l = k - n;
                    if (k < kPrime) {
                        l += m;
                    }
                    arr[k] = arr[l];
                    k = l;
                }
                arr[k] = temp;
            }
        }
    },

    // Move { arr[i], ..., arr[i + n - 1] } to appear after arr[j].
    _moveAfter : function (arr, i, j, n) {

        if (i < j) {
            isc.Array._rotate(arr, i, j, -n);
        } else {
            isc.Array._rotate(arr, j + 1, i + n - 1, n);
        }
    },

    // _binarySearch() returns either the lowest index of a value in `values' that equals `value'
    // or indicates the lowest index in `values' at which `value' may be inserted without breaking
    // the sort order of `values', as induced by `compareFn'.
    //
    // This function assumes that `values' is already sorted by `compareFn'.
    //
    // Parameters:
    // - values (Array of any) an array of values in which to search.
    // - value (any) the value to search for.
    // - [compareFn] (Function) an optional comparator function used to compare values in
    //   `values' with `value'. `compareFn' is called with two arguments. The first is a value
    //   from `values' and the second is always `value'. `compareFn' defaults to
    //   isc.Array._defaultCompareFn if it is not specified.
    // - [strict] (boolean) Should this function search for identical values to `value'
    //   (via ===), or is a zero of `compareFn' sufficient for determining equality? The
    //   default value is false. Note that `compareFn' must return zero when passed identically
    //   equal values for this function to work correctly.
    //
    // Returns:
    // (integer) If `value' is in `values' then this function returns the index of `value' in
    // the array. Otherwise, the return value is `-(insertion index) - 1', where the insertion
    // index is the lowest index at which `value' could be inserted into `values' while maintaining
    // the sort order.
    _binarySearch : function (values, value, compareFn, strict) {

        if (!compareFn) {
            compareFn = isc.Array._defaultCompareFn;
        }

        var low = 0,
            len = values.length,
            high = len - 1;
        var i = 0,
            comparison;
        while (low <= high) {
            i = Math.floor((low + high) / 2);
            comparison = compareFn(values[i], value);
            if (comparison < 0) {
                low = i + 1;
            } else if (comparison > 0) {
                high = i - 1;
            } else {


                // `values[i]' equals `value' according to the compare function. However,
                // it may be that `i' is in the middle of a range of equal values. Keep
                // decrementing `i' until it is the lowest index of that range.
                // If `strict' is true then we are actually looking to return the index of an
                // identically equal value in the `values' array.

                if (strict) {
                    var j = i;

                    do {
                        if (values[j] === value) {
                            return j;
                        }
                        ++j;
                    } while (j < len && compareFn(values[j], value) == 0);
                }

                while (i > 0 && compareFn(values[i - 1], value) == 0) {
                    if (strict && values[i - 1] === value) {
                        return i - 1;
                    }
                    --i;
                }

                // `i' is the insertion index. If strict, return `-i - 1' because the value was
                // not strictly in the `values' array.
                if (strict) {

                    return -i - 1;

                } else {
                    return i;
                }
            }
        }

        // Return the lowest index such that `values' at that index is greater than `value'.
        // That is the index at which `value' could be inserted while maintaining sort order.
        // The actual return value is `-(insertion index) - 1', so that callers can know whether
        // the value was in the `values' array by checking the sign.
        var undef;
        if (comparison !== undef && comparison < 0) {
            // values[i] < value, so i + 1 is the correct insertion index.
            return -(i + 1) - 1;
        } else {


            // values[i] > value, so i is the correct insertion index.
            return -i - 1;
        }
    },

    // Default comparator function used by _binarySearch() if `compareFn' is not provided.
    //
    // Parameters:
    // - lhs (any)
    // - rhs (any)
    //
    // Returns:
    // (number) -1 if `lhs' is less than `rhs', 0 if `lhs' and `rhs' are equal, or 1 if `lhs'
    // is greater than `rhs'
    _defaultCompareFn : function (lhs, rhs) {
        if (lhs < rhs) {
            return -1;
        } else if (lhs > rhs) {
            return 1;
        } else {
            return 0;
        }
    }
};

isc.ClassFactory.defineClass("BitSet");

isc.BitSet.addProperties({

    addPropertiesOnCreate: false,
    init : function () {
        this._ranges = [];
        return this.Super("init", arguments);
    },

    _getRangesIndex : function (index) {
        var k = isc.Array._binarySearch(this._ranges, index);
        return (k < 0 ? -(2 + k) : k);
    },

    get : function (index) {
        return (this._getRangesIndex(index) % 2 == 0);
    },

    nextIndex : function (iterIndex) {

        var ranges = this._ranges;
        return (iterIndex + 1 < ranges.length ? ranges[iterIndex + 1] : -1);
    },

    all : function (value, start, end) {

        var i = this._getRangesIndex(start),
            j = this._getRangesIndex(end - 1);
        return (i == j && (value == (i % 2 == 0)));
    },

    none : function (value, start, end) {

        var i = this._getRangesIndex(start),
            j = this._getRangesIndex(end - 1);
        return (i == j && (value != (i % 2 == 0)));
    },

    firstIndexOf : function (value, start, end) {
        if (!(start < end)) {
            return -1;
        }
        var ranges = this._ranges,
            j = this._getRangesIndex(start);
        if (value == (j % 2 == 0)) {
            return start;
        } else if (j + 1 < ranges.length && ranges[j + 1] < end) {
            return ranges[j + 1];
        } else {
            return -1;
        }
    },

    lastIndexOf : function (value, start, end) {
        if (!(start < end)) {
            return -1;
        }
        var ranges = this._ranges,
            j = this._getRangesIndex(end - 1);
        if (value == (j % 2 == 0)) {
            return end - 1;
        } else if (0 <= j && start <= ranges[j] - 1) {
            return ranges[j] - 1;
        } else {
            return -1;
        }
    },

    // Same as setRange(index, index + 1, value), but returns whether the value at the given
    // index was changed.
    set : function (index, value) {

        var k = this._getRangesIndex(index),
            changed = (value != (k % 2 == 0));
        if (changed) {
            this._setRange(index, k, index + 1, k, value);
        }
        return changed;
    },

    setRange : function (start, end, value) {
        if (!(0 <= start && start < end)) {
            return;
        }

        this._setRange(
            start, this._getRangesIndex(start), end, this._getRangesIndex(end - 1), value);
    },

    // Implementation for set() and setRange():
    _setRange : function (start, i, end, j, value) {
        var ranges = this._ranges;


        // The terminology used here assumes that value is true.
        var startFalse = (value != (i % 2 == 0)),
            endFalse = (value != (j % 2 == 0)),
            mergeLeft = (startFalse && 0 <= i && start == ranges[i]),
            mergeRight = (
                endFalse &&
                j + 1 < ranges.length &&
                end == ranges[j + 1]),
            addStart = (!mergeLeft && startFalse),
            addEnd = (!mergeRight && endFalse),
            index = i + (mergeLeft ? 0 : 1),
            howMany = (j - i + (mergeLeft ? 1 : 0) + (mergeRight ? 1 : 0));
        if (addStart && addEnd) {
            ranges.splice(index, howMany, start, end);
        } else if (addStart) {
            ranges.splice(index, howMany, start);
        } else if (addEnd) {
            ranges.splice(index, howMany, end);
        } else {
            ranges.splice(index, howMany);
        }

    }
});
/*
    Isomorphic SmartClient web presentation layer
    Copyright 2000 and beyond Isomorphic Software, Inc.

    OWNERSHIP NOTICE
    Isomorphic Software owns and reserves all rights not expressly granted in this source code,
    including all intellectual property rights to the structure, sequence, and format of this code
    and to all designs, interfaces, algorithms, schema, protocols, and inventions expressed herein.

    CONFIDENTIALITY NOTICE
    The contents of this file are confidential and protected by non-disclosure agreement:
      * You may not expose this file to any person who is not bound by the same obligations.
      * You may not expose or send this file unencrypted on a public network.

    SUPPORTED INTERFACES
    Most interfaces expressed in this source code are internal and unsupported. Isomorphic supports
    only the documented behaviors of properties and methods that are marked "@visibility external"
    in this code. All other interfaces may be changed or removed without notice. The implementation
    of any supported interface may also be changed without notice.

    If you have any questions, please email <sourcecode@isomorphic.com>.

    This entire comment must accompany any portion of Isomorphic Software source code that is
    copied or moved from this file.
*/



//> @class NumberUtil
// Static singleton class containing APIs for interacting with Numbers.
// @treeLocation Client Reference/System
// @visibility external
//<
isc.defineClass("NumberUtil");

isc.NumberUtil.addClassProperties({
// decimal symbol used in Number.toString() - doesn't vary by locale (whereas toLocaleString() does)
_jsDecimalSymbol : ".",



//> @classAttr NumberUtil.decimalSymbol (String : "." : IR)
// The decimal symbol to use when formatting numbers
// <P><smartgwt>
// Note: the correct symbol is normally auto-derived from GWT's locale system, so the
// only valid reason to set it is desiring to use a language from one locale in combination
// with formatting rules from another locale, in a single application and for a single end user.
// </smartgwt>
// @group i18nMessages
// @visibility external
//<
decimalSymbol : ".",

//> @classAttr NumberUtil.groupingSymbol (String : "," : IR)
// The grouping symbol, or thousands separator, to use when formatting numbers
// <P><smartgwt>
// Note: the correct symbol is normally auto-derived from GWT's locale system, so the
// only valid reason to set it is desiring to use a language from one locale in combination
// with formatting rules from another locale, in a single application and for a single end user.
// </smartgwt>
// @group i18nMessages
// @visibility external
//<
groupingSymbol : ",",

//> @classAttr NumberUtil.negativeSymbol (String : "-" : IR)
// The negative symbol to use when formatting numbers
// <P><smartgwt>
// Note: the correct symbol is normally auto-derived from GWT's locale system, so the
// only valid reason to set it is desiring to use a language from one locale in combination
// with formatting rules from another locale, in a single application and for a single end user.
// </smartgwt>
// @group i18nMessages
// @visibility external
//<
negativeSymbol : "-",

//> @classAttr NumberUtil.currencySymbol (String : "$" : IR)
// The currency symbol to use when formatting numbers
// <P><smartgwt>
// Note: the correct symbol is normally auto-derived from GWT's locale system, so the
// only valid reason to set it is desiring to use a language from one locale in combination
// with formatting rules from another locale, in a single application and for a single end user.
// </smartgwt>
// @group i18nMessages
// @visibility external
//<
currencySymbol : "$",

//> @classAttr NumberUtil.negativeFormat (Number : 1 : IR)
// The format to use when formatting nagative numbers.  Supported values are: 1 = before,
// 2 = after, 3 = beforeSpace, 4 = afterSpace, 5 = parens
// <P><smartgwt>
// Note: the correct format is normally auto-derived from GWT's locale system, so the
// only valid reason to set it is desiring to use a language from one locale in combination
// with formatting rules from another locale, in a single application and for a single end user.
// </smartgwt>
// @group i18nMessages
// @visibility external
//<
negativeFormat : 1,

//> @classAttr NumberUtil.groupingFormat (Number : 1 : IR)
// The grouping-format for numbers
// <P><smartgwt>
// Note: the correct format is normally auto-derived from GWT's locale system, so the
// only valid reason to set it is desiring to use a language from one locale in combination
// with formatting rules from another locale, in a single application and for a single end user.
// </smartgwt>
// @group i18nMessages
// @visibility external
//<
groupingFormat : 1, // 0 = none; 1 = 123,456,789; 2 = 12,34,56,789


//> @classMethod NumberUtil.setStandardFormatter()
// Set the standard "toString()" formatter for Number objects.
// After this call, all <code>numberUtil.toString()</code>  calls will yield a number
// in this format.
//
// @param functionName (string) name of a formatting function on the number object prototype
// @group stringProcessing
//<
setStandardFormatter : function (functionName) {
    if (isc.isA.Function(isc.NumberUtil[functionName]))
        isc.NumberUtil.formatter = functionName;
},

//> @classMethod NumberUtil.setStandardLocaleStringFormatter()
// Set the standard locale formatter for all Number objects.
// After this call, all  <code>isc.iscToLocaleString(number)</code> for number instances
// calls will yield the string returned by the formatter specified.
//
// @param functionName (string) name of a formatting function (on number instances)
// @group stringProcessing
//<
setStandardLocaleStringFormatter : function (functionName) {
    if (isc.isA.Function(isc.NumberUtil[functionName]))
        isc.NumberUtil.localeStringFormatter = functionName;
},

_1zero : "0",
_2zero : "00",
_3zero : "000",
_4zero : "0000",

_getZeroString : function (length) {
    if (length <= 0) return;

    var nu = isc.NumberUtil,
        pad
    ;
    // with > 4 zeros (very rare), build up a leading pad 4 0's at a time
    while (length > 4) {
        if (pad == null) pad = nu._4zero;
        else pad += nu._4zero;
        length -= 4;
    }

    var finalPad;
    switch (length) {
        case 4: finalPad = nu._4zero; break;
        case 3: finalPad = nu._3zero; break;
        case 2: finalPad = nu._2zero; break;
        case 1: finalPad = nu._1zero; break;
    }

    // no leading pad (less than 4 zeros total)
    if (pad == null) return finalPad;
    return pad + finalPad;
},

// Remove any exponent from a the formatted number, adding zeros where
// necessary while preserving the precision represented in the string.
_expandExponent : function (formattedNumber) {

    return formattedNumber.replace(/^([+-])?(\d+).?(\d*)[eE]([-+]?\d+)$/,

        // Search for an exponential in the formatted number, matching four groups:
        //     sign, natural, fraction, coeffcient
        //
        //     sign        = sign of the number
        //     natural     = integer part of significand (a natural number since no sign)
        //     fraction    = fractional part of significand
        //     coefficient = coefficient of number, including sign

        function(matchedString, sign, natural, fraction, coefficient){

            // We define the following variables
            //     lessThanOne           - whether number's absolute value is less than one
            //     normalizedCoefficient - coefficient normalized for the number of digits in
            //                             natural, integer part of the significand (off by one);
            //                             this abstractly represents the total number of digits
            //                             (including any added zeros) to the left of the
            //                             decimal point in the final formatted number
            //     digitsToCross         - when moving the decimal point left or right from its
            //                             place in the significand to remove the exponential,
            //                             the number of digits from the signficand that will
            //                             be crossed (excluding zeros added by our own logic)

            var lessThanOne = +coefficient < 0,
                normalizedCoefficient = natural.length + (+coefficient),
                digitsToCross = (lessThanOne ? natural : fraction).length;

            // Now, build a string of zeros whose length is determined by the absolute value
            // of the coefficient, less the number of digits to cross; this is the number of
            // zeros needed to separate the number from the decimal point.

            coefficient = Math.abs(coefficient);

            var nZeros = coefficient >= digitsToCross ?
                         coefficient - digitsToCross + lessThanOne : 0,
                zeros = nZeros > 0 ? isc.NumberUtil._getZeroString(nZeros) : "";

            // Form the significand (joining both parts together), and attach zeros
            var significand = natural + fraction;
            if (lessThanOne) significand  = zeros + significand;
            else             significand += zeros;

            // If absolute value of number is less than one, offset the
            // normalized coefficient by the number of zeros.
            if (lessThanOne) normalizedCoefficient += zeros.length;

            // Output the digits to the left of the decimal point; we may be done
            var result = (sign || "") + significand.substr(0, normalizedCoefficient);

            // If not, add the remaining fractional digits to the right of the decimal
            if (normalizedCoefficient < significand.length) {
                result += "." + significand.substr(normalizedCoefficient);
            }
            return result;
        });
},

//> @classMethod NumberUtil.stringify()
// Return the passed number as a string padded out to digits length.
//
// @param number (number) Number object to stringify
// @param [digits] (number) Number of digits to pad to.  (Default is 2)
// @return (string) Padded string version of the number
//
// @example var str = isc.NumberUtil.stringify(myNumberVar, 2);
// @group stringProcessing
// @visibility external
//<

stringify : function (number, totalDigits, predecimal) {
    if (!isc.isA.Number(number)) return "";


    return isc.NumberUtil._stringify(totalDigits, predecimal, number);
},

_stringify : function (totalDigits, predecimal, number, radix) {
    if (number == null) number = this;
    // default to 2 digits
    if (!totalDigits) totalDigits = 2;

    var numberString = (radix != null ? number.toString(radix) : number.toString()),
        zeroes = totalDigits - numberString.length;

    // predecimal: ignore any decimal digits, such that two numbers with differing decimal
    // precision get the same total number of characters before the decimal.
    if (predecimal) {
        var dotIndex = numberString.indexOf(isc.dot);
        if (dotIndex != -1) {
            zeroes += (numberString.length - dotIndex);
        }
    }
    var pad = isc.NumberUtil._getZeroString(zeroes);

    if (pad == null) return numberString;
    return pad + numberString;
},

//> @classMethod NumberUtil.isBetween()
// Returns true if the number parameter falls between the 'first' and 'second' parameters.
//
// @param number (number) Number object to be evaluated
// @param [first] (number) Number at the lower boundary
// @param [second] (number) Number at the upper boundary
// @param [inclusive] (number) Whether or not the numbers at either end of the boundary should be included in the comparison
// @return (Boolean) True if the given <code>number</code> falls inside the given range, false otherwise
//
// @example n = 3; bool = n.isBetween(3, 3, 6, true); // true
// @group stringProcessing
// @visibility external
//<
isBetween : function (number, first, second, inclusive) {
    if (!isc.isA.Number(number)) return false;


    return isc.NumberUtil._isBetween(first, second, inclusive, number);
},

_isBetween : function (first, second, inclusive, number) {

    if (number == null) number = this;

    var min = Math.min(first, second),
        max = Math.max(first, second);

    if (inclusive) {
        return min <= number && number <= max;
    } else {
        return min < number && number < max;
    }
},

//> @classMethod NumberUtil.clamp()
// Returns a clamped number between a min and max.
// <p>
// <pre>
// var clamped = isc.NumberUtil.clamp(10, 0, 5); // Returns 5 because 10 is greater than 5
// var clamped = isc.NumberUtil.clamp(-3, 0, 5); // Returns 0 because -3 is less than 0
// var clamped = isc.NumberUtil.clamp(4, 0, 5); // Returns 4 because 4 is between 0 and 5
// </pre>
// @param number (Number) the number to clamp
// @param min (Number) the number to return if the number is lower than min
// @param max (Number) the number to return if the number is higher than max
// @return (Number) the clamped number
//
// @visibility external
//<
clamp : function (number, min, max) {
    return Math.min(Math.max(number, min), max);
},

//> @classMethod NumberUtil.toCurrencyString()
// Return the passed number as a currency-formatted string, or an empty string if not passed a
// number.
//
// @param number (Number) the number to convert
// @param [currencyChar] (string) Currency symbol, default taken from the locale and can be
//                                set to an empty string. If not passed and missing from the
//                                locale, defaults to <code>"$"</code>.
// @param [decimalChar] (string) Decimal separator symbol, default taken from the locale. If
//                                if not passed and missing from the locale, defaults to
//                                <code>"."</code>.
// @param [padDecimal] (boolean) Should decimal portion be padded out to two digits? True
//                               by default.
// @param [currencyCharLast] (boolean) Should the currency symbol be shown at the end of the
//                                      string?  If unspecified, it will prefix the number.
// @return (string) Currency-formatted string version of the number
// @group stringProcessing
// @visibility external
//<
toCurrencyString : function (number, currencyChar, decimalChar, padDecimal, currencyCharLast) {
    if (!isc.isA.Number(number)) return "";


    return isc.NumberUtil._toCurrencyString(currencyChar, decimalChar, padDecimal, currencyCharLast, number)
},

_toCurrencyString : function (currencyChar, decimalChar, padDecimal, currencyCharLast, number) {
    if (number == null) number = this;

    var negative = number < 0,
        wholeNumber = number < 0 ? Math.ceil(number) : Math.floor(number),
        decimalNumber = Math.abs(Math.round((number - wholeNumber)*100)),
        output = isc.StringBuffer.create();

    wholeNumber = Math.abs(wholeNumber);

    // default currency/decimal symbols and decimal padding on
    // allow empty string for no currency character
    currencyChar = currencyChar || isc.NumberUtil.currencySymbol || "$";
    decimalChar = decimalChar || isc.NumberUtil.decimalSymbol || ".";
    if (padDecimal == null) padDecimal = true;

    // output sign

    if (negative) output.append(isc.NumberUtil.negativeSymbol || "-");

    // output currency symbol first by default
    if (currencyCharLast != true) output.append(currencyChar);

    // output whole number
    output.append(wholeNumber.stringify(1));

    // output decimal symbol and decimal number
    // (unless padding is off and decimal portion is 0)
    if (padDecimal) {
        output.append(decimalChar);
        output.append(decimalNumber.stringify(2));
    } else if (decimalNumber != 0) {
        output.append(decimalChar);
        if (decimalNumber % 10 == 0) output.append(decimalNumber/10);
        else output.append(decimalNumber.stringify(2));
    }

    // output currency symbol last if specified
    if (currencyCharLast == true) output.append(currencyChar);

    return output.release(false);
},

//> @classMethod NumberUtil.toLocalizedString()
//  Format the passed number for readability, with:
//  <ul>
//      <li>separators between three-digit groups</li>
//      <li>optional fixed decimal precision (so decimal points align on right-aligned numbers)</li>
//      <li>localized decimal, grouping, and negative symbols</li>
//  </ul>
//  +link{NumberUtil.decimalSymbol, Decimal symbol},
//  +link{NumberUtil.groupingSymbol, grouping symbol}, and
//  +link{NumberUtil.negativeSymbol, negative symbol} will normally come from
//  SmartClient locale settings (which may come from either client OS or application locale
//  settings), but they are also supported as arguments for mixed-format applications
//  (eg normalize all currency to +link{NumberUtil.toUSCurrencyString, US format}, but use the
// current locale format for other numbers).
//
//  @param number (Number) the number object to convert
//  @param [decimalPrecision] (number) decimal-precision for the formatted value
//  @param [decimalSymbol] (string) the symbol that appears before the decimal part of the number
//  @param [groupingSymbol] (string) the symbol shown between groups of 3 non-decimal digits
//  @param [negativeSymbol] (string) the symbol that indicate a negative number
//  @return (string) formatted number or empty string if not passed a number.
//  @visibility external
//<

toLocalizedString : function (
        number, decimalPrecision, decimalSymbol, groupingSymbol, negativeSymbol, minInteger,
        maxFraction, minPrecision, maxPrecision)
{
    if (!isc.isA.Number(number)) return "";

    var negative = (number < 0),
        wholeString = null,
        decimalString = null;
    if (negative) {
        number = -number;
    }


    var bySignificantDigits = (minPrecision != null || maxPrecision != null),
        minFraction = 0;
    if (bySignificantDigits) {
        // `minPrecision` must be an integer between 1 and 21.
        minPrecision = Math.max(1, Math.min(21, minPrecision || 0));
        // `maxPrecision` must be an integer between `minPrecision` and 21.
        maxPrecision = Math.max(minPrecision, Math.min(21, maxPrecision || 0));
    } else {
        // `minInteger` must be an integer between 1 and 21.
        minInteger = Math.max(1, Math.min(21, minInteger || 0));
        // `minFraction` must be an integer between 0 and 20.
        minFraction = Math.max(0, Math.min(20, decimalPrecision || 0));
        // `maxFraction` must be an integer between `minFraction` and 20.
        maxFraction = Math.max(minFraction, Math.min(20, maxFraction || 0));
    }
    var zeroStr = isc.NumberUtil._getZeroString(1);
    if (bySignificantDigits) {
        var p = maxPrecision, e = 0, m;

        if (number == 0) {
            e = 0;
            m = isc.NumberUtil._getZeroString(p);
            if (e == p - 1) {
                wholeString = m;
            }
        } else {

            e = Math.floor(Math.log(number) / Math.LN10);
            var n = 0;
            if (e < p) {
                n = Math.round(number * Math.pow(10, -(e - p + 1)));
            } else {
                n = Math.round(number / Math.pow(10, e - p + 1));
            }
            if (n == Math.pow(10, p)) {
                ++e;
                n /= 10;
            }

            if (e >= p) {

                wholeString = (
                    isc.NumberUtil._toFixed(n) + isc.NumberUtil._getZeroString(e - p + 1));
            } else if (e == p - 1) {
                wholeString = isc.NumberUtil._toFixed(n);
            } else {
                m = isc.NumberUtil._toFixed(n);
            }
        }

        if (wholeString == null) {
            if (e >= 0) {
                wholeString = m.substr(0, e + 1);
                decimalString = m.substr(e + 1, p - (e + 1));
            } else {
                wholeString = zeroStr;
                decimalString = isc.NumberUtil._getZeroString(-(e + 1)) + m;
            }

            var cut0 = maxPrecision - minPrecision,
                cut = cut0;
            while (cut > 0) {
                if (decimalString.charAt(p - (e + 1) - 1 - (cut0 - cut)) == zeroStr) {
                    --cut;
                } else {
                    break;
                }
            }
            if (p - (e + 1) == cut0 - cut) {
                decimalString = null;
            } else {
                decimalString = decimalString.substr(0, p - (e + 1) - (cut0 - cut));
            }
        }
    } else {
        var f = maxFraction,
            n = Math.round(number * Math.pow(10, f)),
            m = (n == 0 ? zeroStr : isc.NumberUtil._toFixed(n)),
            l = 0;
        if (f > 0) {
            var k = m.length;
            if (k <= f) {
                m = isc.NumberUtil._getZeroString(f + 1 - k) + m;
                k = f + 1;
            }
            wholeString = m.substr(0, k - f);
            decimalString = m.substr(k - f, f);
            l = k - f;

            var cut0 = maxFraction - minFraction,
                cut = cut0;
            while (cut > 0) {
                if (decimalString.charAt(f - 1 - (cut0 - cut)) == zeroStr) {
                    --cut;
                } else {
                    break;
                }
            }
            if (f == cut0 - cut) {
                decimalString = null;
            } else {
                decimalString = decimalString.substr(0, f - (cut0 - cut));
            }
        } else {
            wholeString = m;
            l = m.length;
        }
        if (l < minInteger) {
            wholeString = isc.NumberUtil._getZeroString(minInteger - l) + wholeString;
        }
    }

    var wholeLength = wholeString.length,
        r = wholeLength % 3,
        // `tripletCount` is the number of complete chunks of 3 digits.
        tripletCount = (wholeLength - r) / 3,
        beforeTripletLength = (negative ? 1 : 0) + (r != 0 ? 1 : 0),
        numGroupSymbols = (r != 0 ? 1 : 0) + tripletCount - 1,
        templateLength = (
            beforeTripletLength +
            numGroupSymbols +
            tripletCount +
            (decimalString != null ? 2 : 0)),
        template = new Array(templateLength);

    var k = 0;
    if (negative) {
        template[k++] = (negativeSymbol || isc.NumberUtil.negativeSymbol);
    }

    // Whole part - slice it into chunks joined with grouping symbols.
    groupingSymbol = groupingSymbol || isc.NumberUtil.groupingSymbol;
    var notFirstGroup = false;
    if (r != 0) {
        // Start with the incomplete chunk (first 1 or 2 digits), if any, ...
        template[k++] = wholeString.substr(0, r);
        notFirstGroup = true;
    }
    for (var i = 0, j = r; i < tripletCount; ++i, j += 3, notFirstGroup = true) {
        if (notFirstGroup) {
            template[k++] = groupingSymbol;
        }
        // ... then slice out each chunk of 3 digits.
        template[k++] = wholeString.substr(j, 3);
    }

    // Append the decimal part.
    if (decimalString != null) {
        template[k++] = (decimalSymbol || isc.NumberUtil.decimalSymbol);
        template[k] = decimalString;
    }

    // Assembly - join the chunks of the whole part with grouping symbols, and glue together
    // the whole part, decimal symbol, decimal part, and negative sign as appropriate.
    return template.join("");
},

_toFixed : function (n) {

    var nStr = n.toFixed(),
        k = nStr.lastIndexOf("e");
    if (k == -1) {
        return nStr;
    } else {

        var lastPow = parseInt(nStr.substr(k + 1), 10),
            numDigits = 1 + lastPow,
            str = "",
            sum = 0;
        do {
            var digit = parseInt(nStr, 10),
                pow = parseInt(nStr.substr(k + 1), 10);
            if (lastPow > pow + 1) {
                str = str + isc.NumberUtil._getZeroString(lastPow - pow - 1) + digit;
            } else {
                str = str + digit;
            }
            sum += digit * Math.pow(10, pow);
            nStr = (n - sum).toFixed();
            k = nStr.lastIndexOf("e");
            lastPow = pow;
        } while (k != -1);

        var l = numDigits - str.length - nStr.length;
        if (l > 0) {
            return str + isc.NumberUtil._getZeroString(l) + nStr;
        } else {
            return str + nStr;
        }
    }
},

// Internal helper that converts a number `numBytes' (representing a byte count) to a localized
// string. When `otherNumBytes' is different, the formatted string is distinguished from
// `toMiBString(otherNumBytes, numBytes)' by inclusion of as many digits of precision as are
// necessary to differentiate the two byte counts, up to 20 digits of precision.
toMiBString : function (numBytes, otherNumBytes) {

    // If the two byte counts are more than 0.16 MiB apart, then one digit of precision is
    // sufficient.
    if (Math.abs(numBytes - otherNumBytes) > 167773) {
        return Math.round(numBytes / 104857.6) / 10;
    }

    var numMiB = numBytes / 1048576,
        mib;
    if (numBytes == otherNumBytes) {
        mib = isc.NumberUtil.toLocalizedString(numMiB, 20);
        var periodPos = mib.search(/[^\d]/);
        if (periodPos >= 0 && mib.length >= periodPos + 20) {
            for (var j = 1; j <= 20; ++j) {
                var c = mib.charCodeAt(periodPos + j);
                if (49 <= c && c <= 57) {
                    return isc.NumberUtil.toLocalizedString(numMiB, j);
                }
            }
        }
        return mib;

    } else {
        var otherNumMiB = otherNumBytes / 1048576,
            otherMiB;
        for (var j = 1; j <= 20; ++j) {
            mib = isc.NumberUtil.toLocalizedString(numMiB, j);
            otherMiB = isc.NumberUtil.toLocalizedString(otherNumMiB, j);

            // If, when `numMiB' and `otherNumMiB' are converted to strings (`mib' and `otherMiB',
            // respectively), they are different strings and `mib' is not a whole number with
            // decimal point and all trailing zeroes, then return `mib'.
            //
            // The trailing zeroes test is meant to prevent strings like:
            // "Size of 'uploaded-file' (0.01 MiB) exceeds maximum allowed file size of 0.00 MiB."
            // .. which makes it seem like the maximum file size is 0 MiB.
            if (mib !== otherMiB && !/[^\d]0+$/.test(mib)) return mib;
        }
        return mib;
    }
},

// same as toLocalizedString but handles extra zeroes using decimalPrecision and decimalPad values
floatValueToLocalizedString : function (number, decimalPrecision, decimalPad, stripGroupingSymbols) {
    if (!isc.isA.Number(number)) return "";
    if (!decimalPad) decimalPad = 0;
    // default decimalPrecision for float is 2
    if (decimalPrecision == null) decimalPrecision = 2;
    var res = isc.NumberUtil.toLocalizedString(number, decimalPrecision);
    // when editing a localized float, we don't want to include groupingSymbols in the string
    if (stripGroupingSymbols) res = res.replaceAll(isc.NumberUtil.groupingSymbol, "");
    var decIndx = res.indexOf(isc.NumberUtil.decimalSymbol);
    var zeroesToAdd = 0;
    if (decIndx < 0) {
        if (decimalPad == 0) return res;
        zeroesToAdd = decimalPad;
        // no decimalSymbol were found, so we adding one
        res += isc.NumberUtil.decimalSymbol;
    } else {
        zeroesToAdd = decimalPad - (res.length - decIndx - 1);
    }
    if (zeroesToAdd > 0) {
        // add zeroes to the end according decimalPad value
        res += new Array(zeroesToAdd + 1).join('0');
    } else if (zeroesToAdd < 0) {
        // all extra zeroes should be removed
        for (var i = (res.length - 1); i>(decIndx + decimalPad); i--) {
            if (res.charAt(i) != '0' && res.charAt(i) != isc.NumberUtil.decimalSymbol) break;
        }
        // remove decimalSymbol if is the last one
        if (res.charAt(i) == isc.NumberUtil.decimalSymbol) i--;
        res = res.substr(0, i + 1);
    }
    return res;
},

//> @classMethod NumberUtil.toUSString()
//  Format the passed number as a US string.  Returns empty string if not passed a number.
//
//  @param number (Number) the number object to format
//  @param [decimalPrecision] (number)
//  @return (string) formatted number or empty string if not passed a number
//  @visibility external
//<
toUSString : function (
    number, decimalPrecision, minInteger, maxFraction, minPrecision, maxPrecision)
{
    return isc.NumberUtil.toLocalizedString(
        number, decimalPrecision, ".", ",", "-",
        minInteger, maxFraction, minPrecision, maxPrecision);
},

//> @classMethod NumberUtil.toUSCurrencyString()
//  Format the passed number as a US Dollar currency string. Returns empty string if not passed
// a number.
//
//  @param number (Number) the number object to format
//  @param [decimalPrecision] (number)
//  @return (string) formatted number
//  @visibility external
//<
toUSCurrencyString : function(number, decimalPrecision) {
    if (!isc.isA.Number(number)) return "";
    var util = isc.NumberUtil;
    return "$" + util.toLocalizedString(number, decimalPrecision, ".", ",", "-");
},

_toUSPercentString : function (
    number, minInteger, minFraction, maxFraction, minPrecision, maxPrecision)
{
    if (!isc.isA.Number(number)) {
        return "";
    } else {
        return (isc.NumberUtil.toLocalizedString(
            100 * number, minFraction, ".", ",", "-",
            minInteger, maxFraction, minPrecision, maxPrecision) + "%");
    }
},

//> @method NumberUtil.iscToLocaleString()
// Customizeable version of the <code>toLocaleString()</code> method for numbers.
// Called by <code>isc.iscToLocaleString()</code>.
// Uses the formatter set by NumberUtil.setStandardLocaleStringFormatter(), or at the instance
// level by NumberUtil.setLocaleStringFormatter()
//
// @param number (Number) the number to format
// @return (string) formatted number as a string
//
// @group stringProcessing
//<
iscToLocaleString : function (number) {
    var f = isc.NumberUtil.localeStringFormatter;
    //var method = Number[f] || isc.NumberUtil[f];
    var method = isc.isA.Function(f) ? f : isc.NumberUtil[f];
    return method ? method(number) : number.toString();
},

//> @method NumberUtil.toFormattedString()
// Allow use of a custom number formatter - can be passed in as a parameter, or set by
// NumberUtil.setStandardFormatter()
//
// @param number (Number) the number to format
// @param [formatter] (string) name of a Number function to use
// @return (string) formatted number as a string
//
// @group stringProcessing
//<

toFormattedString : function (number, formatter) {
    var f = formatter || isc.NumberUtil.formatter;
    var method = isc.isA.Function(f) ? f : isc.NumberUtil[f];
    return method ? method(number) : number.toString();
},

//> @classMethod NumberUtil.parseInt()
// Parse string that contains integer number. This method correctly handles locale based
// separators and currency symbol.
//
// @param string (string) the string to parse
// @return (Number) parsed number as a Number
// @visibility external
//
//<

parseInt : function (string) {
    if (isc.isA.String(string)) {
        string = string.replace(new RegExp("[" + this.groupingSymbol + "|"  +
                                           this.currencySymbol + "]", "g"),"");
    }
    return parseInt(string);
},

//> @classMethod NumberUtil.parseFloat()
// Parse string that contains float number. This method correctly handles locale based
// separators, decimal points and currency symbol.
//
// @param string (string) the string to parse
// @return (float) parsed number as a Number
// @visibility external
//<
parseFloat : function (string) {
    if (isc.isA.String(string)) {
        string = string.replace(new RegExp("[" + this.groupingSymbol + "|"  +
                                           this.currencySymbol + "]", "g"), "");
        if (this.decimalSymbol != ".") {
            string = string.replace(new RegExp("[" + this.decimalSymbol + "]", "g"), ".");
        }
    }
    return parseFloat(string);
},

parseLocaleFloat : function (string, decimalSymbol, groupingSymbol) {
    if (string == null) return Number.NaN;
    if (!decimalSymbol) decimalSymbol = isc.NumberUtil.decimalSymbol;
    if (!groupingSymbol) groupingSymbol = isc.NumberUtil.groupingSymbol;
    var numberString = "";
    var lastGroupingSymbolIndex = -1;
    var decimalSymbolFound = false;
    var isPositiveNumber = true;
    // user could use grouping symbol in number or not, if he used we should check that every
    // three symbols are followed by one grouping symbol
    var groupingSymbolUsed = string.contains(groupingSymbol);
    for (var i = 0; i < string.length; i++) {
        if (i == 0) {
            if (string.charAt(i) == "-") {
                isPositiveNumber = false;
                continue;
            } else if (string.charAt(i) == "+") {
                continue;
            }
        }
        // no grouping symbols should be found after decimal symbol found
        var mustBeGroupingSymbol = !decimalSymbolFound && groupingSymbolUsed;
        if (mustBeGroupingSymbol) {
            if (lastGroupingSymbolIndex != -1) {
                // grouping symbol should be after every three letters in the line
                mustBeGroupingSymbol = (i - lastGroupingSymbolIndex) == 4;
            } else {
                // first should be on third position or less
                mustBeGroupingSymbol = (i == 3) || (string.charAt(i) == groupingSymbol);
            }
        }
        if (string.charAt(i) == groupingSymbol) {
            if (!mustBeGroupingSymbol) {
                return Number.NaN;
            }
            lastGroupingSymbolIndex = i;
            continue;
        } else if (mustBeGroupingSymbol && string.charAt(i) != decimalSymbol) {
            return Number.NaN;
        } else if (string.charAt(i) == decimalSymbol) {
            if (decimalSymbolFound) return Number.NaN;
            if (groupingSymbolUsed && (i - lastGroupingSymbolIndex) != 4) return Number.NaN;
            decimalSymbolFound = true;
            numberString += ".";
            continue;
        }
        // Number should not contain any other non-digit symbols
        if (string.charAt(i) < "0" || string.charAt(i) > "9") return Number.NaN;
        numberString += string[i];
    }
    if (!decimalSymbolFound && groupingSymbolUsed && ((i - lastGroupingSymbolIndex) != 4)) {
        return Number.NaN;
    }
    return isPositiveNumber? parseFloat(numberString) : -parseFloat(numberString);
},

parseLocaleInt : function (string, groupingSymbol) {
    if (string == null) return Number.NaN;
    if (!groupingSymbol) groupingSymbol = isc.NumberUtil.groupingSymbol;
    var numberString = "";
    var lastGroupingSymbolIndex = -1;
    var isPositiveNumber = true;
    var groupingSymbolUsed = string.contains(groupingSymbol);
    for (var i = 0; i < string.length; i++) {
        if (i == 0) {
            if (string.charAt(i) == "-") {
                isPositiveNumber = false;
                continue;
            } else if (string.charAt(i) == "+") {
                continue;
            }
        }
        // no grouping symbols should be found after decimal symbol found
        var mustBeGroupingSymbol = groupingSymbolUsed;
        if (mustBeGroupingSymbol) {
            if (lastGroupingSymbolIndex != -1) {
                // grouping symbol should be after every three letters in the line
                mustBeGroupingSymbol = (i - lastGroupingSymbolIndex) == 4;
            } else {
                // first should be on third position or less
                mustBeGroupingSymbol = (i == 3) || (string.charAt(i) == groupingSymbol);
            }
        }
        if (string.charAt(i) == groupingSymbol) {
            if (!mustBeGroupingSymbol) {
                return Number.NaN;
            }
            lastGroupingSymbolIndex = i;
            continue;
        } else if (mustBeGroupingSymbol) {
            return Number.NaN;
        }
        // Number should not contain any other non-digit symbols
        if (string.charAt(i) < "0" || string.charAt(i) > "9") return Number.NaN;
        numberString += string[i];
    }
    if (groupingSymbolUsed && ((i - lastGroupingSymbolIndex) != 4)) {
        return Number.NaN;
    }

    return isPositiveNumber? parseInt(numberString) : -parseInt(numberString);
},

parseLocaleCurrency : function (string, currencySymbol, decimalSymbol, groupingSymbol) {
    if (string == null) return Number.NaN;
    if (!currencySymbol) currencySymbol = isc.NumberUtil.currencySymbol;
    // correct input could be CHF1.227,33 and 1.227,33CHF (symbol could contain several letters)
    if (string.startsWith(currencySymbol)) {
        string = string.substring(currencySymbol.length);
    } else if (string.endsWith(currencySymbol)) {
        string = string.substring(0, string.length - currencySymbol.length);
    }
    return this.parseLocaleFloat(string);
},

//> @classMethod NumberUtil.parseIfNumeric()
//
// If given a numeric string (that is, a non-empty string which converts to a
// number), will return the equivalent integer. Otherwise, returns the
// parameter unchanged. Useful for dealing with values that can be numbers or
// strings, but which you want to coerce to a numeric type if possible.
//
// @param numberOrString (any) the string or number to parse
// @return (any) an integer, if possible, otherwise the input unchanged
// @visibility external
//<
// Used for dealing with heights and widths. They can be numbers or strings
// (e.g. "50%" or "*"), and thus are deserialized as strings. But we
// sometimes want to know whether it's "really" a string, or instead a
// "numeric string" like "100".
parseIfNumeric : function (numberOrString) {
    if (isc.isA.Number(numberOrString)) {
        return numberOrString;
    } else if (isc.isA.nonemptyString(numberOrString)) {
        // Note that we want to return strings with trailing characters (like
        // "100%") unchanged, even though parseInt would produce an integer
        // from them. To check for that, isNaN is probably faster than a
        // regexp.
        if (isNaN(numberOrString)) {
            return numberOrString;
        } else {
            return parseInt(numberOrString, 10);
        }
    } else {
        // If it's neither Number nor String, or an empty String, just return
        // it. An empty string could be parsed to 0, but that's not necessarily
        // what was meant.
        return numberOrString;
    }
},

//>    @classMethod    NumberUtil.format()
// Return the parameter number formatted according to the parameter +link{type:FormatString}.
// This method is used to implement the +link{DataSourceField.format} functionality, but it can
// also be used to format arbitrary numbers programmatically.
// @param  number  (Number) The number to format
// @param  format  (FormatString) The format to apply
// @return (String) formatted number string
// @visibility external
//<
format : function(number, pformat) {

    if (!isc.isA.Number(number)) {
        this.logWarn("Cannot format '" + number + "' - not a Number");
        return number;
    }

    if (!isc.isA.String(pformat)) {
        this.logWarn("Cannot use format '" + pformat + "' - not a String");
        return number;
    }

    if (pformat == "") {
        return number.toString();
    }

    var format = pformat + "",
        n = number + 0,
        neg = n < 0,
        abs = Math.abs(number),
        negFormat,
        parts = abs.toString().split('.'),
        intPart = parts[0],
        decPart = parts[1];

    if (neg) {
        if (format.indexOf(";") != -1) {
            format = negFormat = format.substring(format.indexOf(";")+1);
        } else {
            format = format.indexOf(";") == -1 ? format : format.substring(0, format.indexOf(";"));
        }
    } else {
        format = format.indexOf(";") == -1 ? format : format.substring(0, format.indexOf(";"));
    }

    var quote = format.indexOf("'"),
        literals = [],
        positions = [];
    while (quote != -1) {
        var start = quote,
            end = format.indexOf("'", start+1);
        if (end == -1) {
            var error = "Invalid format string \"" + pformat + "\" - contains " +
                            "mismatched quotes"
            this.logWarn(error);
            return error;
        }
        var literal = format.substring(start+1, end);
        if (literal === "") literal = "'";
        literals.push(literal);
        positions.push(start);
        format = format.substring(0, start) + format.substring(end+1);
        quote = format.indexOf("'");
    }

    var grouping = format.indexOf(",");
    if (grouping > -1) {
        format = format.replace(/,/g, '');
    }

    var zeroesStart = format.indexOf("0"),
        poundsStart = format.indexOf("#"),
        decimalPos = format.indexOf("."),
        numberStarts = Math.min(zeroesStart == -1 ? 999 : zeroesStart,
                                poundsStart == -1 ? 999 : poundsStart,
                                decimalPos == -1 ? 999 : decimalPos),
        numberEnds = format.length-1,
        percent = false,
        permil = false,
        zeroes = 0;

    for (var i = format.length-1; i > numberStarts; i--) {
        var ch = format.charAt(i);
        if (ch == '0' || ch == '#' || ch == '.') break;
        if (ch == '%') percent = true;
        if (ch == '\u2030') permil = true;
        numberEnds--;
    }

    if (numberStarts == 999 || numberEnds < 0 || numberStarts > numberEnds) {
        // This matches the (somewhat arbitrary-seeming) Java DecimalFormat behavior
        parts = Math.abs(n).toString().split('.');
        intPart = parts[0];
        decPart = "";
        var prefix = format;
        if (positions) {
            for (var i = positions.length-1; i >= 0; i--) {
                prefix = prefix.substring(0, positions[i]) + literals[i] + prefix.substring(positions[i]);
            }
        }
        if (neg && !negFormat) prefix = "-" + prefix;
        var suffix = "",
            dPoint = "";
    } else {

        if (zeroesStart != -1 && poundsStart != -1 && decimalPos != -1) {
            if (zeroesStart < poundsStart && poundsStart < decimalPos) {
                var error = "Invalid format string \"" + pformat + "\" - cannot specify '0' to the " +
                                "left of '#' in the integer part"
                this.logWarn(error);
                return error;
            }
        }

        var curr = format.indexOf("\u00a4");
        while (curr != -1) {
            format = format.substring(0, curr) + isc.NumberUtil.currencySymbol + format.substring(curr+1);
            curr = format.indexOf("\u00a4");
        }

        var prefix = format.substring(0, numberStarts);
        var suffix = format.substring(numberEnds+1);
        for (var i = positions.length-1; i >= 0; i--) {
            if (positions[i] > numberStarts && positions[i] < numberEnds) {
                this.logWarn("Format string \"" + pformat + "\" contains quoted characters within " +
                                "the actual number area - these will be ignored");
            } else if (positions[i] <= numberStarts) {
                prefix = prefix.substring(0, positions[i]) + literals[i] + prefix.substring(positions[i]);
            } else {
                positions[i] -= (numberEnds+1);
                suffix = suffix.substring(0, positions[i]) + literals[i] + suffix.substring(positions[i]);
            }
        }

        if (zeroesStart != -1 && (decimalPos == -1 || zeroesStart < decimalPos)) {
            zeroes = (decimalPos == -1 ? numberEnds+1 : decimalPos) - zeroesStart;
        }

        if (percent) n = n * 100;
        else if (permil) n = n * 1000;

        var precision = "";
        if (decimalPos != -1) precision = format.substring(decimalPos+1, numberEnds+1);

        n = this._roundDecimalForFormatting(n, precision.length, decPart ? decPart.length : 0);
        parts = Math.abs(n).toString().split('.');
        intPart = parts[0];
        decPart = parts[1] || "";
        if (decPart.length < precision.length) {
            var c = decPart.length;
            while (precision[c] === "0" && c++ < precision.length) decPart += "0";
        }

        if (intPart == "0") {
            intPart = "0000000000000000000000000000000000000000".substring(0, zeroes);
        } else if (zeroes > intPart.length) {
            intPart = "0000000000000000000000000000000000000000".substring(intPart.length, zeroes) + intPart;
        }

        if (grouping > -1) {
            intPart = intPart.replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + isc.NumberUtil.groupingSymbol);
        }

        if (neg && !negFormat) {
            // No explicit format provided for negative numbers, so just prepend a minus sign to
            // the positive-formatted number
            prefix = prefix ? "-" + prefix : "-";
        }

        var dPoint = decPart && decPart.length > 0 ? isc.NumberUtil.decimalSymbol : "";
    }

    return prefix + intPart + dPoint + decPart + suffix;
},

useAccurateRounding: false,

_roundDecimalForFormatting : function(number, targetPrecision, numberPrecision) {
    // NOTE: native toFixed() rounds unpredictably on exact 0.5, 0.05, etc, boundaries, because
    // of inaccuracies introduced by the floating-point format.  So we don't use it...
    if (numberPrecision <= targetPrecision) return number;

    // Use the absolute value of negative numbers, to force it to round away from zero like
    // both DecimalFormat and Excel do
    var neg = number < 0;
    if (neg) number = 0 - number;


    var ori = number;
    var m = Math.pow(10, targetPrecision);
    number = number * m;
    if (isc.NumberUtil.useAccurateRounding) {
        var e = Math.pow(10, numberPrecision * -1);
        number += e;
    }
    number = Math.round(number)
    number = number / m;



    return neg ? 0 - number : number;
}

});

// NOTE: toString functions CANNOT be added by addMethods, because a property named "toString"
// will not be enumerated by for..in.  This is actually part of the ECMAScript standard!

isc.NumberUtil.toString = function (number) {
    if (number == null) return "";
    if (isc.isA.Class(number)) return number.valueOf().toString();
    return number.toString();
};

// set the standard formatter for the date prototype to the native browser string
// so 'toFormattedString()' defaults to returning the standard number format string
if (!isc.NumberUtil.formatter) isc.NumberUtil.formatter = "toString";


if (!isc.NumberUtil.localeStringFormatter)
    isc.NumberUtil.localeStringFormatter = "toString";

/*
    Isomorphic SmartClient web presentation layer
    Copyright 2000 and beyond Isomorphic Software, Inc.

    OWNERSHIP NOTICE
    Isomorphic Software owns and reserves all rights not expressly granted in this source code,
    including all intellectual property rights to the structure, sequence, and format of this code
    and to all designs, interfaces, algorithms, schema, protocols, and inventions expressed herein.

    CONFIDENTIALITY NOTICE
    The contents of this file are confidential and protected by non-disclosure agreement:
      * You may not expose this file to any person who is not bound by the same obligations.
      * You may not expose or send this file unencrypted on a public network.

    SUPPORTED INTERFACES
    Most interfaces expressed in this source code are internal and unsupported. Isomorphic supports
    only the documented behaviors of properties and methods that are marked "@visibility external"
    in this code. All other interfaces may be changed or removed without notice. The implementation
    of any supported interface may also be changed without notice.

    If you have any questions, please email <sourcecode@isomorphic.com>.

    This entire comment must accompany any portion of Isomorphic Software source code that is
    copied or moved from this file.
*/



  //>DEBUG
// This lets us label methods with a name within addMethods
Number.prototype.Class = "Number";
  //<DEBUG


//> @object Number
//
// Extra methods added to the Number object, available on all number variables.
//
//  @visibility external
//  @treeLocation Client Reference/System
//<

isc.addMethods(Number, {
setStandardFormatter : function (functionName) {
    isc.NumberUtil.setStandardFormatter(functionName);
},
setStandardLocaleStringFormatter : function (functionName) {
    isc.NumberUtil.setStandardLocaleStringFormatter(functionName);
}
});

//
// add methods to all Numbers
//
isc.addMethods(Number.prototype, {
//> @method number.stringify()
//
// Return this number as a string padded out to digits length.
//
// @param [digits] (number : 2) Number of digits to pad to.  (Default is 2)
// @return (string) Padded string version of the number
//
// @example var str = myNumberVar.stringify(2);
// @group stringProcessing
// @visibility external
// @deprecated Moved to a static method on NumberUtil to avoid the possibility of collision
//              with other libraries on the native Number object
//<

stringify : isc.NumberUtil._stringify,

//> @method number.isBetween()
// Returns true if the number parameter falls between the 'first' and 'second' paramters.
//
// @param number (number) Number object to be evaluated
// @param [first] (number) Number at the lower boundary
// @param [second] (number) Number at the upper boundary
// @param [inclusive] (number) Whether or not the numbers at either end of the boundary should be included in the comparison
// @return (Boolean) True if the given <code>number</code> falls inside the given range, false otherwise
// @example n = 3; bool = n.isBetween(3, 3, 6, true); // true
// @example n = 3; bool = n.isBetween(3, 3, 6);       // false
// @visibility external
//<
isBetween : isc.NumberUtil._isBetween,

//> @method number.toCurrencyString()
// Return this number as a currency-formatted string.
//
// @param [currencyChar] (string) Currency symbol, can be set to an empty string.
//                                If unset <code>"$"</code> will be used.
// @param [decimalChar] (string) Decimal separator symbol. If unset <code>"."</code> will be used.
// @param [padDecimal] (boolean) Should decimal portion be padded out to two digits? True
//                               by default.
// @param [currencyCharLast] (boolean) Should currency symbol come at the end of the string?
//                                      If unspecified, currency symbol will be shown at the
//                                      beginning of the string.
// @return (string) Currency-formatted string version of the number
// @group stringProcessing
// @visibility external
// @deprecated Moved to a static method on NumberUtil to avoid the possibility of collision
//              with other libraries on the native Number object
//<

toCurrencyString : isc.NumberUtil._toCurrencyString

// NOTE:
// We don't provide 'setFormatter' or 'setStandardFormatter' instance methods for Numbers.
// This is because
// a) we don't want to confuse the issue of where formatters are stored (we have a pattern here
//    and on Dates of having standard formatters for all instances only)
// b) (at least in IE), numbers are not allocated as "true instances", so having a
//     number instance (var theVar = 2;) does not mean that you can set up properties on it,
//     such as theVar.formatter -- when you next refer to 'theVar', you are really given
//     another '2' instance, so your properties have been wiped out.

});

//
// add class-methods to the Number object
//  Moved to NumberUtil.js

isc.addProperties(Number.prototype, {

// doc and implementation moved to NumberUtil
iscToLocaleString : function () {
    var result = isc.NumberUtil.iscToLocaleString(this);
    return result;
},

// doc and implementation moved to NumberUtil
toFormattedString : function (formatter) {
    var result = isc.NumberUtil.toFormattedString(this, formatter)
    return result;
},

// doc and implementation moved to NumberUtil
toLocalizedString : function (decimalPrecision, decimalSymbol, groupingSymbol, negativeSymbol) {
    var result = isc.NumberUtil.toLocalizedString(this, decimalPrecision, decimalSymbol,
                groupingSymbol, negativeSymbol);
    return result;
},


toUSString : function(decimalPrecision) {
    var result = isc.NumberUtil.toUSString(this, decimalPrecision);
    return result;
},
toUSDollarString : function (decimalPrecision) {
    return isc.NumberUtil.toUSCurrencyString(this, decimalPrecision);
},
toUSCurrencyString : function(decimalPrecision) {
    var result = isc.NumberUtil.toUSCurrencyString(this, decimalPrecision);
    return result;
}

}); // end addProperties(Number.prototype) for localizable number formatter



isc.defineClass("Format");

isc.Format.addClassMethods({
    toUSString : function (theNum, decimalPrecision) {
        if (!isc.isA.Number(theNum)) return theNum;
        return isc.NumberUtil.toUSString(theNum, decimalPrecision)
    },
    toUSCurrencyString : function (theNum, decimalPrecision) {
        if (!isc.isA.Number(theNum)) return theNum;
        return isc.NumberUtil.toUSCurrencyString(theNum, decimalPrecision)
    },
    toUSDollarString : function (theNum, decimalPrecision) {
        if (!isc.isA.Number(theNum)) return theNum;
        return isc.NumberUtil.toUSCurrencyString(theNum, decimalPrecision)
    },
    toCurrencyString : function (theNum, currencyChar, decimalChar,
                                 padDecimal, currencyCharLast) {
        if (!isc.isA.Number(theNum)) return theNum;
        return isc.NumberUtil._toCurrencyString(currencyChar, decimalChar,
                                       padDecimal, currencyCharLast, theNum);
    }
});

// Instance of this class can hold numeric value of any size and precision.
isc.defineClass("BigDecimal");

isc.BigDecimal.addProperties({
    // RegExp to parse number. exec() result array values:
    // 0 - parsed value
    // 1 - sign
    // 2 - whole number (if entered witout fraction)
    // 3 - whole number (if entered with fraction)
    // 4 - fraction part (if entered with fraction)
    // 5 - exponent sing
    // 6 - exponent value
    // 7 - Infinity
    r : /^(?:(?:NaN|([+|-]?)(?:(?:(\d+)\.*|(\d*)\.(\d+))(?:[E|e]([+|-]?)(\d+))?|(Infinity))))$/,
    // Holds true if value is NaN
    // new BigDecimal starts as NaN
    nanValue: true,
    // Holds true if value is positive or negative Infinity
    infinityValue: false,
    // 1: "+"
    //-1: "-"
    sign: 1,
    // Holds significant digits of number:
    // for value 12.345: num="12345";
    // for value 607000: num="607";
    // for value 0.00809: num="809";
    num: "",
    // Holds exponent
    // realValue=num*10^exp
    exp: 0
});

isc.BigDecimal.addMethods({
    // Returns true if instance holds value which does not represent valid number.
    isNaN : function() {
        return this.nanValue;
    },
    // Returns true if instance holds Infinity (positive or negative).
    isInfinity : function() {
        return !this.nanValue && this.infinityValue;
    },
    // Returns 1 if holds positive value or -1 if holds negative value.
    getSign : function() {
        return (this.nanValue)?1:this.sign;
    },
    // Returns significant digits of number.
    getNum : function() {
        return (this.nanValue)?"0":this.num;
    },
    // Returns exponent
    getExp : function() {
        return (this.nanValue)?0:this.exp;
    },
    // Normalizes state of number: trims leading/trailing zeroes and adjusts exponent accordingly:
    // 00012300e2 becomes 123e4
    // Value is not changed - method changes only internal representation of the seam value.
    normalize : function() {
        if (this.nanValue) {
            // Reset all internals for NaN
            this.infinityValue = false;
            this.sign = 1;
            this.num = "";
            this.exp = 0;
        } else {
            if (this.infinityValue) {
                // Infinity does not have number representation - reset it
                this.num = "";
                this.exp = 0;
            } else {
                // Trim leading zeroes
                this.num = this.num.replace(/^0*/, "");
                // Trim trailing zeroes
                var trail = /0*$/.exec(this.num);
                if (trail) {
                    this.num = this.num.replace(/0*$/, "");
                    // Adjust exponent
                    this.exp += trail[0].length;
                }
                if (this.num === "") {
                    this.num = "0";
                    this.exp = 0;
                }
            }
        }
        return this;
    },
    // Returns value as a string.
    // If exponent parameter is true - return value in exponent representation
    getStringValue : function(exponent) {
        if (this.nanValue) {
            return "NaN";
        }
        if (this.infinityValue) {
            return (this.sign === 1?"":"-") + "Infinity";
        }
        if (exponent) {
            if (this.num.length === 1) {
                return (this.sign === 1?"":"-") + this.num + "e" + this.exp;
            }
            var res = this.num.substr(0, 1) + "." + this.num.substr(1);
            return (this.sign === 1?"":"-") + res + "e" + (this.exp + (this.num.length - 1));
        } else {
            var res = this.num;
            if (this.exp >= 0) {
                res += "0".repeat(this.exp);
            } else {
                if (res.length < Math.abs(this.exp) + 1) {
                    res = "0".repeat(Math.abs(this.exp) - res.length + 1) + res;
                }
                res = res.substr(0, res.length + this.exp) + "." + res.substr(res.length + this.exp);
            }
            return (this.sign === 1?"":"-") + res;
        }
    },
    // Returns value as Number
    // Loss of precision can occur.
    getNumberValue : function() {
        if (this.nanValue) {
            return NaN;
        } else if (this.infinityValue) {
            return Infinity * this.sign;
        } else {
            return new Number(this.getStringValue());
        }
    },
    // If THIS number is greater than parameter - return 1;
    // If THIS number equals to parameter - return 0;
    // If THIS number is less than parameter - return -1;
    // Special cases:
    //      if parameter can not be converted to number it is treated as zero;
    //      NaN treated as zero
    compareTo : function(number) {
        if (!(isc.isA.BigDecimal(number))) {
            number = isc.BigDecimal.create(number);
        }
        var thisNanValue = this.isNaN();
        var thisInfinityValue = this.isInfinity();
        var thisSign = this.getSign();
        var thisNum = this.getNum();
        var thisExp = this.getExp();
        var otherNanValue = number.isNaN();
        var otherInfinityValue = number.isInfinity();
        var otherSign = number.getSign();
        var otherNum = number.getNum();
        var otherExp = number.getExp();
        if (thisInfinityValue) {
            if (otherInfinityValue) {
                if (thisSign > otherSign) {
                    return 1;
                } else if (thisSign === otherSign) {
                    return 0;
                } else {
                    return -1;
                }
            } else {
                if (thisSign > 0) {
                    return 1;
                } else {
                    return -1;
                }
            }
        }
        if (otherInfinityValue) {
            if (otherSign < 0) {
                return 1;
            } else {
                return -1;
            }
        }
        if (thisExp > otherExp) {
            thisNum += "0".repeat(thisExp - otherExp);
        } else {
            otherNum += "0".repeat(otherExp - thisExp);
        }
        if (thisNum.length > otherNum.length) {
            otherNum = "0".repeat(thisNum.length - otherNum.length) + otherNum;
        } else {
            thisNum = "0".repeat(otherNum.length - thisNum.length) + thisNum;
        }
        if (thisNum > otherNum) {
            if (thisSign > otherSign) {
                return 1;
            } else if (thisSign === otherSign) {
                return 1;
            } else {
                return -1;
            }
        } else if (thisNum === otherNum) {
            if (thisSign > otherSign) {
                return 1;
            } else if (thisSign === otherSign) {
                return 0;
            } else {
                return -1;
            }
        } else {
            if (thisSign > otherSign) {
                return 1;
            } else if (thisSign === otherSign) {
                return -1;
            } else {
                return -1;
            }
        }
    },
    // Negates number
    // Returns new instance
    negate : function() {
        var ret = isc.BigDecimal.create(this);
        if (!ret.isNaN()) {
            if (ret.sign === 1) {
                ret.sign = -1;
            } else {
                ret.sign = 1;
            }
        }
        return ret;
    },
    // Add specified number to THIS number
    // Returns new instance
    add : function(number) {
        if (!(isc.isA.BigDecimal(number))) {
            number = isc.BigDecimal.create(number);
        }
        var thisNanValue = this.isNaN();
        var thisInfinityValue = this.isInfinity();
        var thisSign = this.getSign();
        var thisNum = this.getNum();
        var thisExp = this.getExp();
        var otherNanValue = number.isNaN();
        var otherInfinityValue = number.isInfinity();
        var otherSign = number.getSign();
        var otherNum = number.getNum();
        var otherExp = number.getExp();
        // If both values are NaN - return NaN.
        if (thisNanValue && otherNanValue) {
            return isc.BigDecimal.create();
        }
        // +Infinity-Infinity or -Infinity+Infinity results in NaN.
        if (thisInfinityValue && otherInfinityValue && thisSign != otherSign) {
            return isc.BigDecimal.create();
        }
        var ret = isc.BigDecimal.create("0");
        // If this value is (+/-)Infinity - adding anything to (+/-)Infinity equals (+/-)Infinity
        if (thisInfinityValue) {
            ret.sign = this.sign;
            ret.infinityValue = true;
            return ret.normalize();
        }
        // If other value is (+/-)Infinity - adding (+/-)Infinity to anything equals (+/-)Infinity
        if (otherInfinityValue) {
            ret.sign = number.sign;
            ret.infinityValue = true;
            return ret.normalize();
        }
        if (thisExp > otherExp) {
            thisNum += "0".repeat(thisExp - otherExp);
            thisExp = otherExp;
        } else {
            otherNum += "0".repeat(otherExp - thisExp);
            otherExp = thisExp;
        }
        if (thisNum.length > otherNum.length) {
            otherNum = "0".repeat(thisNum.length - otherNum.length) + otherNum;
        } else {
            thisNum = "0".repeat(otherNum.length - thisNum.length) + thisNum;
        }
        ret.sign = thisSign;
        ret.exp = thisExp;
        if (thisSign === otherSign) {
            var res = "";
            var carry = 0;
            for (var i = thisNum.length - 1; i >= 0; i--) {
                var s = parseInt(thisNum[i]) + parseInt(otherNum[i]) + carry;
                res = "" + (s % 10) + res;
                carry = Math.floor(s / 10);
            }
            if (carry > 0) {
                res = "" + carry + res;
            }
            ret.num = res;
        } else {
            if (thisNum < otherNum) {
                var tmp = thisNum;
                thisNum = otherNum;
                otherNum = tmp;
                ret.sign = otherSign;
            }
            var res = "";
            var carry = 0;
            for (var i = thisNum.length - 1; i >= 0; i--) {
                var s = 10 + parseInt(thisNum[i]) - parseInt(otherNum[i]) - carry;
                res = "" + (s % 10) + res;
                carry = (Math.floor(s / 10) >= 1)?0:1;
            }
            ret.num = res;
        }
        return ret.normalize();
    },
    // Subtracts specified number from THIS number.
    // Returns new instance
    subtract : function(number) {
        number = isc.BigDecimal.create(number);
        number = number.negate();
        return this.add(number);
    },
    multiply : function(number) {
        if (!(isc.isA.BigDecimal(number))) {
            number = isc.BigDecimal.create(number);
        }
        // If any is NaN - return NaN
        if (this.isNaN() || number.isNaN()) {
            return isc.BigDecimal.create();
        }
        // Multiplying any Infinity by 0 gives NaN
        if ((this.compareTo(0) === 0 && number.isInfinity())
            || (this.isInfinity() && number.compareTo(0) === 0)) {
            return isc.BigDecimal.create();
        }
        // Multiplying any Infinity by any number gives Infinity
        if (this.isInfinity() || number.isInfinity()) {
            var ret = isc.BigDecimal.create("Infinity");
            if (this.sign !== number.sign) {
                ret.sign = -1;
            }
            return ret;
        }
        // Multiplying any number by 0 gives 0
        if (this.compareTo(0) === 0 || number.compareTo(0) === 0) {
            return isc.BigDecimal.create(0);
        }
        // Inflate num values (from both sides) that they would represent
        // numbers of same magnitude.
        var tNum = this.num;
        var oNum = number.num;
        tNum += "0".repeat(Math.max(this.exp - number.exp, 0));
        oNum += "0".repeat(Math.max(number.exp - this.exp, 0));
        tNum = "0".repeat(Math.max(oNum.length - tNum.length, 0)) + tNum;
        oNum = "0".repeat(Math.max(tNum.length - oNum.length, 0)) + oNum;
        // Multiply 7-digit chunks: result would be maximum 14 digits long -
        // JS can handle this.
        var a = [];
        while (tNum.length > 0) {
            var tm = parseInt(tNum.substring(Math.max(tNum.length - 7, 0)));
            var tmpONum = oNum;
            var r1 = [];
            var r2 = [];
            while (tmpONum.length > 0) {
                var om = parseInt(tmpONum.substring(Math.max(tmpONum.length - 7, 0)));
                var r = tm * om;
                r1.push(r % 10000000);
                r1.push(0);
                r2.push(0);
                r2.push(Math.floor(r / 10000000));
                tmpONum = tmpONum.substring(0, Math.max(tmpONum.length - 7, 0));
            }
            a.push(r1);
            a.push(r2);
            tNum = tNum.substring(0, Math.max(tNum.length - 7, 0));
        }
        // If resulting array has more than 10 rows we have to use BigDecimal
        // to sum. Summing more than 10 we can get result exceeding
        // 15 digits thus loose precision.
        var useBD = true;
        if (a.length < 10) {
            useBD = false;
        }
        var y = 0;
        var x = 0;
        // Carry
        var c = (useBD)?isc.BigDecimal.create("0"):0;
        var resA = [];
        while (y < a.length) {
            var s = (useBD)?isc.BigDecimal.create("0"):0;
            var xx = x;
            var yy = y;
            while ((a[yy] !== undefined) && (a[yy][xx] !== undefined)) {
                if (useBD) {
                    s = s.add(a[yy++][xx--]);
                } else {
                    s += a[yy++][xx--];
                }
            }
            // Add previous carry and save chunk 7 digits long.
            // Higher digits saved to next carry.
            if (useBD) {
                s = s.add(c);
                var sNum = "00000000" + s.num + "0".repeat(s.exp);
                c = isc.BigDecimal.create(sNum.substring(0, sNum.length - 7));
                s = isc.BigDecimal.create(sNum.substring(sNum.length - 7));
            } else {
                s += c;
                c = Math.floor(s / 10000000);
                s = s % 10000000;
            }
            resA.push(s);
            if (x < a[0].length - 2) {
                x = x + 2;
            } else {
                if (x < a[0].length - 1) {
                    y++
                } else {
                    y = y + 2;
                }
                x = a[0].length - 1;
            }
        }
        resA.push(c);
        var resNum = "";
        for (var i = resA.length - 1; i >= 0; i--) {
            var sNum;
            if (useBD) {
                sNum = "00000000" + resA[i].num + "0".repeat(resA[i].exp);
            } else {
                sNum = "00000000" + resA[i]
            }
            // Each chunk is 7 digits long
            resNum += sNum.substring(sNum.length - 7);
        }
        var rSign = "";
        if (this.sign !== number.sign) {
            rSign = "-";
        }
        // Resulting exponent
        var rExp = Math.min(this.exp, number.exp) * 2;
        return isc.BigDecimal.create(rSign + resNum + "e" + rExp);
    },
    round : function(precision, mode) {
        // NaN, Infinity, Zero - there is nothing to round
        if (this.isNaN() || this.isInfinity() || this.num === "0") {
            return isc.BigDecimal.create(this);
        }
        if (!precision) {
            precision = 0;
        }
        // Number is already at required precision
        if ((-1 * precision) <= this.exp) {
            return isc.BigDecimal.create(this);
        }
        var leftPart;
        var rightPart;
        if ((-1 * precision) >= (this.exp + this.num.length)) {
            leftPart = "0";
            rightPart = "0".repeat((-1 * precision) - (this.exp + this.num.length)) + this.num;
        } else {
            leftPart = this.num.substring(0, this.exp + this.num.length + precision);
            rightPart = this.num.substring(this.exp + this.num.length + precision);
        }
        if (!mode) {
            mode = "round";
        }
        var left = isc.BigDecimal.create(leftPart);
        var right = isc.BigDecimal.create("0." + rightPart);
        if (mode === "round") {
            var c = right.compareTo("0.5");
            if (this.sign >= 0) {
                if (c >= 0) {
                    left = left.add(1);
                }
            } else {
                if (c > 0) {
                    left = left.add(1);
                }
                left = left.negate();
            }
            left.exp += (-1 * precision);
            return left.normalize();
        } else if (mode === "ceil" || mode == "java_ceil") {
            if (this.sign >= 0) {
                left = left.add(1);
            } else {
                left = left.negate();
            }
            left.exp += (-1 * precision);
            return left.normalize();
        } else if (mode === "floor" || mode == "java_floor") {
            if (this.sign < 0) {
                left = left.add(1).negate();
            }
            left.exp += (-1 * precision);
            return left.normalize();
        } else if (mode == "java_up") {
            left = left.add(1);
            if (this.sign < 0) {
                left = left.negate();
            }
            left.exp += (-1 * precision);
            return left.normalize();
        } else if (mode == "java_down") {
            if (this.sign < 0) {
                left = left.negate();
            }
            left.exp += (-1 * precision);
            return left.normalize();
        } else if (mode == "java_halfUp") {
            var c = right.compareTo("0.5");
            if (c >= 0) {
                left = left.add(1);
            }
            if (this.sign < 0) {
                left = left.negate();
            }
            left.exp += (-1 * precision);
            return left.normalize();
        } else if (mode == "java_halfDown") {
            var c = right.compareTo("0.5");
            if (c > 0) {
                left = left.add(1);
            }
            if (this.sign < 0) {
                left = left.negate();
            }
            left.exp += (-1 * precision);
            return left.normalize();
        } else if (mode == "java_halfEven") {
            var c = right.compareTo("0.5");
            if (c > 0) {
                left = left.add(1);
            } else if (c === 0) {
                var lastDigit = leftPart.substring(leftPart.length - 1);
                if (lastDigit === "1" || lastDigit === "3" || lastDigit === "5" || lastDigit === "7" || lastDigit === "9") {
                    left = left.add(1);
                }
            }
            if (this.sign < 0) {
                left = left.negate();
            }
            left.exp += (-1 * precision);
            return left.normalize();
        }
        return isc.BigDecimal.create(this);
    },
    ceil : function(precision) {
        return this.round(precision, "ceil");
    },
    floor : function(precision) {
        return this.round(precision, "floor");
    },
    // Parses provided parameter
    init : function () {
        this.Super("init", arguments);
        if (arguments && arguments[0]) {
            var value = arguments[0];
            if (isc.isA.Number(value)) {
                value = value.toExponential(20);
            }
            if (isc.isA.String(value)) {
                var parts = this.r.exec(value);
                if (parts) {
                    if (parts[0] !== "NaN") {
                        this.nanValue = false;
                        if (parts[1] !== undefined) {
                            this.sign = (parts[1] === "-"?-1:1);
                        }
                        if (parts[7] !== undefined) {
                            this.infinityValue = true;
                        } else {
                            if (parts[6] !== undefined) {
                                this.exp = new Number(parts[6]);
                                if (parts[5] === '-') {
                                    this.exp *= -1;
                                }
                            }
                            if (parts[2] !== undefined) {
                                this.num = parts[2];
                                this.num = this.num.replace(/^0*/, "");
                            } else {
                                this.num = parts[3];
                                this.num = this.num.replace(/^0*/, "");
                                if (parts[4] !== undefined) {
                                    parts[4] = parts[4].replace(/0*$/, "");
                                    this.exp -= parts[4].length;
                                    this.num += parts[4];
                                    this.num = this.num.replace(/^0*/, "");
                                }
                            }
                            this.normalize();
                        }
                    }
                }
            } else if (value === Infinity) {
                this.nanValue = false;
                this.sign = 1;
                this.infinityValue = true;
            } else if (value === -Infinity) {
                this.nanValue = false;
                this.sign = -1;
                this.infinityValue = true;
            } else if (isc.isA.BigDecimal(value)) {
                this.nanValue = value.isNaN();
                this.infinityValue = value.isInfinity();
                this.sign = value.getSign();
                this.num = value.getNum();
                this.exp = value.getExp();
                this.normalize();
            }
        }
    }
});

//
// Math helpers
//
isc.Math = {
    clamp : function (value, min, max) {
        if (value < min) return min;
        if (value > max) return max;
        return value;
    },
    // When called with two parameters `a' and `b', selects a random integer between `a' and `b'
    // inclusive, drawn uniformly.
    // When called with a single parameter `a', selects a random integer between 0 and `a' inclusive,
    // drawn uniformly.
    // @param a (int)
    // @param [b] (int)
    // @return (int)

    random : function (a, b) {

        if (b == null) {

            return Math.floor(Math.random() * (a + 1));
        } else {

            return Math.floor(Math.random() * (b - a + 1)) + a;
        }
    },

    _hexStringify : function (number, totalDigits) {
        var str = number.toString(16);
        if (str.length < totalDigits) str = isc.NumberUtil._getZeroString(totalDigits - str.length) + str;
        return str;
    },
    // Generate an RFC 4122-compliant UUID according to section 4.4. Algorithms for Creating a
    // UUID from Truly Random or Pseudo-Random Numbers.

    randomUUID : function () {
        var uint16s;
        if (window.Uint16Array && window.crypto && window.crypto.getRandomValues) {
            uint16s = new window.Uint16Array(8);
            window.crypto.getRandomValues(uint16s);
        } else {
            uint16s = new Array(8);
            var now = new Date().getTime();
            for (var i = 0; i < uint16s.length; ++i) {
                uint16s[i] = (now ^ (Math.random() * 65536)) & 0xFFFF;
            }
        }

        uint16s[3] = (uint16s[3] & 0x0FFF) | 0x4000;

        // Set the two most significant bits of clock_seq_hi_and_reserved to 0 and 1, respectively.
        uint16s[4] = (uint16s[4] & 0xBFFF) | 0x8000;

        return (this._hexStringify(uint16s[0], 4) + this._hexStringify(uint16s[1], 4) + "-" +
                this._hexStringify(uint16s[2], 4) + "-" +
                this._hexStringify(uint16s[3], 4) + "-" +
                this._hexStringify(uint16s[4], 4) + "-" +
                this._hexStringify(uint16s[5], 4) + this._hexStringify(uint16s[6], 4) + this._hexStringify(uint16s[7], 4)).toUpperCase();
    },

    // Generates a random string of length `len' from characters in a specified alphabet.
    // @param len (int) the length of the generated random string.
    // @param alphabet (String | int) when a String, each character of the string has an equal
    // probability of being selected as a character of the generated random string. When an
    // integer less than or equal to 36, the first `alphabet' characters of "0123456789abcdefghijklmnopqrstuvwxyz"
    // become the alphabet.
    randomString : function (len, alphabet) {
        var arr = new Array(len);
        var alphabetLen;
        if (isc.isA.Number(alphabet)) {
            alphabetLen = alphabet;
            alphabet = "0123456789abcdefghijklmnopqrstuvwxyz".substring(0, alphabetLen);
        } else {
            alphabetLen = alphabet.length;
        }
        for (var i = 0; i < len; ++i) {
            arr[i] = alphabet[this.random(alphabetLen - 1)];
        }
        return arr.join("");
    },

    _signum : function (x) {
        return (x < 0 ? -1 : (x > 0 ? 1 : 0));
    },



    // Calculate sqrt(a^2 + b^2) without overflow or underflow
    // Note: Firefox 27.0+ supports Math.hypot() from EcmaScript 6: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot
    _hypot : function (a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        if (a > b) {
            return a * Math.sqrt(1 + b * b / a / a);
        } else if (b != 0) {
            return b * Math.sqrt(1 + a * a / b / b);
        } else {
            return a;
        }
    },

    // Calculates the shortest Euclidean distance from a test point (x3, y3) to the line between
    // start point (x1, y1) and end point (x2, y2).
    euclideanDistanceToLine : function (x1, y1, x2, y2, x3, y3) {
        // http://web.archive.org/web/20080704103329/http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/

        var dx = x2 - x1,
            dy = y2 - y1;

        var uDenom = dx * dx + dy * dy;
        // If the line's endpoints are coincident, then just return the Euclidean distance from
        // the test point to the start point.
        if (uDenom <= 0.00001) {
            return this.euclideanDistance(x1, y1, x3, y3);
        }

        var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / uDenom;

        if (u < 0) {
            return this.euclideanDistance(x1, y1, x3, y3);
        } else if (u > 1) {
            return this.euclideanDistance(x2, y2, x3, y3);
        } else {
            // Actually compute the point of intersection.
            var x = x1 + u * dx,
                y = y1 + u * dy;

            return this.euclideanDistance(x, y, x3, y3);
        }
    },

    // Calculates the Euclidean distance between two points.
    euclideanDistance : function (x1, y1, x2, y2) {
        if (arguments.length == 2) {
            // Assume that the two given arguments are points.
            var p1 = x1,
                p2 = y1;
            x1 = p1[0];
            y1 = p1[1];
            x2 = p2[0];
            y2 = p2[1];
        }
        return this._hypot((x1 - x2), (y1 - y2));
    },

    // Trigonometry
    // ---------------------------------------------------------------------------------------
    _radPerDeg: Math.PI / 180,

    _piOver2: Math.PI / 2,

    //> @classMethod math.toRadians()
    // Converts an angle in degrees to radians.
    // @param angle (double) the angle in degrees.
    // @return (double) the angle in radians.
    //<
    toRadians : function (angle) {
        return angle * this._radPerDeg;
    },

    //> @classMethod math.cosdeg()
    // Calculates the cosine of the given angle in degrees.
    // @param angle (double) the angle in degrees.
    // @return (double) the cosine of the given angle.
    //<
    cosdeg : function (angle) {
        return Math.cos(angle * this._radPerDeg);
    },

    //> @classMethod math.sindeg()
    // Calculates the sine of the given angle in degrees.
    // @param angle (double) the angle in degrees.
    // @return (double) the sine of the given angle.
    //<
    sindeg : function (angle) {
        return Math.sin(angle * this._radPerDeg);
    },

    // Linear Algebra
    // ---------------------------------------------------------------------------------------

    // Calculates the dot product of two vectors. To be well formed, the two vectors must have
    // the same array length (dimension).
    _dot : function (u, v) {
        var ret = 0;
        for (var i = 0; i < u.length; ++i) {
            ret += u[i] * v[i];
        }
        return ret;
    },

    // Given a matrix A (that is an Array of Arrays of Numbers) returns a new matrix that is the matrix
    // multiplication of the transpose of A times A.  If A has m rows and n columns then the
    // new matrix will have n rows and n columns.
    _dotAtA : function (A) {
        var m = A.length,
            n = A[0].length,
            AtA = new Array(n);

        for (var i = n; i--; ) {
            AtA[i] = new Array(n);
        }

        for (var i = n; i--; ) {
            var AtAi = AtA[i];
            for (var j = i; j < n; ++j) {
                var sum = 0;
                for (var k = m; k--; ) {
                    var Ak = A[k];
                    sum += Ak[i] * Ak[j];
                }
                AtAi[j] = AtA[j][i] = sum;
            }
        }
        return AtA;
    },

    // Given a matrix A, that is an Array of Arrays of Numbers, and a vector b, that is an Array of Numbers,
    // return a new vector that is the matrix multiplication of A times b.  If A has m rows and n columns,
    // then b is expected to have length n, and the returned vector will have length m.
    _dotAtb : function (A, b) {
        if (A.length != b.length) {
            return null;
        }

        var m = A[0].length, n = b.length,
            Atb = new Array(m);

        for (var i = m; i--; ) {
            var sum = 0;
            for (var j = n; j--; ) {
                sum += A[j][i] * b[j];
            }
            Atb[i] = sum;
        }
        return Atb;
    },

    // Calculates the Cholesky decomposition of a symmetric, positive-definite matrix A.
    // A must be an Array of Arrays of Numbers.  The return value is the unique,
    // lower triangular matrix L such that A = L * Lt.  If A has n rows and n columns
    // (it must have equal number of rows and columns in order to be symmetric), then the
    // returned matrix L will also have n rows and n columns.
    // See:  http://en.wikipedia.org/wiki/Cholesky_decomposition
    _cholesky : function (A) {
        if (A.length != A[0].length) {
            // The matrix A is apparently not symmetric, so return null.
            return null;
        }

        var n = A.length,
            L = isc.Math._createMatrix(n, n);

        for (var j = 0; j < n; ++j) {
            var Lj = L[j],
                sum = 0;

            for (var k = 0; k < j; ++k) {
                var Ljk = Lj[k];
                sum += Ljk * Ljk;
            }

            if (A[j][j] - sum < 0) {
                // The matrix A must not have been positive-definite.  In this case
                // the matrix has no Cholesky decomposition, so return null.
                return null;
            }

            var Ljj = Lj[j] = Math.sqrt(A[j][j] - sum);

            for (var i = j + 1; i < n; ++i) {
                var Li = L[i],
                    sum = 0;
                for (var k = 0; k < j; ++k) {
                    sum += Li[k] * Lj[k];
                }
                Li[j] = (A[i][j] - sum) / Ljj;
            }
        }

        return L;
    },

    // Return the transpose of a matrix A (an Array of Arrays of Numbers).  The transpose
    // matrix will have the same number of rows as A has columns and the same
    // number of columns as A has rows.
    _transpose : function (A) {
        var m = A.length, n = A[0].length,
            At = new Array(n);
        for (var i = n; i--; ) {
            At[i] = new Array(m);
        }
        for (var i = n; i--; ) {
            var Ati = At[i];
            for (var j = m; j--; ) {
                Ati[j] = A[j][i];
            }
        }
        return At;
    },

    // Create a matrix of m x n size as an Array of Arrays with no initial values.
    _createMatrix : function (m, n) {
        var A = new Array(m);
        for (var i = m; i--; ) {
            A[i] = new Array(n);
        }
        return A;
    },

    // Similar to _createMatrix(), but the matrix is filled with zeros.
    _createZeroMatrix : function (m, n) {
        var A = new Array(m);
        for (var i = m; i--; ) {
            var Ai = A[i] = new Array(n);
            for (var j = n; j--; ) {
                Ai[j] = 0;
            }
        }
        return A;
    },

    // Creates a new Array of length n that contains zeros as entries.
    _createZeroVector : function (n) {
        var v = new Array(n);
        for (var i = n; i--; ) {
            v[i] = 0;
        }
        return v;
    },

    // Creates a new matrix (an Array of Arrays) that has identical size and
    // entries as the given matrix A.
    _cloneMatrix : function (A) {
        var m = A.length, n = A[0].length,
            B = new Array(m);
        for (var i = m; i--; ) {
            var Ai = A[i],
                Bi = B[i] = new Array(n);
            for (var j = n; j--; ) {
                Bi[j] = Ai[j];
            }
        }
        return B;
    },

    // Calculate the MoorePenrose pseudoinverse of a matrix A.
    _pseudoInv : function (A, maxIterations) {
        var svd = isc.Math._svd(A, maxIterations, true, true);
        if (svd != null) {
            var s = svd.s,
                m = s.length;
            for (var i = m; i--; ) {
                s[i] = (s[i] == 0 ? 0 : (1 / s[i]));
            }
            return isc.Math._dotUSVt(svd.V, s, svd.U);
        } else {
            return null;
        }
    },

    // Calculate the singular value decomposition of a matrix A into the product
    // A = U * S * Vt, where U and V are unitary matrices, and S is a
    // diagonal matrix.  The return value is an object with the keys "U" and "V"
    // each mapped to a matrix (an Array of Arrays of Numbers) and the key "s" mapped
    // to an Array of Numbers.  The matrix S in the singular value decomposition can
    // be formed by taking a zero matrix of the appropriate size (see _createZeroMatrix())
    // and filling the diagonal entries of that matrix with the entries of s:
    //
    //     var m = A.length,
    //         n = A[0].length,
    //         svd = isc.Math._svd(A),
    //         s = svd.s,
    //         S = isc.Math._createZeroMatrix(m, n);
    //     for (var i = 0; i < m && i < n; ++i) {
    //         S[i][i] = s[i];
    //     }
    //

    _svd : function (A, maxIterations, wantU, wantV, calculateThinSVD) {
        if (maxIterations == null) {
            maxIterations = 50;
        }
        if (wantU == null) {
            wantU = true;
        }
        if (wantV == null) {
            wantV = true;
        }

        var eps = 2.220446049250313e-16; // 2^-52
        var tiny = Number.MIN_VALUE;
        var m = A.length, n = A[0].length;

        if (m < n) {
            var ret = isc.Math._svd(isc.Math._transpose(A), maxIterations, wantV, wantU);
            if (ret != null) {
                var swap = ret.U;
                ret.U = ret.V;
                ret.V = swap;
            }
            return ret;
        }

        var hypot = isc.Math._hypot,
            nu = Math.min(m, n),
            q = (calculateThinSVD ? nu : m),
            p = Math.min(n, m + 1),
            nct = Math.min(m - 1, n),
            nrt = Math.max(0, Math.min(n - 2, m)),
            A = isc.Math._cloneMatrix(A),
            s = new Array(p),
            U = isc.Math._createZeroMatrix(m, q),
            V = isc.Math._createZeroMatrix(n, n),
            e = isc.Math._createZeroVector(n),
            work = isc.Math._createZeroVector(m);

        for (var k = 0, maxK = Math.max(nct, nrt); k < maxK; ++k) {
            if (k < nct) {
                s[k] = 0;
                for (var i = k; i < m; ++i) {
                    s[k] = hypot(s[k], A[i][k]);
                }
                if (s[k] != 0) {
                    if (A[k][k] < 0) {
                        s[k] = -s[k];
                    }
                    for (var i = k; i < m; ++i) {
                        A[i][k] /= s[k];
                    }
                    A[k][k] += 1;
                }
                s[k] = -s[k];
            }
            for (var j = k + 1; j < n; ++j) {
                if (k < nct && s[k] != 0) {
                    // apply the transformation
                    var t = 0;
                    for (var i = k; i < m; ++i) {
                        t += A[i][k] * A[i][j];
                    }
                    t = -t / A[k][k];
                    for (var i = k; i < m; ++i) {
                        A[i][j] += t * A[i][k];
                    }
                }

                // place the kth row of A into e for the subsequent calculation of the row transform
                e[j] = A[k][j];
            }
            if (wantU && k < nct) {
                // place the transformation in U for subsequent back multiplication
                for (var i = k; i < m; ++i) {
                    U[i][k] = A[i][k];
                }
            }
            if (k < nrt) {
                // compute the kth row transformation and place the kth super-diagonal into e[k].
                e[k] = 0;
                for (var i = k + 1; i < n; ++i) {
                    e[k] = hypot(e[k], e[i]);
                }
                if (e[k] != 0) {
                   if (e[k + 1] < 0) {
                       e[k] = -e[k];
                   }
                   for (var i = k + 1; i < n; ++i) {
                       e[i] /= e[k];
                   }
                   e[k + 1] += 1;
                }
                e[k] = -e[k];

                if (k + 1 < m && e[k] != 0) {
                    // apply the transformation
                    for (var i = k + 1; i < m; ++i) {
                        work[i] = 0;
                    }
                    for (var j = k + 1; j < n; ++j) {
                        for (var i = k + 1; i < m; ++i) {
                            work[i] += e[j] * A[i][j];
                        }
                    }
                    for (var j = k + 1; j < n; ++j) {
                        var t = -e[j] / e[k + 1];
                        for (var i = k + 1; i < m; ++i) {
                            A[i][j] += t * work[i];
                        }
                    }
                }
                if (wantV) {
                    // place the transformation in V for subsequent back multiplication
                    for (var i = k + 1; i < n; ++i) {
                        V[i][k] = e[i];
                    }
                }
            }
        }

        // Set up the final bidiagonal matrix of order p
        if (nct < n) {
            s[nct] = A[nct][nct];
        }
        if (m < p) {
            s[p - 1] = 0;
        }
        if (nrt + 1 < p) {
            e[nrt] = A[nrt][p - 1];
        }
        e[p - 1] = 0;

        // If required, generate U
        if (wantU) {
            for (var j = nct; j < q; ++j) {
                for (var i = 0; i < m; ++i) {
                    U[i][j] = 0;
                }
                U[j][j] = 1;
            }
            for (var k = nct - 1; k >= 0; --k) {
                if (s[k] != 0) {
                    for (var j = k + 1; j < q; ++j) {
                        var t = 0;
                        for (var i = k; i < m; ++i) {
                            t += U[i][k] * U[i][j];
                        }
                        t = -t / U[k][k];
                        for (var i = k; i < m; ++i) {
                            U[i][j] += t * U[i][k];
                        }
                    }
                    for (var i = k; i < m; ++i) {
                        U[i][k] = -U[i][k];
                    }
                    U[k][k] += 1;
                    for (var i = 0; i < k - 1; ++i) {
                        U[i][k] = 0;
                    }
                } else {
                    for (var i = 0; i < m; ++i) {
                        U[i][k] = 0;
                    }
                    U[k][k] = 1;
                }
            }
        }

        // If required, generate V
        if (wantV) {
            for (var k = n - 1; k >= 0; --k) {
                if (k < nrt && e[k] != 0) {
                    for (var j = k + 1; j < nu; ++j) {
                        var t = 0;
                        for (var i = k + 1; i < n; ++i) {
                            t += V[i][k] * V[i][j];
                        }
                        t = -t / V[k+1][k];
                        for (var i = k + 1; i < n; ++i) {
                            V[i][j] += t * V[i][k];
                        }
                    }
                }
                for (var i = 0; i < n; ++i) {
                    V[i][k] = 0;
                }
                V[k][k] = 1;
            }
        }

        // Main iteration loop for the singular values.
        var pp = p-1,
            iter = 0;
        while (p > 0) {
            if (iter > maxIterations) {
                return null;
            }

            // Inspect for negligible elements in the s and e arrays.
            // case 1:  s[p] and e[k-1] are negligible and k < p
            // case 2:  s[k] is negligible and k < p
            // case 3:  e[k-1] is negligible, k < p, and s[k], ..., s[p] are not negligible (QR step)
            // case 4:  e[p-1] is negligible (convergence)
            var k, caseNum;
            for (k = p - 2; k >= -1; --k) {
                if (k == -1) {
                    break;
                }
                if (Math.abs(e[k]) <= tiny + eps*(Math.abs(s[k]) + Math.abs(s[k+1]))) {
                    e[k] = 0;
                    break;
                }
            }
            if (k == p - 2) {
                // e[p - 1] is negligible (convergence)
                caseNum = 4;
            } else {
                var ks;
                for (ks = p - 1; ks >= k; --ks) {
                    if (ks == k) {
                        break;
                    }
                    var t = (ks != p ? Math.abs(e[ks]) : 0) +
                            (ks != k + 1 ? Math.abs(e[ks - 1]) : 0);
                    if (Math.abs(s[ks]) <= tiny + eps * t)  {
                        s[ks] = 0;
                        break;
                    }
                }
                if (ks == k) {
                    // e[k-1] is negligible, k < p, and
                    // s[k], ..., s[p] are not negligible => QR step
                    caseNum = 3;
                } else if (ks == p - 1) {
                    // s[p] and e[k-1] are negligible and k < p
                    caseNum = 1;
                } else {
                    // s[k] is negligible and k < p
                    caseNum = 2;
                    k = ks;
                }
            }
            ++k;

            // Perform the task indicated by the exact case:
            switch (caseNum) {
            case 1:
                // Deflate negligible s[p]
                var f = e[p-2];
                e[p-2] = 0;
                for (var j = p - 2; j >= k; --j) {
                    var t = hypot(s[j], f),
                        cs = s[j] / t,
                        sn = f / t;
                    s[j] = t;
                    if (j != k) {
                        f = -sn * e[j-1];
                        e[j-1] = cs * e[j-1];
                    }
                    if (wantV) {
                        for (var i = 0; i < n; ++i) {
                            t = cs * V[i][j] + sn * V[i][p-1];
                            V[i][p-1] = -sn * V[i][j] + cs * V[i][p-1];
                            V[i][j] = t;
                        }
                    }
                }
                break;

            case 2:
                // Split at negligible s(k).
                var f = e[k-1];
                e[k-1] = 0;
                for (var j = k; j < p; ++j) {
                    var t = hypot(s[j], f),
                        cs = s[j] / t,
                        sn = f / t;
                    s[j] = t;
                    f = -sn * e[j];
                    e[j] = cs * e[j];
                    if (wantU) {
                        for (var i = 0; i < m; ++i) {
                            t = cs * U[i][j] + sn * U[i][k-1];
                            U[i][k-1] = -sn * U[i][j] + cs * U[i][k-1];
                            U[i][j] = t;
                        }
                    }
                }
                break;

            case 3:
                // Perform one QR step

                // Calculate the shift.
                var scale = Math.max(
                        Math.abs(s[p-1]),
                        Math.abs(s[p-2]),
                        Math.abs(e[p-2]),
                        Math.abs(s[k]),
                        Math.abs(e[k])),
                    sp = s[p-1] / scale,
                    spm1 = s[p-2] / scale,
                    epm1 = e[p-2] / scale,
                    sk = s[k] / scale,
                    ek = e[k] / scale,
                    b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2,
                    c = sp * epm1 * sp * epm1,
                    shift = 0;
                if (!(b == 0 && c == 0)) {
                   shift = Math.sqrt(b * b + c);
                   if (b < 0) {
                      shift = -shift;
                   }
                   shift = c / (b + shift);
                }
                var f = (sk + sp) * (sk - sp) + shift,
                    g = sk * ek;

                // Chase zeros
                for (var j = k; j < p - 1; ++j) {
                   var t = hypot(f, g),
                       cs = f / t,
                       sn = g / t;
                   if (j != k) {
                      e[j-1] = t;
                   }
                   f = cs * s[j] + sn * e[j];
                   e[j] = cs * e[j] - sn * s[j];
                   g = sn * s[j+1];
                   s[j+1] = cs * s[j+1];
                   if (wantV) {
                       for (var i = 0; i < n; ++i) {
                           t = cs * V[i][j] + sn * V[i][j+1];
                           V[i][j+1] = -sn * V[i][j] + cs * V[i][j+1];
                           V[i][j] = t;
                       }
                   }
                   t = hypot(f, g);
                   cs = f / t;
                   sn = g / t;
                   s[j] = t;
                   f = cs * e[j] + sn * s[j+1];
                   s[j+1] = -sn * e[j] + cs * s[j+1];
                   g = sn * e[j+1];
                   e[j+1] = cs * e[j+1];
                   if (wantU && j < m - 1) {
                       for (var i = 0; i < m; ++i) {
                           t = cs * U[i][j] + sn * U[i][j+1];
                           U[i][j+1] = -sn * U[i][j] + cs * U[i][j+1];
                           U[i][j] = t;
                       }
                   }
                }
                e[p-2] = f;
                ++iter;
                break;

            case 4:
                // Convergence.

                // Make the singular values non-negative
                if (s[k] <= 0) {
                    s[k] = -s[k];
                    if (wantV) {
                        for (var i = 0; i <= pp; ++i) {
                            V[i][k] = -V[i][k];
                        }
                    }
                }

                // Order the singular values.
                for (; k < pp; ++k) {
                    if (s[k] >= s[k+1]) {
                        break;
                    }
                    var t = s[k];
                    s[k] = s[k+1];
                    s[k+1] = t;
                    if (wantV && k < n - 1) {
                        for (var i = 0; i < n; ++i) {
                            t = V[i][k+1]; V[i][k+1] = V[i][k]; V[i][k] = t;
                        }
                    }
                    if (wantU && k < m - 1) {
                        for (var i = 0; i < m; ++i) {
                            t = U[i][k+1]; U[i][k+1] = U[i][k]; U[i][k] = t;
                        }
                    }
                }
                iter = 0;
                --p;
                break;
            } // end of switch
        } // end of loop while p > 0

        return { U: U, s: s, V: V };
    },

    // Takes a matrix U, an array s that defines the diagonal elements of a diagonal matrix S, and
    // a matrix V, and returns the matrix multiplication of U times S times the transpose of V.
    // This method may be used to check the singular value decomposition of a matrix A,
    // but it is also used to calculate the MoorePenrose pseudoinverse of A (see _pseudoInv()).
    _dotUSVt : function (U, s, V) {
        var m = U.length,
            n = V.length,
            l = Math.min(m, n),
            A = isc.Math._createMatrix(m, n);

        for (var i = m; i--; ) {
            var Ui = U[i], Ai = A[i];
            for (var j = n; j--; ) {
                var sum = 0, Vj = V[j];
                for (var k = l; k--; ) {
                    sum += Ui[k] * s[k] * Vj[k];
                }
                Ai[j] = sum;
            }
        }
        return A;
    },

    _EPSILON : (function () {
        var i = 0;
        while (1.0 + Math.pow(2, -i) > 1.0) {
            ++i;
        }
        return Math.pow(2, -i + 1);
    })(),

    // A constructor function for a complex number.
    _complexNumber : function (real, imag) {
        this.real = real;
        this.imag = imag;
    },


    _rpolyState : {
        // arrays of numbers:
        p: [], qp: [], k: [], qk: [], svk: [],
        // numbers:
        sr: 0, si: 0, u: 0, v: 0, a: 0, b: 0, c: 0, d: 0, a1: 0, a2: 0, a3: 0, a6: 0, a7: 0, e: 0,
        f: 0, g: 0, h: 0, szr: 0, szi: 0, lzr: 0, lzi: 0,
        // integers:
        n: 0,
        nn: 0
    },
    _rpoly : function (op, degree) {

        var state = isc.Math._rpolyState,
            zeros = [],
            fail = false;

        // The following statements set machine constants used in various parts of the program.
        // The meaning of the four constants are:
        // eta     The maximum relative representation error which can be described as the
        //         smallest positive floating point number such that 1.0 + eta is greater than 1.
        // `are` and `mre` refer to the unit error in `+` and `*` respectively.  They are assumed
        // to be the same as eta.
        var eta = isc.Math._EPSILON,
            are = eta,
            mre = eta;

        // Initialization of constants for shift rotation.
        var xx = Math.SQRT1_2;
        var yy = -xx;
        var cosr = Math.cos(94 * Math.PI / 180);
        var sinr = Math.sin(94 * Math.PI / 180);

        // Skip any leading coefficients that are zero.
        var op0 = 0;
        while (op0 <= degree && op[op0] == 0) {
            ++op0;
        }
        degree -= Math.min(degree, op0);

        if (degree == 0) {
            // Fail if the degree is zero.  The polynomial is constant so there are either
            // zero roots or infinitely many roots.
            fail = true;
            degree = 0;
            return { degree: degree, zeros: zeros, fail: fail };
        }
        state.n = degree;
        state.nn = degree + 1;

        // Remove the zeros at the origin if any.
        while (op[op0 + state.nn - 1] == 0) {
            var j = degree - state.n;
            zeros[j] = new isc.Math._complexNumber(0, 0);
            --state.nn;
            --state.n;
        }

        // Make a copy of the coefficients.
        for (var i = state.nn; i--; ) {
            state.p[i] = op[op0 + i];
        }

        var pt = new Array(101),
            temp = new Array(101);
        for (;;) {
            // Start the algorithm for one zero.
            if (state.n <= 2) {
                // Calculate the final zero or pair of zeros.
                if (state.n == 2) {
                    var quadOutput = isc.Math._quad(state.p[0], state.p[1], state.p[2]);
                    zeros[degree - 2] = new isc.Math._complexNumber(quadOutput.sr, quadOutput.si);
                    zeros[degree - 1] = new isc.Math._complexNumber(quadOutput.lr, quadOutput.li);
                } else if (state.n == 1) {
                    zeros[degree - 1] = new isc.Math._complexNumber(-state.p[1] / state.p[0], 0);
                }
                return { degree: degree, zeros: zeros, fail: fail };
            }

            // Find largest and smallest moduli of coefficients.
            var max = 0;
            var min = Number.MAX_VALUE;
            for (var i = state.nn; i--; ) {
                var x = Math.abs(state.p[i]);
                if (x > max) {
                    max = x;
                }
                if (x != 0 && x < min) {
                    min = x;
                }
            }

            // Scale if there are large or very small coefficients computes a scale factor to multiply
            // the coefficients of the polynomial.  The scaling is done to avoid overflow and to
            // avoid undetected underflow interfering with the convergence criterion.  The factor is
            // a power of 10.
            var sc = (Number.MIN_VALUE / eta) / min;
            if ((sc > 1 && Number.MAX_VALUE / sc >= max) || max >= 10) {
                if (sc == 0) {
                    sc = Number.MIN_VALUE;
                }
                var factor = Math.pow(10, Math.floor(Math.log(sc) / Math.LN10 + 0.5));
                if (factor != 1) {
                    if (factor == 0) {
                        // You're on the Edge...of an underflow.
                        // Workaround for MS Edge bug: minimum safe Number value per MS docs
                        // https://msdn.microsoft.com/en-us/library/ff806190(v=vs.94).aspx
                        // is: Number.MIN_VALUE: 5.00E-324
                        // but if you substitute anything smaller than -308 in the formula
                        // below, it will underflow, returning zero.  The 308 limit is
                        // suspiciously the same as the exponent of Number.MAX_VALUE: 1.79E+308.
                        // The Math.pow() above ends up resolving to Math.pow(10, -318) in, for
                        // example, our FE "Shape Gallery" example whend drawing a bezier curve
                        // (and we end up here because Edge doesn't implement the
                        // isPointInStroke() Canvas API).
                        // Also, This -308 exponent limit is a regression from IE which doesn't
                        // share this shortcoming.
                        //
                        // If left unaddressed, a zero factor here ends up causing an infinite loop by
                        // zeroing out the values in the state.p[].
                        // all the
                        factor = Math.pow(10, -308);
                    }
                    for (var i = state.nn; i--; ) {
                        state.p[i] *= factor;
                    }
                }
            }

            // Compute lower bound on moduli of zeros.
            for (var i = state.nn; i--; ) {
                pt[i] = Math.abs(state.p[i]);
            }
            pt[state.nn - 1] = -pt[state.nn - 1];
            // Compute upper estimate of bound.
            var x = Math.exp((Math.log(-pt[state.nn - 1]) - Math.log(pt[0])) / state.n);
            if (pt[state.n - 1] != 0) {
                // If Newton step at the origin is better, use it.
                var xm = -pt[state.nn - 1] / pt[state.n - 1];
                if (xm < x) {
                    x = xm;
                }
            }

            // Chop the interval (0,x) until ff <= 0.
            for (;;) {
                var xm = x / 10;
                var ff = pt[0];
                for (var i = 1; i < state.nn; ++i) {
                    ff = ff * xm + pt[i];
                }
                if (ff > 0) {
                    x = xm;
                } else {
                    break;
                }
            }

            // Do Newton iteration until x converges to two decimal places.
            for (var dx = x; Math.abs(dx / x) > 5e-3; ) {
                var ff = pt[0];
                var df = ff;
                for (var i = 1; i < state.n; ++i) {
                    ff = ff * x + pt[i];
                    df = df * x + ff;
                }
                ff = ff * x + pt[state.nn - 1];
                dx = ff / df;
                x -= dx;
            }

            var bnd = x;
            // Compute the derivative as the intial k polynomial and do 5 steps with no shift.
            var nm1 = state.n - 1;
            state.k[0] = state.p[0];
            for (var i = state.n; (--i) >= 1; ) {
                state.k[i] = (state.nn - i - 1) * state.p[i] / state.n;
            }
            var aa = state.p[state.nn - 1];
            var bb = state.p[state.n - 1];
            var zerok = (state.k[state.n - 1] == 0);
            for (var jj = 5; jj--; ) {
                var cc = state.k[state.n - 1];
                if (zerok) {
                    // Use unscaled form of recurrence.
                    for (var i = 0; i < nm1; ++i) {
                        var j = state.nn - i;
                        state.k[j] = state.k[j - 1];
                    }
                    state.k[0] = 0;
                    zerok = (state.k[state.n - 1] == 0);
                } else {
                    // Use scaled form of recurrence if value of k at 0 is nonzero.
                    var t = -aa / cc;
                    for (var i = 0; i < nm1; ++i) {
                        var j = state.nn - i;
                        state.k[j] = t * state.k[j - 1] + state.p[j];
                    }
                    state.k[0] = state.p[0];
                    zerok = (Math.abs(state.k[state.n - 1]) <= Math.abs(bb) * eta * 10);
                }
            }

            // Save k for restarts with new shifts.
            for (var i = state.n; i--; ) {
                temp[i] = state.k[i];
            }

            // Loop to select the quadratic corresponding to each new shift.
            for (var cnt = 1; cnt <= 20; ++cnt) {
                // Quadratic corresponds to a double shift to a non-real point and its complex
                // conjugate.  The point has modulus bnd and amplitude rotated by 94 degrees from
                // the previous shift.
                var xxx = cosr * xx - sinr * yy;
                yy = sinr * xx + cosr * yy;
                xx = xxx;
                state.sr = bnd * xx;
                state.si = bnd * yy;
                state.u = state.sr * -2;
                state.v = bnd;
                // Second stage calculation, fixed quadratic
                var nz = isc.Math._fxshfr(state, cnt * 20, eta, are, mre);
                if (nz != 0) {
                    // The second stage jumps directly to one of the third stage iterations and
                    // returns here if successful.  Deflate the polynomial, store the zero or
                    // zeros and return to the main algorithm.
                    var j = degree - state.n;
                    zeros[j] = new isc.Math._complexNumber(state.szr, state.szi);
                    state.nn -= nz;
                    state.n = state.nn - 1;
                    for (var i = state.nn; i--; ) {
                        state.p[i] = state.qp[i];
                    }
                    if (nz != 1) {
                        zeros[j + 1] = new isc.Math._complexNumber(state.lzr, state.lzi);
                    }
                    break;
                }

                // If the iteration is unsuccessful another quadratic is chosen after restoring k.
                for (var i = state.n; i--; ) {
                    state.k[i] = temp[i];
                }
            }
        }

        // Return with failure if no convergence with 20 shifts.
        fail = true;
        degree -= state.n;
        return { degree: degree, zeros: zeros, fail: fail };
    },


    _fxshfr : function (state, l2, eta, are, mre) {

        var betav = 0.25;
        var betas = 0.25;
        var oss = state.sr;
        var ovv = state.v;
        var otv = 0, ots = 0;

        // Evaluate polynomial by synthetic division.
        var quadsdOutput = isc.Math._quadsd(state.nn, state.u, state.v, state.p);
        for (var i = state.nn; i--; ) {
            state.qp[i] = quadsdOutput.q[i];
        }
        state.a = quadsdOutput.a;
        state.b = quadsdOutput.b;

        var type = isc.Math._calcsc(state, eta);
        var vv = 0, ss = 0, tv = 0, ts = 0;
        for (var j = 1; j <= l2; ++j, ovv = vv, oss = ss, otv = tv, ots = ts) {
            // Calculate next k polynomial and estimate v.
            isc.Math._nextk(state, type, eta);
            type = isc.Math._calcsc(state, eta);
            var newestOutput = isc.Math._newest(state, type);
            var ui = newestOutput.uu;
            var vi = newestOutput.vv;

            vv = vi;
            // Estimate s.
            ss = 0;
            if (state.k[state.n - 1] != 0) {
                ss = -state.p[state.nn - 1] / state.k[state.n - 1];
            }
            tv = 1;
            ts = 1;
            if (j == 1 || type == 3) {
                continue;
            }
            // Compute relative measures of convergence of s and v sequences.
            if (vv != 0) {
                tv = Math.abs((vv - ovv) / vv);
            }
            if (ss != 0) {
                ts = Math.abs((ss - oss) / ss);
            }
            // If decreasing, multiply two most recent convergence measures.
            var tvv = 1;
            if (tv < otv) {
                tvv = tv * otv;
            }
            var tss = 1;
            if (ts < ots) {
                tss = ts * ots;
            }
            // Compare with convergence criteria.
            var vpass = tvv < betav;
            var spass = tss < betas;
            if (!(spass || vpass)) {
                continue;
            }
            // At least one sequence has passed the convergence test.  Store variables before iterating.
            var svu = state.u;
            var svv = state.v;
            for (var i = state.n; i--; ) {
                state.svk[i] = state.k[i];
            }
            var s = ss;
            // Choose iteration according to the fastest converging sequence.
            var vtry = false;
            var stry = false;
            for (var tryQuadraticIteration = !(spass && (!vpass || tss < tvv)); true; ) {
                if (tryQuadraticIteration) {
                    var nz = isc.Math._quadit(state, ui, vi, eta, are, mre);
                    if (nz > 0) {
                        return nz;
                    }

                    // Quadratic iteration has failed. flag that it has been tried and decrease
                    // the convergence criterion.
                    vtry = true;
                    betav /= 4;
                    // Try linear iteration if it has not been tried and the s sequence is converging.
                    if (stry || !spass) {
                        // Restore variables.
                        state.u = svu;
                        state.v = svv;
                        for (var i = state.n; i--; ) {
                            state.k[i] = state.svk[i];
                        }
                        if (vpass && !vtry) {
                            tryQuadraticIteration = true;
                            continue;
                        } else {
                            break;
                        }
                    }
                    for (var i = state.n; i--; ) {
                        state.k[i] = state.svk[i];
                    }
                }

                var realitOutput = isc.Math._realit(state, s, eta, are, mre);
                s = realitOutput.sss;
                var nz = realitOutput.nz;
                var iflag = realitOutput.iflag;
                if (nz > 0) {
                    return nz;
                }

                // Linear iteration has failed.  Flag that it has been tried and decrease the convergence criterion.
                stry = true;
                betas /= 4;
                if (iflag != 0) {
                    // If linear iteration signals an almost double real zero attempt quadratic interation.
                    ui = -(s + s);
                    vi = s * s;
                    tryQuadraticIteration = true;
                    continue;
                }

                // Restore variables.
                state.u = svu;
                state.v = svv;
                for (var i = state.n; i--; ) {
                    state.k[i] = state.svk[i];
                }
                // Try quadratic iteration if it has not been tried and the v sequence is converging.
                tryQuadraticIteration = vpass && !vtry;
                if (!tryQuadraticIteration) {
                    break;
                }
            }

            // Recompute qp and scalar values to continue the second stage.
            var quadsdOutput = isc.Math._quadsd(state.nn, state.u, state.v, state.p);
            for (var i = state.nn; i--; ) {
                state.qp[i] = quadsdOutput.q[i];
            }
            state.a = quadsdOutput.a;
            state.b = quadsdOutput.b;

            type = isc.Math._calcsc(state, eta);
        }
        return 0;
    },


    _quadit : function (state, uu, vv, eta, are, mre) {

        state.u = uu;
        state.v = vv;

        var tried = false,
            relstp = 0,
            omp = 0;

        var j = 0;
        for (;;) {
            var quadOutput = isc.Math._quad(1, state.u, state.v);
            state.szr = quadOutput.sr;
            state.szi = quadOutput.si;
            state.lzr = quadOutput.lr;
            state.lzi = quadOutput.li;
            // Return if roots of the quadratic are real and not close to multiple or nearly equal
            // and of opposite sign.
            if (Math.abs(Math.abs(state.szr) - Math.abs(state.lzr))
                    > Math.abs(state.lzr) * 1e-2)
            {
                return 0;
            }
            // Evaluate polynomial by quadratic synthetic division.
            var quadsdOutput = isc.Math._quadsd(state.nn, state.u, state.v, state.p);
            for (var i = state.nn; i--; ) {
                state.qp[i] = quadsdOutput.q[i];
            }
            state.a = quadsdOutput.a;
            state.b = quadsdOutput.b;

            var mp = (
                Math.abs(state.a - state.szr * state.b) +
                Math.abs(state.szi * state.b));
            // Compute a rigorous bound on the rounding error in evaluting p.
            var zm = Math.sqrt(Math.abs(state.v));
            var ee = Math.abs(state.qp[0]) * 2;
            var t = -state.szr * state.b;
            for (var i = 1; i < state.n; ++i) {
                ee = ee * zm + Math.abs(state.qp[i]);
            }
            ee = ee * zm + Math.abs(state.a + t);
            ee = (
                (5 * mre + 4 * are) * ee -
                (5 * mre + 2 * are) * (Math.abs(state.a + t) + Math.abs(state.b) * zm) +
                are * 2 * Math.abs(t));
            // Iteration has converged sufficiently if the polynomial value is less than 20 times
            // this bound.
            if (mp <= ee * 20) {
                return 2;
            }

            ++j;
            // Stop iteration after 20 steps.
            if (j > 20) {
                return 0;
            }
            if (!(j < 2 || relstp > 1e-2 || mp < omp || tried)) {
                // A cluster appears to be stalling the convergence.  Five fixed shift steps are
                // taken with a u,v close to the cluster.
                relstp = Math.sqrt(Math.max(eta, relstp));
                state.u -= state.u * relstp;
                state.v += state.v * relstp;
                var quadsdOutput = isc.Math._quadsd(state.nn, state.u, state.v, state.p);
                for (var i = state.nn; i--; ) {
                    state.qp[i] = quadsdOutput.q[i];
                }
                state.a = quadsdOutput.a;
                state.b = quadsdOutput.b;

                for (var i = 5; i--; ) {
                    isc.Math._nextk(state, isc.Math._calcsc(state, eta), eta);
                }
                tried = true;
                j = 0;
            }

            omp = mp;
            // Calculate next k polynomial and new u and v.
            isc.Math._nextk(state, isc.Math._calcsc(state, eta), eta);
            var newestOutput = isc.Math._newest(state, isc.Math._calcsc(state, eta));
            var ui = newestOutput.uu;
            var vi = newestOutput.vv;

            // If vi is zero the iteration is not converging.
            if (vi == 0) {
                return 0;
            }
            relstp = Math.abs((vi - state.v) / vi);
            state.u = ui;
            state.v = vi;
        }
    },


    _realit : function (state, sss, eta, are, mre) {

        var nm1 = state.n - 1;

        var s = sss;
        var nz = 0;
        var iflag = 0;

        for (var j = 0, omp = 0; true; ) {
            var pv = state.p[0];
            // Evaluate p at s.
            state.qp[0] = pv;
            for (var i = 1; i < state.nn; ++i) {
                pv = pv * s + state.p[i];
                state.qp[i] = pv;
            }
            var mp = Math.abs(pv);
            // Compute a rigorous bound on the error in evaluating p.
            var ms = Math.abs(s);
            var ee = mre / (are + mre) * Math.abs(state.qp[0]);
            for (var i = 1; i < state.nn; ++i) {
                ee = ee * ms + Math.abs(state.qp[i]);
            }
            // Iteration has converged sufficiently if the polynomial value is less than 20 times
            // this bound.
            if (mp <= ((are + mre) * ee - mre * mp) * 20) {
                nz = 1;
                state.szr = s;
                state.szi = 0;
                return { sss: sss, nz: nz, iflag: iflag };
            }

            ++j;
            // Stop iteration after 10 steps.
            if (j > 10) {
                return { sss: sss, nz: nz, iflag: iflag };
            }
            if (!(j < 2 || Math.abs(t) > Math.abs(s - t) * 1e-3 || mp <= omp)) {
                // A cluster of zeros near the real axis has been encountered.  Return with `iflag`
                // set to initiate a quadratic iteration.
                iflag = 1;
                sss = s;
                return { sss: sss, nz: nz, iflag: iflag };
            }

            // Return if the polynomial value has increased significantly.
            omp = mp;
            // Compute `t`, the next polynomial, and the new iterate.
            var kv = state.k[0];
            state.qk[0] = kv;
            for (var i = 1; i < state.n; ++i) {
                kv = kv * s + state.k[i];
                state.qk[i] = kv;
            }
            if (Math.abs(kv) <= Math.abs(state.k[state.n - 1]) * 10 * eta) {
                // Use unscaled form.
                state.k[0] = 0;
                for (var i = state.n; (--i) >= 1; ) {
                    state.k[i] = state.qk[i - 1];
                }
            } else {
                // Use the scaled form of the recurrence if the value of k at s is nonzero.
                var t = -pv / kv;
                state.k[0] = state.qp[0];
                for (var i = state.n; (--i) >= 1; ) {
                    state.k[i] = t * state.qk[i - 1] + state.qp[i];
                }
            }

            kv = state.k[0];
            for (var i = 1; i < state.n; ++i) {
                kv = kv * s + state.k[i];
            }
            var t = 0;
            if (Math.abs(kv) > Math.abs(state.k[state.n - 1]) * 10 * eta) {
                t = -pv / kv;
            }
            s += t;
        }
    },


    _calcsc : function (state, eta) {
        // Synthetic division of `k` by the quadratic `1,u,v`.
        var quadsdOutput = isc.Math._quadsd(state.n, state.u, state.v, state.k);
        for (var i = state.n; i--; ) {
            state.qk[i] = quadsdOutput.q[i];
        }
        state.c = quadsdOutput.a;
        state.d = quadsdOutput.b;

        var isType3 = !(
            Math.abs(state.c) > Math.abs(state.k[state.n - 1]) * 100 * eta ||
            Math.abs(state.d) > Math.abs(state.k[state.n - 2]) * 100 * eta);

        if (isType3) {
            // type=3 indicates the quadratic is almost a factor of k.
            return 3;
        } else if (Math.abs(state.d) < Math.abs(state.c)) {
            // type=1 indicates that all formulas are divided by c.
            state.e = state.a / state.c;
            state.f = state.d / state.c;
            state.g = state.u * state.e;
            state.h = state.v * state.b;
            state.a3 = state.a * state.e + (state.h / state.c + state.g) * state.b;
            state.a1 = state.b - state.a * (state.d / state.c);
            state.a7 = state.a + state.g * state.d + state.h * state.f;
            return 1;
        } else {
            // type=2 indicates that all formulas are divided by d.
            state.e = state.a / state.d;
            state.f = state.c / state.d;
            state.g = state.u * state.b;
            state.h = state.v * state.b;
            state.a3 = (state.a + state.g) * state.e + state.h * (state.b / state.d);
            state.a1 = state.b * state.f - state.a;
            state.a7 = (state.f + state.u) * state.a + state.h;
            return 2;
        }
    },


    _nextk : function (state, type, eta) {
        if (type == 3) {
            // Use unscaled form of the recurrence if type is 3.
            state.k[0] = state.k[1] = 0;
            for (var i = state.n; (--i) >= 2; ) {
                state.k[i] = state.qk[i - 2];
            }
        } else {
            var temp = (type == 1 ? state.b : state.a);
            if (Math.abs(state.a1) > Math.abs(temp) * eta * 10) {
                // Use scaled form of the recurrence.
                state.a7 /= state.a1;
                state.a3 /= state.a1;
                state.k[0] = state.qp[0];
                state.k[1] = state.qp[1] - state.a7 * state.qp[0];
                for (var i = state.n; (--i) >= 2; ) {
                    state.k[i] = (
                        state.a3 * state.qk[i - 2] - state.a7 * state.qp[i - 1] + state.qp[i]);
                }
            } else {
                // If a1 is nearly zero then use a special form of the recurrence.
                state.k[0] = 0;
                state.k[1] = -state.a7 * state.qp[0];
                for (var i = state.n; (--i) >= 2; ) {
                    state.k[i] = state.a3 * state.qk[i - 2] - state.a7 * state.qp[i - 1];
                }
            }
        }
    },


    _newest : function (state, type) {
        if (type != 3) {
            var a4, a5;
            if (type == 2) {
                a4 = (state.a + state.g) * state.f + state.h;
                a5 = (state.f + state.u) * state.c + state.v * state.d;
            } else {
                a4 = state.a + state.u * state.b + state.h * state.f;
                a5 = state.c + (state.u + state.v * state.f) * state.d;
            }
            // Evaluate new quadratic coefficients.
            var b1 = -state.k[state.n - 1] / state.p[state.nn - 1];
            var b2 = -(state.k[state.n - 2] + b1 * state.p[state.n - 1]) / state.p[state.nn - 1];
            var c1 = state.v * b2 * state.a1;
            var c2 = b1 * state.a7;
            var c3 = b1 * b1 * state.a3;
            var c4 = c1 - c2 - c3;
            var temp = a5 + b1 * a4 - c4;
            if (temp != 0) {
                var uu = state.u - (state.u * (c3 + c2) + state.v *
                                    (b1 * state.a1 + b2 * state.a7)) / temp;
                var vv = state.v * (c4 / temp + 1);
                return { uu: uu, vv: vv };
            }
        }
        // If type=3 the quadratic is zeroed.
        return { uu: 0, vv: 0 };
    },


    _quadsd : function (nn, u, v, p) {
        var q = new Array(nn),
            b = q[0] = p[0],
            a = q[1] = p[1] - u * b;
        for (var i = 2; i < nn; ++i) {
            var c = p[i] - u * a - v * b;
            q[i] = c;
            b = a;
            a = c;
        }

        return { q: q, a: a, b: b };
    },


    _quad : function (a, b1, c) {

        var sr = 0, si = 0, lr = 0, li = 0;

        if (a == 0) {
            sr = 0;
            if (b1 != 0) {
                sr = -c / b1;
            }
            lr = 0;

            si = 0;
            li = 0;
            return { sr: sr, si: si, lr: lr, li: li };
        } else if (c == 0) {
            sr = 0;
            lr = -b1 / a;

            si = 0;
            li = 0;
            return { sr: sr, si: si, lr: lr, li: li };
        }

        // Compute discriminant avoiding overflow.
        var b = b1 / 2, d = 0, e = 0;
        if (Math.abs(b) < Math.abs(c)) {
            e = a;
            if (c < 0) {
                e = -a;
            }
            e = b * (b / Math.abs(c)) - e;
            d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));
        } else {
            e = 1 - a / b * (c / b);
            d = Math.sqrt(Math.abs(e)) * Math.abs(b);
        }
        if (e < 0) {
            // complex conjugate zeros
            sr = -b / a;
            lr = sr;
            si = Math.abs(d / a);
            li = -si;
            return { sr: sr, si: si, lr: lr, li: li };
        } else {
            // real zeros
            if (b >= 0) {
                d = -d;
            }
            lr = (-b + d) / a;
            sr = 0;
            if (lr != 0) {
                sr = c / lr / a;
            }
            si = 0;
            li = 0;
            return { sr: sr, si: si, lr: lr, li: li };
        }
    },

    _gcd : function (a, b) {

        if (a < 0) {
            a = -a;
        }
        if (b < 0) {
            b = -b;
        }
        if (a == 0) {
            return b;
        } else if (b == 0) {
            return a;
        } else {
            var r0 = a, r1 = b, r2 = 0;
            while ((r2 = r0 % r1) != 0) {
                r0 = r1;
                r1 = r2;
            }
            return r1;
        }
    },

    _isAnAffineTransformDecomposition : function (obj) {
        return (
            isc.isAn.Object(obj) &&
            isc.isAn.Array(obj.translate) && obj.translate.length == 2 &&
            isc.isA.Number(obj.translate[0]) && isc.isA.Number(obj.translate[1]) &&
            isc.isAn.Array(obj.scale) && obj.scale.length == 2 &&
            isc.isA.Number(obj.scale[0]) && isc.isA.Number(obj.scale[1]) &&
            isc.isA.Number(obj.xShearFactor) &&
            isc.isA.Number(obj.yShearFactor) &&
            isc.isA.Number(obj.rotation) &&
            isc.isAn.Array(obj.rotationCenter) && obj.rotationCenter.length == 2 &&
            isc.isA.Number(obj.rotationCenter[0]) && isc.isA.Number(obj.rotationCenter[1]));
    },

    //> @object AffineTransformDecomposition
    // An object containing properties defining a translation, scale, x-shear, y-shear, and
    // rotation transforms, to be concatenated in that order to construct the equivalent
    // +link{class:AffineTransform,AffineTransform}.
    // @see affineTransform.decompose()
    // @treeLocation Client Reference/Drawing/AffineTransform
    // @visibility customTransform
    //<
    //> @attr affineTransformDecomposition.translate (Array[] of double : [0.0, 0.0] : IRW)
    // Array holds two values representing translation along the x and y dimensions.
    // @visibility customTransform
    //<
    //> @attr affineTransformDecomposition.scale (Array[] of double : [1.0, 1.0] : IRW)
    // Array holds 2 values representing scaling along x and y dimensions.
    // @visibility customTransform
    //<
    //> @attr affineTransformDecomposition.xShearFactor (double : 0.0 : IRW)
    // The slope of an x-shearing transformation.  The shear moves points along the x-axis a
    // distance that is proportional to the initial y-coordinate of the point.
    // @visibility customTransform
    //<
    //> @attr affineTransformDecomposition.yShearFactor (double : 0.0 : IRW)
    // The slope of a y-shearing transformation.  The shear moves points along the y-axis a
    // distance that is proportional to the initial x-coordinate of the point.
    // @visibility customTransform
    //<
    //> @attr affineTransformDecomposition.rotation (double : 0.0 : IRW)
    // Rotation in degrees about the +link{rotationCenter,center point}.
    // The positive direction is clockwise.
    // @visibility customTransform
    //<
    //> @attr affineTransformDecomposition.rotationCenter (Point : [0.0, 0.0] : IRW)
    // The center point of +link{rotation,rotation}.
    // @visibility customTransform
    //<

    // A constructor function for AffineTransformDecomposition objects.
    _affineTransformDecomposition : function (
            translate, scale, xShearFactor, yShearFactor, rotation, rotationCenter)
    {
        this.translate = translate;
        this.scale = scale;
        this.xShearFactor = xShearFactor;
        this.yShearFactor = yShearFactor;
        this.rotation = rotation;
        this.rotationCenter = rotationCenter;

    }
};

//> @class AffineTransform
// An AffineTransform represents a 2-dimensional affine transformation function given by the
// following matrix formula:
// <pre>
// [ m00, m01, m02 ]   [ x ]   [ m00 * x + m01 * y + m02 ]
// [ m10, m11, m12 ] * [ y ] = [ m10 * x + m11 * y + m12 ]
// [   0,   0,   1 ]   [ 1 ]   [                       1 ]
// </pre>
// where the m<sub>ij</sub> are properties of the AffineTransform.  The last row of the matrix
// (0,0,1) and the last entry (1) in the input and output vectors is considered implicit.  No
// extra space is used to store the last rows, and the AffineTransform only needs `x` and `y`
// in a call to +link{affineTransform.transform(),transform()}.
// <p>
// AffineTransform offers the typical means of creating, combining, and manipulating 2D affine
// transformations.  An AffineTransform can also be
// +link{affineTransform.decompose(),decomposed} into the product of basic translation, scale,
// x-shear, y-shear, and rotation transforms.  The order of matrices in this matrix
// decomposition is the same order used to define the +link{class:DrawPane,local transforms}
// of +link{class:DrawItem,DrawItems}.  The decomposition can be recomposed into a new
// AffineTransform by calling +link{classMethod:AffineTransform.recompose()}.
// @treeLocation Client Reference/Drawing
// @visibility customTransform
//<

isc.defineClass("AffineTransform").addClassProperties({
    //> @classMethod affineTransform.getRotateTransform()
    // Returns an AffineTransform that rotates points by the given angle about a center point.
    // @param angle (double) A rotation angle in degrees.  The positive direction is clockwise.
    // @param [center] (Point) An optional point that is fixed in the rotation (default (0, 0)).
    // @return (AffineTransform) the rotation transform
    // @visibility customTransform
    //<

    getRotateTransform : function (angle, cx, cy) {
        if (isc.isAn.Array(cx)) {
            cy = cx[1]; cx = cx[0];
        }
        if (!(isc.isA.Number(cx) && isc.isA.Number(cy))) {
            cx = cy = 0;
        }
        var c = isc.Math.cosdeg(angle),
            s = isc.Math.sindeg(angle);
        return isc.AffineTransform.create(
            c, -s, -c * cx + s * cy + cx,
            s, c, -s * cx - c * cy + cy);
    },

    //> @classMethod affineTransform.getTranslateTransform()
    // Returns an AffineTransform representing a translation.
    // @param dx (double) distance that the translation moves points along the x-axis
    // @param dy (double) distance that the translation moves points along the y-axis
    // @return (AffineTransform) the translation transform
    // @visibility customTransform
    //<
    getTranslateTransform : function (dx, dy) {
        if (isc.isAn.Array(dx)) {
            dy = dx[1]; dx = dx[0];
        }
        if (!(isc.isA.Number(dx) && isc.isA.Number(dy))) {
            dx = dy = 0;
        }
        return isc.AffineTransform.create(1, 0, dx, 0, 1, dy);
    },

    // An internal singleton used to avoid wasting memory storing multiple copies of a trivial
    // transform:
    _identityTransform: isc.AffineTransform.create(),
    _getIdentityTransform : function () {
        return isc.AffineTransform._identityTransform;
    },


    _transformDecomposition: {
        dx: 0, dy: 0, sx: 0, sy: 0, kx: 0, ky: 0, theta: 0, cx: 0, cy: 0,
        h00: 0, h01: 0, h02: 0, h10: 0, h11: 0, h12: 0
    },
    _decomposeTransform : function (transform, cx, cy) {
        var m00 = transform.m00,
            m01 = transform.m01,
            m02 = transform.m02,
            m10 = transform.m10,
            m11 = transform.m11,
            m12 = transform.m12,
            polarDecomp = isc.AffineTransform._polarDecomposition(m00, m01, m10, m11),
            output = isc.AffineTransform._transformDecomposition;

        if (polarDecomp.zeroMatrix) {
            output.sx = output.sy = output.kx = output.ky = output.theta = 0;
            output.dx = output.h02 = m02;
            output.dy = output.h12 = m12;
            output.h00 = output.h01 = output.h10 = output.h11;
            return output;
        }
        var reflected = polarDecomp.reflected,
            theta = polarDecomp.theta,
            c = polarDecomp.cos, s = polarDecomp.sin,
            s00 = polarDecomp.s00, s01 = polarDecomp.s01, s10 = polarDecomp.s10, s11 = polarDecomp.s11,
            detS = (s00 * s11 - s01 * s10);

        // Calculate parameters sx, sy, kx, ky, dx, and dy.
        var sx = 0, sy = 0, kx = 0, ky = 0, dx = 0, dy = 0;
        if (reflected) {
            var c2ms2 = Math.cos(2 * theta),
                twocs = Math.sin(2 * theta);



            // alpha = s * (2 * c - 1) = 2 * c * s - s
            var alpha = twocs - s,
                // beta = ((c + 1) * s^2 + (c - 1) * c^2)
                //      = c * (s^2 + c^2) + (s^2 - c^2)
                //      = c - (c^2 - s^2)
                beta = c - c2ms2,
                gamma = (-cx * beta + cy * alpha),
                delta = (cx * alpha + cy * beta);

            dx = m02 - (s00 * gamma + s01 * delta);
            dy = m12 - (s01 * gamma + s11 * delta);

            sy = twocs * s01 - c2ms2 * s11;

            ky = (c2ms2 * s01 + twocs * s11) / sy;
            sx = -detS / sy;
            kx = (twocs * s00 - c2ms2 * s01) / sx;

        } else {
            var alpha = (cy * s + cx * (1 - c)),
                beta = (-cx * s + cy * (1 - c));
            dx = m02 - (alpha * s00 + beta * s01);
            dy = m12 - (alpha * s01 + beta * s11);

            if (s00 == 0 || s11 == 0 || s01 == 0) {

                sx = s00;
                sy = s11;
                kx = ky = 0;
            } else if (detS == 0) {

                sx = s00;
                sy = s11;
                kx = ky = 0;
            } else {
                // `s00`, `s11`, and `detS` are all greater than zero.
                sx = detS / s11;
                sy = s11;
                kx = s01 / sx;
                ky = s01 / sy;
            }
        }



        output.dx = dx;
        output.dy = dy;
        output.sx = sx;
        output.sy = sy;
        output.kx = kx;
        output.ky = ky;
        output.theta = theta;
        output.cx = cx;
        output.cy = cy;
        output.h00 = polarDecomp.h00;
        output.h01 = polarDecomp.h01;
        output.h10 = (reflected ? -polarDecomp.h10 : polarDecomp.h10);
        output.h11 = (reflected ? -polarDecomp.h11 : polarDecomp.h11);
        output.h02 = m02 * c + m12 * s;
        output.h12 = -m02 * s + m12 * c;

        return output;
    },


    _polarDecompositionOutput: {
        theta: 0,
        cos: 0, sin: 0,
        u00: 0, u01: 0, u10: 0, u11: 0,
        h00: 0, h01: 0, h10: 0, h11: 0,
        s00: 0, s01: 0, s10: 0, s11: 0,
        reflected: false,
        zeroMatrix: false
    },
    _polarDecomposition : function (m00, m01, m10, m11) {
        var output = isc.AffineTransform._polarDecompositionOutput;
        if (m00 == 0 && m01 == 0 && m10 == 0 && m11 == 0) {
            output.theta = 0;
            output.u00 = output.u11 = output.cos = 1;
            output.u01 = output.u10 = output.sin = 0;
            output.h00 = output.h01 = output.h10 = output.h11 = 0;
            output.s00 = output.s01 = output.s10 = output.s11 = 0;
            output.reflected = false;
            output.zeroMatrix = true;
            return output;
        }

        var epsilon = 1e-9,
            det = m00 * m11 - m01 * m10,
            singular = (Math.abs(det) < epsilon);

        var absDet = Math.abs(det),
            signDet = (det < 0 ? -1 : 1),
            u00 = m00 + signDet * m11,
            u01 = m01 - signDet * m10,
            u10 = m10 - signDet * m01,
            u11 = m11 + signDet * m00,
            detU = u00 * u11 - u01 * u10,
            gamma = Math.sqrt(Math.abs(detU));

        var reflected = output.reflected = (detU < 0),
            theta = output.theta = Math.atan2(u10, u00);
        u00 = output.u00 = u00 / gamma;
        u01 = output.u01 = u01 / gamma;
        u10 = output.u10 = u10 / gamma;
        u11 = output.u11 = u11 / gamma;



        // H = (A^t * A + |det A| * I) / gamma
        var h00 = output.h00 = (m00 * m00 + m10 * m10 + absDet) / gamma,
            h01 = output.h01 = (m00 * m01 + m10 * m11) / gamma,
            h10 = output.h10 = h01,
            h11 = output.h11 = (m01 * m01 + m11 * m11 + absDet) / gamma;

        // S = U * H * U^-1
        var c = output.cos = Math.cos(theta),
            s = output.sin = Math.sin(theta),
            c2 = c * c,
            s2 = s * s,
            // c^2 - s^2 = cos(2 * theta)
            c2ms2 = Math.cos(2 * theta),
            // 2 * c * s = sin(2 * theta)
            twocs = Math.sin(2 * theta),
            s00 = 0, s01 = 0, s10 = 0, s11 = 0;
        if (reflected) {
            s00 = c2 * h00 + twocs * h01 + s2 * h11;
            s01 = -c2ms2 * h01 + c * s * (h00 - h11);
            s10 = s01;
            s11 = c2 * h11 - twocs * h01 + s2 * h00;
        } else {
            s00 = c2 * h00 - twocs * h01 + s2 * h11;
            s01 = c2ms2 * h01 + c * s * (h00 - h11);
            s10 = s01;
            s11 = c2 * h11 + twocs * h01 + s2 * h00;
        }
        var detS = (s00 * s11 - s01 * s10);



        output.s00 = s00;
        output.s01 = s01;
        output.s10 = s10;
        output.s11 = s11;
        return output;
    },

    //> @classMethod affineTransform.recompose()
    // This method is the opposite of +link{affineTransform.decompose()} in that it
    // reconstructs the AffineTransformation from its matrix decomposition.
    // @param decomp (AffineTransformDecomposition) the matrix decomposition
    // @return (AffineTransform) the equivalent affine transformation
    // @visibility customTransform
    //<
    recompose : function (decomp, output) {

        if (output == null) {
            output = isc.AffineTransform.create();
        }
        if (decomp == null) {
            return;
        }

        var dx = 0, dy = 0, sx = 1, sy = 1, kx = 0, ky = 0, theta = 0, cx = 0, cy = 0;
        if (isc.isAn.Array(decomp.translate)) {
            if (isc.isA.Number(decomp.translate[0])) {
                dx = decomp.translate[0];
            }
            if (isc.isA.Number(decomp.translate[1])) {
                dy = decomp.translate[1];
            }
        }
        if (isc.isAn.Array(decomp.scale)) {
            if (isc.isA.Number(decomp.scale[0])) {
                sx = decomp.scale[0];
            }
            if (isc.isA.Number(decomp.scale[1])) {
                sy = decomp.scale[1];
            }
        }
        if (isc.isA.Number(decomp.xShearFactor)) {
            kx = decomp.xShearFactor;
        }
        if (isc.isA.Number(decomp.yShearFactor)) {
            ky = decomp.yShearFactor;
        }
        if (isc.isA.Number(decomp.rotation)) {
            theta = decomp.rotation * Math.PI / 180;
        }
        if (isc.isAn.Array(decomp.rotationCenter)) {
            if (isc.isA.Number(decomp.rotationCenter[0])) {
                cx = decomp.rotationCenter[0];
            }
            if (isc.isA.Number(decomp.rotationCenter[1])) {
                cy = decomp.rotationCenter[1];
            }
        }

        var sin = Math.sin(theta), cos = Math.cos(theta),
            sxsin = sx * sin, sxcos = sx * cos,
            sysin = sy * sin, sycos = sy * cos,
            kxkyp1 = kx * ky + 1,
            kycymcx = ky * cy - cx,
            kycxpcy = ky * cx + cy;

        output.setTransform(
            kx * sxsin + kxkyp1 * sxcos,
            -kxkyp1 * sxsin + kx * sxcos,
            (kx * kycymcx + cy) * sxsin + (kx * kycxpcy + cx) * sx * (1 - cos) + dx,
            sysin + ky * sycos,
            sycos - ky * sysin,
            kycymcx * sysin + kycxpcy * sy * (1 - cos) + dy);
        return output;
    }
});

isc.AffineTransform.addProperties({
    // Start with the identity transform.
    m00: 1, m01: 0, m02: 0,
    m10: 0, m11: 1, m12: 0,

    addPropertiesOnCreate: false,
    init : function (m00, m01, m02, m10, m11, m12) {
        if (
            isc.isA.Number(m00) && isc.isA.Number(m01) && isc.isA.Number(m02) &&
            isc.isA.Number(m10) && isc.isA.Number(m11) && isc.isA.Number(m12))
        {
            this.m00 = m00;
            this.m01 = m01;
            this.m02 = m02;
            this.m10 = m10;
            this.m11 = m11;
            this.m12 = m12;
        } else if (isc.Math._isAnAffineTransformDecomposition(m00)) {
            return isc.AffineTransform.recompose(m00);
        } else {
            var numArgs = arguments.length;
            for (var i = 0; i < numArgs; ++i) {
                var arg = arguments[i];
                if (isc.isAn.Object(arg)) {
                    isc.addProperties(this, arg);
                }
            }
        }
        return this.Super("init", arguments);
    },

    duplicate : function () {
        return isc.AffineTransform.create(
            this.m00, this.m01, this.m02, this.m10, this.m11, this.m12);
    },

    _copy : function (output) {

        output.setTransform(this.m00, this.m01, this.m02, this.m10, this.m11, this.m12);
        return output;
    },

    //> @method affineTransform.getDeterminant()
    // Returns the <a href="http://en.wikipedia.org/wiki/Determinant">determinant</a> of this
    // transform's matrix.
    // @return (double) the determinant of the matrix
    // @visibility customTransform
    //<
    getDeterminant : function () {
        return this.m00 * this.m11 - this.m10 * this.m01;
    },

    //> @method affineTransform.getInverse()
    // Returns the <a href="http://en.wikipedia.org/wiki/Invertible_matrix">inverse matrix</a>
    // to this transform's matrix, or <code>null</code> if the inverse does not exist.
    // @return (AffineTransform) a new AffineTransform storing the inverse transformation
    // @visibility customTransform
    //<
    getInverse : function (output) {

        var det = this.getDeterminant(),
            isInvertible = isc.isA.Number(det) && det != 0;

        if (!isInvertible) return null;

        if (output == null) {
            output = isc.AffineTransform.create();
        }
        output.setTransform(
            this.m11 / det,
            -this.m01 / det,
            (this.m01 * this.m12 - this.m11 * this.m02) / det,
            -this.m10 / det,
            this.m00 / det,
            (this.m10 * this.m02 - this.m00 * this.m12) / det);
        return output;
    },

    //> @method affineTransform.leftMultiply()
    // Multiplies the matrix of this transformation by the matrix of another transformation,
    // on the left.  The resulting transformation is saved back onto this AffineTransform
    // object.
    // <p>
    // The matrix formula is as follows:
    // <pre>
    //                    [ t00, t01, t02 ]   [ m00, m01, m02 ]
    // transform * this = [ t10, t11, t12 ] * [ m10, m11, m12 ] =
    //                    [   0,   0,   1 ]   [   0,   0,   1 ]
    //
    //     [ t00 * m00 + t01 * m10, t00 * m01 + t01 * m11, t00 * m02 + t01 * m12 + t02 ]
    //     [ t10 * m00 + t11 * m10, t10 * m01 + t11 * m11, t10 * m02 + t11 * m12 + t12 ]
    //     [                     0,                     0,                           1 ]
    // <pre>
    // @param transform (AffineTransform)
    // @visibility customTransform
    //<
    leftMultiply : function (transform) {

        var m0 = this.m00,
            m1 = this.m10;
        this.m00 = transform.m00 * m0 + transform.m01 * m1;
        this.m10 = transform.m10 * m0 + transform.m11 * m1;

        m0 = this.m01;
        m1 = this.m11;
        this.m01 = transform.m00 * m0 + transform.m01 * m1;
        this.m11 = transform.m10 * m0 + transform.m11 * m1;

        m0 = this.m02;
        m1 = this.m12;
        this.m02 = transform.m00 * m0 + transform.m01 * m1 + transform.m02;
        this.m12 = transform.m10 * m0 + transform.m11 * m1 + transform.m12;
        return this;
    },

    //> @method affineTransform.rightMultiply()
    // Multiplies the matrix of this transformation by the matrix of another transformation,
    // on the right.  The resulting transformation is saved back onto this AffineTransform
    // object.
    // <p>
    // The matrix formula is as follows:
    // <pre>
    //                    [ m00, m01, m02 ]   [ t00, t01, t02 ]
    // this * transform = [ m10, m11, m12 ] * [ t10, t11, t12 ] =
    //                    [   0,   0,   1 ]   [   0,   0,   1 ]
    //
    //      [ m00 * t00 + m01 * t10, m00 * t01 + m01 * t11, m00 * t02 + m01 * t12 + m02 ]
    //      [ m10 * t00 + m11 * t10, m10 * t01 + m11 * t11, m10 * t02 + m11 * t12 + m12 ]
    //      [                     0,                     0,                           1 ]
    // </pre>
    // @param transform (AffineTransform)
    // @visibility customTransform
    //<
    rightMultiply : function (transform) {

        var mx = this.m00,
            my = this.m01;
        this.m00 = mx * transform.m00 + my * transform.m10;
        this.m01 = mx * transform.m01 + my * transform.m11;
        this.m02 = mx * transform.m02 + my * transform.m12 + this.m02;

        mx = this.m10;
        my = this.m11;
        this.m10 = mx * transform.m00 + my * transform.m10;
        this.m11 = mx * transform.m01 + my * transform.m11;
        this.m12 = mx * transform.m02 + my * transform.m12 + this.m12;
        return this;
    },

    //> @method affineTransform.preRotate()
    // Left-multiplies a rotation matrix onto the matrix of this affine transform.
    // @param angle (double) the angle in degrees
    // @param [cx] (double) X coordinate of the center of rotation
    // @param [cy] (double) Y coordinate of the center of rotation
    // @visibility customTransform
    //<
    preRotate : function (angle, cx, cy) {
        if (isc.isAn.Array(cx)) {
            cy = cx[1]; cx = cx[0];
        }
        if (!(isc.isA.Number(cx) && isc.isA.Number(cy))) {
            cx = cy = 0;
        }
        return this.leftMultiply(isc.AffineTransform.getRotateTransform(angle, cx, cy));
    },

    //> @method affineTransform.rotate()
    // Adds a rotation transform to this affine transform.
    // @param angle (double) the angle in degrees.
    // @param [cx] (double) X coordinate of the center of rotation.
    // @param [cy] (double) Y coordinate of the center of rotation.
    // @visibility customTransform
    //<
    rotate : function (angle, cx, cy) {
        if (isc.isAn.Array(cx)) {
            cy = cx[1]; cx = cx[0];
        }
        if (!(isc.isA.Number(cx) && isc.isA.Number(cy))) {
            cx = cy = 0;
        }
        return this.rightMultiply(isc.AffineTransform.getRotateTransform(angle, cx, cy));
    },

    //> @method affineTransform.preScale()
    // Left-multiplies a scaling matrix onto the matrix of this affine transform:
    // <pre>
    // [ sx,  0, 0 ]   [ m00, m01, m02 ]   [ sx * m00, sx * m01, sx * m02 ]
    // [  0, sy, 0 ] * [ m10, m11, m12 ] = [ sy * m10, sy * m11, sy * m12 ]
    // [  0,  0, 1 ]   [   0,   0,   1 ]   [        0,        0,        1 ]
    // </pre>
    // @param sx (double) the factor by which points are scaled along the x-axis
    // @param sy (double) the factor by which points are scaled along the y-axis
    // @visibility customTransform
    //<
    preScale : function (sx, sy) {

        this.m00 *= sx; this.m01 *= sx; this.m02 *= sx;
        this.m10 *= sy; this.m11 *= sy; this.m12 *= sy;
        return this;
    },

    //> @method affineTransform.scale()
    // Adds a scaling transform to this affine transform:
    // <pre>
    // [ m00, m01, m02 ]   [ sx,  0, 0 ]   [ m00 * sx, m01 * sy, m02 ]
    // [ m10, m11, m12 ] * [  0, sy, 0 ] = [ m10 * sx, m11 * sy, m12 ]
    // [   0,   0,   1 ]   [  0,  0, 1 ]   [        0,        0,   1 ]
    // </pre>
    // @param sx (double) the factor by which points are scaled along the x-axis
    // @param sy (double) the factor by which points are scaled along the y-axis
    // @visibility customTransform
    //<
    scale : function (sx, sy) {

        this.m00 *= sx; this.m01 *= sy;
        this.m10 *= sx; this.m11 *= sy;
        return this;
    },

    //> @method affineTransform.preShear()
    // Left-multiplies a shearing transform onto the matrix of this affine transform that
    // simultaneously applies shear in the x- and y-directions:
    // <pre>
    // [  1, kx, 0 ]   [ m00, m01, m02 ]   [ kx * m10 + m00, kx * m11 + m01, kx * m12 + m02 ]
    // [ ky,  1, 0 ] * [ m10, m11, m12 ] = [ ky * m00 + m10, ky * m01 + m11, ky * m02 + m12 ]
    // [  0,  0, 1 ]   [   0,   0,   1 ]   [              0,              0,              1 ]
    // </pre>
    // @param kx (double) the slope of the x-shear
    // @param ky (double) the slope of the y-shear
    // @visibility customTransform
    //<
    preShear : function (kx, ky) {

        var m00 = this.m00, m01 = this.m01, m02 = this.m02;
        this.m00 += kx * this.m10;
        this.m01 += kx * this.m11;
        this.m02 += kx * this.m12;
        this.m10 += ky * m00;
        this.m11 += ky * m01;
        this.m12 += ky * m02;
        return this;
    },

    //> @method affineTransform.shear()
    // Adds a shearing transform to this affine transform that simultaneously shifts points
    // along the x-axis a distance proportional to their y-coordinates and shifts along the
    // y-axis a distance proportional to their x-coordinates:
    // <pre>
    // [ m00, m01, m02 ]   [  1, kx, 0 ]   [ ky * m01 + m00, kx * m00 + m01, m02 ]
    // [ m10, m11, m12 ] * [ ky,  1, 0 ] = [ ky * m11 + m10, kx * m10 + m11, m12 ]
    // [   0,   0,   1 ]   [  0,  0, 1 ]   [              0,              0,   1 ]
    // </pre>
    // @param kx (double) the slope of the x-shear
    // @param ky (double) the slope of the y-shear
    // @visibility customTransform
    //<
    shear : function (kx, ky) {

        var m00 = this.m00, m10 = this.m10;
        this.m00 += ky * this.m01;
        this.m01 += kx * m00;
        this.m10 += ky * this.m11;
        this.m11 += kx * m10;
        return this;
    },

    //> @method affineTransform.preTranslate()
    // Left-multiplies a translation transform onto the matrix of this affine transform:
    // <pre>
    // [ 1, 0, dx ]   [m00, m01, m02 ]   [ m00, m01, m02 + dx ]
    // [ 0, 1, dy ] * [m10, m11, m12 ] = [ m10, m11, m12 + dy ]
    // [ 0, 0,  1 ]   [  0,   0,   1 ]   [   0,   0,        1 ]
    // </pre>
    // @param dx (double) the distance by which points are translated along the x-axis
    // @param dy (double) the distance by which points are translated along the y-axis
    // @visibility customTransform
    //<
    preTranslate : function (dx, dy) {

        this.m02 += dx;
        this.m12 += dy;
        return this;
    },

    //> @method affineTransform.translate()
    // Adds a translation transform to this affine transform:
    // <pre>
    // [ m00, m01, m02 ]   [ 1, 0, dx ]   [ m00, m01, m00 * dx + m01 * dy + m02 ]
    // [ m10, m11, m12 ] * [ 0, 1, dy ] = [ m10, m11, m10 * dx + m11 * dy + m12 ]
    // [   0,   0,   1 ]   [ 0, 0,  1 ]   [   0,   0,                         1 ]
    // </pre>
    // @param dx (double) the distance by which points are translated along the x-axis
    // @param dy (double) the distance by which points are translated along the y-axis
    // @visibility customTransform
    //<
    translate : function (dx, dy) {

        this.m02 += this.m00 * dx + this.m01 * dy;
        this.m12 += this.m10 * dx + this.m11 * dy;
        return this;
    },

    //> @method affineTransform.preXShear()
    // Left-multiplies a shearing transform onto the matrix of this affine transform that
    // shifts points along the x-axis a distance proportional to their y-coordinates:
    // <pre>
    // [ 1, kx, 0 ]   [ m00, m01, m02 ]   [ kx * m10 + m00, kx * m11 + m01, kx * m12 + m02 ]
    // [ 0,  1, 0 ] * [ m10, m11, m12 ] = [            m10,            m11,            m12 ]
    // [ 0,  0, 1 ]   [   0,   0,   1 ]   [              0,              0,              1 ]
    // </pre>
    // @param kx (double) the slope of the x-shearing transformation
    // @visibility customTransform
    //<
    preXShear : function (kx) {

        this.m00 += kx * this.m10;
        this.m01 += kx * this.m11;
        this.m02 += kx * this.m12;
        return this;
    },

    //> @method affineTransform.xShear()
    // Adds a shearing transform to this affine transform that shifts points along the x-axis
    // a distance proportional to their y-coordinates:
    // <pre>
    // [ m00, m01, m02 ]   [ 1, kx, 0 ]   [ m00, m01 + kx * m00, m02 ]
    // [ m10, m11, m12 ] * [ 0,  1, 0 ] = [ m10, m11 + kx * m10, m12 ]
    // [   0,   0,   1 ]   [ 0,  0, 1 ]   [   0,              0,   1 ]
    // </pre>
    // @param kx (double) the slope of the x-shearing transformation
    // @visibility customTransform
    //<
    xShear : function (kx) {

        this.m01 += kx * this.m00;
        this.m11 += kx * this.m10;
        return this;
    },

    //> @method affineTransform.preYShear()
    // Left-multiplies a shearing transform onto the matrix of this affine transform that
    // shifts points along the y-axis a distance proportional to their x-coordinates:
    // <pre>
    // [  1, 0, 0 ]   [ m00, m01, m02 ]   [            m00,            m01,            m02 ]
    // [ ky, 1, 0 ] * [ m10, m11, m12 ] = [ ky * m00 + m10, ky * m01 + m11, ky * m02 + m12 ]
    // [  0, 0, 1 ]   [   0,   0,   1 ]   [              0,              0,              1 ]
    // </pre>
    // @param ky (double) the slope of the y-shearing transformation
    // @visibility customTransform
    //<
    preYShear : function (ky) {

        this.m10 += ky * this.m00;
        this.m11 += ky * this.m01;
        this.m12 += ky * this.m02;
        return this;
    },

    //> @method affineTransform.yShear()
    // Adds a shearing transform to this affine transform that shifts points along the y-axis
    // a distance proportional to their x-coordinates:
    // <pre>
    // [ m00, m01, m02 ]   [  1, 0, 0 ]   [ ky * m01 + m00, m01, m02 ]
    // [ m10, m11, m12 ] * [ ky, 1, 0 ] = [ ky * m11 + m10, m11, m12 ]
    // [   0,   0,   1 ]   [  0,  , 1 ]   [              0,   0,   1 ]
    // </pre>
    // @param ky (double) the slope of the y-shearing transformation
    // @visibility customTransform
    //<
    yShear : function (ky) {

        this.m00 += ky * this.m01;
        this.m10 += ky * this.m11;
        return this;
    },

    //> @method affineTransform.transform()
    // Applies this affine transform to the point <code>(v0,v1)</code> and returns the
    // transformed point:
    // <pre>
    // [ m00, m01, m02 ]   [ v0 ]   [ m00 * v0 + m01 * v1 + m02 ]
    // [ m10, m11, m12 ] * [ v1 ] = [ m10 * v0 + m11 * v1 + m12 ]
    // [   0,   0,   1 ]   [  1 ]   [                         1 ]
    // </pre>
    // @param v0 (double) the x-coordinate of the point to be transformed
    // @param v1 (double) the y-coordinate of the point to be transformed
    // @return (Point) the transformed point
    // @visibility customTransform
    //<
    transform : function (v0, v1, output) {
        if (isc.isAn.Array(v0)) {
            output = v1; v1 = v0[1]; v0 = v0[0];
        }
        if (!isc.isAn.Array(output)) {
            output = new Array(2);
        }
        output[0] = this.m00 * v0 + this.m01 * v1 + this.m02;
        output[1] = this.m10 * v0 + this.m11 * v1 + this.m12;
        return output;
    },

    //> @method affineTransform.setTransform()
    // Sets the matrix of this affine transform to the matrix specified by six numbers.
    // @param m00 (double) the (0,0)-entry of the matrix
    // @param m01 (double) the (0,1)-entry of the matrix
    // @param m02 (double) the (0,2)-entry of the matrix
    // @param m10 (double) the (1,0)-entry of the matrix
    // @param m11 (double) the (1,1)-entry of the matrix
    // @param m12 (double) the (1,2)-entry of the matrix
    // @visibility customTransform
    //<
    setTransform : function (m00, m01, m02, m10, m11, m12) {
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m10 = m10;
        this.m11 = m11;
        this.m12 = m12;
    },

    //> @method affineTransform.decompose()
    // Decomposes the AffineTransform into the product of translation, scale, x-shear, y-shear,
    // and rotation transforms:
    // <pre>
    // [ m00, m01, m02 ]
    // [ m10, m11, m12 ] =
    // [   0,   0,   1 ]
    //
    //      [ 1, 0, translate[0] ]   [ scale[0],        0, 0 ]   [ 1, xShearFactor, 0 ]
    //      [ 0, 1, translate[1] ] * [        0, scale[1], 0 ] * [ 0,            1, 0 ] *
    //      [ 0, 0,            1 ]   [        0,        0, 1 ]   [ 0,            0, 1 ]
    //
    //          [            1, 0, 0 ]
    //          [ yShearFactor, 1, 0 ] * R
    //          [            0, 0, 1 ]
    // </pre>
    // where the rotation matrix <code>R</code> produces rotation about an optional center
    // point (default (0, 0)):
    // <pre>
    //     [ 1, 0, center[0] ]   [ cos(theta), -sin(theta), 0 ]   [ 1, 0, -center[0] ]
    // R = [ 0, 1, center[1] ] * [ sin(theta),  cos(theta), 0 ] * [ 0, 1, -center[1] ]
    //     [ 0, 0,         1 ]   [          0,           0, 1 ]   [ 0, 0,          1 ]
    // </pre>
    // and <code>theta</code> is the equivalent in radians of the degrees of rotation.
    // <p>
    // Note that the order of the translation/scale/shear/rotation transforms is the same as
    // the +link{class:DrawPane,local transforms} of +link{class:DrawItem,DrawItems}.
    // @param [center] (Point) an optional center point of rotation
    // @return (AffineTransformDecomposition) an object consisting of the variables in the
    // above matrix formula
    // @visibility customTransform
    //<
    decompose : function (cx, cy) {
        if (isc.isAn.Array(cx)) {
            cy = cx[1]; cx = cx[0];
        }
        if (!(isc.isA.Number(cx) && isc.isA.Number(cy))) {
            cx = cy = 0;
        }
        var decomp = isc.AffineTransform._decomposeTransform(this, cx, cy);
        return new isc.Math._affineTransformDecomposition(
            [decomp.dx, decomp.dy], [decomp.sx, decomp.sy], decomp.kx, decomp.ky,
            decomp.theta * 180 / Math.PI, [cx, cy]);
    }
});
// NOTE: toString functions CANNOT be added by addMethods, because a property named "toString"
// will not be enumerated by for..in.  This is actually part of the ECMAScript standard!

isc.AffineTransform.getPrototype().toString = function () {
    return isc.StringBuffer.concat(
        "[", this.m00.toFixed(5), ", ", this.m01.toFixed(5), ", ", this.m02.toFixed(5), "]\n",
        "[", this.m10.toFixed(5), ", ", this.m11.toFixed(5), ", ", this.m12.toFixed(5), "]");
};







//> @class DateUtil
// Static singleton class containing APIs for interacting with Dates.
// @treeLocation Client Reference/System
// @visibility external
//<

isc.defineClass("DateUtil");

isc.DateUtil.addClassMethods({

    _min : function (date1, date2) {

        return (date1.getTime() < date2.getTime() ? date1 : date2);
    },

    _max : function (date1, date2) {

        return (date1.getTime() < date2.getTime() ? date2 : date1);
    },

    //>    @classMethod DateUtil.format()
    // Return the parameter date formatted according to the parameter +link{type:FormatString}.
    // This method is used to implement the +link{DataSourceField.format,DataSourceField.format}
    // functionality, but it can also be used to format arbitrary dates programmatically.
    // @group dateFormatting
    // @param date (Date) The date to format
    // @param format (FormatString) The format to apply to this date
    // @return (String) formatted date string
    // @visibility external
    //<
    // This method is ultimately based on code from the DateJS library (www.datejs.com), refactored
    // to remove dependencies on that library's support structures and i18n approaches and integrate
    // the SmartClient i18n system.  It is also enhanced to support more of the functionality of
    // Java's SimpleDateFormat class, and to support fiscal days, weeks and years.
    format : function (date, format) {

        if (!isc.isA.String(format)) {
            isc.logWarn("Cannot use Date format '" + format + "' - not a String");
            return date.toString();
        }

        var p = function p(s) {
            return (s.toString().length == 1) ? "0" + s : s;
        };

        return format ? format.replace(/dd?d?d?|EE?E?E?|MM?M?M?|yy?y?y?|YY?Y?Y?|LL?L?L?|ww?|CC?|cc?|DD?|hh?|HH?|mm?|ss?|a|u/g,
        function (innerFormat) {
            switch (innerFormat) {
            case "hh":
                var hour = date.getHours();
                if (format.contains("a") && hour == 0) hour = 12;
                return p(hour < 13 ? hour : (hour - 12));
            case "h":
                var hour = date.getHours();
                if (format.contains("a") && hour == 0) hour = 12;
                return hour < 13 ? hour : (hour - 12);
            case "HH":
                var hour = date.getHours();
                if (format.contains("a") && hour == 0) hour = 12;
                return p(hour);
            case "H":
                var hour = date.getHours();
                if (format.contains("a") && hour == 0) hour = 12;
                return hour;
            case "mm":
                return p(date.getMinutes());
            case "m":
                return date.getMinutes();
            case "ss":
                return p(date.getSeconds());
            case "s":
                return date.getSeconds();
            case "yyyy":
                return date.getFullYear();
            case "yy":
                return date.getFullYear().toString().substring(2, 4);
            case "YYYY":
                return isc.DateUtil.getWeekNumber(date)[0];
            case "YY":
                return isc.DateUtil.getWeekNumber(date)[0].toString().substring(2, 4);
            case "dddd":
            case "EEEE":
                return date.getDayName();
            case "ddd":
            case "E":
            case "EE":
            case "EEE":
                return date.getShortDayName();
            case "dd":
                return p(date.getDate());
            case "d":
                return date.getDate().toString();
            case "DD":
                return p(isc.DateUtil.getDayNumber(date));
            case "D":
                return isc.DateUtil.getDayNumber(date).toString();
            case "u":
                return (date.getDay() || 7) + "";
            case "MMMM":
                return date.getMonthName();
            case "MMM":
                return date.getShortMonthName();
            case "MM":
                return p((date.getMonth() + 1));
            case "M":
                return date.getMonth() + 1;
            case "w":
                return isc.DateUtil.getWeekNumber(date)[1];
            case "ww":
                return p(isc.DateUtil.getWeekNumber(date)[1]);
            case "a":
                return date.getHours() < 12 ? isc.Time.AMIndicator : isc.Time.PMIndicator;
            default:
                return "";
            }
        }
        ) : "";
    },

    getWeekNumber : function(date) {
        var d = new Date(date);
        d.setHours(0,0,0);
        // The ISO standard is: the first week of a year is the one that contains the year's
        // first Thursday.  http://en.wikipedia.org/wiki/ISO-8601#Week_dates
        d.setDate(d.getDate() + 4 - (d.getDay()||7));
        // Get first day of year
        var yearStart = new Date(d.getFullYear(),0,1);
        // Calculate full weeks to nearest Thursday
        var weekNo = Math.ceil(( ( (d - yearStart) / 86400000) + 1)/7);
        // Return array of year and week number
        return [d.getFullYear(), weekNo];
    },

    getDayNumber : function(date) {
        var d = new Date(date);
        d.setHours(0,0,0);
        var yearStart = new Date(d.getFullYear(),0,1);
        return Math.ceil(((d - yearStart) / 86400000) + 1);
    },

    //> @classMethod DateUtil.createLogicalDate()
    // Create a new Date to represent a logical date value (rather than a specific datetime value),
    // typically for display in a +link{DataSourceField.type,date type field}. The generated
    // Date value will have year, month and date set to the specified values
    // (in browser native local time).
    // @param year (int) full year
    // @param month (int) month (zero based, so 0 is January)
    // @param date (int) date within the month
    // @return (Date) new javascript Date object representing the Date in question
    // @visibility external
    //<
    // For logical dates, the only requirement for the "time" component value is that the
    // date shows up correctly in local time.

    createLogicalDate : function (year, month, date, suppressConversion) {
        var d = new Date();
        d.setHours(12, 0, 0, 0);
        year = (year != null ? year : d.getFullYear());
        month = (month != null ? month : d.getMonth());
        date = (date != null ? date : d.getDate());
        d.setFullYear(year, month, date);

        if (suppressConversion) {
            // If the 'suppressConversion' flag was passed, we will want to return null to indicate
            // we were passed an invalid date if the values passed in had to be converted
            // (For example a month of 13 effecting the year, etc)
            var isValid = (d.getFullYear() == year &&
                           d.getMonth() == month &&
                           d.getDate() == date );
            if (!isValid) return null;
        }

        d.logicalDate = true;
        return d;
    },

    //> @classMethod DateUtil.getDisplayYear()
    // Returns the full year from the passed datetime, as it will be displayed to the user.
    // This might not be the same value as that returned by getFullYear() if a
    // +link{Time.setDefaultDisplayTimezone(), custom timezone}
    // has been applied.  Only necessary for datetimes - for logical dates and times, this
    // method returns the same value as getFullYear().
    // @param datetime (Date) datetime instance to work with
    // @return (int) the 4-digit display year from the passed datetime
    // @visibility external
    //<
    getDisplayYear : function (datetime) {
        return isc.Date.getLogicalDateOnly(datetime).getFullYear();
    },

    //> @classMethod DateUtil.getDisplayMonth()
    // Returns the month number from the passed datetime, as it will be displayed to the user.
    // This might not be the same value as that returned by getMonth() if a
    // +link{Time.setDefaultDisplayTimezone(), custom timezone}
    // has been applied.  Only necessary for datetimes - for logical dates and times, this
    // method returns the same value as getMonth().
    // @param datetime (Date) datetime instance to work with
    // @return (int) the month number from the passed datetime
    // @visibility external
    //<
    getDisplayMonth : function (datetime) {
        //return date._getTimezoneOffsetDate(isc.Time.getUTCHoursDisplayOffset(date),
        //    isc.Time.getUTCMinutesDisplayOffset(date)).getUTCMonth() + 1;
        return isc.Date.getLogicalDateOnly(datetime).getMonth();
    },

    //> @classMethod DateUtil.getDisplayDay()
    // Returns the day of month from the passed datetime, as it will be displayed to the user.
    // This might not be the same value as that returned by getDate() if a
    // +link{Time.setDefaultDisplayTimezone(), custom timezone}
    // has been applied.  Only necessary for datetimes - for logical dates and times, this
    // method returns the same value as getDate().
    // @param datetime (Date) datetime instance to work with
    // @return (int) the day of month from the passed datetime
    // @visibility external
    //<
    getDisplayDay : function (datetime) {
        return isc.Date.getLogicalDateOnly(datetime).getDate();
    },

    //> @classMethod DateUtil.getDisplayHours()
    // Returns the hours value from the passed datetime, as it will be displayed to the user.
    // This might not be the same value as that returned by getHours() if a
    // +link{Time.setDefaultDisplayTimezone(), custom timezone}
    // has been applied.  Only necessary for datetimes - for logical dates and times, this
    // method returns the same value as getHours().
    // @param datetime (Date) datetime instance to work with
    // @return (int) the hours value from the passed datetime
    // @visibility external
    //<
    getDisplayHours : function (datetime) {
        return isc.Date.getLogicalTimeOnly(datetime).getHours();
    },

    //> @classMethod DateUtil.getDisplayMinutes()
    // Returns the minutes value from the passed datetime, as it will be displayed to the user.
    // This might not be the same value as that returned by getMinutes() if a
    // +link{Time.setDefaultDisplayTimezone(), custom timezone}
    // has been applied.  Only necessary for datetimes - for logical dates and times, this
    // method returns the same value as getMinutes().
    // @param datetime (Date) datetime instance to work with
    // @return (int) the minutes value from the passed datetime
    // @visibility external
    //<
    getDisplayMinutes : function (datetime) {
        return isc.Date.getLogicalTimeOnly(datetime).getMinutes();
    },

    getDisplaySeconds : function (datetime) {
        return isc.Date.getLogicalTimeOnly(datetime).getSeconds();
    },

    getDisplayMilliseconds : function (datetime) {
        return isc.Date.getLogicalTimeOnly(datetime).getMilliseconds();
    }

});

//>    @class Date
//
//    Extensions to the Date class, including added static methods on the Date object, and
//  additional instance methods available on all date instances.
//
//  @treeLocation Client Reference/System
//  @visibility external
//<

//>    @classMethod    isc.timeStamp()
//  Shorthand for <code>new Date().getTime();</code>, this returns a timeStamp - a large number
//  which is incremented by 1 every millisecond.  Can be used to generate unique identifiers,
//  or perform timing tasks.
//
//  @visibility external
//    @return    (int)    a large integer (actually the number of milliseconds since 1/1/1970)
//<

isc.addGlobal("timeStamp", function () {

    return new Date().getTime()
});


// synonym
isc.addGlobal("timestamp", isc.timeStamp);


  //>DEBUG
// This lets us label methods with a name within addMethods
Date.prototype.Class = "Date";
Date.Class = "Date";
  //<DEBUG


isc.Date = Date;


isc.addProperties(Date, {
    // add a constant for an error message when attempting to convert an invalid string to a
    // date
    INVALID_DATE_STRING:"Invalid date format"
});


//
// add methods to the Date object itself for parsing additional formats
//
isc.addMethods(Date, {

//>    @classMethod    Date.newInstance()
//            Cover function for creating a date in the 'Isomorphic-style',
//                eg:   Date.newInstance(args)
//            rather than new Date(args)
//        @return                (Date)        Date object
//      @deprecated As of SmartClient 5.5, use +link{Date.create}.
//<
newInstance : function (arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
    return new Date(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
},


//>    @classMethod    Date.create()
//  Create a new <code>Date</code> object - synonym for <code>new Date(arguments)</code>
//    @return (Date) Date object
//  @visibility external
//<
create : function (arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
    // handle being passed a subset of parameters
    // Note that passing undefined into new Date() results in an invalid date where
    // getTime() returns NaN
    var undef;
    if (arg1 === undef) return new Date();
    if (arg2 === undef) return new Date(arg1);
    if (arg3 === undef) arg3 = 0;
    if (arg4 === undef) arg4 = 0;
    if (arg5 === undef) arg5 = 0;
    if (arg6 === undef) arg6 = 0;
    if (arg7 === undef) arg7 = 0;
    return new Date(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
},

//> @classMethod Date.createLogicalDate()
// Create a new Date to represent a logical date value (rather than a specific datetime value),
// typically for display in a +link{DataSourceField.type,date type field}. The generated
// Date value will have year, month and date set to the specified values
// (in browser native local time).
// @param year (int) full year
// @param month (int) month (zero based, so 0 is January)
// @param date (int) date within the month
// @return (Date) new javascript Date object representing the Date in question
// @visibility external
// @deprecated in favor of +link{DateUtil.createLogicalDate}
//<

createLogicalDate : function (year, month, date, suppressConversion) {
    return isc.DateUtil.createLogicalDate(year, month, date, suppressConversion);
},

//> @classMethod Date.createLogicalTime()
// Create a new Date object to represent a logical time value (rather than a specific datetime
// value), typically for display in a +link{DataSourceField.type,time type field}. The generated
// Date value will have year, month and date set to the epoch date (Jan 1 1970), and time
// elements set to the supplied hour, minute and second (in browser native local time).
// @param hour (int) hour (0-23)
// @param minute (int) minute (0-59)
// @param second (int) second (0-59)
// @return (Date) new Javascript Date object representing the time in question
// @visibility external
//<
// This is a synonym for Time.createLogicalTime();
createLogicalTime : function (hour, minute, second, millisecond) {
    return isc.Time.createLogicalTime(hour,minute,second,millisecond);
},

createDatetime : function (year, month, date, hours, minutes, seconds, milliseconds, suppressConversion) {
    var hasHours = hours != null,
        hasMinutes = minutes != null,
        hasSeconds = seconds != null;

    // Handle being passed strings
    if (isc.isA.String(hours)) hours = parseInt(hours || 12, 10);
    if (isc.isA.String(minutes)) minutes = parseInt(minutes || 0, 10);
    if (isc.isA.String(seconds)) seconds = parseInt(seconds || 0, 10);

    var newDate;
    if (!isc.Time._customTimezone) {
        newDate = new Date(year, month, date);
        if (hasHours) {
            if (milliseconds != null) newDate.setHours(hours, minutes, seconds, milliseconds);
            else if (hasSeconds) newDate.setHours(hours, minutes, seconds);
            else if (hasMinutes) newDate.setHours(hours, minutes);
            else newDate.setHours(hours);
        }

        if (!suppressConversion) return newDate;

        // If the 'suppressConversion' flag was passed, we will want to return null to indicate
        // we were passed an invalid date if the values passed in had to be converted
        // (For example a month of 13 effecting the year, etc)
        var isValid = (newDate.getFullYear() == year &&
                       newDate.getMonth() == month &&
                       newDate.getDate() == date &&
                       (!hasHours || newDate.getHours() == hours) &&
                       (!hasMinutes || newDate.getMinutes() == minutes) &&
                       (!hasSeconds || newDate.getSeconds() == seconds)
                       );
        return (isValid ? newDate : null);
    } else {

        // We need a date where the UTCTime is set such that when we apply our
        // custom timezone offset we get back the local time.
        // Do this by creating a new date with UTC time matching this custom display time
        // and then shifting that date by the inverse of our display timezone offset.
        if (hours == null) hours = 0;
        if (minutes == null) minutes = 0;
        if (seconds == null) seconds = 0;
        if (milliseconds == null) milliseconds = 0;

        newDate = new Date(Date.UTC(year, month, date, hours, minutes, seconds, milliseconds));
        // If the 'suppressConversion' flag was passed, we will want to return null to indicate
        // we were passed an invalid date if the values passed in had to be converted
        // (For example a month of 13 effecting the year, etc)
        // Easiest to check this against the date before we apply the offset to correct for
        // our timezone
        if (suppressConversion) {
            var isValid = (newDate.getUTCFullYear() == year &&
                           newDate.getUTCMonth() == month &&
                           newDate.getUTCDate() == date &&
                           (!hasHours || newDate.getUTCHours() ==hours) &&
                           (!hasMinutes || newDate.getUTCMinutes() == minutes) &&
                           (!hasSeconds || newDate.getUTCSeconds() == seconds)
                           );
            if (!isValid) newDate = null;
        }
        if (newDate != null) {
            // Subtract the UTCHoursDisplayOffset and UTCMinutesDisplayOffset, then adjust
            // for DST if required.

            newDate._applyTimezoneOffset(
                -isc.Time.UTCHoursDisplayOffset,
                -isc.Time.UTCMinutesDisplayOffset
            );

            newDate._applyTimezoneOffset(-isc.Time.getUTCHoursDisplayOffset(newDate, 0),
                                         -isc.Time.getUTCMinutesDisplayOffset(newDate, 0));
        }
        return newDate;
    }
},

//> @classMethod Date.getLogicalDateOnly()
// Get a logical date - a value appropriate for a DataSourceField of type "date" - from a
// datetime value (a value from a DataSourceField of type "datetime").
// <P>
// This method correctly takes into account the current
// +link{Time.setDefaultDisplayTimezone,display timezone}, specifically, the returned Date
// will reflect the day, month and year that appears when the datetime is rendered
// by a SmartClient component rather than the date values that would be returned by
// Date.getDay() et al (which can differ, since getDay() uses the browser's local timezone).
// <P>
// For further background on date, time and datetime types, storage and transmission, see
// +link{group:dateFormatAndStorage,this overview}.
//
// @param date (Date) a Date instance representing a datetime value
// @return (Date) a Date instance representing just the date portion of the datetime value, as
//                a logical date
// @visibility external
//<
getLogicalDateOnly : function (datetime) {
    if (!isc.isA.Date(datetime)) {
        isc.logWarn("getLogicalDateOnly() passed invalid value:" + datetime
            + ". Returning null.");
        return null;
    }
    var year,month,day;
    // handle being passed something that's already a logical date
    if (datetime.logicalDate) {
        year = datetime.getFullYear();
        month = datetime.getMonth();
        day = datetime.getDate();
    } else {
        var offsetDate = datetime._getTimezoneOffsetDate(
                            isc.Time.getUTCHoursDisplayOffset(datetime),
                            isc.Time.getUTCMinutesDisplayOffset(datetime)
                         );
        offsetDate._applyTimezoneOffset(0, offsetDate.getTimezoneOffset());

        month = offsetDate.getMonth();
        day = offsetDate.getDate();
        year = offsetDate.getFullYear();
    }

    return this.createLogicalDate(year, month, day);
},

//> @classMethod Date.getLogicalTimeOnly()
// Get a logical time - a value appropriate for a DataSourceField of type "time" - from a
// datetime value (a value from a DataSourceField of type "datetime").
// <P>
// This method correctly takes into account the current
// +link{Time.setDefaultDisplayTimezone,display timezone}, specifically, the returned Date will
// reflect the hour, minute and second that appears when the datetime is rendered by a SmartClient
// component rather than the time values that would be returned by Date.getHours() et al (which
// can differ, since getHours() uses the browser's local timezone).
// <P>
// For further background on date, time and datetime types, storage and transmission, see
// +link{group:dateFormatAndStorage,this overview}.
//
// @param date (Date) a Date instance representing a datetime value
// @return (Date) a Date instance representing just the time portion of the datetime value, as
//                a logical time
// @visibility external
//<
getLogicalTimeOnly : function (datetime) {
    if (!isc.isA.Date(datetime)) {
        isc.logWarn("getLogicalTimeOnly() passed invalid value:" + datetime
            + ". Returning null.");
        return null;
    }

    var offsetHours = 0, offsetMinutes = 0;
    if (!datetime.logicalTime) {
        offsetHours = isc.Time.getUTCHoursDisplayOffset(datetime);
        offsetMinutes = isc.Time.getUTCMinutesDisplayOffset(datetime) +
                        datetime.getTimezoneOffset();
    }

    return this.createLogicalTime(datetime.getHours() + offsetHours, datetime.getMinutes() + offsetMinutes,
                                  datetime.getSeconds(), datetime.getMilliseconds());
},


//> @classMethod Date.combineLogicalDateAndTime()
// Combine a logical date (a value appropriate for a DataSourceField of type "date") with a
// logical time (a value appropriate for a DataSourceField of type "time") into a datetime
// value (a value appropriate for a DataSourceField of type "datetime")
// <P>
// This method correctly takes into account the current
// +link{Time.setDefaultDisplayTimezone,display timezone}, specifically, the returned datetime
// value will show the same date and time as the passed date and time objects when rendered by
// a SmartClient component that has been configured with a field of type "datetime".
// <P>
// For further background on date, time and datetime types, storage and transmission, see
// +link{group:dateFormatAndStorage,this overview}.
//
// @param date (Date) a Date instance representing logical date value
// @param time (Date) a Date instance representing logical time value
// @return (Date) a Date instance representing a datetime value combining the logical date and
//                time passed
// @visibility external
//<
combineLogicalDateAndTime : function (date, time) {
    var hasDate = isc.isA.Date(date),
        hasTime = isc.isA.Date(time);
    if (!hasDate || !hasTime) {
        // date only, convert from logical date to datetime.
        if (hasDate) {
            // pass in the result of 'getFullYear()' etc. These numbers are the correct
            // abs values - createDatetime will handle shifting them to account for
            // timezones.
            return this.createDatetime(date.getFullYear(), date.getMonth(), date.getDate(), 0,0,0);
        } else if (hasTime) {
            // We could log a warning and bail in this case. However may as well just
            // give back a datetime with the same time value as the 'time' passed in.
            return time.duplicate();
        } else {
            isc.logWarn("combineLogicalDateAndTime passed invalid parameters:"
                 + date + " and " + time + ". Returning null.");
            return null;
        }
    }

    // Get hours / minutes in display timezone.
    var hour = time.getHours(),
        minutes = time.getMinutes();
    return this.createDatetime(
                date.getFullYear(), date.getMonth(), date.getDate(),
                hour, minutes, time.getSeconds(), time.getMilliseconds()
           );
},


//>    @classMethod    Date.compareDates()
// Compare two dates; returns 0 if equal, -1 if the first date is greater (later), or 1 if
// the second date is greater.  If either value is not a Date object, it is treated as the
// epoch (midnight on Jan 1 1970) for comparison purposes.
//  @param  date1   (date)  first date to compare
//  @param  date2   (date)  second date to compare
//  @return (int)    0 if equal, -1 if first date &gt; second date, 1 if second date &gt; first date
// @visibility external
//<
compareDates : function (a, b, allowRelativeDates) {
    if (a == b) return 0; // same date instance
    if (allowRelativeDates) {
        // adds support for comparing the absolute values of relative date objects, shortcuts
        // and strings
        a = isc.DateUtil.getAbsoluteDate(a);
        b = isc.DateUtil.getAbsoluteDate(b);
    }
    var aval = (isc.isA.Date(a) ? a.getTime() : 0),
        bval = (isc.isA.Date(b) ? b.getTime() : 0);
    return aval > bval ? -1 : (bval > aval ? 1 : 0);
},

//>    @classMethod    Date.compareLogicalDates()
// Compare two dates, normalizing out the time elements so that only the date elements are
// considered; returns 0 if equal, -1 if the first date is greater (later), or 1 if
// the second date is greater.
//  @param  date1   (date)  first date to compare
//  @param  date2   (date)  second date to compare
//  @return (int)    0 if equal, -1 if first date &gt; second date, 1 if second date &gt;
//                      first date.  Returns false if either argument is not a date
// @visibility external
//<
compareLogicalDates : function (a, b, allowRelativeDates) {
    if (a == b) return 0; // same date instance
    if (!isc.isA.Date(a) || !isc.isA.Date(b)) {
        if (allowRelativeDates) {
            // adds support for comparing the absolute logical values of relative date objects,
            // shortcuts and strings
            a = isc.DateUtil.getAbsoluteDate(a, null, null, true);
            b = isc.DateUtil.getAbsoluteDate(b, null, null, true);
        }
        if (!isc.isA.Date(a) || !isc.isA.Date(b)) {
            return false; // bad arguments, so return false
        }
    }
    var aYear = a.getFullYear(),
        aMonth = a.getMonth(),
        aDay = a.getDate(),
        bYear = b.getFullYear(),
        bMonth = b.getMonth(),
        bDay = b.getDate();

    var aval = aYear * 10000 + aMonth * 100 + aDay,
        bval = bYear * 10000 + bMonth * 100 + bDay;

    return aval > bval ? -1 : (bval > aval ? 1 : 0);
},

// `month' begins at 0.
getJulianDayNumber : function (year, month, date) {
    // http://quasar.as.utexas.edu/BillInfo/JulianDatesG.html
    var y = year,
        m = month + 1,
        d = date;

    if (m <= 2) {
        --y;
        m += 12;
    }
    var a = parseInt(y / 100),
        b = parseInt(a / 4),
        c = 2 - a + b,
        e = parseInt(365.25 * (y + 4716)),
        f = parseInt(30.6001 * (m + 1))
    return c + d + e + f - 1524;
},

_getWeekdayCounts : function (weekendDays) {
    weekendDays = weekendDays || isc.Date.getWeekendDays();
    var weekdayCounts = weekendDays._weekdayCounts;
    if (!weekdayCounts) {
        var isWeekend = {}, numWeekends = 0;
        for (var i = 0; i < weekendDays.length; ++i) {
            if (!isWeekend[weekendDays[i]]) {
                ++numWeekends;
                isWeekend[weekendDays[i]] = true;
            }
        }

        weekdayCounts = [];
        for (var d = 0; d <= 6; ++d) {
            var weekdayCount = 0;
            var counts = [ 0 ];
            for (var dd = 1; dd < 7; ++dd) {
                if (!isWeekend[(d + dd - 1) % 7]) ++weekdayCount;
                counts.push(weekdayCount);
            }
            weekdayCounts[d] = counts;
        }
        weekdayCounts._numWeekends = numWeekends;
        weekendDays._weekdayCounts = weekdayCounts;
    }
    return weekdayCounts;
},

_getDayDiff : function (date1, date2, weekdaysOnly, useCustomTimezone, weekendDays) {
    var logicalDate1, logicalDate2;
    var compareRes = isc.Date.compareDates(date1, date2);
    var sign = (compareRes > 0 ? 1 : -1);
    if (compareRes >= 0) { // `date1' is before `date2'.
        if (useCustomTimezone !== false) {
            logicalDate1 = isc.Date.getLogicalDateOnly(date1);
            logicalDate2 = isc.Date.getLogicalDateOnly(date2);
        } else {
            logicalDate1 = date1;
            logicalDate2 = date2;
        }
    } else {
        if (useCustomTimezone !== false) {
            logicalDate1 = isc.Date.getLogicalDateOnly(date2);
            logicalDate2 = isc.Date.getLogicalDateOnly(date1);
        } else {
            logicalDate1 = date2;
            logicalDate2 = date1;
        }
    }

    var jd1 = isc.Date.getJulianDayNumber(logicalDate1.getFullYear(), logicalDate1.getMonth(), logicalDate1.getDate()),
        jd2 = isc.Date.getJulianDayNumber(logicalDate2.getFullYear(), logicalDate2.getMonth(), logicalDate2.getDate());

    if (weekdaysOnly) {
        var dd = jd2 - jd1;
        var weekdayCounts = isc.Date._getWeekdayCounts(weekendDays);
        return sign * (parseInt(dd / 7) * (7 - weekdayCounts._numWeekends) + weekdayCounts[logicalDate1.getDay()][dd % 7]);
    } else {
        return sign * (jd2 - jd1);
    }
},

//>    @type DateInputFormat
//  3 character string containing the <code>"M"</code>, <code>"D"</code> and <code>"Y"</code>
//  characters to indicate the format of strings being parsed into Date instances via
//  <code>Date.parseInput()</code>.
//  <P>
//  As an example - an input format of "MDY" would parse "01/02/1999" to Jan 2nd 1999
// <smartclient>
//  <P>
//  Note: In addition to these standard formats, a custom date string parser function may be
//  passed directly to +link{Date.setInputFormat()} or passed into +link{Date.parseInput()} as
//  the inputFormat parameter.
// </smartclient>
//  @visibility external
//<

//> @classMethod Date.setInputFormat()
// Sets up the default system-wide input format for strings being parsed into dates via
// <code>Date.parseInput()</code>. This will effect how SmartClient components showing editable
// date or datetime fields parse user-entered values into live Date objects.
// <P>
// The input format can be specified as a +link{type:DateInputFormat} - a 3 character string like
// <code>"MDY"</code> indicating the order of the Month, Day and Year components of date strings.
// <P>
// As an example - an input format of "MDY" would parse "01/02/1999" to Jan 2nd 1999<br>
// This standard parsing logic will also handle date-time strings such as "01/02/1999 08:45", or
// "01/02/1999 16:21:05".
// <P>
// Notes:
// <ul>
// <li>If the inputFormat is not explicitly set,the system automatically determines
//     the standard input format will be based on the specified +link{Date.setShortDisplayFormat,Date.shortDisplayFormat}
//     wherever possible.
//     For example if the short display format has been set to "toEuropeanShortDate" the input
//     format will default to "DMY".</li>
// <li>The default date parsing functionality built into SmartClient will handle dates presented
//     with any separator string, and can handle 1 or 2 digit day and month values and 2 or 4
//     digit year values. This means that in many cases custom date display formats can be parsed
//     back to Date values without the need for a custom parser function. However if more
//     sophisticated parsing logic is required, a function may be passed into this method. In
//     this case the parser function should be able to handle parsing date and datetime values
//     formatted via +link{Date.toShortDate()} and +link{Date.toShortDateTime()}.</li>
// <li>Date parsing and formatting logic may be overridden at the component level by setting
//     properties directly on the component or field in question.</li>
// </ul>
// @param format (DateInputFormat | function) Default format for strings to be parsed into Dates.
// <smartclient>
// If this method is passed a function, it is expected to take a single parameter
// (the formatted date string), and return the appropriate Javascript Date object (or null if
// appropriate).
// </smartclient>
// @see Date.parseInput()
// @example dateFormat
// @example customDateFormat
// @visibility external
//<
setInputFormat : function (format) {

    this._inputFormat = format;
},

//> @classMethod Date.getInputFormat()
// Retrieves the default format for strings being parsed into dates via
// <code>Date.parseInput()</code>
// @see Date.setInputFormat()
// @return (string) the current inputFormat for dates
// @visibility external
//<
getInputFormat : function () {
    if (this._inputFormat != null) return this._inputFormat;
    return this.mapDisplayFormatToInputFormat("toShortDate");
},

// Given a display format return the associated input format
_inputFormatMap:{
    toUSShortDate:"MDY",
    toUSShortDateTime:"MDY",
    toUSShortDatetime:"MDY",
    toEuropeanShortDate:"DMY",
    toEuropeanShortDateTime:"DMY",
    toEuropeanShortDatetime:"DMY",
    toJapanShortDate:"YMD",
    toJapanShortDateTime:"YMD",
    toJapanShortDatetime:"YMD"
},
mapDisplayFormatToInputFormat : function (displayFormat) {
    if (displayFormat == null || displayFormat == "toShortDate") {
        displayFormat = Date.prototype._shortFormat;
    } else if (displayFormat == "toNormalDate") {
        displayFormat = Date.prototype.formatter;
    }
    if (isc.isA.Function(displayFormat)) {
        isc.Log.logInfo("Unable to determine input format associated with display format " +
                        "function - returning default input format", "Date");
        return this._inputFormat || "MDY";
    }
    var inputFormat = this._inputFormatMap[displayFormat];
    // Note: isA.String check is necessary - all objects have toString / toLocaleString
    // present on them and we definitely don't want to return those native object formatters
    // as what will become a dateString parsing function!
    if (inputFormat != null && isc.isA.String(inputFormat)) return inputFormat;

    // a couple of special cases where we actually return functions.
    if (displayFormat == "toSerializeableDate") return this.parseSchemaDate;

    // Otherwise you're on your own - assume you've set up input foramt, or overridden this method
    isc.Log.logInfo("Unable to determine input format associated with display format " +
                     displayFormat + " - returning default input format", "Date");

    return this._inputFormat || "MDY";
},

//>    @classMethod    Date.parseInput()
// Parse a date passed in as a string, returning the appropriate date object.
// @param dateString (string) date value as a string
// @param [format] (DateInputFormat) Format of the date string being passed.
//                                      If not passed, the default date input format as set up
//                                      via setInputFormat() will be used.
// @param [centuryThreshold] (integer) For date formats that support a 2 digit
//                                  year, if parsed year is 2 digits and less than this
//                                  number, assume year to be 20xx rather than 19xx
// @param [suppressConversion] (Boolean)
//          If the string passed in was not a valid date, in some cases we can convert to a
//          valid date (for example incrementing the year if the month is greater than 12).
//          This optional parameter will suppress such conversions - anything that doesn't
//          parse directly to a valid date will simply return null.
// @return (Date) date value, or null if the string could not be parsed to a valid date.
// @group dateFormatting
// @visibility external
//<

// Note: undocumented isDatetime parameter. Are we creating a logical "date" value or a standard
// datetime type value where the time component is important? If ommitted assume datetime.
// Implementation-wise, if isDatetime is explicitly false, we will use the system local timezone
// rather than any timezone specified via Time.setDisplayTimezone().

parseInput : function (dateString, format, centuryThreshold, suppressConversion,
                        isDatetime)
{
    var logicalDate = (isDatetime == false);

    if (isc.isA.Date(dateString)) return dateString;

    if (!isc.isA.String(dateString) || isc.isAn.emptyString(dateString)) {
        return null;
    }

    // Strip the '$$DATE$$:' prefix if present.
    var origDateString = dateString;
    dateString = dateString.trim();

    if (dateString.startsWith("$$DATESTAMP$$:")) {
        return new Date(parseInt(dateString.substring(14)));
    }

    if (dateString.startsWith("$$DATE$$:")) {
        dateString = dateString.substring(9).trimLeft();
    }

    // Default to the standard input format
    if (format == null) format = this.getInputFormat();

    // If the format passed in is the name of a function on the Date class, or an
    // explicit function, assume its a parser and call it directly

    if (isc.isA.Function(Date[format])) format = Date[format];
    if (isc.isA.Function(format)) {
        return format(origDateString, centuryThreshold, suppressConversion);
    }

    // use the helper method _splitDateString() to get an array of values back
    // (representing year / month / day, etc.)
    // If null is returned, this was not a valid date - just return null.
    // Otherwise make the month zero-based, by reducing by one, and pass construct a new date
    // from the values returned.
    var array = this._splitDateString(dateString, format);

    if (array != null) {
        var year = array[0],
            bce = year && year.contains("-");

        if (year && bce) year = year.replaceAll("-", "");

        if (year) {
            if (year.length <= 2) {
                year = parseInt(year, 10);
                if (centuryThreshold != null) {
                    if (year < centuryThreshold) year += 2000;
                    else year += 1900;
                }
                array[0] = year;
            } else if (year.length == 3) {
                array[0] = "0" + year.toString();
            } else {
                array[0] = year;
            }
            if (bce) array[0] = "-" + array[0];
        }

        if (logicalDate) {
            return Date.createLogicalDate(array[0], array[1], array[2], suppressConversion);
        } else {
            return Date.createDatetime(array[0], array[1], array[2],
                        array[3], array[4], array[5], null, suppressConversion);
        }
    } else {
        return null;
    }
},

// Helper used by the Relative date item -- returns true if the date-string passed
// in includes a time portion.
// False if it does not (or if it's not a recognized date-string at all)
isDatetimeString : function (dateString, format) {
    format = format || isc.Date.getInputFormat();
    if (!isc.isA.Function(format)) {
        var array = this._splitDateString(dateString, format, false);
        if (array == null) return false;

        return (array[3] != null && !isc.isA.emptyString(array[3])) &&
               (array[4] != null && !isc.isA.emptyString(array[4]));
    }


    if (!dateString.contains(" ")) return false;
    // get the offset of the last colon and assume there's a valid time portion if the characters
    // either side of it are numbers
    var colonOffset = dateString.lastIndexOf(":");
    if (colonOffset < 1) return false;
    if (isNaN(dateString.substring(colonOffset-1, colonOffset)) ||
        isNaN(dateString.substring(colonOffset+1, colonOffset+2)))
    {
        return false;
    }
    return true;
},

// Parse a date or datetime value from a dataset or specified in code.
// NB: unlike parseInput, this method should not change behavior in different locales, or dates
// coming over the wire or specified in code will suddenly break!
//
// For Datetime, XML Schema uses "2005-08-01T21:35:48.350Z", see
//    http://www.w3.org/TR/xmlschema-2/#dateTime
// SmartClient Server parses "yyyy-mm-dd" format
parseSchemaDate : function (value) {
    if (isc.isA.Date(value)) return value;

    if (!isc.isA.String(value)) value = (value.toString ? value.toString() : value + "");

    // Notes on regex:
    // - result[4] is the optional timestamp including the T and colon separators
    // - result[8] would be the optional milliseconds including the ".", whereas
    //   result[9] is just the numeric part
    //   results[10] is the timezone - either "Z" (zulu time or GMT) or +/- HH:MM
    var result = value.match(/(\d{4})[\/-](\d{2})[\/-](\d{2})([T ](\d{2}):(\d{2})(:(\d{2}))?)?(\.(\d+))?([+-]\d\d?:\d{2}|Z)?/);
//    isc.Log.logWarn("isDate: '" + value + "', regex match: " + result);

    if (result == null) return null;

    value = value.trim();

    var secondsIndex = 8;
    var msIndex = 10;
    var tzIndex = 11;


    var dateValue;
    // NOTE: pass only the relevant arguments as Moz does not like being passed nulls

    if (!result[4]) { // no VALID time
        // before creating a logical date, check if the value has additional characters that
        // make it look like it has something in place of a time-value, even if it isn't
        // valid for schema-format - return null in this case, rather than a valid logicalDate
        if (value.length > 10 && value.contains(" ")) return null;
        dateValue = Date.createLogicalDate(result[1], result[2] - 1, result[3]);
    } else if (!result[msIndex]) { // no ms
        dateValue = new Date(Date.UTC(result[1], result[2] - 1, result[3],
                                      result[5], result[6], result[secondsIndex] || 0));
    } else {
        var ms = result[msIndex];

        // XML Schema says any number of fractional digits can be specified.  new Date() is
        // expecting a whole number of milliseconds (and further precision would be ignored).
        // Multiply by a power of ten based on the number of digits provided, such that ".9"
        // becomes 900 and ".98367" becomes 984.
        if (ms.length != 3) {
            var multiplier = Math.pow(10,3-ms.length);
            ms = Math.round(parseInt(ms,10) * multiplier);
        }
        //isc.Log.logWarn("ms is: " + ms);

        dateValue = new Date(Date.UTC(result[1], result[2] - 1, result[3],
                                      result[5], result[6], result[secondsIndex] || 0, ms));
    }
    // Handle timezone offset from GMT

    if (result[tzIndex] && result[tzIndex].toLowerCase() != "z") {
        var HM = result[tzIndex].split(":"),
            H = HM[0],
            negative = H && H.startsWith("-"),
            M = HM[1];
        H = parseInt(H, 10);
        M = parseInt(M, 10);
        var dateTime = dateValue.getTime();


        // Note no need to account for negative on hours since the "+" or "-" prefix was picked up
        // in parseInt
        if (isc.isA.Number(H)) dateTime -= (3600000 * H);
        if (isc.isA.Number(M)) dateTime -= (60000 * M * (negative ? -1 : 1));
        dateValue.setTime(dateTime);
    }

    return dateValue
},

//>!BackCompat 2005.11.3
// parseDate() was old name for parseInput
parseDate : function (dateString, format, centuryThreshold, suppressConversion) {
    return this.parseInput(dateString, format, centuryThreshold, suppressConversion);
},

// For completeness also support parseDatetime()
parseDateTime : function (dateString, format, centuryThreshold, suppressConversion) {
    return this.parseDatetime(dateString,format,centuryThreshold,suppressConversion);
},
parseDatetime : function (dateString, format, centuryThreshold, suppressConversion) {
    return this.parseInput(dateString, format, centuryThreshold, suppressConversion);
},
//<!BackCompat

// ISC DSResponses that use our SQLTransform logic (basically our backend DB implementation)
// will call this method by default - giving the user an opportunity to override.  This can be
// disabled by setting jsTranslater.writeNativeDate: true in server.properties.
//
// Note: month is zero-based, just like the native Date constructor.
parseServerDate : function (year, month, day) {
    return Date.createLogicalDate(year, month, day);
},

// ISC DSResponses will call this method by default for fields of type "time"
parseServerTime : function (hour, minute, second) {
    return Date.createLogicalTime(hour, minute, second);
},


_splitDateString : function (string, format, zeroEmptyTime) {
    var isFunc = isc.isA.Function(format);

    if (zeroEmptyTime == null) zeroEmptyTime = true;

    var month, day, year, hour, minute, second;

    var monthIndex = format && !isFunc ? format.indexOf("M") : 0,
        dayIndex = format && !isFunc ? format.indexOf("D") : 1,
        yearIndex = format && !isFunc ? format.indexOf("Y") : 2;
    // shortDate implies it's of the format MM/DD/YYYY

    //>Safari12
    if (isc.Browser.isSafari && isc.Browser.safariVersion <= 312) {
        var splitDate = this._splitDateViaSubstring(string, monthIndex, dayIndex, yearIndex,
                                                    zeroEmptyTime);
        year = splitDate[0];
        month = splitDate[1];
        day = splitDate[2];
        hour = splitDate[3];
        minute = splitDate[4];
        second = splitDate[5];

    // For browsers that support RegExp properly, use regexp pattern matching to get the result
    // (This has the advantage that we can deal with dates of the form 1/1/1999, and attempt to
    //  convert MM/YY/DD -- though we're relying on the native browser handling for the
    //  Date constructor being passed a 2 digit year)
    } else {
    //<Safari12

        // Each of the first three slots is either YYYY / YY or MM / M (or DD/D) (depends on the
        // format passed in)
        // Note: We don't support years greater than 9999. Attempting to set a year greater than
        // 9999 on a JS date causes a native browser crash on IE6
        var regex =
        //          YYYY || YY/[M]M  /  YYYY || YY/[M]M  /  YYYY || YY/[M]M [(space) [H]H  :    MM    [:     SS]]
        new RegExp(/^\s*(-?\d{1,4})[^\d](-?\d{1,4})[^\d](-?\d{1,4})([^\d](\d{1,2})[^\d](\d\d)[^\d]?(\d\d)?)?\s*$/),
            results = string.match(regex);

        if (results == null) return null;
        // Notes - we need to match the order of day / month / year to the format passed in
        // Also - the month value in the string is 1-based rather than zero based

        // Note: this was parseInt(results[index]) -1, but both IE and Mozilla will do the
        // wrong thing here - if the substring was "09", the parseInt would return 0 rather
        // than 9.
        // In any case, the parseInt is rendered unnecessary by the 'isA.Number' check below.
        month = results[monthIndex +1] -1;
        day = results[dayIndex+1];
        year = results[yearIndex +1];

        // Note - results[4] is the whole time string (if present)
        // Zero out any time fields that are not present - this may happen if
        // - time has invalid format (could check by examining results[4] too)
        // - time not included in dateString (could check by examining results[4] too)
        // - time has no seconds (legal - just zero out the seconds)
        hour = results[5];
        if (zeroEmptyTime && hour == null) hour = 0;
        minute = results[6];
        if (zeroEmptyTime && results[6] == null) minute = 0;
        second = results[7];
        if (zeroEmptyTime && results[7] == null) second = 0;
    //>Safari12
    }
    //<Safari12
    // If they all are numbers, this was a valid date string
    // NOTE: If year - month - day gives a number then they
    // are all numbers, or strings that implicitly convert to numbers.
    // We could also use this syntax:
    // if(parseInt(year) == year && parseInt(month) == month ...)
    // but this is slower in both Moz and IE
    var isValid = zeroEmptyTime ?
                    isc.isA.Number(year - month - day - hour - minute - second) :
                    isc.isA.Number(year - month - day);
    if (isValid) {
        // Return the hours modulo 24 in case the hours were formatted by a Java `SimpleDateFormat'
        // using the 'k' pattern char. This takes care of both 'H' and 'k'.
        // http://ideone.com/E5HC4E

        return ([year,month,day,hour != null ? hour % 24 : null ,minute,second]);
    }
    else return null
},

//>    @type DateDisplayFormat
// Valid display formats for dates.  These strings are the names of formatters which can be
// passed to <code>Date.setNormalDisplayFormat()</code> or <code>Date.setShortDisplayFormat()</code>
// and will be subsequently used as default long or short formatters for date objects by
// SmartClient components.<br>
// Default set of valid display formats is as follows:<br><br>
//
// @value toString
// Default native browser 'toString()' implementation. May vary by browser.<br>
// <i>Example</i>: <code>Fri Nov 04 2005 11:03:00 GMT-0800 (Pacific Standard Time)</code>
// @value toLocaleString
// Default native browser 'toLocaleString()' implementation. May vary by browser.
// <i>Example</i>: <code>Friday, November 04, 2005 11:03:00 AM</code>
// @value toUSShortDate Short date in format MM/DD/YYYY.<br>
// <i>Example</i>: <code>11/4/2005</code>
// @value toUSShortDatetime Short date with time in format MM/DD/YYYY HH:MM<br>
// <i>Example</i>: <code>11/4/2005 11:03</code>
// @value toEuropeanShortDate Short date in format DD/MM/YYYY.<br>
// <i>Example</i>: <code>4/11/2005</code>
// @value toEuropeanShortDatetime Short date with time in format DD/MM/YYYY HH:MM<br>
// <i>Example</i>: <code>4/11/2005 11:03</code>
// @value toJapanShortDate Short date in format YYYY/MM/DD.<br>
// <i>Example</i>: <code>2005/11/4</code>
// @value toJapanShortDatetime Short date with time in format YYYY/MM/DD HH:MM<br>
// <i>Example</i>: <code>2005/11/4 11:03</code>
// @value toSerializeableDate Date in the format YYYY-MM-DD HH:MM:SS<br>
// <i>Example</i>: <code>2005-11-04 11:09:15</code>
// @value toDateStamp   Date in the format &lt;YYYYMMDD&gt;T&lt;HHMMSS&gt;Z
// <i>Example</i>: <code>20051104T111001Z</code>
// <br>
// <br>
// Note: In addition to these standard formats, custom formatting can be set by passing
// a function directly to +link{Date.setNormalDisplayFormat()} et al. This
// function will then be executed whenever the appropriate formatter method is called [eg
// +link{date.toNormalDate()}], in the scope of the date instance in question.
// <p>
// Custom formatting can also be applied by passing a +link{FormatString} instead of a
// <code>DateDisplayFormat</code> string to +link{Date.setNormalDisplayFormat()} et al. See
// the <code>FormatString</code> docs for details.
//
//  @visibility external
//<

//> @classMethod Date.setNormalDisplayFormat()
// Set the default formatter for date objects to the method name passed in.  After calling this
// method, subsequent calls to +link{Date.toNormalDate()} will return a string formatted
// according to this format specification. Note: this will be the standard long date format used
// by SmartClient components.
// <p>
// The <code>format</code> parameter may be a +link{FormatString}, a +link{DateDisplayFormat}
// string, or a function. If passed a function, this function will be executed in the scope of
// the Date and should return the formatted string.<br>
// <p>
// Initial default normalDisplayFormat is <code>"toLocaleString"</code>
// @group    dateFormatting
// @param    format    (FormatString | DateDisplayFormat | function)    new formatter
//      @visibility external
//<
setNormalDisplayFormat : function (format) {
    // if a valid formatter was passed in, set our .formatter property
    if (isc.isA.Function(Date.prototype[format]) ||
        isc.isA.Function(format) ||
        isc.isA.String(format))
    {
        Date.prototype.formatter = format;
    }
},

setNormalDateDisplayFormat : function (format) {
    this.setNormalDisplayFormat(format);
},

//> @classMethod Date.setNormalDatetimeDisplayFormat()
//  Set the default normal format for datetime values. After calling this method, subsequent calls to
// +link{Date.toNormalDatetime()} will return a string formatted according to this format
// specification. Note that this will be the standard datetime format used by
// SmartClient components.
// <P>
// The <code>format</code> parameter may be a +link{FormatString}, a +link{DateDisplayFormat}
// string, or a function. If passed a function, this function will be executed in the scope of
// the Date and should return the formatted string.<br>
//
// @group    dateFormatting
// @param    format    (FormatString | DateDisplayFormat | function)    new formatter
// @example dateFormat
// @example customDateFormat
// @visibility external
//<
setNormalDatetimeDisplayFormat : function (format) {
    // if a valid formatter was passed in, set our .formatter property
    if (isc.isA.Function(Date.prototype[format]) ||
        isc.isA.Function(format) ||
        isc.isA.String(format))
    {
        Date.prototype.datetimeFormatter = format;
    }
},

//>    @classMethod    Date.setShortDisplayFormat()
// Set the default short format for dates. After calling this method, subsequent calls to
// +link{Date.toShortDate()} will return a string formatted according to this format
// specification. Note that this will be the standard short date format used by
// SmartClient components.
// <P>
// The <code>format</code> parameter may be a +link{FormatString}, a +link{DateDisplayFormat}
// string, or a function. If passed a function, this function will be executed in the scope of
// the Date and should return the formatted string.<br>
// <P>
// Initial default shortDateFormat is <code>"toUSShortDate"</code>. This property
// is commonly modified for localization of applications. See
// +externalLink{http://en.wikipedia.org/wiki/Date_format_by_country}
// for a useful overview of standard date formats per country.
//
// @group    dateFormatting
// @param    format    (FormatString | DateDisplayFormat | function)    new formatter
// @example dateFormat
// @example customDateFormat
// @visibility external
//<
setShortDisplayFormat : function (format) {
    if (isc.isA.Function(Date.prototype[format]) ||
        isc.isA.Function(format) ||
        isc.isA.String(format))
    {
        Date.prototype._shortFormat = format;
    }
},

//>    @classMethod Date.setDefaultDateSeparator
// Sets a new default separator that will be used when formatting dates. By default, this
// is a forward slash character: "/"
// @group   dateFormatting
// @param separator (string) separator to use in dates
// @visibility external
//<
setDefaultDateSeparator : function (separator) {
    Date.prototype._shortDateTemplate = [,,,,separator,,,,,separator,,,,null];
    Date.prototype._separator = separator;
},

//>    @classMethod Date.getDefaultDateSeparator
// gets the default date separator string
// @group   dateFormatting
// @return (string) the default date separator
// @visibility external
//<
getDefaultDateSeparator : function (separator) {
    if (Date.prototype._separator) return Date.prototype._separator;
    else return "/";
},

//> @classMethod Date.setShortDatetimeDisplayFormat()
//  Set the default short format for datetime values. After calling this method, subsequent calls to
// +link{Date.toShortDateTime()} will return a string formatted according to this format
// specification. Note that this will be the standard datetime format used by
// SmartClient components.
// <P>
// The <code>format</code> parameter may be a +link{FormatString}, a +link{DateDisplayFormat}
// string, or a function. If passed a function, this function will be executed in the scope of
// the Date and should return the formatted string.<br>
// <P>
// Initial default format is <code>"toUSShortDatetime"</code>.  See
// +externalLink{http://en.wikipedia.org/wiki/Date_format_by_country}
// for a useful overview of standard date formats per country.
//
// @group    dateFormatting
// @param    format    (FormatString | DateDisplayFormat | function)    new formatter
// @example dateFormat
// @example customDateFormat
// @visibility external
//<
setShortDatetimeDisplayFormat : function (format) {
    if (isc.isA.Function(Date.prototype[format]) ||
        isc.isA.Function(format) ||
        isc.isA.String(format))
    {
        Date.prototype._shortDatetimeFormat = format;
    }
},


//> @object FiscalYear
//
// An object representing the start of a given Fiscal Year in the current locale.
// <P>
// See +link{FiscalCalendar} for more information on how FiscalYears are set up and used.
//
// @treeLocation Client Reference/System/Date
// @visibility external
//<

//> @attr fiscalYear.fiscalYear (integer : null : IRW)
//
// The actual fiscal year that this date relates to.
// <P>
// A fiscal year ends when the next one begins. A fiscal year may span the boundary
// between two calendar years in which case the +link{fiscalYear.fiscalYear} value may
// not match the +link{fiscalYear.year} value.
// <P>
// For example fiscalYear 2020 may start in July of 2019 and end in July of 2020. In this
// case the <code>fiscalYear</code> would be set to <code>2020</code> and the
// +link{fiscalYear.year} would be set to <code>2019</code>
//
// @visibility external
//<

//> @attr fiscalYear.year (integer : null : IRW)
//
// The 4-digit calendar year when this fiscal year starts.
//
// @visibility external
//<

//> @attr fiscalYear.month (integer : null : IRW)
//
// The zero-based month-number when this fiscal year starts.
//
// @visibility external
//<

//> @attr fiscalYear.date (integer : null : IRW)
//
// The one-based day-number in the +link{fiscalYear.month, specified month} when this fiscal
// year starts.
//
// @visibility external
//<

//> @object FiscalCalendar
//
// An object representing the start date for fiscal years in the current locale.
// <P>
// A fiscal year spans a configurable date range - it may not exactly
// match a calendar year in length and it can start on any date within the calendar year
// and potentially end in the next calendar year.
// <P>
// Developers may specify explicit fiscal year start dates by adding +link{FiscalYear}
// objects to the +link{FiscalCalendar.fiscalYears, fiscal years array}.
// If none are provided, or if there is no entry for the given year, one is
// manufactured based on the default +link{FiscalCalendar.defaultMonth, month}
// and +link{FiscalCalendar.defaultDate, date}.
//
// @treeLocation Client Reference/System/Date
// @visibility external
//<

//> @attr fiscalCalendar.defaultMonth (integer : null : IRW)
//
// The default zero-based month-number to use for calculating fiscal dates when no
// +link{FiscalCalendar.fiscalYears, fiscal years} are provided. This value together
// with +link{fiscalCalendar.defaultDate} will be used as the start date for the
// fiscal years where no explicitly specified fiscalYear configuration is present.
// <br>
// See also +link{fiscalCalendar.defaultYearMode}.
//
// @visibility external
//<

//> @attr fiscalCalendar.defaultDate (integer : null : IRW)
//
// The default one-based day-number in the +link{fiscalCalendar.defaultMonth, specified month}
// to use for calculating fiscal dates when no +link{FiscalCalendar.fiscalYears, fiscal years}
// are provided. This value together
// with +link{fiscalCalendar.defaultMonth} will be used as the start date for the
// fiscal years where no explicitly specified fiscalYear configuration is present.
// <br>
// See also +link{fiscalCalendar.defaultYearMode}.
//
// @visibility external
//<

//> @type FiscalYearMode
//
// Strategies for calculating the FiscalYear within a +link{fiscalCalendar} from the
// specified +link{fiscalCalendar.defaultDate} and +link{fiscalCalendar.defaultMonth}
// If the specified fiscal year date starts in one calendar year and ends in the next.
//
// @value "end" The fiscalYear value for the date range will match the calendar year
//  in which the period ends. For example if the defaultDate and defaultMonth were set
//  to represent April 1st, the fiscal year starting on April 1st 2020 would end on
//  April 1st 2021. Setting the fiscalYearMode to <code>end</code> would mean the
//  fiscalYear value for this block would be 2021.
//
// @value "start" The fiscalYear value for the date range will match the calendar year
//  in which the period starts. For example if the defaultDate and defaultMonth were set
//  to represent April 1st, the fiscal year starting on April 1st 2020 would end on
//  April 1st 2021. Setting the fiscalYearMode to <code>start</code> would mean the
//  fiscalYear value for this block would be 2020.
// @visibility external
//<

//> @attr fiscalCalendar.defaultYearMode (FiscalYearMode : "end" : IRW)
//
// This attribute controls how the displayed fiscalYear value should be calculated for
// dates falling within a period not explicitly listed in the
// +link{fiscalCalendar.fiscalYears,fiscal years array}.
// <P>
// The +link{fiscalCalendar.defaultMonth} and +link{fiscalCalendar.defaultDate} will be
// used to calculate the start of the fiscal year period. The defaultYearMode
// determines whether the reported fiscalYear for this period matches the year in which
// the period starts or the year in which it ends (so whether a fiscal year spanning
// dates within both 2020 and 2021 is reported as fiscalYear 2020 or 2021).
// @visibility external
//<

//> @attr fiscalCalendar.fiscalYears (Array of FiscalYear : null : IRW)
//
// An array of +link{FiscalYear, FiscalYear objects} which each represent the start date of a
// single fiscal year.
//
// @visibility external
//<

//>    @classMethod date.setFiscalCalendar()
// Sets the global fiscal calendar, which is used for all calls to
// getFiscalYear() / getFiscalWeek() if those methods aren't passed a fiscalCalander.
//
// @param fiscalCalendar (FiscalCalendar) the object representing the start month and date of
//           the fiscal year in the current locale
// @visibility external
//<
setFiscalCalendar : function (fiscalCalendar) {
    if (!fiscalCalendar.fiscalYears) fiscalCalendar.fiscalYears = [];
    Date.prototype.fiscalCalendar = fiscalCalendar;
    // init the start/endDate values on any specified FiscalYear objects
    Date._getFiscalYearObjectForDate(new Date());
},

//>    @classMethod date.getFiscalCalendar()
// Returns the global +link{FiscalCalendar, FiscalCalendar object} representing the start month and
// date of the fiscal year in the current locale.
// @return (FiscalCalendar)    the FiscalCalendar object
// @visibility external
//<
getFiscalCalendar : function () {
    if (!Date.prototype.fiscalCalendar.fiscalYears) {
        Date.prototype.fiscalCalendar.fiscalYears = [];
    }
    return Date.prototype.fiscalCalendar;
},

//>    @classMethod date.getFiscalStartDate()
// Returns the start date of the fiscal year for the passed date.
//
// @param date (Date | number) the date, or the year-number, to get the fiscal year for
// @param [fiscalCalendar] (FiscalCalendar) the object representing the starts of one or more
//                              fiscal years
// @return (Date)    the start of the fiscal year for the passed date and fiscalCalendar
// @visibility external
//<
getFiscalStartDate : function (date, fiscalCalendar) {
    var fiscalYear = Date._getFiscalYearObjectForDate(date, fiscalCalendar);
    return new Date(fiscalYear.year, fiscalYear.month, fiscalYear.date);
},


getFiscalEndDate : function (date, fiscalCalendar) {
    var fy = Date._getFiscalYearObjectForDate(date, fiscalCalendar),
        nfy = Date.getFiscalYear(fy.fiscalYear + 1);
    if (nfy.year < fy.fiscalYear) nfy = Date.getFiscalYear(nfy.fiscalYear + 1);
    var endDate = new Date(nfy.startDate.getTime()-1);
    return endDate;
},


_getFiscalYearObjectForDate : function (date, fiscalCalendar) {

    fiscalCalendar = fiscalCalendar || Date.getFiscalCalendar();
    if (!fiscalCalendar.fiscalYears) fiscalCalendar.fiscalYears = [];

    var fiscalYears = fiscalCalendar.fiscalYears;

    var defaultStartDate = fiscalCalendar.defaultDate,
        defaultStartMonth = fiscalCalendar.defaultMonth;
    // If unspecified default to calendar years.
    if (defaultStartDate == null) defaultStartDate = 1;
    if (defaultStartMonth == null) defaultStartMonth = 0;

    // In order to rapidly find the fiscalYearObject associated with some date,
    // do a one-time calculation of the start and endDates of each specified fiscal year
    // and store them on the objects.

    var initialized = true;
    for (var i = 0; i < fiscalYears.length; i++) {
        if (fiscalYears[i].startDate == null || fiscalYears[i].endDate == null) {
            initialized = false;

            fiscalYears[i].startDate = Date.createDatetime(
                                        fiscalYears[i].year,
                                        fiscalYears[i].month,
                                        fiscalYears[i].date
                                       );
       }
    }
    fiscalYears.setSort({property: "startDate", direction: "ascending" });
    if (!initialized) {
        for (var i = 0; i < fiscalYears.length; i++) {
            var endDate;

            var fy = fiscalYears[i],
                nextFY = fiscalYears[i+1];
            // If the next entry in the fiscalYears array starts in the following year
            // (or later in the same year), consider that the end date for this FY.
            // Otherwise use the defaultDate/defaultMonth of the next year.
            // This allows the specified fiscalYears array to be sparse
            // (For example custom behavior could be specified for 2000 and 2010 only, and
            // every year in between will use the default month/date start)
            if (nextFY && (nextFY.year == fy.year || (nextFY.year == fy.year+1))) {
                fy.endDate = new Date(nextFY.startDate.getTime()-1);
            } else {

                fy.endDate = Date.createDatetime(
                                fy.year+1, defaultStartMonth, defaultStartDate);
                // reduce by 1ms so it's the end of the prev day
                // This will avoid confusion with whether it rolls over a year
                // if the date is actually jan 1st
                fy.endDate.setTime(fy.endDate.getTime()-1);
            }
        }
    }


    // If we're passed just a year value, return the fiscalYear definition where
    // 'fiscalYear' is set to the specified date (may have to be created)
    if (!isc.isA.Date(date)) {

        var fiscalYearObj = fiscalYears.find("fiscalYear", date);
        if (fiscalYearObj != null) {
             return fiscalYearObj;
        }

        // We know we need to create a new fiscalYear object who's fiscalYear
        // property will be set to the specified date value.
        var calendarYear = date;
        if (fiscalCalendar.defaultYearMode != "start" &&
            (defaultStartMonth != 0 || defaultStartDate != 1))
        {
            calendarYear -= 1;
        }
        // Build a default object and return it.

        var result = {
            year:calendarYear,
            fiscalYear:date,
            month:defaultStartMonth,
            date:defaultStartDate,
            startDate: isc.DateUtil.getStartOf(new Date(calendarYear, defaultStartMonth, defaultStartDate), "d")
        };
        return result;

    } else {
        var date_timestamp = date.getTime();
        // Array should already be sorted - re-sort just in case it was missed.
        fiscalYears.sortByProperty("startDate", Array.ASCENDING);
        for (var i = 0; i < fiscalYears.length; i++) {
            if (date_timestamp < fiscalYears[i].startDate.getTime()) break;
            if (date_timestamp <= fiscalYears[i].endDate.getTime()) {
                // date falls between start and end of the specified fiscal year so use it.
                return fiscalYears[i];
            }
        }

        // At this point we know we didn't have an entry in the fiscal years array
        // for this date, so create one based on the default start date
        var dateYear = date.getFullYear(),
            startDate = Date.createDatetime(dateYear,
                                          defaultStartMonth,
                                          defaultStartDate);
        // Date falls before default start date, shift back a year.
        if (startDate.getTime() > date_timestamp) {
            dateYear -= 1;
            startDate = Date.createDatetime(dateYear,
                                          defaultStartMonth,
                                          defaultStartDate);
        }

        // Calculate the endDate - the year it falls in will determine the reported
        // 'fiscalYear'.
        var endDate = Date.createDatetime(dateYear+1,
                                          defaultStartMonth,
                                          defaultStartDate);
        // Shunt back to the end of the prev day.
        endDate.setTime(endDate.getTime()-1);

        // If there's a specified fiscalYear in our array that starts before the
        // calculated endDate, truncate this year a little earlier to account for it.
        var endDate_timestamp = endDate.getTime();
        for (var i = 0; i < fiscalYears.length; i++) {

            if (endDate_timestamp < fiscalYears[i].endDate.getTime()) {
                continue;
            } else {
                if (endDate_timestamp > fiscalYears[i].startDate.getTime()) {
                    endDate = new Date(fiscalYears[i].startDate.getTime()-1);
                } else break;
            }
        }

        var fiscalYear = dateYear;
        // If we span 2 calendar years and the year mode is set to "end",
        // (or unset - since this is default behavior), increment the fiscal year to
        // match the end date.
        if (endDate.getFullYear() != startDate.getFullYear()
             && fiscalCalendar.defaultYearMode != "start")
        {
            if (endDate.getFullYear() < date.getFullYear()) {
                fiscalYear = date.getFullYear();

                var tempStart = new Date(fiscalYear, defaultStartMonth, defaultStartDate);
                if (date.getTime() > tempStart.getTime()) {
                    fiscalYear++;
                }
            } else {
                fiscalYear = endDate.getFullYear();
            }
        }

        return {
            year:dateYear,
            fiscalYear:fiscalYear,
            date:defaultStartDate,
            month:defaultStartMonth
        };

    }
},

//>    @classMethod date.setShowChooserFiscalYearPickers()
// Sets the global attribute that dictates whether the +link{DateChooser, choosers} shelled
// from +link{DateItem, DateItems} show a UI for working with Fiscal Years.
//
// @param showChooserFiscalYearPickers (boolean) whether to show Fiscal Year pickers in DateChoosers by default
// @visibility external
//<
setShowChooserFiscalYearPickers : function (showChooserFiscalYearPickers) {
    isc.DateItem.addProperties({
        showChooserFiscalYearPicker: showChooserFiscalYearPickers
    });
    isc.DateChooser.addProperties({
        showFiscalYearChooser: showChooserFiscalYearPickers
    });
},

//>    @classMethod date.setShowChooserWeekPickers()
// Sets the global attribute that dictates whether the +link{DateChooser, choosers} shelled
// from +link{DateItem, DateItems} show a UI for working with Weeks.
//
// @param showChooserWeekPickers (boolean) whether to show Fiscal Week pickers in DateChoosers by default
// @visibility external
//<
setShowChooserWeekPickers : function (showChooserWeekPickers) {
    isc.DateItem.addProperties({
        showChooserWeekPicker: showChooserWeekPickers
    });
    isc.DateChooser.addProperties({
        showWeekChooser: showChooserWeekPickers
    });
},


//>    @classMethod date.setFirstDayOfWeek()
// Sets the global attribute that dictates which day should be treated as the first day of the
// week in calendars and date calculations.  The parameter is expected to be an integer value
// between 0 (Sunday) and 6 (Saturday).
// <P>
// The default value is picked up from the current locale.
//
// @param firstDayOfWeek (int) the number of the day to use as the first day of the week
// @visibility external
//<
setFirstDayOfWeek : function (firstDayOfWeek) {
    if (isc.DateChooser) {
        if (firstDayOfWeek == null || firstDayOfWeek < 0 || firstDayOfWeek > 6)
            firstDayOfWeek = 0;
        isc.DateChooser.addProperties({firstDayOfWeek: firstDayOfWeek});
    }
},

//>    @classMethod date.getFirstDayOfWeek()
// Returns the global attribute that dictates which day should be treated as the first day of
// the week in calendars and date calculations.  The parameter is expected to be an integer
// value between 0 (Sunday) and 6 (Saturday).
// <P>
// The default value is picked up from the current locale.
//
// @return (int) the number of the day being used as the first day of the week
// @visibility external
//<
getFirstDayOfWeek : function () {
    if (isc.DateChooser) {
        return isc.DateChooser.getInstanceProperty("firstDayOfWeek");
    }
    return 0;
},



//>    @classMethod date.getFiscalYear()
// Returns the +link{FiscalYear} object for the fiscal year in which the passed date exists.
//
// @param date (Date | int) the date to get the fiscal year for
// @param [fiscalCalendar] (FiscalCalendar) the object representing the start of the fiscal period
// @return (FiscalYear) the +link{FiscalYear} object for the passed date
// @visibility external
//<
getFiscalYear : function (date, fiscalCalendar) {
    return Date._getFiscalYearObjectForDate(date, fiscalCalendar);
},

//>    @classMethod date.getFiscalWeek()
// Returns a date's week-number, according to the fiscal calendar
//
// @param date (Date) the date to get the fiscal year for
// @param [fiscalCalendar] (FiscalCalendar) the object representing the starts of fiscal years
// @return (int) the fiscal week for the passed date
// @visibility external
//<
_millisInADay: (1000 * 60 * 60 * 24),
getFiscalWeek : function (date, fiscalCalendar, firstDayOfWeek) {
    fiscalCalendar = fiscalCalendar || Date.getFiscalCalendar();

    var yearStart = Date.getFiscalStartDate(date, fiscalCalendar),
        logicalYearStart = Date.getLogicalDateOnly(yearStart),
        logicalDate = date.logicalDate ? date : Date.getLogicalDateOnly(date);
    return this._getWeekOffset(logicalDate, logicalYearStart, firstDayOfWeek);
},

// Used by getWeek() / getFiscalWeek()
_stackCount:0,
_getWeekOffset : function (date, startDate, firstDayOfWeek) {
    // this method isn't based on january 1 - instead, it's based on the start of the week
    // containing the first thursday in the year (catering for firstDayOfWeek)
    // - take the start of the passed date's week and divide the delta by 7 days
    // - add 1
    if (firstDayOfWeek == null) {
        firstDayOfWeek = isc.DateChooser.getInstanceProperty("firstDayOfWeek");
    }
    var weekStart = isc.DateUtil.getStartOf(date, "w", true, firstDayOfWeek);
    var days = (weekStart.getTime() - startDate.getTime()) / (24*60*60000);
    var weeks = Math.floor(days / 7);

    return weeks + 1;
},

//>!BackCompat 2005.11.3
// -- Older depracated synonym of setNormalDisplayFormat
//>    @classMethod        Date.setFormatter()
//  Set the formatter for all date objects to the method name passed in.  After this call
//  all <code>theDate.toNormalDate()</code> calls will fall through to this formatter function to
//  return the date as a string.
//        @group    dateFormatting
//        @param    functionName    (string)    name of a date formatter method on this Date
//      @visibility internal
//<

setFormatter : function (formatter) {
    Date.setNormalDisplayFormat(formatter);
},
//<!BackCompat

//>    @classMethod Date.setLocaleStringFormatter() (A)
// Set default the +link{Date.iscToLocaleString()} formatter for all date instances.
//
//        @param    format (DateDisplayFormat | function) new formatter for iscToLocaleString()
//        @group    dateFormatting
//      @visibility internal
//<

setLocaleStringFormatter : function (functionName) {
    if (isc.isA.Function(Date.prototype[functionName]) || isc.isA.Function(functionName))
        Date.prototype.localeStringFormatter = functionName;
},

// Localizing dayName / monthNames
//> @classAttr  Date.shortDayNames  (Array : null : IRWA)
// This property may be set to an array of names of days of the week. <br>
// For example:
// <pre>
// ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
// </pre>
// The appropriate day name will then be returned from +link{date.getShortDayName()}, and may
// be used whenever SmartClient components display day-names (for example in the
// +link{class:DateItem, DateItem class}).<br>
// Note: For US based applications the first item in the array should be the name for Sunday,
// then Monday, Tuesday, etc. For browsers with different locales this may vary.
// To determine the first day for some locale, you can run the following code:
// <pre>
//    alert(new Date(2000, 0, 2).getDay());
// </pre>
// You should see an alert with a number between zero and 6. This represents the numerical
// 'day' value for Sunday for your browser's locale, since Jan 2nd 2000 was a Sunday.
// Therefore if this code alerted the number 6, Sunday should appear last in your list
// of day-names, and Monday first.
// @group i18nMessages
// @visibility external
//<



//> @classAttr  Date.dayNames  (Array : null : IRWA)
// This property may be set to an array of names of days of the week. <br>
// For example:
// <pre>
// ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
// </pre>
// The appropriate day name will then be returned from +link{date.getDayName()}, and may
// be used whenever SmartClient components display day-names (for example in the
// +link{class:DateItem, DateItem class}).<br>
// @group i18nMessages
// @visibility external
//<
dayNames: ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],

//> @classAttr  Date.shortMonthNames  (Array : null : IRWA)
// This property may be set to an array of shortened month-names.<br>
// For example:
// <pre>
// ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
// </pre>
// The appropriate month name will then be returned from +link{date.getShortMonthName()},
// and may be used whenever SmartClient components display month-names (for example in the
// +link{class:DateItem, DateItem class}).
// @group i18nMessages
// @visibility external
//<


derivedShortMonthNameLength: 3,

//> @classAttr  Date.monthNames  (Array : null : IRWA)
// This property may be set to an array of names of months.<br>
// For example:
// <pre>
// ["January", "February", "March", "April", "May", "June", "July",
//  "August", "September", "October", "November", "December"]
// </pre>
// The appropriate month name will then be returned from +link{date.getMonthName()},
// and may be used whenever SmartClient components display month-names (for example in the
// +link{class:DateItem, DateItem class}).
// @group i18nMessages
// @visibility external
//<
monthNames: ["January","February","March","April","May","June","July","August","September",
             "October","November","December"],

//>    @classMethod date.getShortMonthNames() (A)
// Return an array of the short names of each month, suitable for use in a selection list, etc.
// If +link{Date.shortMonthNames} is specified, this list will be used - by default, all locales
// specify shortMonthNames.
// @param length (int) maximum length of each day string - default is no maximum (full strings)
// @return (Array of String) array of short month names
// @group dateFormatting
//<
getShortMonthNames : function (length) {
    var rawNames = Date.shortMonthNames;



    // NOOP starts - this block of code will never run, because shortMonthNames will alway be set
    if (rawNames == null) rawNames = Date._derivedShortMonthNames;
    if (rawNames == null) {
        var list = Date._derivedShortMonthNames = [];
        for (var i = 0; i < 12; i++) {
            // Changed the day in this synthetic date to 2 in order to derive the
            // correct month in timezones that are ahead of GMT (if you convert
            // midnight on the first of a month to UTC in such timezones, you
            // get the previous month...)
            var date = Date.createLogicalDate(2000,i,2);
            // have deriveShortMonthNames() return the shortened strings according to the
            // internal default (3 chars)
            list[i] = date.deriveShortMonthName(Date.derivedShortMonthNameLength);
        }
        rawNames = Date._derivedShortMonthNames;
    }
    // NOOP ends

    var names = [];
    for (var i =0; i< 12; i++) {
        if (!length) {
            // zero or null length - return the full rawName - we used to default to 3 chars,
            // but that's a bit pointless, since the rawNames are already *short*MonthNames,
            // but they may not be 3 chars long, or of *any* fixed length
            names[i] = rawNames[i];
        } else {
            names[i] = rawNames[i].substring(0,length);
        }
    }
    return names;
},

//>    @classMethod date.getMonthNames() (A)
// Return an array of the full names of each month, suitable for use in a selection list, etc.
// If +link{Date.monthNames} is specified, this list will be used. Otherwise the value
// will be derived from the native browser date formatters.  Note, if we have to derive names
// from the native browser date string, the day names may be in an abbreviated form, like the
// result of calling +link{getShortMonthNames()} - we have no control over this, we have to work
// with whatever the browser returns, which may vary by browser as well as locale.  If a
// consistent and correct set of day names is important in your application, ensure that
// <code>Date.monthNames</code> is set.
// @group dateFormatting
// @return (Array of String) array of month names
//<
getMonthNames : function () {
    var rawNames = Date.monthNames;
    if (rawNames == null) rawNames = Date._derivedMonthNames;
    if (rawNames == null) {
        var list = Date._derivedMonthNames = [];
        for (var i = 0; i < 12; i++) {
            // Changed the day in this synthetic date to 2 in order to derive the
            // correct month in timezones that are ahead of GMT (if you convert
            // midnight on the first of a month to UTC in such timezones, you
            // get the previous month...)
            var date = Date.createLogicalDate(2000,i,2);
            list[i] = date.deriveMonthName();
        }
        rawNames = Date._derivedMonthNames;
    }
    return rawNames;
},

//>    @classMethod date.getShortDayNames() (A)
// Return an array of the short names of each day, suitable for use in a selection list, etc.
// Day names are picked up from a +link{Date.shortDayNames} list specified in each locale.
// @group dateFormatting
// @param length (int) maximum length of each day string - default is no maximum (full strings)
// @return (Array of String) array of short day names
//<
getShortDayNames : function (length) {
    length = length || 3;
    var rawNames = Date.shortDayNames;
    if (rawNames == null) rawNames = Date._derivedShortDayNames;
    if (rawNames == null) {
        Date._derivedShortDayNames = [];
        var dateObj = new Date();
        dateObj.setDate(1);
        if (dateObj.getDay() > 0) dateObj.setDate(dateObj.getDate() + (7-dateObj.getDay()));
        var startDate = dateObj.getDate();
        for (var i = 0; i < 7; i++) {
            dateObj.setDate(startDate + i);
            Date._derivedShortDayNames[i] = dateObj.deriveShortDayName();
        }
        rawNames = Date._derivedShortDayNames;
    }
    var names = [];
    for (var i = 0; i < 7; i++) {
        names[i] = rawNames[i].substring(0,length);
    }
    return names;
},

//>    @classMethod date.getDayNames() (A)
// Return an array of the full names of each day, suitable for use in a selection list, etc.
// Day names will be picked up from +link{Date.dayNames} if specified - otherwise derived
// from the native browser date string.  Note, if we have to derive names from the native
// browser date string, the day names may be in an abbreviated form, like the result of
// calling +link{getShortDayNames()} - we have no control over this, we have to work with
// whatever the browser returns, which may vary by browser as well as locale.  If a consistent
// and correct set of day names is important in your application, ensure that
// <code>Date.dayNames</code> is set.
// @group dateFormatting
// @return (string[]) array of day names
//<
getDayNames : function () {
    var rawNames = Date.dayNames;
    if (rawNames == null) rawNames = Date._derivedDayNames;
    if (rawNames == null) {
        Date._derivedDayNames = [];
        var dateObj = new Date();
        dateObj.setDate(1);
        if (dateObj.getDay() > 0) dateObj.setDate(dateObj.getDate() + (7-dateObj.getDay()));
        var startDate = dateObj.getDate();
        for (var i = 0; i < 7; i++) {
            dateObj.setDate(startDate + i);
            Date._derivedShortDayNames[i] = dateObj.deriveDayName();
        }
        rawNames = Date._derivedDayNames;
    }
    var names = [];
    for (var i = 0; i < 7; i++) {
        names[i] = rawNames[i];
    }
    return names;
},

//> @classAttr Date.weekendDays (Array of int : [0, 6] : IR)
// Days that are considered "weekend" days.   Values should be the integers returned by the
// JavaScript built-in Date.getDay(), eg, 0 is Sunday and 6 is Saturday.  Override to
// accommodate different workweeks such as Saudi Arabia (Saturday -> Wednesday) or Israel
// (Sunday -> Thursday).
//
// @visibility external
//<

//> @classMethod Date.setWeekendDays()
// Sets the days that are considered +link{Date.weekendDays, weekend days}.  The parameter
// should be array of the integers returned by the JavaScript built-in Date.getDay(), eg, 0 is
// Sunday and 6 is Saturday.  Override to accommodate different workweeks such as Saudi Arabia
// (Saturday -> Wednesday) or Israel (Sunday -> Thursday).
//
// @param weekendDays (Array of Integer) the array of day-numbers to assign as weekend days
// @visibility external
//<
setWeekendDays : function (weekendDays) {
    Date.weekendDays = weekendDays;
},

//> @classMethod Date.getWeekendDays()
// Return an array of days that are considered "weekend" days. Values will be the integers
// returned by the JavaScript built-in Date.getDay(), eg, 0 is Sunday and 6 is Saturday.
// Override +link{date.weekendDays} to accommodate different workweeks such as Saudi Arabia
// (Saturday -> Wednesday) or  Israel (Sunday -> Thursday).
// @group dateFormatting
//
// @return (Array of integer) array of weekend days
// @visibility external
//<
getWeekendDays : function () {
    var daysArr = Date.weekendDays;
    if (daysArr == null) daysArr = Date._derivedWeekendDays;
    if (daysArr == null) {
        daysArr = Date._derivedWeekendDays = [0, 6];
    }
    return daysArr;
},

getFormattedDateRangeString : function (fromDate, toDate) {
    if (fromDate != null && !isc.isA.Date(fromDate)) {
        fromDate = null;
    }
    if (toDate != null && !isc.isA.Date(toDate)) {
        toDate = null;
    }
    var fromMonth = fromDate ? fromDate.getMonth() : null,
        fromMonthName = fromDate ? fromDate.getShortMonthName() : null,
        fromYear = fromDate ? fromDate.getFullYear() : null,
        fromDay = fromDate ? fromDate.getDate() : null,
        toMonth = toDate ? toDate.getMonth() : null,
        toMonthName = toDate ? toDate.getShortMonthName() : null,
        toYear = toDate ? toDate.getFullYear() : null,
        toDay = toDate ? toDate.getDate() : null,
        result = ""
    ;

    if (fromDate && toDate) {
        if (fromYear == toYear) {
            // dates are in the same year - check the months
            if (fromMonth == toMonth) {
                // dates are in the same month - check the day-numbers
                if (fromDay == toDay) {
                    // dates are the same - use just the one date
                    result = fromMonthName + " " + fromDate.getDate() + ", " + fromYear;
                } else {
                    // day-numbers are different, use "month start - end, year"
                    result = fromMonthName + " " + fromDate.getDate() + " - " +
                        toDate.getDate() + ", " + fromYear;
                }
            } else {
                // dates are in different months, use "month start - month end, year"
                result = fromMonthName + " " + fromDate.getDate() + " - " +
                    toMonthName + " " + toDate.getDate() + ", " + fromYear;
            }
        } else {
            // different years - use "month start year - month end year"
                result = fromMonthName + " " + fromDate.getDate() + ", " + fromYear + " - " +
                    toMonthName + " " + toDate.getDate() + ", " + toYear;
        }
    } else if (fromDate) {
        // only a fromDate provided use "month start - end, year"
        result = fromMonthName + " " + fromDate.getDate() + ", " + fromYear;
    } else if (toDate) {
        // only a toDate provided use "month start - end, year"
        result = toMonthName + " " + toDate.getDate() + ", " + toYear;
    }

    return result;
}

});

//
//    add methods to the Date.prototype for additional formatting options
//
isc.addMethods(Date.prototype, {

//>    @method        date.duplicate()    (A)
//      Copy the value of this date into a new Date() object for independent manipulation
//  @visibility external
//<
duplicate : function () {
    var newDate = new Date();
    newDate.setTime(this.getTime());
    newDate.logicalDate = this.logicalDate;
    newDate.logicalTime = this.logicalTime;
    newDate._fromRelativeDate = this._fromRelativeDate;
    newDate._relativeDateTimestamp = this._relativeDateTimestamp
    return newDate;
},

//>    @method        date.clearTimeFields()    (A)
//            Zero-out the time fields for a date.
//        @group    dateFormatting
//<
clearTimeFields : function () {
    this.setHours(0);
    this.setMinutes(0);
    this.setSeconds(0);
    this.setMilliseconds(0);
    return this;
},




// Determine the day name from this.toString()
deriveShortDayName : function (length) {
    var string = this.toString();
    if (length == null || length <=0 || length > 3) length = 3;
    return string.substring(0,length);
},

// Determine the day name from this.toString(), without a target length
deriveDayName : function () {
    var string = this.toString();
    var length = string.indexOf(" ");
    return string.substring(0,length);
},

//>    @method        date.getShortDayName()
// Return the abbreviated (up to 3 chars) day of week name for this date (Mon, Tue, etc).
// To modify the value returned by this method, set +link{Date.shortDayNames}
//
//        @group    dateFormatting
//      @param  length  (int)    Number of characters to return (Defaults to 3, can't be
//                                  longer than 3)
//        @return        (string)    Abbreviated day name
//      @visibility external
//<
getShortDayName : function () {
    return Date.getShortDayNames()[this.getDay()];
},

//>    @method        date.getDayName()
// Return the full day of week name for this date (Monday, Tuesday, etc).
// To modify the value returned by this method, set +link{Date.dayNames}
//
// @group    dateFormatting
// @return        (string)    Day name
// @visibility external
//<
getDayName : function () {
    return Date.getDayNames()[this.getDay()];
},

// deriveShortMonthNames() - figure out the names of months from the native browser
// date formatting methods.
deriveShortMonthName : function (length) {
    // Use this.toUTCString - to work around Opera's different toString format
    var string = this.toUTCString();
    var start = 8;  // The correct start point if we have a 2-digit day portion in the date

    var defaultLength = Date.derivedShortMonthNameLength;
    if (length == null || length < 0 || length > defaultLength) length = defaultLength;

    if (string.substring(6, 7) == ' ') {  // we have a single-digit day number - only IE
                                          // does this, the others put a leading 0 in
        start = 7;
    }
    return string.substring(start, (start+length));
},

deriveMonthName : function () {
    // Use this.toUTCString - to work around Opera's different toString format
    var string = this.toUTCString();
    var start = 8;  // The correct start point if we have a 2-digit day portion in the date
    if (string.substring(6, 7) == ' ') {  // we have a single-digit day number - only IE
                                          // does this, the others put a leading 0 in
        start = 7;
    }
    var length = string.indexOf(" ", start);
    return string.substring(start, (start+length));
},


//>    @method date.getShortMonthName()
// Return the abbreviated name of the month for this date (Jan, Feb, etc)
// To modify the value returned by this method,
// <smartclient>set +link{Date.shortMonthNames}</smartclient>
// <smartgwt>use {@link com.smartgwt.client.util.DateUtil#setShortMonthNames()}</smartgwt>.
// @param length (int) Number of characters to return (Defaults to 3, can't be longer than 3)
// @return (string) Abbreviated month name (3 character string)
// @group dateFormatting
// @visibility external
//<
getShortMonthName : function (length) {
    return Date.getShortMonthNames(length)[this.getMonth()];
},

//>    @method        date.getMonthName()
// Return the full name of the month for this date (January, February, etc)
// To modify the value returned by this method,
// <smartclient>set +link{Date.shortMonthNames}</smartclient>
// <smartgwt>use {@link com.smartgwt.client.util.DateUtil#setMonthNames()}</smartgwt>.
// @group    dateFormatting
// @return        (string)    Month name
// @visibility external
//<
getMonthName : function () {
    return Date.getMonthNames()[this.getMonth()];
},

//>    @method        date.getShortYear()
//      Return a 2 digit year for this date.
//    @group    dateFormatting
//    @return        (string)    year number, padded to 2 characters
//  @visibility external
//<
getShortYear : function () {
    var year = this.getFullYear();
    return (year % 100).stringify(2);
},


firstWeekIncludesDay: 4,
getYearStart : function (firstDayOfWeek) {
    if (firstDayOfWeek == null) {
        firstDayOfWeek = isc.DateChooser.getInstanceProperty("firstDayOfWeek");
    }

    var yearStart = Date.createLogicalDate(this.getFullYear(),0,1);

    if (yearStart.getDay() > this.firstWeekIncludesDay && firstDayOfWeek <= this.firstWeekIncludesDay) {
        // by default, jan 1 is friday or saturday and firstDayOfWeek <= Thursday
        // - the first (thursday) in the year is next week
        yearStart.setDate(yearStart.getDate() + 7);
    } else if (yearStart.getDay() < firstDayOfWeek) {
        // eg Jan 1 is Sunday but firstDayOfWeek is Monday - Jan 1 is last week
        yearStart.setDate(yearStart.getDate() + 7);
    }

    yearStart = isc.DateUtil.getStartOf(yearStart, "W", true, firstDayOfWeek);
    return yearStart;
},

//>    @method date.getWeek()
// Returns an integer containing the week number
// @group dateFormatting
// @return (int) week number, starting with 1
// @visibility external
//<
getWeek : function (firstDayOfWeek) {
    var logicalDate = this;

    // Normalize to a logical date, and compare with the logical yearStart - this will get rid
    // of any oddities around time of day and custom timezones etc (any datetime within the
    // logical day will round to the same logicalDate object)
    if (!this.logicalDate) {
        logicalDate = Date.getLogicalDateOnly(this);
    }

    if (firstDayOfWeek == null) {
        firstDayOfWeek = isc.DateChooser.getInstanceProperty("firstDayOfWeek");
    }

    // get the start of the week that contains the first (Thursday) after January 1
    var yearStart = logicalDate.getYearStart(firstDayOfWeek);

    // make sure it's a logical date
    if (!yearStart.logicalDate) yearStart = Date.getLogicalDateOnly(yearStart);

    if (logicalDate.getTime() < yearStart.getTime()) {
        // this date is before the calculated yearStart - return a week offset for this date
        // into the previous year
        return isc.DateUtil.getAbsoluteDate("-1w", logicalDate).getWeek(firstDayOfWeek);
    }

    // divide the day delta between this date and the yearStart by 7 and add 1
    var result = Math.floor((logicalDate.getTime() - yearStart.getTime()) / (60000 * 60 * 24 * 7)) + 1;
    return result;
},

getFiscalCalendar : function () {
    return Date.getFiscalCalendar();
},

//>    @method date.getFiscalYear()
// Returns the +link{FiscalYear} object appropriate for the the current date, according to the
// +link{FiscalCalendar, FiscalCalendar}.
// @return (FiscalYear) the fiscal year object
// @visibility external
//<
getFiscalYear : function (fiscalCalendar) {
    return Date.getFiscalYear(this, fiscalCalendar);
},

//>    @method date.getFiscalWeek()
// Returns the fiscal week number of the current date, according to the global
// +link{Date.setFiscalCalendar, FiscalCalendar}.
// @param [fiscalCalendar] (FiscalCalendar) the object representing the starts of fiscal years
// @return (int) the week number, offset from the start of the fiscal period
// @visibility external
//<
getFiscalWeek : function (fiscalCalendar, firstDayOfWeek) {
    return Date.getFiscalWeek(this, fiscalCalendar, firstDayOfWeek);
},

//
// Date Formatters (toNormalDate(), toShortDate(), etc.)
//
// Date formatters are applied to date objects to convert them into strings for display.
// Dates are intended to be localizable.
// For localization, a developer would typically set either the shortDateFormatter or
// normalDateFormatter, as well as the inputDateFormat, and then call
// "toNormalDate()" / "toShortDate()" and "parseInput()" as normal.

//>    @method        date.toDateStamp()
//            Return this date in the format (UTC timezone):
//                <code><i>YYYYMMDD</i>T<i>HHMMSS</i>[Z]</code>
//        @group    dateFormatting
//        @return                    (string)    formatted date string
//  @visibility external
//<
toDateStamp : function () {
    return    this.getUTCFullYear()
          + (this.getUTCMonth()+1).stringify()
          + this.getUTCDate().stringify()
          + "T"
          +    this.getUTCHours().stringify()
          + this.getUTCMinutes().stringify()
          + this.getUTCSeconds().stringify()
          + "Z";
},

//>    @method date.toNormalDate()
// Returns the date as a formatted string using the format set up via the
// <code>setNormalDisplayFormat()</code> method. Note that the default formatter for this
// method is <code>"toLocaleString"</code>.
// @group   dateFormatting
// @param format (DateDisplayFormat) Optional Format for the date returned
// @return  (string) formatted date string
// @visibility external
//<
// This method is used by our data components such as ListGrid to display long format dates.
// @param useCustomTimezone (boolean) If true, format the date using the timezone
//  setDefaultDisplayTimezone() rather than the native browser locale.
//  Defaults to true.
//  Has no effect if no custom timezone applied
//  * Note that the native browser formatters including toLocaleString won't respect the
//    developer specified timezone of course. We could workaround this (create a new date, shift
//    by offset between specified timezone and native timezone, and call the native formatter on that)
//    but we currently don't.
toNormalDate : function (formatter, useCustomTimezone) {


    if (!formatter) formatter = this.formatter;
    // fire the formatter in the scope of this date, so date is available as 'this'

    if (isc.isA.Function(formatter)) {
        return formatter.apply(this, [useCustomTimezone])
    } else if (this[formatter]) {
        return this[formatter](useCustomTimezone);
    } else if (isc.isA.String(formatter)) {
        return isc.DateUtil.format(this, formatter);  // WWW - what about useCustomTimezone??
    }
},

toNormalDateTime : function (formatter, useCustomTimezone) {
    return this.toNormalDatetime(formatter, useCustomTimezone);
},

//>    @method date.toNormalDatetime()
// Returns the datetime as a formatted string using the format set up via the
// <code>setNormalDatetimeDisplayFormat()</code> method.
// @group   dateFormatting
// @param format (DateDisplayFormat) Optional Format for the date returned
// @param [useCustomTimezone] (Boolean) If a custom timezone has been set via
//   Time.setDefaultDisplayTimezone(), by default date formatters will respect this timezone.
//   To suppress this behavior, this parameter should be set to false.
// @return  (string) formatted date string
// @visibility external
//<
toNormalDatetime : function (formatter, useCustomTimezone) {
    if (!formatter) formatter = this.datetimeFormatter;
    return this.toNormalDate(formatter, useCustomTimezone);
},

//>    @method date.toShortDate()
// Returns the date as a formatted string using the format set up via the
// <code>setShortDisplayFormat()</code> method.
// @group   dateFormatting
// @param format (DateDisplayFormat) Optional Format for the date returned
// @param [useCustomTimezone] (Boolean) If a custom timezone has been set via
//   Time.setDefaultDisplayTimezone(), by default date formatters will respect this timezone.
//   to suppress this behavior, this parameter should be set to false.
// @return  (string) formatted date string
// @visibility external
//<

toShortDate : function (formatter, useCustomTimezone) {
    if (!formatter) formatter = this._shortFormat;
    if (isc.isA.Function(formatter)) return formatter.apply(this, [useCustomTimezone]);
    else if (isc.isA.Function(this[formatter])) {
        if (formatter == "toSerializeableDate") return this[formatter]();
        return this[formatter](useCustomTimezone);
    } else if (isc.isA.String(formatter)) {
        return isc.DateUtil.format(this, formatter);  // WWW - what about useCustomTimezone??
    }

    isc.logWarn("Date.toShortDate() specified formatter not understood:" + formatter);
    return this.toUSShortDate();

},


//>    @method date.toShortDateTime()
// Returns the datetime as a formatted string using the format set up via the
// <code>setShortDatetimeDisplayFormat()</code> method.
// @group   dateFormatting
// @param format (DateDisplayFormat) Optional Format for the date returned
// @param [useCustomTimezone] (Boolean) If a custom timezone has been set via
//   Time.setDefaultDisplayTimezone(), by default date formatters will respect this timezone.
//   to suppress this behavior, this parameter should be set to false.
// @return  (string) formatted date string
// @visibility external
//<



toShortDateTime : function (formatter, useCustomTimezone) {
    return this.toShortDatetime(formatter,useCustomTimezone);
},

toShortDatetime : function (formatter, useCustomTimezone) {
    if (!formatter) formatter = this._shortDatetimeFormat;
    return this.toShortDate(formatter, useCustomTimezone);
},


//>    @method date.setDefaultDateSeparator
// Sets a new default separator that will be used when formatting dates. By default, this
// is a forward slash character: "/"
// @group dateFormatting
// @param separator (string) separator to use in dates
// @visibility external
//<
setDefaultDateSeparator : function (separator) {
    this._shortDateTemplate = [,,,,separator,,,,,separator,,,,null];
    this._separator = separator;
},

//>    @method date.getDefaultDateSeparator
// gets the default date separator string
// @group dateFormatting
// @return(string) the default date separator
// @visibility external
//<
getDefaultDateSeperator : function (separator) {
    if (this._separator) return this._separator;
    else return "/";
},


_shortDateTemplate:[,,,,"/",,,,,"/",,,,null],
_$MDY:"MDY",
_$DMY:"DMY",
_$YMD:"YMD",
_$MDY:"MDY",

// _applyTimezoneOffset()
// shift a date by some arbitrary number of hours/minutes
// third parameter allows you to specify the starting date time [result of date.getTime()]
// to offset from
_applyTimezoneOffset : function (hourOffset, minuteOffset, dateTime) {
    if (dateTime == null) dateTime = this.getTime();
    if (isc.isA.Number(hourOffset)) dateTime += (3600000 * hourOffset);
    if (isc.isA.Number(minuteOffset)) dateTime += (60000 * minuteOffset);
    this.setTime(dateTime);
},

// _getTimezoneOffsetDate()
// This is a helper method - given a date with a certain UTC time, apply an explicit timezone
// offset to return a date where the UTC time is offset by the specified hours/minutes.
// We'll use this when formatting dates for display in arbitrary local times [so we can't just
// use the native browser local timezone methods like getHours()]

_getTimezoneOffsetDate : function (hourOffset, minuteOffset) {
    var offsetDate = Date._timezoneOffsetDate;
    if (offsetDate == null) offsetDate = Date._timezoneOffsetDate = new Date();

    offsetDate._applyTimezoneOffset(hourOffset, minuteOffset, this.getTime());
    return offsetDate;

},


// _toShortDate()
// Internal method to give us a shortDate - either DD/MM/YYYY, MM/DD/YYYY or YYYY/MM/DD.
// this will be passed "MDY" / "DYM" / etc. as a format parameter.
// useCustomTimezone parameter: use the hour and minute offset specified by
// Time.setDefaultDisplayTimezone() rather than the native browser local timezone
_$zero:"0",
_toShortDate : function (format, useCustomTimezone) {

    // if this is a "logical date", don't use the developer-specified custom timezone when
    // formatting. Typically handled by DBC's passing in the useCustomTimezone parameter, but
    // we can also check for the logical date marker

    if (useCustomTimezone == null) {
        useCustomTimezone = !this.logicalDate;
    }
    var template = this._shortDateTemplate,
        month,day,year;

    // Browser native locale timezone
    if (!useCustomTimezone || !isc.Time._customTimezone) {
        month = this.getMonth()+1;
        day = this.getDate();
        year = this.getFullYear();

    // Developer specified custom timezone
    } else {
        var offsetDate = this._getTimezoneOffsetDate(
                            isc.Time.getUTCHoursDisplayOffset(this),
                            isc.Time.getUTCMinutesDisplayOffset(this)
                         );

        month = offsetDate.getUTCMonth() + 1;
        day = offsetDate.getUTCDate();
        year = offsetDate.getUTCFullYear();
    }

    var monthIndex, dayIndex, yearIndex;

    if (format == this._$MDY) {
        monthIndex = 0;
        dayIndex = 5;
        yearIndex = 10;
    } else if (format == this._$DMY) {
        dayIndex = 0;
        monthIndex = 5;
        yearIndex = 10;
    } else if (format == this._$YMD) {
        yearIndex = 0;
        monthIndex = 5;
        dayIndex = 10
    // Unlikely - don't bother avoiding string alloc's for every one of these options
    } else {
        dayIndex = format.indexOf("D")*5;
        yearIndex = format.indexOf("Y")*5;
        monthIndex = format.indexOf("M")*5;
    }

    // Note: each number has 4 slots so it can accommodate a full year
    // For month/day - if we need a leading zero, fill the first slot with it
    // Use fillNumber to fill 3 slots even though we have a max of 2 digits to ensure
    // the last slot gets cleared out if it was populated by a year already.
    template[dayIndex] = day < 10 ? this._$zero : null
    isc._fillNumber(template, day, dayIndex+1, 3);

    template[monthIndex] = month < 10 ? this._$zero : null
    isc._fillNumber(template, month, monthIndex+1, 3);

    template[yearIndex + 1] = null;
    isc._fillNumber(template, year, yearIndex, 4);
    return template.join(isc.emptyString);
},

//>    @method        date.toUSShortDate()
//            Return this date in the format: <code>MM/DD/YYYY</code>
//        @group    dateFormatting
//        @return                    (string)    formatted date string
//  @visibility external
//<
toUSShortDate : function (useCustomTimezone) {
    return this._toShortDate(this._$MDY, useCustomTimezone);
},

// _toShortTime - returns the time portion of the date in HH:MM
_timeTemplate:[null,null],
_toShortTime : function (useCustomTimezone) {

    return isc.Time.toShortTime(this, "toShortPadded24HourTime");
},

//>    @method        date.toUSShortDateTime()
//  Return this date in the format: <code>MM/DD/YYYY HH:MM</code>
//
//        @group    dateFormatting
//        @return                    (string)    formatted date string
//  @visibility external
//<
toUSShortDateTime : function (useCustomTimezone) {
    return this.toUSShortDatetime(useCustomTimezone);
},


toUSShortDatetime : function (useCustomTimezone) {
    return this.toUSShortDate(useCustomTimezone) + " " + this._toShortTime(useCustomTimezone);
},


//>    @method        date.toEuropeanShortDate()
//            Return this date in the format: <code>DD/MM/YYYY</code>
//        @group    dateFormatting
//        @return                    (string)    formatted date string
//      @visibility external
//<
toEuropeanShortDate : function (useCustomTimezone) {
    return this._toShortDate(this._$DMY, useCustomTimezone);
},

//>    @method        date.toEuropeanShortDateTime()
// Return this date in the format: <code>DD/MM/YYYY HH:MM</code>.
//        @group    dateFormatting
//        @return                    (string)    formatted date string
//      @visibility external
//<
toEuropeanShortDateTime : function (useCustomTimezone) {
    return this.toEuropeanShortDatetime();
},


toEuropeanShortDatetime : function (useCustomTimezone) {
    return this.toEuropeanShortDate(useCustomTimezone) + " " +
            this._toShortTime(useCustomTimezone);
},

//> @method date.toJapanShortDate()
// Return the date in this format: <code>YYYY/MM/DD</code>
// @group dateFormatting
// @return (string) formatted date string
// @visibility external
//<
toJapanShortDate : function (useCustomTimezone) {
    return this._toShortDate(this._$YMD, useCustomTimezone);
},

//>    @method        date.toJapanShortDateTime()
//            Return this date in the format: <code>YYYY/MM/DD HH:MM:SS</code>
//        @group    dateFormatting
//        @return                    (string)    formatted date string
//      @visibility external
//<
toJapanShortDateTime : function (useCustomTimezone) {
    return this.toJapanShortDatetime(useCustomTimezone);
},


toJapanShortDatetime : function (useCustomTimezone) {
    return this.toJapanShortDate(useCustomTimezone) + " " + this._toShortTime(useCustomTimezone);
},

//>    @method        date._serialize()    (A)
//            Serialize this date to a string in a format that can be reinstantiated back into a date.
//                <code>$$DATE$$:<i>YYYY</i>-<i>MM</i>-<i>DD</i></code>
//        @group    dateFormatting
//        @return                    (string)    formatted date string
//      @visibility internal
//<
_serialize : function () {
    if (isc.Comm._legacyJSMode) {
        // legacy mode: add $$DATE$$ that only our server-side JS parser understands
        return isc.SB.concat('"' + this.toDBDate(), '"');
    } else {
        // any other caller: return code that would reconstruct the same Date in a JS
        // interpreter

        return isc.SB.concat("new Date(", this.getTime(), ")");
    }
},



//> @groupDef dateFormatAndStorage
// The SmartClient system has the following features for handling Date and Time type values
// within DataSources and databound components.
// <P>
// DataSources and databound components may define fields of type <code>date</code>,
// <code>time</code>, or <code>datetime</code>.
// <P>
// <h3>"date" handling</h3>
// <P>
// Fields of type +link{type:FieldType,date} are considered to be logical Dates with no time
// value, such as a holiday or birthday.  In the browser, values for "date" fields are stored
// as Date objects, but when formatted for display to the user, they are typically displayed
// without any time information.
// <P>
// When using the SmartClient server framework, "date" values are automatically transmitted
// with year, month and day preserved and time value ignored.
// <P>
// When sent or received in XML or JSON, date field values should be serialized in the
// +externalLink{http://www.w3.org/TR/xmlschema-2/#dateTime,XML Schema date format} -
// <code>YYYY-MM-DD</code> - are expected to be received in the same format.  Any time value
// present for a "date" field is ignored.
// <smartclient>
// <P>
// The +link{DateUtil.createLogicalDate()} method may be used to create a new Date object to
// represent a logical date value on the browser.
// </smartclient>
// <smartgwt>
// <P>
// The DateUtil.createLogicalDate() method may be used to create a new Date object to represent
// a logical date value on the browser.
// </smartgwt>
// <P>
// System wide formatting for dates may be controlled via the
// +link{Date.setNormalDisplayFormat()} and +link{Date.setShortDisplayFormat()} methods.
// <P>
// <h3>"datetime" handling</h3>
// <P>
// Fields of type +link{type:FieldType,datetime} are dates with full time information.
// In the browser, values for datetime fields are stored as Date objects.
// <P>
// When using the SmartClient server framework, "datetime" values are automatically transmitted
// such that the resulting Date object has the same GMT/UTC timestamp (milliseconds since
// epoch).
// <P>
// When sent or received in XML or JSON, datetime field values should be serialized out as full
// datetimes using the standard
// +externalLink{http://www.w3.org/TR/xmlschema-2/#dateTime,XML Schema datetime format}
// (EG:<code>2006-01-10T12:22:04-04:00</code>).  If no timezone offset is supplied, the value
// is assumed to be GMT/UTC.
// <P>
// System wide formatting for datetimes may be controlled via the
// +link{Date.setShortDatetimeDisplayFormat()} method.  Datetimes will be displayed to the user
// in browser local time by default (see also timezone notes below).
// <P>
// <h3>"time" handling</h3>
// <P>
// Fields of type +link{type:FieldType,time} are time values in the absence of a day, such as
// the beginning of the workday (9:00).  In the browser, values for "time" fields are stored as
// Date objects with the time in browser local time.  The date information has no meaning and
// only the time information is displayed to the user.
// <P>
// Time formatting is handled by the +link{Time} class APIs.
// <br>
// When using the SmartClient server framework, "time" values are automatically transmitted
// such that the resulting Date object has the same hour, minute and second values in local
// time, and year/month/day is ignored.
// <P>
// When sent or received in XML or JSON, date field values should be serialized as hours,
// minutes and seconds using the standard
// +externalLink{http://www.w3.org/TR/xmlschema-2/#dateTime,XML Schema time format} -
// <code>"22:01:45"</code>.  Timezone is not relevant and should be omitted.
// <smartclient>
// <P>
// The +link{Date.createLogicalTime()} method may be used to create a new Date object to represent
// a logical time value on the browser.
// </smartclient>
// <smartgwt>
// <P>
// The DateUtil.createLogicalTime() method may be used to create a new Date object to represent
// a logical time value on the browser.
// </smartgwt>
// <P>
// <h3>Timezone settings and Daylight Savings Time</h3>
// <P>
// By default, "datetime" values will be shown to the user in browser local time, as derived
// from the native browser locale.  Developers may modify this behavior by specifying an
// explicit display timezone via +link{Time.setDefaultDisplayTimezone()}.
// <P>
// Note that depending on the specific date being displayed, a Daylight Savings Time offset may
// also be applied based on the browser locale.  To disable this behavior set
// +link{isc.Time.adjustForDST} to false.
// <P>
// If a custom timezone is specified, it will be respected by all +link{TimeDisplayFormat}s, and
// by the standard short +link{DateDisplayFormat}s when formatting dates representing datetime
// type values. However native JavaScript Date formatters,
// including <code>toLocaleString()</code> will not respect the specified timezone. Developers
// specifying a custom timezone may therefore wish to modify the +link{Date.setNormalDisplayFormat()}
// to avoid using a native JS Date formatter function.
// <P>
// Note that in addition to the system-wide date, datetime and time-formatting settings described
// above, databound components also support applying custom display formats for date values.
// Typically this can be achieved via a custom <code>dateFormatter</code> or
// <code>timeFormatter</code> at the field level (see +link{dataSourceField.dateFormatter},
// +link{dataSourceField.timeFormatter} and for example +link{listGridField.dateFormatter}).
// Date formatting may also be configured at the component level by setting the
// <code>dateFormatter</code>, <code>datetimeFormatter</code> and <code>timeFormatter</code>
// attributes (See for example +link{listGrid.dateFormatter}, +link{listGrid.timeFormatter},
// and +link{listGrid.datetimeFormatter}).
// <P>
// <h3>Troubleshooting Date and Time values</h3>
// <P>
// Date and time storage and timezones can be confusing, and Isomorphic receives a steady
// stream of false bug reports from users that are incorrectly analyzing logs and diagnostics.
// Please consider the following points when troubleshooting issues such as date values
// changing to a different day, or datetime value shifting when saved and reloaded:
// <P>
// <h4>1. compare values for "datetime" fields via date.getTime()</h4>
// <P>
// Whenever you use Date.toString() (client or server-side) the value you get is based on the
// server or browser timezone.
// <P>
// Perhaps you are troubleshooting an issue with datetimes and you try to log the value of a
// Date like this:
// <pre>
//    Date someDate = &lt;<i>some expression</i>&gt;;
//    log("date value is: " + someDate);
// </pre>
// Code like this will show the datetime value in the server's timezone if executed
// server-side, and in the client's timezone if executed client-side.  If they are in different
// timezones, the hour or day will be different, <b>whereas the actual datetime value -
// milliseconds since epoch as retrieved by Date.getTime() - is the same</b>.  To correctly
// compare two datetime values, compare the result of getTime().
// <P>
// <h4>2. "date" and "time" field values <b>cannot</b> be compared via getTime()</h4>
// <P>
// This is the inverse situation as for "datetime" values.  As explained above, "date" values
// have no meaningful values for time fields (hours/minutes/seconds) and "time" values have no
// meaningful values for date fields (month/day/year).  Here, the result of Date.getTime() is
// not meaningful, and values should be compared via getHours(), getMonth() et al.
// <P>
// <h4>3. the display timezone does not affect Date.getHours(), Date.getDay() et al</h4>
// <P>
// If you've called setDefaultDisplayTimezone() to cause all datetime values to be rendered in
// a particular timezone, this does not affect the return values of Date.getHours(), which will
// still return values for the browser's current timezone.  Hence it is not a bug if you have a
// "datetime" value which is displaying as 4am, but getHours() returns 10 or some other
// number.  This just reflects the timezone offset between the timezone passed to
// setDefaultDisplayTimezone() and the browser's local timezone.
// <P>
// <h4>4. use correct DataSourceField types and use the matching FormItem type</h4>
// <P>
// If you declare a field as type "date" but values you provide actually contain specific
// hours, minutes and seconds, these will not be preserved.  The system will discard or reset
// the hours, minutes and seconds in the course of serialization or editing.  Likewise
// if you declare a field as type "time" but actually provide values where year, month and day
// have meaning, these values will be dropped.
// <P>
// Similarly, DateItem expects values for "date" fields, TimeItem expects values for "time"
// fields, and DateTimeItem expects values for "datetime" fields.  Providing the wrong type of
// value to a control, such as providing a value from a "datetime" field to a DateItem, will
// have unspecified results.
// <P>
// <smartclient>
// If you want to take the date and time aspects of a "datetime" value and edit them in separate
// FormItems, use +link{Date.getLogicalDateOnly()} and +link{Date.getLogicalTimeOnly()} to
// split a datetime value into date and time values, and use
// +link{Date.combineLogicalDateAndTime()} to re-combine such values. Otherwise it is very
// easy to make mistakes related to timezone offsets.
// </smartclient>
// <smartgwt>
// If you want to take the date and time aspects of a "datetime" value and edit them in separate
// FormItems, use
// <code>getLogicalDateOnly()</code> and <code>DateUtil.getLogicalTimeOnly()</code> to
// split a datetime value into date and time values, and use
// <code>DateUtil.combineLogicalDateAndTime()</code> to re-combine
// such values. Otherwise it is very
// easy to make mistakes related to timezone offsets.
// </smartgwt>
// <P>
// <h4>5. check data at every phase when troubleshooting</h4>
// <P>
// If you're having a problem with round-tripping "datetime" values or "date" values shifting
// to another day, you need to isolate the problem to a specific layer.  Bearing in mind the
// techniques above for comparing values, you potentially need to look at any/all of the
// following:
// <ol>
// <li> what value do I have on the server-side before it's sent to the client?
// <li> what value is being transmitted to the client? (use the RPC Tab of the Developer
// Console to see the actual data sent)
// <ul>
// <li> was the value shifted to a different time/date by my serialization approach?
// <li> does it have the right format? (see above for correct JSON/XML formats)
// </ul>
// <li> what value do I have on the client before it gets to any widgets (eg, do a direct call
// to +link{DataSource.fetchData()} and inspect the data in the callback)
// <li> what value does the FormItem or other editing widget report before saving is attempted?
// <li> what value is reported right before the value is serialized for transmission to the
// server (+link{DataSource.transformRequest()} is a good place to check)
// <li> what value is being transmitted to the server? (use the RPC tab - same concerns as for
// server-to-client transmission above)
// <li> what value does the server have after de-serialization, before saving to the database
// or other permanent storage?
// <li> what value is sent to the database or permanent storage?  If generating SQL or another
// similar query language, does the value in the SQL statement include an explicit timezone?
// If not, how will the database interpret it?
// </ol>
//
// @title Date and Time Format and Storage
// @treeLocation Concepts
// @visibility external
//<


_xmlSerialize : function (name, type, namespace, prefix) {
    return isc.Comm._xmlValue(name, this.toSchemaDate(null, isc.Comm._trimMillis),
                              type || (this.logicalDate ? "date" :
                                        (this.logicalTime &&
                                        !isc.DataSource.serializeTimeAsDatetime ? "time" : "datetime")),
                              namespace, prefix);
},

// logicalType parameter - option to specify "date" vs "datetime" vs "time" which impacts
// how this date instance should be serialized out.
// Alternatively logicalDate / logicalTime attributes may be hung onto the date objet
// directly.
// Used by DataSources when serializing dates out
toSchemaDate : function (logicalType, trimMillis) {
    // logical date values have no meaningful time
    // Note that they also have "no meaningful timezone" - we display native browser locale time
    // to the user and when we serialize to send to the server we serialize in that same
    // local timezone.
    if ((logicalType == "date") || this.logicalDate) {
        return isc.SB.concat(
            this.getFullYear().stringify(4),
            "-",
            (this.getMonth() + 1).stringify(2),     // getMonth() is zero-based
            "-",
            this.getDate().stringify(2)
        );
    };

    // logical times are serialized as truncated schema strings (HH:MM:SS) by default
    if ((!isc.DataSource || !isc.DataSource.serializeTimeAsDatetime) &&
        (logicalType == "time" || this.logicalTime))
    {
        var value = isc.SB.concat(
            this.getHours().stringify(2), ":",
            this.getMinutes().stringify(2), ":",
            this.getSeconds().stringify(2));
        if (trimMillis !== true) {
            value += "." + this.getUTCMilliseconds().stringify(3);
        };
        return value;
    }

    // represent date time values in UTC
    var value = isc.SB.concat(
        this.getUTCFullYear().stringify(4),
        "-",
        (this.getUTCMonth() + 1).stringify(2),     // getMonth() is zero-based
        "-",
        this.getUTCDate().stringify(2),
        "T",
        this.getUTCHours().stringify(2),
        ":",
        this.getUTCMinutes().stringify(2),
        ":",
        this.getUTCSeconds().stringify(2));
    if (trimMillis !== true) {
        value += "." + this.getUTCMilliseconds().stringify(3);
    };
    return value;
},

//>    @method        date.toSerializeableDate()    (A)
// Return this date in 'serialized' format <code>YYYY-MM-DD HH:MM:SS</code>
// @group dateFormatting
// @return (String) formatted date string
// @visibility external
//<

toSerializeableDate : function (useCustomTimezone) {
    var output = isc.SB.create();
    output.append(
            this.getFullYear().stringify(4),
            "-",
            (this.getMonth() + 1).stringify(2),     // getMonth() is zero-based
            "-",
            this.getDate().stringify(2)
    );

    output.append(isc.Comm.xmlSchemaMode ? "T" : " ",
                  isc.Time.toShortTime(this, "toPadded24HourTime"));
    return output.release(false);
},

//>    @method        date.toDBDate()    (A)
//            Return this date in the format the database can parse as a datetime:
//                <code>$$DATE$$:<i>YYYY-MM-DD HH:MM:SS</i></code>
//        @group    dateFormatting
//
//        @return                    (string)    formatted date string
//  @visibility internal
//<
// Leave this internal for now
toDBDate : function () {
    return isc.StringBuffer.concat(
            "$$DATE$$:",
            this.toSerializeableDate()
            );
},


//>    @method        date.toDBDateTime()    (A)
//            Return this date in the format the database can parse as a dateTime:
//                <code>$$DATE$$:<i>YYYY-MM-DD HH:MM:SS</i></code>
//        @group    dateFormatting
//
//        @return                    (string)    formatted date string
//      @visibility internal
//<

toDBDateTime : function () {    return this.toDBDate();       },

//>    @method        date.setFormatter()
//  Set the formatter for this date object to the method name passed in.  After this call
//  wherever appropriate SmartClient components will use this formatter function to return
//  the date as a string.
//        @group    dateFormatting
//        @param    functionName    (string)    name of a date formatter method on this Date
//      @visibility external
//      @deprecated As of SmartClient 5.5 use the static methods
//              +link{classMethod:Date.setNormalDisplayFormat} and
//              +link{classMethod:Date.setShortDisplayFormat} to set default formatters for all dates
//<
setFormatter : function (formatter) {
    this.setNormalDisplayFormat(formatter);
},

//>    @method    date.setLocaleStringFormatter() (A)
//            Set the <code>iscToLocaleString()</code> formatter for a specific date object.
//            After this call, all  <code>theDate.toLocaleString()</code>  calls will yield a string
//             in this format.
//
//        @param    functionName    (string)    name of a dateFormatting function
//        @group    dateFormatting
//      @visibility internal
//      @deprecated As of SmartClient 5.5 use the static method
//                  +link{classMethod:Date.setLocaleStringFormatter} instead
//<

setLocaleStringFormatter : function (functionName) {
    if (isc.isA.Function(this[functionName]) || isc.isA.Function(functionName))
        this.localeStringFormatter = functionName;
},

// ------------------------Advanced Date Comparison -------------------------------------------
// (currently undocd)
isBeforeToday : function (dateObj) {
    var today = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0).getTime();
    if (dateObj.getTime() < today) return true;
    else return false;
},

isToday : function (dateObj) {
    if (this.getFullYear() == dateObj.getFullYear() && this.getMonth() == dateObj.getMonth()
        && this.getDate() == dateObj.getDate())
        return true;
    else return false;
},

isTomorrow : function (dateObj) {
    var tomorrowStart = new Date(this.getFullYear(), this.getMonth(), this.getDate() + 1, 0);
    var tomorrowEnd = new Date(this.getFullYear(), this.getMonth(), this.getDate() + 1, 23);
    var dateTime = dateObj.getTime();
    if (dateTime >= tomorrowStart.getTime() && dateTime <= tomorrowEnd.getTime()) {
        return true;
    } else {
        return false;
    }
},

isThisWeek : function (dateObj) {
    var weekStart = new Date(this.getFullYear(), this.getMonth(), this.getDate() - this.getDay(), 0);
    var weekEnd = new Date(this.getFullYear(), this.getMonth(), this.getDate() + (7 - this.getDay()), 23);
    var dateTime = dateObj.getTime();
     if (dateTime >= weekStart.getTime() && dateTime <= weekEnd.getTime()) {
        return true;
    } else {
        return false;
    }
},

isNextWeek : function (dateObj) {
    var weekStart = new Date(this.getFullYear(), this.getMonth(), (this.getDate() - this.getDay()) + 7, 0);
    var weekEnd = new Date(this.getFullYear(), this.getMonth(), (this.getDate() - this.getDay()) + 14, 23);
    var dateTime = dateObj.getTime();
     if (dateTime >= weekStart.getTime() && dateTime <= weekEnd.getTime()) {
        return true;
    } else {
        return false;
    }
},

isNextMonth : function (dateObj) {
    var monthStart = new Date(this.getFullYear(), this.getMonth());
    monthStart.setMonth(monthStart.getMonth() + 1);
    if (monthStart.getFullYear() == dateObj.getFullYear() && monthStart.getMonth() == dateObj.getMonth()) {
        return true;
    } else {
        return false;
    }
}

});


//>    @method        date.toBrowserString()
//  Native <code>date.toString()</code> provided by the browser for Date objects
//        @group    dateFormatting
//      @visibility internal
//      @deprecated As of SmartClient 5.5
//<
// Note that the default formatter varies by browser/platform so it's not that useful.
// This was exposed in 5.2 so we're keeping it around for back-compat only
Date.prototype.toBrowserString = Date.prototype.toString;

//>    @method        date.toBrowserLocaleString()    (A)
//  Synonym for <code>date.toLocaleString()</code> provided by the browser for Date objects
//        @group    dateFormatting
//      @visibility internal
//      @deprecated As of SmartClient 5.5
//<

Date.prototype.toBrowserLocaleString = Date.prototype.toLocaleString;

// default the global fiscal year to the start of the calendar year
Date.prototype.fiscalCalendar = { defaultMonth:0, defaultDate:1, fiscalYears: [] };

// set the standard formatter for the date prototype to the native browser string
//    so everything works as normal until it is overridden.
if (!Date.prototype.formatter) Date.setNormalDateDisplayFormat("toLocaleString");
if (!Date.prototype.datetimeFormatter) Date.setNormalDatetimeDisplayFormat("toLocaleString");

// set the standard toShortDate() formatter to US Short Date
if (!Date.prototype._shortFormat) Date.setShortDisplayFormat("toUSShortDate");
if (!Date.prototype._shortDatetimeFormat) Date.setShortDatetimeDisplayFormat("toUSShortDatetime");

//>    @method        date.iscToLocaleString()   (A)
// Customizeable toLocaleString() type method.
// This method is called when isc.iscToLocaleString(date) is called.
//
//        @group    dateFormatting
//        @return                (string)    formatted date string
//      @visibility internal
//<
// Leave this internal - we don't really expect this to be called directly or overridden by
// the developer

Date.prototype.iscToLocaleString = function () {
    var formatter = this.localeStringFormatter;
    if (isc.isA.Function(formatter)) return formatter.apply(this);
    else if (this[formatter]) return this[formatter]();
}

// By default have iscToLocaleString() call date.toLocaleString()
if (!Date.prototype.localeStringFormatter)
    Date.prototype.localeStringFormatter = "toLocaleString";


//>Safari12
isc.addMethods(Date, {
    // Simple substring matching for splitting up a date string to avoid using unsupported
    // string.match() method in early Safari
    // Note - somewhat flawed: we're assuming well never be handed a single digit month or day
    _splitDateViaSubstring : function (string, monthIndex, dayIndex, yearIndex) {

        // We know that year may be after month and/or day - allow 3 chars ("DD/") for each
        var yearCharIndex = yearIndex * 3,
            year = string.substring(yearCharIndex, yearCharIndex +4)
        ;

        // If we have a 2 or 3 char year, this affects the position of the day/month in the
        // string
        var yearLength = year.length;

        var monthCharIndex = 0,
            dayCharIndex = 0;
        if (monthIndex > dayIndex) monthCharIndex += 3;
        else dayCharIndex += 3;

        if (monthIndex > yearIndex) monthCharIndex += yearLength + 1;
        if (dayIndex > yearIndex) dayCharIndex += yearLength + 1;

        // Note: Month is zero based rather than 1 based.
        var month = string.substring(monthCharIndex, monthCharIndex + 2) -1;
        var day = string.substring(dayCharIndex, dayCharIndex +2);

        // Hour minute second are not expected to change orders
        var hourCharIndex = 7 + yearLength,
            hour = (string.substring(hourCharIndex,hourCharIndex + 2) || 0),
            minute = (string.substring(hourCharIndex + 3, hourCharIndex + 5) || 0),
            second = (string.substring(hourCharIndex + 6, hourCharIndex + 8) || 0);

        return[year,month,day,hour,minute,second];
    }
});
//<Safari12

//>!BackCompat 2005.11.3

isc.addMethods(Date.prototype, {

//>    @method        date.toPrettyString()
//            Return this date in the format: <code>MM/DD/YY HH:MM</code>
//    @group  dateFormatting
//    @return (string)    formatted date string
//  @visibility external
//  @deprecated As of SmartClient 5.5 use +link{date.toShortDate()} instead
//<
toPrettyString : function () {
    return this.toUSShortDatetime();
}

});

isc.addMethods(Date, {


// --- Parsing functions --- :
// In 5.2 the paradigm was to provide formatters and complimentary parsers, like
// 'toEuropeanShortDate' and 'parseEuropeanShortDate'.
// We've moved away from this to instead use a single 'parseInput' function which takes a
// 'format' parameter specifying "MDY" / "DMY", etc.
// This is appropriate since we do not plan to provide parsing functions for every date formatter
// format.
// Leaving the older explicit parsing functions in place for back-compat only.

//>    @classMethod    Date.parseStandardDate()
//      Parse a date passed in as a string of format:
//      <code>YYYY-MM-DD HH:MM:SS</code> or <code>YYYY-MM-DD</code>
//      Returning a new <code>Date</code> object with the appropriate value.
//
//      @group  dateFormatting
//
//      @param  dateString  (string)    date value as a string
//
//      @return    (date)      date value
//      @visibility internal
//  @deprecated As of SmartClient 5.5 use +link{date.parseInput} instead
//<
parseStandardDate : function (dateString) {
    if (!isc.isA.String(dateString)) return null;

    // Note: we could be using a regexp here rather than substring matches
    var year = dateString.substring(0,4),
        month = dateString.substring(5,7)-1,
        day = dateString.substring(8,10),
        hour = dateString.substring(11, 13),
        minute = dateString.substring(14, 16),
        second = dateString.substring(17, 19);

    // If they all are numbers, construct a new date
    // NOTE: If year - month - day gives a number then they
    // are all numbers, or strings that implicitly convert to numbers.
    // We could also use this syntax:
    // if(parseInt(year) == year && parseInt(month) == month ...)
    // but this is slower in both Moz and IE
    if (dateString.length < 19) {
        if (!isc.isA.Number(year - month - day)) return null;
    } else {
        if (!isc.isA.Number(year - month - day - hour - minute - second)) return null;
    }

    return new Date(year, month, day, hour, minute, second);

},

//>    @classMethod    Date.parseSerializeableDate()
//      Parse a date passed in as a string of format:
//      <code>YYYY-MM-DD HH:MM:SS</code> or <code>YYYY-MM-DD</code>
//      Returning a new <code>Date</code> object with the appropriate value.
//      <i>This is a synonym for </i><code>Date.parseStandardDate()</code>
//
//      @group  dateFormatting
//      @param  dateString  (string)    date value as a string
//      @return    (Date)      date value
//      @visibility internal
//  @deprecated As of SmartClient 5.5 use +link{date.parseInput} instead
//<
parseSerializeableDate : function (dateString) {
    // synonym for parseStandardDate
    return this.parseStandardDate(dateString);
},


//>    @classMethod    Date.parseDBDate()
// Parse a date passed in as a string of format:
//  <code>$$DATE$$:<i>YYYY-MM-DD HH:MM:SS</i></code>
//      Returning a new <code>Date</code> object with the appropriate value.
//
//      @group  dateFormatting
//        @param    dateString  (string)    date value as a string
//        @return    (date)        date value
//      @visibility internal
//  @deprecated As of SmartClient 5.5 use +link{date.parseInput} instead
//<
parseDBDate : function (dateString) {

    // remove the leading "$$DATE$$:"
    if (isc.isA.String(dateString) && dateString.startsWith("$$DATE$$:")) {
        dateString = dateString.substring(9)
        return this.parseStandardDate(dateString);
    }

    return null;

},

//>    @classMethod    Date.parseDateStamp()
//
// Parse a dateStamp of the format: <code><i>YYYYMMDD</i>T<i>HHMMSS</i>[Z]</code><br><br>
//
// @group  dateFormatting
// @param    dateString    (string)    String to parse
// @return                (Date)        Date object, or null if not parsed correctly.
//
// @visibility internal
//  @deprecated As of SmartClient 5.5 use +link{date.parseInput} instead
//<
parseDateStamp : function (string) {
    if (string == null || isc.isA.Date(string)) return string;

    var date = new Date( Date.UTC(
                string.substring(0,4),                // year
                parseInt(string.substring(4,6), 10)-1,    // mon
                string.substring(6,8),              // day
                // omit this character (T)
                string.substring(9,11),             // hour
                string.substring(11,13),            // min
                string.substring(13,15)
                // Technically we should look at the last character - if its something other
                // than "z" the timezone would be something other than UTC.
               ));

    if (isc.isA.Date(date)) return date;
    else                return null;

},

//>    @classMethod    Date.parseShortDate()
// Parse a date passed in as a string of format:   <code>MM/DD/YYYY</code>
//
//      @group  dateFormatting
//        @param    dateString  (string)    date value as a string
//      @param  [centuryThreshold]  (int)    if parsed year is 2 digits and less than this
//                                              number, assume year to be 20xx
//
//        @return    (date)        date value
//  @visibility internal
//  @deprecated As of SmartClient 5.5 use +link{date.parseInput} instead
//<
parseShortDate : function (string, centuryThreshold) {
    return this.parseInput(string, "MDY", centuryThreshold);
},

//>    @classMethod    Date.parseShortDateTime()
// Parse a date passed in as a string of format:   <code>MM/DD/YYYY HH:MM:SS</code>
//
//      @group  dateFormatting
//        @param    dateString  (string)    date value as a string
//      @param  [centuryThreshold]    (int)    if parsed year is 2 digits and less than this
//                                              number, assume year to be 20xx
//
//        @return    (date)        date value
//  @visibility internal
//  @deprecated As of SmartClient 5.5 use +link{date.parseInput} instead
//<

parseShortDateTime : function (string, centuryThreshold) {
    // synonym for parseShortDate - included for completeness and to provide the appropriate
    // compliment to date.toShortDateTime()
    return this.parseShortDate(string, centuryThreshold);
},

//>    @classMethod    Date.parsePrettyString()
// Parse a date passed in as a string of format:   <code>MM/DD/YY HH:MM:SS</code>
//
//      @group  dateFormatting
//        @param    dateString  (string)    date value as a string
//      @param  [centuryThreshold]    (int)    if parsed year is less than this
//                                              number, assume year to be 20xx rather than 19xx
//
//        @return    (date)        date value
//  @visibility internal
//  @deprecated As of SmartClient 5.5 use +link{date.parseInput} instead
//<
parsePrettyString : function (string, centuryThreshold) {
    // this is just the same as a short date with a 2 digit year.
    return this.parseShortDate(string, centuryThreshold);
},

//>    @classMethod    Date.parseEuropeanShortDate()
//            parse a date passed in as a string of format:   <code>DD/MM/YYYY</code>
//        @group    dateFormatting
//        @param    dateString  (string)    date value as a string
//      @param  [centuryThreshold]    (int)    if parsed year is 2 digits and less than this
//                                              number, assume year to be 20xx
//
//        @return    (date)        date value
//      @visibility internal
//  @deprecated As of SmartClient 5.5 use +link{date.parseInput} instead
//<
parseEuropeanShortDate : function (string, centuryThreshold) {
    return this.parseInput(string, "DMY", centuryThreshold);
},

//>    @classMethod    Date.parseEuropeanShortDateTime()
//            parse a date passed in as a string of format:   <code>DD/MM/YYYY HH:MM:SS</code>
//        @group    dateFormatting
//        @param    dateString  (string)    date value as a string
//      @param  [centuryThreshold]    (int)    if parsed year is 2 digits and less than this
//                                              number, assume year to be 20xx
//
//        @return    (date)        date value
//  @visibility internal
//  @deprecated As of SmartClient 5.5 use +link{date.parseInput} instead
//<

parseEuropeanShortDateTime : function (string, centuryThreshold) {
    return this.parseInput(string, "DMY", centuryThreshold);
},

// Helper to set the time to zero for a datetime

setToZeroTime : function (date) {
    if (date == null || !isc.isA.Date(date)) return date;

    // Clear the "logicalDate" flag so when we run through formatters we respect
    // developer specified timezone rather than displaying time in the browser native timezone
    var wasLogicalDate = date.logicalDate;
    date.logicalDate = false;

    var timestamp = date.getTime();

    // Apply the timezone offset such that if the default system-wide formatter is used
    // and applies the display timezone offset, 00:00 will be seen.
    var hourOffset = isc.Time.getUTCHoursDisplayOffset(date),
        minuteOffset = isc.Time.getUTCMinutesDisplayOffset(date)
    ;

    if (wasLogicalDate) {
        var previousDay = new Date(date);
        previousDay.setHours(0);
        previousDay.setMinutes(0);

        var previousDayHourOffset = isc.Time.getUTCHoursDisplayOffset(previousDay);
        if (hourOffset != previousDayHourOffset) {
            // logical dates have a time of 12-noon - if the date in question happens to be
            // the one that DST changes on, the final date (with a time of 00:00) will have
            // a different hourOffset - use that one instead.
            hourOffset = previousDayHourOffset;
        }
    }

    var utcHours = hourOffset > 0 ? 24-hourOffset : 0-hourOffset,
        utcMins = 60-minuteOffset;

    if (utcMins >= 60) {
        utcMins -= 60;

    // If the minute offset was non-zero and the offset as a whole is positive
    // we need to knock an additional hour off (as the hours/minutes are cumulative so
    // we otherwise will roll forward to 01:00 local time)

    } else if (utcMins != 0) {
        utcHours -= 1;
    }


    var oldDisplayDate;
    if (wasLogicalDate) {
        oldDisplayDate = date.getDate();
    } else {
        var offsetDate = date._getTimezoneOffsetDate(hourOffset, minuteOffset);
        oldDisplayDate = offsetDate.getUTCDate();
    }

    date.setUTCHours(utcHours);
    date.setUTCMinutes(utcMins);

    var displayOffsetDate = date._getTimezoneOffsetDate(hourOffset, minuteOffset),
        displayDate = displayOffsetDate.getUTCDate(),
        adjustedUTCHours = utcHours;

    if (displayDate != oldDisplayDate) {
        // Cant just check for displayDate > oldDisplayDate since it might be the first or
        // last of a month...
        var moveForward = date.getTime() < timestamp;

        adjustedUTCHours += moveForward ? 24 : -24;
        date.setUTCHours(adjustedUTCHours);
    }


    if (date.getUTCHours() != utcHours) {
        date.setTime(timestamp);
        date.setUTCHours(adjustedUTCHours+1);
        if (date.getUTCHours() != utcHours+1) {
            date.setTime(timestamp);
            date.setUTCHours(adjustedUTCHours+2);
        }
    }

    // No need to return the date - we updated it directly.

}

});
//<!BackCompat







//> @type RelativeDateShortcut
// A RelativeDateShortcut is a special string that represents a shortcut to a date phrase that can
// be automatically mapped to a +link{type:RelativeDateString} for use in widgets that
// leverage relative-dates, such as the +link{class:RelativeDateItem}.
// <P>
// Note that some shortcuts indicate a time period but do not directly indicate whether the value
// refers to the start or end of the time period in question. This ambiguity
// can be resolved by specifying an explicit +link{RelativeDateRangePosition} when calling APIs that
// convert from RelativeDates to absolute date values. This is the case for <i>$today</i>,
// <i>$tomorrow</i>, <i>$yesterday</i>, <i>$weekAgo</i>, <i>$weekFromNow</i>, <i>$monthAgo</i>
// and <i>$monthFromNow</i>. If a range position is not explicitly passed, these will all default
// to the start of the day in question.
// <P>
// Builtin options include
// <ul>
// <li> $now - this moment </li>
// <li> $today - the current day. By default this resolves to the start of the current day though
//   an explicit +link{RelativeDateRangePosition} may be used to specify the end of the current day.</li>
// <li> $startOfToday - the start of today</li>
// <li> $endOfToday - the end of today (one millisecond before the $startOfTomorrow) </li>
// <li> $yesterday - the previous day.</li>
// <li> $startOfYesterday - the start of yesterday</li>
// <li> $endOfYesterday - the end of yesterday (one millisecond before the $startOfToday) </li>
// <li> $tomorrow - the following day</li>
// <li> $startOfTomorrow - the start of tomorrow </li>
// <li> $endOfTomorrow - the end of tomorrow </li>
// <li> $weekAgo - the current day of the previous week </li>
// <li> $weekFromNow - the current day of the next week </li>
// <li> $startOfWeek - the start of the current week </li>
// <li> $endOfWeek - the end of the current week </li>
// <li> $monthAgo - the current day of the previous month </li>
// <li> $monthFromNow - the current day of the following month </li>
// <li> $startOfMonth - the start of the current month </li>
// <li> $endOfMonth - the end of the current month </li>
// <li> $startOfYear - the start of the current year </li>
// <li> $endOfYear - the end of the current year </li>
// </ul>
//
// <P>
//
// @see RelativeDateString
// @visibility external
//<

//> @type RelativeDateString
// A string of known format used to specify a datetime offset.  For example, a
// RelativeDateString that represents "one year from today" is written as <code>"+1y"</code>.
// <P>
// RelativeDateStrings are comprised of the following parts:
// <ul>
// <li>direction: the direction in which the quantity applies - one of + or - </li>
// <li>quantity: the number of units of time to apply - a number </li>
// <li>timeUnit: an abbreviated timeUnit to use - one of ms/MS (millisecond), s/S (second),
//      mn/MN (minute), h/H (hour), d/D (day), w/W (week), m/M (month), q/Q (quarter, 3-months),
//      y/Y (year), dc/DC (decade) or c/C (century). <br>
//      The timeUnit is case sensitive. A lowercase timeUnit implies an exact offset, so <code>+1d</code>
//      refers to the current date / time increased by exactly 24 hours. If the timeUnit is
//      uppercase, it refers to the start or end boundary of the period of time in question, so
//      <code>+1D</code> would refer to the end of the day (23:39:59:999) tomorrow, and
//      <code>-1D</code> would refer to the start of the day (00:00:00:000) yesterday.</li>
// <li>[qualifier]: an optional timeUnit encapsulated in square-brackets and used to offset
//      the calculation - eg. if +1d is "plus one day", +1d[W] is "plus one day from the
//      end of the current week".  You may also specify another complete RelativeDateString as the
//      [qualifier], which offers more control - eg, +1d[+1W] indicates "plus one day from
//      the end of NEXT week".</li>
// </ul>
// <P>
// This format is very flexible. Here are a few example relative date strings:<br>
// <code>+0D</code>: End of today. There are often multiple ways to represent the same time
//  using this system - for example this could also be written as <code>-1ms[+1D]</code><br>
// <code>-0D</code>: Beginning of today.<br>
// <code>+1W</code>: End of next week.<br>
// <code>+1w[-0W]</code>: Beginning of next week.<br>
// <code>+1w[-0D]</code>: Beginning of the current day of next week.
//
// @see RelativeDateShortcut
// @visibility external
//<

//> @object RelativeDate
// An object representing a relative date, useful for representing date ranges etc in criteria.
// RelativeDate objects may be created directly by SmartClient components such as the
// +link{RelativeDateItem}.
// <P>
// RelativeDate objects will have <code>"_constructor"</code> set to <code>"RelativeDate"</code>
// and must have a specified +link{RelativeDate.value}. Any other attributes are optional.
//
// @treeLocation Client Reference/System
// @visibility external
//<
// This type of object is returned by RelativeDateItem.getValue() and is understood directly by
// DataSources when assembling criteria.


//> @attr relativeDate.value (RelativeDateString or RelativeDateShortcut : null : IR)
// The value of this relative date, specified as a +link{RelativeDateString}
// or +link{RelativeDateShortcut}.
// @visibility external
//<

//> @type RelativeDateRangePosition
// When  relative dates are specified in a date range, typically in a RelativeDateItem or
// DateRangeItem, in order to make the range inclusive or exclusive, it is useful to be able
// to specify whether we're referring to the start or end of the date in question.
//
// @value "start" Indicates this relative date should be treated as the start of the specified
//    logical date.
// @value "end" Indicates this relative date should be treated as the end of the specified logical
//    date.
// @visibility external
//<

//> @attr relativeDate.rangePosition (RelativeDateRangePosition : null : IR)
// If this relative date has its value specified as a +link{RelativeDateShortcut} which doesn't
// specify an exact time-period boundary - for example <code>"$yesterday"</code>, this attribute
// may be set to specify whether the date should be interpreted as the start or end boundary of
// the time period.
// @visibility external
//<

// Add static methods to the DateUtil class (defined in Date.js)
isc.DateUtil.addClassMethods({

    //> @classMethod DateUtil.mapRelativeDateShortcut() [A]
    // Converts a +link{RelativeDateShortcut} to a +link{RelativeDateString}.
    // @param relativeDate (RelativeDateShortcut) shortcut string to convert
    // @param [rangePosition] (RelativeDateRangePosition) Are we interested in the start or end of the
    //  specified relative date? This applies to shortcuts which do not specify a specific
    //  moment (such as <code>$today</code>) - it does not apply to shortcuts which
    //  already specify a specific moment such as <code>$startOfToday</code>. If unspecified
    //  rangePosition is always assumed to be "start"
    // @return (RelativeDateString) converted relative date string.
    // @visibility external
    //<
    mapRelativeDateShortcut : function (relativeDate, rangePosition) {
        switch (relativeDate) {
            case "$now": return "+0MS";

            case "$today":
                if (rangePosition == "end") {
                    return "+0D";
                } else {
                    return "-0D";
                }
            case "$startOfToday":
                return "-0D";
            case "$endOfToday": return "+0D";

            case "$yesterday":
                if (rangePosition == "end") {

                    return "-1d[+0D]";
                } else {
                    return "-1D";
                }
            case "$startOfYesterday":
                return "-1D";
            case "$endOfYesterday": return "-1d[+0D]";

            case "$tomorrow":
                if (rangePosition == "end") {
                    return "+1D";
                } else {
                    return "+1d[-0D]";
                }
            case "$startOfTomorrow":
                return "+1d[-0D]";
            case "$endOfTomorrow": return "+1D";

            case "$startOfWeek": return "-0W";
            case "$endOfWeek": return "+0W";

            case "$startOfMonth": return "-0M";
            case "$endOfMonth": return "+0M";

            case "$startOfYear": return "-0Y";
            case "$endOfYear": return "+0Y";

            case "$weekFromNow" :
                if (rangePosition == "end") {
                    return "+1w[+0D]";
                } else {
                    return "+1w[-0D]";
                }

            case "$weekAgo" :
                if (rangePosition == "end") {
                    return "-1w[+0D]";
                } else {
                    return "-1w[-0D]";
                }

            case "$monthFromNow" :
                if (rangePosition == "end") {
                    return "+1m[+0D]";
                } else {
                    return "+1m[-0D]";
                }

            case "$monthAgo" :
                if (rangePosition == "end") {
                    return "-1m[+0D]";
                } else {
                    return "-1m[-0D]";
                }
        }
        return relativeDate;
    },

    //> @classMethod DateUtil.getAbsoluteDate()
    //  Converts a +link{RelativeDate}, +link{type:RelativeDateShortcut} or +link{RelativeDateString}
    // to a concrete Date.
    // @param relativeDate (RelativeDate or RelativeDateShortcut or RelativeDateString) the relative
    //   date to convert
    // @param [baseDate] (Date) base value for conversion.  Defaults to the current date/time.
    // @param [rangePosition] (RelativeDateRangePosition) optional date-range position. Only has an effect
    //   if the date passed in is a +link{type:RelativeDateShortcut} where the range position
    //   is not implicit, such as "$yesterday"
    // @param [isLogicalDate] (boolean) should the generated date be marked as a "logical" date? A
    //   logical date object is a Date value where the time component is ignored for formatting and
    //   serialization purposes - such as the date displayed within a component field of
    //   specified type "date". See +link{group:dateFormatAndStorage} for more on logical dates vs
    //   datetime type values.
    // @return (Date) resulting absolute date value
    // @visibility external
    //<
    getAbsoluteDate : function (relativeDate, baseDate, rangePosition, isLogicalDate) {
        // passed a date object, just return a duplicate of it
        if (isc.isA.Date(relativeDate)) return relativeDate.duplicate();

        var _this = isc.DateUtil;
        var value = relativeDate;

        if (_this.isRelativeDate(value)) {
            // the caller passed an actual RelativeDate object - get the relativeDateString and
            // potentially the rangePosition from the object
            if (!rangePosition) rangePosition = value.rangePosition;
            value = relativeDate.value;
        }

        // if the param isn't now a string, it's not a relativeDate - return null
        if (!isc.isA.String(value)) return null;

        // convert relativeDateShortcut to relativeDateString, if necessary.
        // This will resolve the 'rangePosition'
        if (value.startsWith("$")) {
            var mappedString = _this.mapRelativeDateShortcut(value, rangePosition);
            // if the mapped string is unchanged, it's not a supported shortcut
            if (mappedString == value) return null;
            value = mappedString;
        }

        var localBaseDate = isLogicalDate ? Date.createLogicalDate() : new Date();

        if (baseDate != null) localBaseDate.setTime(baseDate.getTime());
        var parts = _this.parseRelativeDateString(value, true);

        // if the string couldn't be parsed, return null
        if (!parts) return null;

        if (parts.qualifier) {
            // Qualifier is always going to be in "boundary" type increments -- support it being
            // specified as upper or lowercase.
            // get rid of the brackets and upper-case it because we're
            // just going to run the baseDate through addDate(), which already understands
            // about capitals
            parts.qualifier = parts.qualifier.toUpperCase();

            var qParts = _this.parseRelativeDateString(parts.qualifier);

            if (qParts) {
                if (isc.DateUtil._relativePeriods.contains(qParts.period)) {
                    localBaseDate = _this.dateAdd(localBaseDate,
                        qParts.period, qParts.countValue, (qParts.direction == "+" ? 1 : -1),
                        isLogicalDate);
                } else {
                    // invalid qualifier - log a warning and skip
                    isc.logWarn("Invalid date-offset qualifier provided: "+qParts.period+".  Valid "+
                        "options are: S, MN (or N), H, D, W, M, Q and Y (or YY, YYYY).");
                }
            }
        }

        // perform the date calculation
        var absoluteDate = _this.dateAdd(localBaseDate, parts.period,
                                        parts.countValue, (parts.direction == "+" ? 1 : -1),
                                        isLogicalDate);

        if (isLogicalDate) absoluteDate.isLogicalDate = true;

        return absoluteDate;
    },

    _relativePeriods: ["MS", "S", "MN", "N", "H", "D", "W", "M", "Q", "Y", "YY", "YYYY", "DC", "C"],
    isRelativeDate : function (value, includeStrings) {
        // return true if the parameter is a RelativeDate object (or string representation)
        if (!isc.isA.Date(value) && isc.isAn.Object(value) && value._constructor == "RelativeDate") return true;
        var _this = isc.DateUtil;
        if (includeStrings && isc.isA.String(value)) {
            return _this.isRelativeDateShortcut(value) || _this.isRelativeDateString(value, true);
        }
        return false;
    },
    isRelativeDateShortcut : function (value) {
        // return true if the parameter is a string representing a RelativeDateShortcut and the
        // result of mapping it is different than the value itself - that means it's supported

        return isc.isA.String(value) && value.startsWith("$") &&
                 isc.DateUtil.mapRelativeDateShortcut(value) != value;
    },

    isRelativeDateString : function (value) {
        // return true if the parameter is a string that can be parsed as a relative date
        return isc.DateUtil.parseRelativeDateString(value, true) != null;
    },

    mapsToDate : function (value) {
        // returns true if the param is a Date, a RelativeDate object or a parse-able
        // relativeDateShortcut/String
        if (isc.isA.Date(value) || isc.DateUtil.isRelativeDate(value, true)) return true;
    },

    parseRelativeDateString : function (relativeDateString, suppressDefaults) {
        // if it's not a string, or shorter than 3 chars, it's not a relativeDateString
        if (!isc.isA.String(relativeDateString) || relativeDateString.length < 3) return null;

        var result = {};

        // string is in the format +1D[-0D]

        var parts = relativeDateString.split("[");
        if (parts[1]) {
            // qualifier is the bit in the square brackets (another relative date string)
            result.qualifier = parts[1].replace("]", "");
        }

        var value = parts[0];
        result.direction = value[0];
        result.count = "";
        result.period = "";

        for (var i=1; i<value.length; i++) {
            if (!isNaN(parseInt(value[i]))) result.count += value[i];
            else result.period += value[i];
        }
        result.count = parseInt(result.count);

        if (suppressDefaults) {
            // the value must start with a + or - character, there must be a valid count
            // and a period that exists in the _relativePeriods array (eg, D or M)
            if (!["+", "-"].contains(result.direction)) return null;
            if (isNaN(result.count)) return null;
            if (result.period.length == 0) return null;
            if (!isc.DateUtil._relativePeriods.contains(result.period.toUpperCase())) return null;
        }

        return {
            direction: (result.direction == "+" || result.direction == "-" ? result.direction : "+"),
            qualifier: result.qualifier,
            countValue: isc.isA.Number(result.count) ? result.count : 0,
            period: result.period ? result.period : "D"
        };
    },

    // helper method for adding positive and negative amounts of any time-unit from
    // milliseconds to centuries to a given date
    // date: base date to modify
    // unit: one of "ms" / "MS", "H" / "h", "D" / "d" etc - if unset, default is "d" (day)
    // amount: the number of "unit"s to offset by
    // multiplier: +1 or -1 - direction in which we're shifting the date
    // Returns the modified date.
    dateAdd : function (date, unit, amount, multiplier, isLogicalDate) {

        // boundary: If the specified time-unit is upperCase, we want to calculate the
        // date offset to the end of the time-unit in question. For example:
        // +1d ==> offset to the same time on the next day
        // +1D ==> offset to the end of the next day
        // -1D ==> offset to the beginning of the previous day.
        var boundary = false;

        // set some defaults for missing params - if code calls dateAdd(date), with no other
        // params, the defaults will add 1 day to the passed date
        if (unit == null) unit = "d";
        if (amount == null) amount = 1;
        if (multiplier == null) multiplier = 1;
        if (isLogicalDate == null) isLogicalDate = date.logicalDate;

        // just in case we were passed a timeUnitName ("minute", rather than "mn", eg)
        if (unit.length > 2) unit = isc.DateUtil.getTimeUnitKey(unit);

        switch (unit) {
            case "MS":
                // no need to set boundary for ms - we don't have a finer gradation than this.
            case "ms":
                date.setMilliseconds(date.getMilliseconds()+(amount*multiplier));
                break;

            case "S":
                boundary = true;
            case "s":
                date.setSeconds(date.getSeconds()+(amount*multiplier));
                break;

            case "MN":
            case "N":
                boundary = true;
            case "mn":
            case "n":
                date.setMinutes(date.getMinutes()+(amount*multiplier));
                break;

            case "H":
                boundary = true;
            case "h":
                date.setHours(date.getHours()+(amount*multiplier));
                break;

            case "D":
                boundary = true;
            case "d":
                if (amount*multiplier != 0) date.setDate(date.getDate()+(amount*multiplier));
                break;

            case "W":
                boundary = true;
            case "w":
                date.setDate(date.getDate()+((amount*7)*multiplier));
                break;

            case "M":
                boundary = true;
            case "m":
                var tempDate = isc.Date.createLogicalDate(date.getFullYear(), date.getMonth(), 1);

                tempDate.setMonth(tempDate.getMonth()+(amount*multiplier));
                tempDate = isc.DateUtil.getEndOf(tempDate, unit, true);

                if (tempDate.getDate() < date.getDate()) date.setDate(tempDate.getDate());
                date.setMonth(tempDate.getMonth());
                date.setFullYear(tempDate.getFullYear());
                break;

            case "Q":
                boundary = true;
            case "q":
                date.setMonth(date.getMonth()+((amount*3)*multiplier));
                break;

            case "Y":
            case "YY":
            case "YYYY":
                boundary = true;
            case "y":
            case "yy":
            case "yyyy":
                date.setFullYear(date.getFullYear()+(amount*multiplier));
                break;

            case "DC":
                boundary = true;
            case "dc":
                date.setFullYear(date.getFullYear()+((amount*10)*multiplier));
                break;

            case "C":
                boundary = true;
            case "c":
                date.setFullYear(date.getFullYear()+((amount*100)*multiplier));
                break;
            default:
        }

        if (boundary) {
            if (multiplier > 0) {
                date = this.getEndOf(date, unit, isLogicalDate);
            } else {
                date = this.getStartOf(date, unit, isLogicalDate);
            }
        }
        return date;
    },

    // getStartOf / getEndOf - methods to round a date to start or end of a period (week, day, etc)


    _datetimeOnlyPeriods:{
        ms:true, MS:true,
        s:true, S:true,
        mn:true, MN:true,
        n:true, N:true,
        h:true, H:true,
        d:true, D:true
    },

    //> @classMethod DateUtil.getStartOf() [A]
    // Returns the start of some period, like day, week or month, relative to a passed Date
    // instance.
    // @param date (Date) the base date to find the period start from
    // @param period (String) the period to return the start of, one of mn/h/d/w/m/y
    // @param [logicalDate] (Boolean) process and return a logicalDate with no time element
    // @param [firstDayOfWeek] (Integer) which day should be considered the firstDayOfWeek -
    //                overrides the default provided by the locale
    // @return (Date) a Date instance representing the start of the period relative to the
    //                passed date
    // @visibility external
    //<
    getStartOf : function (date, period, logicalDate, firstDayOfWeek) {
        var year, month, dateVal, hours, minutes, seconds, dayOfWeek;
        if (logicalDate == null) logicalDate = date.logicalDate;

        if (firstDayOfWeek == null && isc.DateChooser)
            firstDayOfWeek = isc.DateChooser.getInstanceProperty("firstDayOfWeek");

        // If we're passed a period <= "day", and we're working in logical dates, just return
        // the date - there's no way to round the time within a "logical date"
        if (logicalDate && this._datetimeOnlyPeriods[period] == true) {
            this.logInfo("DateUtil.getStartOf() passed period:"
                + period + " for logical date. Ignoring");
            var newDate = new Date(date.getTime());
            newDate.logicalDate = true;
            return newDate;
        }

        if (!isc.Time._customTimezone || logicalDate) {
            month = date.getMonth();
            dateVal = date.getDate();
            year = date.getFullYear();
            hours = date.getHours();
            minutes = date.getMinutes();
            seconds = date.getSeconds();

            dayOfWeek = date.getDay();

        // Developer specified custom timezone
        } else {
            // Use the "offsetDate" trick we use for formatting datetimes - easier to shift the
            // date and call native date APIs than to actually modify potentially
            // minute, hour, date, month, year directly.
            var offsetDate = date._getTimezoneOffsetDate(
                                isc.Time.getUTCHoursDisplayOffset(date),
                                isc.Time.getUTCMinutesDisplayOffset(date)
                             );

            month = offsetDate.getUTCMonth();
            dateVal = offsetDate.getUTCDate();
            year = offsetDate.getUTCFullYear();

            hours = offsetDate.getUTCHours();
            minutes = offsetDate.getUTCMinutes();
            seconds = offsetDate.getUTCSeconds();

            dayOfWeek = offsetDate.getDay();
        }

        switch (period.toLowerCase()) {
            case "s":
                // start of second - bit dramatic, but may as well be there
                return Date.createDatetime(year, month, dateVal, hours, minutes, seconds, 0);
            case "mn":
            case "n":
                // start of minute
                return Date.createDatetime(year, month, dateVal, hours, minutes, 0, 0);

            case "h":
                // start of hour
                return Date.createDatetime(year, month, dateVal, hours, 0, 0, 0);

            case "d":
                // start of day
                if (dateVal != date.getDate()) dateVal = date.getDate();
                if (month != date.getMonth()) month = date.getMonth();
                if (year != date.getFullYear()) year = date.getFullYear();
                if (logicalDate) {
                    return Date.createLogicalDate(year, month, dateVal);
                } else {
                    return Date.createDatetime(year, month, dateVal, 0, 0, 0, 0);
                }

            case "w":
                // start of week
                var newDate;
                if (logicalDate) {
                    newDate = Date.createLogicalDate(year, month, dateVal);
                } else {
                    newDate = Date.createDatetime(year, month, dateVal, 0, 0, 0, 0);
                }
                var delta = dayOfWeek - firstDayOfWeek;
                if (delta < 0) delta += 7;
                else if (delta > 0) delta += firstDayOfWeek;
                newDate.setDate(newDate.getDate()-delta);
                return newDate;

            case "m":
                // start of month
                if (logicalDate) {
                    return Date.createLogicalDate(year, month, 1);
                } else {
                    return Date.createDatetime(year, month, 1, 0, 0, 0, 0);
                }
            case "q":
                // start of quarter
                var quarterStart = month - (month % 3);
                if (logicalDate) {
                    return Date.createLogicalDate(year, quarterStart, 1);
                } else {
                    return Date.createDatetime(year, quarterStart, 1, 0, 0, 0, 0);
                }
            case "y":
            case "yy":
            case "yyyy":
                // start of year
                if (logicalDate) {
                    return Date.createLogicalDate(year, 0, 1);
                } else {
                    return Date.createDatetime(year, 0, 1, 0, 0, 0, 0);
                }

            case "dc":
                // start of decade
                var decade = year - (year % 10);
                if (logicalDate) {
                    return Date.createLogicalDate(decade, 0, 1);
                } else {
                    return Date.createDatetime(decade, 0, 1, 0, 0 ,0, 0);
                }

            case "c":
                // start of century
                var century = year - (year % 100);
                if (logicalDate) {
                    return Date.createLogicalDate(century, 0, 1);
                } else {
                    return Date.createDatetime(century, 0, 1, 0, 0, 0, 0);
                }
        }

        return date.duplicate();
    },

    //> @classMethod DateUtil.getEndOf() [A]
    // Returns the end of some period, like day, week or month, relative to a passed Date
    // instance.
    // @param date (Date) the base date to find the period end from
    // @param period (String) the period to return the end of, one of mn/h/d/w/m/y
    // @param [logicalDate] (Boolean) process and return a logicalDate with no time element
    // @param [firstDayOfWeek] (Integer) which day should be considered the firstDayOfWeek -
    //                overrides the default provided by the locale
    // @return (Date) a Date instance representing the end of the period relative to the
    //                passed date
    // @visibility external
    //<
    getEndOf : function (date, period, logicalDate, firstDayOfWeek) {

        var year, month, dateVal, hours, minutes, seconds, dayOfWeek;
        if (logicalDate == null) logicalDate = date.logicalDate;

        if (firstDayOfWeek == null && isc.DateChooser)
            firstDayOfWeek = isc.DateChooser.getInstanceProperty("firstDayOfWeek");

        // If we're passed a period <= "day", and we're working in logical dates, just return
        // the date - there's no way to round the time within a "logical date"
        if (logicalDate && this._datetimeOnlyPeriods[period] == true) {
            this.logInfo("DateUtil.getEndOf() passed period:"
                + period + " for logical date. Ignoring");
            var newDate = new Date(date.getTime());
            newDate.logicalDate = true;
            return newDate;
        }

        if (!isc.Time._customTimezone || logicalDate) {
            month = date.getMonth();
            dateVal = date.getDate();
            year = date.getFullYear();
            hours = date.getHours();
            minutes = date.getMinutes();
            seconds = date.getSeconds();

            dayOfWeek = date.getDay();

        // Developer specified custom timezone
        } else {
            // Use the "offsetDate" trick we use for formatting datetimes - easier to shift the
            // date and call native date APIs than to actually modify potentially
            // minute, hour, date, month, year directly.
            var offsetDate = date._getTimezoneOffsetDate(
                                isc.Time.getUTCHoursDisplayOffset(date),
                                isc.Time.getUTCMinutesDisplayOffset(date)
                             );

            month = offsetDate.getUTCMonth();
            dateVal = offsetDate.getUTCDate();
            year = offsetDate.getUTCFullYear();

            hours = offsetDate.getUTCHours();
            minutes = offsetDate.getUTCMinutes();
            seconds = offsetDate.getUTCSeconds();

            dayOfWeek = offsetDate.getDay();
        }

        switch (period.toLowerCase()) {
            case "s":
                // end of second
                return Date.createDatetime(year, month, dateVal, hours, minutes, seconds, 999);
            case "mn":
            case "n":
                // end of minute
                return Date.createDatetime(year, month, dateVal, hours, minutes, 59, 999);

            case "h":
                // end of hour
                return Date.createDatetime(year, month, dateVal, hours, 59, 59, 999);

            case "d":
                // end of day
                if (dateVal != date.getDate()) dateVal = date.getDate();
                if (month != date.getMonth()) month = date.getMonth();
                if (year != date.getFullYear()) year = date.getFullYear();
                if (logicalDate) {
                    return Date.createLogicalDate(year, month, dateVal);
                } else {
                    return Date.createDatetime(year, month, dateVal, 23, 59, 59, 999);
                }

            case "w":
                // end of week
                var delta = (6-(dayOfWeek-firstDayOfWeek));
                if (delta >= 7) delta -= 7;
                var endDate = dateVal + delta;
                if (logicalDate) {
                    return Date.createLogicalDate(year, month, endDate);
                } else {
                    return Date.createDatetime(year, month, endDate, 23, 59, 59, 999);
                }

            case "m":
                // end of month
                // Get start of *next* month, then knock back to prev day.
                var newDate;
                if (logicalDate) {
                    newDate = Date.createLogicalDate(year, month+1, 1);
                    newDate.setDate(newDate.getDate() - 1);
                } else {
                    newDate = Date.createDatetime(year, month+1, 1, 0, 0, 0, 0);
                    newDate.setTime(newDate.getTime()-1);
                }
                return newDate;

            case "q":
                // end of quarter
                var nextQ = month + 3 - (month%3),
                    newDate;
                if (logicalDate) {
                    newDate = Date.createLogicalDate(year, nextQ, 1);
                    newDate.setDate(newDate.getDate()-1);
                } else {
                    newDate = Date.createDatetime(year, nextQ, 1, 0, 0, 0, 0);
                    newDate.setTime(newDate.getTime()-1);
                }
                return newDate;

            case "y":
            case "yy":
            case "yyyy":
                // end of year
                if (logicalDate) {
                    return Date.createLogicalDate(year, 11, 31);
                } else {
                    return Date.createDatetime(year, 11, 31, 23, 59, 59, 999);
                }

            case "dc":
                // end of decade
                var decade = year + 10 - (year % 10);
                if (logicalDate) {
                    return Date.createLogicalDate(decade, 11, 31);
                } else {
                    return Date.createDatetime(decade, 11, 31, 23, 59, 59, 999);
                }

            case "c":
                // start of century
                var century = year +100 - (year % 100);
                if (logicalDate) {
                    return Date.createLogicalDate(century, 11, 31);
                } else {
                    return Date.createDatetime(century,  11, 31, 23, 59, 59, 999);
                }
        }
        return date.duplicate();
    },

    // mappings between "TimeUnit" strings and the equivalent period markers used in
    // RelativeDateStrings and Calendars/Timelines
    _timeUnitMapping:{
        ms:"millisecond",
        s:"second",
        // support mn and n for minutes (Excel uses n)
        mn:"minute",
        n:"minute",
        h:"hour",
        d:"day",
        w:"week",
        m:"month",
        q:"quarter",
        // support y, yy and yyyy for year (Excel uses yyyy)
        y:"year",
        yy:"year",
        yyyy:"year",
        dc:"decade",
        c:"century"
    },
    getTimeUnitName : function (timeUnitKey) {
        var value = timeUnitKey.toLowerCase();
        return this._timeUnitMapping[value] || value;
    },
    getTimeUnitKey : function (timeUnitName) {
        if (this._timeUnitReverseMapping == null) {
            this._timeUnitReverseMapping = isc.makeReverseMap(this._timeUnitMapping);
        }
        var value = timeUnitName.toLowerCase();
        return this._timeUnitReverseMapping[value] || value;
    },
    compareTimeUnits : function (unitName, otherUnitName) {
        var unitMS = this.getTimeUnitMilliseconds(unitName),
            otherUnitMS = this.getTimeUnitMilliseconds(otherUnitName)
        ;
        if (unitMS <= otherUnitMS) return -1;
        if (unitMS == otherUnitMS) return 0;
        return 1;
    },
    getTimeUnitMilliseconds : function (timeUnitName) {
        var name = this.getTimeUnitName(timeUnitName),
            l = { millisecond: 1, second: 1000 }
        ;

        l.minute = l.second * 60;
        l.hour = l.minute * 60;
        l.day = l.hour * 24;
        l.week = l.day * 7;
        l.month = l.day * 30; // this is accurate enough for the purposes of this method
        l.quarter = l.month * 3;
        l.year = l.day * 365;
        l.decade = l.year * 10;
        l.century = l.decade * 10;

        return l[name];
    },

    convertPeriodUnit : function (period, fromUnit, toUnit) {
        if (fromUnit == toUnit) return period;
        var fromKey = this.getTimeUnitKey(fromUnit),
            toKey = this.getTimeUnitKey(toUnit),
            millis = (fromKey == "ms" ? period : period * this.getTimeUnitMilliseconds(fromKey)),
            result = millis / this.getTimeUnitMilliseconds(toKey)
        ;
        return result;
    },

    getTimeUnitTitle : function (unit) {
        return this.getTimeUnitName(unit);
    },

    getPeriodLength : function (startDate, endDate, unit, roundUnit) {
        var periodLength = (endDate.getTime() - startDate.getTime());
        if (unit) periodLength = isc.DateUtil.convertPeriodUnit(periodLength, "ms", unit);
        return periodLength;
    }
});








  //>DEBUG
// This lets us label methods with a name within addMethods
String.prototype.Class = "String";
  //<DEBUG

//>    @class String
//    Generic extensions to JavaScript Strings.  You can call these on any String.
// @treeLocation Client Reference/System
// @visibility external
//<

isc._patchLocaleSupport = function () {

    var protos = [Array, Number, Date].getProperty("prototype");
    for (var i = 0; i < protos.length; i++) {
        var theProto = protos[i];
        if (theProto.toLocaleString == null) {
            theProto.toLocaleString = theProto.toString;
        }
    }

    // ensure String.toLocaleUpper/LowerCase are there so we can call them blindly
    var strProto = String.prototype;
    if (!strProto.toLocaleUpperCase) {
        strProto.toLocaleUpperCase = strProto.toUpperCase;
        strProto.toLocaleLowerCase = strProto.toLowerCase;
    }

    // Mozilla's String.toLocaleString() actually does the equivalent of Object.toString(),
    // which is to return [object String] instead of the string value, so we patch it to
    // simply return the equivalent of String.toString() since Strings are unicode by nature.
    if (isc.Browser.isMoz) {
        var string = "x",
            localeString = string.toLocaleString();
            if (localeString != string) {

                strProto.toBrowserLocaleString = strProto.toLocaleString;
                strProto.toLocaleString = strProto.toString;
            }
        // Patch Boolean as well
        string = true;
        localeString = string.toLocaleString();
        if (localeString != string + "") {

            Boolean.prototype.toBrowserLocaleString = Boolean.prototype.toLocaleString;
            Boolean.prototype.toLocaleString = Boolean.prototype.toString;
        }
    }
}
isc._patchLocaleSupport();

isc.addProperties(String, {
    _singleQuoteRegex : new RegExp("'", "g"),
    _doubleQuoteRegex : new RegExp("\"", "g")
});

isc.addMethods(String.prototype, {

//>    @method    string.replaceAll()
//            Replace all occurances of 'find' string with 'replacement' string.
//            Uses a native method so is very efficient (and easier to use than grep).
//        @group    stringProcessing
//
//        @param    find        (string)    string to find
//        @param    replacement    (string)    string to replace each occurance of find with
//
//        @return                (string)    new string with replacements made
//<
replaceAll : function (find, replacement) {

    return isc.replaceAll(this, find, replacement);
},

//>    @method    string.contains()
//            Returns true if this string contains the specified substring.
//        @group    stringProcessing
//
//        @param    substring    (String)    string to look for
//        @return                (boolean)    true == this string contains the substring
// @visibility external
//<
contains : function (substring) {
    // support eg Numbers.  Note: only available with non-performance-critical version of API
    if (substring && !isc.isA.String(substring)) substring = substring.toString();


    return isc.contains(this, substring);
},

//>    @method    string.convertTags()    (A)
//            Convert all tag symbols ( &lt;  and &gt; ) into displayable HTML
//            by changing them to   &amp;lt;  and  &amp;gt;   respectively.
//        @group    stringProcessing
//
//        @param    [prefix]    (string)    text to tack onto the beginning of result (eg: "&lt;PRE&gt;")
//        @param    [suffix]    (string)    text to tack onto the end of result (eg: "&lt;/PRE&gt;")
//
//        @return                (string)    prefix + converted text + suffix as a single string
//<
convertTags : function (prefix,suffix){
    // use regular expressions to convert < and > characters
    return (prefix ? prefix : "") +
        this.replace(/</g, "&lt;").replace(/>/g, "&gt;") +
        (suffix ? suffix : "");
},

//>    @method    string.asHTML()
// Convert plain text into into displayable HTML.
// <p>
// This prevents HTML-special characters like &lt; and &gt; from being interpreted as tags, and
// preserves line breaks and extra spacing.
// <pre>
//    converts           to
//    --------             ---------------------------
//    &                   &amp;
//    <                   &lt;
//    >                   &gt;
//    \r,\n,\r\n1space <BR>&nbsp;
//    \r,\n,\r\n       <BR>
//    \t               &nbsp;&nbsp;&nbsp;&nbsp;
//    2 spaces           1space&nbsp;
// </pre>
//
// @group stringProcessing
// @return (string) string of HTML with tags in the original HTML escaped.
//<
asHTML : function (noAutoWrap) {
    var s = this.replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g,"&gt;")
                // if we don't do this, we lose the leading space after a crlf because all
                // browsers except IE in compat (non-standards) mode treat a <BR> followed by a
                // space as just a <BR> (the space is ignored)
                .replace(/(\r\n|\r|\n) /g,"<BR>&nbsp;")
                .replace(/(\r\n|\r|\n)/g,"<BR>")
                .replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;");
    // in autoWrap mode, replace two spaces with a space and an &nbsp; to preserve wrapping to
    // the maximum extent possible
    return (noAutoWrap ? s.replace(/ /g, "&nbsp;") : s.replace(/  /g, " &nbsp;"));
},

asAttValue : function (doubleQuote, includeOuterQuotes) {

    return String.asAttValue(this, doubleQuote, includeOuterQuotes);
},

// revereses asHTML()
unescapeHTML : function () {
    // Note: in asHTML() we turn tabs into four &nbsp;, this reversal is lossy in that it turns
    // those into four spaces - but we really have no way of knowing whether there were four
    // spaces there before or a tab.
    return this.replace(/&nbsp;/g, " ")
               .replace(/<BR>/gi, "\n")
               .replace(/&gt;/g, ">")
               .replace(/&lt;/g, "<")
               .replace(/&amp;/g, "&");
},




//>    @method    string.toInitialCaps()
//            Convert A String To Initial Caps
//        @group    stringProcessing
//
//        @return                (string)    converted string
//<
toInitialCaps : function () {
    // lowercase the entire thing, then split by spaces
    var it = this.toLowerCase().split(" ");
    // for each word
    for (var i = 0; i < it.length; i++) {
        // uppercase the first letter, then add the rest (already lower case)
        it[i] = it[i].substring(0,1).toLocaleUpperCase() + it[i].substring(1);
    }
    return it.join(" ");
},


//>    @method    string.evalDynamicString()
//          Look for &#36;{expressions} in a string and evaluate them.  To escape, prepend a
//          backslash to the dollar sign.  Note that in the event that you actually want
//          to display \&#36;{  you will have to escape the backslash as follows: \\&#36;{.  Note
//          also that if you're writing this in a JS string you must escape the backslash
//          again.
//        @group    dynamicString
//
//        @return                (string)    converted string
//<
evalDynamicString : function (target, evalVars) {


    // must toString() - otherwise strange object literal with slots is returned
    if (this.indexOf("${") < 0) return this.toString();
    var str = this, lastStart, start, end, evalBlock;

    // hand-coded for performance
    var accum = isc.StringBuffer.create();
    while ((start = str.indexOf("${")) != -1) {
            end = str.indexOf("}", start + 1);
            if (end == -1) break;

            // handle escapes
            if (str.charAt(start - 1) == '\\') {
                accum.append(str.slice(0, start - 1), str.slice(start, end + 1));
                str = str.substring(end + 1, str.length);
                continue;
            }
            var evalBlock = str.slice(start + 2, end);
            var evalResult;
            if (evalVars != null && evalBlock in evalVars) {
                // shortcut to avoid evalWithVars, which creates a Function each time
                evalResult = evalVars[evalBlock];
            } else {
                try {
                    evalResult = isc.Class.evalWithVars(evalBlock, evalVars, target);
                } catch (e) {
                    // if a target has been supplied, use that for the log report
                    var logTarget = target ? target : isc.Log;
                    logTarget.logWarn("dynamicContents eval error - returning empty string for block -->${"
                                      + evalBlock + "}<-- error was: " + isc.Log.echo(e));
                    evalResult = isc.emptyString;
                }
            }
            accum.append(str.slice(0, start), evalResult);
            str = str.substring(end + 1, str.length);
    }
    accum.append(str);
    return accum.release(false);
},


//>    @method    string.asSource()    (A)
// Return a new String that, evaluated as source code, would produce this String's value.
//        @group    stringProcessing
//
//        @return                (string)    new string
//<
asSource : function (singleQuote) {
    return String.asSource(this, singleQuote);
},

// String.cssToCamelCaps()
//  Converts a string in css dash syntax "foo-bar-baz" to camelCaps syntax "fooBarBaz".
// Non-alphabetic chars between the '-' and the lowercase letter are ignored,
// eg, 'test-234foo' -> 'test234Foo'.
cssToCamelCaps : function () {
    return this.replace(/-([^a-z]*)([a-z])/g,
                        function (str, p1, p2, offset, s) { return p1 + p2.toUpperCase(); });
}

});

// Concatenates the current string with itself `count' times. If `count' is 0, then an empty
// string is returned.

if (!String.prototype.repeat) {
    String.prototype.repeat = function (count) {
        count = count << 0;
        var str = String(this);
        if (str === "" || count == 0) return "";

        var repeated = "";
        for (;;) {
            if ((count & 1) == 1) {
                repeated += str;
            }
            count >>>= 1;
            if (count == 0) break;
            str += str;
        }
        return repeated;
    };
}

//> @method string.startsWith()
// Returns <code>true</code> if this string starts with another string, or if the other string
// occurs at the given <code>position</code> within this string.
//
// @param substring (String) other string to check
// @param [position] (int) optional position in this string. Defaults to 0.
// @return (boolean) <code>true</code> if <code>substring</code> occurs within this string at
// position <code>position</code>.
// @group stringProcessing
// @visibility external
//<

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (substring, position) {
        if (isc.isA.RegularExpression(substring)) {
            var a;
            a.throwNewTypeError();
        }

        // support eg Numbers.  Note: only available with non-performance-critical version of API
        substring = String(substring);

        var str = String(this);
        position = Math.min(Math.max(0, position << 0), str.length);
        if (position > str.length - substring.length) return false;
        if (position > 0) str = str.substring(position);


        return isc.startsWith(str, substring);
    };
}


//> @method string.endsWith()
// Returns <code>true</code> if this string ends with another string, or if the other string
// occurs in this string beginning at <code>position - substring.length</code>.
//
// @param substring (String) other string to check
// @param [position] (int) optional position in this string. Defaults to the length of this
// string.
// @return (boolean) <code>true</code> if <code>substring</code> occurs within this string
// ending with <code>position - 1</code>.
// @group stringProcessing
// @visibility external
//<

if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (substring, position) {
        var undef;
        if (isc.isA.RegularExpression(substring)) {
            undef.throwNewTypeError();
        }

        // support eg Numbers.  Note: only available with non-performance-critical version of API
        substring = String(substring);

        var str = String(this);
        if (position !== undef) {
            position = Math.min(Math.max(0, position << 0), str.length);
            if (position < substring.length) return false;
            str = str.substring(0, position);
        }


        return isc.endsWith(str, substring);
    };
}

String.prototype.nativeTrim = String.prototype.trim;
String.prototype.trim = function (chars) {
    if (String.prototype.nativeTrim != null &&
        String.prototype.nativeTrim !== String.prototype.trim &&
        !chars)
    {
        return String.prototype.nativeTrim.call(this);

    } else {
        var str = String(this),
            removeChars = chars || " \t\n\r",
            l = str.length,
            start = 0,
            end = l - 1,
            i = 0;

        // find first character not in the removal list
        while (start < l && removeChars.contains(str.charAt(i++))) start++;

        // find last character not in the removal list
        i = l - 1;
        while (end >= 0 && end >= start && removeChars.contains(str.charAt(i--))) end--;

        return str.substring(start, end + 1);
    }
};


String._unicodeLPattern = "[\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2183\u2184\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005\u3006\u3031-\u3035\u303b\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6e5\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]";
String._unicodeNlPattern = "[\u16ee-\u16f0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303a\ua6e6-\ua6ef]";
String._unicodeMnPattern = "[\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0902\u093a\u093c\u0941-\u0948\u094d\u0951-\u0957\u0962\u0963\u0981\u09bc\u09c1-\u09c4\u09cd\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b62\u0b63\u0b82\u0bc0\u0bcd\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc6\u0ccc\u0ccd\u0ce2\u0ce3\u0d41-\u0d44\u0d4d\u0d62\u0d63\u0dca\u0dd2-\u0dd4\u0dd6\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4\u17b5\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1bab\u1be6\u1be8\u1be9\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302d\u3099\u309a\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaec\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe26]";
String._unicodeMcPattern = "[\u0903\u093b\u093e-\u0940\u0949-\u094c\u094e\u094f\u0982\u0983\u09be-\u09c0\u09c7\u09c8\u09cb\u09cc\u09d7\u0a03\u0a3e-\u0a40\u0a83\u0abe-\u0ac0\u0ac9\u0acb\u0acc\u0b02\u0b03\u0b3e\u0b40\u0b47\u0b48\u0b4b\u0b4c\u0b57\u0bbe\u0bbf\u0bc1\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcc\u0bd7\u0c01-\u0c03\u0c41-\u0c44\u0c82\u0c83\u0cbe\u0cc0-\u0cc4\u0cc7\u0cc8\u0cca\u0ccb\u0cd5\u0cd6\u0d02\u0d03\u0d3e-\u0d40\u0d46-\u0d48\u0d4a-\u0d4c\u0d57\u0d82\u0d83\u0dcf-\u0dd1\u0dd8-\u0ddf\u0df2\u0df3\u0f3e\u0f3f\u0f7f\u102b\u102c\u1031\u1038\u103b\u103c\u1056\u1057\u1062-\u1064\u1067-\u106d\u1083\u1084\u1087-\u108c\u108f\u109a-\u109c\u17b6\u17be-\u17c5\u17c7\u17c8\u1923-\u1926\u1929-\u192b\u1930\u1931\u1933-\u1938\u19b0-\u19c0\u19c8\u19c9\u1a19-\u1a1b\u1a55\u1a57\u1a61\u1a63\u1a64\u1a6d-\u1a72\u1b04\u1b35\u1b3b\u1b3d-\u1b41\u1b43\u1b44\u1b82\u1ba1\u1ba6\u1ba7\u1baa\u1bac\u1bad\u1be7\u1bea-\u1bec\u1bee\u1bf2\u1bf3\u1c24-\u1c2b\u1c34\u1c35\u1ce1\u1cf2\u1cf3\u302e\u302f\ua823\ua824\ua827\ua880\ua881\ua8b4-\ua8c3\ua952\ua953\ua983\ua9b4\ua9b5\ua9ba\ua9bb\ua9bd-\ua9c0\uaa2f\uaa30\uaa33\uaa34\uaa4d\uaa7b\uaaeb\uaaee\uaaef\uaaf5\uabe3\uabe4\uabe6\uabe7\uabe9\uabea\uabec]";
String._unicodeNdPattern = "[\u0030-\u0039\u0660-\u0669\u06f0-\u06f9\u07c0-\u07c9\u0966-\u096f\u09e6-\u09ef\u0a66-\u0a6f\u0ae6-\u0aef\u0b66-\u0b6f\u0be6-\u0bef\u0c66-\u0c6f\u0ce6-\u0cef\u0d66-\u0d6f\u0e50-\u0e59\u0ed0-\u0ed9\u0f20-\u0f29\u1040-\u1049\u1090-\u1099\u17e0-\u17e9\u1810-\u1819\u1946-\u194f\u19d0-\u19d9\u1a80-\u1a89\u1a90-\u1a99\u1b50-\u1b59\u1bb0-\u1bb9\u1c40-\u1c49\u1c50-\u1c59\ua620-\ua629\ua8d0-\ua8d9\ua900-\ua909\ua9d0-\ua9d9\uaa50-\uaa59\uabf0-\uabf9\uff10-\uff19]";
String._unicodePcPattern = "[\u005f\u203f\u2040\u2054\ufe33\ufe34\ufe4d-\ufe4f\uff3f]";
String._jsUnicodeEscapeSequencePattern = "\\u[0-9A-Fa-f]{4}";
String._jsIdentifierStartPattern = "(?:" + String._unicodeLPattern + "|[$_]|" + String._jsUnicodeEscapeSequencePattern + ")";
String._jsUnicodeCombiningMarkPattern = "(?:" + String._unicodeMnPattern + "|" + String._unicodeMcPattern + ")";
String._jsUnicodeDigitPattern = String._unicodeNdPattern;
String._jsUnicodeConnectorPunctuationPattern = String._unicodePcPattern;
// Zero-width non-joiner
String._zwnjPattern = "\u200c";
// Zero-width joiner
String._zwjPattern = "\u200d";
String._jsIdentifierPartPattern = "(?:" + String._jsIdentifierStartPattern + "|" + String._jsUnicodeCombiningMarkPattern + "|" + String._jsUnicodeDigitPattern + "|" + String._jsUnicodeConnectorPunctuationPattern + "|" + String._zwnjPattern + "|" + String._zwjPattern + ")";
String._jsIdentifierNamePattern = "^(?:" + String._jsIdentifierStartPattern + String._jsIdentifierPartPattern + "*)$";
String._jsIdentifierNameRegExp = new RegExp(String._jsIdentifierNamePattern);

String._jsKeywordPattern = "(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|this|throw|try|typeof|var|void|while|with)";
String._jsFutureReservedWordPattern = "(?:class|const|enum|export|extends|import|super)";
String._jsStrictModeFutureReservedWordPattern = "(?:implements|interface|let|package|private|protected|public|static|yield)";
String._jsReservedWordRegExp = new RegExp("^(?:" + String._jsKeywordPattern + "|" + String._jsFutureReservedWordPattern + "|" + String._jsStrictModeFutureReservedWordPattern + "|null|true|false)$");

String._htmlStringToStringTagBodyPattern = '(?:[^"\'>]|"[^"]*"|\'[^\']*\')*';

isc.addMethods(String, {

    //> @classMethod    String.format()
    //  Mimics the Java String.format static method, returning a formatted string using the
    //  specified format string and arguments.  e.g.,
    //  <p/>
    //  String.format('Hello {0}!', 'World')    // returns "Hello World!"
    //  @group  stringProcessing
    //  @param  format  (string)    a format string
    //  @param  args    (varargs)   arguments referenced by the format specifiers in the format string
    //  @return         (string)    formatted string
    //  @visibility internal
    //<

    format : function() {
        var string = arguments[0];
        var values = [];
        for (var i = 1; i < arguments.length; i++) {
            values[i-1] = arguments[i];
        };
        return string.replace(/{(\d+)}/g, function(match, number) {
          return typeof values[number] != 'undefined'
            ? values[number]
            : match
          ;
        });
    },

    //>    @classMethod    String.asSource()
    //            Static method to return a new String that, evaluated as source code, would produce
    //          the passed in String's value.
    //        @group    dynamicString
    //        @param    string  (string)    string to convert
    //        @return            (string)    converted string
    //<

    asSource : function (string, singleQuote) {
        if (!isc.isA.String(string)) string = ""+string;

        var quoteRegex = singleQuote ? String._singleQuoteRegex : String._doubleQuoteRegex,
            outerQuote = singleQuote ? "'" : '"';
        return outerQuote +
                   string.replace(/\\/g, "\\\\")
                         // quote whichever quote we use on the outside
                         .replace(quoteRegex, '\\' + outerQuote)
                         .replace(/\t/g, "\\t")
                         .replace(/\r/g, "\\r")
                         .replace(/\n/g, "\\n")
                         .replace(/\u2028/g, "\\u2028")
                         .replace(/\u2029/g, "\\u2029") + outerQuote;
    },

    // Escapes <code>str</code> as an +externalLink{http://www.w3.org/TR/xml11/#NT-AttValue,XML AttValue}.
    // @param str (string) the string to escape.
    // @param [doubleQuote] (boolean) <code>true</code> to use double-quotes; otherwise, use single-quotes.
    // @param [includeOuterQuotes] (boolean) <code>true</code> to prepend and append the outer
    // quote char; otherwise, the outer quote char is <em>not</em> prepended and appended in the resulting
    // string.
    _attValueSpecialCharsRegex: new RegExp("[<&\"']", ""),
    asAttValue : function (str, doubleQuote, includeOuterQuotes) {
        var inner;
        if (str == null) {
            inner = isc.emptyString;

        } else {
            str = String(str);

            // If there aren't any potentially special characters present in the string, then we can
            // skip the replace() calls.
            if (!this._attValueSpecialCharsRegex.test(str)) {
                inner = str;
            } else {
                var quoteRegex,
                    quoteReplacement;
                if (doubleQuote) {
                    quoteRegex = this._doubleQuoteRegex;
                    quoteReplacement = isc._$quot;
                } else {
                    quoteRegex = this._singleQuoteRegex;
                    quoteReplacement = isc._$39;
                }
                inner = str.replace(isc._RE_amp, isc._$amp)
                           .replace(isc._RE_lt, isc._$lt)
                           .replace(quoteRegex, quoteReplacement);
            }
        }

        if (includeOuterQuotes) {
            var outerQuote = doubleQuote ? "\"" : "'";
            return outerQuote + inner + outerQuote;
        } else {
            return inner;
        }
    },

    _escapedJSONCharsRegExp: /[\u0000-\u001F\u0022\u005C]/g,
    _jsonSubstitutionsTable: {
        '\b': "\\b", // U+0008
        '\t': "\\t", // U+0009
        '\n': "\\n", // U+000A
        '\f': "\\f", // U+000C
        '\r': "\\r", // U+000D
        '"': "\\\"", // U+0022
        '\\': "\\\\" // U+005C
    },
    asJSONString : (isc.Browser._supportsJSONObject
    ?
        window.JSON.stringify
    :
        function (str) {
            var escapedJSONCharsRegExp = String._escapedJSONCharsRegExp;
            escapedJSONCharsRegExp.lastIndex = 0;
            if (!escapedJSONCharsRegExp.test(str)) {
                return '"' + str + '"';
            } else {
                var substitutionsTable = String._jsonSubstitutionsTable;
                return '"' + str.replace(escapedJSONCharsRegExp, function (match) {
                    var sub = substitutionsTable[match];
                    if (sub != null) return sub;
                    sub = match.charCodeAt(0).toString(16);
                    if (sub.length == 1) {
                        return "\\u000" + sub;
                    } else {

                        return "\\u00" + sub;
                    }
                }) + '"';
            }
        }
    ),


    _cssDeclarationValueUnsafeCharsRegex: new RegExp("[^ _.,!#%a-zA-Z0-9-]+", ""),
    _asCSSDeclarationValue : function (str) {
        if (str == null) {
            return "";
        } else {
            return String(str).replace(this._cssDeclarationValueUnsafeCharsRegex, "");
        }
    },


    _fontFamilyEscapes: {
        "\b": "&#x5C;08&#x20;",
        "\t": "&#x5C;09&#x20;",
        "\n": "&#x5C;0A&#x20;",
        "\f": "&#x5C;0C&#x20;",
        "\r": "&#x5C;0D&#x20;",
        "'": "&#x5C;27&#x20;",
        "\"": "&#x5C;22&#x20;",
        "\\": "&#x5C;5C&#x20;",
        " ": "&#x20;",
        "&": "&#x5C;26&#x20;",
        "/": "&#x5C;2F&#x20;",
        "<": "&#x5C;3C&#x20;",
        ">": "&#x5C;3E&#x20;",
        "\u2028": "&#x5C;002028&#x20;",
        "\u2029": "&#x5C;002029&#x20;"
    },
    _fontFamilyEscapeRegExp: /[\b\t\n\f\r'"\\ &\/<>\u2028\u2029]/g,
    _fontFamilyEscapeReplace : function (c) {
        return String._fontFamilyEscapes[c];
    },
    _asFontFamilyValue : function (str) {
        var emptyString = isc.emptyString;
        if (str == null) {
            return emptyString;
        } else {
            str = String(str);
            if (str == emptyString) {
                return emptyString;
            } else {
                var r = String._fontFamilyEscapeRegExp;
                return (r.test(str) ? str.replace(r, String._fontFamilyEscapeReplace) : str);
            }
        }
    },

    // Removes comments, <script>- and <style>-looking blocks, and then removes tags. This can
    // be used to convert an HTMLString value to an attribute like 'aria-label' or the <input>
    // 'placeholder' attribute which do not support HTML content.
    //
    // NOTE: This is not to be used for security purposes (such as to avoid XSS). This function
    // assumes that the HTML is from a trusted source (HTMLString type).
    //
    // The resulting string will probably need to be run through asAttValue().

    _htmlStringToStringRegExp: new RegExp('<(?:' +
                                 // Comment
                                 '!--(?:(?:-*[^->])*--+|-?)' +
                                 // Special "raw text" elements
                                 // Use a "word boundary" assertion \b to avoid matching, for example, <scriptStuff>.
                                 '|script\\b' + String._htmlStringToStringTagBodyPattern + '>[\\s\\S]*?</script\\s*' +
                                 '|style\\b' + String._htmlStringToStringTagBodyPattern + '>[\\s\\S]*?</style\\s*' +
                                 // Regular tag name. HTML elements all have names that only use alphanumeric ASCII characters:
                                 // http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#syntax-tag-name
                                 '|/?[a-z0-9]' +
                                 String._htmlStringToStringTagBodyPattern +
                                 ')>', "ig"),
    htmlStringToString : function (html) {
        if (html == null) return "";

        html = String(html).replace(/<BR\s*>/ig, "\n");

        var oldHtml;
        do {
            oldHtml = html;
            html = html.replace(this._htmlStringToStringRegExp, "");
        } while (html.length != oldHtml.length);

        // If the HTMLString happens to end in a partial tag, remove that.
        // Exception: If there is whitespace after the '<' or it is preceded by another '<',
        // then keep it. E.g.: '<< Less', '< $monthName'
        var pos = html.search(/<(?!\s)[^>]*$/);
        if (pos >= 0 && (pos == html.length - 1 || html.charCodeAt(pos + 1) != 60)) html = html.substring(0, pos);

        var text;

        // Unescape HTML entities

        if (html.indexOf("&") >= 0) {
            var spanElem = document.createElement("span");
            spanElem.innerHTML = html;
            text = (spanElem.innerText || spanElem.textContent);
        } else {
            text = html;
        }

        return text;
    },

    //> @classMethod String.isValidID()
    // Tests whether the given string is a valid JavaScript identifier.
    //
    // @param string (string) the string to test.
    // @return (boolean) true if string is a valid JavaScript identifier; false otherwise.
    // @visibility external
    //<
    isValidID : function (string) {
        if (!isc.isA.String(string)) return false;
        // A JavaScript Identifier is an IdentifierName that is not a ReservedWord. (ECMA-262 Section 7.6)
        return (string.search(String._jsIdentifierNameRegExp) != -1 &&
                string.search(String._jsReservedWordRegExp) == -1);
    }
});






isc.addMethods(isc, {

// isc.replaceAll() [string helper]
//  Replace all occurances of 'find' string with 'replacement' string.
//  Uses a native method so is very efficient (and easier to use than grep).
replaceAll : function (source, find, replacement) {
    return source.split(find).join(replacement);
},

// isc.contains() [string helper]
//  Returns true if this string contains the specified substring.
contains : function (string1, substring) {
    if (string1 == null) return false;

    return string1.indexOf(substring) > -1;
},

// isc.startsWith() [string helper]
//  Returns true if this string starts with another string.
startsWith : function (string1, substring) {
    if (string1 == null) return false;

    return (string1.lastIndexOf(substring, 0) == 0);
},


// isc.endsWith() [string helper]
//  Returns true if this string ends with another string.
endsWith : function (string1, substring) {
    if (string1 == null) return false;

    var startPos = string1.length - substring.length;
    if (startPos < 0) return false; // substring longer than main string
    return (string1.indexOf(substring, startPos) == startPos);
},

// escapes special characters in XML values - so called 'unparsed data'
// " -> &quot;
// ' -> &apos;
// & -> &amp;
// < -> &lt;
// > -> &gt;
// \r -> &x000D;
//
// NOTE: in an XHTML document, this is baseline functionality.
//
// NOTE: leave these functions at the end of the file because the quotes within regex's hose the
// obfuscator, causing it to continue to end of file
makeXMLSafe : function (string, amp, lt, gt, quot, apos, cr) {
    if (string == null) return isc.emptyString;
    else if (!isc.isA.String(string)) string = string.toString();

    if (amp != false) string = string.replace(this._RE_amp, this._$amp);
    if (lt != false) string = string.replace(this._RE_lt, this._$lt);
    if (gt != false) string = string.replace(this._RE_gt, this._$gt);
    if (quot != false) string = string.replace(String._doubleQuoteRegex, this._$quot);
    if (apos != false) string = string.replace(String._singleQuoteRegex, this._$apos);
    if (cr != false) string = string.replace(this._RE_cr, this._$escapedCR);
    string = string.replace(this._RE_restricted, isc.emptyString);
    return string;
},
xmlAttributeEscapeLF:true,
makeXMLSafeAttribute : function (string, amp, lt, gt, quot, apos, cr, lf) {
    // Ambiguity in spec/implementation on how to encode a LF (\n) in an attribute:
    //
    // http://stackoverflow.com/questions/2004386/how-to-save-newlines-in-xml-attribute
    //
    // Empirical testing with Reify shows that simply not escaping LFs in attributes doesn't work - we
    // get a space instead. This is exemplied in the breakage of the following autoTest due to
    // our marking FormItem.defaultValue as xmlAttribute="true" and then feeding a defaultValue
    // with a line break to the BMML import logic and expecting it to be preserved:
    //
    // http://localhost.smartclient.com:15011/isomorphic/QA/VisualBuilder/bmmlImporter/InVivoRequestsGridBmmlTest.test.jsp
    //
    // To be super safe we have this separate makeXMLSafeAttribute() method that
    // calls makeXMLSafe and then additionally escapes LFs and then use that anytime we want to
    // encode an attribute.
    string = this.makeXMLSafe(string, amp, lt, gt, quot, apos, cr);
    if (lf != false && isc.xmlAttributeEscapeLF) string = string.replace(this._RE_lf, this._$escapedLF);
    return string;
},
_$amp:"&amp;",
_$lt:"&lt;",
_$gt:"&gt;",
_$quot:"&quot;",
_$apos:"&apos;",
_$39:"&#39;",
_$escapedCR:"&#x000D;",
_$escapedLF:"&#x000A;",
_RE_amp:/&/g,
_RE_lt:/</g,
_RE_gt:/>/g,
_RE_cr:/\r/g,
_RE_lf:/\n/g,
// restricted chars: use discouraged per https://www.w3.org/TR/xml11/#NT-Char
_RE_restricted:/[\u0001-\u0008\u000B-\u000C\u000E-\u001F\u007F-\u0084\u0086-\u009F]/g,

makeCDATA : function (string) {
    return "<![CDATA["+string.replace(/\]\]>/, "]]<![CDATA[>")+"]]>";
}

});









//>    @class    StringBuffer
//
//        Use instances of this class to concatenate strings rather than using the normal "this"+"that" methodology.
//        For large sets of strings, this can be up to an order of mangintude faster!
//
//        You can use this class in two ways:
//            1) if you have a static and fairly small set of things to concatenate, call statically
//                    alert(StringBuffer.concat("this"," ","that ","and the other"))
//                yields:        "This that and the other"
//
//            2) if you have a loop or more complex logic, create s StringBuffer instance and append to that,
//                then do a buffer.toString() on the results (or do something like an alert() or document.write()
//                that does a toString() for you:
//
//                  <pre>
//                    var buffer = StringBuffer.newInstance();
//                    for (var i = 0; i < 10; i++) {
//                        buffer.append(i, " ");
//                    }
//                    alert(buffer)
//                yields:    "0 1 2 3 4 5 6 7 8 9 "
//              </pre>
//<
isc.ClassFactory.defineClass("StringBuffer");
// nickname
isc.SB = isc.StringBuffer;

isc.StringBuffer.addClassProperties({
    // For efficiency we re-use StringBuffers (created lazily when needed).
    _bufferPool:[],
    // upper limit on the number of outstanding buffers to be re-used
    _maxPoolSize:50
});


isc.StringBuffer.addProperties({

    maxStreamLength : (isc.Browser.isIE6 ? 1000 : 100000),

    // Don't add props passed in to the SB on create - not supported and this is slightly
    // more efficient
    addPropertiesOnCreate:false

});
isc.StringBuffer.addMethods({


//>    @method        stringBuffer.init()    (A)
// Initialize the string buffer
//        @group    concat
//
//        @param    [a,b,c]    (object)    properties for the buffer instance
//<
init: function () {
    // create the stream array
    this._stream = [];
},

//>    @method        stringBuffer.append()
// Append all arguments to the string buffer as strings
//        @group    concat
//
//        @param    [arguments]    (string)    strings to append to the buffer
//<
append : function (arg1,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z) {


    // Set up local variable to use - this is a very small amount quicker than always referencing
    // this._stream directly
    var theStream = this._stream,  // by reference - manipulating this manipulates this._stream
        strings,
        undef;

    // If we are passed an array, it's quickest to manually add it slot by slot
       if (arg1 != null && arg1.constructor.__nativeType == 2) {



        var length = arg1.length;
        if (length <= 30) {
            var length = theStream.length;
            for (var i = 0; i < arg1.length; i++) {
                theStream[length++] = arg1[i];
            }
        } else {
            theStream[theStream.length] = arg1.join(isc.emptyString)
        }


    // If we are not passed an array it's quickest to iterate through the arguments and add them
    // to this._stream.
    // We don't have arguments.join(), and adding it is too expensive
    } else {
        if (Z === undef && Y === undef && X === undef) {


            if (arg1 != null) theStream[theStream.length] = arg1;
            if (A != null) theStream[theStream.length] = A
            if (B != null) theStream[theStream.length] = B
            if (C != null) theStream[theStream.length] = C
            if (D != null) theStream[theStream.length] = D
            if (E != null) theStream[theStream.length] = E
            if (F != null) theStream[theStream.length] = F
            if (G != null) theStream[theStream.length] = G
            if (H != null) theStream[theStream.length] = H
            if (I != null) theStream[theStream.length] = I
            if (J != null) theStream[theStream.length] = J
            if (K != null) theStream[theStream.length] = K
            if (L != null) theStream[theStream.length] = L
            if (M != null) theStream[theStream.length] = M
            if (N != null) theStream[theStream.length] = N
            if (O != null) theStream[theStream.length] = O
            if (P != null) theStream[theStream.length] = P
            if (Q != null) theStream[theStream.length] = Q
            if (R != null) theStream[theStream.length] = R
            if (S != null) theStream[theStream.length] = S
            if (T != null) theStream[theStream.length] = T
            if (U != null) theStream[theStream.length] = U
            if (V != null) theStream[theStream.length] = V
            if (W != null) theStream[theStream.length] = W

        // If we were passed more than 27 args, look at the arguments object

        } else {
            strings = arguments;
            for (var i = 0, l = strings.length; i < l; i++) {
                theStream[theStream.length] = strings[i]
            }
        }
    }

    // if we're holding on to too many string instances, collapse them into one instance
    // This is because IE slows down in general when a lot of large objects are sitting in
    // memory
    if (theStream.length > this.maxStreamLength) {
        theStream[0] = theStream.join(isc.emptyString);
        //isc.Log.logWarn("collapsing stream: " + theStream[0].substring(0, 80));
        theStream.length = 1;
    }
    return this;
},


appendNumber : function (number, length) {
    var stream = this._stream;
    if (length == null) {
        length = 5;
        var numberCopy = number;
        if (numberCopy < 0) {
            numberCopy = 0 - numberCopy;
            // add one for the "-" char
            length += 1;
        }
        // If it will take up more than 5 slots, determine how many it needs
        if (numberCopy >= 100000) {
            numberCopy = numberCopy / 100000;
            while (numberCopy >= 1) {
                length += 1;
                numberCopy = numberCopy / 10;
            }
        }
    }
    isc._fillNumber(stream, number, stream.length, length);
},

clear : function () {
    this._stream.length = 0;
},


// Can be called when a stringBuffer is no longer required - gets added to the pool to be reused
// Also returns the buffer's contents
release : function (noReturnValue) {

    var SB = isc.SB, pool = SB._bufferPool,
        string = noReturnValue ? null : this.toString();
    if (pool.length < SB._maxPoolSize) {

        // Clear it out and put it into the pool
        this.clear();
        pool[pool.length] = this;
    }
    if (!noReturnValue) return string;
},


getArray : function () {
    return this._stream;
}

});

//>    @method        stringBuffer.toString()
//        @group    concat
//             Return all of the appended strings as a single string.
//             Added manually here since doing it with addMethods doesn't work because toString is not
//             enumerable.
//
//        @return    (string)    a single concatenated string
//<
isc.StringBuffer.getPrototype().toString = function () {
    //if (isc.Browser.isMoz) isc.SB._checkArray(this._stream);
    return this._stream.join(isc.emptyString);
}

isc.StringBuffer._joinFunc = Array.prototype.join;
isc.StringBuffer.addClassMethods({

// Override create() - if we've already created a stringBuffer that's no longer being
// used, reuse it.
create : function () {
    var pool = this._bufferPool,
        poolLength = pool.length;
    if (poolLength > 0) {
        var buffer = pool[poolLength -1];
        pool.length = poolLength -1;
        return buffer;
    } else {
        // standard creation.
        return isc.Class.create.apply(this);
    }
},



//>    @method        StringBuffer.concat()
//        @group    concat
//             Static method that will return a string composed of the arguments passed in
//
//        @return    (string)    a single concatenated string
//<
_joinBuffer : [],
concat : function (A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,
                   a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)
{


    var undef,
        returnString;
    if (isc.Browser.isIE && x === undef && y === undef && z === undef) {
        var buffer = this._joinBuffer;
        buffer.length = 0;


        if (A != null) buffer[buffer.length] = A;
        if (B != null) buffer[buffer.length] = B;
        if (C != null) buffer[buffer.length] = C;
        if (D != null) buffer[buffer.length] = D;
        if (E != null) buffer[buffer.length] = E;
        if (F != null) buffer[buffer.length] = F;
        if (G != null) buffer[buffer.length] = G;
        if (H != null) buffer[buffer.length] = H;
        if (I != null) buffer[buffer.length] = I;
        if (J != null) buffer[buffer.length] = J;
        if (K != null) buffer[buffer.length] = K;
        if (L != null) buffer[buffer.length] = L;
        if (M != null) buffer[buffer.length] = M;
        if (N != null) buffer[buffer.length] = N;
        if (O != null) buffer[buffer.length] = O;
        if (P != null) buffer[buffer.length] = P;
        if (Q != null) buffer[buffer.length] = Q;
        if (R != null) buffer[buffer.length] = R;
        if (S != null) buffer[buffer.length] = S;
        if (T != null) buffer[buffer.length] = T;
        if (U != null) buffer[buffer.length] = U;
        if (V != null) buffer[buffer.length] = V;
        if (W != null) buffer[buffer.length] = W;
        if (X != null) buffer[buffer.length] = X;
        if (Y != null) buffer[buffer.length] = Y;
        if (Z != null) buffer[buffer.length] = Z;
        if (a != null) buffer[buffer.length] = a;
        if (b != null) buffer[buffer.length] = b;
        if (c != null) buffer[buffer.length] = c;
        if (d != null) buffer[buffer.length] = d;
        if (e != null) buffer[buffer.length] = e;
        if (f != null) buffer[buffer.length] = f;
        if (g != null) buffer[buffer.length] = g;
        if (h != null) buffer[buffer.length] = h;
        if (i != null) buffer[buffer.length] = i;
        if (j != null) buffer[buffer.length] = j;
        if (k != null) buffer[buffer.length] = k;
        if (l != null) buffer[buffer.length] = l;
        if (m != null) buffer[buffer.length] = m;
        if (n != null) buffer[buffer.length] = n;
        if (o != null) buffer[buffer.length] = o;
        if (p != null) buffer[buffer.length] = p;
        if (q != null) buffer[buffer.length] = q;
        if (r != null) buffer[buffer.length] = r;
        if (s != null) buffer[buffer.length] = s;
        if (t != null) buffer[buffer.length] = t;
        if (u != null) buffer[buffer.length] = u;
        if (v != null) buffer[buffer.length] = v;
        if (w != null) buffer[buffer.length] = w;
        if (x != null) buffer[buffer.length] = x;
        if (y != null) buffer[buffer.length] = y;
        if (z != null) buffer[buffer.length] = z;

        returnString = buffer.join(isc.emptyString);
    } else {
        arguments.join = this._joinFunc;
        returnString = arguments.join(isc.emptyString);
    }

    return returnString;
}

});










isc.defineClass("StringMethod");

// Actual string value of the method is stored in the "value" property

isc.StringMethod.addMethods({

getValue : function () {
    return this.value;
},

// Helper method to get a 'display value' for the stringMethod
// Returns the expression / body of the function or, for actions, the title of the action
getDisplayValue : function () {
    var value = this.getValue();
    if (value == null || isc.isA.String(value)) return value;
    if (value.title != null) return "[" + value.title + "]"
    // If we were created with a string value, return the raw expression
    return value;

},

// not allowed to have ]]> in a CDATA block
cdata : function (string) {
    var index = string.indexOf("]]>");
    if (index == -1) return "<![CDATA[" + string + "]]>";
    return this.cdata(string.slice(0, index)) + "]]&gt;" + this.cdata(string.slice(index+3));
},

_xmlSerialize : function (name, type, namespace, prefix, refs, path) {
    var value = this.value;
    if (isc.isA.String(value)) return isc.Comm._xmlValue(name, this.cdata(value),
                                      type || "stringMethod", namespace, prefix);
    else
        return isc.StringMethod._xmlSerializeAction(value, name, prefix, refs, path);

}

});


// NOTE: toString functions CANNOT be added by addMethods, because a property named "toString"
// will not be enumerated by for..in.  This is actually part of the ECMAScript standard!

isc.StringMethod.getPrototype().toString = function () {
    var value = this.getValue();
    if (value == null || isc.isA.String(value)) return value;
    return value.toString();
},

isc.StringMethod.addClassMethods({

_$Action:"Action",
_xmlSerializeAction : function (action, name, indent, refs, path) {

        var actionDS = isc.DataSource.get(this._$Action);
        if (!actionDS) return isc.Comm._xmlSerializeObject(name, action, path, refs, indent);

        return [isc.Comm._xmlOpenTag(name),
                 actionDS.xmlSerialize(action, null, indent + "        ", this._$Action),
                 "\n", indent,
                 isc.Comm._xmlCloseTag(name)].join(isc.emptyString);

}

})




//> @class URIBuilder
//<
isc.defineClass("URIBuilder").addClassMethods({

create : function (uri) {
    if (isc.isA.String(uri)) return this.Super("create", [{ uri: uri }], arguments);
    else return this.Super("create", arguments);
}

});

isc.URIBuilder.addProperties({

//> @attr URIBuilder.uri (URI : "" : IR)
// The current URI.
//<
uri: ""

});

isc.URIBuilder.addMethods({

init : function () {
    this.Super("init", arguments);
    if (this.uri == null) this.uri = "";
    else this.uri = String(this.uri);
    this._qsStartPos = this._getQsStartPos();
},

_getQsStartPos : function () {
    var uri = this.uri;
    var hashStartPos = uri.indexOf('#');
    if (hashStartPos == -1) {
        return uri.indexOf('?');
    } else {
        var qsStartPos = uri.indexOf('?');
        if (qsStartPos >= hashStartPos) {
            return -1;
        }
        return qsStartPos;
    }
},

appendPath : function (path) {
    if (path == null || path.length == 0) return;

    var encodedPath = encodeURI(path).replace('?', encodeURIComponent('?')).replace('#', encodeURIComponent('#'));

    if (this.uri.length == 0) {
        this.uri = encodedPath;

    } else {
        var pathEndPos = this._qsStartPos;
        if (pathEndPos == -1) {
            pathEndPos = this.uri.indexOf('#');
        }
        if (pathEndPos == -1) {
            pathEndPos = this.uri.length;
        }

        var tmp = this.uri.substring(0, pathEndPos);
        if (pathEndPos > 0 && this.uri.charAt(pathEndPos - 1) != '/' && path.charAt(0) != '/') {
            tmp += '/';
        }
        tmp += encodedPath;
        tmp += this.uri.substring(pathEndPos);
        this.uri = tmp;
        this._qsStartPos = this._getQsStartPos();
    }
},

_indexOfQueryParam : function (encodedName, pos) {
    if (pos == null) pos = this._qsStartPos;
    else pos = Math.max(this._qsStartPos, pos);

    if (pos < 0) return -1;

    var hashStartPos = this.uri.indexOf('#', this._qsStartPos + 1);
    var qsEndPos = hashStartPos == -1 ? this.uri.length : hashStartPos;
    for (; pos < qsEndPos && (pos = this.uri.indexOf(encodedName, pos)) != -1; pos += encodedName.length) {

        if (this.uri.charAt(pos - 1) == '&' || this.uri.charAt(pos - 1) == '?') {
            var pos2 = pos + encodedName.length;
            if (pos2 <= qsEndPos && (pos2 == qsEndPos ||
                                     this.uri.charAt(pos2) == '=' ||
                                     this.uri.charAt(pos2) == '&'))
            {
                return pos;
            }
        }
    }
    return -1;
},

containsQueryParam : function (name) {
    return name != null && this._indexOfQueryParam(encodeURIComponent(name)) != -1;
},

getQueryValue : function (paramName, firstOnly) {
    var encodedParamName = encodeURIComponent(paramName);
    var pos = this._indexOfQueryParam(encodedParamName);
    if (pos < 0) return null;

    var hashStartPos = this.uri.indexOf('#', this._qsStartPos == -1 ? 0 : this._qsStartPos + 1);
    if (hashStartPos == -1) hashStartPos = this.uri.length;

    var ampPos = this.uri.indexOf('&', pos + encodedParamName.length);
    var encodedValueStartPos = pos + (this.uri[pos + encodedParamName.length] === '=' ? encodedParamName.length + 1 : encodedParamName.length);
    var encodedValueEndPos = ampPos >= 0 ? Math.min(ampPos, hashStartPos) : hashStartPos;
    var encodedValue = this.uri.substring(encodedValueStartPos, encodedValueEndPos);

    if (firstOnly || (pos = this._indexOfQueryParam(encodedParamName, encodedValueEndPos)) < 0) {
        return decodeURIComponent(encodedValue);
    } else {
        var values = [decodeURIComponent(encodedValue)];

        do {
            ampPos = this.uri.indexOf('&', pos + encodedParamName.length);
            encodedValueStartPos = pos + (this.uri[pos + encodedParamName.length] === '=' ? encodedParamName.length + 1 : encodedParamName.length);
            encodedValueEndPos = ampPos >= 0 ? Math.min(ampPos, hashStartPos) : hashStartPos;
            encodedValue = this.uri.substring(encodedValueStartPos, encodedValueEndPos);
            values.add(decodeURIComponent(encodedValue));

            pos = this._indexOfQueryParam(encodedParamName, encodedValueEndPos);
        } while (pos >= 0);
        return values;
    }
},

_appendQueryParamHelper : function (prefix, value) {
    if (value == null) return;
    if (isc.isA.String(value)) {
        var hashStartPos = this.uri.indexOf('#', this._qsStartPos == -1 ? 0 : this._qsStartPos + 1);
        if (hashStartPos == -1) hashStartPos = this.uri.length;

        var tmp = this.uri.substring(0, hashStartPos);

        if (this._qsStartPos == -1) {
            this._qsStartPos = hashStartPos;
            tmp += '?';
        } else tmp += '&';
        tmp += prefix;
        tmp += encodeURIComponent(value.toString());
        tmp += this.uri.substring(hashStartPos);
        this.uri = tmp;

    } else if (isc.isAn.Array(value)) {
        for (var i = 0; i < value.length; ++i) {
            this._appendQueryParamHelper(prefix, value[i]);
        }
    } else {
        this._appendQueryParamHelper(prefix, String(value));
    }
},

appendQueryParam : function (name, value) {
    if (name == null) return;

    var encodedName = encodeURIComponent(name);
    var prefix = encodedName + '=';
    this._appendQueryParamHelper(prefix, value);
},

setQueryParam : function (name, value) {
    var encodedName = encodeURIComponent(name);
    var prefix = encodedName + '=';

    if (this._qsStartPos != -1) {
        var hashStartPos = this.uri.indexOf('#', this._qsStartPos + 1);
        var qsEndPos = hashStartPos == -1 ? this.uri.length : hashStartPos;
        var sb = "";
        sb += this.uri.substring(0, this._qsStartPos);
        var prevPos = this._qsStartPos, pos = this._qsStartPos;
        while (pos < qsEndPos && (pos = this.uri.indexOf(prefix, pos)) != -1) {

            var ampPos = this.uri.indexOf('&', pos + prefix.length);

            if (this.uri.charAt(pos - 1) == '&' || this.uri.charAt(pos - 1) == '?') {
                sb += this.uri.substring(prevPos, pos);
                if (ampPos != -1 && ampPos < qsEndPos) {
                    pos = ampPos + 1;
                } else {
                    pos = qsEndPos;
                    sb = sb.substring(0, sb.length - 1);
                }
            } else {
                pos = (ampPos != -1 && ampPos < qsEndPos ? ampPos + 1 : qsEndPos);
                sb += this.uri.substring(prevPos, pos);
            }
            prevPos = pos;
        }
        sb += this.uri.substring(prevPos, this.uri.length);
        this.uri = sb;
        this._qsStartPos = this._getQsStartPos();
    }

    this.appendQueryParam(name, value);
}

});








//>    @class    Cookie
//
//    Singleton class to manage browser cookies automatically.
//    The "Cookie" object is automatically created by the system for you.
//
//    Note that there is a limit to the size of the data that you can store
//    in all cookies for a site; it is generally believed that 1024 characters
//    is the maximum amount you can safely store in all cookies for one site.
//
//    You access cookie functions by calling methods on Cookie directly:
//
//            var value = Cookie.get("myCookieName");
//            Cookie.set("myCookieName", 100);
//            Cookie.clear("myCookieName");
//
//<


isc.ClassFactory.defineClass("Cookie");


//
//    add class methods to the cookie object
//
isc.Cookie.addClassMethods({
//>    @classMethod        Cookie.init()    (A)
//        Initialize the cookies array.  This method is called automatically whenever cookies are
//      accessed to make sure they're always correct.
//<
init : function () {
    isc.Cookie.list = {};
    if (document.cookie == "") return;

    var list = ("" + document.cookie).split("; ");
    for (var i = 0, len = list.length, it; it = list[i], i < len; i++) {
        var equalChar = it.indexOf('='),
            name = (equalChar == -1 ? it : it.substring(0,equalChar))
        ;
        isc.Cookie.list[name] = (equalChar == -1 ? '' : unescape(it.substring(equalChar+1)));
    }
},

//>    @classMethod        Cookie.get()
//        Get the value of a cookie by name.
//
//        @param    name    (string)    name of the cookie
//        @param            (string)    value of the cookie or null if not found
//<
get : function (name) {
    // call init again to refresh the list of cookies
    isc.Cookie.init();

    // get the value of the cookie
    return isc.Cookie.list[name];
},

//>    @classMethod        Cookie.set()
//        Set the value of a cookie.
//
//        @param    name            (string)        name of the cookie
//        @param    value            (string)        value for the cookie
//        @param    [path]            (string)        path to the cookie
//        @param    [domain]        (string)        domain of the cookie
//        @param    [expiration]    (date | string)    expiration date for the cookie
//<
set : function (name, value, path, domain, expiration) {
    // call init again to refresh the list of cookies
    isc.Cookie.init();

    // add the cookie
    document.cookie = name + "=" + escape(value)
                            + (path ? ";path=" + path : "")
                            + (domain ? ";domain=" + domain : "")
                            + (expiration ? ";expires=" + (isc.isA.String(expiration) ? expiration : expiration.toGMTString()) : "");
},

//>    @classMethod        Cookie.clear()
//        Clear a particular cookie.
//
//        @param    name            (string)        name of the cookie
//        @param    [path]            (string)        path to the cookie
//        @param    [domain]        (string)        domain of the cookie
//<
clear: function (name, path, domain) {
    // call init again to refresh the list of cookies
    isc.Cookie.init();

    // set the cookie to empty and set the expiration time to a long time ago
    this.set(name, "", path, domain, "Thu, 01-Jan-70 00:00:01 GMT");
},

//>    @classMethod        Cookie.getList()
//        Return the names of all of the cookies,
//
//        @return        (string[])    array of the names of all the cookies
//<
getList : function () {
    isc.Cookie.init();
    return isc.getKeys(isc.Cookie.list);
}

});





// Encapsulates various bits of logic for generating, converting, and
// presenting stack traces.
isc.defineClass("StackTrace");

isc.StackTrace.addClassMethods({
    // Creates a StackTrace from a browser-native exception stack
    //
    // For instance:
    //
    // try {
    //     eval("bob ===== 7;");
    // }
    // catch (e) {
    //     if (e.stack) {
    //         var trace = isc.StackTrace.fromNativeStack(e.stack);
    //         var output = trace.toString();
    //     }
    // }
    //
    // Chooses the correct subclass based on the browser. If the browser
    // native stack is not supported yet for te browswer, it will simply
    // output the stack itself.
    fromNativeStack : function (stack) {
        if (isc.Browser.isMoz) {
            return isc.MozStackTrace.create({stack: stack});
        } else if (isc.Browser.isChrome) {
            return isc.ChromeStackTrace.create({stack: stack});
        } else if (isc.Browser.isIE) {
            return isc.IEStackTrace.create({stack: stack});
        } else {
            return isc.UnsupportedStackTrace.create({stack: stack});
        }
    },

    // return an intelligently shortened version of the source file and line number
    getSourceLine : function (sourceLine, appDir, hostAndProtocol) {
        appDir = appDir || isc.Page.getAppDir();
        hostAndProtocol = hostAndProtocol || window.location.protocol + "//" + window.location.host;

        sourceLine = sourceLine.replace(/(\?|\&)?sc_selenium=true/, "");

        // detect core modules
        var modulesStart = sourceLine.indexOf("/system/modules/ISC_"),
            devModulesStart = sourceLine.indexOf("/system/development/ISC_");

        // core modules: trim off everything but module name
        if (modulesStart != -1) {
            sourceLine = sourceLine.substring(modulesStart + 16);
        } else if (devModulesStart != -1) {
            sourceLine = sourceLine.substring(devModulesStart + 20) + "[d]";
        }

        if (modulesStart != -1 || devModulesStart != -1) {
            // option to not show core modules
            if (!isc.Log.logIsDebugEnabled("traceLineNumbersCore")) return "";

            // core modules: trim out the version parameter (just noise)
            var versionIndex = sourceLine.indexOf("?isc_version");
            if (versionIndex != -1) {
                sourceLine = sourceLine.substring(0, versionIndex) +
                    sourceLine.substring(sourceLine.indexOf(":"));
            }
        }

        // other files: show obviously relative paths as relative
        if (sourceLine.startsWith(appDir)) {
            sourceLine = sourceLine.substring(appDir.length);
        } else if (sourceLine.startsWith(hostAndProtocol)) {
            sourceLine = sourceLine.substring(hostAndProtocol.length);
        }

        return " @ " + sourceLine;
    }
});


isc.StackTrace.addProperties({
    // Provide the browser-native stack on creation

    stack: null,

    // number of lines in error.stack before actual functions are lised off.  Eg Chrome stacks
    // start with the error message ("Reference error: ...").
    preambleLines : 0,

    // Where we store the "converted" stack trace in readable format
    // Access via the toString() method.
    _output: "",

    init : function() {
        if (this.stack) {
            this._parseStack();
        }
    },

    // Should extract the function name from a line of the stack
    // Implement in a browser-specific subclass
    extractFunctionFromLine : function (line) {
        this.logError("Should implement extractFunctionFromLine in subclass");
    },

    // Should extract the arguments from a line of the stack
    // Implement in a browser-specific subclass
    extractArgumentsFromLine : function (line) {
        this.logError("Should implement extractArgumentsFromLine in subclass");
    },

    // Should extract the source file and line number from a line of the stack
    // Implement in a browser-specific subclass
    extractSourceFromLine : function (line) {
        this.logError("Should implement extractSourceFromLine in subclass");
    },

    // Parse native stack trace
    // ---------------------------------------------------------------------------------------
    // Do an in-browser transform of the native stack to make it more readable.
    //
    // FF theoretically provides an onerror notification, but it seems flaky, and it is not
    // possible to walk the stack via arguments.caller.callee in this notification even when it
    // does fire.  So the best we can get when an error occurs is the native error.stack,
    // which we transform here for readability.
    //
    // How good is it:
    // - if function names have been embedded into framework code with server-side help, we can
    //   correctly identify and print the class and method for all framework functions that go
    //   through the obfuscator
    //   - this is better than the current state of parsing with the help of a server-side Perl
    //     script, which frequently misidentifies functions
    // - worse than stack walking via arguments.callee.caller, where:
    //   - we can identify all functions, regardless of whether they went through the
    //     obfuscator
    //   - we can directly access arguments and format them more meaningfully (eg, show than an
    //     object being passed to a method is an SC class, and show it's ID)
    _parseStack : function () {
        // Parse inside a try/catch block so that we can simply use the supplied
        // stack as the output if an error occurs in parsing.
        try {
            var lines = this.stack.split("\n"),
                output = isc.StringBuffer.create(),
                appDir = isc.Page.getAppDir(),
                hostAndProtocol = window.location.protocol + "//" + window.location.host;

            //isc.logWarn("original trace: " + lines.join("\n\n"));

            for (var i = this.preambleLines; i < lines.length; i++) {
                var line = lines[i],
                    argNames = null,
                    className = null,
                    methodName = null;

                if (isc.isAn.emptyString(line)) continue;

                //isc.logWarn("parsing line: " + line);

                var functionName = this.extractFunctionFromLine(line);
                if (functionName == "") {
                    functionName = "unnamed";
                } else if (functionName.startsWith("isc_")) {
                    var isClassMethod;
                    if (functionName.startsWith("isc_c_")) {
                        functionName = functionName.substring(6);
                        isClassMethod = true;
                    } else {
                        functionName = functionName.substring(4);
                    }
                    className = functionName.substring(0, functionName.indexOf("_"));
                    methodName = functionName.substring(className.length+1);

                    var clazz = isc.ClassFactory.getClass(className),
                        method = null;
                    if (clazz) {
                        method = isClassMethod ?
                            clazz[methodName] : clazz.getInstanceProperty(methodName);
                    }
                    // if we figure out what actual method is being referred to, we can find
                    // out the official argument names and show them
                    if (method != null) {
                        functionName = isc.Func.getName(method, true);
                        //isc.logWarn("Got live method: " + isc.Func.getName(method, true) +
                        //            " from functionName: " + functionName);
                        var argString;
                        if (!isClassMethod) {
                            // takes into account StringMethods
                            argString = clazz.getArgString(methodName);
                        } else {
                            argString = isc.Func.getArgString(method);
                        }
                        argNames = argString.split(",");
                        // NOTE: we checked to see if the live stack might still be there, since that would
                        // let us just call the normal getStackTrace() facility with the exception just
                        // serving to help us locate the leaf method, but as expected, only the stack above
                        // the try..catch is intact.  This does mean that we could call getStackTrace() for
                        // the top of the stack instead of parsing the Moz native trace, but not currently
                        // doing this since it could hit recursion issues and might mislead you into
                        // thinking two arguments differed since our traces provide more information (eg
                        // they look for an ID and display that)
                        //if (method.caller) {
                        //    isc.logWarn("method.caller: " + isc.Func.getName(method.caller, true) +
                        //                "\n" + isc.Log.getCallTrace(method.caller.arguments));
                    } else {
                        functionName = functionName.replace(/_{1}/, ".");
                        functionName = functionName.replace(/_{2}/, "._");
                    }
                }

                output.append("    ", functionName, "(");

                var argString = this.extractArgumentsFromLine(line);
                var argNum = 0;

                while (argString && argString.length > 0) {
                    if (argNum > 0) output.append(", ");
                    if (argNames) output.append(argNames[argNum] + "=>");
                    var lastLength = argString.length;
                    argString = this._parseArgument(argString, output);
                    if (argString.length == lastLength) {
                        isc.logWarn("failure to parse next arg at:\n" + argString);
                        break;
                    }
                    argNum++;
                }

                output.append(")");

                // add source path and line number
                var atIndex = line.lastIndexOf("@");
                output.append(isc.StackTrace.getSourceLine(this.extractSourceFromLine(line),
                                                           appDir, hostAndProtocol));

                output.append("\n");
            }

            this._output = output.release(false);
        }
        // If there are any errors, we just store the stack itself as output
        catch (e) {
            this._output = this.stack;
        }
    },

    // parse an argument from a line in a native stack trace
    _parseArgument : function (argString, output) {
        //isc.logWarn("parsing argString: " + argString);

        var firstChar = argString.charAt(0);

        if (firstChar == "\"") { // string argument
            // look for an unquoted closing quote
            var stringEnd = argString.search(/[^\\]"/);
            if (stringEnd == -1) stringEnd = argString.length; // shouldn't happen

            var stringArg = argString.substring(0, stringEnd+2);
            // enforce max size
            if (stringArg.length > 40) {
                stringArg = stringArg.substring(0,40) + "...\"[ " + stringArg.length + "]";
            }
            output.append(stringArg);
            return argString.substring(stringEnd+3);

        } else if (firstChar == "[") { // object argument
            var closeBrace = argString.substring(1).indexOf("]"),
                objectString = argString.substring(0, closeBrace+2);
            // shorten this common case
            if (objectString == "[object Object]") objectString = "{Obj}";

            output.append(objectString);
            return argString.substring(closeBrace+3);

        } else if (argString.startsWith("(void 0)")) {
            output.append("undef");
            return argString.substring(9);

        } else if (argString.startsWith("undefined")) {
            output.append("undef");
            return argString.substring(10);

        } else if (argString.startsWith("(function ")) {
            var signature = argString.substring(1,argString.indexOf("{"));
            if (signature.endsWith(" ")) signature = signature.substring(0, signature.length-1);
            output.append(signature);

            var functionEnd = argString.indexOf("}),");
            if (functionEnd == -1) return ""; // no more arguments
            return argString.substring(functionEnd+3);

        } else { // other argument
            var nextComma = argString.indexOf(",");
            if (nextComma == -1) nextComma = argString.length;
            output.append(argString.substring(0, nextComma));
            return argString.substring(nextComma+1);
        }
    }
});

// NOTE: toString functions CANNOT be added by addMethods, because a property named "toString"
// will not be enumerated by for..in.  This is actually part of the ECMAScript standard!

isc.StackTrace.getPrototype().toString = function () {
    // Return the normalized output
        return this._output;
};

// The native stack trace for Mozilla has changed.  For FF14 and above, the arguments are
// no longer supplied and the native stack trace looks like:
//
// isc_Canvas_editSummaryField@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:30870
// isc_Canvas_addSummaryField@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:30865
// anonymous@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:420
// isc_Menu_selectMenuItem@http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:28093
// isc_Menu_rowClick@http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:28059
// anonymous@http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:7836
// isc_GridRenderer__rowClick@http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:6199
// isc_c_Class_invokeSuper@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:2263
// isc_c_Class_Super@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:2198
// isc_GridBody__rowClick@http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:6793
// isc_GridRenderer_click@http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:6178
// isc_Canvas_handleClick@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:25741
// isc_c_EventHandler_bubbleEvent@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:15164
// isc_c_EventHandler_handleClick@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:14083
// isc_c_EventHandler__handleMouseUp@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:13973
// isc_c_EventHandler_handleMouseUp@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:13916
// isc_c_EventHandler_dispatch@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:15541
// anonymous@http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:420
//
// For FF13 and earlier, the lines from the native stack trace look something like this:
//
// eval("bob ==== 7;")@:0
// ()@http://localhost:40011/isomorphic/QA/Debug/StackTrace.test:45
// ()@http://localhost:40011/isomorphic/QA/Debug/StackTrace.test:40
// ()@http://localhost:40011/isomorphic/QA/Debug/StackTrace.test:36
// ([object Object],[object Object])@http://localhost:40011/isomorphic/QA/Debug/StackTrace.test:56
// isc_TestCase_run()@http://localhost:40011/isomorphic/system/modules/ISC_Core.js?isc_version=dev.js:29775
// isc_TestRunner_runTests(0)@http://localhost:40011/isomorphic/system/modules/ISC_Core.js?isc_version=dev.js:29920
// isc_TestRunner_init([object Object],(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0))@http://localhost:40011/isomorphic/system/modules/ISC_Core.js?isc_version=dev.js:29882
// isc_Class_completeCreation([object Object],(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0),(void 0))@http://localhost:40011/isomorphic/system/modules/ISC_Core.js?isc_version=dev.js:2323



isc.defineClass("MozStackTrace", isc.StackTrace).addProperties({
    // Parse a line from the stack and extract the function name
    extractFunctionFromLine : function (line) {
        var noArgs = isc.Browser.version >= 14,
            parenIndex = line.indexOf(noArgs ? "@" : "(");
        return line.substring(0, parenIndex);
    },

    // Parse a line from the stack and extract the arguments
    extractArgumentsFromLine : function (line) {
        if (isc.Browser.version >= 14) return "";
        var parenIndex = line.indexOf("(");
        var atIndex = line.lastIndexOf("@");
        return line.substring(parenIndex + 1, atIndex - 1);
    },

    // Extract the source file and line numver from a line
    extractSourceFromLine : function (line) {
        var atIndex = line.lastIndexOf("@");
        if (atIndex >= 0) {
            return line.substring(atIndex + 1);
        } else {
            return "";
        }
    }
});

// Browser specific subclass for Google Chrome
// NOTE: we don't use this code by default because we instead use an obscure prepareStackTrace
// API in Chrome.  See debug.js, look for "useChromeAPIToPrepareStackTrace"
//
// Given this code:
//
//   isc.Page.setEvent("load", function foo () {
//       try {
//           var arr = [];
//           arr.myFunc = function () { crash() };
//           arr.myFunc();
//       } catch (e) {
//           isc.logWarn(e.stack);
//       }
//   });
//
// Error.stack looks like this:
//
//  ReferenceError: crash is not defined
//      at Array.myFunc (http://mime:15011/isomorphic/QA/scratch.jsp:776:31)
//      at Object.foo [as action] (http://mime:15011/isomorphic/QA/scratch.jsp:777:8)
//      at Object.isc_c_Page_handleEvent [as handleEvent] (http://mime:15011/isomorphic/system/modules/ISC_Core.js?isc_version=dev.js:10998:17)
//      at isc_c_EventHandler_handleLoad (http://mime:15011/isomorphic/system/modules/ISC_Core.js?isc_version=dev.js:11702:17)
//
// 1. "Object." and "Array." is the native type of the "this" value.  Yes, incredibly useless
//     given that they clearly have the "this" value and its type is all we get.  May not be
//     present for something executed in global scope (last line)
// 2. "[as action]" means the function was invoked under the name "action" even though the
//     function is named foo.
//
// More background on special cases here, at the bottom:
//   http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
isc.defineClass("ChromeStackTrace", isc.StackTrace).addMethods({
    preambleLines:1,
    _functionRegexp: /at (Object\.)?([^ ]+)/,
    _sourceRegexp: /\((.+)\)/,

    // Parse a line from the stack and extract the function name
    extractFunctionFromLine : function (line) {
        var match = line.match(this._functionRegexp);
        return match ? match[2] : "";
    },

    // Parse a line from the stack and extract the arguments
    // Chrome does not appear to show the arguments ...
    extractArgumentsFromLine : function (line) {
        return "";
    },

    // Extract the source file and line numver from a line
    extractSourceFromLine : function (line) {
        var match = line.match(this._sourceRegexp);
        return match ? match[1] : "";
    }
});

// Chrome-specific code for getting stack information; see useChromeAPIToPrepareStackTrace
isc.ChromeStackTrace.addClassMethods({

    // return the last CallSites trace array captured by Error.prepareStackTrace()
    _getLastErrorCallSitesParsedStack : function (loggingTarget) {
        if (!isc._lastErrorCallSites) return "";

        // resolve function arguments if not already done
        this._resolveCallSiteFunctionArguments();

        var parsedStackBuffer = isc.StringBuffer.create(),
            isTimerTimeoutFunctionWithoutStackTrace = null;

        for (var i = 0; i < isc._lastErrorCallSites.length; i++) {
            var currentCallSite = isc._lastErrorCallSites[i],
            currentCallSiteThis = currentCallSite.getThis();
            if (!currentCallSiteThis) {
                continue;
            }
            var scType = null,
                nativeType = currentCallSite.getTypeName(),
                functionName = currentCallSite.getFunctionName(),
                func         = currentCallSite.getFunction();

            if (!functionName) { // null or ""
                functionName = "<anonymous>";
            } else {
                if (functionName && functionName.startsWith("isc_")) {
                    // class method, name is like isc_c_EventHandler_handleLoad, or
                    // instance method, name is like SectionStack_dragResizeStart
                    var offset = functionName.startsWith("isc_c_") ? 6 : 4;
                    functionName = functionName.substring(offset);

                    // note: we're assuming no SC classes have an underscore in their
                    // name; if they did, the natively returned functionName is ambiguous
                    var firstUnderscore = functionName.indexOf("_");
                    scType = functionName.substring(0, firstUnderscore);
                    functionName = functionName.substring(firstUnderscore + 1);
                } else {
                    // some kind of non-instance non-class method, trim off everything but
                    // the method name as such
                    functionName = functionName.substring(functionName.lastIndexOf(".") + 1);
                }
            }
            var modifier = this._getFunctionModifier(functionName, scType, func);
            var fullFunctionName = (scType != null ? scType : nativeType) + "." + functionName;

            var resolvedArgs = currentCallSite.resolvedArguments;
            if (resolvedArgs == null) {
                // arguments are only available for functions that are still on the stack,
                // so if we are called from a catch{} block we will only report arguments
                // for methods above the catch block
                resolvedArgs = "(<no args: exited>)";
            }
            // for global methods, omit the useless type information
            if (scType == null && (nativeType == "Object" || nativeType == "Window")) {
                fullFunctionName = functionName;
            }
            parsedStackBuffer.append("\t", modifier, fullFunctionName, resolvedArgs, " ");

            // add "this" object information to the frame line detail if useful
            if (isc.isAn.Instance(currentCallSiteThis) ||
                isc.isA.ClassObject(currentCallSiteThis))
            {
                parsedStackBuffer.append("on ", loggingTarget.echoLeaf(currentCallSiteThis),
                                         " ");
            }

            // getMethodName tries to determine the slot where a function exists in an
            // object, is very slow and doesn't return much new information, so
            // don't use it
            //                var mn = currentCallSite.getMethodName();
            //                if (mn) {
            //                    parsedStackBuffer.append("[as ", mn, "] ");
            //                }

            // get fileName and line number
            var fileName = currentCallSite.getFileName();
            if (fileName) {
                fileName = fileName.substring(fileName.lastIndexOf("/") + 1)
                var questionIndex = fileName.lastIndexOf("?");
                if (questionIndex > 0) {
                    fileName = fileName.substring(0, questionIndex);
                }
                parsedStackBuffer.append("@ ", fileName);
            } else {
                parsedStackBuffer.append("@ [no file]");
            }
            parsedStackBuffer.append(
                ":", currentCallSite.getLineNumber(),
                ":", currentCallSite.getColumnNumber(), "\n");
            // pick up stored stack traces that show how setTimeout() was called, leading
            // to the current thread
            if (func != null && func.arguments != null && func.arguments.timerTrace) {
                parsedStackBuffer.append("Stack trace for setTimeout() call:\n" +
                                         func.arguments.timerTrace);
                isTimerTimeoutFunctionWithoutStackTrace = false;
            } else if (fullFunctionName == "Timer.__fireTimeout" &&
                       isTimerTimeoutFunctionWithoutStackTrace == null)
            {
                isTimerTimeoutFunctionWithoutStackTrace = true;
            }
        }
        if (isTimerTimeoutFunctionWithoutStackTrace && isc.Timer.currentAction &&
            isc.Timer.currentAction.timerTrace)
        {
            parsedStackBuffer.append("Stack trace for setTimeout() call:\n" + isc.Timer.currentAction.timerTrace);
        }
        delete isc._lastErrorCallSites;

        return parsedStackBuffer.release(false);
    },

    _getFunctionModifier : function (functionName, type, func) {
        if (type == null) return "";
        var clazz = isc.ClassFactory.getClass(type);
        return (func._instanceSpecific ?
                (func._isOverride ? "[o]" : "[a]") : isc._emptyString) +
                ((clazz != null && clazz[functionName] === func) ? "[c]" : isc._emptyString);
    },

    // _add/_containsCallSiteFunction maintain a hashset of the functions we've processed

    _addCallSiteFunction : function (functionName, functionObj) {
        var errorCallSites = isc._lastErrorCallSites,
            functionSet = errorCallSites.functionSet;
        if (!functionSet) {
            functionSet = errorCallSites.functionSet = {};
        }
        var nameBucket = functionSet[functionName];
        if (isc.isAn.Array(nameBucket))                nameBucket.add(functionObj);
        else if (nameBucket) functionSet[functionName] = [nameBucket, functionObj];
        else                 functionSet[functionName] =              functionObj;
    },

    _containsCallSiteFunction : function (functionName, functionObj) {
        var errorCallSites = isc._lastErrorCallSites,
            functionSet = errorCallSites.functionSet;
        if (!functionSet) return false;

        var nameBucket = functionSet[functionName];
        return nameBucket == functionObj ||
            isc.isAn.Array(nameBucket) && nameBucket.contains(functionObj);
    },


    _resolveCallSiteFirstArgsIndex : function () {

        var errorCallSites = isc._lastErrorCallSites,
            firstArgsIndex = errorCallSites.firstArgsIndex;
        if (firstArgsIndex != null) return;

        var currentCallSites,
            errorCallSites = isc._lastErrorCallSites;

        // preserve existing Error hook
        var originalPrepareStackTrace = Error.prepareStackTrace;
        delete Error.prepareStackTrace;
        // install a temporary hook to measure stack depth
        Error.prepareStackTrace = function (error, structuredStackTrace) {
            currentCallSites = structuredStackTrace;
        };
        // access "stack" property to trigger lazy execution
        var stack = new Error().stack;
        // restore the original hook
        Error.prepareStackTrace = originalPrepareStackTrace;


        var minimumDepth = Math.min(currentCallSites.length, errorCallSites.length),
            currentIndex = currentCallSites.length - minimumDepth,
            errorIndex   =   errorCallSites.length - minimumDepth;

        for (var i = 0; i < minimumDepth; i++, errorIndex++, currentIndex++) {
            if (errorCallSites[errorIndex].getFunction() ==
                currentCallSites[currentIndex].getFunction()) break;
        }

        errorCallSites.firstArgsIndex = errorIndex;

        // account for functions in current stack that we've skipped
        for (var i = 0; i < currentIndex; i++) {
            var currentCallSite = currentCallSites[i];
            this._addCallSiteFunction(currentCallSite.getFunctionName(),
                                      currentCallSite.getFunction());
        }
    },

    // for each CallSite, resolve the function arguments to a string and attach it;

    _resolveCallSiteFunctionArguments : function () {

        this._resolveCallSiteFirstArgsIndex();

        var errorCallSites = isc._lastErrorCallSites;
        if (errorCallSites.argumentsResolved) return;

        var firstArgsIndex = errorCallSites.firstArgsIndex;

        for (var i = firstArgsIndex; i < errorCallSites.length; i++) {
            var errorCallSite = errorCallSites[i],
                func = errorCallSite.getFunction(),
                name = errorCallSite.getFunctionName();
            if (func == null || func.arguments == null) continue;

            // since the arguments are actually pulled off the function object, only
            // the top frame for each function has valid arguments available
            var args = "";
            if (this._containsCallSiteFunction(name, func)) {
                args = "(<no args: recursion>) ";
            } else {
                var argNames = isc.Func.getArgs(func);
                if (argNames.length > 0) {
                    var argValues = func.arguments;
                    for (var j = 0; j < argNames.length; j++) {
                        if (j != 0) {
                            args += ", ";
                        }
                        args += argNames[j] + "=>" + isc.echoLeaf(argValues[j]);
                    }
                    args = "(" + args + ")";
                } else {
                    args = "()";
                }
                this._addCallSiteFunction(name, func);
            }

            errorCallSites[i].resolvedArguments = args;
        }

        errorCallSites.argumentsResolved = true;
    }

});


// The error.stack from IE10 looks like:
//
// "TypeError: Unable to set property 'foo' of undefined or null reference
//   at isc_Canvas_editSummaryField (http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:30842:5)
//   at sc_Canvas_addSummaryField (http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:30837:5)
//   at Function code (Function code:1:1)
//   at isc_Menu_selectMenuItem (http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:28093:9)
//   at isc_Menu_rowClick (http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:28059:5)
//   at Function code (Function code:1:142)
//   at isc_GridRenderer__rowClick (http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:6199:5)
//   at isc_c_Class_invokeSuper (http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:2262:17)
//   at isc_c_Class_Super (http://localhost:49011/isomorphic/system/modules/ISC_Core.js?isc_version=v11.0p_2016-03-31.js:2198:9)
//   at isc_GridBody__rowClick (http://localhost:49011/isomorphic/system/modules/ISC_Grids.js?isc_version=v11.0p_2016-03-31.js:679[3:13)

isc.defineClass("IEStackTrace", isc.StackTrace).addMethods({
    preambleLines:1,
    _functionRegexp: /at ((?:[A-Za-z_$0-9]+ )+)/,
    _sourceRegexp: /\((.+)\)/,

    // Parse a line from the stack and extract the function name
    extractFunctionFromLine : function (line) {
        var match = line.match(this._functionRegexp);
        return match ? match[1] : "";
    },

    // Parse a line from the stack and extract the arguments
    // IE does not appear to show the arguments ...
    extractArgumentsFromLine : function (line) {
        return "";
    },

    // Extract the source file and line numver from a line
    extractSourceFromLine : function (line) {
        var match = line.match(this._sourceRegexp);
        return match ? match[1] : "";
    }
});

// Subclass for unsupported browsers
isc.defineClass("UnsupportedStackTrace", isc.StackTrace).addMethods({
    // For parseStack, just do nothing
    _parseStack : function () {

    }
});

// NOTE: toString functions CANNOT be added by addMethods, because a property named "toString"
// will not be enumerated by for..in.  This is actually part of the ECMAScript standard!

isc.UnsupportedStackTrace.getPrototype().toString = function () {
    return this.stack;
};

// override Error.prepareStackTrace function for Chrome browser
if (isc.Browser.isChrome) {
    isc.StackTrace._prepareStackTraceUserDefinedFunction = null;
    if (Error.prepareStackTrace != null) {
        isc.StackTrace._prepareStackTraceUserDefinedFunction = Error.prepareStackTrace;
    }
    // there is no original prepareStackTrace function in Chrome - it just check if
    // we defined the method, so to get originally formatted error message we need to
    // temporary delete our prepareStackTrace method and rethrow the error just to
    // retrieve formatted message.

    // This method handles three different situations:
    // 1. There were no Error.prepareStackTrace method defined
    // 2. Error.prepareStackTrace method was defined before we override it
    // 3. Error.prepareStackTrace method was defined after we override it but it saves and
    // calls our method
    Error.prepareStackTrace = function (error, structuredStackTrace) {
        isc._lastErrorCallSites = structuredStackTrace;
        if (error.getStackTraceOnly) {
            return isc._emptyString;
        }
        // we need to return originally formatted error message;
        var origErrorMessage = null;
        if (isc.StackTrace._prepareStackTraceUserDefinedFunction != null) {
            origErrorMessage = isc.StackTrace._prepareStackTraceUserDefinedFunction(error,
                                                                    structuredStackTrace);
        } else {
            // User could override our prepareStackTrace function after we defined it. In
            // this case Error.prepareStackTrace will be his method, otherwise it will be
            // this function.
            var overriddenPrepareStackTraceFunction = Error.prepareStackTrace;
            delete Error.prepareStackTrace;
            try {
                throw error;
            } catch (e) {
                origErrorMessage = e.stack;
            }
            Error.prepareStackTrace = overriddenPrepareStackTraceFunction;
        }
        return origErrorMessage;
    }


    Error.stackTraceLimit = Infinity;
};






isc._debug = {};

isc.addProperties(isc._debug, {

    // Stack Traces
    // --------------------------------------------------------------------------------------------
    // given the 'arguments' object from a function invocation, return a developer-readable summary,
    // complete with the names and values of the arguments

    //>    @method    Class.getCallTrace()
    // Returns a one-line summary of the current method call, showing method name and passed
    // arguments.
    // This function is available as a static on every ISC Class and as an instance
    // method on every instance of an ISC Class.<br>
    // General best practice is to call the method as "this.getCallTrace(arguments)" whenever "this" is an
    // instance, or call the static classMethod on the +link{class:Log} class otherwise.
    // <P>
    // Note the <code>arguments</code> object is required in most cases for this method to function. In some
    // browsers, it can be derived automatically, but developers looking to debug on multiple platforms
    // should not rely on this.
    //
    // @param [args]  (Arguments)  arguments object from the call to trace. If ommitted, where supported,
    //   arguments will be derived from the calling function, or if this is not supported, the method
    //   will not function.
    //
    // @group debug
    // @visibility external
    //<
    //> @classMethod Class.getCallTrace()
    // @include method:class.getCallTrace
    // @visibility external
    //<
    // We also explicitly doc this method on the Log class (the only place it was doc'd prior to 7.0)
    //> @classMethod Log.getCallTrace()
    // @include method:class.getCallTrace
    // @visibility external
    //<
    getCallTrace : function (args, thisValue, showShortMethodBody, argNames, argValues, extensionTrace) {
        if (args == null) args = arguments.caller;
        if (args == null) return "[getCallTrace(): Error: couldn't get arguments object]";

        var output, func = args.callee;

        // determine function name from arguments.callee.  arguments.callee property is the Function
        // instance being invoked.
        if (func == null) {
            // browser doesn't support args.callee? (should never happen)
            output = "[args.callee == null]";
        } else if (!isc.Func) {
            output = "[Func utility class not loaded]";
        } else {
            output = isc.Func.getName(func, true);
        }

        // output a summary of the parameters
        output += "(";

        // get the names of the parameters if available
        argNames = argNames || (func != null ? isc.Func.getArgs(func) : []);
        argValues = argValues || args;

        // iterate to the larger of the declared parameters or the passed parameters
        var length = Math.max(argValues.length, argNames.length);

        for (var i = 0; i < length; i++) {
            var argName = argNames[i],
                argValue = argValues[i];

            if (i > 0) output += ", ";
            if (argName != null) {
                // show the names of the parameters as eg
                // ListGrid.setRecordStyle(recordNum=>2, newStyle=>"cellDark");
                // Note that there may be no name for the parameter if a parameter was passed
                // where none was expected.
                output += argName + "=>";
            }
            output += this.echoLeaf(argValue);
        }
        output += ")";

        // there's no known way to generally derive the value of "this" from the arguments object -
        // but in ISC several key methods store it explicitly.  This is tremendously valuable in
        // trying to interpret long stacks with method calls weaving through several related
        // instances.a
        thisValue = thisValue || args.__this;
        if (thisValue) output += " on " + this.echoLeaf(thisValue);

        var showedCrashCode = false;


        // determine whether to show entire body of method in the trace
        if (showedCrashCode || (!showShortMethodBody && !func._showBodyInTrace)) return output;

        var body = this._getTrimmedMethodBody(func);
        if (!func._showBodyInTrace) {
            // if the function at the top of the stack (the one that crashed) or at the
            // bottom of the stack (the entry point) is a one-liner, show it's contents.
            // This is very useful when an anoynmous expression is being called on a timer.
            // NOTE: have to be careful here to avoid spitting out giant methods:
            // - with stripping all functions in ISC are one-liners, hence the crude length
            //   limit
            // - when using XML, very long functions are delivered as stringMethods
            // Could limit to anonymous functions like so:
            //     && args.callee.getName && args.callee.getName() == "anonymous")
            var lines = body.split(/[\r\n]+/);
            if (lines.length > 1 || lines[0].length > 200) return output;
        }
        output += '\n        "' + body + '"';

        return output;
    },

    // for when stack walking is enabled, trim off the try..catch block added to all functions
    _getTrimmedMethodBody : function (func) {
        var body = isc.Func.getBody(func);

        return body.trim();
    },

    //>    @method Class.getStackTrace()
    // Returns a "stack trace" - one line per method in the current call stack, showing the method
    // name and any parameters passed.
    // This function is available as a static on every ISC Class and as an instance
    // method on every instance of an ISC Class.<br>
    // General best practice is to call the method as "this.getStackTrace" whenever "this" is an
    // instance, or call the static classMethod on the +link{class:Log} class otherwise.
    // <P>
    // Platform Notes: In Mozilla Firefox, if Firebug is enabled, a stack trace will be logged
    // to the firebug console in addition to the standard stack trace string returned by
    // this method.
    // <br>
    // In browsers other than Internet Explorer a complete stack trace may not be available -
    // this occurs when a function is re-entrant (meaning it calls itself). In this case the
    // stack will terminate with text indicating where the recursive function call occurred.
    // <P>
    // See +link{group:debugging} for further information information.
    //
    // @return (String) stack trace.  Use eg +link{method:isc.Class.logWarn()} to log to the
    // Developer Console.
    // @group debug
    // @visibility external
    //<
    //> @classMethod Class.getStackTrace()
    // @include method:class.getStackTrace
    // @visibility external
    //<

    // We also explicitly doc this method on the Log class (the only place it was doc'd prior to 7.0)
    //> @classMethod Log.getStackTrace()
    // @include method:class.getStackTrace
    // @visibility external
    //<
    getStackTrace : function (args, ignoreLevels, maxLevels, skipFBugTrace, extensionTrace) {
        if (isc.Class.useChromeAPIToPrepareStackTrace && isc.Browser.isChrome) {

            var e = new Error;
            var origPrepareStackTrace = Error.prepareStackTrace;
            // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi#Customizing_stack_traces
            Error.prepareStackTrace = function (error, structuredStackTrace) {
                // when intentionally grabbing a trace, we haven't lost any frames
                structuredStackTrace.firstArgsIndex = 0;
                return structuredStackTrace;
            };
            Error.captureStackTrace(e, arguments.callee);
            isc._lastErrorCallSites = e.stack;
            Error.prepareStackTrace = origPrepareStackTrace;

            var stackTrace = isc.ChromeStackTrace._getLastErrorCallSitesParsedStack(this);
            if (ignoreLevels) {
                for (var i = 0; i < ignoreLevels; i++) {
                    stackTrace = stackTrace.substring(stackTrace.indexOf("\n") + 1);
                }
            }
            return "\r\n" + stackTrace;
        }

        var stack = "";


        // do not put getStackTrace method to stackTrace by default
        if (!ignoreLevels) {
            ignoreLevels = 1;
        }
        stack += this._getStackTraceFromArgs(args,ignoreLevels,maxLevels);

        // If Firebug is present we can show a stack trace in it directly - see fireBugTrace()
        if (this.hasFireBug() && !skipFBugTrace && isc.Log.showFireBugTrace != false) {
            isc.Log._fBugTrace = isc.Log._fBugTrace || 0;
            var traceId = "FBugTrace" + isc.Log._fBugTrace++;
            stack += "\r\n" + this.fireBugTrace(traceId);
        }

        return stack;
    },


    _getStackTraceFromArgs : function (args, ignoreLevels, maxLevels, extensionTrace) {
        // If we can't get at the properties necessary to do a stack walk just log a warning and
        // quit
        if (!arguments || !arguments.callee || !arguments.callee.caller) {
            return " [Stack trace not supported in this browser]";
        }

        // if we are not passed a specific arguments objects, default to the arguments object of
        // the function that asked for the stack trace

        if (args == null) args = arguments.caller || arguments.callee.caller.arguments;
        var output = [];

        // in earlier versions of IE we can use arguments.caller to walk up the stack
        // This actually allows us to get past recursive function calls in a way that
        // arguments.callee.caller does not - use it if available


        var useArgsCaller = extensionTrace || (isc.Browser.isIE && isc.Browser.version <= 5);

        // skip some of the stack (useful to eg, a logging subsystem)
        if (ignoreLevels != null) {
            for (var i = 0; i < ignoreLevels; i++) {
                if (args == null) break;
                if (!useArgsCaller) {
                    args = args.callee.caller.arguments;
                } else {
                    args = args.caller;
                }
            }
        }


        // we ran out of stack trying to skip past the ignoreLevels
        if (args == null) {
            return "";
        }

        var func = args.callee;

        var seenFuncs = [];

        var top = true;
        if (maxLevels == null) maxLevels = Number.MAX_VALUE;
        var numLevels = 0;

        var message = "";

        while (func != null && args != null && numLevels < maxLevels) {

            if (args.timerTrace) {
                output.add("\nStack trace for setTimeout() call:   " + args.timerTrace);
                break;
            } else if (isc.Func.getName(func, true) == "[c]Timer._fireTimeout" &&
                isc.Timer.currentAction && isc.Timer.currentAction.timerTrace) {
                output.add("\nStack trace for setTimeout() call:   " + isc.Timer.currentAction.timerTrace);
                break;
            }

            if (!useArgsCaller) {
                if (seenFuncs.contains(func)) {
                    output.add("    ** recursed on " + isc.Func.getName(func, true));
                    break;
                }
                seenFuncs.add(func);
            }

            var showFuncText = (top || (args.callee != null && args.callee.caller == null));
            if (extensionTrace) {

            } else {
                output.add("    " + this.getCallTrace(args, null, showFuncText));
            }

            if (numLevels == 0 || isc.showLocalsInTraces) {
                var locals = args.__frame;

                var frameLocalsOutput = this._getFrameLocals(locals, numLevels != 0);
                if (frameLocalsOutput) output.add(frameLocalsOutput);
            }

            func = args.callee;
            if (!useArgsCaller) {
                func = func.caller;
                if (func) args = func.arguments;
            } else args = args.caller;
            top = false;
            numLevels++;

            // the extension currently provides the global scope as a stack frame for
            // completeness
            if (extensionTrace && args != null && args.callee == null) {
                output.add("    [global scope]");
                break;
            }
        }
        if (output.length == 0) return "";
        // skip a line at the beginning of the stack trace
        return "\r\n" + output.join("\r") + "\r";
    },

    // http://stackoverflow.com/questions/398111/javascript-that-detects-firebug
    // Note that console.exception was added to Firefox 28, so we need to check whether console.exception
    // is a native function or not.
    // https://developer.mozilla.org/en-US/docs/Web/API/console.error
    hasFireBug : function () {
        return (isc.Browser.isMoz &&
                window.console != null &&
                (window.console.firebug != null ||
                 (window.console.exception != null &&
                  (isc.Browser.version <= 27 ||
                   window.console.exception.toString().indexOf("[native code]") < 0))));
    },

    fireBugVersion : function () {
        return this.hasFireBug() ? window.console.firebug : null;
    },

    // this help function
    fireBugTrace : function (traceId) {
        window.console.trace(traceId);
        return " [Complete stack trace logged via Firebug: " + traceId + "]";
    },

    // get a report of local variable values from a frame (that is, a dump of local variable
    // values from the moment a function crashed)
    _getFrameLocals : function (frame, singleLine) {
        var output = isc.SB.create();
        var first = true;
        for (var varName in frame) {
            var varValue = frame[varName], undef;

            // avoid reporting variables that have not yet been declared or assinged to.  Note
            // this also catches values that have been explicitly assigned undef; we require
            // the developer to understand what the omission means.
            if (varValue === undef) continue;

            // ignore special values stored on the frame object (we assume no local variable
            // would be named with an _)
            if (isc.startsWith(varName, isc._underscore)) continue;

            if (singleLine) {
                if (!first) output.append(", ");
                else output.append("\n        locals: ");
                output.append(varName + "=>" + this.echoLeaf(varValue));
                first = false;
            } else {
                output.append("\n        " + varName + " = " + this.echoLeaf(varValue));
            }
        }
        return output.release(false);
    },

    // called in two circumstances (split these uses?)
    // - when trapping JS errors at top level entry points (eg events) in non-IE browsers
    // - with "stackwalking" try..catch blocks added to all methods, called from every catch
    //   block successively in order to walk the stack by catch..rethrow (any browser)
    _reportJSError : function (error, args, thisValue, frame, addedMessage) {


        // avoid reporting the same error twice
        if (error._reported) return;
        error._reported = true;

        var message = (addedMessage ? addedMessage + ": " : "") + error.toString();

        // Do an in-browser transform of the native stack to make it more readable.
        if (error.stack) {
            message += "\nStack from error.stack:\n";
            if (isc.Class.useChromeAPIToPrepareStackTrace && isc.Browser.isChrome) {
                message += isc.ChromeStackTrace._getLastErrorCallSitesParsedStack(this);
            } else {
                message += isc.StackTrace.fromNativeStack(error.stack).toString();
            }
        } else {
            message += "  [No error.stack available]";
        }



        this._reportJSErrorStack(message);
    },


    _reportJSErrorStack : function (message) {
        this.logWarn(message);
    },


    _onRethrowError : function (error) {
        if (isc.Class.useChromeAPIToPrepareStackTrace && error instanceof Error) {
            error.stack; // trigger lazy evaluation
            isc.ChromeStackTrace._resolveCallSiteFunctionArguments(this);
        }
    },





    // Shim for old function ... now implemented in debug/StackTrace.js
    transformMozStackTrace : function (trace) {
        return isc.StackTrace.fromNativeStack(trace).toString();
    },



    // Echoing Objects
    // --------------------------------------------------------------------------------------------

    //>    @method    Class.echoLeaf()
    // Return a very short (generally less than 40 characters) string representation of any object,
    // suitable for viewing by a developer for debugging purposes.
    // This function is available as a static on every ISC Class and as an instance
    // method on every instance of an ISC Class.<br>
    // General best practice is to call the method as "this.echoLeaf" whenever "this" is an
    // instance, or call the static classMethod on the +link{class:Log} class otherwise.
    //
    // @param  obj  (any)  object to echo
    // @return (string) a short string representation of the object
    //
    // @group debug
    // @see class.echo()
    // @visibility external
    //<
    //> @classMethod Class.echoLeaf()
    // @include method:class.echoLeaf
    // @visibility external
    //<

    // We also explicitly doc this method on the Log class (the only place it was doc'd prior to 7.0)
    //> @classMethod Log.echoLeaf()
    // @include method:class.echoLeaf
    // @visibility external
    //<
    _echoLeafLimit: 40,
    echoLeaf : function (obj, longMode) {
        var output = "",
            undef;
        if (obj === undef) return "undef";
        try {
            // Avoid attempting to manipulate SGWT Java objects
            if (obj != null && isc.Browser.isSGWT && window.SmartGWT.isNativeJavaObject(obj))
                return obj.toString();

            if (isc.isA.Class(obj)) {
                // Always call toString() for instances of Classes.  We need handle this case
                // specially, since typeof [instance of a Class] is "object", and we try to do
                // special things for vanilla Objects below
                output += obj.toString();
            } else if (isc.isAn.Array(obj)) {
                output += "Array[" + obj.length + "]";
            } else if (isc.isA.Date(obj)) {
                output += "Date(" + obj.toShortDate() + ")";
            } else if (isc.isA.Function(obj)) {
                output += isc.Func.getName(obj, true) + "()";
            } else {
                switch (typeof obj) {
                case "string" :
                    var limit = this._echoLeafLimit;
                    // for shorter strings show the whole thing.  Also, in "longMode" don't
                    // shorten.
                    if (obj.length <= limit || longMode) {
                        output += '"' + obj + '"';
                        break;
                    }

                    // for long strings, show an elipsis and the strings full length
                    output += '"' + obj.substring(0, limit) + '..."[' + obj.length + ']';

                    // convert CR/LF to avoid spanning several lines
                    output = output.replaceAll("\n", "\\n").replaceAll("\r", "\\r");
                    break;
                case "object" :
                    // typeof null is "object"
                    if (obj == null) { output += "null"; break; }

                    // DOM object
                    if (obj.tagName != null) {
                        output += "[" + obj.tagName + "Element]" + this.getIDText(obj);
                        break;
                    }

                    var toString = "[object]";
                    try {
                        toString = "" + obj;
                    } catch (e) {

                        /*empty*/
                    }
                    if (toString != "" && toString != "[object Object]" &&
                        toString != "[object]")
                    {
                        // someone went through the trouble of making a better toString(), so
                        // use it.  NOTE: check for "" because in IE an XmlNodeList among
                        // others will toString() to ""
                        output += toString;
                        break;
                    }

                    // return generic "Obj", plus any obvious ID/name property
                    output += "Obj" + this.getIDText(obj);

                    break;
                default: output += "" + obj; // invoke native toString()
                }
            }
            return output;
        } catch (e) {
            var message = "[Error in echoLeaf: " + e + "]";
            output += message;
            this.logDebug(message, "Log");
            return output;
        }
    },

    getIDText : function (obj) {
        // look for properties that may name the object

        // name
        var name = obj.name || (isc.isAn.XMLNode(obj) ? obj.getAttribute("name") : null);
        if (name != null && !isc.isAn.emptyString(name)) return "{name:" + name + "}";

        // ID or id
        var ID = obj.ID != null ? obj.ID :
                    obj.id != null ? obj.id :
                      (isc.isAn.XMLNode(obj) ? obj.getAttribute("id") : null);
        if (ID != null && !isc.isAn.emptyString(ID)) return "{ID:" + ID + "}";

        // nodeName (HTML DOM)
        if (obj.nodeName != null && !isc.isAn.emptyString(obj.nodeName)) {
            return "{nodeName:" + obj.nodeName + "}";
        }

        // title (eg sections)
        var title = obj.title || (isc.isAn.XMLNode(obj) ? obj.getAttribute("title") : null);
        if (title != null && !isc.isAn.emptyString(title)) return "{title:" + title + "}";

        // type (eg validators)
        var type = obj.type || (isc.isAn.XMLNode(obj) ? obj.getAttribute("type") : null);
        if (type != null && !isc.isAn.emptyString(type)) return "{type:" + type + "}";

        // _constructor (defaults)
        var type = obj._constructor;
        if (type != null && !isc.isAn.emptyString(type)) return "{_constructor:" + type + "}";

        // random other objects that might have a "label" property (such as a TreeNode where
        // "label" is the titleField)
        var label = obj.label || (isc.isAn.XMLNode(obj) ? obj.getAttribute("label") : null);
        if (label != null && !isc.isAn.emptyString(label)) return "{label:" + label + "}";

        // className (defaults as captured by globalEvalWithCapture)
        var type = obj.className;
        if (type != null && !isc.isAn.emptyString(type)) return "{className:" + type + "}";

        // length: handy for recognizing XMLNodeLists and similar objects in IE, which aren't
        // Arrays and can't be enumerated
        if (obj.length != null) return "{length:" + obj.length + "}";
        return "";
    },

    //>    @method    Class.echo()
    // Return a short string representation of any object, suitable for viewing by a developer for
    // debugging purposes.
    // <P>
    // If passed an object containing other objects, echo will not recurse into subobjects,
    // summarizing them instead via echoLeaf().
    // <P>
    // NOTE: echo() is used to generate the output shown in the Log window when evaluating an
    // expression.
    // <P>
    // This function is available as a static on every ISC Class and as an instance
    // method on every instance of an ISC Class.<br>
    // General best practice is to call the method as "this.echo()" whenever "this" is an
    // instance, or call the static classMethod on the +link{class:Log} class otherwise.
    //
    // @param obj (any) object to echo
    // @return (string) a short string representation of the object
    //
    // @group debug
    // @see Log.echoAll()
    // @see Log.echoLeaf()
    // @visibility external
    //<

    //> @classMethod Class.echo()
    // @include method:class.echo
    // @visibility external
    //<

    // We also explicitly doc this method on the Log class (the only place it was doc'd prior to 7.0)
    //> @classMethod Log.echo()
    // @include method:class.echo
    // @visibility external
    //<
    echo : function (obj, multiLine, longArrays, showFunctions) {
        if (obj == null) return this.echoLeaf(obj);

        // Avoid attempting to manipulate SGWT Java objects
        if (isc.Browser.isSGWT && window.SmartGWT.isNativeJavaObject(obj)) return obj.toString();

        if (multiLine == null) multiLine = true;

        if (obj.tagName) return this.echoDOM(obj);

        // anything isn't an Array or Object should be handled by echoLeaf.  (Note that typeof
        // [] is "object").  Note we pass a flag telling echoLeaf it shouldn't try to shorten
        // it's result, since it's going to be the entirety of the output.
        if (typeof obj != "object" || isc.isA.Date(obj)) return this.echoLeaf(obj, true);

        // echo entire arrays rather than just their properties
        if (isc.isAn.Array(obj)) {
            var output = (longArrays ? "[\n" : "[");
            for (var i = 0; i < obj.length; i++) {
                // echo each item either as a leaf or as a full property map
                output += (longArrays ? this.echo(obj[i], multiLine) : this.echoLeaf(obj[i]));
                if (i + 1 < obj.length) output += (longArrays ? ",\n" : ", ");
            }
            output += "\n]";
            return output;
        }

        // echo only properties of this instance, as opposed to properties inherited from it's
        // superclass if any
        var output = "{";
        if (obj.getUniqueProperties != null) {
            output = obj.getClassName() + "{";
            obj = obj.getUniqueProperties();
            // avoid a blizzard of function definitions
            if (showFunctions == null) showFunctions = false;
        }
        // if this is not an ISC object, not a DOM element, not atomic (eg String or
        // Number), and not an Array, show its functions as it's something unusual where we'd
        // like to see everything
        if (showFunctions == null) showFunctions = true;

        // echo normal objects
        var propertyNames;
        try {
            propertyNames = isc.getKeys(obj);
        } catch (e) {
            // in IE several XML-related objects through exceptions if you try to for..in on
            // them
            return this.echoLeaf(obj);
        }

        if (isc.Browser.isSafari) {

            var isStyle = false,
                styleDecl = "[object CSSStyleDeclaration]";
            try {
                // many objects JSError on attempts to toString() in Safari
                isStyle = (obj + "" == styleDecl);
            } catch (e) { }
            if (isStyle) {
                output = styleDecl + "{\n[standard props only]\n";
                propertyNames = isc.getKeys(isc.Canvas._getStylePropertyMask());
                // add 'cssText' as that's not included by default
                propertyNames.add("cssText");
            }
        }


        for (var i = 0; i < propertyNames.length; i++) {
            var propertyName = propertyNames[i],
                value;

            try {
                // sometimes you can get permission denied on the property access rather than
                // on the attempt to toString() the value
                value = obj[propertyName];
            } catch (e) {
                value = "[error accessing property: " + e + "]";
            }
            if (!showFunctions && isc.isA.Function(value)) continue;
            // don't show internal properties when private identifier obfuscation is on
            if (propertyName.startsWith("$")) continue;

            var echoValue;
            if (propertyName == isc.gwtRef) {
                // don't try to echo references to GWT Java objects.  In hosted / dev mode, our
                // attempt to look for various identifying properties can cause the GWT engine
                // to wedge
                echoValue = "{GWT Java Obj}";
            } else if (propertyName == isc.gwtModule) {
                // Also don't echo references to the GWT module exported to SGWTFactory
                echoValue = "{GWT Module Obj}";
            } else {
                echoValue = this.echoLeaf(value);
            }
            output += propertyName + ": " + echoValue;
            if (i + 1 < propertyNames.length) output += (multiLine ? ",\r" : ", ");
        }
        output += "}";
        return output;
    },

    //>    @method    Class.echoAll()
    // Like echo(), except that if passed an Array, echoAll() will echo() every element of the
    // Array.
    // This function is available as a static on every ISC Class and as an instance
    // method on every instance of an ISC Class.<br>
    // General best practice is to call the method as "this.echo()" whenever "this" is an
    // instance, or call the static classMethod on the +link{class:Log} class otherwise.
    //
    // @param obj  (any)  object to echo
    // @return (string) a short string representation of the object
    //
    // @group debug
    // @see echo()
    // @visibility external
    //<
    //> @classMethod Class.echoAll()
    // @include method:class.echoAll
    // @visibility external
    //<

    // We also explicitly doc this method on the Log class (the only place it was doc'd prior to 7.0)
    //> @classMethod Log.echoAll()
    // @include method:class.echoAll
    // @visibility external
    //<
    echoAll : function (obj, multiLine) {
        return this.echo(obj, multiLine, true);
    },

    echoFull : function (obj) {
        return isc.JSON.encode(obj, {
            prettyPrint:true,
            showDebugOutput:true
        })
    },

    // variant of echo that will be compact: one line, don't recurse into arrays
    echoShort : function (obj) {
        return this.echo(obj, false, false);
    },

    // echoArray - writes out an array with numbered slots.
    echoArray : function (obj) {
        if (!isc.isAn.Array(obj)) return this.echo(obj);
        if (obj.length == 0) return "[empty array]";
        var result = ["["];
        for (var i = 0; i < obj.length; i++) {
            result.addList([i, ":", obj[i], "\n"]);
        }
        result.add("]");
        return result.join("");
    },

    // various properties we want to ignore when echoing DOM elements
    _DOMIgnoreProperties : {

        // we rarely care about the text value of a node
        outerText: false,
        innerText: false,

        // IE proprietary crap
        parentTextEdit: false,
        isTextEdit: false,
        parentTextEdit: false,
        contentEditable: false,
        canHaveHTML: true,
        isMultiLine: false,
        filters: false,
        canHaveChildren: false,
        behaviorUrns: false,
        sourceIndex: false,
        accelerator: false,
        textDecorationUnderline: false,
        textDecorationNone: false

        // security exceptions in Moz
        //fullScreen: false, // window.fullScreen

        // error in IE6 (maybe other versions).  You cannot compare the values of these
        // properties to strings.  If you try (eg window.navigator == "") you get "object does
        // not support this property or method", presumably because some native code threw an
        // exception trying to compare against a JS string.
        //clientInformation: false, // window
        //external: false, // window
        //navigator: false, // window
    },

    // echo a DOM Node, avoiding outputting the many constants, functions, and other useless
    // things that appear on all DOM Nodes.
    // NOTE: in IE, there's no real prototype for DOM elements, so we just suppress things by
    // hand.
    echoDOM : function (node) {
        return this.echoDelta(node, window.Node, node.tagName + this.getIDText(node));
    },

    echoEvent : function (event) {
        // NOTE: in Moz, some of the constants we'd like to omit are on window.KeyEvent and some are
        // on window.Event.  window.KeyEvent has more.
        return this.echoDelta(event, (isc.Browser.isMoz ? window.KeyEvent : window.Event));
    },

    echoDelta : function (obj, base, prefix) {
        if (obj == null) return null;

        if (isc.Browser.isIE && isc.isAn.XMLNode(obj)) {

            var output = "<" + obj.tagName + " [XMLNode] ";
            var attrs = obj.attributes;
            for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                if (i > 0) output += " ";
                output += attr.name + "=" + this.echoLeaf(attr.value);
            }
            output += (i > 0 ? " [" : "") + obj.childNodes.length + " child nodes]>";
            return output;
        }

        var output = (prefix || isc.emptyString) + "{",
            propertyNames = isc.getKeys(obj);
        for (var i = 0; i < propertyNames.length; i++) {
            var propertyName = propertyNames[i];

            // skip useless properties found in DOM objects
            if (this._DOMIgnoreProperties[propertyName] != null) continue;

            // skip properties inherited from base class
            if (base != null && base[propertyName] != null) continue;

            // omit multi-letter properties in all caps (typically constants)
            if (propertyName.length > 3 && propertyName.toUpperCase() == propertyName) continue;

            try {
                var value = obj[propertyName];

                // skip null/empty values
                if (value == null || value == "") continue;

                // skip functions
                if (isc.isA.Function(value)) continue;

                output += propertyName + ": " + this.echoLeaf(obj[propertyName]);
            } catch (e) {
                output += propertyName + ": " + this.echoLeaf(e);
            }
            if (i + 1 < propertyNames.length) output += ", ";
        }
        output += "}";
        return output;
    },

    // echo all the size-related properties of a DOM element.  Won't work in Nav4.
    echoElementSize : function (element) {
        var undef;
        return this.echo({
            scrollLeft : element.scrollLeft,
            scrollTop : element.scrollTop,
            scrollWidth : element.scrollWidth,
            scrollHeight : element.scrollHeight,
            clientWidth : undef,
            clientHeight : undef,
            offsetWidth : element.offsetWidth,
            offsetHeight : element.offsetHeight,
            styleLeft : element.style.left,
            styleTop : element.style.top,
            styleWidth : element.style.width,
            styleHeight : element.style.height,
            styleClip : element.style.clip
        });
    }
});

// make methods available on any class or instance
isc.Class.addProperties(isc._debug);
isc.Class.addClassProperties(isc._debug);






// The log functions below will always be defined even with DEBUG> <DEBUG blocks stripped, so that
// if an end user calls a log function and forgets to mark it with DEBUG, it doesn't result in a
// JS error.

// write special log accessor functions for Class instances so we can call them
isc._logMethods =
{

    logMessage : function (priority, message, category, timestamp) {
        var log = isc.Log;
        if (!log) return;

        //>DEBUG

        // if no priority was passed in, use the default
        if (priority == null) priority = log.defaultPriority;

        // automatically add a stack trace for error logs
        if (priority <= log.stackTracePriority && this.getStackTrace != null) {
            // skip two levels of the stack to avoid showing the logMessage() invocation itself
            message += "\nStack trace:\n" + this.getStackTrace(arguments, 2);
        }

        // If a category was not specified, use the name of this class.
        if (!category) category = this.Class;

        var idString = this.ID;
        if (isc.FormItem && isc.isA.FormItem(this) && this.name != null) {
            idString += "[" + this.name + "]";
        }



        // actually do the log.  NOTE: if we have an instance ID, pass it
        log.log(priority, message, category, idString, this, timestamp);

        //<DEBUG
    },

    //> @method class.logDebug()
    // Log a message at "debug" priority
    // <P>
    // A method named log<i>Priority</i> exists for each priority level, on every ISC Class and
    // instance of an ISC Class.  Messages logged on a Class or instance have a default
    // category of the classname.  Messages logged on an instance will also automatically
    // incorporate the instance ID.  General best practice is to call logDebug() et al as
    // "this.logDebug" whenever "this" is an instance, or as "Log.logDebug" otherwise.
    //
    //     @param message    (String)  message to log
    //     @param [category] (String)  category to log in
    //
    // @see Log.echo() for dumping datastructures to the log
    // @see Log.setPriority() for controlling what messages appear in the log
    // @visibility external
    //<
    //> @classMethod class.logDebug()
    // @include method:class.logDebug
    // @visibility external
    //<

    // We commonly refer to the classMethod Log.logDebug / logWarn et al

    //> @classMethod Log.logDebug()
    // A common usage of +link{classMethod:class.logDebug()} is to call the method directly on
    // the Log class.
    // @include classMethod:class.logDebug()
    // @visibility external
    //<
    logDebug : function (message, category) { return this.logMessage(isc.Log.DEBUG, message, category)},

    //> @method class.logInfo()
    // Log a message at "info" priority
    //
    //     @param message    (String)  message to log
    //     @param [category] (String)  category to log in
    //
    // @see Log.logDebug() for usage info
    // @visibility external
    //<
    //> @classMethod class.logInfo()
    // @include method:class.logInfo
    // @visibility external
    //<

    //> @classMethod Log.logInfo()
    // A common usage of +link{classMethod:class.logInfo()} is to call the method directly on
    // the Log class.
    // @include classMethod:class.logInfo()
    // @visibility external
    //<
    logInfo : function (message, category) { return this.logMessage(isc.Log.INFO, message, category)},

    //> @method class.logWarn()
    // Log a message at "warn" priority
    //
    //     @param message    (String)  message to log
    //     @param [category] (String)  category to log in
    //
    // @see Log.logDebug() for usage info
    // @visibility external
    //<
    //> @classMethod class.logWarn()
    // @include method:class.logWarn
    // @visibility external
    //<

    //> @classMethod Log.logWarn()
    // A common usage of +link{classMethod:class.logWarn()} is to call the method directly on
    // the Log class.
    // @include classMethod:class.logWarn()
    // @visibility external
    //<
    logWarn : function (message, category) { return this.logMessage(isc.Log.WARN, message, category)},

    //> @method class.logError()
    // Log a message at "error" priority
    //
    //     @param message    (String)  message to log
    //     @param [category] (String)  category to log in
    //
    // @see Log.logDebug() for usage info
    // @visibility external
    //<
    //> @classMethod class.logError()
    // @include method:class.logError
    // @visibility external
    //<

    //> @classMethod Log.logError()
    // A common usage of +link{classMethod:class.logError()} is to call the method directly on
    // the Log class.
    // @include classMethod:class.logError()
    // @visibility external
    //<
    logError : function (message, category) { return this.logMessage(isc.Log.ERROR, message, category)},

    //> @method class.logFatal()
    // Log a message at "fatal" priority
    //
    //     @param message    (String)  message to log
    //     @param [category] (String)  category to log in
    //
    // @see Log.logDebug() for usage info
    // @visibility external
    //<
    //> @classMethod class.logFatal()
    // @include method:class.logFatal
    // @visibility external
    //<

    //> @classMethod Log.logFatal()
    // A common usage of +link{classMethod:class.logFatal()} is to call the method directly on
    // the Log class.
    // @include classMethod:class.logFatal()
    // @visibility external
    //<
    logFatal : function (message, category) { return this.logMessage(isc.Log.FATAL, message, category)},

    //> @method class.logIsEnabledFor()
    // Check whether a message logged at the given priority would be visible in the log.
    // <P>
    // As with logDebug, category is defaulted to the current className.  Use this method to avoid
    // putting together expensive log messages if they will never appear in the log.
    //
    //     @param priority   (LogPriority)  priority level
    //     @param [category] (String)            category to log in
    // @visibility external
    //<
    //> @classMethod class.logIsEnabledFor()
    // @include method:class.logIsEnabledFor
    // @visibility external
    //<
    logIsEnabledFor : function (priority, category) {
        return (isc.Log.isEnabledFor &&
                isc.Log.isEnabledFor((category ? category : this.Class), priority, this))
    },

    //> @method class.logIsDebugEnabled()
    // Check whether a message logged at "debug" priority would be visible in the log.
    // <P>
    // As with logDebug, category is defaulted to the current className.  Use this method to avoid
    // putting together expensive log messages if they will never appear in the log.
    //
    //     @param [category] (String)            category to log in
    // @visibility external
    //<
    //> @classMethod class.logIsDebugEnabled()
    // @include method:class.logIsDebugEnabled
    // @visibility external
    //<
    logIsDebugEnabled : function (category) { return this.logIsEnabledFor(isc.Log.DEBUG, category) },

    //> @method class.logIsInfoEnabled()
    // Check whether a message logged at "info" priority would be visible in the log.
    // <P>
    // As with logDebug, category is defaulted to the current className.  Use this method to avoid
    // putting together expensive log messages if they will never appear in the log.
    //
    //     @param [category] (String)            category to log in
    // @visibility external
    //<
    //> @classMethod class.logIsInfoEnabled()
    // @include method:class.logIsInfoEnabled
    // @visibility external
    //<
    logIsInfoEnabled : function (category) {    return this.logIsEnabledFor(isc.Log.INFO, category) },

    //> @method class.logIsWarnEnabled()
    // Check whether a message logged at "warn" priority would be visible in the log.
    // <P>
    // As with logDebug, category is defaulted to the current className.  Use this method to avoid
    // putting together expensive log messages if they will never appear in the log.
    //
    //     @param [category] (String)            category to log in
    // @visibility external
    //<
    //> @classMethod class.logIsWarnEnabled()
    // @include method:class.logIsWarnEnabled
    // @visibility external
    //<
    logIsWarnEnabled : function (category) {    return this.logIsEnabledFor(isc.Log.WARN, category) },

    //> @method class.logIsErrorEnabled()
    // Check whether a message logged at "error" priority would be visible in the log.
    // <P>
    // As with logDebug, category is defaulted to the current className.  Use this method to avoid
    // putting together expensive log messages if they will never appear in the log.
    //
    //     @param [category] (String)            category to log in
    // @visibility external
    //<
    //> @classMethod class.logIsErrorEnabled()
    // @include method:class.logIsErrorEnabled
    // @visibility external
    //<
    logIsErrorEnabled : function (category) {    return this.logIsEnabledFor(isc.Log.ERROR, category) },

    // Methods to update the log priority directly on objects

    //> @method class.setLogPriority()
    // Set the priority of messages that will be visible for some log category, when logged on
    // this Class or Instance object.<br>
    // If called with no category, this priority will be applied to every logged message on this
    // object<br>
    // To set the visible log priority for some category across the entire page, use
    // <code>isc.Log.setPriority()</code> instead.
    // @param category (string) Category for which the log priority will be updated. If not
    //                          all logs on this canvas will be logged at the priority passed in.
    // @param priority (LogPriority) priority level
    // @see Log.setPriority()
    // @visibility external
    //<
    //> @classMethod class.setLogPriority()
    // @include method:class.setLogPriority
    // @visibility external
    //<

    //> @classMethod Log.setLogPriority()
    // A common usage of +link{classMethod:class.setLogPriority()} is to call the method
    // directly on the Log class.
    // @include classMethod:class.setLogPriority()
    // @visibility external
    //<
    setLogPriority : function (category, priority) {
        isc.Log.setPriority(category, priority, this);
    },

    //> @method class.setDefaultLogPriority()
    // Set the default priority of logging for messages logged on this Class or Instance object.
    // All categories for which there is no explicit, instance level logging priority set will
    // log at this level on this object.<br>
    // To set the default visible log priority across the entire page, use
    // <code>isc.Log.setDefaultPriority()</code> instead.
    // @param category (string) Category for which the log priority will be updated. If not
    //                          all logs on this canvas will be logged at the priority passed in.
    // @param priority (LogPriority) priority level
    // @see Log.setPriority()
    // @visibility external
    //<
    //> @classMethod class.setDefaultLogPriority()
    // @include method:class.setDefaultLogPriority
    // @visibility external
    //<

    //> @classMethod Log.setDefaultLogPriority()
    // A common usage of +link{classMethod:class.setDefaultLogPriority()} is to call the
    // method directly on the Log class.
    // @include classMethod:class.setDefaultLogPriority()
    // @visibility external
    //<
    setDefaultLogPriority : function (priority) {
        isc.Log.setDefaultPriority(priority, this);
    },

    //> @method class.getDefaultLogPriority()
    // Retrieves the default priority of messages for this class or instance.
    // @return (LogPriority) default priority for logging messages on this object.
    // @visibility external
    //<
    //> @classMethod class.getDefaultLogPriority()
    // @include method:class.getDefaultLogPriority
    // @visibility external
    //<

    //> @classMethod Log.getDefaultLogPriority()
    // A common usage of +link{classMethod:class.getDefaultLogPriority()} is to call the
    // method directly on the Log class.
    // @include classMethod:class.getDefaultLogPriority()
    // @visibility external
    //<
    getDefaultLogPriority : function () {
        return isc.Log.getDefaultPriority(this);
    },

    //> @method class.clearLogPriority()
    // Clear this object's priority setting for a particular category, so that the category's
    // effective priority returns to the specified priority for this category at the Log level
    // (or <code>Log.defaultPriority</code> if not set).<br>
    // To clear the Page-level priority setting for this log category use
    // <code>isc.Log.clearPriority()</code> instead.
    //
    // @param category   (String) Category name. If not specified, all logging on this object
    //                              will revert to default priority settings.
    // @visibility external
    // @see Log.clearPriority()
    //<
    //> @classMethod class.clearLogPriority()
    // @include method:class.clearLogPriority
    // @visibility external
    //<
    clearLogPriority : function (category) {
        isc.Log.clearPriority(category, this);
    }

};

// add the methods to Class object prototype and to the Class instance prototype
isc.Class.addMethods(isc._logMethods);
isc.Class.addClassMethods(isc._logMethods);



//> @groupDef serverLogging
// <h3>Default logging</h3>
// <p>
// SmartClient's server-side classes have extensive built-in diagnostics which are output via
// the +externalLink{http://logging.apache.org/log4j/1.2/,Apache Log4j library} (see below for
// other alternatives).
// <p>
// At startup, SmartClient will automatically load the file <code>log4j.isc.config.xml</code>
// from the classpath and use it to configure Log4j.  <code>log4j.isc.config.xml</code> is in
// Log4j's standard
// +externalLink{http://wiki.apache.org/logging-log4j/Log4jXmlFormat,XML configuration format},
// and sets default log threshold levels for various subsystems to produce output that is
// generally appropriate for both development and production systems.  Various SmartClient
// documentation may encourage you to enable certain diagnostic logs using this file when
// troubleshooting specific problems.
// <p>
// <h3>Server Logs tab (SmartClient Developer Console)</h3>
// <p>
// The Server Logs tab of the +link{group:debugging,SmartClient Developer Console} provides the
// ability to view the most recent 500 log entries, and change log threshold levels dynamically
// at runtime.
// <p>
// <h3>Redirecting logging to other frameworks</h3>
// <p>
// SmartClient server logging can alternatively use the Simple Logging Facade for Java (slf4j),
// which allows logs to be sent to a variety of different logging frameworks that support
// slf4j.
// <p>
// To send all logging to slf4j, the <code>iscUseSlf4j</code> VM argument must be set to true
// on the command line, like this:
// <pre>
// -DiscUseSlf4j=true
// </pre>
// If slf4j is used and the underlying log system is still Log4j, SmartClient will still
// configure Log4j using <code>log4j.isc.config.xml</code> as describe above <i>unless</i> you
// pass an additional command line argument to prevent this:
// <pre>
// -DiscUseLog4jConfig=false
// </pre>
// If slf4j is used with any other logging system, SmartClient will not attempt to apply
// configuration - see the
// +externalLink{http://www.slf4j.org/manual.html,SLF4J user manual} for details on
// how to configure slf4j.
// <p>
// Note that the features of the "Server Logs" tab will <b>not</b> be available if using slf4j,
// even if Log4j is also used.
// <p>
// <h3>Configure custom log4j loggers</h3>
// <p>
// If log4j is used and custom loggers are configured in <code>log4j.isc.config.xml</code>
// file, use <code>DataTools.getLoggerRespository()</code> method to access them on server side,
// like this:
// <pre>
// DataTools.getLoggerRepository().getLogger(CustomClass.class.getName());
// </pre>
//
// @title Server logging
//<

//>    @groupDef debug
// Support for debugging and logging
//<

//>    @class Log
// A logging system similar to the Java log4j package: messages are logged with a "category" and
// "priority", and developers can dynamically set which log messages are being displayed.
// <P>
// 5 log priorities are available, with the following general meaning:
// <ul>
// <li> "debug": diagnostic info which is only likely to be understood by a developer with
// source access, or would occur too frequently for normal usage
// <li> "info": reports of significant events in the normal operation of the subsystem
// <li> "warn": some kind of problem is likely to occur, an API appears is apparently being
// misused or will yield a partial or very slow result
// <li> "error": a definite error has occurred which may be recoverable
// <li> "fatal": total failure with no possibility of recovery
// </ul>
// <P>
// Log categories do not need to be declared in advance - you can simply make up a category name and
// start logging to it, and control whether that category's messages will be displayed via
// <code>setPriority()</code>.
// <P>
// <b>NOTE:</b> to open the Developer Console in any page that loads ISC, type
// javascript:isc.Log.show() in the URL bar - this URL is bookmarkable.
// <P>
// The Developer Console should <b>always</b> be open while developing any ISC-enabled application,
// because ISC logs many important errors and warnings to the Developer Console.
// <P>
// NOTE: if you have the Microsoft JavaScript Debugger installed, ISC will be unable to log stack
// traces on JS errors until you go to Tools->Internet Options->Advanced Tab and check "Disable
// script debugging".  The ability to see stack traces in the Developer Console is generally much
// more useful for debugging ISC-based applications than the generic Javascript Debugging
// facilities.
//
// @treeLocation Client Reference/System
// @group debug
//
// @see Log.setPriority()
//
//  @visibility external
//<
isc.ClassFactory.defineClass("Log");

//> @groupDef debugging
// <smartgwt>
// <h4>Development and Super Dev Modes</h4>
// GWT
// +externalLink{http://www.gwtproject.org/doc/latest/DevGuideCompilingAndDebugging.html#dev_mode,Development Mode},
// which runs your Java code in an actual Java VM attached to the browser via a browser plugin,
// is being phased out of the GWT project in favor of
// +externalLink{http://www.gwtproject.org/articles/superdevmode.html,Super Dev Mode}, which
// translates your Java code into JavaScript before running it, even when debugging.
// <p>
// In Super Dev Mode,
// +externalLink{https://developer.chrome.com/devtools/docs/javascript-debugging#source-maps,source maps}
// provided by a GWT Code Server Java app allow breakpoints to be placed at chosen locations
// within the Java source code.  Running Super Dev Mode in GWT 2.7.0+ is possible by just
// launching the (Super) Dev Mode Server in Eclipse using a <i>Web Application</i> Run
// Configuration.  This should be available under Run Configurations if the
// +externalLink{http://www.gwtproject.org/download.html,GWT 2.7.0 Eclipse Plugin} has been
// installed.  Under such a configuration, the Code Server will be automatically run
// for you and source maps loaded whenever you reload the web application in your browser.
// <P>
// For earlier versions of GWT, running Super Dev mode requires:
// <ul>
// <li> Adding a bit of additional configuration to your GWT project file (gwt.xml) and rebuilding
// <li> Running the GWT Code Server Java App (either from the command line or from Eclipse)
// </ul><p>
// Once these two steps have been completed, you can run the web application through Eclipse,
// or deploy it manually to an existing web server.  The code server can then be invoked
// by a browser bookmark and the source maps for your project navigated to place breakpoints
// where needed.
// <P>
// Note that Google Chrome is recommended as the primary browser for use with Super Dev Mode
// for all versions of GWT, because while the built-in Firefox debugger supports source maps,
// it doesn't appear to stop at breakpoints for GWT versions before 2.7.0, and hangs when
// trying to do so in GWT 2.7.0 (as of Firefox 38).  Source maps don't work at all for any GWT
// version in IE11 or +externalLink{https://code.google.com/p/fbug/issues/detail?id=5765,Firefox Firebug}.
// <p>
// <i>Refer to +link{superDevModeTroubleshooting, Troubleshooting Super Dev Mode} for more
// detailed help running Super Dev Mode.</i>
// <P>
// Classic Development Mode can now only be used with older versions of Firefox, such as
// +externalLink{https://ftp.mozilla.org/pub/mozilla.org/firefox/releases/latest-24.0esr/,Firefox 24ESR}
// (which is only supported until 10/14/2014).  There are no plans to re-add support in current
// versions of Firefox.  Chrome's Development Mode also cannot be used because of
// +externalLink{http://forums.smartclient.com/showthread.php?t=8159#aChrome,limitations of Chrome}
// that break core GWT functionality.
// <P>
// <h4>Stack Details</h4>
// When not using one of the GWT development modes described above, the stack trace presented in
// the SmartClient Developer Console will consist of obfuscated method names and provide little
// helpful information.  Useful unobfuscated traces may be obtained by adding "-optimize 0" and
// "-style DETAILED" or "-style PRETTY" to the gwtc ant target in the build.xml file for your
// project.  A more useful stack trace in certain cases can sometimes be obtained by activating
// GWT "stack emulation".  To do this, set the property <code>compiler.stackMode</code> to
// "emulated" and <code>compiler.emulatedStack.recordLineNumbers</code> to "true" in your
// gwt.xml project file.  (Note that enabling stack emulation will increase the size of the
// JavaScript files generated by GWT.)  Examples of both of these enhancements are provided
// as commented-out lines in the appropriate files of the BuiltInDS SGWT sample
// <P>
// Note that due to how GWT compiles Java code into JavaScript, the top of the stack may
// actually go deeper than expected in the visible trace when a crash in the Java code occurs.
// So for example if you try to invoke a method on a null object like:
// <pre>
//     ListGrid listGrid = null;
//     listGrid.setWidth100();</pre>
// then the actual Development Console error will look something like:
// <pre>
// 23:11:44.461:WARN:Log:TypeError: this$static is null
// Stack from error.stack:
//     $isCreated_4() @ showcase/239D5C0DDE9A2775E194CC3519D90866.cache.html:22080:7
//     $setAttribute_20() @ showcase/239D5C0DDE9A2775E194CC3519D90866.cache.html:22132:3
//     $setWidth_3() @ showcase/239D5C0DDE9A2775E194CC3519D90866.cache.html:23349:3
//     $setWidth100() @ showcase/239D5C0DDE9A2775E194CC3519D90866.cache.html:23353:3
//         :</pre>
// (where -optimize 0 and -style PRETTY have been added to build.xml as mentioned above).
// This is because the JavaScript code emitted by GWT for <code>setWidth100()</code>,
// <code> setWidth()</code>, and <code>setAttribute()</code> never actually attempts
// to access the widget (<code>this$static</code>) until execution reaches
// <code>BaseWidget.isCreated()</code>.
// <P>
// </smartgwt>
// <h4>Built-in Diagnostics</h4>
// <P>
// The SmartClient Developer Console is a suite of development tools implemented in SmartClient itself.
// The Console runs in its own browser window, parallel to your running application, so it is always
// available in every browser, and in every deployment environment.
// <P>
// The Developer Console can be opened by calling <code>isc.showConsole()</code> on any page in which
// SmartClient has been loaded. You can create a bookmark in your browser to quickly show the Console on
// any SmartClient application, without any changes to the application code:
// <P>
// 1. Create a new bookmark in your browser.<BR>
// 2. Enter url "javascript:isc.showConsole()".<BR>
// 3. Label the bookmark as "Show Console".<BR>
// 4. Consider adding this to the Bookmarks Toolbar. This allows one-click access to the Console
// from any SmartClient application.
// <P>
// Note: For most browsers you can evaluate javascript directly from the browser URL bar by entering
// <code>javascript:<i>string to evaluate</i></code> directly in the URL bar, so setting up a bookmark
// is not strictly necessary. For Firefox 6 and above, this feature has been disallowed, but the bookmark
// approach will still work. Alternatively developers could use
// +externalLink{http://blog.mozilla.com/devtools/2011/08/15/introducing-scratchpad/,Firefox Scratchpad}
// to launch the console.
// <P>
// Basic information on the features of the Developer Console can be found in the QuickStart
// Guide.  For information about the "RPC" tab of the Developer Console and the request
// profiling information it can provide, see
// +link{groupDef:devConsoleRPCTab,the Developer Console RPC tab}.  The Develper Console also
// supports debugging of remote pages (very useful for mobile devices) - see
// +link{groupDef:remoteDebugging} for more information.  The remainder of this
// topic focuses on use of the log system and related debugging facilities.
// <P>
// The Developer Console contains a "Results" pane that displays a list of diagnostic
// messages logged by the SmartClient framework. The "Logging Preferences" menu lets you
// enable and disable SmartClient's built-in diagnostics in several categories. Because
// important diagnostic messages may be logged at any time, you should have the Developer
// Console open whenever you are working with SmartClient (and you should bookmark the
// "javascript:" expression above to make this easier).
// <P>
// Log messages are of the format:
// <P>
// &nbsp;&nbsp;&nbsp;<i>timestamp</i>:<i>priority</i>:<i>category</i>:<i>message</i>
// <P>
// For example, the following log message:
// <pre>
//     11:59:25:806:INFO:Page:Page loading complete.</pre>
// Occurred at 11:59:25 local time and 806 milliseconds.  It's priority was <code>INFO</code>,
// it occurred in the category <i>Page</i>, and the message is "Page loading complete.".
// <P>
// Each logging <i>category</i> has a <i>priority</i> associated with it.  If a message's
// priority is lower than the current priority for the category it is logged in, the
// message will be suppressed (will not appear in the "Results" pane).
// <p>
// It is critical to be familiar with the diagnostic categories built-in to SmartClient -
// you will use them in most debugging sessions.  Open the Logging Preferences menu and select
// "More.." to see a list of diagnostic log categories.   Hover over each category name to
// see a description of what kind of messages are logged in the category.
// <P>
// <h4>Debugging JavaScript Errors</h4>
// <P>
// Javascript errors will typically be reported in the Developer Console. Wherever possible a stack
// trace will be included which can help determine the cause of the error.
// In addition to this, recent versions of the Firefox browser (versions 6.0 and above) ship with some
// useful development tools including the Error Console for reporting errors. We also recommend Console2
// and Firebug for debugging in Firefox.
// <P>
// When JavaScript errors occur, SmartClient is usually able to report full stack traces
// in the Developer Console.  This can be invaluable when your code triggers a JavaScript error
// in the SmartClient libraries themselves, or when it is unclear how your code is being
// called.  Stack traces from the Developer Console Explorer should <i>always</i> be included in issue
// reports sent to Isomorphic Software, if at all possible.
// <smartclient><P>
// <h4>Avoiding JavaScript Validation Errors from the Framework</h4>
// <P>
// In Eclipse, you may find that you're getting a bunch of spurious validation errors from the
// SmartClient Framework JavaScript code.  This can be distracting and slow down interactions
// with Eclipse.  If you encounter this problem, you can try to apply the following fixes
// (verified in Eclipse 4.3 "Kepler"):<ul>
// <li> For each affected project, in
// <i>Properties =&gt; JavaScript =&gt; Include Path =&gt; Source</i>, exclude the
// SmartClient Framework files that are triggering the errors.
// <li> If errors are still being reported, you can switch off validation entirely:<ul>
//     <li> In <i>Window =&gt; Preferences =&gt; JavaScript =&gt; Validator =&gt; Errors/Warnings</i>,
//          uncheck "Enable JavaScript Semantic Validation".
//     <li> For each affected project, in
//          <i>Properties =&gt; Builders</i>, uncheck "JavaScript Validator" underneath where it
//          says "Configure the builders for the project," and make sure that the "Enable
//          project-specific settings" checkboxes are unchecked at both levels (second one in
//          parens): <i>Properties =&gt; JavaScript =&gt; Validation (=&gt; Errors/Warnings)</i>.
// </ul></ul>
// A more in-depth discussion can be found at
// +externalLink{http://stackoverflow.com/questions/17329028/eclipse-kepler-disable-javascript-validation}.
// </smartclient>
// <P>
// <h4>Inspecting application state</h4>
// <P>
// The "Evaluate JS Expression" area of the Results Pane in the Developer Console can be used
// to inspect the current state of a SmartClient application by running JavaScript code.
// The result of any expression you evaluate will be intelligently summarized (via
// +link{Log.echo()}).  For example, simply typing a component's ID and pressing the "Eval JS"
// button will give you a dump of it's current property values.
// <smartgwt>
// <p>
// Note that when using the "Evaluate JS Expression" area, since you are writing code in
// JavaScript, if you call a method on a component via evaluating an expression like
// "<i>componentId.someMethod()</i>", you are calling a &#83;martClient JavaScript API.  Most
// of the time, component APIs have the same name and same function in &#83;martClient as in
// Smart GWT, so you can use such APIs to inspect or modify the runtime state of components
// without being proficient in &#83;martClient.  You can refer to the &#83;martClient Reference
// available at
// +externalLink{http://www.smartclient.com/product/documentation.jsp,Isomorphic.com} for
// details on API differences.
// </smartgwt>
// <p>
// Many, many component APIs can be usefully called while troubleshooting, eg,
// +link{listGrid.data} is a +link{ResultSet} when a grid is DataBound and
// +link{resultSet.get()} can be called to inspect the current values on records.
// <smartclient>In addition, new application code can be tried out, for example, you might
// repeatedly instantiate a new component, trying variants on the properties you could give it.
// </smartclient>
// <smartgwt>
// <p>
// Note that methods you have added to a component in Java via GWT will not be present.  You
// can only invoke Java methods via JavaScript if you are familiar with the (possibly
// obfuscated) JavaScript names that GWT produces for those methods.
// </smartgwt>
// <P>
// <b>Inspecting transient application state with logs</b>
// <P>
// Transient state, such as the values of local variables in a method that is crashing, can be
// sent to the Developer Console via using the <smartclient>+link{Log}</smartclient>
// <smartgwt>+externalLink{../util/SC.html,SC}</smartgwt> class.  For example, to dump the
// value of <smartclient>the local variable</smartclient><smartgwt>a local instance of
// +link{DataClass}</smartgwt> "request":
// <smartclient>
// <pre>
//     isc.logWarn("request is: " + isc.echo(request));</pre>
// </smartclient><smartgwt>
// <pre>
//     SC.logWarn("request is: " + SC.logEcho(request.getJsObj()));</pre>
// </smartgwt>
// It's a good idea to dump the values of local variables in any method that is crashing or
// behaving unexpectedly.
// <P>
// Note the use of <smartclient>+link{classMethod:isc.logWarn,logWarn()}</smartclient>
// <smartgwt>+externalLink{../util/SC.html#logWarn(java.lang.String),SC.logWarn()}</smartgwt>
// above: in typical debugging sessions, it's best to simply use the <code>logWarn</code> method
// to output diagnostics to ensure your message will not be suppressed by log priority settings.
// <P>
// <smartclient>
// NOTE: never use the native <code>alert()</code> method to output diagnostics.  Among other
// issues, <code>alert()</code> can affect timing, masking or altering the behavior you were
// trying to debug.  SmartClient's logging system doesn't suffer from these problems and
// provides much more control.
// <P>
// </smartclient>
// <h4>Issue Reports</h4>
// <P>
// If you believe you've discovered a bug in SmartClient or you are having trouble using
// SmartClient APIs, you can report it in
// +externalLink{http://forums.smartclient.com/,the SmartClient Forums}.
// <P>
// <b>How quickly your issue is resolved is entirely up to you</b>.  If you follow the steps
// below and submit an appropriate issue report, you will generally receive a rapid solution
// from Isomorphic Support, regardless of what support level you have, because Isomorphic
// aggressively corrects bugs and legitimate usage issues.  If you skip steps you are likely to
// be directed back to this document and asked to submit a more complete issue report.
// <P>
// Before reporting an issue, ensure that you:
// <ul>
// <li> Have read the +docTreeLink{QuickStartGuide,QuickStart Guide} cover to
// cover.  Later chapters cover more advanced topics and provide links to further examples and
// reference.
// <li> Have searched the
// <smartclient>
// +docTreeLink{FeatureExplorer,Feature Explorer}
// </smartclient><smartgwt>
// SGWT Showcase from your installation (e.g.
// +externalLink{http://www.smartclient.com/smartgwt/showcase/, SGWT LGPL Showcase} /
// +externalLink{http://www.smartclient.com/smartgwtee/showcase/, SGWT EE Showcase})
// </smartgwt>
// for examples that show what you are trying to do
// <li> Have searched this reference, trying multiple searches using different, common and
// related terms for what you are trying to do (eg for search, try "search", "filter",
// "criteria", "find", "match", etc)
// <li> Have searched the public +externalLink{http://forums.smartclient.com,forums}
// </ul>
// Always include:
// <ul>
// <li> A description of what you are trying to accomplish <b>from an end user's perspective</b>.
// The best answers often point out a simpler approach.
// <li> The browser(s), operating system(s) and SmartClient version(s) you experience the error
// on (SmartClient version is available in the lower-left handle corner of the Developer
// Console)
// </ul>
// Then, include <b>either</b> a standalone test case (see below), <b>or</b>:
// <ul>
// <li> For JS errors, Stack traces from Firebug (for Firefox) or the Developer Console (for
// IE), as covered under "Debugging JavaScript Errors" above
// <li> What server platform and +link{group:clientServerIntegration,databinding approach} you
// are using, if applicable
// <li> contents of the SmartClient Developer Console "Log messages" area, with appropriate
// diagnostic categories set the DEBUG or INFO level (see "Built-in Diagnostics" above)
// <li> for any problem involving server contact, the complete server-side log for the request
// that fails or produces unexpected results
// <smartgwt>
// <li> if using GWT Development Mode, any exceptions reported from Java in Eclipse
// </smartgwt>
// <li> Results of calling <code>echo()</code> on local variables or other application
// state you think is relevant (see "Inspecting Application State" above)
// <li> sample code and sample data
// </ul>
// <b>Preparing a standalone test case</b>
// <P>
// A standalone test case is one of:
// <smartclient>
// <ol>
// <li> a chunk of JavaScript code that can be executed from the "Eval JS" area of the
// Developer Console on some specified page within the unmodified SmartClient SDK,
// demonstrating your issue
// <li> an .html or .jsp file that can be dropped at a specified location into an unmodified
// SmartClient SDK and will run without changes, demonstrating your issue.
// <li> a .zip file that includes a standalone .html/.jsp file  as above, as well as
// dependencies required to make the test case runnable, such as XML datasets
// </ol>
// </smartclient><smartgwt><ol>
// <li>a modified version of one of our sample projects, such as the BuiltInDS sample
// with BuiltInDS.java changed to demonstrate your issue
// <li>a modified version of any one of our SGWT Showcase samples (e.g. GridSortSample);
// choosing one that requires only a slight modification to demonstrate your issue is best
// </ol>
// Note: Ideally this results in a single Java file you provide to us if possible.
// </smartgwt>
// <P>
// Submitting a standalone test case removes any ambiguity as to whether there is a bug in
// SmartClient or a bug in your code, and eliminates the possibility of Isomorphic Support
// responding with a "works for me" result due to incomplete information.  Issues with verified
// test cases are routed directly to the engineer that authored the relevant SmartClient
// subsystem, often as the new highest priority task.  In addition, the process of preparing a
// test case very often allows you to solve the issue yourself, if the underlying issue is not
// actually a framework bug.
// <P>
// There are two approaches to test case preparation:
// <ol>
// <li> Add code to an existing <smartclient>SmartClient example</smartclient>
// <smartgwt>SGWT Showcase sample</smartgwt> until you can reproduce the problem
// <li> Remove code from your application until it minimally shows the problem and runs standalone
// </ol>
// <P>
// For approach #1, find the nearest match to your use case in the
// <smartclient>
// +docTreeLink{FeatureExplorer} examples or in the other examples accessible from the Examples
// folder of the SDK, then try to minimally modify that example to demonstrate your issue.
// Feature Explorer examples are a particularly good starting point because you can simply copy
// the code from the Feature Explorer to the Eval JS area of the Developer Console and begin
// changing it, and if successful this yields a type #1 test case,
// </smartclient><smartgwt>
// SGWT Showcase samples or in the sample projects included in the SGWT download package, then
// try to minimally modify that sample to demonstrate your issue.  This should yield a
// #1 test case,
// </smartgwt>
// the easiest for you to submit and most efficient for Isomorphic to work with.
// <P>
// For approach #2,
// <ol>
// <li> If a server is involved in initial page generation (eg a .jsp file), in most cases you
// can eliminate many server dependencies <b>and</b> create an easily modifiable starting point
// by using the browser's "View Source" feature to save a copy of the generated HTML output as
// an .html file in the same directory as the .jsp file that generated it.  Such a file will
// generally continue to function (all relative paths are still correct), and can be modified
// freely without the need to later revert changes to a .jsp.
// <li> Eliminate any code that isn't involved in the interaction.  Keep running the test case
// as you eliminate code to ensure you are still seeing the issue (you may solve it this way,
// or find key preconditions that you can report to Isomorphic)
// <li> For any issue that isn't cosmetic, revert to a default SmartClient skin
// <li> For any necessary RPC/DataSource interactions, spoof the interaction with one of these
// approaches:
// <ul>
// <li> switch any DataSources to one of the sample DataSources from the <smartclient>SDK
// (eg "supplyItem")</smartclient><smartgwt>SGWT Showcase (e.g. ItemSupplyXmlDS)</smartgwt>
// if your issue can still be reproduced in this case.
// <li> create a small sample dataset in <smartclient>JavaScript directly in the .html file,
// </smartclient><smartgwt>Java directly in the Java sample file</smartgwt> and use a
// +link{dataSource.clientOnly,clientOnly DataSource} with that dataset.
// <li> capture server responses verbatim by setting the RPCManager log category to DEBUG, save
// the responses as flat files, and set +link{dataSource.dataURL} to point at them.
// <li> for RPCs, instead of calling the RPCManager, directly call your own callback function,
// passing a spoofed RPCResponse that includes just the fields your code depends upon
// </ul>
// <smartclient>
// <li> Finally, move your .html file into the stock SmartClient SDK</smartclient>
// <smartgwt>
// <li> Finally, move your Java file into one of the stock SGWT sample projects,
// such as the BuiltInDS sample,</smartgwt>
// along with any remaining dependencies and verify the problem can still be reproduced
// </ol>
// Having prepared the test case, combine it with the other required issue report information
// covered above, and submit it to the +externalLink{http://forums.smartclient.com/,forums},
// or, if you have Enterprise Support, at the
// +externalLink{http://support.isomorphic.com/,Customer Support Extranet}.
// <P>
// <h4>Using the Debug Modules (Advanced)</h4>
// <P>
// See +link{group:debugModules,Using the Debug Modules}.
// <P>
// <h4>Adding your own diagnostic categories</h4>
// <P>
// Calling <code>logWarn()</code> is fine for a log statement you plan to delete at the end of
// the debugging session.  However, many log statements have lasting value if you could enable
// or disable them only when you need the relevant diagnostics, like SmartClient's built-in
// diagnostic categories.  To do this, pick a priority level less than <code>WARN</code>
// (<code>INFO</code> or <code>DEBUG</code>), and call the corresponding method on the
// <smartclient>Log</smartclient><smartgwt>SC</smartgwt> class (<code>logInfo()</code> or
// <code>logDebug()</code>), passing the category name as a second parameter.  For example:
// <smartclient>
// <pre>
//     isc.Log.logInfo("first record is: " + isc.Log.echo(myGrid.data.get(0)),
//                     "myGridLoading");
// </pre>
// </smartclient><smartgwt>
// <pre>
//     Sc.logInfo("first record is: " +
//                SC.logEcho(myGrid.getDataAsRecordList().get(0).getJsObj()),
//                "myGridLoading");
// </pre>
// </smartgwt>
// This message will no longer appear in the Results Pane by default, because its priority
// (<code>INFO</code>) is less than the default of <code>WARN</code>.  To see this message,
// open the Logging Preferences menu and pick "More..", then click the "Add" button, enter
// "myGridLoading" as the category name and set the priority to <code>INFO</code>.  The message
// will now appear next time it is logged.
// <P>
// Now you have a custom log category that you and other developers can use to debug your
// application, subsystem by subsystem.  These diagnostics will be available to you both in
// development and production environments.
// <P>
// As with SmartClient's built-in diagnostics, you may choose to log certain messages in your
// custom category at the <code>DEBUG</code> level and a lesser number of messages at the
// <code>INFO</code> level, to create different depths of diagnostic output.
// <P>
// <smartclient>
// <h4>Logging refinements</h4>
// <P>
// The core log methods (<code>logDebug()</code>, <code>logInfo()</code>,
// <code>logWarn()</code>) and the "echo" facilities (<code>echo()</code> and
// <code>echoAll()</code>) are available on every SmartClient component and Class.  Hence,
// in many cases, the special JavaScript value "this" will refer to an object that supports
// <code>logWarn()</code> et al.  For example:
// <pre>
//     isc.Canvas.create({
//        ID:"canvasExample",
//        contents:"Hello World!",
//        click:"this.logWarn('the Canvas is: ' + this.echo(this))"
//     });
// </pre>
// The special value "this" is not always set to a SmartClient component, for example, in some
// kinds of callbacks (eg +link{ListGrid.fetchData(),fetchData()}).  When in doubt, use these
// methods via the Log class as <code>isc.Log.logWarn()</code>.
// <P>
// </smartclient>
// <b>Find the source of logs</b>
// Sometimes, you will see a log message with a warning, usage error or other unusual condition,
// and it won't be clear how your code is causing the log to appear.  In these situations, you can
// use +link{Log.traceLogMessage()} to request that a stack trace is logged whether that specific
//  message appears.
// <b>Logging performance</b>
// <P>
// Because the log message is actually formed <i>before</i> the call to the log system, logs
// that are suppressed can still carry a performance penalty.  This is particularly true of
// logs that output a lot of data or occur frequently.  To avoid this penalty, you can check in
// advance whether a message will be suppressed using
// <smartclient>
// +link{classMethod:Class.logIsDebugEnabled(),isc.Log.logIsDebugEnabled()} and
// +link{classMethod:Class.logIsInfoEnabled(),isc.Log.logIsInfoEnabled()}.  For example:
// <pre>
//     if (isc.Log.logIsInfoEnabled("myGridLoading")) {
//        isc.Log.logInfo("first record is: " + isc.Log.echo(myGrid.data.get(0)),
//                        "myGridLoading");
//     }
// </pre>
// </smartclient><smartgwt>
// +externalLink{../util/SC.html#logIsDebugEnabled(java.lang.String),SC.logIsDebugEnabled()} and
// +externalLink{../util/SC.html#logIsInfoEnabled(java.lang.String),SC.logIsInfoEnabled()}.
// For example:
// <pre>
//     if (SC.logIsInfoEnabled("myGridLoading")) {
//         SC.logInfo("first record is: " +
//                    SC.logEcho(myGrid.getDataAsRecordList().get(0).getJsObj()),
//                    "myGridLoading");
//     }
// </pre>
// </smartgwt>
// Generally, it is only important to do this for logs that will occur multiple times during a
// given user interaction (eg a mousedown or keypress) and/or that call <code>echo()</code> on
// objects with many properties.
//
// @title Debugging
// @treeLocation Concepts
// @see serverLogging
// @see remoteDebugging
// @visibility external
//<

//> @groupDef remoteDebugging
//
// In Pro and better builds (and also the Eval build), the SmartClient
// +link{groupDev:debugging,Developer Console} supports debugging remote pages,
// including those running on mobile devices.  With remote debugging, you can use all of the
// powerful debugging features of the +link{groupDev:debugging,Developer Console} - the
// component hierarchy (Watch tab), client/server requests (RPC tab), logs and log categories -
// using the large screen and physical keyboard of a desktop machine.
//
// <P>
// <h4>Using Remote Debugging</h4>
// <P>
// To enable remote debugging on a page, just add <code>isc_remoteDebug=true</code> to the page
// URL.  For example:
// <p>
// <smartclient>
// +externalLink{http://localhost:8080/isomorphic/system/reference/SmartClient_Explorer.html?isc_remoteDebug=true}
// </smartclient>
// <smartgwt>
// +externalLink{http://localhost:8080/?isc_remoteDebug=true}
// </smartgwt>
// </p>
// Note in the URL above, set localhost to the actual hostname or IP address of the machine
// running the SDK.
// <P>
// You'll also need to be sure that your +link{Page.setIsomorphicDir(),isomorphicDir} has been set up
// correctly and that messaging is enabled on your server as noted below.
// <p>
// Then direct your <i>desktop</i> browser to the Developer Console in the
// <code>system/helpers/</code> subdirectory of your isomorphic dir - typically:
// <p>
// <smartclient>
// +externalLink{http://localhost:8080/isomorphic/system/helpers/Log.html}
// </smartclient>
// <smartgwt>
// +externalLink{http://localhost:8080/showcase/sc/system/helpers/Log.html}
// </smartgwt>
// </p>
// At top right of the page, you will see a "Remote" dropdown that lists the devices and URLs
// that have registered for
// remote debugging (by passing the <code>isc_remoteDebug</code> parameter).  As you roll over
// the available remote targets in this dropdown, the target page will glow blue to make it
// easy to tell which page you will be selecting for debugging - this is particularly handy
// when you have a lot of devices.  Pick the page to debug and just starting using the
// +link{groupDev:debugging,Developer Console} as normal.
// <p>
// If you reload the page on your mobile device, the remote Developer Console automatically
// re-establishes the connection.  And any settings - such as Logging Preferences or Watch tab
// settings - automatically persist as they normally would.
// <p>
// <h4>Licensing</h4>
// <p>
// Anyone with a Pro or better license can use the Remote Debugging feature.
//
// Under the covers, the Remote Debugging feature actually uses the Real-time Messaging module,
// which is not a Pro feature.  However we've rearranged things so that Pro users can use
// Real-time Messaging <i>just for Remote Debugging</i>.
//
// This does mean that, if you are upgrading your environment to the current release and you
// don't already have Real-time Messaging, you will need to follow the installation steps
// normally required for Real-time Messaging before the Remote Debugging feature will work.
// See the +link{groupDef:messaging} documentation for details.
//
// @title Remote Debugging
// @treeLocation Concepts
// @see debugging
// @visibility external
//<


//> @groupDef debugModules
// <smartclient>
// SmartClient comes with a debug / readable version of the SmartClient JS files that may
// be useful during development.
// </smartclient><smartgwt>
// Smart&nbsp;GWT LGPL, Pro, Power, and Enterprise come with debug / readable versions of the
// SmartClient JS files that may be useful during development.
// </smartgwt>
// <P><b>
// Note: These are useful only if you are interested in step-through debugging of
// framework JavaScript code using a JavaScript debugger, and we strongly discourage
// this as a primary approach to debugging: the SmartClient framework code provides many,
// many advanced features and is extremely sophisticated as a result.  Learning the
// internals of large parts of SmartClient is unnecessary and ineffective as a debugging
// approach, and the other approaches discussed in +link{group:debugging}
// should be your primary approaches to troubleshooting.</b>
// <smartclient>
// <p>To use the debug modules, simply change each &lt;script&gt; tag's SRC to the URI of the
// debug version of the module. For example:
// <pre>&lt;script src="/isomorphic/system/modules/ISC_Core.js"&gt;&lt;/script&gt;</pre>
// should be changed to:
// <pre>&lt;script src="/isomorphic/system/modules<b>-debug</b>/ISC_Core.js"&gt;&lt;/script&gt;</pre>
//
// <p>Alternatively, the &lt;isomorphic:loadISC&gt; and &lt;isomorphic:loadModules&gt; tags
// support a <code>useDebugModules</code> attribute:
// <pre>&lt;isomorphic:loadISC skin="Enterprise" useDebugModules="true"/&gt;</pre>
// <p>
// Note that the debug modules are intended to help in debugging your own application,
// and not the SmartClient Feature Explorer.  The Feature Explorer is not present
// in modules-debug, and the non-debug version requires the other non-debug files.</smartclient>
// <smartgwt>
// <p>To enable the use of debug modules, you will need to change the &lt;inherits&gt; lines
// in the application's GWT module file to reference the debug versions of the Smart&nbsp;GWT modules:
// <table border="1" cellpadding="5" cellspacing="0">
// <tbody>
// <tr><th>Edition</th><th>Original &lt;inherits&gt;</th><th>New &lt;inherits&gt;</th></tr>
// <tr>
// <th>LGPL</th>
// <td><code>&lt;inherits name="com.smartgwt.SmartGwt"/&gt;</code></td>
// <td><code>&lt;inherits name="com.smartgwt<b>.debug.</b>SmartGwt<b>Debug</b>"/&gt;</code></td>
// </tr>
// <tr>
// <th>Pro</th>
// <td><code>&lt;inherits name="com.smartgwtpro.SmartGwtPro"/&gt;</code></td>
// <td><code>&lt;inherits name="com.smartgwtpro<b>.debug.</b>SmartGwtPro<b>Debug</b>"/&gt;</code></td>
// </tr>
// <tr>
// <th>Power</th>
// <td><code>&lt;inherits name="com.smartgwtpower.SmartGwtPower"/&gt;</code></td>
// <td><code>&lt;inherits name="com.smartgwtpower<b>.debug.</b>SmartGwtPower<b>Debug</b>"/&gt;</code></td>
// </tr>
// <tr>
// <th>Enterprise</th>
// <td><code>&lt;inherits name="com.smartgwtee.SmartGwtEE"/&gt;</code></td>
// <td><code>&lt;inherits name="com.smartgwtee<b>.debug.</b>SmartGwtEE<b>Debug</b>"/&gt;</code></td>
// </tr>
// </tbody>
// </table>
// <p>
// The convention is that the names of debug GWT modules end with "Debug".
//
// <p>If using the NoScript modules, you will instead need to change the &lt;inherits&gt; lines
// as follows:<table border="1" cellpadding="5" cellspacing="0">
// <tbody>
// <tr><th>Edition</th><th>Original &lt;inherits&gt;</th><th>New &lt;inherits&gt;</th></tr>
// <tr>
// <th>LGPL</th>
// <td><code>&lt;inherits name="com.smartgwt.SmartGwtNoScript"/&gt;</code></td>
// <td><code>&lt;inherits name="com.smartgwt<b>.debug.</b>SmartGwtNoScript<b>Debug</b>"/&gt;</code></td>
// </tr>
// <tr>
// <th>Pro</th>
// <td><code>&lt;inherits name="com.smartgwtpro.SmartGwtProNoScript"/&gt;</code></td>
// <td><code>&lt;inherits name="com.smartgwtpro<b>.debug.</b>SmartGwtProNoScript<b>Debug</b>"/&gt;</code></td>
// </tr>
// <tr>
// <th>Power</th>
// <td><code>&lt;inherits name="com.smartgwtpower.SmartGwtPowerNoScript"/&gt;</code></td>
// <td><code>&lt;inherits name="com.smartgwtpower<b>.debug.</b>SmartGwtPowerNoScript<b>Debug</b>"/&gt;</code></td>
// </tr>
// <tr>
// <th>Enterprise</th>
// <td><code>&lt;inherits name="com.smartgwtee.SmartGwtEENoScript"/&gt;</code></td>
// <td><code>&lt;inherits name="com.smartgwtee<b>.debug.</b>SmartGwtEENoScript<b>Debug</b>"/&gt;</code></td>
// </tr>
// </tbody>
// </table>
// <p>
// and change the &lt;script&gt; tags in the application's HTML file to the debug modules
// instead of the normal SmartClient modules. For example:<pre><code>
//    &lt;script src="myapp/sc/modules<b>-debug</b>/ISC_Core.js"&gt;          &lt;/script&gt;
//    &lt;script src="myapp/sc/modules<b>-debug</b>/ISC_Foundation.js"&gt;    &lt;/script&gt;
//    &lt;script src="myapp/sc/modules<b>-debug</b>/ISC_Containers.js"&gt;    &lt;/script&gt;
//    &lt;script src="myapp/sc/modules<b>-debug</b>/ISC_Grids.js"&gt;         &lt;/script&gt;
//    &lt;script src="myapp/sc/modules<b>-debug</b>/ISC_Forms.js"&gt;         &lt;/script&gt;
//    &lt;script src="myapp/sc/modules<b>-debug</b>/ISC_RichTextEditor.js"&gt;&lt;/script&gt;
//    &lt;script src="myapp/sc/modules<b>-debug</b>/ISC_Calendar.js"&gt;      &lt;/script&gt;
//    &lt;script src="myapp/sc/modules<b>-debug</b>/ISC_DataBinding.js"&gt;   &lt;/script&gt;
//    &lt;script src="myapp/sc/modules<b>-debug</b>/ISC_Drawing.js"&gt;       &lt;/script&gt;
// </code></pre>
// Alternatively, the &lt;isomorphic:loadISC&gt; and &lt;isomorphic:loadModules&gt; tags
// support a <code>useDebugModules</code> attribute:
// <pre>&lt;isomorphic:loadISC skin="Enterprise" useDebugModules="true"/&gt;</pre>
// </smartgwt>
//
// @title Using the Debug Modules
// @see debugging
// @treeLocation Concepts
// @visibility external
//<

//> @groupDef superDevModeTroubleshooting
// This topic provides details on configuring and running Super Dev Mode, and troubleshooting
// any problems.  For an overview see +link{debugging, Debugging: Dev Mode and Super Dev Mode}.
// <P>
// <h3>Super Dev Mode in GWT 2.7.0+</h3>
// <P>
// The recommended way of running Super Dev Mode in GWT 2.7.0+ is by installing the
// +externalLink{http://www.gwtproject.org/download.html, GWT (Super) Dev Mode Plugin}
// and launching the
// +externalLink{http://www.gwtproject.org/articles/superdevmode.html,Super Dev Mode Server}
// using a Web Application Run Configuration.  For more guidance beyond the overview in the
// previous link, see
// +externalLink{http://www.gwtproject.org/usingeclipse.html,Using GWT with Eclipse}.
// <P>
// <h3>Super Dev Mode in GWT 2.6.x and Earlier</h3>
// <P>
// For GWT releases before GWT 2.7.0, you must run the Code Server directly.  It can be
// launched in +externalLink{https://www.eclipse.org/, Eclipse} (with or without a web server),
// or you can launch it from the command line.  Unless a web server is launched in Eclipse
// with the Code Server, you'll need to deploy the SGWT Web Application separately from the Code
// Server.
// <P>
// At this point, it's assumed that you have installed the
// +externalLink{http://www.gwtproject.org/download.html,GWT Eclipse Plugin}, and that
// you already have an Eclipse Project containing your Java code with a valid classpath picking
// up the SGWT JARs and the GWT SDK Library (perhaps the same project you use for Dev Mode).
// <p>
// <h4>Creating a Run Configuration for the Code Server</h4>
// <p>
// You must first create a new Run Configuration for the GWT Code Server.  To do this:<ul>
// <li> Right Click / Run As... / Run Configurations
// <li> Select "Java Application", and hit the "New" button
// <li> Set the title (very top) to something you'll remember
// <li> Set the "Main class" to <code>com.google.gwt.dev.codeserver.CodeServer</code>
// <li> If using GWT 2.6.1 or earlier, then in the "Classpath" tab, add
//      <code>gwt-codeserver.jar</code> using the "Add External Jar" button
// <li> In the "Arguments" Tab, add entries for (at a minimum) the source path and
//      the module (package, plus name of your .gwt.xml file) - for example:
//      <code>-src src/ com.smartgwt.sample.BuiltInDS</code></ul>
// <p>
// For the required JAR above, you can either
// +externalLink{http://www.gwtproject.org/download.html, download} a version of the GWT SDK
// and extract the needed JAR, or locate it in your Eclipse installation (from the GWT Plugin).
// Additional arguments beyond those mentioned in the last step above are supported in the
// "Arguments" Tab, such as specifying a port, bind address, etc.  Your Run Configuration
// should now be complete.
// <p>
// <h4>Configuring your GWT Project</h4>
// <p>
// A few additions to your GWT Project must be made if you're using a GWT SDK version older
// than 2.7.  (They are included as comments in the "Built in DS" sample GWT Project,
// BuiltInDS.gwt.xml.)  If you're running GWT SDK 2.6 or older, you must add:
// <p>
// <code>&lt;add-linker name="xsiframe" /&gt;</code>
// <p>
// and if you're running GWT SDK 2.5 or older, you must also add:
// <p>
// <code>&lt;set-configuration-property name="devModeRedirectEnabled" value="true" /&gt;</code>
// <p>
// <h4>Running the Code Server</h4>
// <p>
// At this stage you should be able to start the code server:<ul>
// <li> Right Click / Run As... / Run Configurations
// <li> Select the new configuration you added</ul>
// <p>
// You should see a bunch of logging in the console tab of Eclipse, followed by a URL.  Visit
// that URL in your browser, and drag the "Dev Mode On" and "Dev Mode Off" buttons up to your
// browser bookmarks toolbar.  These bookmarks allow you to easily switch to Super Dev Mode
// (recompiling your Web Application) or switch back to Production Mode.
// <p>
// <h4>Deploying your Web Application</h4>
// <p>
// You should now launch the "Web Application" Run Configuration that it was suggested you use -
// the simplest way is to Right Click on the Project / Run As / Web Application.  Visit the URL
// generated by Eclipse, without the <code>gwt.codesvr</code> parameter.  You may see a
// warning about needing a recompile - you can either ignore this or run a full compile once to
// get rid of it.  (If you've deployed your Web Application manually outside of Eclipse, this
// section can be skipped.)
// <p>
// <h4>Entering Super Dev Mode</h4>
// <p>
// Visit the Production Mode URL of the running Web Application.  The bookmarks created earlier
// can now be used to enter Super Dev Mode:<ul>
// <li>hit the "Dev Mode On" bookmark link
// <li>on the pop-up, select the button to "Compile"</ul>
// <p>
// If you make code changes, you can update Super Dev Mode using the "Dev Mode On" bookmark.
// <P>
// <h3>Script Tags in Super Dev Mode</h3>
// <P>
// The official GWT Super Dev Mode linker (the default linker in GWT 2.7.0+) does not support
// including modules which load javascript files.  SmartGWT restores support for script tags
// by modifying some of the generated files with a post link step.  However, going forward
// it is recommended to migrate away from script tags in modules since we cannot control future
// changes to GWT that may introduce additional incompatibilities.
// <P>
// To avoid script tags if you're inheriting the standard module
// <code>com.smartgwtee.SmartGwtEE</code>, you'll need to switch that to
// <code>com.smartgwtee.SmartGwtEENoScript</code>, and add the following
// lines to your bootstrap HTML file (under the "war" directory):
// <pre><code>
//    &lt;script src="[app]/sc/modules/ISC_Core.js"&gt;          &lt;/script&gt;
//    &lt;script src="[app]/sc/modules/ISC_Foundation.js"&gt;    &lt;/script&gt;
//    &lt;script src="[app]/sc/modules/ISC_Containers.js"&gt;    &lt;/script&gt;
//    &lt;script src="[app]/sc/modules/ISC_Grids.js"&gt;         &lt;/script&gt;
//    &lt;script src="[app]/sc/modules/ISC_Forms.js"&gt;         &lt;/script&gt;
//    &lt;script src="[app]/sc/modules/ISC_RichTextEditor.js"&gt;&lt;/script&gt;
//    &lt;script src="[app]/sc/modules/ISC_Calendar.js"&gt;      &lt;/script&gt;
//    &lt;script src="[app]/sc/modules/ISC_DataBinding.js"&gt;   &lt;/script&gt;
//
//    &lt;script src="[app]/sc/skins/[skinname]/load_skin.js"&gt;&lt;/script&gt;</code></pre>
// In the above lines:<ul>
// <li>Replace "<code>[app]</code>" with the directory containing the "sc" lib - determined by
// the "rename-to" attribute in your .gwt.xml file -- for example "builtinds" or "dsdmi".
// <li>Replace "<code>[skinname]</code>" with the name of the skin you want to use -- for
// example "Enterprise" or "Graphite".</ul>
// <p>
// <h3> Browser Source Map Support</h3>
// As discussed in +link{debugging, Debugging: Dev Mode and Super Dev Mode}, not all browsers
// and debuggers at this time support the Source Maps feature that's required to set
// breakpoints for Super Dev Mode.  To enable them in Chrome, make sure the "Enable JavaScript
// Source Maps" checkbox is ticked in the Developer Tools preferences.  When the page is loaded
// and you've hit the "Dev Mode On" bookmark, you can browse the Java source in the debugger
// (under the "sources tab"), and set breakpoints in Java code.
// <p>
// <h3><u>Troubleshooting</u></h3>
// <table width="90%" class="normal" align="center" border="1" cellpadding="5">
// <tr bgcolor="#b0b0b0">
//     <td width="30%"><b>Problem</b></td>
//     <td width="30%"><b>Possible Causes</b></td>
//     <td width="40%"><b>Solution</b></td>
// </tr><tr>
// <td>Missing GWT classes or JARs are reported when project is compiled.</td>
// <td>GWT Eclipse Plugin with GWT SDK is not installed or project was built with version
//  different from what's configured in Eclipse and needs to be rebuilt.</td>
// <td>Install plugin (ticking checkbox for GWT SDK) from
// +externalLink{http://www.gwtproject.org/download.html, here} and/or rebuild project.</td>
// </tr><tr>
// <td>Error reported: "Could not find or load main class
// com.google.gwt.dev.codeserver.<wbr>CodeServer".</td>
// <td>In GWT 2.6.1 and earlier, adding the GWT SDK library to your project's build path
// doesn't automatically add the gwt-codeserver.jar (included in the GWT SDK zip) to the build
// path.</td>
// <td>Add gwt-codeserver.jar as a separate JAR to the project build path.</td>
// </tr><tr>
// <td>Errors are reported by GWT about the "linker not supporting script tags" when your
// project is oompiled.</td>
// <td>The SmartGWT Linker has been enhanced to work around this issue, so you should no
// longer be affected by it when migrating from earlier GWT versions.</td>
// <td>Report any remaining issues at +externalLink{http://forums.smartclient.com}.</td>
// </tr><tr>
// <td>Nothing happens when you visit the "Dev Mode On" bookmark.</td>
// <td>The GWT Code Server is not running or the bookmark is not valid.</td>
// <td>Start the Code Server or create new bookmarks from the URL displayed in the Eclipse
// console when the Code Server launches.</td>
// </tr><tr>
// <td>No GWT projects are found/available for recompiling when the modal dialog opens
// from clicking "Dev Mode On" bookmark, and you're running GWT 2.6 or earlier.</td>
// <td>Needed lines of the GWT Project file (gwt.xml) are missing or commented.</td>
// <td>Read section "Configuring your GWT Project" above and uncomment the appropriate
// gwt.xml lines based on your GWT version, or copy them from BuiltInDS.gwt.xml</td>
// </tr><tr>
// <td>When you launch your Web Application from Eclipse as directed above, you see an error
// in the browser indicating the GWT Plugin is missing (and perhaps that it's not available).
// </td><td>
// You've forgotten to remove the <code>gwt.codesvr</code> argument from the URL as
// we instructed above and the browser is not able to find the GWT Dev Mode Plugin.</td>
// <td>Remove the <code>gwt.codesvr</code> argument from the URL, or don't use the Eclipse GWT
// "Web Application" Run Configuration template (intended originally for Dev Mode) to launch
// your Web Application.  You may deploy your Web Application manually outside of Eclipse.</td>
// </tr><tr>
// <td>When the SDM Server is launched in Eclipse, the SGWT Application fails to
// load, resource or configuration files are reported missing, or browser errors are hit
// because the core SmartClient JavaScript Framework files haven't been loaded properly.
// Missing symbols may be reported, such as "isc is not defined".
// </td><td>JavaScript Framework or linker-created files are missing from the war directory, or
// your GWT project uses script tags, but you're not using or have not merged your app's main
// page from the BuiltInDS Sample Project HTML.  The linkers used by GWT for SDM don't support
// script tags, but SGWT generates code to load them for you automatically.  However, this
// requires that your app's HTML load the file loadScriptTagFiles.js as in the BuiltInDS Sample
// Project.</td>
// <td>Make sure to run the GWT Plugin in <i>Classic Dev Mode</i> at least once, to install the
// Framework resources and generate loadScriptTagFiles.js.  Then, if not already present, merge
// the line loading loadScriptTagFiles.js into your application's main HTML page from the
// BuiltInDS Sample Project.  (If you hit the latter issue, please add your opinion to the
// +externalLink{https://github.com/gwtproject/gwt/issues/9149,GWT Issue report} to help
// get it resolved.)<br>
// Alternatively, you may run the Code Server Java app directly (even in GWT 2.7.0) rather than
// using the GWT SDM Server.  See the instructions above provided for GWT 2.6.x and ealier.</td>
// </tr><tr>
// <td>You're not able to connect to the SDM Code Server from a remote machine, even though
// you've launched it with -bindAddress 0.0.0.0 to enable all IP addresses to connect.</td>
// <td>You're hitting a +externalLink{https://github.com/gwtproject/gwt/issues/8910,known issue}
// with SDM in GWT that affects any situation where the fully qualified server name is not
// available via DNS lookup on the client, even if you access the server by IP address.</td>
// <td>Ensure DNS lookup is available for the server on the client, or add a binding to your
// hosts files.</td>
// </tr></table>
// <p><b>
// A useful discussion of some other problems and solutions related to GWT Super Dev Mode can be
// found +externalLink{http://stackoverflow.com/questions/18330001/super-dev-mode-in-gwt, here}.
// </b>
//
// @title Troubleshooting Super Dev Mode
// @treeLocation Concepts
// @see debugging
// @visibility sgwt
//<

//> @groupDef devConsoleRPCTab
// The "RPC" tab of the SmartClient Developer Console allows you to track
// +link{class:RPCRequest}s and +link{class:DSRequest}s sent from your application.  Tracking
// is activated by checking the "Track RPCs" box at the top of the tab.
// <p>
// The main "RPC History" list shows the transactions that have been sent from your application
// since the session began (since you checked the "Track RPCs" box or refreshed your browser,
// whichever happened most recently).  Each entry in the list represents either a server
// roundtrip, a DSRequest to a clientOnly DataSource or a direct request to a webservice.
// +link{RPCManager.startQueue,Request queues} are shown as separate entries, with the requests
// that made up the queue shown indented beneath it.
// <p>
// Each entry in the RPC History list shows useful diagnostic information, including:
// <ul>
// <li>Whether the request was sent via a server-side proxy</li>
// <li>The URL of the request, or an indication that the request was client-only</li>
// <li>The type of request - +link{class:DSRequest}, +link{class:RPCRequest},
//    +link{class:WSRequest} or +link{RPCManager.startQueue,Queue}</li>
// <li>The DataSource name, operation type and operation ID</li>
// <li>The success/failure status of the request, if it has completed</li>
// <li>Basic timing information</li>
// </ul>
// In addition, clicking an entry in the RPC History list populates the "Request" and "Response"
// sections with the details of the request.
// <p>
// <h2>Detailed timing/profiling information</h2>
// <P>
// SmartClient and SmartClient Server can gather detailed profiling information for a
// request/response roundtrip, and display it in the Developer Console.  Note, the server-side
// information is only available for DSRequests, and only if you are using the SmartClient
// Server module.  Extra levels of server-side detail are available if you are also using one
// of SmartClient Server's built-in DataSource types (note, at the time of writing this only
// applies to SQLDataSource).  To enable detailed timings:
// <ul>
// <li>Set debug log category "RpcTabTiming" to INFO level in "Logging Preferences" (see
//     +link{group:debugging} for details)</li>
// <li>If you want to collect details of the server-side processing, either:
//     <ul>
//     <li>Set <code>DSRequest.returnTimingData: true</code> in your +link{server_properties,server.properties}
//         file.  This will cause server timing information to be gathered and returned for
//         every DSRequest from every client</li>
//     <li>Enable the built-in RPCs "areServerTimingsTracked" and "trackServerTimings" via the
//         <code>RPCManager.enabledBuiltinMethods</code> setting of your
//          +link{server_properties,server.properties}
//         file (these builtin RPCs should already be enabled in a development environment).
//         When these built-in RPCs are enabled, server timing data can be switched on and
//         off on a per-client basis, via a checkbox in the Developer Console.</li>
//     </ul>
// </li>
// </ul>
// With these settings in place, an extra "Timing" tab appears in the "Request" section:
// <p>
// <img src="skin/detailedTiming1.png" width="1059px" height="275px">
// <p>
// The timing data is tree-structured; a node with an opener next to it can be expanded to
// drill into more detail:
// <p>
// <img src="skin/detailedTiming2.png" width="1059px" height="701px">
// <p>
// The following important points apply to the detailed timing information:
// <ul>
// <li>It is meaningless to compare the actual start and end timestamps reported by the client
//     with those reported by the server, because their clocks are unlikely to be exactly
//     synchronized (unless the client and the server are the same physical machine).  The
//     timestamps are the underlying raw data - it is much more meaningful to consider the
//     elapsed times than the timestamps</li>
// <li>The basic timing details reported in the main RPC History list do not correspond to the
//     detailed timing data because the detailed timing data attempts to cover the entire
//     period of the transaction, from the UI event to calling the user callback method.  By
//     contrast, the basic timing data only covers the period from when the request left the
//     client to when the response was received by the client.  The basic timing "Time Sent"
//     and "Elapsed time" figures correspond to the "Server roundtrip" entry in the detailed
//     timing data</li>
// <li>The "Network time (inferred)" measurements are informed guesswork.  We calculate the
//     difference between the "Server turnaround" time measured by the client and the "Server
//     processing" time measured by the server, and apply half of that difference to either side
//     of the "Server processing" figure as "Network time (inferred)".  Note that this guesswork
//     can easily mean that network timings overlap with server processing timings, even when the
//     client and the server are the same machine</li>
// <li>The "UI event to DSRequest creation" timing measures the time from the most recent event
//     to be registered by the EventHandler subsystem, to that of DSRequest creation (and
//     hence, incidentally, is not recorded for RPCRequests).  This is often a meaningful thing
//     to measure, but not always.  If the DSRequest was created programatically during application
//     startup or off the back of a timer, then the most recent UI event clearly had no influence
//     and so measuring the time since it happened has no meaning.  However, most DSRequests
//     <em>are</em> created, directly or indirectly, as a result of a UI event; so even though we
//     can't tell which DSRequests belong to events and which don't, we still provide the figure
//     in the timing data as something that will be "often useful"</li>
// </ul>
//
// @title The Developer Console RPC Tab
// @treeLocation Concepts
// @visibility external
//<


isc.Log.addClassProperties({
    //> @type    LogPriority
    // Priority levels for log messages
    // @value  Log.FATAL   unrecoverable error
    FATAL : 1,
    // @value  Log.ERROR   error, may be recoverable
    ERROR : 2,
    // @value  Log.WARN    apparent problem, misused API, partial result
    WARN : 3,
    // @value  Log.INFO    significant events in normal operation
    INFO : 4,
    // @value  Log.DEBUG   diagnostics for developers
    DEBUG : 5,
    // @see Class.logDebug()
    //            @visibility external
    //<

    //>    @classAttr    Log.PRIORITY_NAMES        (string[] : [...] : IRWA)
    //        User-visible names for log priorities
    //        Note: NONE should never show up...
    //<
    PRIORITY_NAMES :["NONE" ,"FATAL", "ERROR", "WARN", "INFO", "DEBUG"]

});


// Hide the Log class setup when we're not debugging
//    this lets us just include the logger, but makes it all a no-op.
//    Note that the creation of Log and the setting of the LogPriority must always be present.


isc.Log.addClassProperties({

    //>    @classAttr    isc.Log.defaultPriority        (LogPriority : isc.Log.WARN : IRWA)
    // Any logs below this priority will be suppressed, unless a more specific setting exists for
    // the category.
    // @see Log.setPriority()
    // @visibility external
    //<
    defaultPriority:isc.Log.WARN,

    //>    @classAttr    isc.Log.stackTracePriority (LogPriority : isc.Log.ERROR : IRWA)
    // At this priority and above, a stack trace will be included automatically along with the log
    // message itself.
    // @visibility external
    //<
    stackTracePriority:isc.Log.ERROR,

    //>    @classAttr    isc.Log.showFireBugTrace (boolean : null : IRW)
    // Controls whether stack traces are written to the Firebug console.
    // Any value except false permits stack traces to be written.
    //<
    //showFireBugTrace: false,

    // priorities setting per category
    _logPriorities: {
        "sgwtInternal": (
                         isc.Log.FATAL)
    },
    // specific priorities for classes / instances
    _objectLogPriorities: {},

    //> @classAttr Log.messageCount (int : 1000 : IR)
    // Maximum number of logged messages to retain in memory.
    // <p>
    // Note that if the Developer Console is open, it will accumulate an unbounded number of
    // messages in the "Log Messages" area.  <code>messageCount</code> only affects the number
    // of messages held in memory in the main application's browser window or tab.
    // @visibility external
    //<
    messageCount:1000,


    // index of the slot for the next message in messageCache
    _messageIndex:0,

    // array for keeping log messages
    _messageCache:[],

    _semiColon : ":",
    _dot : ".",
    _allCategories : "_allCategories",
    _default : "_default",
    regexObjectForMessagePattern : null,
    prefixForMessagePattern : null
});

isc.Log.addClassMethods({

    // Log Priorities
    // --------------------------------------------------------------------------------------------

    //> @classMethod Log.applyLogPriorities()
    // Apply a batch a batch of priority settings, as a object mapping category names to priority
    // levels.
    //
    // @param settings (Object) priority settings for multiple categories
    // @visibility external
    //<
    applyLogPriorities : function (newDefaults) {
        // make a blank priority defaults object if necessary
        if (!this._logPriorities) {
            this._logPriorities = {};
        }

        // if new defaults were specified, overlay them on the current set
        if (newDefaults) {
            isc.addProperties(this._logPriorities, newDefaults);
        }
    },

    //> @classMethod Log.getLogPriorities()
    // Get all priority settings as an object mapping category names to priority levels.
    //
    // @param [object] (Class or Instance object) Optional param to get priorities specific to
    //                                            some ISC class or instance.
    // @param [overridesOnly] (boolean) If this method is retrieving the priorities specific
    //                                  to logging for some class or instance, this parameter
    //                                  can be used to view only the overrides to the default
    //                                  log priorities on this object.
    // @return (Object) priority settings
    // @visibility external
    //<
    getLogPriorities : function (object, overridesOnly) {
        var overrides;
        if (object != null) {
            var objectID = this._getObjectID(object);

            overrides = this._objectLogPriorities[objectID];
            if (overridesOnly) {
                return isc.addProperties({}, overrides);
            }
        }

        // copy to avoid unintentional changes
        var priorities = isc.addProperties({}, this._logPriorities);
        if (overrides) priorities = isc.addProperties(priorities, overrides);

        return priorities;
    },


    _getObjectID : function (object) {
        var ID;
        if (object == null) ID = isc.emptyString;
        else if (isc.isA.String(object)) return object; // already an ID
        else ID = (object.getID ? object.getID() : object.getClassName());
        return ID;
    },

    //> @classMethod Log.getPriority()
    // Return the priority setting for a particular category.
    // <P>
    // If there is no priority setting specific to this category, <code>null</code> will be
    // returned, NOT <code>Log.defaultPriority</code>.
    //
    // @param   category   (String)            category name
    // @param [object] (Class or Instance object)   Optional class or instance to check for
    //                                              specific log priority overrides
    // @return  (LogPriority)     priority setting
    // @visibility external
    //<
    // return the priority for a particular category
    getPriority : function (category, object) {

        if (object != null) {
            var objectID = this._getObjectID(object),
                overrides = this._objectLogPriorities[objectID];
            if (overrides) {
                if (overrides._allCategories != null) return overrides._allCategories;
                if (overrides[category] != null) return overrides[category];
                if (overrides._default != null) return overrides._default;
            }
        }

        // Still going - look at global settings
        var priorities = this._logPriorities;
        return priorities[category] || priorities._default;
    },

    //> @classMethod Log.setPriority()
    // Set the priority of messages that will be visible for this log category.
    // <P>
    // After calling setPriority, any messages logged to the given category whose priority is
    // below the specified priority will not appear in the Log.
    //
    // @param category   (String)            category name
    // @param priority   (LogPriority)  priority level to set
    // @param [object]   (Class or Instance object)
    //      Optional ISC class or instance - if passed the priority will be set for logging
    //      occurring on the class or instance only.
    // @see Log.isEnabledFor() to check whether a category would allow a log at a given priority
    // @visibility external
    //<
    setPriority : function (category, priority, object) {
        if (object != null) {
            var objectID = this._getObjectID(object);
            if (this._objectLogPriorities[objectID] == null)
                this._objectLogPriorities[objectID] = {};
            // If we're not passed a category, ensure we show all logs on the object in question
            // at the appropriate priority.
            if (!category) category = this._allCategories;
            this._objectLogPriorities[objectID][category] = priority;
        } else {

            this._logPriorities[category] = priority;
        }
    },

    //> @classMethod Log.setDefaultPriority()
    // Set the default priority of messages that will be visible.
    //
    // @param priority   (LogPriority)  priority level to set
    // @param [object]   (Class or Instance object)
    //      Optional ISC class or instance - if passed the default priority will be set for logging
    //      occurring on the class or instance only.
    // @visibility external
    //<
    setDefaultPriority : function (priority, object) {
        if (!object || object == isc.Log) isc.Log.defaultPriority = priority;
        else isc.Log.setPriority("_default", priority, object);
    },

    //> @classMethod Log.getDefaultPriority()
    // Retrieves the default priority of messages that will be visible.
    //
    // @param [object]   (Class or Instance object)
    //      Optional ISC class or instance - if passed the returns the default priority for
    //     the class or instance only.
    // @return (LogPriority) default priority for which messages will be logged.
    // @visibility external
    //<
    getDefaultPriority : function (object) {
        var defaultPriority;
        if (object && object != isc.Log) defaultPriority = this.getPriority("_default", object);
        return defaultPriority || isc.Log.defaultPriority;
    },

    //> @classMethod Log.clearPriority()
    // Clear the priority setting for a particular category, so that the category's effective
    // priority returns to <code>Log.defaultPriority</code><br>
    // If the optional second parameter is passed, the specific priority setting for the
    // category on that object will be cleared, so logs in that category on that object will
    // be logged at the global priority level for the category.
    //
    // @param category   (String)            category name
    // @param [object] (Class or Instance object) Optional instance or class object - if passed
    //                                        clear logging priority for the appropriate category
    //                                        on that object.
    // @visibility external
    //<
    clearPriority : function (category, object) {
        if (object) {
            var objectID = this._getObjectID(object);

            // If we were passed no category, clear all explicit log priorities on the object
            // in question.
            if (!category)
                delete this._objectLogPriorities[objectID];
            else if (this._objectLogPriorities[objectID])
                delete this._objectLogPriorities[objectID][category];

        } else {
            delete this._logPriorities[category];
        }
    },

    //> @classMethod Log.isEnabledFor()
    // Would a message logged to the given category at the given priority appear in the Log?
    // <P>
    // NOTE: if there is no specific priority setting for a given category, the
    // <code>Log.defaultPriority</code> is used.
    //
    // @param category   (String)            category name
    // @param priority   (LogPriority)  priority level to check
    //
    // @visibility external
    //<
    // NOTE: hierarchical categories are not documented; not clear whether we want to expose this
    // feature
    isEnabledFor : function (category, priority, object) {
        if (!category) category = isc._emptyString;
        while (category != isc._emptyString) {

            // get the priority for the category
            var categoryPriority = this.getPriority(category, object);
            // if it was found and its priority is set
            if (categoryPriority != null) {
                // return if the message is at the appropriate priority
                return priority <= categoryPriority;
            }

            // if the category contains a period, chop it down and try again
            var periodIndex = category.lastIndexOf(this._dot);
            if (periodIndex > 0) {
                // chop off the last category
                category = category.substring(0, periodIndex);
            } else {
                // jump out of the loop
                break;
            }
        }

        // category not found or was null -- return according to the default logging priority
        return priority <= isc.Log.defaultPriority;
    },

    // Formatting and Displaying Log messages
    // --------------------------------------------------------------------------------------------

    // log a message at an arbitrary priority (for wrappers)
    log : function (priority, message, category, msgPrefix, object, timestamp) {
        if (this.isEnabledFor(category, priority, object))
            this.addLogMessage(priority, message, category, msgPrefix, timestamp);
        else if (this.reportSuppressedLogs) {
            // Useful for detecting unnecessary logs, especially unnecessary logs during
            // critical path code
            this.logWarn("suppressed log, category: " + category + ": " + message
                // + this.getStackTrace()
            );
        }
    },

    // get a timestamp suitable for our short-lived log: millisecond precision, no need to show
    // date

    _1zero : "0",
    _2zero : "00",
    getLogTimestamp : function (date) {
        var tsArray = this._tsArray;
        if (tsArray == null) {
            tsArray = this._tsArray = [];
            tsArray[2] = this._semiColon;
            tsArray[5] = this._semiColon;
            tsArray[8] = this._dot;
        }

        if (date == null) date = new Date();
        var hours = date.getHours(),
            minutes = date.getMinutes(),
            seconds = date.getSeconds(),
            ms = date.getMilliseconds();

        tsArray[1] = hours;
        if (hours < 10) tsArray[0] = this._1zero;
        else tsArray[0] = null;

        tsArray[4] = minutes;
        if (minutes < 10) tsArray[3] = this._1zero;
        else tsArray[3] = null;

        tsArray[7] = seconds;
        if (seconds < 10) tsArray[6] = this._1zero;
        else tsArray[6] = null;

        tsArray[10] = ms;
        if (ms < 10) tsArray[9] = this._2zero;
        else if (ms < 100) tsArray[9] = this._1zero;
        else tsArray[9] = null;

        return tsArray.join(isc._emptyString);
    },


    // return the name shown to the user for a particular log priority
    getPriorityName : function (priority) {
        if (priority == null) return isc._emptyString;
        return this.PRIORITY_NAMES[priority];
    },

    // routine to format the log message and officially "log" it
    // override to set your own outputter
    _makeLogMessage : function (priority, message, category, msgPrefix, timestamp) {
        var msg = this._msgArray;
        if (msg == null) {
            msg = this._msgArray = [];
        }

        if (!category) category = this.category;

        msg[0] = this.getLogTimestamp(timestamp);
        msg[1] = this._semiColon;

        // Add the "thread" if available, eg, what the native source of the JS thread
        // is, such as mouse events, timers, etc
        if (this.ns.EH && this.ns.EH._thread != null) {
            msg[2] = this.ns.EH._thread;
            msg[3] = this._semiColon;
        }

        if (priority != null) {
            msg[4] = this.getPriorityName(priority);
            msg[5] = this._semiColon;
        }

        msg[6] = category;
        msg[7] = this._semiColon;
        // allow a prefix to the message to be passed in, so we can do the concat
        if (msgPrefix) {
            msg[8] = msgPrefix
            msg[9] = this._semiColon;
        }
        msg[10] = message;

        var result = msg.join(isc._emptyString);

        // clear out the array used to construct the message
        msg.length = 0;

        return result;
    },

    addLogMessage : function (priority, message, category, msgPrefix, timestamp) {


        var logMessage = this._makeLogMessage(priority, message, category, msgPrefix, timestamp);

        if (this.regexObjectForMessagePattern && this.regexObjectForMessagePattern.test(message)) {
            var stackTrace = isc.Log.getStackTrace(arguments, 4);
            // since there are many calls to addLogMessage, and "message" matches with the pattern provided
            // by the user, we need to avoid  treating those stack traces as an additional match.
            // Log.addLogMessage appears in the stack traces that we need to avoid showing in the Developer Console.
            var patternToAvoid = new RegExp("Log.addLogMessage", "im");
            if (!patternToAvoid.test(stackTrace)) {
                var msg = "traceLogMessage(): pattern '"+this.regexObjectForMessagePattern+"' matched, stack trace:\n"+stackTrace;
                if (this.prefixForMessagePattern) msg = this.prefixForMessagePattern + "\n" + msg;
                switch (priority) {
                    case this.FATAL : this.logFatal(msg);
                            break;
                    case this.ERROR : this.logError(msg);
                            break;
                    case this.WARN : this.logWarn(msg);
                            break;
                    case this.INFO : this.logInfo(msg);
                            break;
                    case this.DEBUG : this.logDebug(msg);
                }
            }
        }

        this.addToMasterLog(logMessage);

        if (this.warningLogged != null && priority != null && priority <= this.WARN) {
            this.warningLogged(logMessage);
        }

        // show alerts in addition for error and fatal level log messages
        if (priority != null && priority <= this.ERROR) {
            if (!isc.Browser.seleniumPresent) alert(message);
        }
    },

    // add a message to the master log
    // anyone who wants to know when messages are added should observe this method!
    addToMasterLog : function (message) {


        if (window.console != null) window.console.warn("*" + message);

//!DONTOBFUSCATE
// NOTE: we're not obfuscating so the "message" parameter will retain that name later
        // remember the message passed in
        this._messageCache[this._messageIndex] = message;

        // set up for the next message
        this._messageIndex++;

        // if we're beyond the appropriate number of messages to remember
        if (this._messageIndex > this.messageCount) {
            // roll over the messsageIndex to 0
            this._messageIndex = 0;
        }
        if (this.showInlineLogs) {
            this.updateInlineLogResults();
        }
    },

    showInlineLogs:false,
    updateInlineLogResults : function () {
        if (isc.Canvas == null || this._messageCache == null) return;
        if (!this.inlineLogCanvas) {
            this.inlineLogCanvas = isc.Canvas.create({
                    width:"50%", height:"100%", overflow:"auto",
                    backgroundColor:"white",
                    canDragReposition:true,
                    autoDraw:true
            });
        }
        this.inlineLogCanvas.setContents(this._messageCache.join("<br>"));
        this.inlineLogCanvas.bringToFront();
    },

    //> @classMethod Log.getMessages()
    // Return an Array of the most recently logged messages as an Array of Strings.  Up to
    // +link{Log.messageCount} messages may be returned.
    // @return (Array of String) most recently logged messages
    // @group debug
    // @visibility external
    //<
    getMessages : function () {
        var cache = this._messageCache,
            index = this._messageIndex,
            count = this.messageCount
        ;
        return cache.slice(count-index,count).concat(cache.slice(0, index));
    },

    //> @classMethod Log.show()
    // Open the Developer Console.
    // <P>
    // The Developer Console should <b>always</b> be open while developing any ISC-enabled
    // application, because ISC logs many important errors and warnings to the Developer Console.
    // <P>
    // In Internet Explorer, the Developer Console is able to log a stack trace for every JS error,
    // including errors that occur in non-ISC code.
    // <P>
    // NOTE: if you have the Microsoft JavaScript Debugger installed, ISC will be unable to log
    // stack traces on JS errors until you go to Tools->Internet Options->Advanced Tab and check
    // "Disable script debugging".  The ability to see stack traces in the Developer Console is
    // generally much more useful for debugging ISC-based applications than the generic Javascript
    // Debugging facilities.
    //
    // @group debug
    // @visibility external
    //<
    show : function (loading, logWindow, dontSaveState, windowName, inline) {
        if (!this.logViewer) this.logViewer = isc.LogViewer.create();
        this.logViewer.showLog(loading, logWindow, dontSaveState, windowName, inline);
    },

    //> @classMethod Log.clear()
    // Clear all currently displayed Log messages
    // @visibility external
    //<
    clear : function () {

        this._messageCache = [];
        this._messageIndex = 0;
        if (this.logViewer) this.logViewer.clear();
    },

    // evaluate an expression and log the results
    evaluate : function (expr, evalVars) {
        // execute the expression - and always report execution time
        var start = isc.timeStamp();

        var error,
            result
        ;
        // NOTE: "this" is the Log so that this.logWarn, this.echo et al will work
        if (isc.Log.supportsOnError) {
            // in IE, if there's an error, we report it via window.onerror
            result = isc.Class.evalWithVars(expr, evalVars, this);
        } else {
            // NOTE: try {} catch is not supported in Safari11, Nav4, or IE4
            try {
                result = isc.Class.evalWithVars(expr, evalVars, this);
            } catch (e) {
                error = e;
            }
        }
        var end = isc.timeStamp(),
            // show a timestamp for the log message itself if enabled
            resultString = isc.Log.getLogTimestamp() + ":";

        // don't show the entire expression
        var lines = expr.split(/[\r\n]+/);
        if (lines.length > 1) expr = lines[0] + "...";
        if (expr.length > 200) expr = expr.substring(0,200) + "...";
        if (error) {
            if (!isc.Log.supportsOnError) {
                isc.Log._reportJSError(error);
                return;
            }

            // In IE the error is an object - get the description property.
            // Unused since we let errors fall through in IE
            //if (isc.Browser.isIE) error = error.description;

            resultString += "Evaluator: '" + expr + "' returned a script error: \r\n"
                         + "'" + error + "'";
        } else {
            resultString = "Evaluator: result of '" + expr + "' (" + (end-start) +
                "ms):\r\n" + this.echo(result);
        }
        // Use addToLog instead of addToMasterLog()
        // - we don't care about losing this on log window reload
        if (this.logViewer) this.logViewer.addToLog(resultString, true);
    },

    // update the form in the log viewer
    updateStats : function (stat) {
        if (isc.debugTarget) isc.debugTarget.updateStats(stat);
    },

    // allow storing log messages before Log class has loaded (advanced internal usage)
    _logPrelogs : function () {
        var preLogs = isc._preLog;
        if (!preLogs) return;
        for (var i = 0; i < preLogs.length; i++) {
            var log = preLogs[i];
            if (isc.isA.String(log)) this.logDebug(log);
            else this.logMessage(log.priority || isc.Log.INFO,
                                 log.message, log.category, log.timestamp);
        }
        isc._preLog = null;
    },

    // Tracing and timing
    // --------------------------------------------------------------------------------------------

    //> @classMethod Log.traceLogMessage()
    //  Causes a stack trace to be logged any time a message containing the provided pattern is
    //  logged.  This can help figure out the origin of warnings or other mysterious logs in a large
    //  complex application.
    //  <p>
    //  The passed <code>messagePattern</code> is interpreted as a JavaScript regular expression.
    //  <p>
    //  Note: log messages that do not appear in the Developer Console because of
    //  +link{Log.setLogPriority,log priority settings} will never trigger a stack trace.
    //
    //  @param messagePattern (String)
    //  @param [prefix] (String)
    //
    //  @group    debug
    //  @visibility external
    //<
    traceLogMessage : function (messagePattern, prefix) {
        if (messagePattern) {
            if (isc.isA.String(messagePattern)) this.regexObjectForMessagePattern = new RegExp(messagePattern, "i");
            else this.regexObjectForMessagePattern = new RegExp(messagePattern);
        } else {
            this.regexObjectForMessagePattern = null;
        }
        if (prefix) this.prefixForMessagePattern = prefix;
        else this.prefixForMessagePattern = null;
    },

    //>    @classMethod        Log.traceMethod()
    //
    //  Observe a method on an object, logging a stack trace whenever the method is called.
    //  <P>
    //  Call a second time with identical arguments to disable tracing.
    //
    //    @param    object        (object)    object to observe
    //    @param    methodName    (string)    name of the method to observe
    //
    //    @group    debug
    //    @visibility external
    //<
    traceMethod : function (obj, methodName, callOnly) {
        if (!obj || !methodName) return;

        // Bail if the arguments aren't valid
        var object = this.validObservation(obj, methodName);
        if (!object) return;

        // Keep a list of what objects / methods we're logging traces for
        //      Note: format is {objName:[methodName1, methodName2]}

        if (!this._traceRegistry) this._traceRegistry = {};
        if (!this._traceRegistry[obj]) this._traceRegistry[obj] = []; // array of method names

        // observation can only be done by instances, so create an arbitrary instance to
        // observe with
        if (!this._observer) this._observer = isc.Class.create();
        var observer = this._observer;

        // If this object is already being traced, stop observation
        if (observer.isObserving(object, methodName) &&
            this._traceRegistry[obj].contains(methodName))
        {
            observer.ignore(object, methodName);
            this.logWarn("MethodTimer: Stopped logging stack traces for " + methodName +
                         " method on " + obj);
            // remove it from the registry
            this._traceRegistry[obj].remove(methodName);

        } else {
            var objName = object.ID ? object.ID : (object.Class ? object.Class : object),
                expression = "isc.Log.logWarn('" + objName + "." + methodName + "() - trace:' +";
            if (callOnly) {
                expression += "'\\n' + isc.Log.getCallTrace(arguments))";
            } else {
                expression += "isc.Log.getStackTrace())";
            }
            this.logWarn("expression is: " + expression);
            observer.observe(object, methodName, expression);
            this.logWarn("MethodTimer: Logging traces whenever " + methodName +
                         " method on " + obj + " is called");
            // add it to the registry
            this._traceRegistry[obj].add(methodName);
        }

    },

    traceCall : function (obj, methodName) {
        this.traceMethod(obj, methodName, true);
    },

    //>    @classMethod        Log.timeMethod()
    //
    //  Observe a method on an object, logging execution time whenever the method is called.
    //  <P>
    //  Call a second time with identical arguments to disable tracing.
    //
    //    @param    object        (object)    object to observe
    //    @param    methodName    (string)    name of the method to observe
    //
    //    @group    debug
    //    @visibility external
    //<
    // storeTotals: execution times of methods and totals for that method will be store in a
    //              central structure Log.classMethodTimes, like:
    //            {
    //                className: { // also "All"
    //                   totalTime:0, calls:0, minTime:0, maxTime:0, avgTime:0
    //                }
    //            }
    // dontLog: means that individual executions will not be logged (typically used with
    //          storeTotals:true when timing methods where logging itself would be significant)
    //
    // Typical use cases:
    // 1. profile a mixture of operations (eg lots of components drawing) to get a breakdown of
    //    time spent in particular methods
    //
    //    isc.Log.timeMethod(someClass, someMethod, true, true); // several times
    //    isc.Log.resetTotals();
    //    ... run test code ...
    //    isc.logWarn(isc.echoFull(isc.Log.classMethodTimes));
    //
    // 2. time a specific codepath to see the time breakdown (high resolution timer only)
    //
    //    isc.Log.timeMethod(someClass, someMethod, true, false); // several times
    //    isc.Log.deferTimerLogs = true;
    //    ... run test code ...
    //    isc.Log.logDeferred(); // alll deferred logs are dumped
    //
    _methodPrefix:"$T_",
    timeMethod : function (obj, methodName, storeTotals, dontLog, causeGC) {
        if (!obj || !methodName) return;

        // Bail if the arguments aren't valid
        var object = this.validObservation(obj, methodName);
        if (!object) return;

        // Keep a list of what objects / methods we're timing
        //      Note: format is {objName:[methodName1, methodName2]}
        if (!this._timeRegistry) this._timeRegistry = {};
        if (!this._timeRegistry[obj]) this._timeRegistry[obj] = []; // array of method names

        // already timing the method
        if (this._timeRegistry[obj].contains(methodName)) return;

        // Note - to time the method, we rename it, and replace it with a timer method (which will
        // return the same value
        var saveMethodName = isc.Log._methodPrefix + methodName,
            observedMethod = isc._obsPrefix + methodName, // Observation saves original method as _$method
            oldMethodName = (object[observedMethod] ? observedMethod : methodName)
        ;

        // If we're not timing the method:
        // If the method isn't being observed, we save the original method on the object as
        // (prefix + method) and replace it with a method that times and calls (prefix + method)
        //
        // If the method IS being observed, we do the same thing, except instead of saving and
        // replacing the current method, we save and replace (isc._obsPrefix + method), which is where the
        // original method's saved for observation.
        //
        // This way, we time only the original method, not the original method + its observer queue.
        //
        // This works even if we subsequently observe the method, because the method saved by the
        // observation mechanism (isc._obsPrefix + method) is left untouched if it already exists.

        object[saveMethodName] = object[oldMethodName];
        object[oldMethodName] = isc.Log.makeTimerFunction(
            methodName, object, storeTotals, dontLog, causeGC
        );
        this.logWarn("MethodTimer: Timing " + methodName + " method on " + obj);
        this._timeRegistry[obj].add(methodName);

    },

    stopTimingMethod : function (obj, methodName) {
        // Bail if the arguments aren't valid
        var object = this.validObservation(obj, methodName);
        if (!object) return;

        // If we're already timing the method, stop timing it.
        if (this._timeRegistry[obj].contains(methodName)) {
            var saveMethodName = isc.Log._methodPrefix + methodName,
                // Observation saves original method as _$method
                observedMethod = isc._obsPrefix + methodName,
                oldMethodName = (object[observedMethod] ? observedMethod : methodName)

            if (!object[saveMethodName]) {
                // This should never happen but we'll just clean up by deleting the registry entry
                this.logWarn("Not timing method '" + methodName + "' on object '"+ obj +"'.");
                this._timeRegistry[obj].remove(methodName);
                return;
            }

            // Stop timing the method:
            object[oldMethodName] = object[saveMethodName];
            delete object[saveMethodName];
            this.logWarn("MethodTimer: " + methodName + " method on " + obj +
                         " is no longer being timed");
            this._timeRegistry[obj].remove(methodName);
            return;
        }
    },

    // generate a function that calls the original message and logs timing data
    _currentlyTiming:{},
    makeTimerFunction : function (methodName, object, storeTotals, dontLog, causeGC) {

        var method = object[methodName],
            fullMethodName = isc.Func.getName(method, true);




        var timerFunc = function (a,b,c,d,e,f,g,h,i,j,k) {
            // you can use this to take the GC-based variability out of a method being timed
            if (causeGC) isc.Log._causeGC();
            var start = isc.timeStamp();


            var returnValue = method.call(this, a,b,c,d,e,f,g,h,i,j,k);
            var total = (isc.timeStamp()-start);



            if (!dontLog) isc.Log._logTimerResult(this, fullMethodName, total);
            return returnValue;
        }
        timerFunc._fullName = (object.ID || object.Class || "") + "_" + methodName + "Timing";
        timerFunc._isTimer = true;
        timerFunc._origMethodSlot = isc.Log._methodPrefix + methodName;
        return timerFunc;
    },

    // logTimerResult: log the result of timing a method
    _timerMessage : [
        "Timed ",
        , // methodName
        ": ",
        , // time
        "ms"
    ],
    _logTimerResult : function (object, methodName, callTime) {
        if (this.deferTimerLogs) return this._deferTimerLog(object, methodName, callTime);
        var template = isc.Log._timerMessage;

        // if "logWarn" exists, use it so the object identifies itself, otherwise,
        // toString() the object as part of the log message
        template[1] = (object.logWarn ? methodName :
                                        methodName + " on " + this.echoLeaf(object));
        template[3] = callTime.toFixed(3);

        var message = template.join(isc.emptyString);
        if (object.logMessage) object.logWarn(message);
        else isc.Log.logWarn(message);
    },





    // check whether method "method" on "obj" can be observed.  "obj" can be a string expression
    // that evaluates to an object
    validObservation : function (obj, method) {
        // Check that both fields are defined
        if (isc.isAn.emptyString(obj) || isc.isAn.emptyString(method)) return false;

        var object = obj;
        if (isc.isA.String(obj)) {
            // assume an expression (including a simple global ID)
            object = isc.Class.evaluate(obj);
            if (!object) {
                this.logWarn("MethodTimer: " + obj + " is not an object.");
                return false;
            }
        }

        // If the method was specifed with parentheses, remove them:
        if (method.indexOf("(") != -1) {
            method = method.slice(0, method.indexOf("("));
        }

        // If the object is a class, then we check whether there's a static method or an instance
        // method with the given name on the class.
        if (isc.isA.ClassObject(object)) {
            var theProto = object.getPrototype();
            // look for an instance method first and return the instance prototype if an
            // instance method was found
            if (isc.isA.Function(theProto[method])) return theProto;

            if (!object[method]) {
                this.logWarn("MethodTimer: " + method +
                             " could not be found as a static or instance property on " + obj);
                return false;
            }
        // not a class object, check that the method exists on it.
        } else if (!object[method]) {
            this.logWarn("MethodTimer: " + method + " is undefined or null on " + obj);
            return false;
        }

        // Check that the method is in fact a function, and not some other type of object
        if (!isc.Func.convertToMethod(object, method)) {
            this.logWarn("MethodTimer: " + method + " is not a method on " + obj);
            return false;
        }

        // Passed all the checks, return the object
        return object;
    },

    // Hiliting a Canvas -- XXX: move this to DebugTarget?
    // --------------------------------------------------------------------------------------------
    hiliteCanvas : function (name) {
        var canvas = name;
        if (isc.isA.String(name)) canvas = window[name];

        if (!isc.isA.Canvas(canvas)) {
            //>DEBUG
            this.logWarn("Unable to find specified canvas '" + name + "'."); //<DEBUG
            return;
        }

        this.showHiliteCanvas(canvas.getPageRect());
    },

    hiliteElement : function (name) {
        var element = name || this.elementToHilite;
        if (isc.isA.String(name)) element = isc.Element.get(name);
        if (element == null) {
            //>DEBUG
            this.logWarn("Unable to find specified element '" + name + "'."); //<DEBUG
            return;
        }

        this.showHiliteCanvas(isc.Element.getElementRect(element));
        this.elementToHilite = null;
    },

    showHiliteCanvas : function (rect) {

        // flash an outline around the canvas
        var hiliteCanvas = this._hiliteCanvas;
        if (!hiliteCanvas) {
            hiliteCanvas = this._hiliteCanvas = isc.Canvas.create({
                ID:"logHiliteCanvas",
                autoDraw:false,
                overflow:"hidden",
                hide : function () {
                    this.Super("hide", arguments);
                    this.resizeTo(1,1);
                    this.setTop(-20);
                },
                border1:"2px dotted red",
                border2:"2px dotted white"
            })
        }

        hiliteCanvas.setPageRect(rect);

        isc.Page.setEvent("click", hiliteCanvas.getID() + ".hide()");

        hiliteCanvas.setBorder(hiliteCanvas.border1);
        hiliteCanvas.bringToFront();
        hiliteCanvas.show();

        // Flash the border a few times
        this._flashHiliteCanvas()
    },

    hideHiliteCanvas : function () {
        if (this._hiliteCanvas) this._hiliteCanvas.hide();
    },

    flashHiliteCount: 7,
    flashHilitePeriod: 500,

    _flashHiliteCanvas : function () {
        // a function to set the hilite canvas to flash on a timer a few times
        var borders = [this._hiliteCanvas.border1,this._hiliteCanvas.border2];

        for (var i=0; i<this.flashHiliteCount; i++) {
            isc.Timer.setTimeout({
                    target:this._hiliteCanvas, methodName:"setBorder",
                    args:[borders[i%2]]
                }, (this.flashHilitePeriod*i)
            )
        }
    }

});


//    LogViewer -- simple log viewer -- use to display the log visually.
// ---------------------------------------------------------------------------------------
//    Automatically updates whenever the log is added to.

isc.ClassFactory.defineClass("LogViewer");
isc.LogViewer.addClassMethods({
    // the GlobalLogCookie stores Log window sizing info that's required to be at path / to
    // work.
    getGlobalLogCookie : function () {
        var globalLogCookie = isc.Cookie.get("GLog");
        if (!globalLogCookie) return null;

        try {
            var fn = isc._makeFunction("return " + globalLogCookie);
            return fn();
        } catch (e) {
            this.logWarn("bad log cookie: " + globalLogCookie + this.getStackTrace());
        }
    },
    // Function to easily get a cookie property value
    getGlobalLogCookieValue : function (property) {
        // dontSaveState property may have been set up on launch
        if (window.dontSaveState) return "";

        var globalLogCookie = this.getGlobalLogCookie();
        if (globalLogCookie != null && globalLogCookie[property] != null) return globalLogCookie[property];
        return "";
    },
    setGlobalLogCookieValue : function (property, value) {
        var globalLogCookie = this.getGlobalLogCookie();
        if (!globalLogCookie) globalLogCookie = {};
        globalLogCookie[property] = value;

        this.setGlobalLogCookie(globalLogCookie);
    },
    setGlobalLogCookie : function (globalLogCookie) {
        // the global log cookie is associated with "/" so it is sent to all pages
        var serializedGlobalLogCookie = isc.Comm.serialize(globalLogCookie);
        isc.Cookie.set('GLog', serializedGlobalLogCookie, "/", null, this.getCookieExpires());
    },



    getCookieExpires : function () {
        // Code to set up the log cookie
        var expires = new Date();
        expires.setFullYear(expires.getFullYear() + 20);
        return expires.toGMTString();
    },

    // The LogCookie is stored at /isomorphic/system/helpers so as not to pollute the / HTTP
    // header space.  This cookie contains everything except what the GlobalLogCookie has
    getLogCookie : function () {
        var logCookie = isc.Cookie.get("Log");
        if (!logCookie) return null;

        try {
            var fn = isc._makeFunction("return " + logCookie);
            return fn();
        } catch (e) {
            this.logWarn("bad log cookie: " + logCookie + this.getStackTrace());
        }
    },
    // Function to easily get a cookie property value
    getLogCookieValue : function (property) {
        // dontSaveState property may have been set up on launch
        if (window.dontSaveState) return "";

        var logCookie = this.getLogCookie();
        if (logCookie != null && logCookie[property] != null) return logCookie[property];
        return "";
    },
    setLogCookieValue : function (property, value) {
        var logCookie = this.getLogCookie();
        if (!logCookie) logCookie = {};
        logCookie[property] = value;

        this.setLogCookie(logCookie);
    },
    setLogCookie : function (logCookie) {
        // the global log cookie is associated with "/" so it is sent to all pages
        var serializedLogCookie = isc.Comm.serialize(logCookie);
        isc.Cookie.set('Log', serializedLogCookie, null, null, this.getCookieExpires());
    }
});

isc.LogViewer.addMethods({

    // the debugOn flag is toggled by the log window when remote debugging is enabled to
    // prevent the opener from updating the log window with local data when it is watching
    // a remote
    _debugOn: true,

    // whether the log window is loaded and ready to be accessed
    logWindowLoaded : function () {
        // We get bizarre errors in IE (typically: "trying to execute a freed script") if we
        // try to access elements of the logWindow page from the main frame if the log window
        // is being loaded, and replacing an existing log window.
        // This is probably due to window.open() returning a handle that is in an invalid state
        // until the new log window finished loading.
        // Therefore we wait for the log window to actually call back to the main frame and set
        // a flag telling us it has loaded.
        //
        return (this._logWindowLoaded && this._logWindow != null && !this._logWindow.closed );
    },

    // showInline - if true we show the full log console in an isc.Window rather than a separate
    // window. useful for tablets where multi-window is a pain but we actually have enough space
    // to basically work with a log window.

    showConsoleInline:isc.Browser.isTouch,

    showLog : function (loading, logWindow, dontSaveState, windowName, showInline) {
        if (!isc.debugTarget || isc.RemoteDebug.isEnabled) {
            var _this = this;
            isc.RemoteDebug.enableLocal(function () {
                _this.showLog(loading, logWindow, dontSaveState, windowName, showInline);
            });
            return;
        }

        if (showInline == null) showInline = this.showConsoleInline;
        // allow a log window to be passed in.  This allows the log window to reconnect to the
        // opener after the opener has been navigated to a new ISC page.
        if (logWindow) this._logWindow = logWindow;

        //alert("showLog called: loading: " + loading + ", logWindow: " + this._logWindow +
        //      ", form: " + (this._logWindow ? this._logWindow.resultsForm : null));
        //    if the _logWindow property is set up, it's a pointer to a log window we previously
        //  opened.  If we can get into its form, just replace the form contents which is much
        //  faster.
        if (this.logWindowLoaded()) {
            if (!this._logWindowInline) {
                this._logWindow.focus();
            }
            return;
        }

        // Assume that this is the only logViewer instance running - make sure it's available
        // as Log.logViewer
        if (!isc.Log.logViewer) isc.Log.logViewer = this;

        // if we have a log window, and it's not closed, we're done
        // (Note - if it is in the process of loading, we will rightly leave it alone)
        if (this._logWindow && !this._logWindow.closed) {

            return;
        }

        var rect = {},
            globalLogCookie = (dontSaveState ? null : isc.LogViewer.getGlobalLogCookie());

        if (globalLogCookie != null) {
            rect = globalLogCookie;
            // Disabled due to multiple-monitors: the log window position that's saved doesn't
            // work properly unless the log window is in the primary monitor. Also, negative
            // coordinates will mean that the window will be displayed at (0, 0) instead.
            /*
            // make sure the log window doesn't end up off the screen
            rect.left = rect.left > screen.availWidth ? 0 : rect.left;
            rect.top = rect.top > screen.availHeight ? 0 : rect.top;
            */
        } else {
            rect.left = 100;
            rect.top = 100;
            rect.width = 640;
            rect.height = 480;
        }

        if (showInline) {
            if (this.inlineWindow == null) {
                this.inlineWindow = isc.Window.create({
                    title:"Inline Developer Console",
                    src:isc.Page.getIsomorphicClientDir() + "helpers/Log.html",
                    animateMinimize:false,
                    // Size big enough to interact with and small enough to be able to grab
                    // the resize edges easily.
                    width:"50%",
                    height:Math.round(isc.Page.getHeight() * 0.8),//"80%",
                    headerControls:[
                        "headerIcon",
                        "headerLabel",
                        isc.Button.create({
                            width:16,
                            height:14,
                            title:"TL",
                            layoutAlign:"center",
                            click:function() {
                                isc.Log.logViewer.inlineWindow.moveTo(0,0);
                            }
                        }),
                        isc.Button.create({
                            width:16,
                            height:14,
                            title:"BL",
                            layoutAlign:"center",
                            click:function() {
                                isc.Log.logViewer.inlineWindow.moveTo(0,
                                    isc.Page.getHeight()-isc.Log.logViewer.inlineWindow.getHeight());
                            }
                        }),
                        isc.Button.create({
                            width:16,
                            height:14,
                            title:"TR",
                            layoutAlign:"center",
                            click:function() {
                                isc.Log.logViewer.inlineWindow.moveTo(
                                    isc.Page.getWidth()-isc.Log.logViewer.inlineWindow.getWidth(),
                                    0);
                            }
                        }),
                        isc.Button.create({
                            width:16,
                            height:14,
                            title:"BR",
                            layoutAlign:"center",
                            click:function() {
                                isc.Log.logViewer.inlineWindow.moveTo(
                                    isc.Page.getWidth()-isc.Log.logViewer.inlineWindow.getWidth(),
                                    isc.Page.getHeight()-isc.Log.logViewer.inlineWindow.getHeight());
                            }
                        }),
                        "minimizeButton",
                        "maximizeButton",
                        "closeButton"
                    ],
                    showMaximizeButton:true,
                    showMinimizeButton:true,
                    canDragReposition:true,
                    canDragResize:true
                });
            }

            if (!this.inlineWindow.isDrawn()) {
                this.inlineWindow.draw();
            }
            this._logWindowInline = true;

        } else {

            var windowSettings = "RESIZABLE,WIDTH=" + rect.width + ",HEIGHT=" + rect.height;

            if (globalLogCookie) {
                if (isc.Browser.isIE) {
                    windowSettings += ",left=" + rect.left + ",top=" + rect.top;
                } else {
                    windowSettings += ",screenX=" + rect.left + ",screenY=" + rect.top;
                }
                if (globalLogCookie.evals) this._currentEval = globalLogCookie.evals.length - 1;



            }


            //var subWindow = (window.opener && window.opener.isc);
            windowName = windowName || "_simpleLog";

            this._logWindow =
                window.open(isc.Page.getIsomorphicClientDir() + "helpers/Log.html",
                            windowName
                            // avoid log window name collisions between Devenv and released
                            // versions of ISC.  NOTE: we'd use the version number, but
                            // IE only is unhappy with a window name of eg "log5.5".
                            + (isc.version.contains("version") ? "Dev" : "")
                             , windowSettings);
        }

        this._initLogWindow(dontSaveState);
    },

    _logWindowInitAttempts:0,
    _logWindowPollInterval: 25,
    _initLogWindow : function (dontSaveState) {
        if (this._logWindow == null && this.inlineWindow != null) {
            var iFrame = this.inlineWindow.body._getURLHandle();
            if (iFrame) {
                this._logWindow = this.inlineWindow.body._getURLHandle().contentWindow;
            }
            // bail if we couldn't get the handle.

            if (this._logWindow == null) {
                return;
            }
        }

        if (this._logWindow == null) return;
        if (isc.Browser.isIE) {
            // if we've set document.domain, then attempting to immediately set a property on
            // the new window, before it can adjust its document.domain automatically, results
            // in an 'Access denied' error, so poll.
            try {
                this._logWindow._accessTest = true;
            } catch (e) {
                this.delayCall("_initLogWindow", [dontSaveState], this._logWindowPollInterval);
                return;
            }
        }

        // In IE, set up a pointer to this window in the newly opened log window
        // This is necessary as IE will not replace the 'window.opener' property to point
        // to this window, if the above call replaced the contents of an already open
        // log window.
        if (isc.Browser.isIE || this._logWindowInline) {
            this._logWindow.launchWindow = window;
            if (this._logWindowInline) {
                this._logWindow.showingInline = true;
            }
        }

        // If we don't want the log window to attempt to save / retrieve state from cookies
        // set a flag on it
        if (dontSaveState) this._logWindow.dontSaveState = true;


        // focus in the log window we just opened, to bring it in front of whatever other windows
        // might be occluding it (WinAmp et al).
        // Do this on an idle.  Otherwise some browsers will focus in the log window, then
        // as code continues to execute in the main window, focus back in the main window.
        // (Mac Moz is a specific example of this).
        //
        // Put the code to focus inside a conditional in case the window is dismissed before
        // page idle fires.

        var focusFunction = function () {
            if (isc.Log.logViewer) {
                var logWindow = isc.Log.logViewer._logWindow;
                if (logWindow && !logWindow.closed) logWindow.focus();
            }
        }

        // Note - if we're showing the log window on page load, avoid this
        isc.Page.setEvent("idle", focusFunction, isc.Page.FIRE_ONCE);

        // if the log window is already open, then reconnect.  Otherwise the log window will
        // fire initializePage() on its own onload.
        if (this._logWindow.initializePage) this._logWindow.initializePage();
    },

    // unlike addToMasterLog(), addToLog() simply updates the log window's results form
    // *without* putting the message into the message index.  This means the log would be lost
    // by log window reload, unlike normal logs.  Used by eval (above)
    // Standard logWarn() et al. use addToMasterLog() - observed by Log.html to keep the
    // results form up to date.
    addToLog : function (message, scrollToEnd) {
        if (isc.debugMaster && !this._tmpDisableLog) {
            // suppress logs caused by message send - e.g. something like a log serialization
            // causing an error which is then logged
            this._tmpDisableLog = true;
            isc.debugMaster.call("addToLog", [message, scrollToEnd]);
            delete this._tmpDisableLog;
        }
    },

    evaluate : function (expr, evalVars) {
        return isc.Log.evaluate(expr, evalVars);
    },

    clear : function () {
        if (isc.debugMaster) isc.debugMaster.call("clearLog");
    }



});

// Set up the preferences, log priorities etc. saved in a previous session
isc._globalLogCookie = isc.LogViewer.getGlobalLogCookie();
if (isc._globalLogCookie != null) {
    isc.Log.applyLogPriorities(isc._globalLogCookie.priorityDefaults)

    if (isc._globalLogCookie.defaultPriority != null)
        isc.Log.defaultPriority = isc._globalLogCookie.defaultPriority;
} else {
    // For the "Log" category, default to "info"
    isc.Log.setPriority("Log", isc.Log.INFO);
}

isc.showConsole = function (loading, logWindow, dontSaveState, windowName) {
    isc.showLog(loading, logWindow, dontSaveState, windowName);
}
// this basically only exists as a convenience for those with old javascript:showLog() bookmarks
isc.addGlobal("showLog", function (loading, logWindow, dontSaveState, windowName) {
    isc.Log.show(loading, logWindow, dontSaveState, windowName)
})

// Useful for touch browsers so you can see log window and page content in the same browser view.
isc.addGlobal("showConsoleInline", function () {
    isc.Log.show(null, null, null, null, true);
});

// indicate that the log has started
isc.Log.logInfo("initialized");

// allow storing log messages before Log class has loaded (advanced internal usage)
isc.Log._logPrelogs();

// capture a stack trace for every JS error.
//

isc.Log.supportsOnError = (
    isc.Browser.isIE  && (isc.Browser.version <= 9  || isc.Browser.version >= 11) ||
    isc.Browser.isMoz &&  isc.Browser.version >= 31
);

isc.Log.fallThroughToOnError = isc.Browser.isChrome && isc.Browser.version >= 34;

if ((isc.Log.supportsOnError || isc.Log.fallThroughToOnError) &&
    !(window.isc_installOnError == false))
{

    window.onerror = function (msg, file, lineNo, columnNo, error) {

        if (error != null) {
            // if an error object is present, use it to report
            isc.Log._reportJSError(error);
        } else {
            // arguments.caller is deprecated, equivalent of arguments.callee.caller.arguments
            // (See getStackTrace implementation for more on how we work with errors)
            //
            // Note:
            // - In FF 3.6+ while onerror fires, it appears we can't walk the stack -
            //   arguments.callee.caller is always null at this point.
            // - In IE9, we also can't walk the stack, though we can identify the function where
            //   the crash occurred (but not its arguments)
            //   - this is because arguments.callee.caller is there, but
            //     arguments.callee.caller.arguments is not, nor arguments.callee.caller.caller
            // Note in both cases the thread in onerror is actually running in some kind of
            // special security context: it's not just that you can't traverse through the
            // onerror function, even if you know the name of a function in the stack
            // beforehand, accessing func.caller on that function is null.
            var callerArgs = arguments.caller,
            caller;
            if (callerArgs == null && arguments.callee.caller != null) {
                caller = arguments.callee.caller;
                callerArgs = caller.arguments;
            }

            // one-time flag to avoid doubled reports for errors that are caught, go through
            // _reportJSError(), and are rethrown
            if (callerArgs && callerArgs._errorReported) {
                return;
            }

            var message = "Error:\r\t'" + msg + "'\r\tin " + file + "\r\tat line " + lineNo;

            // in IE9 called from window.onerror, this is the way the stacks end (not with a
            // bang but a whimper).  We can at least log the name of the function that crashed
            // and direct users to other browsers for better diagnostics.
            // Note we can't check Browser.isIE9 because that's enabled only when IE9 is not
            // running in a compatibility mode to emulate other browser's rendering.  This
            // JavaScript behavior is present in all modes.
            if (caller != null && callerArgs == null &&
                isc.Browser.isIE && isc.Browser.version >= 9)
            {


                message += "\r\n    crashed in:  " + isc.Func.getName(caller, true) + "()" +
                    "\r\n    Use any version of Internet Explorer other than IE9 for " +
                    "best diagnostics, otherwise Firefox or Chrome";
            } else if (callerArgs != null) {
                message += isc.Log.getStackTrace(callerArgs);
            }

            isc.Log.logWarn(message);
        }

        if (isc.Browser.isIE && isc.useIEDebugger) {
            if (confirm("Run debugger?" + "\r\r" + message)) {
                debugger;
            }
        }
    };
} else if (isc.Browser.autotest == isc.Browser.RUNNER) {

    window.onerror = function (msg, url, line) {
        if (isc.TestRunner) {
            isc.TestRunner.addUnassignedErrorDetails("Javascript Exception at " + url +
                                                     ", line " + line + ": " + msg);
        }
    };
}


isc.Log.rethrowErrors = isc.Browser.isChrome && isc.Browser.version >= 34;



// shared toString method for data model classes (ResultSet, ResultTree)
isc._dataModelToString = function () {
// Add in a check for a DataSource and if present, record the DS Name as part of the description
    var ds = this.getDataSource();
    if (ds && ds.ID) {
        return "[" + this.Class + " ID:" + this.ID +
          (this.componentId != null ? " (dataSource: " + ds.ID + ", created by: " + this.componentId + ")"
                                      : "(dataSource: " + ds.ID + ", created directly)") +
    "]";
    } else {
        return "[" + this.Class + " ID:" + this.ID +
          (this.componentId != null ? " (created by: " + this.componentId + ")"
                                      : "(created directly)") +
    "]";
    }
}

// shared logMessage method for data model classes (Resultset, ResultTree)
isc._dataModelLogMessage = function (priority, message, category, timestamp) {
    var log = isc.Log;
    if (!log) return;

    //>DEBUG

    // if no priority was passed in, use the default
    if (priority == null) priority = log.defaultPriority;

    // automatically add a stack trace for error logs
    if (priority <= log.stackTracePriority && this.getStackTrace != null) {
        // skip two levels of the stack to avoid showing the logMessage() invocation itself
        message += "\nStack trace:\n" + this.getStackTrace(arguments, 2);
    }

    // If a category was not specified, use the name of this class.
    if (!category) category = this.Class;

    // actually do the log.  NOTE: if we have an instance ID, pass it
    // Add in a check for a DataSource and if present, record the DS Name as part of the description
         var ds = this.getDataSource();
         if (ds && ds.ID) {
            log.log(priority, message, category, this.ID  + " (dataSource: " + ds.ID +
                    ", created by: " + this.componentId + ")", this, timestamp);
         } else {
            log.log(priority, message, category, this.ID  + " (created by: " +
                    this.componentId + ")", this, timestamp);
         }

    //<DEBUG
}







/////////////////////
//
//    Methods for sorting an array easily
//
/////////////////////


isc.addProperties(Array, {
    // note: documented as string values, internal constant is a boolean, code handles either
    //>    @type SortDirection
    ASCENDING:true,            //    @value    "ascending"        Sort in ascending order (eg: A-Z, larger items later in the list)
    DESCENDING:false        //    @value    "descending"    Sort in descending order (eg: Z-A, larger items earlier in the list)
    // @group sorting
    // @visibility external
    //<

});

isc.addMethods(Array, {

//>    @method        Array.shouldSortAscending()
//            Returns the passed in sortDirection (string / boolean) as the appropriate boolean
//        @group    sorting
//
//<
shouldSortAscending : function (sortDirection) {

    if (sortDirection == Array.ASCENDING) return true;
    if (sortDirection == Array.DESCENDING) return false;

    if (isc.isA.String(sortDirection)) {
        if (sortDirection.toLowerCase() == "ascending") return true;
        if (sortDirection.toLowerCase() == "descending") return false;
    }

    // Anything else is invalid  - just return null
    return null;
}

});


// add a bunch of methods to the Array prototype so all arrays can use them
isc.addMethods(Array.prototype, {




//>    @method        array.sortByProperty()
// @include list.sortByProperty()
//<
sortByProperty : function (property, direction, normalizer, context) {
    return this.sortByProperties({property:property, direction:direction,
                                  normalizer:normalizer, context:context});

},

//> @method array.setSort()
// Sort this Array by a list of +link{SortSpecifier}s.
// @param sortSpecifiers (Array of SortSpecifier) the list of +link{SortSpecifier}s to sort by
// @return (array) the array itself
// @visibility external
//<
setSort : function (sortSpecifiers) {
    var numSortSpecifiers = sortSpecifiers.length,
        properties = new Array(numSortSpecifiers),
        directions = new Array(numSortSpecifiers),
        normalizers = new Array(numSortSpecifiers),
        contexts = new Array(numSortSpecifiers),
        comparators = new Array(numSortSpecifiers);
    for (var i = 0; i < numSortSpecifiers; ++i) {
        var item = sortSpecifiers[i];
        properties[i] = item.sortByProperty ? item.sortByProperty : item.property;
        directions[i] = Array.shouldSortAscending(item.direction);
        normalizers[i] = item.normalizer;
        contexts[i] = item.context;
        comparators[i] = item._comparator;
    }
    return this.sortByProperties(properties, directions, normalizers, contexts, comparators);
},

//> @method array.sortByProperties()
// Given an array of objects, sort them by the properties of the member objects.
// Note that the sort will occur by the first property passed in, then for objects
// with matching values for the first property, the second property will be used (and so on).
// Can pass in an arbitary number of parameters.
// @param sortData (object) Each parameter is an object of the following format:<br>
// <code>{property:'propertyName', direction:direction, normalizer:normalizer}</code><br>
// Only the "property" attribute is required.  Pass in multiple arguments to sort by multiple
// properties.
// @return (array) the array itself
//<
// This method also supports being passed a 'context' parameter. If present, this is passed
// into the sort normalizer method as a parameter
// Example use case: ListGrids pass themselves into the 'sortByProperty' method as the context
// and are then available to the sort normalizer for the field.
// The context, if present, should be passed in as the 'context' attribute of each parameter
// object (so we can support 1 context per field name)
// In addition to the documented parameter format, sortByProperties will take 4 arrays - an
// array of property names, an array of sort directions, an array of normalizers and an array
// of 'context' objects.
// The normalizer / sortDirection / context for each property is then determined by
// the position in the array (so the last 3 arrays are optional and may be sparse)


sortByProperties : function () {
    // bail out if nothing to sort (see IDoc below)
    if (this.length == 0) return;


    if (isc.Browser.isIE && isc.Browser.version >= 11) {
        this._dummyIE = true;
        delete this._dummyIE;
    }

    // initialize per-array storage of normalized values for sorting when first call is made

    if (this._sortDirections == null) {
        this._sortDirections       = [];
        this._normalizedValues     = [];
        this._unexpectedTypeValues = [];
    }

    var normalizedArray = this._normalizedValues,
        wrongTypeArray  = this._unexpectedTypeValues;

    // Support being called with either the signature
    //  (["prop1", "prop2", ...], [dir1, dir2, ...], [norm1, norm2, ...])
    // or
    //  ({property:"prop1", direction:dir1, normalizer:norm1}, {property:"prop2", ...},...)

    var returnSortIndex = false,
        disallowSortingOnLoadingMarker = false;
    if (isc.isAn.Array(arguments[0])) {
        this.sortProps = arguments[0];
        this.sortDirections = arguments[1] || [];
        this.normalizers = arguments[2] || [];
        this.contexts = arguments[3] || [];
        this._comparators = arguments[4] || [];
        returnSortIndex = arguments[5] || false;
        disallowSortingOnLoadingMarker = arguments[6] || false;
    } else {

        // clear out any sortProps so we don't get additional (old) properties

        if (!this.sortProps) {
            this.sortProps = [];
            this.normalizers = [];
            this.sortDirections = [];
            this.contexts = [];
            this._comparators = [];
        } else {
            this.sortProps.clear();
            this.sortDirections.clear();
            this.normalizers.clear();
            this.contexts.clear();
            this._comparators.clear();
        }


        for (var i = 0, numArgs = arguments.length, extra = 0; i < numArgs; ++i) {
            var arg = arguments[i];
            if (!isc.isAn.Object(arg)) {
                if (extra == 0) {
                    returnSortIndex = arg || false;
                } else if (extra == 1) {
                    disallowSortingOnLoadingMarker = arg || false;
                }
                ++extra;
            } else {
                this.sortProps[i] = arg.property;

                this.sortDirections[i] = arg.direction;
                this.normalizers[i] = arg.normalizer;
                this.contexts[i] = arg.context;
                this._comparators[i] = arg._comparator;
                returnSortIndex = disallowSortingOnLoadingMarker = false;
                extra = 0;
            }
        }
    }

    // Bail out if we have empty sortProps

    if (this.sortProps == null || this.sortProps.length == 0) {
        return (returnSortIndex ? null : this);
    }

    // local refs
    var props = this.sortProps,
        norms = this.normalizers,
        contexts = this.contexts,
        undef;

    // Reset the lengths of the `this._normalizedValues' and `this._unexpectedTypeValues' arrays.
    normalizedArray.length = props.length;
    wrongTypeArray.length  = props.length;

    // Refuse to sort the array if the ResultSet's loading marker if found in it.
    var loadingMarker = (disallowSortingOnLoadingMarker && isc.ResultSet != null ?
            isc.ResultSet.getLoadingMarker() : undef);

    var compareAscending = Array.compareAscending,
        compareDescending = Array.compareDescending;

    var start = isc.timestamp();

    for (var i = 0; i < props.length; i++) {

        // remember the sort directions on the Array object -- retrieved in _compareNormalized
        var direction = this._sortDirections[i] = this.sortDirections[i];

        if (!isc.isA.Function(this._comparators[i])) {
            this._comparators[i] = (direction ? compareAscending : compareDescending);
        }

        var property = props[i],
            normalizer = norms[i],
            context = contexts[i],
            l = this.length;
        // Set up the array to store the normalized values for this prop in
        normalizedArray[i] = new Array(l);
        wrongTypeArray[i] = new Array(l);

        var dataType = null;
        var isValueMap = false;
        var isDataPath = false;

        if (isc.isA.Function(normalizer)) {

            for (var ii = 0; ii < l; ++ii) {
                var item = this[ii];
                if (item == null) {
                    // If any nulls were detected during the sort notify the developer
                    isc._containsNulls = true;
                    continue;
                } else if (item === loadingMarker) {
                    return (returnSortIndex ? null : this);
                }

                item._tempSortIndex = ii;
                var normalizedValue = normalizer(item, this.sortProps[i], context);
                normalizedArray[i][ii] = normalizedValue;

                // If we're sorting the field according to an explicit data type, store values
                // not of that type for separate comparison

                if (dataType != null && !Array._matchesType(item[this.sortProps[i]], dataType)) {
                    wrongTypeArray[i][ii] = item[this.sortProps[i]];
                }

                // a custom normalizer might produce NaN, which is a dangerous because, unlike
                // any other value, both "1 > NaN" and "1 < NaN" are false, which fools the
                // comparator into thinking everything is equal to NaN, so the sort order is
                // scrambled and changes each time, and the reason why isn't obvious to the
                // developer.  Hence normalize NaN to the maximum negative value, like our
                // built-in numeric normalizer does.
                if (isc.isA.SpecialNumber(normalizedValue) && isNaN(normalizedValue)) {
                    normalizedArray[i][ii] = 0-Number.MAX_VALUE;
                }
            }
            //isc.Log.logWarn("function normalizer: normalized values: " + normalizedArray[i] +
            //                ", unexpected types: " + wrongTypeArray[i]);
        } else {
            // if not passed an explicit normalizer, choose the appropriate function to normalize data
            // (see above)
            // catch the case where we were passed a data type rather than a normalizer function
            if (isc.isA.String(normalizer)) {
                dataType = normalizer;
            } else if (normalizer != null) {
                isValueMap = true;
            }

            if (context && context.getField) {
                var field = context.getField(property);

                if (field) {
                    if (field.dataPath) {
                        // Trim dataPath - required as field.dataPath may be absolute (so may include
                        // component.dataPath.
                        property = isc.Canvas._trimDataPath(field.dataPath, context);
                        isDataPath = true;
                    } else {
                        property = field.name;
                        isDataPath = false;
                    }
                    if (field.type && dataType == null) {
                        dataType = field.type;
                    }
                } else {
                    isDataPath = (property.indexOf("/") >= 0);
                }
            }

            if (dataType == null) {
                dataType = this._getSortDataType(props[i]);
            }

            var type = isc.SimpleType.getType(dataType);
            var baseType = isc.SimpleType.getBaseType(type);
            if (baseType == null) {
                baseType = dataType;
            }

            if (!isValueMap) {
                normalizer = Array._getNormalizerFromType(baseType);
            }

            // In the case where we were unable to determine a custom data-type normalizer for the field
            // fall back on the default object normalizer.
            if (normalizer == null) normalizer = Array._normalizeObj;

            // a non-null, non-dataType, non-function normalizer was passed, assume it's a
            // propertyValue -> normalizedValue map
            var normalizerMap = this.normalizers[i];
            for (var ii = 0; ii < l; ++ii) {
                var item = this[ii];

                if (item == null) {
                    isc._containsNulls = true;
                    continue;
                } else if (item === loadingMarker) {
                    return (returnSortIndex ? null : this);
                }
                item._tempSortIndex = ii;
                var atomicValue = Array._getAtomicValue(item, property, isDataPath, type);

                var normalizedValue = null;
                if (!isValueMap) {
                    normalizedValue = normalizer(atomicValue);
                } else {
                    var mappedVal = normalizer[atomicValue];
                    if (mappedVal == null) mappedVal = atomicValue;
                    normalizedValue = Array._normalizeStr(mappedVal);
                }
                normalizedArray[i][ii] = normalizedValue;

                // If we're sorting the field according to an explicit data type, store values
                // not of that type for separate comparison

                if (dataType != null && !Array._matchesType(atomicValue, baseType)) {
                    wrongTypeArray[i][ii] = item[this.sortProps[i]];
                }
            }
        }
    }   // END of the for loop



    if (isc.Browser.compensateForUnstableSort == null) {
        isc.Browser.compensateForUnstableSort =
                // Webkit covers Chrome, Safari, Android
                isc.Browser.isWebKit || isc.Browser.isOpera ||
                (isc.Browser.isIE && isc.Browser.version>=9);

    }
    if (isc.Browser.compensateForUnstableSort) {
        var numProps = normalizedArray.length;
        normalizedArray[numProps] = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
            normalizedArray[numProps][i] = i;
        }

        var wrongTypeArrayNumPos = wrongTypeArray.length;
        if (wrongTypeArrayNumPos != 0) {
            wrongTypeArray[wrongTypeArrayNumPos] = new Array(this.length);
            for (var i = 0; i < this.length; i++) {
                wrongTypeArray[wrongTypeArrayNumPos][i] = i;
            }
        }
        // sort ascending
        this._sortDirections[numProps] = true;
        this._comparators[numProps] = compareAscending;
    }

    //isc.logWarn("normalizing took: " + (isc.timestamp() - start) + "ms");



    // worth pre-computing for the common case that there are no values of unexpected type
    var hasUnexpectedTypeValues = false;
    for (var i = 0; i < this._unexpectedTypeValues.length; i++) {
        if (this._unexpectedTypeValues[i].length > 0) {
            hasUnexpectedTypeValues = true;
            break;
        }
    }

    this._hasUnexpectedTypeValues = hasUnexpectedTypeValues;

    //isc.logWarn("about to sort, hasUnexpectedTypeValues: " + this._hasUnexpectedTypeValues +
    //            ", normalizedValues: " + isc.echoFull(this._normalizedValues) +
    //            ", unexpectedTypes: " + isc.echoFull(this._unexpectedTypeValues) +
    //            " directions: " + this._sortDirections);


    var normalizedValues = this._normalizedValues,
        directions = this._sortDirections,
        unexpectedTypes = this._unexpectedTypeValues,
        comparators = this._comparators;

    // define comparator function for sorting by property - uses already stored out normalized
    // values and sort-directions
    var compareNormalized =
function (a,b) {

    // For null values we'll always compare 'null' regardless of the field property
    var aIndex = (a != null ? a._tempSortIndex : null),
        bIndex = (b != null ? b._tempSortIndex : null),
        undef;

    for (var i = 0; i < normalizedValues.length; i++) {

        var aFieldValue = normalizedValues[i][aIndex],
            bFieldValue = normalizedValues[i][bIndex];

        // if both values were not the expected type, compare them directly in un-normalized
        // form.  Note if only one value was unexpected type, by comparing normalized values we
        // will sort values of unexpected type to one end, since the standard normalizers all
        // normalize unexpected type values to the lowest values in the type's range.
        if (hasUnexpectedTypeValues && aFieldValue != null && bFieldValue != null) {
            var aWrongType = unexpectedTypes[i][aIndex],
                bWrongType = unexpectedTypes[i][bIndex];
            if (aWrongType !== undef && bWrongType !== undef) {
                aFieldValue = aWrongType;
                bFieldValue = bWrongType;
            }
        }

        var returnVal = comparators[i](aFieldValue, bFieldValue);

        //isc.Log.logWarn("compared: " + isc.Log.echo(aFieldValue) + " to " +
        //             isc.Log.echo(bFieldValue) + ", returning: " + returnVal);

        // If we have a non-equal result, return it, otherwise we'll check the next property
        // in array.sortProps
        if (returnVal != 0) return returnVal;
        else if (hasUnexpectedTypeValues) {

            if ((aWrongType !== undef) != (bWrongType !== undef)) {
                return (aWrongType !== undef) == !!directions[i] ? -1 : 1;
            }
        }
    }

    // at this point we've gone through every field in the sort, and these 2 items match in
    // each case -- just return 0 to indicate no order pref.

    return 0;
};

    var start = isc.timeStamp();

    // perform the actual sort
    this.sort(compareNormalized);

    //isc.logWarn("sorted in: " + (isc.timeStamp() - start) + "ms");

    // if we hit any nulls, warn the developer
    if (isc._containsNulls) {
        isc.Log.logWarn("Attempt to sort array by property hit null entry where a record should be. Array:" +
                        isc.Log.echo(this));
        isc._containsNulls = null;
    }

    // Clear out the index temporarily stored on each item, and empty the temp arrays of
    // sort values / directions

    var sortIndex = null;
    if (returnSortIndex) {
        sortIndex = this._extractProperty("_tempSortIndex");
    } else {
        this.clearProperty("_tempSortIndex");
    }
    normalizedArray.clear();
    wrongTypeArray.clear();
    this._sortDirections.clear();

    // call dataChanged in case anyone is observing it
    this.dataChanged();

    return (returnSortIndex ? sortIndex : this);
},


//>    @method        array.unsort()    (A)
//        Turn sorting off for this array, indicating that the current sort
//        order should be preserved.  Return true if this is supported in this List.
//
//        Some implementations may not support this -- they should return false
//        to indicate to the caller that sort order must be maintained (eg: in
//        the case where sort order is derived from the server, etc).
//
//        @group    sorting
//
//        @return    (boolean)    true == list supports unsorting, false == not supported.
// @visibility external
//<
unsort : function () {
    if (this.sortProps) this.sortProps.clear();
    return true;
},


// _getSortDataType() - given a field to sort this Array's member objects by, this method
// returns the data type to treat these field values as. Used to determine the appropriate
// normalizer function for the values.
// Note that a "normalizer" function renders a variable in a standardized format
// so we can sort by it easily.  For example, dates are converted into msec, etc.
_getSortDataType : function (sortProp, value) {
    var list = (value != null ? (isc.isAn.Array(value) ? value : [value]) : this);
    // determine the type WRT sorting based on the type of the first non null value
    for (var i = 0; i < list.length; i++) {

        if (!isc.isAn.Object(list[i])) continue;

        value = list[i][sortProp];

        // skip null entries
        if (value == null) continue;

        var type = Array._getType(value);
        if (type != null) return type;
    }
    return null;
},

// _getNormalizer() - method to give us a normalizer based on the data for the
// appropriate field within this Array's member objects.
_getNormalizer : function (sortProp, value) {

    var type = this._getSortDataType(sortProp, value);
    var normalizer = Array._getNormalizerFromType(type);
    return normalizer || Array._normalizeObj;
},


//>    @method        array.normalize()    (A)
//        @group    sorting
//             Normalize a property of an object based on the normalizer for this array
//            or the type of the property if that's this.normalizer is not set
//
//        @return    (any)    normalized value
//<
normalize : function (obj, property) {
    var isDataPath = (property.indexOf("/") >= 0);
    var type = null;
    var normalizer;
    if (isc.isA.String(this.normalizer)) {
        var dataType = this._getSortDataType(property);
        type = isc.SimpleType.getType(dataType);
        var baseType = isc.SimpleType.getBaseType(type);
        normalizer = this._getNormalizerFromType(baseType);
    } else {
        normalizer = this.normalizer;
    }
    var atomicValue = Array._getAtomicValue(obj, property, isDataPath, type);
    return normalizer[atomicValue];
}

}); // END isc.addMethods(Array.prototype)

// add static sort routines and variables to the Array object
isc.addProperties(Array,{
    _SORT_TEMP : "__sort_temp",        // name of the temporary variable to use as sort criteria
    _UNEXPECTED_TYPE : "__unexpected_type" // Used by sortByProperty when a value doesn't match
                                           // the field's expected data type
});

isc.addMethods(Array, {
//>    @method        array._normalize()
//        @group    sorting
//            Normalize one field into another for sorting
//    obj = object to normalize
//    property = property to normalize
//
//        @param    obj            (object)    object to normalize
//        @param    property    (string)    name of the property of object to normalize
//<
_normalizeObj : function (val) {
    return val;
},
_getAtomicValue : function (record, property, isDataPath, simpleType) {
    var value = null;
    if (isDataPath) {
        value = isc.Canvas._getFieldValue(property, null, record, null, true, "sort");
    } else {
        value = record[property];
    }
    if (simpleType &&  simpleType.getAtomicValue) {
        isc.Func.replaceWithMethod(simpleType, "getAtomicValue", "value");
        value = simpleType.getAtomicValue(value);
    }
    return value;
},
_normalizeStr : function (val) {

    return (isc.isA.String(val) ? val.toLowerCase() : isc.emptyString);
},
_normalizeNum : function (val) {
    // put non-numbers at the beginning of the sort
    return isc.isA.Number(val) ? val : (0 - Number.MAX_VALUE);
},

_normalizeBool : function (val) {
    if (val == true) return 1;
    if (val == false) return 0;
    if (val == null) return -1;
    return -2;
},

_normalizeDate : function (val) {

    var time = (val && isc.isA.Date(val) ? val.getTime() : new Date(val).getTime())
    // NOTE: "new Date([bad date])" creates a special invalidate date object for which
    // getTime() returns NaN in both Moz and IE.
    // Replace with zero to reliably sort at the top of ascending sort (or end of descending
    // sort).

    // NOTE: return the earliest valid date, not 0, which would be epoch time start (Jan 1
    // 1970), which would sort into the middle of some sets of dates.

    if (isNaN(time) || val == null) return -8640000000000000;
    return time;
},

_normalizeTime : function (val) {
    if (!isc.isA.Date(val) && val != null) val = isc.Time.parseInput(val);

    if (isc.isA.Date(val)) return val.getTime();
    return 0;
},

// Normalizer for sorting data of type string numerically
textToNumericNormalizer : function (val) {
    var value = parseInt(val, 10);
    if (isc.isA.Number(value)) return value;
    else return 0;
},

// Given a known data type - what is the appropriate sort-normalizer?


_$string:"string", _$text:"text", _$number:"number", _$integer:"integer", _$float:"float",

_$int:"int", _$boolean:"boolean", _$Date_ : "Date",  _$Time:"Time",
_$datetime : "datetime", _$Datetime:"Datetime",
_$date : "date", _$time:"time",

_getNormalizerFromType : function (type) {
    if (!type || !isc.isA.String(type)) return null;
    switch (type) {
        case this._$string:
        case this._$text:
                                return Array._normalizeStr;
        case this._$boolean:    return Array._normalizeBool;
        case this._$Date_:
        case this._$date:
        case this._$Datetime:
        case this._$datetime:
                                return Array._normalizeDate;
        case this._$Time:
        case this._$time:
                                return Array._normalizeTime;

        case this._$number:
        case this._$integer:
        case this._$int:
        case this._$float:
                                return Array._normalizeNum;
    }
    return Array._normalizeObj;
},

// _getType() - returns the "type" name of an object for sorting normalization purposes
_$object:"object",
_getType : function (object) {
    var type = typeof object;
    if (type == this._$object) {
        if (isc.isA.Date(object)) type = this._$date;
    }
    return type;
},

// _matchesType() - helper method used by sortByProperty to catch unexpected type values
// Note the 'type' specified for a field (like "float") may not match the value returned by
// this._getType(object) - so we have to detect equivalent types, (like float and number)
_standardTypeMap:{
    "float":"number",
    "int:":"number",
    "integer":"number",
    "text":"string",
    "Date":"date",
    "Time":"date",
    "time":"date"
},
_matchesType : function (object, type) {
    var objectType = this._getType(object);
    if (objectType == type) return true;

    return (this._standardTypeMap[type] == objectType);
},




//>    @classMethod        Array.compareAscending()    (A)
// Compare two values for an ascending order sort, using locale-sensitive comparison.
//        @group    sorting
//
// @param    a    (any)    first value to compare
// @param    b    (any)    second value to compare
//
// @return    (number)    negative == second is larger, 0 == same value, positive == first is larger
// @visibility external
//<
compareAscending : function (first, second) {
    if (first != null && first.localeCompare != null) {
        return first.localeCompare(second);
    }
    if (second != null && second.localeCompare != null) {
        return -second.localeCompare(first);
    }
    return (second > first ? -1 : second < first ? 1 : 0);
},

//>    @classMethod        Array.compareDescending()    (A)
// Compare two values for a descending order sort, using locale-sensitive comparison.
//        @group    sorting
//
// @param    first    (any)    first value to compare
// @param    second    (any)    second value to compare
//
// @return    (number)    negative == first is larger, 0 == same value, positive == second is larger
// @visibility external
//<
compareDescending : function (first, second) {
    if (first != null && first.localeCompare != null) {
        return -first.localeCompare(second);
    }
    if (second != null && second.localeCompare != null) {
        return second.localeCompare(first);
    }
    return (second < first ? -1 : second > first ? 1 : 0);
}

//>Safari3 Safari comparators for broken localeCompare
,
safariCompareAscending : function (first, second) {
    if (first != null && first.localeCompare != null) {
        return (first.localeCompare(second) - 2);
    }
    if (second != null && second.localeCompare != null) {
        return -(second.localeCompare(first) - 2);
    }
    return (second > first ? -1 : second < first ? 1 : 0);
},
safariCompareDescending : function (first, second) {
    if (first != null && first.localeCompare != null) {
        return -(first.localeCompare(second) - 2);
    }
    if (second != null && second.localeCompare != null) {
        return (second.localeCompare(first) - 2);
    }
    return (second < first ? -1 : second > first ? 1 : 0);
}
//<Safari3

});



//>Safari3
(function () {
    if (isc.Browser.isSafari) {
        var b = "b";
        if (b.localeCompare("a") == 3) {
            Array.compareAscending = Array.safariCompareAscending;
            Array.compareDescending = Array.safariCompareDescending;
        }
    }
})();
//<Safari3







//
//
//    Array object utilities -- not commonly used but sometimes useful stuff
//


isc.addMethods(Array.prototype, {

//>    @method        array.max() ([])
//
//             Returns the largest number in the array, skipping non-numeric values.
//
//            If the start and/or end are given, searches the specified subset of the list.
//
//      @visibility external
//        @group    arrayMath
//        @param    [start]        (number)    optional start index (default is 0)
//        @param    [end]        (number)    optional end index (default is list.length)
//
//        @return    (number)    maximum of all items in the list, or null if all values are non-numeric
//<
max : function (start, end) {
    if (start == null) start = 0;
    if (end == null) end = this.length;

    var max = null;

    for (var i = start; i < end; i++) {
        var value = this[i];
        if (isc.isA.Number(value)) {
            if (max == null) max = value;
            else max = Math.max(max, value);
        }
    }

    return max;
},

//>    @method        array.min() ([])
//
//             Returns the smallest number in the array, skipping non-numeric values.
//
//            If the start and/or end are given, searches the specified subset of the list.
//
//      @visibility external
//        @group    arrayMath
//        @param    [start]        (number)    optional start index (default is 0)
//        @param    [end]        (number)    optional end index (default is list.length)
//
//        @return    (number)    minimum of all items in the list, or null if all values are non-numeric
//<
min : function (start, end) {
    if (start == null) start = 0;
    if (end == null) end = this.length;

    var min = null;

    for (var i = start; i < end; i++) {
        var value = this[i];
        if (isc.isA.Number(value)) {
            if (min == null) min = value;
            else min = Math.min(min, value);
        }
    }

    return min;
},

//>    @method        array.sum() ([])
//             Returns the sum of the numbers in the array, skipping non-numeric values.
//
//            If the start and/or end are given, uses only the specified subset of the list.
//
//      @visibility external
//        @group    arrayMath
//        @param    [start]        (number)    optional start index (default is 0)
//        @param    [end]        (number)    optional end index (default is list.length)
//
//        @return    (number)    sum of all items in the list
//<
sum : function (start, end) {
    if (start == null) start = 0;
    if (end == null) end = this.length;

    var total = 0;

    for(var i = start; i < end; i++)
        if(isc.isA.Number(this[i])) total += this[i];
    return total;
},

//>    @method        array.and() ([])
// Returns true if all values between the start and end indices are true.
//
//      @visibility external
//        @group    arrayMath
//        @param    [start]        (number)    optional start index (default is 0)
//        @param    [end]        (number)    optional end index (default is list.length)
//
//        @return    (boolean)        all of the items in the array are true
//<
and : function (start, end) {
    if (start == null) start = 0;
    if (end == null) end = this.length;

    for(var i = start; i < end; i++)
        if (!this[i]) return false;
    return true;
},

//>    @method        array.or()  ([])
// Returns true if at least one value between the start and end indices is true.
//
//      @visibility external
//        @group    arrayMath
//        @param    [start]        (number)    optional start index (default is 0)
//        @param    [end]        (number)    optional end index (default is list.length)
//
//        @return    (boolean)        at least one of the items is true
//<
or : function (start, end) {
    if (start == null) start = 0;
    if (end == null) end = this.length;

    var total = 0;

    for(var i = start; i < end; i++)
        if (this[i]) return true;
    return false;
}

})    //END isc.addMethods(Array.prototype)







//>    @classMethod isc.getValueForKey()
// Given a key and an object of <code>key:value</code> pairs, return the value that corresponds to
// that key.
// <P>
// If the key is not found, <code>defaultValue</code> will be returned if provided, otherwise the
// key will be returned.
//
//    @param    key                (string or number)    key to look for
//    @param    valueMap        (object)            object of key:value pairs
//    @param    [defaultValue]    (any)                default value to return if key not found
//
//    @return                    (any)                returns value in valueMap under name key, or
//                                              defaultValue if key not found
// @visibility external
//<
isc.getValueForKey = function (key, valueMap, defaultValue) {

    if (valueMap && valueMap[key] != null && !isc.isAn.Array(valueMap)) return valueMap[key];
    return (arguments.length < 3 ? key : defaultValue);
}

//>    @classMethod isc.getKeyForValue()
// Given a value and an object of <code>key:value</code> pairs, return a key that corresponds
// to that value.
// <P>
// If the key is not found, <code>defaultKey</code> will be returned if provided, otherwise the
// value will be returned.
//
//    @param    value            (string or number)    value to look for
//    @param    valueMap        (object)            object of key:value pairs
//    @param    [defaultKey]    (any)                default key to return if value not found
//
//    @return                    (any)                returns first key in valueMap with value, or
//                                              defaultKey if value not found
// @visibility external
//<
isc.getKeyForValue = function (value, valueMap, defaultKey) {
// JMD: handle null value here?
    if (valueMap) {
        for (var key in valueMap) {
            if (valueMap[key] == value) return key;
        }
    }
    return (arguments.length < 3 ? value : defaultKey);
}


//>    @classMethod  isc.makeReverseMap()
// Given a key:value map, return a new map as value:key.
// <P>
// If the same value appears more than once, the key will correspond to the last instance of that
// value.
//
//    @param    valueMap        (object)            object of key:value pairs
//    @return                    (object)            reversed value map
// @visibility external
//<
isc.makeReverseMap = function (valueMap) {
    var newMap = {}, value;
    for (var key in valueMap) {
        value = valueMap[key];
        newMap[value] = key;
    }
    return newMap;
}

// returns a new value map, sorted by the key
// technically, maps can't be sorted, but in JS, objects "remember" the order in which key/value
// pairs were added
// XXX add support for normalizers
isc.sortByKey = function (valueMap) {
    var newMap = {},
        keys = isc.getKeys(valueMap).sort()
    ;
    for (var i = 0; i < keys.length; i++) {
        newMap[keys[i]] = valueMap[keys[i]];
    }
    return newMap;
}

// returns a new value map, sorted by the value
// technically, maps can't be sorted, but in JS, objects "remember" the order in which key/value
// pairs were added
// XXX add support for normalizers
isc.sortByValue = function (valueMap) {
    // make a reverse map of the input map; map is now: value -> key
    // call sortByKey on this reversed map
    // reverse the map again (so map is key -> value) and return it
    // XXX horribly inefficient
    return isc.makeReverseMap(isc.sortByKey(isc.makeReverseMap(valueMap)));
}




// A container that stores unique values.
// Note: This Set type does not have the same semantics as the proposed Set type of Harmony
// (ECMAScript 6). In particular, two Date objects are treated as the same if they represent
// the same time.
isc.defineClass("Set").addClassProperties({
    _nextUniqueSetNumber: 1,

    _dateCompareFn : function (t1, d2) {
        return (t1 - d2.getTime());
    }
});
isc.Set.addProperties({

//> @attr set.size (int : 0 : R)
// The current size of the set.
//<


    init : function () {
        this.Super("init", arguments);

        // The _withinSetProperty is a special property set on objects that are added to this
        // set.
        var uniqueSetNumber = this._uniqueSetNumber = isc.Set._nextUniqueSetNumber++;
        this._withinSetProperty = "_withinSetNumber" + uniqueSetNumber;

        // The times of any Date objects added to this set. The times are sorted for efficient
        // lookup via Array._binarySearch().
        this._dateValues = [];
        // An array of the objects contained in this set. This array is not accessed except in
        // remove() and clear() because if an object is contained in this set, then it will have
        // the _withinSetProperty set to true.
        // We keep a list of the objects so that if clear() is called with some objects still
        // contained in this set, we can delete the _withinSetProperty on those objects.
        this._objectValues = [];
        // A JavaScriptObject map from primitive values (stringified) to the actual primitive
        // value(s) that are contained in this set.
        this._primitiveValues = {};

        this.size = 0;
    },

    //> @method set.has()
    // Returns <code>true</code> if this set contains the given value.
    // @param value (any) the value to look for.
    // @return (boolean) <code>true</code> if this set contains <code>value</code>; <code>false</code>
    // otherwise.
    //<
    has : function (value) {
        if (isc.isA.Date(value)) {
            var i = isc.Array._binarySearch(this._dateValues, value, isc.Set._dateCompareFn);
            return i >= 0;

        } else if (isc.isAn.Object(value)) {
            return value[this._withinSetProperty];

        } else {
            var primitiveValues = this._primitiveValues[value],
                primitiveValue;
            if (isc.isAn.Array(primitiveValues)) {
                for (var i = 0, len = primitiveValues.length; i < len; ++i) {
                    primitiveValue = primitiveValues[i];
                    // Note: The check of the `typeof' is needed because `isNaN(" NaN")',
                    // `isNaN("NaN ")', `isNaN("NaNgarbage")', and `isNaN("+NaN")' are all
                    // true!
                    if (primitiveValue === value ||
                        (typeof primitiveValue === "number" && isNaN(primitiveValue) &&
                         typeof value === "number" && isNaN(value)))
                    {
                        return true;
                    }
                }
            } else {
                primitiveValue = primitiveValues;
                return (value in this._primitiveValues &&
                        (primitiveValue === value ||
                         (typeof primitiveValue === "number" && isNaN(primitiveValue) &&
                          typeof value === "number" && isNaN(value))));
            }
        }
        return false;
    },

    //> @method set.add()
    // Adds a value to this set.
    // @param value (any) the value to add.
    // @return (Set) this set.
    //<
    add : function (value) {
        if (isc.isA.Date(value)) {
            var i = isc.Array._binarySearch(this._dateValues, value, isc.Set._dateCompareFn);
            if (i >= 0) return this;

            // Store the time instead of the actual Date object because JS Dates are not immutable.
            this._dateValues.addAt(value.getTime(), -i - 1);

        } else if (isc.isAn.Object(value)) {
            // If the object is already within this set, return early.
            if (value[this._withinSetProperty]) return this;

            value[this._withinSetProperty] = true;
            this._objectValues.add(value);

        } else {
            var primitiveValues = this._primitiveValues[value],
                primitiveValue;
            if (isc.isAn.Array(primitiveValues)) {
                // Check for the primitive value already being in this set. If so, return early.
                for (var i = 0, len = primitiveValues.length; i < len; ++i) {
                    primitiveValue = primitiveValues[i];
                    if (primitiveValue === value ||
                        ((typeof primitiveValue === "number" && isNaN(primitiveValue)) &&
                         (typeof value === "number" && isNaN(value))))
                    {
                        return this;
                    }
                }

                // The primitive value is not already in this set.
                primitiveValues.add(value);
            } else if (value in this._primitiveValues) {
                // Check whether the primitive value is the same as the primitive value already
                // in this set. If so, return early.
                var primitiveValue = primitiveValues;
                if (value in this._primitiveValues &&
                    (primitiveValue === value ||
                     ((typeof primitiveValue === "number" && isNaN(primitiveValue)) &&
                      (typeof value === "number" && isNaN(value)))))
                {
                    return this;
                }
                this._primitiveValues[value] = [primitiveValue, value];
            } else {
                this._primitiveValues[value] = value;
            }
        }
        ++this.size;
        return this;
    },

    //> @method set.remove()
    // Removes a value from this set.
    // @param value (any) the value to remove.
    // @return (boolean) <code>true</code> if this set previously +link{Set.has(),contained}
    // <code>value</code>; <code>false</code> otherwise.
    //<
    remove : function (value) {
        if (isc.isA.Date(value)) {
            var i = isc.Array._binarySearch(this._dateValues, value, isc.Set._dateCompareFn);
            if (i >= 0) {
                this._dateValues.removeAt(i);
                --this.size;
                return true;
            }

        } else if (isc.isAn.Object(value)) {
            if (value[this._withinSetProperty]) {
                delete value[this._withinSetProperty];
                this._objectValues.remove(value);
                --this.size;
                return true;
            }

        } else if (value in this._primitiveValues) {
            var primitiveValues = this._primitiveValues[value],
                primitiveValue;
            if (isc.isAn.Array(primitiveValues)) {
                for (var i = 0, len = primitiveValues.length; i < len; ++i) {
                    primitiveValue = primitiveValues[i];
                    if (primitiveValue === value ||
                        ((typeof primitiveValue === "number" && isNaN(primitiveValue)) &&
                         (typeof value === "number" && isNaN(value))))
                    {
                        primitiveValues.removeAt(i);
                        --this.size;
                        return true;
                    }
                }
            } else {
                primitiveValue = primitiveValues;
                if (primitiveValue === value ||
                    ((typeof primitiveValue === "number" && isNaN(primitiveValue)) &&
                     (typeof value === "number" && isNaN(value))))
                {
                    delete this._primitiveValues[value];
                    --this.size;
                    return true;
                }
            }
        }
        return false;
    },

    //> @method set.clear()
    // Removes all values from this set.
    //<
    clear : function () {
        this._dateValues.setLength(0);

        var objectValues = this._objectValues,
            withinSetProperty = this._withinSetProperty;
        for (var i = 0, len = objectValues.length; i < len; ++i) {
            delete objectValues[i][withinSetProperty];
        }
        objectValues.setLength(0);

        this._primitiveValues = {};

        this.size = 0;
    }
});






//> @class Time
// Helper methods and system-wide defaults for dealing with time values and time display formats.
// <P>
// This class includes utility methods for the creation and display of logical time values, as well
// as modifying the default display timezone for datetime type values. See
// +link{group:dateFormatAndStorage} for more information on working with dates, times and datetimes
// in SmartClient.
//
// @treeLocation Client Reference/System
// @visibility external
//<
isc.ClassFactory.defineClass("Time");


isc.Time.addClassProperties({

    //> @classAttr  Time.UTCHoursOffset (number : null : IRA)
    // Hour offset from UTC to use when formatting +link{fieldType,"datetime"} type fields for
    // display to the user.
    // <P>
    // Has no effect on fields specified as logical date (<code>field.type = "date";</code>) and
    // logical time (<code>field.type = "time"</code>) fields.
    //
    // @visibility external
    // @deprecated As of 7.0 this attribute has been deprecated in favor of
    // +link{Time.setDefaultDisplayTimezone()}
    //<
    //UTCHoursOffset:0,
    // ** On page load we check for this property being set and use it to call
    //    setDefaultDisplayTimezone() with a deprecated warning


    //> @classMethod  Time.setDefaultDisplayTimezone()
    // Sets the offset from UTC to use when formatting values of type +link{FieldType,datetime}
    // with standard display formatters.
    // <p>
    // This property affects how dates are displayed and also the
    // assumed timezone for user-input. For a concrete example - assume this method has been called
    // and passed a value of "+01:00", and an application has a +link{DateTimeItem} visible in
    // a DynamicForm. If the value of this field is set to the current date, with UTC time set to
    // "10:00", the time portion of the value displayed in the form item will be "11:00".
    // Similarly if a user modifies the time value in the text box to be "16:00", a call to
    // +link{FormItem.getValue()} for the item will return a date object with UTC time set to 15:00.
    // <P>
    // Interaction with daylight savings time: The specified "defaultDisplayTimezone" should
    // reflect the correct UTC offset for the current date, for which it will always be exactly respected;
    // adjustment will only be made for dates that fall outside the current daylight savings time mode.
    // <P>
    // In other words if DST is currently not in effect (IE: the current date is a Winter date),
    // any other dates where DST is not in effect will be formatted to exactly respect the specified
    // defaultDisplayTimezone (so for defaultDisplayTimezone of "+01:00", the display
    // string will be 1 hour ahead of the UTC time on the date in question), and any
    // dates where DST is in effect would be further adjusted to account for DST
    // (so the display string would be 2 hours ahead for dates that fall in the Summer).<br>
    // Alternatively if DST currently is in effect (EG: Current date is a Summer date)
    // the situation is reversed. Any date value for which DST should be applied
    // will be be formatted for display with an offset of 1 hour from UTC - and any date value
    // for which DST should not be applied would be formatted with an offset of 0 hours from UTC.
    // <br>
    // Note that the +link{Time.adjustForDST} property may be set to <code>false</code> to
    // disable this logic - in this case the time portion of dates will always be offset from
    // UTC by exactly the specified defaultDisplayOffset, regardless of whether they fall in the
    // range where Daylight Savings Time would usually be applied or not.
    // <p>
    // Note that if a custom timezone is specified, it will not effect native javascript
    // date formatting functions such as <code>toLocaleString()</code>.
    // See +link{group:dateFormatAndStorage} for more on how SmartClient handles date and time
    // formatting and storage.
    // <P>
    // If this method is never called, the default display timezone for times and datetimes will
    // be derived from the native browser local timezone.
    // <P>
    // Note that the displayTimezone effects datetime fields only and has no effect on fields
    // specified as logical date (<code>field.type = "date";</code>) or
    // logical time (<code>field.type = "time"</code>).
    //
    // @param offset (string) offset from UTC. This should be a string in the format
    //    <code>+/-HH:MM</code> for example <code>"-08:00"</code>
    // @see group:dateFormatAndStorage
    // @visibility external
    //<
    setDefaultDisplayTimezone : function (offset, isBrowserDefault) {

        this._customTimezone = !isBrowserDefault;

        if (offset == null) return;
        // Handle being passed an offset in minutes - this matches the format returned by
        // native Date.getTimezoneOffset()
        var hours, minutes;
        if (isc.isA.Number(offset)) {

            offset = -offset;
            hours = Math.floor(offset/60);
            minutes = offset - (hours*60);
        } else if (isc.isA.String(offset)) {
            var HM = offset.split(":");
            hours = HM[0];
            // If the string starts with "-", hours and minutes will be negative
            var negative = hours && hours.startsWith("-");
            if (negative) hours = hours.substring(1);
            minutes = HM[1];

            hours = (negative ? -1 : 1) * parseInt(hours,10);
            minutes = (negative ? -1 : 1) * parseInt(minutes,10);
        }

        if (isc.isA.Number(hours) && isc.isA.Number(minutes)) {
            this.UTCHoursDisplayOffset = hours;
            this.UTCMinutesDisplayOffset = minutes;
        }

    },

    //> @classMethod Time.getDefaultDisplayTimezone()
    // Returns the default display timezone set up by +link{Time.setDefaultDisplayTimezone}.
    // If no explicit timezone has been set this will return the browser locale timezone offset.
    // @return (string) String of the format <code>+/-HH:MM</code>
    // @visibility external
    //<
    // we don't call this internally since it's easier to to work with the stored hours/minutes
    // directly
    getDefaultDisplayTimezone : function () {
        var H = this.UTCHoursDisplayOffset,
            M = this.UTCMinutesDisplayOffset,
            negative = H < 0;
        return (!negative ? "+" : "-") +
            ((negative ? -1 : 1) * H).stringify(2) + ":" + ((negative ? -1 : 1) * M).stringify(2);
    },

    //>    @classAttr    isc.Time._timeExpressions (Array : [..] : IRA)
    // List of regular expressions to parse a time string
    //        @group    parsing
    //<
    _timeExpressions : [
            /^\s*(\d?\d)\s*[: ]\s*(\d?\d)\s*[: ]\s*(\d?\d)?\s*([AaPp][Mm]?)?\s*([+-]\d{2}:\d{2}|Z)?\s*$/,
            /^\s*(\d?\d)\s*[: ]\s*(\d?\d)(\s*)([AaPp][Mm]?)?\s*([+-]\d{2}:\d{2}|Z)?\s*$/,
            /^\s*(\d\d)(\d\d)(\d\d)?\s*([AaPp][Mm]?)?\s*([+-]\d{2}:\d{2}|Z)?\s*$/,
            /^\s*(\d)(\d\d)(\d\d)?\s*([AaPp][Mm]?)?\s*([+-]\d{2}:\d{2}|Z)?\s*$/,
            /^\s*(\d\d?)(\s)?(\s*)([AaPp][Mm]?)?\s*([+-]\d{2}:\d{2}|Z)?\s*$/
        ],

    // This is a combination of the time patterns matched by regular expressions in `_timeExpressions'.
    // If this is changed, be sure to update Time._prepForParseValueExpressions() as well.
    _combinedTimeExpression: /(?:(\d?\d)\s*[: ]\s*(\d?\d)\s*[: ]\s*(\d?\d)?|(\d?\d)\s*[: ]\s*(\d?\d)(\s*)|(\d\d)(\d\d)(\d\d)|(\d)(\d\d)(\d\d)?|(\d\d?)(\s)?(\s*))\s*([AaPp][Mm])?/g,

    //> @type   TimeDisplayFormat
    // String designating a standard time format for displaying the times associated with
    // dates strings.
    // @value   toTime
    //  String will display with seconds and am/pm indicator:<code>[H]H:MM:SS am|pm</code>. <br>
    //  Example: <code>3:25:15 pm</code>
    // @value  to24HourTime
    //  String will display with seconds in 24 hour time: <code>[H]H:MM:SS</code>. <br>
    //  Example: <code>15:25:15</code>
    // @value  toPaddedTime
    //  String will display with seconds, with a 2 digit hour and am/pm indicator:
    //  <code>HH:MM:SS am|pm</code> <br>
    //  Example: <code>03:25:15 pm</code>
    // @value  toPadded24HourTime
    //  String will display with seconds, with a 2 digit hour in 24 hour format:
    //  <code>HH:MM:SS</code> <br>
    //  Examples: <code>15:25:15</code>, <code>03:16:45</code>
    // @value toShortTime
    //  String will have no seconds and be in 12 hour format:<code>[H]H:MM am|pm</code><br>
    //  Example: <code>3:25 pm</code>
    // @value toShort24HourTime
    //  String will have no seconds and be in 24 hour format: <code>[H]H:MM</code><br>
    //  Example:<code>15:25</code>
    // @value toShortPaddedTime
    //  String will have no seconds and will display a 2 digit hour, in 12 hour clock format:
    //  <code>HH:MM am|pm</code><br>
    //  Example: <code>03:25 pm</code>
    // @value toShortPadded24HourTime
    //  String will have no seconds and will display with a 2 digit hour in 24 hour clock format:
    // <code>HH:MM</code><br>
    // Examples: <code>15:25</code>, <code>03:16</code>
    //
    // @visibility external
    //<

    // To simplify parsing / formatting, map valid formatter names to the details of the format
    formatterMap:{
        toTime:{showSeconds:true, padded:false, show24:false},
        to24HourTime:{showSeconds:true, padded:false, show24:true},

        toPaddedTime:{showSeconds:true, padded:true, show24:false},
        toPadded24HourTime:{showSeconds:true, padded:true, show24:true},

        toShortTime:{showSeconds:false, padded:false, show24:false},
        toShort24HourTime:{showSeconds:false, padded:false, show24:true},
        toShortPaddedTime:{showSeconds:false, padded:true, show24:false},

        toShortPadded24HourTime:{showSeconds:false, padded:true, show24:true},
        toTimestamp:{showSeconds:true, padded:true, show24:true, showMillis:true}
    },


    //> @classAttr Time.displayFormat  (TimeDisplayFormat | function : "toTime" : RWA)
    // Standard formatter to be used when converting a date to a time-string via +link{Time.toTime()}
    // @setter Time.setNormalDisplayFormat()
    // @visibility external
    //<
    displayFormat:"toTime",

    //> @classAttr Time.shortDisplayFormat  (TimeDisplayFormat | function : "toShortTime" : RWA)
    // Standard formatter to be used when converting a date to a time-string via +link{Time.toShortTime()}
    // @setter Time.setShortDisplayFormat()
    // @visibility external
    //<
    shortDisplayFormat:"toShortTime",

    //> @classAttr Time.AMIndicator (string : " am" : RWA)
    // String appended to times to indicate am (when not using 24 hour format).
    // @visibility external
    // @group i18nMessages
    //<
    AMIndicator:" am",
    //> @classAttr Time.PMIndicator (string : " pm" : RWA)
    // String appended to times to indicate am (when not using 24 hour format).
    // @visibility external
    // @group i18nMessages
    //<
    PMIndicator:" pm"

    //> @classAttr Time.adjustForDST (boolean : true (see description) : RWA)
    // Determines whether datetime formatters should consider the effect of Daylight Saving
    // Time when computing offsets from UTC.  By default, this flag is set during framework
    // initialization if SmartClient detects that it is running in a locale that is observing
    // DST this year.  If you do not want DST adjustments to be applied, set this flag to
    // false.<p>
    // Note that setting this flag to true will have no effect unless you are in a locale
    // that is observing Daylight Saving Time for the date in question; this is because
    // we rely on the browser for offset information, and browsers are only capable of
    // returning local date and time information for the computer's current locale.
    // <P>
    // This setting will not have any impact on the display of fields specified as type "time" or
    // "date" (logical dates and logical times) - only on datetime type values. See
    // +link{group:dateFormatAndStorage} for information on working with dates, times and datetimes
    // in SmartClient.
    // @visibility external
    //<

});

isc.Time.addClassMethods({

    //> @classMethod Time.toTime()
    // Given a date object, return the time associated with the date as a formatted string.
    // If no formatter is passed, use the standard formatter set up via
    // +link{Time.setNormalDisplayFormat()}.
    //
    // @param date (Date) Date to convert to a time string.
    // @param [formatter] (TimeDisplayFormat | function) Optional custom formatter to use. Will accept
    //  a function (which will be passed a pointer to the date to perform the conversion), or
    //  a string designating a standard formatter
    // @param [logicalTime] Is the date passed in a representation of a logical time value such as
    //  a value from a <code>"time"</code> type field on a dataSource or a datetime value?
    //  For datetime values the formatted string will respect any custom
    // +link{Time.setDefaultDisplayTimezone,display timezone}.
    // If not explicitly specified, the date passed in will be assumed to be a datetime unless
    // it was created explicitly as a time via +link{Time.createLogicalTime()} or similar APIs.
    // @visibility external
    //<
    toTime : function (date, formatter, logicalTime) {
        return this.format(date, formatter, false, logicalTime);
    },

    //> @classMethod Time.toShortTime()
    // Given a date object, return the time associated with the date as a short string.
    // If no formatter is passed, use the standard formatter set up via +link{Time.setShortDisplayFormat()}
    // @param date (Date) Date to convert to a time string.
    // @param [formatter] (TimeDisplayFormat | function) Optional custom formatter to use. Will accept
    //  a function (which will be passed a pointer to the Date to format), or
    //  a string designating a standard formatter
    // @param [logicalTime] Is the date passed in a representation of a logical time value such as
    //  a value from a <code>"time"</code> type field on a dataSource or a datetime value?
    //  For datetime values the formatted string will respect any custom
    // +link{Time.setDefaultDisplayTimezone,display timezone}.
    // If not explicitly specified, the date passed in will be assumed to be a datetime unless
    // it was created explicitly as a time via +link{Time.createLogicalTime()} or similar APIs.

    // @visibility external
    //<
    toShortTime : function (date, formatter, logicalTime) {
        return this.format(date, formatter, true, logicalTime);
    },

    // Given a date return a formatted time string
    _$timeTemplate:[null, ":", null, ":"],
    _$shortTimeTemplate:[null, ":"],

    format : function (date, formatter, shortFormat, logicalTime) {
        // If we're passed a random object (most likely null or a string), just return it
        if (!isc.isA.Date(date)) return date;

        var originalFormatter = formatter;

        // Sanity check - don't allow unexpected things passed in as a formatter to give us
        // odd results
        if (!formatter && !isc.isA.String(formatter) && !isc.isA.Function(formatter)) {
            formatter = shortFormat ? this.shortDisplayFormat : this.displayFormat;
        }

        // Support passing in a completely arbitrary formatter function
        if (isc.isA.Function(formatter)) return formatter(date, logicalTime);

        if (isc.isA.String(formatter)) formatter = this.formatterMap[formatter];

        if (!isc.isAn.Object(formatter)) {
            this.logWarn("Invalid time formatter:" + originalFormatter + " - using 'toTime'");
            formatter = this.formatterMap.toTime;
        }

        var showSeconds = formatter.showSeconds,
            padded = formatter.padded,
            show24 = formatter.show24,
            showMillis = formatter.showMillis;

        var useCustomTimezone;

        if (logicalTime != null) useCustomTimezone = !logicalTime;
        else useCustomTimezone = !date.logicalTime && !date.logicalDate;

        var hour,minutes;
        if (!useCustomTimezone) {
            hour = date.getHours();
            minutes = date.getMinutes();
        } else {

            var hour = date.getUTCHours(),
                minutes = date.getUTCMinutes();

            // Add the display timezone offset to the hours / minutes so we display the
            // time in the appropriate timezone
            var hm = this._applyTimezoneOffset(hour, minutes,
                                                this.getUTCHoursDisplayOffset(date),
                                                this.getUTCMinutesDisplayOffset(date));
            hour = hm[0];
            minutes = hm[1];
        }


        var seconds = showSeconds ? date.getUTCSeconds() : null,
            pm = show24 ? null : (hour >=12);

        // Hour will be in 24 hour format by default
        if (!show24) {
            if (hour > 12) hour = hour - 12;
            if (hour == 0) hour = 12;
        }
        if (padded) hour = hour.stringify(2);

        var template = showSeconds ? this._$timeTemplate : this._$shortTimeTemplate;
        template[0] = hour;
        template[2] = minutes.stringify();
        if (showSeconds) template[4] = seconds.stringify();

        if (!show24) template[5] = (pm ? this.PMIndicator : this.AMIndicator);
        else template[5] = null;

        var formatted = template.join(isc.emptyString);

        if (showMillis) {
            var millis = date.getMilliseconds().stringify(3);
            formatted += "." + millis;
        }

        return formatted;
    },

    //> @classMethod Time.parseInput()
    // Converts a time-string such as <code>1:00pm</code> to a new Date object
    // representing a logical time value (rather than a specific datetime
    // value), typically for display in a +link{DataSourceField.type,time type field}.
    // Accepts most formats of time string. The generated
    // Date value will have year, month and date set to the epoch date (Jan 1 1970), and time
    // elements set to the supplied hour, minute and second (in browser native local time).
    // <P>
    // See +link{group:dateFormatAndStorage} for more information on date, time and datetime
    // values in SmartClient.
    //
    // @param timeString (string) time string to convert to a date
    // @param validTime (boolean) If this method is passed a timeString in an unrecognized format,
    //  return null rather than a date object with time set to 00:00:00
    // @visibility external
    //<
    // UTCTime param deprecated - leaving supported (though now undocumented) for backCompat only.
    //
    // Additional 'isDatetime' and 'baseDatetime' parameters: These are used for the case where we
    // need to set the time portion of a datetime based on a user-entered time string.
    // In this case we need to respect the local timezone specified by
    // +link{time.setDefaultDisplayTimezone}, and we'll also support respecting an explicit
    // timezone offset from UTC being present in the string (EG: <code>"00:00:00+02:00"</code>).
    //
    // Assuming we're not passed a 'baseDatetime', the returned date is always set to 1/1/1970.
    // This is deliberate: It'll make DST never
    // an issue and it matches the format for Time values returned by the server for JSON format
    // DataSources.
    //
    // EXTREMELY forgiving of formatting, can accept the following:
    //        11:34:45 AM    => 11:34:45
    //      11:34:45    => 11:34:45
    //        1:3:5 AM    => 01:30:50
    //        1:3p        => 13:30:00
    //        11 34 am    => 11:34:00
    //        11-34        => 11:34:00
    //        113445        => 11:34:45
    //        13445        => 01:34:45
    //        1134        => 11:34:00
    //        134            => 01:34:00
    //        11            => 11:00:00
    //        1p            => 13:00:00
    //        9            => 09:00:00
    // Also supports explicitly specified timezone offset specified by "+/-HH:MM" at the end, though
    // we only care about this for the datetime case. logical times are literally a way for us
    // to work with numbers for H, M and S.

    // Note: technically being passed "1:00" is ambiguous - could be AM or PM.
    // We always interpret as 24 hour clock (so <12 = AM) unless am/pm is  passed in.
    parseInput : function (string, validTime, UTCTime, isDatetime, baseDatetime) {
        var hours = null,
            minutes = null,
            seconds = null,
            // We don't currently extract milliseconds from a time-string. Instead we zero them
            // out for consistency across times created by this method.
            milliseconds = null,
            ampm;

        var hoursOffset, minutesOffset;

        // if we're passed a date we'll return a new date with the same time (h/m/s/ms, not the same
        // date).
        if (isc.isA.Date(string)) {
            // We'll match the specified time exactly - no need to manipulate timezone offsets
            // here since the underlying UTC time will match and any offsetting for display
            // will occur in formatters.
            UTCTime = true;
            hours = string.getUTCHours();
            minutes = string.getUTCMinutes();
            seconds = string.getUTCSeconds();
            milliseconds = string.getUTCMilliseconds();

        } else if (string != null) {
            // iterate through the time expressions, trying to find a match
            for (var i = 0; i < isc.Time._timeExpressions.length; i++) {

                var match = isc.Time._timeExpressions[i].exec(string);
                if (match) break;
            }
            if (match) {
                // get the hours, minutes and seconds from the match
                // NOTE: this results in 24:00 going to 23:00 rather than 23:59...
                var defaultHours,
                    defaultMinutes,
                    defaultSeconds;
                if (baseDatetime != null) {
                    defaultSeconds = defaultMinutes = defaultHours = null;
                } else {
                    defaultSeconds = defaultMinutes = defaultHours = 0;
                }
                hours = match[1] ? Math.min(parseInt(match[1], 10), 23) : defaultHours;
                minutes = match[2] ? Math.min(parseInt(match[2], 10), 59) : defaultMinutes;
                seconds = match[3] ? Math.min(parseInt(match[3], 10), 59) : defaultSeconds;
                ampm = match[4];

                if (ampm) {
                    if (!this._pmStrings) this._pmStrings = {p:true, P:true, pm:true, PM:true, Pm:true, pM:true};
                    if (this._pmStrings[ampm] == true) {
                        if (hours == null) hours = 12;
                        else if (hours < 12) hours += 12;
                    } else if (hours == 12) hours = 0;
                }

                // For dateTimes only, if a timezone was explicitly specified on the value passed in,
                // respect it.
                // So we'll handle 18:00:01 -01:00 as 6pm one hour offset from UTC on the generated
                // date value.
                // NOTE: the offset specifies the timezone the date is already in, so
                // to get to UTC we have to subtract the offset

                if (isDatetime && match[5] != null && match[5] != "" && match[5].toLowerCase() != "z") {
                    var HM = match[5].split(":"),
                        H = HM[0],
                        negative = H && H.startsWith("-"),
                        M = HM[1];
                    hoursOffset = parseInt(H,10);
                    minutesOffset = (negative ? -1 : 1) * parseInt(M,10);
                }
            } else if (validTime) return null;
        } else if (validTime) return null;

        var date;
        if (baseDatetime != null) {
            date = baseDatetime.duplicate();
        } else {
            date = new Date(null);
            // Zero out the milliseconds for consistency.
            date.setMilliseconds(0);
        }
        if (isDatetime || UTCTime) {

            if (hoursOffset == null) {
                hoursOffset = UTCTime ? 0 : this.getUTCHoursDisplayOffset(date);
            }
            if (minutesOffset == null) {
                minutesOffset = UTCTime ? 0 : this.getUTCMinutesDisplayOffset(date);
            }

            // NOTE: we're creating UTC time -- any offset indicates the offset for the timezone
            // the inputted time is currently in [either browser local time or explicit offset
            // passed in as part of the time string], so we need to subtract this offset to get to
            // UTC time (not add it)
            var hm = this._applyTimezoneOffset(hours, minutes, (0-hoursOffset), (0-minutesOffset));

            hours = hm[0];
            minutes = hm[1];

            date.setUTCHours(hours == null ? date.getUTCHours() : hours,
                             minutes == null ? date.getUTCMinutes() : minutes,
                             seconds == null ? date.getUTCSeconds() : seconds,
                             milliseconds == null ? date.getUTCMilliseconds() : milliseconds);
        } else {
            date.setHours(hours == null ? date.getHours() : hours,
                          minutes == null ? date.getMinutes() : minutes,
                          seconds == null ? date.getSeconds() : seconds,
                          milliseconds == null ? date.getMilliseconds() : milliseconds);
        }

        // Mark as logical time so we format / serialize correctly without requiring
        // explicit "logicalTime" param to formatter functions
        if (!isDatetime) date.logicalTime = true;

        return date;
    },

    // Preps a string value for parsing by FormItem.parseValueExpressions().
    // It is assumed that value contains a time value expression. The result of calling this
    // function is a new time value expression that can be better parsed by FormItem.parseValueExpressions().
    // For example, without the use of this function, FormItem.parseValueExpressions() will fail
    // on "< 6 am" because of the space between "6" and "am".
    _prepForParseValueExpressions : function (value) {
        if (value == null) return null;
        value = String(value);

        value = value.replace(this._combinedTimeExpression, function (match, p1, p2, p3,
                                                                             p4, p5, p6,
                                                                             p7, p8, p9,
                                                                             p10, p11, p12,
                                                                             p13, p14, p15,
                                                                             p16) {
            p1 = parseInt(p1 || p4 || p7|| p10 || p13) || 0;
            p2 = parseInt(p2 || p5 || p8|| p11 || p14) || 0;
            p3 = (p3 || p6 || p9|| p12 || p15);
            if (p3) {
                p3 = ":" + (parseInt(p3) || 0).stringify(2);
            } else p3 = "";
            p16 = (p16 || "").trim();
            var value = p1 + ":" + p2.stringify(2) + p3;
            if (p16) {
                value += p16;
            }
            return value + " ";
        });
        return value;
    },

    // Helper method to apply an arbitrary timezone offset to hours / minutes
    // Returns array: [newHours,newMinutes,dayOffset]
    // dayOffset ignored for time fields, but can be used to update datetimes
    _applyTimezoneOffset : function (hours, minutes, hOffset, mOffset) {
        if (minutes == null || hours == null) {
            this.logWarn("applyTimezoneOffset passed null hours/minutes");
            return [hours,minutes];
        }
        if (hOffset == null) hOffset = 0;
        if (mOffset == null) hOffset = 0;
        if (hOffset == 0 && mOffset == 0) return [hours,minutes,0];

        hours += hOffset;
        minutes += mOffset;

        // Catch the case where the display offset from UTC pushes the hours / minutes
        // past 60 [or 24] or below zero
        // (Don't worry about the date - we're only interested in the time!)
        while (minutes >= 60) {
            minutes -= 60;
            hours += 1;
        }

        while (minutes < 0) {
            minutes += 60;
            hours -= 1;
        }

        var dayOffset = 0;

        while (hours >= 24) {
            hours -= 24;
            dayOffset += 1;
        }
        while (hours < 0) {
            hours += 24;
            dayOffset -= 1;
        }

        return [hours,minutes, dayOffset];
    },


    //> @classMethod Time.createDate()
    // Creates a date object with the time set to the hours, minutes and seconds passed in.
    // Unless the <code>UTCTime</code> parameter is passed in, parameters are assumed
    // to specify the time in native local display time.
    // @param [hours] (number) Hours for the date (defaults to zero)
    // @param [minutes] (number) Minutes for the date (defaults to zero)
    // @param [seconds] (number) Seconds for the date (defaults to zero)
    // @param [milliseconds] (number) Milliseconds for the date (defaults to zero)
    // @param [UTCTime] (boolean) If true, treat the time passed in as UTC time rather than local time
    // @visibility external
    // @deprecated use +link{Time.createLogicalTime()} instead.
    //<
    createDate : function (hours, minutes, seconds, milliseconds, UTCTime) {
        return this.createLogicalTime(hours, minutes, seconds, milliseconds, UTCTime);
    },

    //> @classMethod Time.createLogicalTime()
    // Create a new Date object to represent a logical time value (rather than a specific datetime
    // value), typically for display in a +link{DataSourceField.type,time type field}. The generated
    // Date value will have year, month and date set to the epoch date (Jan 1 1970), and time
    // elements set to the supplied hour, minute and second (in browser native local time).
    // <P>
    // See +link{group:dateFormatAndStorage} for more information on date, time and datetime
    // values in SmartClient.
    //
    // @param hour (integer) hour (0-23)
    // @param minute (integer) minute (0-59)
    // @param second (integer) second (0-59)
    // @return (Date) new Javascript Date object representing the time in question
    // @visibility external
    //<
    // This is also available as Date.createLogicalTime [and the deprecated Time.createDate]
    // The returned date is always set to 1/1/1970. This is deliberate: It'll make DST never
    // an issue and it matches the format for Time values returned by the server for JSON format
    // DataSources.
    createLogicalTime : function (hours, minutes, seconds, milliseconds, UTCTime) {

        var date = new Date(null);

        if (hours == null) hours = 0;
        if (minutes == null) minutes = 0;
        if (seconds == null) seconds = 0;
        if (milliseconds == null) milliseconds = 0;

        if (UTCTime) {
            date.setUTCHours(hours, minutes, seconds, milliseconds);
        } else {
            date.setHours(hours, minutes, seconds, milliseconds);
        }
        date.logicalTime = true;
        return date;
    },

    //> @classMethod Time.setShortDisplayFormat()
    // Sets the default format for strings returned by +link{Time.toShortTime()}.
    // @param formatter (TimeDisplayFormat | function) Optional custom formatter to use. Will accept
    //  a function (which will be passed a pointer to the date to perform the conversion), or
    //  a string designating a standard formatter
    // @visibility external
    //<
    setShortDisplayFormat : function (format) {
        this.shortDisplayFormat = format;
    },

    //> @classMethod Time.setNormalDisplayFormat()
    // Sets the default format for strings returned by +link{Time.toTime()}.
    // @param formatter (TimeDisplayFormat | function) Optional custom formatter to use. Will accept
    //  a function (which will be passed a pointer to the date to perform the conversion), or
    //  a string designating a standard formatter
    // @visibility external
    //<
    setNormalDisplayFormat : function (format) {
        this.displayFormat = format;
    },

    //> @classMethod Time.compareTimes()
    // Compares the times of 2 dates, or strings. If a string is passed as one of the
    // parameters it should be in a format that converts to a valid time such as <code>"1:30pm"</code>,
    // <code>"13:30"</code>, or <code>"1:30:45pm"</code>
    // @param time1 (Date|string) First time to compare
    // @param time2 (Date|string) Second time to compare
    // @return (boolean) True if the times match, false if not
    // @visibility external
    //<
    compareTimes : function (time1, time2) {
        // If this method becomes time-critical we could speed this up by avoiding the
        // date conversion and having parseInput return just an array of H,M,S
        if (isc.isA.String(time1)) time1 = isc.Time.parseInput(time1);
        if (isc.isA.String(time2)) time2 = isc.Time.parseInput(time2);

        if (time1 == null && time2 == null) return true;

        // If we get non-dates at this point just return false - we don't want to be
        // comparing other types
        if (!isc.isA.Date(time1) || !isc.isA.Date(time2)) return false;


        return ((time1.getUTCHours() == time2.getUTCHours()) &&
                (time1.getUTCMinutes() == time2.getUTCMinutes()) &&
                (time1.getUTCSeconds() == time2.getUTCSeconds()));

    },

    //> @classMethod Time.compareLogicalTimes()
    // Compare two times, normalizing out the date elements so that only the time elements are
    // considered; returns 0 if equal, -1 if the first time is greater (later), or 1 if
    // the second time is greater.
    //  @param  time1   (Date)  first time to compare
    //  @param  time2   (Date)  second time to compare
    //  @return (number)    0 if equal, -1 if first time &gt; second time, 1 if second time &gt;
    //                      first time.  Returns false if either argument is not a date
    //<
    compareLogicalTimes : function (time1, time2) {
        if (!isc.isA.Date(time1) || !isc.isA.Date(time2)) return false;

        time1 = isc.Date.getLogicalTimeOnly(time1);
        time2 = isc.Date.getLogicalTimeOnly(time2);

        var aHours = time1.getHours(),
            aMinutes = time1.getMinutes(),
            aSeconds = time1.getSeconds(),
            aMillis = time1.getMilliseconds();
        var bHours = time2.getHours(),
            bMinutes = time2.getMinutes(),
            bSeconds = time2.getSeconds(),
            bMillis = time2.getMilliseconds();
        var aval = aMillis + 1000 * (aSeconds + 60 * (aMinutes + 60 * aHours));
        var bval = bMillis + 1000 * (bSeconds + 60 * (bMinutes + 60 * bHours));
        return aval > bval ? -1 : (bval > aval ? 1 : 0);
    },

    _performDstInit : function () {
        var now = new Date(),
            january = new Date(0),
            july = new Date(0);

        // Daylight Saving Time involves moving the clock forward in order to shift some of
        // the daylight from very early morning (when most people are asleep) to mid-evening
        // (when people benefit from more hours of daylight, and energy can be saved that
        // would otherwise be needed for lighting).  Not every country observes DST, and those
        // countries that do observe it set their own start and end dates, though there are
        // common approaches - for example, many European countries start DST during the last
        // weekend of March and end it during the last weekend of October.
        //
        // Daylight Saving Time, if it is applicable at all, always starts sometime in spring
        // and ends sometime in autumn, but there is no more accurate rule than that.
        // Currently, every country that observes DST does so by moving their local time
        // forward by one hour; however, other values have been used, so this cannot be relied
        // upon either.
        //
        // It is common to transition to and from DST at 02:00 local time - when
        // DST starts, the local time jumps instantly to 03:00, when DST ends it jumps
        // instantly back to 01:00.  However, this is again a common approach rather than a
        // rule.
        //
        // Note that it is important to think in terms of seasons rather than months, because
        // the northern and southern hemispheres have opposite seasons.  Hence DST (if it
        // applies at all) starts in March/April and ends in October/November in the northern
        // hemisphere, and does the exact opposite in the southern hemisphere.
        //
        // Because of all of this, and because the only timezone information you can retrieve
        // from a Javascript Date object is the number of minutes that particular date/time
        // is offset from UTC, we have quite limited information and must resort to roundabout
        // techniques.  We can discover if we are in a locale that observes DST by checking
        // the UTC offsets in January and July; if they are different, the current locale
        // observes DST.
        //
        // Going a step further than this, we can tell whether we are observing DST or normal
        // time on an arbitrary date: by looking to see whether the clock goes  forward or
        // backward in the early part of the year (spring in the northern hemisphere), we can
        // infer which hemisphere the current locale is in, and from that we can decide if
        // the offset in January is the DST or non-DST offset.  Then, we can check the offset
        // of the given date against the offset in January; if it matches then it is in DST
        // if we're in the southern hemisphere, and in normal time if we're in the northern
        // hemisphere.
        //
        // For more interesting information on this subject, see
        // http://www.timeanddate.com/time/aboutdst.html

        january.setUTCFullYear(now.getUTCFullYear());
        january.setUTCMonth(0);
        january.setUTCDate(1);
        july.setUTCFullYear(now.getUTCFullYear());
        july.setUTCMonth(6);
        july.setUTCDate(1);

        var nowOffset = now.getTimezoneOffset();
        this.januaryDstOffset = january.getTimezoneOffset();
        var julyOffset = july.getTimezoneOffset();

        this.dstDeltaMinutes = this.januaryDstOffset - julyOffset;
        if (this.dstDeltaMinutes > 0) {
            // Time is offset further forward from UTC in July; this locale observes DST
            // and is in the northern hemisphere (this logic is curiously backwards, because
            // getTimezoneOffset() returns negative numbers for positive offsets)
            this.southernHemisphere = false;
            this.adjustForDST = true;
            if (nowOffset == julyOffset) this.currentlyInDST = true;
        } else if (this.dstDeltaMinutes < 0) {
            // Time is offset further forward from UTC in January; this locale observes DST
            // and is in the southern hemisphere
            this.southernHemisphere = true;
            this.adjustForDST = true;
            if (nowOffset == this.januaryDstOffset) this.currentlyInDST = true;
        } else {
            // the delta is 0 and DST is not a factor in this locale
            this.adjustForDST = false;
        }

        // As noted above, all current observations of Daylight Saving Time involve moving
        // local time one hour forward, so right now these variables will always end up as
        // 1 and 0
        this.dstDeltaMinutes = Math.abs(this.dstDeltaMinutes);
        this.dstDeltaHours = Math.floor(this.dstDeltaMinutes / 60);
        this.dstDeltaMinutes -= (this.dstDeltaHours * 60);
    },

    getUTCHoursDisplayOffset : function (date, utcHoursDisplayOffset) {
        // If we're currently inside DST and wanting to calculate an offset for a datetime
        // that is outside DST, we need to move the offset backwards because the offset we
        // stored on the Time class during startup already includes the DST offset
        var dstDelta = this.currentlyInDST ? -(this.dstDeltaHours) : 0;
        if (this.adjustForDST) {
            if (date.getTimezoneOffset() == this.januaryDstOffset) {
                if (this.southernHemisphere) {
                    dstDelta += this.dstDeltaHours;
                }
            } else {
                if (!this.southernHemisphere) {
                    dstDelta += this.dstDeltaHours;
                }
            }
        }
        return (utcHoursDisplayOffset != null
                ? utcHoursDisplayOffset
                : this.UTCHoursDisplayOffset) + (this.adjustForDST ? dstDelta : 0);
    },

    getUTCMinutesDisplayOffset : function (date, utcMinutesDisplayOffset) {
        var dstDelta = this.currentlyInDST ? -(this.dstDeltaMinutes) : 0;
        if (this.adjustForDST) {
            if (date.getTimezoneOffset() == this.januaryDstOffset) {
                if (this.southernHemisphere) {
                    dstDelta += this.dstDeltaMinutes;
                }
            } else {
                if (!this.southernHemisphere) {
                    dstDelta += this.dstDeltaMinutes;
                }
            }
        }
        return (utcMinutesDisplayOffset != null
                ? utcMinutesDisplayOffset
                : this.UTCMinutesDisplayOffset) + (this.adjustForDST ? dstDelta : 0);
    }
});

// Work out whether we're currently inside Daylight Saving Time, and compute the offset to
// apply on the transition.
isc.Time._performDstInit();

// set up the default timezone offset based on the browser locale here.
isc.Time.setDefaultDisplayTimezone(new Date().getTimezoneOffset(), true);









// We add a few convenience methods on SmartClient instances so that they can
// reflect a little on their SmartGWT equivalents.
isc.Class.addProperties({
    // Returns the corresponding SmartGWT instance.
    getSGWTInstance : function () {
        return this[isc.gwtRef];
    },

    // Returns the SGWTModule which corresponds to the module that created
    // the SmartGWT instance
    getSGWTModule : function () {
        return this[isc.gwtModule];
    },

    getSGWTFactory : function () {
        var module = this.getSGWTModule();
        if (!module) return null;

        var instance = this.getSGWTInstance();
        if (!instance) return null;

        return module.getSGWTFactory(instance);
    },

    // Returns the fully-qualified Java class name of the SmartGWT instance.
    getSGWTClassName : function () {
        var factory = this.getSGWTFactory();
        return factory ? factory.getClassName() : null;
    },

    // Sets properties via the SmartGWT object, rather than directly. Of
    // course, the SmartGWT object will often eventually call back to set
    // properties on the SmartClient object. If we can't find a SmartGWT
    // object, we fall back to setProperties. Thus, you can call this and know
    // that the properties will be set, one way or the other.
    setSGWTProperties : function (json) {
        var factory = this.getSGWTFactory();
        if (factory) {
            factory.setSGWTProperties(this.getSGWTInstance(), json);
        } else {
            this.setProperties(json);
        }
    },

    // Gets an array of the names of SmartGWT properties (but not values). If
    // we can't find the SmartGWT object, we fall back to getAttributes, which
    // does the equivalent for SmartClient objects.
    getSGWTAttributes : function () {
        var factory = this.getSGWTFactory();
        if (factory) {
            return factory.getSGWTAttributes();
        } else {
            // Adapted from language/Reflection.js
            var list = [];
            for (var property in this) {
                if (typeof this[property] == "function") continue;
                if (property.charAt(0) == "_") continue;
                if (property == property.toUpperCase()) continue;
                list[list.length] = property;
            }
            return list;
        }
    },

    // Gets a single attribute value
    getSGWTProperty : function (property) {
        var module = this.getSGWTModule();
        if (module) {
            return module.getProperty(this.getSGWTInstance(), property);
        } else {
            return this.getProperty(property);
        }
    },

    // Gets a single attribute value as a string. Can be equivalent to
    // getSGWTProperty(prop).toString(). But, if there is more than one getter,
    // it will prefer the one that actually returns a string (e.g.
    // getWidthAsString)
    getSGWTPropertyAsString : function (property) {
        var module = this.getSGWTModule();
        if (module) {
            return module.getPropertyAsString(this.getSGWTInstance(), property);
        } else {
            // Note that when we're not dealing with SGWT objects, we just call
            // toString rather than looking for alternate methods. This isn't
            // ideal, since sometimes we might want an alternative method.
            // However, it isn't trivial to figure out which methods to choose.
            var result = this.getProperty(property);
            return result ? result.toString() : result;
        }
    }
});

// A factory class which knows how to produce SmartGWT objects, apply
// properties to them, get lists of their property names, and get the
// corresponding SmartClient instance.  SmartGWT creates an SGWTFactory
// instance for each SmartGWT BeanFactory. The SGWTFactory is stored in the
// isc[] space, as if it were a regular SmartClient class. In fact, calls to
// isc.ClassFactory.getClass(fullyQualifiedSmartGWTClassName) will return the
// SGWTFactory. So, SGWTFactory is a kind of sister-class to Class. This
// permits the autoChild process and creation via _constructor to work mostly
// unchanged where the autoChild or _constructor is specified as a
// fully-qualified SmartGWT class name. Calling code does have to be aware of
// SGWTFactory if using createRaw() rather than create() -- see below.
isc.defineClass("SGWTFactory");

isc.SGWTFactory.addClassProperties({
    // A marker that we use to identify config blocks for the createRaw() /
    // init() | completeCreation() cycle
    CONFIG_BLOCK: "sgwtConfigBlock",

    // The name of the property on the config block where init() |
    // completeCreation() stores the real object when called after createRaw()
    SC_INSTANCE: "smartclientInstance",

    // A marker on hashes in the isc[] space, to indicate that they represent
    // parts of bean class names ... e.g. "com" in com.mycompany.MyListGrid.
    BEAN_CLASS_PARTS: "beanClassParts",

    // Note that this only gets factories by name, and only those which have
    // been explicitly created by GWT.create on the SmartGWT side (rather than
    // merely having been creating for superclasses of those classes).
    //
    // If you have an existing object, then call getSGWTFactory on it instead,
    // since that will query class objects from the appropriate SGWT module,
    // possibly loaded separately with classes that possibly have the same
    // name.
    //
    // Thus, this function is really only for cases in which all you have is
    // a class name, and nothing else.
    getFactory : function (beanClassName) {
        if (!beanClassName) return null;
        var factory = isc[beanClassName];
        if (factory && isc.isA.SGWTFactoryObject(factory)) {
            return factory;
        } else {
            return null;
        }
    },

    // This is a convenience function to help with the createRaw / (init |
    // completeCreation) cycle ... see below
    extractFromConfigBlock : function (sgwtConfigBlock) {
        if (sgwtConfigBlock[isc.SGWTFactory.CONFIG_BLOCK]) {
            // if it is a config block, extract the instance
            return sgwtConfigBlock[isc.SGWTFactory.SC_INSTANCE];
        } else {
            // Otherwise, return the "config block" itself, so we can call this
            // unconditionally with things that might not be config blocks
            return sgwtConfigBlock;
        }
    }
});

// SGWTFactory instances get used as if they were Class objects (rather than
// instances). As an example, the SGWTFactory objects have an *instance* method
// create(), which functions like the *class* method create, except that it
// creates the SGWT object for the beanClassName (rather than creating another
// SGWTFactory). In order to make various schema-driven routines just work, we
// need to mimic various things that would normally apply to Class objects on
// the SGWTFactory instance -- essentially, pretend that each SGWTFactory
// *instance* is a Class object. (The alternative would be to actually make
// each SGWTFactory a class object via defineClass, but that would add a large
// number of classes. Also, in the case of multiple SGWT modules, we need to
// create more than one SGWTFactory with the same beanClassName.)
//
// One result of the mimicry is that it's hard to detect whether an SGWTFactory
// instance is actually an SGWTFactory instance (the normal isA.SGWTFactory won't
// work because it's fooled by the mimicry), so we have a special method.
isc.addMethods(isc.isA, {
    SGWTFactoryObject : function (object) {
        return object != null && object._isSGWTFactoryObject == true;
    }
});

isc.SGWTFactory.addProperties({
    // Marker for isc.isA.SGWTFactoryObject, since the normal isc.isA.SGWTFactory
    // won't work.
    _isSGWTFactoryObject: true,

    // --------------------------------------------------------------------
    // These properties will be set by the SGWT BeanFactory when it creates
    // this SGWTFactory.
    // --------------------------------------------------------------------

    // The fully-qualified SmartGWT class name: e.g. com.mycompany.MyListGrid
    // beanClassName: null,

    // The SGWT BeanFactory
    // beanFactory: null,

    // The SGWTModule that corresopnds to this factory
    // sgwtModule: null,

    getClassName : function () {
        return this.beanClassName;
    },

    getSGWTClassName : function () {
        return this.beanClassName;
    },

    getSuperClass : function () {
        return this._superClass;
    },

    init : function () {
        this.Super("init", arguments);

        // Do some things to the *instance* that ClassFactory would
        // normally do when defining a *class*.
        this.Class = this.beanClassName;
        this.isFrameworkClass = this.isSGWTFrameworkClass();

        if (!this.isFrameworkClass) {
            var scClass = this.getSGWTSuperClass();
            while (scClass && !scClass.isFrameworkClass) {
                scClass = scClass.getSGWTSuperClass();
            }
            if (scClass) this._scClass = scClass.Class;
        }
        if (!this._scClass) this._scClass = this.Class;

        this._superClass = this.getSGWTSuperClass();

        // We don't add the instance to isc.ClassFactory.classList, since it
        // doesn't seem to be used for anything we need.

        isc.isA[this.beanClassName] = isc.ClassFactory.makeIsAFunc(this.beanClassName);

        // Need to mimic the _isA_Canvas optimization
        if (this.isA("Canvas")) this._isA_Canvas = true;
    },

    // Registers the class name in the isc[] space, so that getFactory() will
    // return it, and the following idioms will work (where _constructor is a
    // fully-qualified SmartGWT class name):
    //
    // isc[object._constructor].create(properties)
    // isc["com.mycompany.MyListGrid"].create(properties);
    //
    // Also, see the notes on createRaw() below -- this is also supported, but
    // the calling code needs to be aware of a few details.
    //
    // This is called from the SmartGWT side if GWT.create was used to make the
    // factory. It is not called if the factory was automatically created for
    // a superclass. That way, the developer controls which class names are
    // registered by which factories are explicitly instantiated by GWT.create.
    registerClassName : function () {
        // Wrap in an error handler, since we call this from SmartGWT
        try {
            var classObj = this;


            /*
            var isFrameworkClass = (isc.SGWTFactory._isSGWTFrameworkClass(this.beanClassName));
            if (isFrameworkClass) {
                var j = this.beanClassName.lastIndexOf("."),
                    scClassName = this.beanClassName.substring(j + 1);

                if (isc.isA.Class(isc[scClassName])) {
                    classObj = isc[scClassName];
                } else {
                    isc.logWarn("beanClassName '" + this.beanClassName + "' is supposed to " +
                               "be a built-in framework class, but isc['" + scClassName + "'] " +
                               "is not a Class.");
                }
            }
            */

            // Check for collisions within isc[] This should be extremely rare,
            // as there is nothing typically in isc[] that would look like a
            // fully-qualified java name. But better safe than sorry! Note that
            // here we store the beanClassName as a single entry in isc[] --
            // that is, if beanClassName is "com.mycompany.MyListGrid" that
            // produces one entry in the hash (at top-level), despite the dots.
            // Below we do a little extra work so that
            // isc.com.mycompany.MyListGrid will also work.
            //
            // Note that we don't try to support simpleNames here, since we
            // wouldn't expect the developer to access any of this directly. We
            // could support simpleNames, at the cost of some increased
            // possibility of collision.
            var existingObject = isc[this.beanClassName];
            if (existingObject) {
                if (isc.isA.ClassObject(existingObject)) {
                    this.logWarn("beanClassName '" + this.beanClassName + "' collides with existing native " +
                                "SmartClient class with the same name. The bean will not be registered.");
                    return;
                } else if (isc.isA.SGWTFactoryObject(existingObject)) {
                    this.logWarn("beanClassName '" + this.beanClassName + "' has already been registered. " +
                                "The existing bean will be replaced.");
                } else {
                    this.logWarn("beanClassName '" + this.beanClassName + "' collides with the ID of an existing " +
                                "object with value '" + this.echo(existingObject) +
                                "'. The bean will not be registered.");
                    return;
                }
            }

            // If the beanClassName has dots (which it should), then we also want
            // to make the following idiom work:
            //
            // isc.com.mycompany.MyListGrid.create(properties)
            //
            // Collisions within isc[] should still be rare. Generally speaking,
            // the first part of the java fully-qualified name will be a short word
            // with only lower-case letters. There are very few of those normally
            // within isc[] -- just:
            //
            // "ask", "auto", "clone", "colon", "confirm", "contains", "defer",
            // "dot", "echo", "eval", "is", "nbsp", "params", "px", "rpc", "say",
            // "semi", "slash", "star", "version", "warn", "xml", "xnbsp"
            //
            // Well, I suppose that's not such a short list. But none of them are
            // very likely candidates for the first part of a Java class name.
            //
            // An alternative would be to use "sgwt." as a prefix -- that way, we
            // would only reserve isc[sgwt]. Using "sgwt:" as the prefix would be
            // awkward, because then ...
            //
            // isc.sgwt:com.mycompany.MyListGrid.create()
            //
            // ... would no longer be legal code.
            var beanClassParts = this.beanClassName.split(".");
            if (beanClassParts.length > 1) {
                var base = isc;
                var breadCrumbs = "isc";

                // Note we're stopping at the second-last element, not the last
                for (var i = 0; i < beanClassParts.length - 1; i++) {
                    var part = beanClassParts[i]
                    var existingObject = base[part];
                    breadCrumbs = breadCrumbs + "." + part;

                    if (existingObject) {
                        // If it exists, make sure it's ours
                        if (!existingObject[isc.SGWTFactory.BEAN_CLASS_PARTS]) {
                            this.logWarn("beanClassName '" + this.beanClassName +
                                        "' collides with existing object located at '" + breadCrumbs +
                                        "' with value '" + this.echo(existingObject) +
                                        "'. The bean will not be registered.");
                            return;
                        }
                    } else {
                        // If it doesn't exist, then create it and mark it as ours,
                        // so we can check for collisions.
                        base[part] = {};
                        base[part][isc.SGWTFactory.BEAN_CLASS_PARTS] = true;
                    }

                    base = base[part];
                }

                // There can't be a collision at this stage, since we would have
                // caught it when checking the isc object itself.
                var lastPart = beanClassParts[beanClassParts.length - 1];
                base[lastPart] = classObj;
            }

            // Wait until here to actually store the proxy in the isc object, in
            // case we bail out
            isc[this.beanClassName] = classObj;
        }
        catch (e) {
            this.logError(e.message);
        }
    },

    // Returns a new SmartGWT instance. Note that this is an instance method,
    // not a class method. However, the semantics are the same as
    // isc.Class.create -- that is, the properties are the entire
    // initialization config, and we return a SmartClient object.
    create : function (A,B,C,D,E,F,G,H,I,J,K,L,M) {
        //>EditMode
        // Capture clean initialization data, and don't construct the actual
        // instance.  This is used to load a set of components for editing.
        if (isc.captureDefaults) {

            var       level = isc.createLevel;
            isc.createLevel = isc.keepGlobals ? (level == null ? 1 : level + 1) : null;


            isc.captureDefaults = false;

            var component = {
                type: this.Class,
                defaults: isc.addProperties({}, A,B,C,D,E,F,G,H,I,J,K,L,M)
            }

            // Delete redundant _constructor if it was supplied -- see below
            delete component.defaults._constructor;

            if (!isc.capturedComponents) isc.capturedComponents = [];
            isc.capturedComponents.add(component);

            if (component.defaults.ID) {
                isc.ClassFactory.addGlobalID(component, component.defaults.ID);
                //isc.Log.logWarn("adding global component: " + component.defaults.ID);
            }

            // restore original value of isc.captureDefaults
            isc.captureDefaults = true;
            // restore original value of isc.createLevel
            isc.createLevel = level;

            return component;
        }
        //<EditMode

        var properties = isc.addProperties({}, A,B,C,D,E,F,G,H,I,J,K,L,M);

        // If _constructor has been supplied as a property, it is redundant,
        // since it has already been used to pick the desired SGWTFactory. So,
        // we delete it. If we left it in, the conversion of the properties to
        // their Java equivalent would actually construct the object, which
        // would be premature!
        delete properties._constructor;

        var sgwtInstance = this.sgwtModule.newInstance(this.beanClassName, properties);

        // Of course, the semantics of "create" are to return the Smartclient
        // object, not the opaque SmartGWT object. So, we get or create it. At
        // this point, it's appropriate to call getOrCreateJsObj, because the
        // properties supplied to create are, by definition, all of the
        // creation properties.
        return this.getOrCreateJsObj(sgwtInstance);
    },

    // createRaw would be called on a normal SmartClient class as a highly
    // efficient way of creating an object -- typically followed by directly
    // setting some properties and then callling init(), or completeCreation(),
    // or _completeCreationWithDefaults(). The usual semantics are that
    // createRaw returns the SmartClient native object *itself*, but with no
    // initialization having been done. That won't exactly work if we're
    // creating a SmartGWT object, because SmartGWT defers creating the native
    // SmartClient object until it has collected the configuration, in order to
    // preserve the distinction between configuration and later changes.
    //
    // Thus, we can't return the ultimate SmartClient object without
    // initialization, since SmartGWT doesn't want to create it before
    // initialization. So, we'll return a special object whose purpose is to
    // collect configuration properties and then apply them lazily when the
    // native SmartClient object is actually created. Unfortunately, code
    // calling createRaw does need to be aware of this, because it needs to
    // explicitly dereference the SmartClient object. Fortunately, there aren't
    // that many usages of createRaw.
    createRaw : function () {
        var factory = this;

        // We return an object which will accept property assignments and then
        // lazily create the real Javascript object and return it. This
        // respects the *semantics* of createRaw, though it does not retain its
        // actual efficiency if what we are creating is a SmartGWT object.
        // However, the code calling createRaw does need to check whether to
        // dereference the real object after it is created.
        var sgwtConfigBlock = {
            getClass : function () {
                return isc[factory.beanClassName]
            },

            init : function (A,B,C,D,E,F,G,H,I,J,K,L,M) {
                isc.addProperties(this, A,B,C,D,E,F,G,H,I,J,K,L,M);

                // Self-destruct, since we don't want to pass "init" or
                // "completeCreation" as a property to create(). Note that
                // "this" is deliberate -- we're referring to our anonymous
                // config object.
                delete(this.init);
                delete(this.completeCreation);
                delete(this.getClass);
                delete(this[isc.SGWTFactory.CONFIG_BLOCK]);

                // SectionStack sets __ref to null when creating a
                // SectionHeader, to deal with some differences between the way
                // that SmartClient and SmartGWT manage SectionStackSection and
                // SectionHeader. But that doesn't make sense in this code
                // path, because here it is SmartGWT that actually handles the
                // creation.  So, we'll delete a null __ref if provided, and
                // let SmartGWT provide its own.
                if (this[isc.gwtRef] === null) delete this[isc.gwtRef];

                //>EditMode
                // Capture clean initialization data, and don't construct the actual
                // instance.  This is used to load a set of components for editing.
                if (isc.captureDefaults) {

                    var       level = isc.createLevel;
                    isc.createLevel = isc.keepGlobals ? (level == null ? 1 : level + 1) : null;


                    isc.captureDefaults = false;

                    var component = {
                        type: factory.beanClassName,
                        defaults: isc.addProperties({}, this)
                    }
                    if (!isc.capturedComponents) isc.capturedComponents = [];
                    isc.capturedComponents.add(component);

                    if (component.defaults.ID) {
                        isc.ClassFactory.addGlobalID(component, component.defaults.ID);
                        //isc.Log.logWarn("adding global component: " + component.defaults.ID);
                    }
                    this[isc.SGWTFactory.SC_INSTANCE] = component;
                    this[isc.SGWTFactory.CONFIG_BLOCK] = true;

                    // restore original value of isc.captureDefaults
                    isc.captureDefaults = true;
                    // restore originnal value of isc.createLevel
                    isc.createLevel = level;

                    return;
                }
                //<EditMode

                // Create the property that calling code will need to
                // dereference ... doesn't seem to be a way of avoiding that.
                // Again, note that "this" is deliberate.
                this[isc.SGWTFactory.SC_INSTANCE] = factory.create(this);

                // And add the marker back
                this[isc.SGWTFactory.CONFIG_BLOCK] = true;
            },

            // In the completeCreation case, we may get some extra properties
            // to apply. We just fall through to init above, after adding
            // the properties. Again, the use of "this" is deliberate.
            completeCreation : function (A,B,C,D,E,F,G,H,I,J,K,L,M) {
                this.init(A,B,C,D,E,F,G,H,I,J,K,L,M);
                return this[isc.SGWTFactory.SC_INSTANCE];
            }
        }

        // Add a marker so that we know it's a config block, rather than a
        // partially created SmartClient object
        sgwtConfigBlock[isc.SGWTFactory.CONFIG_BLOCK] = true;
        return sgwtConfigBlock;
    },

    // Apply json string or object properties to the specified sgwtInstance.
    setSGWTProperties : function (sgwtInstance, json) {
        if (json) {
            if (isc.isA.String(json)) {
                if (!(isc.startsWith(json, '(') && isc.endsWith(json, ')'))) {
                    json = '(' + json + ')';
                }
                json = isc.Class.evaluate(json);
            }

            for (var name in json) {
                this.sgwtModule.setProperty(sgwtInstance, name, json[name]);
            }
        }
    },

    // Returns the names of the properties of the beanClass as an array
    getSGWTAttributes : function () {
        return this.sgwtModule.getAttributes(this.beanClassName);
    },

    // Returns the property of the SGWT instance
    getSGWTProperty : function (sgwtInstance, property) {
        return this.sgwtModule.getProperty(sgwtInstance, property);
    },

    // Returns the property of the SGWT instance as a string, preferring
    // getters that natively return a string (if present)
    getSGWTPropertyAsString : function (sgwtInstance, property) {
        return this.sgwtModule.getPropertyAsString(sgwtInstance, property);
    },

    // If the passed object represents an SGWT instance, invoke it's
    // getOrCreateJsObj() method so that the SC object is returned.
    getOrCreateJsObj : function (sgwtInstance) {
        return this.sgwtModule.getOrCreateJsObj(sgwtInstance);
    },

    // If the passed object represents an SGWT instance, invoke its
    // setJsObj() method (or equivalent) to reset the JS object it refers to
    setJsObj : function (sgwtInstance, jsObj) {
        this.sgwtModule.setJsObj(sgwtInstance, jsObj);
    },

    getSGWTSuperClass : function () {
        return this.sgwtModule.getSGWTSuperClass(this);
    },

    isSGWTFrameworkClass : function () {
        return this.sgwtModule.isSGWTFrameworkClass(this);
    },

    getDefaultScClassName : function () {
        return this.sgwtModule.getDefaultScClassName(this);
    },

    getDefaultScClass : function () {
        return isc.ClassFactory.getClass(this.getDefaultScClassName());
    },

    isA : function (className) {
        if (className == null) return false;

        // First, we see whether our scClass equivalent isA clasName, since
        // what you'll get from create() is the scClass
        var scClass = this.getDefaultScClass();
        if (scClass && scClass.isA(className)) return true;

        // If not, then see whether className is a superclass on the SGWT side.

        // handle being passed Class Objects and instances of classes
        if (!isc.isA.String(className)) {
            if (className.getSGWTClassName) className = className.getSGWTClassName();
            if (!isc.isA.String(className)) return false;
        }

        if (isc.startsWith(className, isc.ClassFactory._$iscPrefix)) {
            className = className.substring(4);
        }

        // walk the class object inheritance chain
        var superClass = this;
        while (superClass) {
            if (superClass.beanClassName == className) return true;
            superClass = superClass.getSGWTSuperClass();
        }

        return false;
    }
});

isc.SGWTFactory.addProperties({
    // Synonym for "create", because isc.ClassFactory calls it
    newInstance : isc.SGWTFactory.getInstanceProperty("create")
});
 
isc.defineClass("PubSub");

isc.PubSub.addClassMethods({
    _subscriberRegistry : {},
    _nextSubscriptionId : 0,

    getSubscribers : function (channelName) {
        return (this._subscriberRegistry[channelName] = 
                this._subscriberRegistry[channelName] || []);
    },

    subscribe : function (channelName, target, callback) {
        var subscribers = this.getSubscribers(channelName), 
            subscriptionId = this._nextSubscriptionId++;

        subscribers.add({ subscriptionId: subscriptionId, target: target, callback: callback });
        return subscriptionId;
    },

    unsubscribe : function (channelName, subscriptionId) {
        var subscribers = this.getSubscribers(channelName);
        subscribers.remove(subscribers.find("subscriptionId", subscriptionId));
    },

    publish : function (channelName, data) {
        // dup to avoid concurrent modification during publish()
        var subscribers = this.getSubscribers(channelName).duplicate(); 
        for (var i = 0; i < subscribers.length; i++) {
            isc.Class.fireCallback(subscribers[i].callback, "data", [data], subscribers[i].target);
        }
    }
});











//>    @class    Page
//
//     Provides information about the page you're loaded in.  We define "page" here to be roughly
//     equivalent to the browser window or frame the libraries have been loaded in.
//
//  @treeLocation Client Reference/System
//  @visibility external
//<



//
//    Create the Page singleton object
//
isc.ClassFactory.defineClass("Page");


// define groups for documentation purposes
isc.Page.addClassProperties({

    _historyActions : [],

    // flag for whether page.onload has fired yet
    _doneLoading : false,

    //> @groupDef browserSupport
    // When considering which browser versions are supported, developers should consider
    // which browser versions they wish to support within their application.
    // Generally this will be a subset of what the framework supports, and should be decided
    // based on the needs of your customers (typically corporate policies on browser usage
    // for intranet applications, or general browser usage for customer facing applications).
    // <P>
    // The SmartClient framework supports all major browsers, and will always support the
    // current versions at release-time.
    // <P>
    // The full list of SmartClient browser support (at the time of the initial v11.0p_2016-03-31/LGPL Deployment release)
    // is listed below. Note that support for some framework features may be implemented using
    // different native approaches - or in rare cases, may be unavailable - in some older browser
    // versions. Such cases are covered in documentation where they occur. For example, see the
    // +link{group:skinning,skinning} discussion about CSS3 mode.
    // <P>
    // At the application level, we'd typically recommend advertising support for the latest
    // versions of Chrome, Safari and Firefox, the most recent Firefox ESR release and the
    // most common (and most recent) versions of Internet Explorer.
    // <P>
    // <h4>Support for new browser versions introduced after SmartClient release</h4>
    // When new browser versions are released we will generally determine whether any issues
    // are introduced by the new version, and update the most recent released
    // SmartClient version to add support for these new browsers if changes are necessary.
    // These changes will be made available in nightly patch builds.
    // <P>
    // Older branches of SmartClient may also be updated to support new browser versions. This will
    // be considered on a case-by-case basis, depending on the effort required to work around any
    // newly introduced browser bugs on these older branches.
    // <P>
    // <h4>Unsupported browser handling</h4>
    // Every distributed SmartClient skin contains an "Unsupported Browser" page. This is an optional
    // placeholder for an application to state its browser support policies.
    // <P>
    // <b>The following browser versions were supported as of the original v11.0p_2016-03-31/LGPL Deployment release</b>:
    //    <table class="normal" cellPadding=5>
    //
    //    <tr><td width=40></td><td width=200>
    //    <b>Browser/Version</b>
    //    </td><td width=240>
    //    <b>Operating System(s)</b>
    //    </td></tr>
    //
    //    <tr><td></td><td>
    //    <i>Internet Explorer 6.0-11.x</i>
    //    </td><td>
    //    Windows
    //    </td></tr>
    //
    //    <tr><td></td><td>
    //    <i>Edge 20.10240.16384.0+</i>
    //    </td><td>
    //    Windows
    //    </td></tr>
    //
    //    <tr><td></td><td>
    //    <i>Firefox 3.6.x-45.x</i>
    //    </td><td>
    //    Windows/MacOS/Linux
    //    </td></tr>
    //
    //    <tr><td></td><td>
    //    <i>Safari 5.0-9.x</i>
    //    </td><td>
    //    MacOS/Windows
    //    </td></tr>
    //
    //    <tr><td></td><td>
    //    <i>Chrome 10.x-49.x</i>
    //    </td><td>
    //    Windows/MacOS/Linux/ChromeOS
    //    </td></tr>
    //
    //    <tr><td></td><td>
    //    <i>Opera 11.x-36.x</i>
    //    </td><td>
    //    Windows/MacOS
    //    </td></tr>
    //
    //    <tr><td></td><td>
    //    <i>Safari (mobile)</i>
    //    </td><td>
    //    iOS 6+
    //    </td></tr>
    //
    //    <tr><td></td><td>
    //    <i>Android browser</i>
    //    </td><td>
    //    Android 3.2+
    //    </td></tr>
    //
    //    </table>
    //
    // @visibility external
    // @title Supported Browsers
    // @treeLocation Concepts
    //<


    //>    @classAttr    isc.Page.defaultUnsupportedBrowserURL   (URL : "[SKIN]/unsupported_browser.html" : IRWA)
    //      On a call to <code>Page.checkBrowserAndRedirect()</code>, if no explicit URL
    //      is passed in, and the browser is not supported by ISC, redirect to this URL.
    //
    // @group    files
    // @group browserSupport
    // @see Page.checkBrowserAndRedirect()
    // @visibility external
    //<
    //  Note all the default load_skin.js files will call this method and pass in an
    //  explicit URL for a page to redirect to.  This default is unlikely to be modified as
    //  it's easier to just modify the explicit URL passed in when the method is called.
    defaultUnsupportedBrowserURL : "[SKIN]/unsupported_browser.html",

    //>    @classAttr    isc.Page._directoryCache    (array : [] : IRW)
    //         URLs in our framework can have keywords embedded in them as
    //        [SKIN] or [ISOMORPHIC], etc.  This is where we store the expanded directory names.
    //        Use Page.getURL() to figure that out.
    //
    //        @group    files
    //         @see Page.setDirectories()
    //<
    _directoryCache : {},

    //> @classAttr Page.protocolURLs (Array of String : [...] : IRW)
    // If a URL provided to various Page APIs begins with one of these Strings, it is treated
    // as an absolute URL.
    // <P>
    // The default of protocols is:
    // <pre>
    //     ["http://","https://","file://","mailto:", "app-resource:", "data:"]
    // </pre>
    // .. and can be replaced via +link{class.addClassProperties,Page.addClassProperties()} or
    // via setting the global variable isc_protocolURLs before SmartClient loads.
    //
    // @group files
    // @see Page.getURL()
    // @visibility external
    //<
    // "app-resource:" used by apollo
    // "data:" allows base64 encoded images to be specified directly, in recent browsers
    protocolURLs : window.isc_protocolURLs || ["http://","https://","file://","mailto:", "app-resource:", "data:"],

    //>    @classAttr    isc.Page.textDirection    (TextDirection : (null) : IRW)
    //        What direction is text supposed to run?
    //            LTR (left to right, eg: English) or RTL (right to left, eg: Arabic)
    //        @group    textDirection
    //        @platformNotes    IE only
    //<
    textDirection:null, // don't remove: initalized to null so we will look up the value set in
                        // the body tag if it hasn't been set in our framework.

    //> @classAttr   isc.Page.pollPageSize (boolean : null : IRWA)
    // Advanced attribute which will cause SmartClient to constantly check for the introduction
    // of scrollbars due to resizing of native content by direct DOM manipulation, and
    // automatically adjust percent sized widgets if external code causes the browser window to
    // be resized.
    //<
    // Polling for changes in page size will also catch orientation changes. We use this
    // in MobileWebKit browsers


    //>    @type    Page.TextDirection
    // Specifies RTL or LTR direction for text -- IE5+ and FF1.5+ only
    LTR:"ltr",                                             //    @value    isc.Page.LTR        Show text left-to-right (eg: English)
    RTL:"rtl",                                            //    @value    isc.Page.RTL        Show text right-to-left (eg: Arabic)
    //            @group    appearance
    //<

    //> @classAttr   isc.Page._addVersionToSkinCSS (boolean : false : IRWA)
    // Advanced attribute which will cause +link{classMethod:Page.loadStyleSheet()} to append
    // an "isc_version" parameter to the end of the url when loading a stylesheet.
    //
    // @group skins, files
    // @see Page.setAddVersionToSkinCSS()
    // @see Page.getAddVersionToSkinCSS()
    //<
    _addVersionToSkinCSS: false
});


isc.Page.addClassMethods({

//>    @classMethod    Page.finishedLoading()    (A)
// Routine called automatically by the EventHandler when the page finishes loading.
//        @group    eventHandling
//<
finishedLoading : function () {

    isc.Page._doneLoading = true;
    isc.Log.logInfo("isc.Page is loaded");

    // kick off the idle timer when the page starts
    isc.EH.startIdleTimer();


    if (isc.Browser.isSafari) isc.Canvas.clearCSSCaches();

    // Open the log window if it should be open
    if (!window.suppressAutoLogWindow) {
        var cookie = isc.LogViewer.getLogCookie();
        if (cookie != null && cookie.keepOpen) {
            // NOTE: wait until any existing log window has had time to reconnect before
            // auto-opening the log window
            isc.Timer.setTimeout("isc.Log.show(true)", 1000);
        }
    }


    // If deprecated UTCHoursOffset has been set for the page, respect it (but log a warning)

    if (isc.Time && isc.Time.UTCHoursOffset != null) {
        isc.logWarn("This application includes code to set the Time.UTCHoursOffset attribute. " +
            "This property will be respected but has been deprecated in favor of the " +
            "classMethod isc.Time.setDefaultDisplayTimezone().");
        // respect it anyway
        isc.Time.setDefaultDisplayTimezone(isc.Time.UTCHoursOffset.stringify() + ":00");
    }

    // If we're polling for page size changes, kick this off now.
    if (isc.Page.pollPageSize) {
        isc.EH._pageResize();

    // Otherwise we've seen a case in some browsers where the scroll size is not calculated
    // correctly on initial draw from clean cache - force a single pageResize event on
    // a delay to fix this if necessary

    } else {
        isc.EH.delayCall("_pageResize", [true],  200);
    }


    if (isc.Browser.isIE) { isc.Class.evaluate("1", null, false, true); }
},

//>    @classMethod    Page.isLoaded()
//        Has the page finished loading?
//
//        @return    (Boolean)        true == page is done loading
// @visibility external
//<
isLoaded : function () { return this._doneLoading },

// return the URL that should be used for an IFRAME that should be blank
getBlankFrameURL : function () {



    if (isc.Browser.isIE && ("https:" == window.location.protocol || document.domain != location.hostname )) {
        // In IE under HTTPS, using "about:blank" as the location for an IFRAME causes a bogus "Mix
        // of secure and insecure content" dialog, so instead fetch an empty html file.
        return this.getURL("[HELPERS]empty.html");
    }
    // known to work in IE, Moz, Safari
    return "about:blank";
},


//>    @classMethod    Page.setTitle()
//        Set the title of the page, which is typically shown as part of the browser window title
// @visibility external
//<
// Doesn't actually update the browser window title in IE.
setTitle : function (title) {
    document.title = title;
},

//>    @classMethod    Page.setDirectories()
//        Set any and all of the directories that the page keeps track of in a single call.
//
//        @param    [directories]    (object)    Object of {directory:URL} paths.
//                                If not specified, we will try to get directories specified in the window objecs.
//        @group    files, images
//<
setDirectories : function (directories) {
    if (directories == null) {
        directories = {
            imgDir:window.imgDir,
            isomorphicDir:(window.isomorphicDir ? window.isomorphicDir : window.IsomorphicDir),
            isomorphicClientDir:window.isomorphicClientDir,
            isomorphicDocsDir:window.isomorphicDocsDir,
            skinDir:window.skinDir,
            helperDir:window.helperDir,
            toolsDir:window.isomorphicToolsDir
        }
    }

    this._deriveAppDir();

    this.setIsomorphicDir(directories.isomorphicDir);
    this.setIsomorphicClientDir(directories.isomorphicClientDir);
    this.setIsomorphicDocsDir(directories.isomorphicDocsDir);
    this.setAppImgDir(directories.imgDir);
    this.setSkinDir(directories.skinDir);
    this.setHelperDir(directories.helperDir);
    this.setIsomorphicToolsDir(directories.isomorphicToolsDir);
},


// derive the base URL of the application.
_deriveAppDir : function () {

    // get the path to the current file and strip off any query params and leaf file names
    var filePath = window.location.href;
    // strip off anything after a "?"
    if (filePath.contains("?")) filePath = filePath.substring(0,filePath.indexOf("?"));
    // # references node IDs which, according to the W3C cannot have slashes in them, but in
    // the AJAX world, # refs are often used to provide back button support rather than
    // actually reference any node ids in the DOM, so it's best that we don't break if # refs
    // contain slashes in the value.
    if (filePath.contains("#")) filePath = filePath.substring(0,filePath.indexOf("#"));
    // strip off the leaf file name if one exists
    if (filePath.charAt(filePath.length-1) != "/") {
        filePath = filePath.substring(0, filePath.lastIndexOf("/") + 1);
    }

    this._directoryCache.APP = filePath;

    //>DEBUG
    if (this.logIsInfoEnabled()) {
        this.logInfo("app dir is " + this._directoryCache.APP);
    }
    //<DEBUG

    // call getAppImgDir() so it will change based on the changed app dir...
    this.setAppImgDir();
},

//>    @classMethod    Page.getAppDir()
// Returns the base URL of the application, which is the page URL minus the last non-directory
// path component.  For example, if the page is loaded from
// <code>http://foo.com/bar/zoo.jsp</code>, appDir will be <code>http://foo.com/bar/</code>.
// <P>
// If other page-wide URLs such as +link{Page.setIsomorphicDir()} are specified as
// relative paths, they are considered relative to this URL.
//
//        @return    (string)    URL for page-specific files.
//        @group    files
// @visibility external
//<
getAppDir : function () {
    return this._directoryCache.APP;
},

//    Application-specific resource directories
// ---------------------------------------------------------------------------------------

//>    @classMethod    Page.setAppImgDir()
// Specify the directory for app-specific images.
// <P>
// This becomes the default location where any SmartClient component will load images from
// unless the special "[SKIN]" prefix is used to indicate that an image is part of a skin.
// <P>
// Default is "[APP]images/"
//
//        @param    [URL]        (string)    New imgDir URL.
//        @group    files, images
// @visibility external
//<
// NOTE: Caches the combined appDir + imgDir.
setAppImgDir : function (URL) {
    // If the URL passed in is not absolute, explicitly combine it with the app dir
    // This means if we generate Img HTML and end up showing it in another frame it'll still
    // pick up the correct image (required for EG printing support)
    this._directoryCache.APPIMG =
            this.combineURLs(this.getAppDir(), URL != null ? URL : "[APP]images/");
},

//>    @classMethod    Page.getAppImgDir()
// Return the directory for app-specific images.
//
//        @return    (string)    URL for page-specific images.
//        @group    files, images
// @visibility external
//<
getAppImgDir : function (imgDir) {
    if (imgDir != null) {
        // expand any [SKIN], [SKINIMG], or similar prefix to the associated dir
        if (isc.startsWith(imgDir, this._$leftBracket)) imgDir = this.getURL(imgDir);
        // specifically check for an imgDir that has been specified as an absolute path.
        if (isc.startsWith(imgDir, isc.slash) || this.getProtocol(imgDir) != isc.emptyString) {
            return imgDir;
        }
        return this._directoryCache.APPIMG + imgDir;
    }
    return this._directoryCache.APPIMG;
},

//>    @classMethod    Page.setAppFilesDir()
// Specify the directory for miscellaneous app-specific files <b>other than</b> images, such as
// +link{HTMLFlow.contentsURL,HTML fragments}, +link{ViewLoader,loadable views},
// XML or JSON flat data files, videos, etc.
// <P>
// This URL also becomes available via the prefix "[APPFILES]" for +link{rpcRequest.actionURL}.
// <P>
// Defaults to the value of +link{Page.getAppDir()}, that is, the current directory.
//
//        @param    [URL]        (string)    New app files URL.
//        @group    files, images
// @visibility external
//<
// NOTE: Caches the combined appDir + imgDir.
setAppFilesDir : function (URL) {
    this._directoryCache.APPFILES = this.combineURLs(this.getAppDir(), URL);
},

//>    @classMethod    Page.getAppFilesDir()
// Returns the directory for application-specific files (other than images).
//
//        @param    [URL]        (string)    New app files URL.
//        @group    files, images
// @visibility external
//<
getAppFilesDir : function (URL) {
    return this._directoryCache.APPFILES;
},

//    Isomorphic-supplied file locations
// ---------------------------------------------------------------------------------------

//>    @classMethod    Page.setIsomorphicDir()
// Specify the root directory for Isomorphic-supplied files - the directory containing
// the <code>modules/</code> and <code>system/</code> subdirectories shipped as part of
// the SmartClient package.
// <P>
// Note that this property is commonly specified directly in the bootstrap HTML file
// by setting <code>window.isomorphicDir</code> before loading the SmartClient library files.
//
//        @param    [URL]        (string)    New IsomorphicDir URL.
//        @group    files
// @visibility external
//<
setIsomorphicDir : function (URL) {
    this._directoryCache.ISOMORPHIC =
            this.combineURLs(this.getAppDir(), URL != null ? URL : "../isomorphic/");

    // call setSkinDir() and setHelperDir() to reset those cached values
    this.setIsomorphicClientDir();
    this.setIsomorphicDocsDir();

    // re-direve toolsDir unless it was explicitly set on the page
    if (!window.isomorphicToolsDir) this.setIsomorphicToolsDir();
},

//>    @classMethod    Page.getIsomorphicDir()
//        Return the root directory for Isomorphic-specific files.
//
//        @return    (string)    IsomorphicDir URL.
//        @group    files
// @visibility external
//<
getIsomorphicDir : function () {
    return this._directoryCache.ISOMORPHIC;
},

//>    @classMethod    Page.setIsomorphicToolsDir()
// Specify the root directory for Isomorphic-supplied tools.  Typicall tools/ under webRoot.
// <P>
// Note that this property is commonly specified directly in the bootstrap HTML file
// by setting <code>window.isomorphicToolsDir</code> before loading the SmartClient library
// files.  If unset, it defaults to $isomorphicDir/../tools/
//
//        @param    [URL]        (string)    New IsomorphicToolsDir URL.
//        @group    files
// @visibility external
//<
setIsomorphicToolsDir : function (URL) {
    this._directoryCache.TOOLS =
            this.combineURLs(this.getIsomorphicDir(), URL != null ? URL : "../tools/");
},

//>    @classMethod    Page.getIsomorphicToolsDir()
//        Return the root directory for Isomorphic-supplied tools dir.
//
//        @return    (string)    IsomorphicToolsDir URL.
//        @group    files
// @visibility external
//<
getIsomorphicToolsDir : function () {
    return this._directoryCache.TOOLS;
},

// Note skins groupDef is in Canvas.js

//>    @classMethod    Page.setSkinDir()
//        Specify the URL for media that's part of the skin
//
//        @param    [URL]        (string)    New skinDir URL
//        @group    skins, files, images
// @visibility external
//<
setSkinDir : function (URL) {
    this._directoryCache.SKIN =
            this.combineURLs(this.getAppDir(), URL != null ? URL : "[ISOMORPHIC]/skins/standard/");
    // remember the skin image directory
    this._directoryCache.SKINIMG = this._directoryCache.SKIN + "images/";

    if (isc.Canvas) isc.Canvas._blankTemplate = isc.Canvas._blankURL = null;
},

//>    @classMethod    Page.getSkinDir()
//        Return the directory for media that's part of the skin
//
//        @return    (string)    base URL for skin media
//        @group    files, images
// @visibility external
//<
getSkinDir : function () {
    return this._directoryCache.SKIN;
},


//>    @classMethod    Page.getSkinImgDir()
//        Return the directory for a skin image.
//
//        @param    [imgDir]    (URL)        Partial URL (relative to Page._skinDir) where the image lives.
//                                        If not supplied, will use "images/"
//        @return                (string)    URL for page-specific images.
//        @group    files, images
// @visibility external
//<
getSkinImgDir : function (imgDir) {
    if (imgDir == null) return this._directoryCache.SKINIMG;
    return this.combineURLs(this._directoryCache.SKIN, imgDir);
},

// Internal directory structures
// ---------------------------------------------------------------------------------------
// Applications need to tell us the relative path to the "isomorphic/" directory and may
// relocate the skin outside of the "isomorphic/" area, however, none of the rest of
// the structure under "isomorphic/" is really intended to be changed.  The most likely reason
// to actually do so might involve needing to move the helpers dir to password protect the log
// window.

//>    @classMethod    Page.setIsomorphicClientDir()
//        Specify the root directory for Isomorphic client files.
//
//        @param    [URL]        (string)    New URL for root of client files.
//        @group    files
//<
// NOTE: not visible: we don't actually want customers to relocate the client dir
setIsomorphicClientDir : function (URL) {
    this._directoryCache.ISOMORPHIC_CLIENT =
            this.combineURLs(this.getAppDir(), URL != null ? URL : "[ISOMORPHIC]/system/");

    // call setSkinDir() and setHelperDir() to reset those cached values
    this.setSkinDir();
    this.setHelperDir();
},

//>    @classMethod    Page.getIsomorphicClientDir()
//        Return the root directory for Isomorphic client files.
//
//        @return    (string)    URL for root of client files.
//        @group    files
//<
getIsomorphicClientDir : function () {
    return this._directoryCache.ISOMORPHIC_CLIENT;
},

//>    @classMethod    Page.setIsomorphicDocsDir()
//        Specify the root directory for Isomorphic documentation and example files.
//
//        @param    [URL]        (string)    New URL for root of documentation and example files.
//        @group    files
//<
// NOTE: not visible: we don't actually want customers to restructure the SDK
setIsomorphicDocsDir : function (URL) {
    this._directoryCache.ISOMORPHIC_DOCS =
            this.combineURLs(this.getAppDir(), URL != null ? URL : "[ISOMORPHIC]/system/reference/");
    this.setIsomorphicDocsSkinDir();
},

//>    @classMethod    Page.getIsomorphicDocsDir()
//        Return the root directory for Isomorphic documentation and example files.
//
//        @return    (string)    URL for root of documentation and example files.
//        @group    files
//<
getIsomorphicDocsDir : function () {
    return this._directoryCache.ISOMORPHIC_DOCS;
},

setIsomorphicDocsSkinDir : function (URL) {
    this._directoryCache.ISO_DOCS_SKIN =
           this.combineURLs(this.getIsomorphicDocsDir(), URL != null ? URL : "skin/");
},
getIsomorphicDocsSkinDir : function () {
    return this._directoryCache.ISO_DOCS_SKIN;
},



//>    @classMethod    Page.setHelperDir()
//        Specify the directory for Isomorphic-specific helper files.
//
//        @param    [URL]        (string)    New helperDir URL.
//        @group    files, images
//<
// NOTE: not visible: we don't actually want customers to relocate the helpers dir
setHelperDir : function (URL) {
    this._directoryCache.HELPERS =
            this.combineURLs(this.getAppDir(), URL != null ? URL : "[ISOMORPHIC_CLIENT]/helpers/");
},

//>    @classMethod    Page.getHelperDir()
//        Return the directory for Isomorphic supplied helper files.
//
//        @return    (string)    URL for Isomorphic supplied helper files.
//        @group    files, images
//<
getHelperDir : function () {
    return isc.Page._directoryCache.HELPERS;
},

// ---------------------------------------------------------------------------------------

_isRelativeURL : function (url) {
    return this.getProtocol(url) == isc._emptyString && !isc.startsWith(url, isc.slash);
},

//>    @classMethod    Page.getImgURL()
// Return the full URL for app-specific or skin image.
// <P>
// To use a skin image, start the URL with "[SKIN]".  Any other relative URL is assumed
// relative to the +link{Page.getAppImgDir(),appImgDir}.
//
//        @param    src            (SCImgURL)    Local file name for the image.
//        @param    [imgDir]    (string)    User-specified image directory,
//                                        local to
//        @return                (string)    URL for the image.
//        @group    files, images
// @visibility external
//<

_skinPrefix : "[SKIN]",
_skinSlashPrefix : "[SKIN]/",
getImgURL : function (src, imgDir, assumeRelativeSrc) {


    // get the full URL for an image
    var baseDir;
    if (isc.startsWith(src, this._skinPrefix)) {
        baseDir = isc.Page.getSkinImgDir(imgDir);
        // NOTE: account for "[SKIN]/" as well; ignore the slash
        var trim = isc.startsWith(src, this._skinSlashPrefix) ? 7 : 6;
        src = src.substring(trim);
    } else {
        baseDir = assumeRelativeSrc ? null : isc.Page.getAppImgDir(imgDir);
    }
    return isc.Page.combineURLs(baseDir, src);
},

_$leftBracket : "[",
_$dotSlash : "./",

//>    @classMethod    Page.getURL()
// Return a full URL for a relative path that uses a special prefix such as "[APPFILES]" or
// "[SKIN]".
// <P>
// For images, use +link{Page.getImgURL()} instead.
//
//        @param    fileName    (string)    Local file name for the image.
//        @return                (string)    URL for the image.
//        @group    files, images
// @visibility external
//<
getURL : function (URL) {


    // check for a special prefix
    if (isc.startsWith(URL, this._$leftBracket)) {
        var endIndex = URL.indexOf("]");
        if (endIndex > 0) {
            var directoryName = URL.substring(1,endIndex).toUpperCase(),
                cachedDirectory = isc.Page._directoryCache[directoryName];
            // substitute if we hit a known prefix
            if (cachedDirectory != null) {
                URL = isc.Page.combineURLs(cachedDirectory,
                                           URL.substring(endIndex+(URL.charAt(endIndex+1)!="/"?1:2)));
            //>DEBUG
            } else {
                this.logDebug("getURL("+URL+"): couldn't find cached directory " + directoryName);
            //<DEBUG
            }
        //>DEBUG
        } else {
            this.logDebug("getURL("+URL+"): didn't find matching ']' in URL");
        //<DEBUG
        }
    }
    return URL;
},

//>    @classMethod    Page.combineURLs()
//        Combine a "masterURL" and a "localURL" into a single URL.
//        If the localURL is a fully specified URL (starts with "http:", "https:" or "file:"),
//            we use that.
//
//        If the localURL is a relative URL, combine with the masterURL
//        to a single URL.
//
//        @param    masterURL    (string)    Master URL.
//        @param    localURL    (string)    Local URL.
//        @return                (string)    Combined URL.
//        @group    files
//<
_$dotdot:"..",
combineURLs : function (masterURL, localURL) {

    if (!isc.isA.String(localURL)) return masterURL;



    if (isc.startsWith(localURL, this._$leftBracket)) {
        // URL appears to contain a special directory name
        return this.getURL(localURL);
    }

    var ns = isc._emptyString;

    // if local directory was specified as a full URL, simply return that
    if (masterURL == null || masterURL == ns || isc.Page.getProtocol(localURL) != ns) {
        return localURL;
    }

    var slash = isc.slash;



    var masterProtocol = isc.Page.getProtocol(masterURL);

    if (isc.startsWith(localURL, slash)) {


        // localURL is absolute; combine with just the protocol/hostName from masterURL

        //if (isc.Log) isc.Log.logWarn("absolute local URL: " + localURL +
        //                             ", base master is: " + masterURL +
        //                             ", masterProtocol: " + masterProtocol);

        if (isc.isAn.emptyString(masterProtocol)) {
            // if master URL has no protocol and hence no host, empty it so that we we will the
            // already absolute "localURL" unchanged
            masterURL = isc.emptyString;
        } else if (masterURL.indexOf(slash, masterProtocol.length) != -1) {
            // We want to chop off everything in the master URL after the first "/"
            masterURL = masterURL.substring(0, masterURL.indexOf(slash, masterProtocol.length));
        }

    // eliminate any "./" entries in the localURL
    // go up a directory in the masterURL for any "../" in the localURL
    } else     if (localURL.indexOf(this._$dotSlash) > -1) {

        //alert("backups in local URL: " + localURL);

        // break up masterURL into protocol and directories
        // break up localURL into directories
        masterURL = masterURL.substring(masterProtocol.length, masterURL.length-1);
        var masterDirs = masterURL.split(slash),
            localDirs = localURL.split(slash)
        ;
        // the first "dir" is actually the host
        var masterHost = masterDirs[0];
        masterDirs.shift();

        while (localDirs[0] == isc.dot || localDirs[0] == this._$dotdot) {
            // if ".", just skip it in the localDirs
            if (localDirs[0] == isc.dot) {
                localDirs.shift(); // take "." off front
                continue;
            }

            // otherwise it's ".." -- take ".." off front of local dir
            localDirs.shift();
            // and go up one directory in the master dir (if possible)
            if (masterDirs.length == 0) break;
            masterDirs.pop(); // take last segment off master dir
        }

        masterURL = masterProtocol + masterHost + slash;
        if (masterDirs.length > 0) masterURL += masterDirs.join(slash) + slash;
        localURL = localDirs.join(slash);
    }
    //return the combined URLs
    return masterURL + localURL;
},

//>    @classMethod    Page.getProtocol()
//        Return the protocol for a given URL.
//        Returns the full protocol (eg: "http://"), or
//        the empty string ("") if protocol was not understood.
//        @param    URL        (URL)        URL to get protocol for.
//        @return            (string)    Protocol for the URL, or "" if not found/recognized.
//        @group    files
//        @see    Page._protocolsURLs
//<
getProtocol : function (URL) {

    for (var i = 0; i < isc.Page.protocolURLs.length; i++) {
        if (isc.startsWith(URL, isc.Page.protocolURLs[i])) return isc.Page.protocolURLs[i];
    }
    return isc._emptyString;
},

getLastSegment : function (url) {
    if (url == null) return isc.emptyString;
    var slashIndex = url.lastIndexOf(isc.slash);
    if (slashIndex == -1) return url;
    return url.substring(slashIndex+1);
},

// XHTML
// ---------------------------------------------------------------------------------------


isXHTML : function () {
    if (this._isXHTML != null) return this._isXHTML;
    if (isc.Browser.isIE) return false;
    var wd = this.getWindow();
    return (this._isXHTML = (this.getDocument().constructor == this.getWindow().XMLDocument));
},


//    Text direction
// ---------------------------------------------------------------------------------------

//> @classMethod Page.isRTL()
//
// Return whether the page text direction is right to left.  If you set "DIR=RTL" in the BODY tag of
// the page, then this method will return true.  If you set "DIR=LTR" then this method will return
// false.
//
// @return (Boolean) true if Page text direction is RTL, false otherwise
// @group RTL
// @visibility external
//<

isRTL : function () { return this.getTextDirection() == isc.Canvas.RTL },

//>    @classMethod    Page.getTextDirection()
//        @group    textDirection
//        Return the text direction of the page for right-to-left
//        language support.  Returned value will be:
//                * Page.LTR (left to right, eg: English), or
//                * Page.RTL (right to left, eg: Arabic)
//<
_$body:"body", _$html:"html", _$direction:"direction",
getTextDirection : function () {
    // if the textDirection of the page has never been set,
    if (this.textDirection == null) {
        var strDirection;
        var htmlTag = document.getElementsByTagName(this._$body)[0] ||
                      document.getElementsByTagName(this._$html)[0]

        if(document.defaultView && document.defaultView.getComputedStyle){
            var computedStyle = document.defaultView.getComputedStyle(
                            htmlTag, isc.emptyString);
            strDirection = computedStyle ?
                            computedStyle.getPropertyValue(this._$direction) : null;
        } else if (htmlTag.currentStyle){
            strDirection = htmlTag.currentStyle[this._$direction];
        }

        // Didn't have the APIs to get a value or it returned null - back off to looking
        // directly at the "dir" property on the body element

        var dontCache;
        if (strDirection == null) {
            dontCache = true;

            var docElement = document.documentElement,
                body = document.body;

            // check body before document element, since it overrides.  (NOTE: empty string
            // is false)
            strDirection = (body ? body.dir : null) || docElement.dir;
        }
        if (strDirection == null || strDirection == isc.emptyString) {
            strDirection = this.LTR;
        } else {
            strDirection = strDirection.toLowerCase();
        }
        // don't save direction as LTR unless the body has been created, in case
        // getTextDireciton() is called in an incomplete document
        if (!dontCache && document.body != null) this.textDirection = strDirection;
        return strDirection;
    }

    // return the direction stored in the page object
    return this.textDirection;
},




//
//    Dynamic loading/writing of various page structures for you
//


//>    @classMethod    Page.loadStyleSheet()
//        Load a styleSheet for this application.
//
//        The styleSheetURL parameter can use any special directories, eg:<br>
//      &nbsp;&nbsp;<code>Page.loadStylesheet("[SKIN]/skin_styles.css")</code><br>
//      or<br>
//      &nbsp;&nbsp;<code>Page.loadStylesheet("[APP]/app_styles.css")</code>.
//      <P>
//        If you don't specify a special directory, the app directory
//            will be assumed.
//        <P>
//        Note:   If the document's ONLOAD handler has already fired, this
//                will have no effect.
//
//        @param    styleSheetURL    (URL)    URL to the stylesheet.
//
//        @group    skins, files, images
//  @visibility external
//<
loadStyleSheet : function (styleSheetURL, wd, callback) {
    var url = isc.Page.getURL(styleSheetURL);

    // If Page.addVersionToSkinCSS has been set to true, lets append an isc_version parameter to
    // the url for caching/cache-busting.
    if (this._addVersionToSkinCSS) {
        var uriBuilder = isc.URIBuilder.create(url);
        uriBuilder.setQueryParam("isc_version", isc.versionNumber);
        url = uriBuilder.uri;
    }

    var html = "<link rel='stylesheet' type='text/css' href=\"" + url + "\"\/>";
    if (wd == null) wd = window;

    if (isc.Page.isLoaded() && wd == window) {
        if (isc.FileLoader) {
            // The FileLoader preemptively loads the css that load_skin.js loads via a call to
            // loadStyleSheet and stores a marker for us
            var loadedSkins = isc.FileLoader._loadedSkins;

            if (loadedSkins != null) {
                for (var i = 0; i < loadedSkins.length; i++) {
                    var loadedURL = loadedSkins[i];
                    // FileLoader will keep whatever window.isomorphicDir was set to, including
                    // relative paths like "../isomorphic", but Page transforms isomorphicDir
                    // and other base URLs into fully qualified URLs by combining with
                    // the page URL (appDir).  Fully qualify FileLoader URLs before comparing
                    // (and update the FileLoader cache so we don't have to repeat this
                    // conversion again each time)
                    if (!loadedURL.startsWith("http")) {
                        loadedURL = loadedSkins[i] = isc.Page.combineURLs(this.getAppDir(), loadedURL);
                    }
                    if (url.indexOf(loadedURL) != -1) {
                        this.logDebug("CSS file " + loadedURL +
                                      " already loaded by FileLoader - not loading again");
                        return;
                    }
                }
            }

            isc.FileLoader.loadCSSFile(url, callback);
        } else {
            //>DEBUG
            this.logWarn("isc.Page.loadStylesheet('"+styleSheetURL+
                         "') called after page load.  Stylesheet not loaded.");
            //<DEBUG
        }
    } else {
        if (this.isXHTML()) {
            // XHTML: no document.write(), and body element may not exist yet.
            // Per XHTML spec <link> elements appear in <head>, so dynamically add
            // to <head> regardless of whether body exists
            var doc = this.getDocument(),
                head = doc.documentElement.firstChild,
                // NOTE: namespace is required or you create a valid <link> element that does
                // nothing because it's not treated as an HTMLLinkElement
                elem = doc.createElementNS(doc.documentElement.namespaceURI, "link");
            elem.rel = "stylesheet";
            elem.type = "text/css";
            elem.href = url;

            head.appendChild(elem);
            this.logWarn("added stylesheet DOM style");
        } else {
            wd.document.write(html);
        }
    }
},


//>    @classMethod    Page.resizeTo()
//        Resize the outer portion of the window to a specific width and height.
//        @group    sizing
//
//        @param    width    (number)    new width for the window
//        @param    height    (number)    new height for the window
// @visibility external
//<
resizeTo : function (width, height) {
    window.resizeTo(width, height);
},

//>    @classMethod    Page.moveTo()
//        Move the window to a specified top and left in screen coordinates.
//
//        @param    left    (number)    new left coordinate for window
//        @param    top        (number)    new top coordinate for window
// @visibility external
//<
moveTo : function (top, left) {
    window.moveTo(top, left);
},

//>    @classMethod    Page.scrollTo()
//        Scroll the window to a specified top and left coordinate.
//
//        @param    left    (number)    new left coordinate for window
//        @param    top        (number)    new top coordinate for window
// @visibility external
//<
scrollTo : function (top, left) {
    window.scroll(top, left);
},

//>    @classMethod    Page.getWidth()
// Get the width of the visible portion of the window, not including browser chrome or the
// scrollbar area.
// <P>
// See also +link{Page.getOrientation()}.
//        @group    sizing
//
//        @param    [wd]        (object)    the window object
//
//        @return    (number)    width of the page
// @visibility external
//<
leaveScrollbarGap : isc.Browser.isMoz && isc.Browser.geckoVersion < 20051107,

getWidth : (isc.Browser.isNS ?
    // isNS: Netscape browsers (inc.Moz, Firefox) and also Safari

    function (wd, recalculate) {

        if (!wd) wd = window;


        recalculate = recalculate || (isc.Browser.isMoz && isc.Browser.geckoVersion >= 20080529);
        if (isc.Browser.isMoz && wd == window && !recalculate) {


            if (this.width != null) {
                return this.width - (this.leaveScrollbarGap ?

                                      (isc.Element ? isc.Element.getNativeScrollbarSize() : 16) :
                                      0
                                    );
            }

            // If we were unable to get the page width, return an arbitrary value (500)
            // this is probably due to the page not being fully loaded.
            // This method is commonly called in order to size percentage-sized widgets
            // correctly - therefore fire a page-resized event on load in this case
            // to fix any incorrectly sized percentage width widgets.

            //>DEBUG
            // Warn this at the 'info' level - Not much a developer can do about this, but it
            // can be valuable for us to see the issue.
            this.logInfo("NOTE: isc.Page.getWidth() unable to determine page width.  Returning 500",
                         "sizing");
            //<DEBUG
            return 500;

        } else {
            // If the body has been written out, use body.clientWidth to ensure we get the
            // size inside any scrollbars

            var isFFPre15 = isc.Browser.geckoVersion != null && isc.Browser.geckoVersion < 20051111;
            var useClientWidth = !isc.Browser.isAndroid && !this.leaveScrollbarGap && !isFFPre15 && wd.document.body != null,
                width;

            if (useClientWidth) {

                var documentBody = isc.Browser.isStrict
                                    ? wd.document.documentElement : wd.document.body;
                if (documentBody != null) width = documentBody.clientWidth;
            }

            // Catch the case where we didn't pick up a width from the body

            if (width == null || width == 0) {

                width = wd.innerWidth;
            }
            if (wd == window) this.width = width;
            return width;
        }
    }
:// isc.Browser.isIE || isc.Browser.isOpera
    function (wd) {
        if (!wd) wd = window;
        var documentBody = wd.document.body;
        if (isc.Browser.isStrict && (!isc.Browser.isOpera || isc.Browser.minorVersion >= 9.5))
            documentBody = wd.document.documentElement;

        if (documentBody) {
            // NOTE: MacIE will show scrollbars if you draw within a (native) scrollbar width of
            // the edge of the page, so the available space is less than clientWidth.
            return documentBody.clientWidth
        } else {

            // As in the Moz case, if we were unable to determine the page width, fire a
            // page-resized event on load to fix any incorrectly sized percentage width
            // widgets.
            if (!isc.Page.isLoaded()) {
                isc.Page.setEvent("load", "isc.EH._pageResize()", isc.Page.FIRE_ONCE);
            }
            //>DEBUG
            this.logWarn("NOTE: isc.Page.getWidth() called before <BODY> tag was written out -- " +
                         "value cannot be determined.  Returning 500");
            //<DEBUG
            return 500;
        }
    }
),

// Does this page have body overflow explicitly set to hidden (suppresses scrollbars)?

getBodyOverflow : function () {
    if (this._bodyOverflow == null) {
        var overflow;
        var documentBody = document.body;
        if (documentBody && documentBody.style) {
            overflow = documentBody.style.overflow;
        }

        this._bodyOverflow = (overflow == null || overflow == "") ? "auto" : overflow.toLowerCase();
    }

    return this._bodyOverflow;
},


//>    @classMethod    Page.getHeight()
// Get the height of the visible portion of the window, not including browser chrome or the
// scrollbar area.
// <P>
// See also +link{Page.getOrientation()}.
//        @group    sizing
//
//        @param    [wd]        (object)    the window object
//
//        @return    (number)    height of the page
// @visibility external
//<
getHeight : (isc.Browser.isNS ?
    function (wd, recalculate) {
        if (!wd) wd = window;
        // see comments in getWidth()
        recalculate = recalculate || (isc.Browser.isMoz && isc.Browser.geckoVersion >= 20080529);
        if (isc.Browser.isMoz && wd == window && !recalculate) {

            if (this.height != null) return this.height;
            return 500;
        } else {
            // If the body has been written out, use body.clientWidth to ensure we get the
            // size inside any scrollbars




            var useClientHeight = ((!isc.Browser.isAndroid && isc.Browser.isMobileWebkit) ||
                                   (isc.Browser.geckoVersion == null ||
                                     isc.Browser.geckoVersion >= 20051111)
                                  )
                                    && wd.document.body != null,
                height;

            if (useClientHeight) {
                height = (isc.Browser.isStrict ? wd.document.documentElement : wd.document.body).clientHeight;
            }
            if (height == null || height == 0) {

                height = wd.innerHeight;
            }


            if (isc.Browser.isIPad && isc.Browser.isMobileSafari && isc.Browser.iOSVersion == 7) {
                if (this.getOrientation() === "landscape") {
                    var pageZoom = this._getPageZoom();
                    //var heightOffset = (20 / pageZoom) << 0;
                    //height -= heightOffset;
                    height = ((692 - 20) / pageZoom) << 0;
                    document.body.style.height = height + "px";
                    document.documentElement.style.height = height + "px";
                } else {
                    document.body.style.height = "";
                    document.documentElement.style.height = "";
                }
            }


            if (isc.Browser.isTouch && (isc.Browser.isAndroid || isc.Browser.isRIM)) {
                if (this._oldHeight == null) {
                    this._oldHeight = height;
                    this._oldWidth = isc.Page.getWidth(wd, recalculate);
                    this._prevSizeOrientation = this.getOrientation();
                } else {

                    var orientation = this.getOrientation();
                    if (height > this._oldHeight ||
                        Math.abs(height - this._oldHeight) <= 100 ||
                        orientation != this._prevSizeOrientation)
                    {
                        this._prevSizeOrientation = orientation;
                        this._oldHeight = height;
                        this._oldWidth = isc.Page.getWidth(wd, recalculate);
                    } else {
                        height = this._oldHeight;
                    }
                }
            }

            if (wd == window) this.height = height;
            return height;
        }
    }
: // isc.Browser.isIE || isc.Browser.isOpera
  function (wd) {
        if (!wd) wd = window;
        var documentBody = wd.document.body;
        // In Opera it appears that document.body.clientWidth / height returns the size
        // (inside scrollbars) even in strict mode
        if (isc.Browser.isStrict && (!isc.Browser.isOpera || isc.Browser.minorVersion >= 9.5))
            documentBody = wd.document.documentElement;
        if (documentBody) {
            return documentBody.clientHeight;
        } else {
            //>DEBUG
            this.logWarn("NOTE: isc.Page.getHeight() called before <BODY> tag was written out -- value cannot be determined.  Returning 500");
            //<DEBUG
            return 500;
        }
    }
),

//> @type PageOrientation
// Is this page being viewed in landscape or portrait orientation? Typically used with
// mobile devices.
//
// @value "landscape" Landscape orientation: page is wider than it is tall.
// @value "portrait" Portrait orientation: page is taller than it is wide.
// @visibility external
//<


//> @classMethod Page.getOrientation()
// Is the current page wider than it is tall ("landscape" orientation) or the reverse
// ("portrait" orientation). Note that the +link{pageEvent,orientationChange page event}
// will be fired whenever the page orientation changes.
// <P>
// This method is typically useful for apps developed for display on mobile devices,
// though it will also return a valid value when running against a desktop browser.
// See also +link{group:mobileDevelopment,this discussion} on building applications
// for mobile devices
// @return (PageOrientation) current page orientation
// @group mobileDevelopment
// @visibility external
//<
getOrientation : function () {



    var width = this.getWidth();
    if (isc.EH != null && width == isc.EH._currentWidth) return isc.EH.currentOrientation;

    var isPortrait;
    if (isc.Browser._supportsScreenOrientationAPI) {
        isPortrait = String(window.screen.orientation.type).contains("portrait");
    } else if (isc.Browser.isIPhone || isc.Browser.isIPad) {
        isPortrait = window.orientation == 0 || window.orientation == 180;
    } else if ("matchMedia" in window) {

        var portraitOrientation = window.matchMedia("(orientation: portrait)");
        isPortrait = portraitOrientation && portraitOrientation.matches;
    }
    if (isPortrait == null) {
        isPortrait = this.getHeight() >= width;
    }
    return isPortrait ? "portrait" : "landscape";
},

_getViewportTag : function (dontCreate) {
    var head = document.head || document.getElementsByTagName("head")[0];
    if (head == null) {
        if (dontCreate) return null;
        head = document.createElement("head");
        var body = document.body || document.getElementsByTagName("body")[0];
        body.parentNode.insertBefore(head, body);
    }

    var metaTags = head.getElementsByTagName("meta"),
        vpTag = null;
    // Remove all but the last viewport <meta> tag and select the last one.
    for (var i = 0; i < metaTags.length; /*empty*/) {
        if (metaTags[i].name == "viewport") {
            if (vpTag != null) {
                vpTag.parentNode.removeChild(vpTag);
                vpTag = metaTags[i - 1];
            } else {
                vpTag = metaTags[i];
                ++i;
            }
        } else ++i;
    }
    if (vpTag == null && !dontCreate) {
        vpTag = document.createElement("meta");
        vpTag.name = "viewport";
        head.appendChild(vpTag);
    }

    return vpTag;
},

_applyDefaultViewport : function () {
    if (window.isc_useDefaultViewport == false) return;

    var extraVpProps = {};


    if (isc.Browser._supportsMinimalUI && window.isc_useMinimalUI != false) {
        extraVpProps["minimal-ui"] = null;

        isc.Canvas.defaultPageSpace = (isc.Page.getOrientation() === "landscape" ? 20 : 0);
        window.addEventListener("orientationchange", function () {

            window.scrollTo(0, 0);
            isc.Canvas.setDefaultPageSpace(isc.Page.getOrientation() === "landscape" ? 20 : 0);
        }, true);
    }

    this.updateViewport(1.0, "device-width", null, false, extraVpProps);
},

// http://dev.w3.org/csswg/css-device-adapt/#parsing-algorithm
_parseViewportOptions : function (viewportContent) {
    var vpProps = {};
    if (isc.isA.String(viewportContent) && !isc.isAn.emptyString(viewportContent)) {
        // Remove all whitespace (horizontal tab, newline, carriage return, or space) and then
        // split on the separators comma and semicolon.
        var vpPropPairs = viewportContent.replace(/[\t\n\r ]+/g, "").split(/,|;/);
        for (var i = 0, len = vpPropPairs.length; i < len; ++i) {
            var vpPropPair = vpPropPairs[i];
            var eqPos = vpPropPair.indexOf('=');

            // It could be a valueless parameter (e.g. iOS 7.1's 'minimal-ui')
            if (eqPos <= 0) {
                vpProps[vpPropPair] = null;

            } else {
                // since viewport property names are case-insensitively-matched, lower case the prop name
                vpProps[vpPropPair.substring(0, eqPos).toLowerCase()] = vpPropPair.substring(eqPos + 1);
            }
        }
    }
    return vpProps;
},

//> @classMethod Page.updateViewport()
// This method only applies to browsers that support the special viewport meta tag, such as
// Mobile Safari running on the iPhone.
// <P>
// This method will dynamically change the viewport configuration, allowing you to set an
// initial size or scale level and enable / disable user-scaling. Typically this method will
// be called with a value for scale, width or height rather than passing in values for all
// three properties.
// <P>
// See Apple's Safari Web Content Guide on configuring the viewport for more information:
// +externalLink{https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html}
// <P>
// <i>Note:</i> Modifying the width/height or initial scale of the viewport has two user-visible
// effects:
// <ul>
// <li>HTML elements may reflow to fit the specified size (or the implied size calculated
//     from the specified scale level and the native device size).</li>
// <li>If the user has not scaled the application explicitly, and no other scaling or sizing
//     attributes were specified via a viewport meta tag for this page, the application will
//     zoom to specified scale level (or the scale level required to fit the specified viewport
//     size to the device's screen).</li>
// </ul>
// @param [scale] (float) Desired scale level where 1 indicates no scaling (each css pixel
//   will be displayed using 1px on the physical device). Pass in null to avoid setting
//   this property.
// @param [width] (Integer) Desired viewport width in pixels. This indicates how many pixels
//   should fit within the device screen. Pass in null to avoid setting this property.
// @param [height] (Integer) Desired viewport height in pixels. This indicates how many pixels
//   should fit within the device screen. Pass in null to avoid setting this property.
// @param [scalable] (Boolean) Should the user be able to scale the application (using
//   pinch gestures, double tapping, rotating the device, etc.)? Pass in null to avoid setting
//   this property.
//
// @group mobileDevelopment
// @see group:mobileDevelopment
// @visibility external
//<

updateViewport : function (scale, width, height, scalable, extraVpProps) {
    var vpTag = this._getViewportTag();

    // Parse the existing viewport parameters so that we preserve any extra viewport parameters
    // added by the application that we won't be changing.
    var vpProps = isc.addProperties(this._parseViewportOptions(vpTag.content), extraVpProps);

    if (width == null) width = vpProps["width"];
    if (height == null) height = vpProps["height"];
    if (scalable == null) scalable = vpProps["user-scalable"] != "no";

    if (scale != null) {
        if (isc.isA.Number(scale)) scale = scale.toFixed(2);
        vpProps["initial-scale"] = scale;
    }
    if (width != null) vpProps["width"] = width;
    if (height != null) vpProps["height"] = height;
    if (scalable != null) {
        vpProps["user-scalable"] = (scalable == false ? "no" : "yes");
        // setting user-scalable to 'no' seems to reliably disable pinch zooming
        // However on pivot the iPhone zooms by default and this seems to still occur
        // with user-scalable set to 'no'. If a desired 'scale' was specified,
        // setting the min/max scale to it appears to really disable scale on pivot
        if (scalable == false && scale != null) {
            vpProps["minimum-scale"] = vpProps["maximum-scale"] = scale;
        }
    }

    var content = [];
    for (var vpPropName in vpProps) {
        var val = vpProps[vpPropName];
        if (val == null) {
            content.push(vpPropName);
        } else {
            content.push(vpPropName + "=" + val);
        }
    }
    content = content.join(", ");


    if (isc.Browser.isMobileFirefox) {
        vpTag.insertAdjacentHTML("afterend", "<meta name='viewport' content='" + String.asAttValue(content) + "'>");
        var oldVpTag = vpTag;
        vpTag = vpTag.nextSibling;
        oldVpTag.parentNode.removeChild(oldVpTag);

    } else {
        vpTag.content = content;
    }
},

//> @groupDef browserZoom
// Native browser zooming, that is, the ability in most browsers to enlarge or shrink the entire
// web page, is currently only partly supported in specific browsers due to intractable browser
// bugs.
// <p>
// Support in this release is restricted to:
// <ul>
// <li> support for almost all components for Internet Explorer version 11 only, with known issues, almost all cosmetic (see below)
// <li> supported with the requirement that users refresh the page after changing zoom, with known cosmetic issues listed
//      below. See also the Detecting Zoom Changes section below.
// <li> no support for Chrome, Safari, other Webkit browsers - support not yet possible (see below)
// </ul>
// In addition, support guarantees are limited for zoom-related issues:
// <ul>
// <li> cosmetic issues that appear only in zoom mode will not be investigated
// <li> functional issues that appear only in zoom mode will be investigated if they are
//      reproducible, but the normal guarantee of a fix or workaround is not provided, since for
//      most zoom issues, there is no feasible way to work around the problem
// </ul>
// Known issues by browser are listed below.
//
// <h3>Chrome and Opera 15+</h3>
// <ul>
// <li>Core DOM APIs for querying position and sizing information of an element return fractional
//     values even though they shouldn't be, which can impact layout, scrolling, and event handling.
//     See issue
//     +externalLink{http://crbug.com/60837,60837}.</li>
// <li>The minimum font size feature can cause layout issues when the page zoom is decreased
//     but the page is not refreshed at the new zoom level.</li>
// <li>Chrome fails <code>background-image</code> related CSS Working Group tests with page zoom,
//     causing background images to draw oddly in certain cases. See issues
//     +externalLink{http://crbug.com/412914,412914} and
//     +externalLink{http://crbug.com/421331,421331}.</li>
// <li>Borders do not scale properly, causing layout issues, cosmetic issues where borders
//     do not line up with background images or appear beveled, and accessibility issues where
//     borders may be too thin. See issues
//     +externalLink{http://crbug.com/257220,257220},
//     +externalLink{http://crbug.com/382483,382483},
//     +externalLink{http://crbug.com/388879,388879},
//     +externalLink{http://crbug.com/406371,406371}, and
//     +externalLink{http://crbug.com/434720,434720}.</li>
// <li>Various issues affecting SVG drawings. See issues
//     +externalLink{http://crbug.com/181122,181122},
//     +externalLink{http://crbug.com/407159,407159}, and
//     +externalLink{http://crbug.com/421926,421926}.</li>
// </ul>
//
// <h3>Firefox</h3>
// <ul>
// <li>Firefox' approach to page zoom involves changing the layout rather than scaling the
//     entire page content by the zoom factor. This can cause layout and scrolling issues
//     if the zoom level is changed without refreshing the page. See
//     +externalLink{http://robert.ocallahan.org/2007/10/tale-of-two-zooms_19.html,A Tale Of Two Zooms}.</li>
// <li>Like Chrome and Safari, Firefox has a minimum font size feature which may cause layout
//     issues when the page zoom is changed without refreshing the page at the new zoom level.
//     See bug
//     +externalLink{https://bugzilla.mozilla.org/show_bug.cgi?id=912159,912159}.</li>
// <li>On Windows and Linux, native checkbox and radio button inputs do not scale with the
//     page zoom. See bug
//     +externalLink{https://bugzilla.mozilla.org/show_bug.cgi?id=400364,400364}.</li>
// <li>A focus outline might not be drawn around the focus element when zoomed. See bug
//     +externalLink{https://bugzilla.mozilla.org/show_bug.cgi?id=1050753,1050753}.</li>
// <li>The form element autocomplete box does not move when the page zoom is changed. See bug
//     +externalLink{https://bugzilla.mozilla.org/show_bug.cgi?id=731150,731150}.</li>
// </ul>
//
// <h3>Internet Explorer</h3>
// <ul>
// <li>IE may draw "seams" on +link{EdgedCanvas} objects, which are faint antialiasing artifacts
//     between the images used to make up the <code>EdgedCanvas</code>. This affects
//     +link{Canvas.showShadow,drop shadows} and showing edges with a high +link{Canvas.edgeSize}.
//     See issue
//     +externalLink{https://connect.microsoft.com/IE/Feedback/Details/808337/IE11-still-shows-odd-lines-on-image-nine-patched-with-CSS-background-position,808337}.</li>
// <li>Phantom borders may appear between table cells and other content that should be adjacent
//     with no separation. This issue is also thought to be the cause of a line appearing below
//     a selected +link{TabSet} tab at certain zoom levels. See issues
//     +externalLink{https://connect.microsoft.com/IE/Feedback/Details/808838/css-border-radius-and-zoom-issues,808838} and
//     +externalLink{https://connect.microsoft.com/IE/Feedback/Details/814033/weird-lines-when-zoom-set-to-150,814033}.</li>
// <li>SVG content may disappear at high zoom levels. See issue
//     +externalLink{https://connect.microsoft.com/IE/Feedback/Details/782997/svg-isnt-shown-on-high-zoom-levels-in-ie10,782997}.</li>
// </ul>
//
// <h3>Safari and WebKit</h3>
// <ul>
// <li>Core DOM APIs for querying sizing information of an element may overstate a dimension,
//     which can impact layout, scrolling, and event handling.</li>
// <li>Like Chrome and Firefox, Safari supports a minimum font size feature. This can cause layout issues
//     to appear when the page zoom is decreased but the page is not refreshed at the new zoom level.</li>
// <li>CSS <code>background-position</code> and background image clipping used for spriting may
//     be misapplied. This can introduce visual effects where different parts of a sprite are
//     visible. See bug
//     +externalLink{https://bugs.webkit.org/show_bug.cgi?id=45840,45840}.</li>
// <li>Background images can be misdrawn at certain zoom levels, where the first or last row
//     or column of pixels in the image "wrap" to the other side. See bug
//     +externalLink{https://bugs.webkit.org/show_bug.cgi?id=125133,125133}.</li>
// <li>Transparent 1px-wide gaps can appear around the content area of an +link{EdgedCanvas},
//     allowing content below the <code>EdgedCanvas</code> in stacking order to show through.
//     See bug
//     +externalLink{https://bugs.webkit.org/show_bug.cgi?id=122061,122061}.</li>
// <li>A phantom line may appear below a selected +link{TabSet} tab at certain zoom levels.</li>
// </ul>
//
// <h2>Detecting Zoom Changes</h2>
// There is no officially supported cross-browser way of detecting zoom, and current approaches
// rely on hacks that browser vendors seem willing to break or deprecate. These current approaches
// are described at
// +externalLink{http://stackoverflow.com/questions/1713771/how-to-detect-page-zoom-level-in-all-modern-browsers/,How to detect page zoom level in all modern browsers?}
// with a small proof-of-concept JavaScript library called +externalLink{https://github.com/tombigel/detect-zoom,detect-zoom}.
// <p>
// Although the detect-zoom library does not accurately determine the current zoom level, the library
// can be used in Firefox to detect when the zoom level <em>changes</em> so that a warning message
// can be displayed to the user.
// <p>
// Note that the latest version of <code>detect-zoom.min.js</code> that is committed to the GitHub
// repository is out of date. It is not recommended to use this file because it causes a runtime
// <code>TypeError</code> if the script is included before the document body has been
// created (see +externalLink{https://github.com/tombigel/detect-zoom/issues/41,issue #41}).
// To rebuild <code>detect-zoom.min.js</code>, you will need to install git, npm, and GNU make.
// Then at a terminal, run the following commands:
// <pre>git clone https://github.com/tombigel/detect-zoom.git
//cd detect-zoom
//npm install
//touch detect-zoom.js && make</pre>
// <p>
// <smartclient>
// Here is a complete example of using the detect-zoom library in a SmartClient project:
// <pre>&lt;script type="text/javascript" src="detect-zoom.min.js">&lt;/script>
//&lt;script type="text/javascript">
//var lastZoom = detectZoom.zoom();
//isc.Page.setEvent("resize", function () {
//    var newZoom = detectZoom.zoom();
//    if (newZoom != lastZoom) {
//        lastZoom = newZoom;
//        isc.warn("After changing the page zoom, you must refresh the page.");
//    }
//});
//&lt;/script&gt;</pre>
// </smartclient>
// <smartgwt>
// To use the detect-zoom library in your Smart&nbsp;GWT project:
// <ul>
// <li>Rebuild the <code>detect-zoom.min.js</code> script.</li>
// <li>Create a directory called <code>public</code> in the same directory as your GWT module.
//     For example, if your GWT module is located at <code>com/mycompany/Product.gwt.xml</code>
//     then create the <code>com/mycompany/public</code> directory if it does not already exist.
//     Copy the rebuilt <code>detect-zoom.min.js</code> script to this <code>public</code>
//     directory.</li>
// <li>Add the following &lt;script&gt; tag to your GWT module definition:
//     <pre>&lt;script src="detect-zoom.min.js"/&gt;</pre></li>
// <li>Add the following JSNI method that calls the detectZoom.zoom() API:
//     <pre>    public static native double detectZoom() /&#42;-{
//        return $wnd.detectZoom.zoom();
//    }-&#42;/;</pre></li>
// <li>When your module's <code>EntryPoint</code> is called, call the detectZoom() static
//     method and save the return value. Then add a window resize handler
//     (see +externalLink{http://www.gwtproject.org/javadoc/latest/com/google/gwt/user/client/Window.html#addResizeHandler(com.google.gwt.event.logical.shared.ResizeHandler),Window.addResizeHandler(com.google.gwt.event.logical.shared.ResizeHandler)})
//     that calls detectZoom() on resize, checking to see if a different value is returned.</li>
// </ul>
// Here is a complete example:
// <pre>import com.google.gwt.core.client.EntryPoint;
//import com.google.gwt.event.logical.shared.ResizeEvent;
//import com.google.gwt.event.logical.shared.ResizeHandler;
//import com.google.gwt.user.client.Window;
//import com.smartgwt.client.util.SC;
//
//public class MyEntryPoint implements EntryPoint {
//
//    public static native double detectZoom() /&#42;-{
//        return $wnd.detectZoom.zoom();
//    }-&#42;/;
//
//    &#64;Override
//    public void onModuleLoad() {
//        //...
//
//        Window.addResizeHandler(new ResizeHandler() {
//            private double lastZoom = detectZoom();
//
//            &#64;Override
//            public void onResize(ResizeEvent event) {
//                final double newZoom = detectZoom();
//                if (newZoom != lastZoom) {
//                    lastZoom = newZoom;
//                    SC.warn("After changing the page zoom, you must refresh the page.");
//                }
//            }
//        });
//    }
//}</pre>
// </smartgwt>
//
// @title Native Browser Zoom Support
// @treeLocation Concepts
// @visibility external
//<




_getPageZoom : function () {
    if (isc.Browser.isTouch) {
        var vpTag;

        var screenWidth = window.screen.width,
            screenHeight = window.screen.height;
        if (screenWidth <= document.documentElement.clientWidth) {
            if (this.getOrientation() === "portrait") {
                return Math.min(screenWidth, screenHeight) / window.innerWidth;
            } else {
                return Math.max(screenWidth, screenHeight) / window.innerWidth;
            }
        } else if ((vpTag = this._getViewportTag(true)) != null) {
            var vpProps = this._parseViewportOptions(vpTag.content);
            var scalable = vpProps["user-scalable"] != "no";
            if (!scalable) {
                // In Android WebViews (Android 4.3 or earlier), there is a bug where user-scalable=no
                // permanently sets the scale to 1.
                if (isc.Browser.isAndroidWebView && isc.Browser.androidMinorVersion < 4.4) {
                    return 1;
                } else {
                    var scale = parseFloat(vpProps["initial-scale"]);
                    if (!window.isNaN(scale)) return scale;

                    scale = parseFloat(vpProps["minimum-scale"]);
                    if (!window.isNaN(scale)) return scale;
                }
            } else {
                var minScale;
                if ("minimum-scale" in vpProps) {
                    minScale = parseFloat(vpProps["minimum-scale"]);
                } else {
                    minScale = parseFloat(vpProps["initial-scale"]);
                }

                if (!window.isNaN(minScale)) minScale;
            }
        }
    }

    return 1;
},

//>    @classMethod    Page.getScrollWidth()
//        Get the width of the window contents as they have been drawn.
//        If the page scrolls, this may be larger than the page.getWidth().
//        @group    sizing
//
//        @return    (number)    width of the page as drawn
// @visibility external
//<

getScrollWidth : function (theDoc) {
    var theDoc = theDoc || document;
    if (theDoc == null || theDoc.body == null) return 500;
    if (isc.Browser.isIE && isc.Browser.version >= 6) {
        // in IE6 in standards compliant mode (DOCTYPE HTML 4 Transitional/Strict), IE hides the
        // window viewport size in window.document.documentElement, and document.body only
        // reports the size of the drawn content.
        var width = Math.max(Math.max(theDoc.body.scrollWidth, theDoc.documentElement.clientWidth))

        // In IE9 with HTML5 doctype, in RTL mode the scroll width is reported under
        // documentElement.scrollWidth.

        if (isc.Browser.isStrict) width = Math.max(width, theDoc.documentElement.scrollWidth);
        return width;
    }
    return theDoc.body.scrollWidth;
},

//>    @classMethod    Page.getScrollHeight()
//        Get the height of the window contents as they have been drawn.
//        If the page scrolls, this may be larger than the page.getHeight().
//        @group    sizing
//
//        @return    (number)    height of the page as drawn
// @visibility external
//<
getScrollHeight : function (theDoc) {
        var theDoc = theDoc || document;

    if (theDoc == null || theDoc.body == null) {

        return this.getHeight();
    }

    // In most cases we can use document.body.scrollHeight
    // however in strict mode we have to look at document.documentElement instead.

        var scrollHeight = theDoc.body.scrollHeight;
    if (isc.Browser.isStrict) {
        var docElement = theDoc.documentElement;
        if (docElement) {
            var docScrollHeight = docElement.scrollHeight;
            if (!isc.isA.Number(docElement.scrollHeight)) {
                docScrollHeight = Math.max(docElement.offsetHeight, docElement.clientHeight);
    }
            if (docScrollHeight && docScrollHeight > scrollHeight) {
                scrollHeight = docScrollHeight;
        }
    }
    }
    return scrollHeight;
},

//>    @classMethod    Page.getScrollLeft()
//        Get the amount that the browser window has been scrolled horizontally.
//        @group    sizing
//
//        @return    (number)    horizontal scroll amount
// @visibility external
//<

getScrollLeft : (isc.Browser.isNS ?
    function (absCoordSpace) {
        var left = window.pageXOffset;

        if (isc.Page.isRTL() && !absCoordSpace) {
            left = isc.Canvas._adjustScrollLeftForRTL(left,
                        isc.Page.getScrollWidth(), isc.Page.getWidth(),
                        // going from negative origin coords to sc (zero based) coords
                        false,
                        // adjust for negative origin
                        true, false);
        }
        return left;
    }
: // isc.Browser.isIE
    function (absCoordSpace) {
        if (document == null || document.body == null) return 0;
        // in IE6 in standards compliant mode (DOCTYPE HTML 4 Transitional/Strict)
        // document.body.scrollLeft and document.body.scrollTop are always zero while
        // document.documentElement.scrollLeft and scrollTop reflect the actual browser scrollDeltas
        var left = (isc.Browser.isStrict ? document.documentElement.scrollLeft :
                                       document.body.scrollLeft);

        if (isc.Page.isRTL()) {
            var inverseCoords = isc.Browser.isIE9 && isc.Browser.isStrict;
            var scrollWidth = (inverseCoords || absCoordSpace) ? isc.Page.getScrollWidth() : null,
                width = (inverseCoords || absCoordSpace) ? isc.Page.getWidth() : null;

            if (inverseCoords) {
                left = isc.Canvas._adjustScrollLeftForRTL(left,
                            scrollWidth, width,
                            false, !inverseCoords, inverseCoords);
            }
            // at this point we have zero origin -- if we're asked for abs-coords space, we'll have
            // to further modify
            if (absCoordSpace) {
                left = isc.Canvas._adjustScrollLeftForRTL(left,
                        scrollWidth, width,
                        // we want to go from zero origin coords to negative origin coords
                        true, true);
            }
        }
        return left;
    }
),

//>    @classMethod    Page.getScrollTop()
//        Get the amount that the browser window has been scrolled vertically.
//        @group    sizing
//
//        @return    (number)    vertical scroll amount
// @visibility external
//<
getScrollTop : (isc.Browser.isNS ?
    function () {        return window.pageYOffset;            }
:// isc.Browser.isIE
    function () {
        if (document == null || document.body == null) return 0;
        // in IE6 in standards compliant mode (DOCTYPE HTML 4 Transitional/Strict)
        // document.body.scrollLeft and document.body.scrollTop are always zero while
        // document.documentElement.scrollLeft and scrollTop reflect the actual browser scrollDeltas
        return (isc.Browser.isStrict ? document.documentElement.scrollTop :
                                       document.body.scrollTop);
    }
),

//>    @classMethod    Page.getScreenWidth()
//        Get the width of the user's screen, in pixels.
// @visibility external
//<
getScreenWidth : function () { return screen.width },

//>    @classMethod    Page.getScreenHeight()
//        Get the height of the user's screen, in pixels.
// @visibility external
//<
getScreenHeight : function () { return screen.height },

//>    @classMethod    Page.getWindowRect()
//            return the coordinates of the window wd, or current window if wd isn't specified
//            in IE this doesn't include scrollbar size (if any)
//        @group    positioning, sizing
//
//        @param    [wd]        (object)    the window object
//
//        @return    (object)        {left:x, top:y, width:w, height:h}
//<
getWindowRect : function (wd) {
    if (!wd) wd = window;
    return {
        left:    (isc.Browser.isIE || isc.Browser.isOpera ? wd.screenLeft : wd.screenX),
        top:    (isc.Browser.isIE || isc.Browser.isOpera ? wd.screenTop : wd.screenY),
        width:    isc.Page.getWidth(wd),
        height:    isc.Page.getHeight(wd)
    };
},

setUnloadMessage : function (message) {
    if (message == null) window.onbeforeunload = null;
    else window.onbeforeunload = function () { return message; };
},

// --------------------------------------------------------------------------------------------

//>    @classMethod    Page.goBack()
// Go back in the browser's history.<br><br>
//
// If the history is empty and the window.opener is set, we assume we're a child window and just
// close the window.
//
// @visibility external
//<
goBack : function () {
    if (history.length == 0 && window.opener) {
        window.close();
    } else {
        history.back();
    }
},

//>    @classMethod    Page.print()
//        Print the window.  This brings up the print dialog and the user actually
//        starts printing.
//
//        Note: In IE4, you have to have already created a BODY tag in the window for this to work.
//
//        @param    wd    (window)    pointer to a window or frame to print
//                                default is the current window
//<
print : function (wd) {
    // default to the current window
    if (!wd) wd = window;
    if (wd.print) {
        wd.print();
    } else {
        // get a pointer to the document of the window
        var doc = wd.document;
        // if not found, bail
        if (!doc || !doc.body) {
            //>DEBUG
            this.logError("isc.Page.print() called on a window that doesn't have a document.body defined.  Exiting.");
            //<DEBUG
            return;
        }
        // The following works in Windows IE only
        // insert a built-in active-x control that will do the printing for us
        if (isc.Browser.isWin) {
            doc.body.insertAdjacentHTML('beforeEnd',
                '<OBJECT ID="printControl" WIDTH=0 HEIGHT=0 CLASSID="CLSID:8856F961-340A-11D0-A96B-00C04FD705A2"></OBJECT>'
            );
            // get a pointer to the printControl
            var control = doc.all.printControl;
            if (!control) {
                //>DEBUG
                this.logError("isc.Page.print() couldn't create or find print control.  Exiting.");
                //<DEBUG
                return;
            }

            // call the print command
            //    -- pass '2' below to skip the dialog box
            control.ExecWB(6, 1);
            // remove the control, since we don't need it anymore
            control.outerHTML = "";
        } else {
            alert("Choose 'Print...' from the File menu to print this page.");
        }
    }
},

// --------------------------------------------------------------------------------------------

// Observation from static scope; for comments, see class.observe
observe : function (object, methodName, action) {
    // create a dummy instance of Class so we can use it for calling "observe" statically
    var observer = isc.Class.create();
    return observer.observe(object, methodName, action);
},

//> @classMethod Page.waitFor()
// Wait for a method to fire on an object.
// <P>
// <code>waitFor</code> is similar +link{class.observe,observation}, but fires once only.
//
// @param object (Object) any SmartClient object, eg, a ListGrid
// @param methodName (String) name of a method on that object
// @param callback (Function) Callback to fire when the observed method completes
// @param [timeout] (Number) Optional timeout period (in milliseconds). If you want a timeout,
//                           you must also provide a timeoutCallback
// @param [timeoutCallback] (Function) Callback to fire if the timeout period elapses before the
//                                     observed method completes
// @return (boolean) whether observation succeeded.  Observation may fail due to null object,
//                   non-existent method or similar bad parameters
//
// @visibility external
//<
// waitFor: wait for a method to fire on another object
waitFor : function (object, method, callback, timeout, timeoutCallback) {
    var observer = isc.Class.create({
        _waitObject : object,
        _waitMethod : method,
        _waitCallback : callback,
        _fired : function (observed) {
            if (this._timerEvent) {
                isc.Timer.clear(this._timerEvent);
            }
            this.ignore(this._waitObject, this._waitMethod);
            this.fireCallback(this._waitCallback, "observed", [observed]);
            this.destroy();
        },
        _timeoutElapsed : function () {
            this.ignore(this._waitObject, this._waitMethod);
            this.fireCallback(this._timeoutCallback);
            this.destroy();
        }
    });
    isc.ClassFactory.addGlobalID(observer);
    var worked = observer.observe(object, method, function () {
        this._fired(object);
    });
    if (!worked) observer.destroy();

    if (timeout && timeoutCallback) {
        observer._timeoutCallback = timeoutCallback;
        observer._timerEvent = isc.Timer.setTimeout(function () { observer._timeoutElapsed(); }, timeout);
    }

    return worked;
},

//> @classMethod Page.waitForMultiple()
// Wait for methods to fire on multiple objects.
// <P>
// <code>waitForMultiple</code> is similar to +link{page.waitFor}, except that it does not fire
// its callback until all of the provided methods have fired.
//
// @param objects (Array) an array of objects, each of which consists of two properties:<br/>
//                        "object": any SmartClient object, eg a ListGrid<br/>
//                        "method": name of a method on that object
// @param callback (Function) Callback to fire when all observed methods have fired
// @param [timeout] (Number) Optional timeout period (in milliseconds). If you want a timeout,
//                           you must also provide a timeoutCallback
// @param [timeoutCallback] (Function) Callback to fire if the timeout period elapses before all
//                                     observed methods have fired
// @return (boolean) whether observation succeeded.  Observation may fail due to null objects,
//                   non-existent methods or similar bad parameters
//
// @visibility external
//<
waitForMultiple : function (objects, callback, timeout, timeoutCallback) {

    var allWorked = true;

    var supervisor = isc.Class.create({
        _waitObjects : objects,
        _waitObservers : [],
        _waitCallback : callback,
        _observedMethodFired : function (observer) {
            this._waitObservers.remove(observer);
            if (this._waitObservers.isEmpty()) {
                if (this._timerEvent) {
                    isc.Timer.clear(this._timerEvent);
                }
                this.fireCallback(this._waitCallback);
                this.destroy();
            }
        },
        _timeoutElapsed : function () {
            var obs = this._waitObservers;
            for (var i = 0; i < obs.length; i++) {
                obs[i].ignore(obs[i]._waitObject, obs[i]._waitMethod);
                obs[i].destroy();
            }
            this.fireCallback(this._timeoutCallback);
            this.destroy();
        }
    });

    for (var i = 0; i < objects.length; i++) {
        var observer = isc.Class.create({
            _waitObject : objects[i].object,
            _waitMethod : objects[i].method,
            _supervisor : supervisor,
            _fired : function (observed) {
                this.ignore(this._waitObject, this._waitMethod);
                this._supervisor._observedMethodFired(this);
                this.destroy();
            }
        });
        isc.ClassFactory.addGlobalID(observer);
        var action = (function (observed) {
            return function () {
                this._fired(observed);
            };
        })(objects[i].object);
        var worked = observer.observe(objects[i].object, objects[i].method, action);
        if (worked) {
            supervisor._waitObservers.add(observer);
        } else {
            observer.destroy();
            allWorked = false;
        }
    }

    if (timeout && timeoutCallback) {
        supervisor._timeoutCallback = timeoutCallback;
        supervisor._timerEvent = isc.Timer.setTimeout(function () { supervisor._timeoutElapsed(); }, timeout);
    }

    return allWorked;
},


//> @classAttr Page.unsupportedBrowserAction (string : "continue" : IRA)
// Action to take when +link{Page.checkBrowserAndRedirect()} is called in a browser for which
// support is not guaranteed. Valid settings are:
// <ul>
// <li><code>"continue"</code> Load the page without notifying the user of potential issues</li>
// <li><code>"confirm"</code> Notify the user via a standard confirm dialog that their browser is
//  not supported. Provide options to continue anyway, or redirect to another page.
// <li><code>"redirect"</code> Automatically redirect to the another URL
// </ul>
// @see Page.checkBrowserAndRedirect()
// @see Page.defaultUnsupportedBrowserURL
// @group browserSupport
// @visibility external
// @deprecated  As discussed in +link{group:browserSupport}, developers are recommended to consider
//  which browsers they wish to support within their specific application rather than relying on framework
//  supported browser detection.
//<
unsupportedBrowserAction:"continue",

//> @classMethod Page.checkBrowserAndRedirect(URL)
// Check whether the browser is supported by the Isomorphic SmartClient system. Behavior depends
// upon the value of +link{Page.unsupportedBrowserAction}:
// <ul>
// <li><code>"continue"</code> Load the page without notifying the user of potential issues</li>
// <li><code>"confirm"</code> Notify the user via a standard confirm dialog that their browser is
//  not supported. Provide options to continue anyway, or redirect to another page. Text of the
//  confirm dialog is retrieved by calling +link{Page.getUnsupportedBrowserPromptString()}.</li>
// <li><code>"redirect"</code> Automatically redirect to the another URL</li>
// </ul>
// If redirecting to another page is necessary, and no explicit URL is provided we will use
// +link{Page.defaultUnsupportedBrowserURL}.
// <p>
// This method is commonly called as part of the +link{group:skinning,skinning} logic after page
// load.
//
// @param    [URL]   (string)    URL of redirect page. May include Isomorphic special directories
//      such as [SKIN].
// @see Page.unsupportedBrowserAction
// @see Page.getUnsupportedBrowserPromptString()
// @see Page.defaultUnsupportedBrowserURL
// @group browserSupport
// @visibility external
// @deprecated As discussed in +link{group:browserSupport}, developers are recommended to consider
//  which browsers they wish to support within their specific application rather than relying on framework
//  supported browser detection.

//<
checkBrowserAndRedirect : function (URL) {
    if (!isc.Browser.isSupported) {
        if (isc.Log) {
            isc.Log.logWarn("Unsupported browser detected - userAgent:" + navigator.userAgent);
        }

        if (this.unsupportedBrowserAction == "continue") return;

        var noRedirect = this.unsupportedBrowserAction == "confirm" &&
                          confirm(this.getUnsupportedBrowserPromptString())

        if (noRedirect) return;

        // if the browser is not supported we support three options:
        // - carry on and cross fingers
        // - prompt the user to carry on, or go to unsupported browser page
        // - redirect them to the "unsupported_browser.html" page
        if (URL == null) URL = isc.Page.defaultUnsupportedBrowserURL;
        var UNSUPPORTED_BROWSER_DETECTED = true;
        window.location.replace(isc.Page.getURL(URL));
    }

},

//> @classMethod Page.getUnsupportedBrowserPromptString()
// Returns the text for the prompt shown to user from +link{Page.checkBrowserAndRedirect()}
// if they are accessing this page in an unsupported
// browser and +link{Page.unsupportedBrowserAction} is set to <code>"confirm"</code>. May be
// overridden to return a different message.
// @return (string) Unsupported browser message.
// @group i18nMessages
// @see Page.checkBrowserAndRedirect()
// @group browserSupport
// @visibility external
//<
getUnsupportedBrowserPromptString : function () {
    var message = "This page uses the Isomorphic SmartClient web presentation layer " +
    "(Version" + isc.version + " - " +isc.buildDate +
    "). The web browser you are using is not supported by this version of SmartClient" +
    " and you may encounter errors on this page. Would you like to continue anyway?\n\n" +
    "(Reported userAgent string for this browser:"+ navigator.userAgent + ")";
    return message;
},

//>    @classMethod    Page.setAddVersionToSkinCSS()
// Setting this to true will cause +link{classMethod:Page.loadStyleSheet()} to append
// an "isc_version" parameter to the end of the url when loading a stylesheet.
//
//        @group    skins, files
//
//        @param    addVersionToSkinCss    (Boolean)    pass in true to turn on automatic adding of version
//                                              parameter to css urls.
// @visibility external
//<
setAddVersionToSkinCSS : function (addVersionToSkinCSS) {
   this._addVersionToSkinCSS = addVersionToSkinCSS;
},

//>    @classMethod    Page.isAddVersionToSkinCSS()
// Returns true if add version to skin CSS is currently turned on.
//
//      @group skins, files
//        @return    (Boolean)        true == add version to skin CSS is turned on
//
// @visibility external
//<
isAddVersionToSkinCSS : function () {
    return this._addVersionToSkinCSS;
}


});    // END isc.Page.addClassMethods()

if (isc.Page.isXHTML()) isc.nbsp = isc.xnbsp;

// set the default directories for files to what's set in the window, if anything
isc.Page.setDirectories();

// in Moz get the page size right now so it's available even before the Page is done loading
// without triggering the "zero width bug"
if (isc.Browser.isMoz) {
    isc.Page.getWidth(null, true);
    isc.Page.getHeight(null, true);
}


if (isc.Browser.isAndroid) {
    isc.Page.pollPageSize = true;
}

// aliases
isc.Page.getToolsDir = isc.Page.getIsomorphicToolsDir;
isc.Page.setToolsDir = isc.Page.setIsomorphicToolsDir;







//>    @object    Params
//
//    Generate an array of parameters for a particular window/frame or URL.
//    One is generated automatically for the default frame and called "isc.params"
//    or you can create one for any other window, frame or URL.
//
//    To access the parameters of the window by name, simply access that
//    property of the params object:
//
//        alert("Parameter 'action' of this page is " + params.action);
//
//    To create a new params object, call the window level function and pass a window handle:
//
//        var otherWindow = window.open(...);
//        var otherWindowParams = getParams(otherWindow)
//
//    or pass a URL
//
//        var myParams = getParams("http://yoursite.com/page.html?foo=bar");
//
//    NOTE: this is not a class, but rather a simple JS object since
//        we do not want to potentially conflict the values of the params
//        with the built-in stuff in the Class object.
//<
isc.addGlobal("Params", function (frame) {
    // if no frame passed in, use the window this executes in
    if (!frame) frame = window;
    // convert the frame to an href string
    // Note: can't use isA because Params is part of the ISC_FileLoader module, which does not
    // include ISA
    var url = typeof frame == "string" ? frame : frame.location.href;

    // get the location of the question mark
    var questionIndex = url.indexOf("?"),
        // The params end at the first "#", or the end of the url
        hashIndex = url.indexOf("#");
    if (hashIndex < 0 || hashIndex< questionIndex) hashIndex = url.length;

    if (questionIndex != -1) {
        var params = url.substring(questionIndex+1, hashIndex).split("&");
        //alert("paramPairs: " + params);
        for (var i = 0, param, equalIndex; i < params.length; i++) {
            param = params[i];
            if (!param) continue;
            equalIndex = param.indexOf("=");
            //alert("param: " + [it.substring(0, equalIndex),unescape(it.substring(equalIndex+1))]);
            this[param.substring(0, equalIndex)] = unescape(param.substring(equalIndex+1));
        }
    }
})


// create a default "params" object for applications to use
isc.params = new isc.Params();

//>    @function    getParams()
//        Create a top-level function called getParams() that creates a new params object for you.
//        Access parameters of the window in question by direct access on the returned object:
//
//            var myParams = getParams(someOtherWindow);
//            alert(myParams.someNamedParameter);
//
//        @param    window        (window | frame | string)        window to get params for
//<
isc.getParams = function (window) { return new isc.Params(window) }








//>    @class Comm
// Provide background communication with an HTTP server
//<

// create the Comm singleton object
isc.ClassFactory.defineClass("Comm");

// add properties to the Comm object
isc.Comm.addClassProperties( {

    //>    @classAttr    isc.Comm.sendMethod (string : isc.Comm.sendMethod : I)
    //            communication method
    //        @group    communication
    //<
    sendMethod:    "POST",

    //>    @type    SendMethod
    //            @visibility external
    //            @group    communication
    // @value    "GET"     GET method (regular URL encoding)
    // @value    "POST"    POST method (form field encoding)
    //<

    // Sequence number for forms created in IE to send data to the server.  Used to give each
    // form a unique name.
    _generatedFormNumber : 0

});


isc.Comm.addClassMethods({

// XMLHttpRequest vs IFrame Comm
//
// Advantages:
// - doesn't add to history in older Moz
// - no request for empty.html in HTTPS
// - doesn't add to document.frames and potentially screw up numbering
// - ability to detect load with a server-initiated callback
// - synchronous option
//
// Disadvantages / neutral
// - can't handle upload fields
// - is subject to concurrent requests limit in IE (test by adding Thread.sleep(5000) to
//   IDACall - responses come in closely-spaced pairs)
// - no persistent connections in IE (server push), see:
//    http://jszen.blogspot.com/2005/03/xmlhttp-and-readystate.html
// - no compression in IE 5.5
//
// XMLHttpRequest behavior with file:// URL - works on FF, Safari, and IE but on all these
// platforms the URL must be relative or it doesn't work.  SO e.g. ../foo.html is ok, but
// /foo.html is not.  Haven't tested specifying the full path (e.g. c:\foo\bar.html).
//
// For XMLHttpRequest, FF uses the baseURL of the window object that started thread that
// eventually calls XMLHttpRequest.send() as the baseURL for resolving the relative reference.
// This means that if you send an RPC using XMLHttpRequest out of the eval area of the
// Developer Console, your base URL will be /isomorphic/system/helpers - because that's where
// Log.html came from.  You can use a timeout to restart the thread in the appropriate context
// - just be aware of this oddity.

_fireXMLCallback : function (request, callback, delayedCall) {


    if (!delayedCall) isc.EH._setThread("XRP");

    // NOTE: last param tells fireCalllback to trap errors in Moz
    isc.Class.fireCallback(callback, "xmlHttpRequest", [request], null, true);

    if (!delayedCall) isc.EH._clearThread();
},

// ==========================================================================================
// IMPORTANT: If you update the XMLHttp code here, also update FileLoader.js
// ==========================================================================================
_getStateChangeHandler : function () {
    return function () {
        var request = arguments.callee.request;

        // IE 5.5 manages to call this handler after readyState changes to 4 and we process the
        // request, which would cause the whole RPC reply logic to run more than once which
        // breaks badly.  If we run more than once, the request will be null becase we null it out
        // below, so just trap this case and return.
        if (!request) return;

        if (request.readyState != 4) return;

        arguments.callee.request = null;

        // Bizarre IE-only bug: in the middle of a readyStateChange thread, we draw a
        // new widget, and on touching the newly created handle in
        // Canvas._browserDoneDrawing(), IE decides it's a good time to interrupt the current
        // thread and fire readyStateChange from another xmlHttpRequest that has arrived in the
        // meantime - this can actually be seen in the stack trace, which shows this handler
        // being called (impossibly) by _browserDoneDrawing().
        // So far as we know, IE is not willing to similarly interrupt a timer thread, so we
        // fire the callback on a 0ms timer instead, which should be order-preserving.
        // NOTE: do not use a closure here or a leak will be introduced
        //isc.Comm._fireXMLCallback(request, arguments.callee.callback);
        isc.Timer.setTimeout({ target:isc.Comm, methodName:"_fireXMLCallback",
                               args:[request, arguments.callee.callback, true] }, 0);
    }
},


// Upon shipping XML3.0, Microsoft started installing XML parsers in "side by side mode"
// meaning the previous version is left intact and a new version is installed parallel to
// the existing one.  Prior to this the latest XML parser being installed by some piece of
// software would overwrite the previous verison and potentially break the software that
// depended on that version.  The catch is that to get the later versions of the parser, you
// need to specify a version-specific prefix.
//
// We use a version independent prefix to get the 2.0 parser in IE6.0 and IE5.5 and then
// fall back on version-specific prefixes if that fails for some reason.  But we expect
// MSXML2.XMLHTTP or Microsoft.XMLHTTP to actually work.
//
// MSXML2 prefix specifies the version independent control.  The "Microsoft" and "MSXML"
// prefixes are old-style version independent controls.  MSXML3 is version specific 3.0 parser.
//                     IE6+               IE5.5               pre-IE5.5 style  IE6+
xmlHttpConstructors : ["MSXML2.XMLHTTP", "Microsoft.XMLHTTP", "MSXML.XMLHTTP", "MSXML3.XMLHTTP"],

// ==========================================================================================
// IMPORTANT: If you update this function, also update its copy in SA_XMLHttp.js
// ==========================================================================================
createXMLHttpRequest : function () {

    if (isc.Browser.isIE && !isc.Browser.isIE10) {

        var xmlHttpRequest;

        // We prefer the  ActiveX version of XMLHttpRequest if it's available because IE7's
        // native implementation has some quirks - for example it doesn't allow requests to
        // file:// URLs no matter what overrides you set in IE's options panel.  Also there
        // are scattered reports of the native implementation being less performant.
        if (this.preferNativeXMLHttpRequest) {
            xmlHttpRequest = this.getNativeRequest();
            if (!xmlHttpRequest) xmlHttpRequest = this.getActiveXRequest();
        } else {
            xmlHttpRequest = this.getActiveXRequest();
            if (!xmlHttpRequest) xmlHttpRequest = this.getNativeRequest();
        }

        if (!xmlHttpRequest) isc.rpc.logWarn("Couldn't create XMLHttpRequest");
        return xmlHttpRequest;
    } else {
        // Moz, Safari, IE10+
        return new XMLHttpRequest();
    }
},

getNativeRequest : function () {
   var xmlHttpRequest;
    if (isc.Browser.version >= 7) {
        isc.rpc.logDebug("Using native XMLHttpRequest");
        xmlHttpRequest = new XMLHttpRequest();
    }
    return xmlHttpRequest;
},

getActiveXRequest : function () {
    var xmlHttpRequest;

    if (!this._xmlHttpConstructor) {
        for (var i = 0; i < this.xmlHttpConstructors.length; i++) {
            try {
                var cons = this.xmlHttpConstructors[i];
                xmlHttpRequest = new ActiveXObject(cons);
                // cache selected constructor
                if (xmlHttpRequest) {
                    this._xmlHttpConstructor = cons;
                    break;
                }
            } catch (e) { }
        }
    } else {
        xmlHttpRequest = new ActiveXObject(this._xmlHttpConstructor);
    }

    if (xmlHttpRequest) isc.rpc.logDebug("Using ActiveX XMLHttpRequest via constructor: " + this._xmlHttpConstructor);
    return xmlHttpRequest;
},


// Comm.sendHiddenFrame() defined in `application/SCServer.js'.


// _transactionCallbacks - array of callbacks for outstanding transactions
// fired from the various 'reply' methods
_transactionCallbacks:[],

// scriptInclude transport
// ---------------------------------------------------------------------------------------

sendScriptInclude : function (request) {
    var URL = request.URL,
        fields = request.fields,
        data = request.data,
        callbackParam = request.callbackParam,
        callback = request.callback,
        transaction = request.transaction
    ;

    if (transaction != null) {
        // create a function for server-generated code to call, and capture the
        // transactionNum by having the function share this scope
        var cbName = "_scriptIncludeReply_"+transaction.transactionNum;
        this[cbName] = function () {
            // copy arguments to a real array
            var values = arguments.length == 1 ? arguments[0] : [];
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) values[i] = arguments[i];
            }
            isc.Comm.performScriptIncludeReply(transaction.transactionNum, values);
        }
        callback = "isc.Comm."+cbName;
    }

    URL = isc.rpc.addParamsToURL(URL, fields);

    if (callbackParam && callback) {
        var callbackParamObj = {};
        callbackParamObj[callbackParam ? callbackParam : "callback"] = callback;
        URL = isc.rpc.addParamsToURL(URL, callbackParamObj);
    }

    if (transaction != null) transaction.mergedActionURL = URL;

    isc.rpc.logInfo("scriptInclude call to: " + URL);

    // store the transactionCallback to fire when the server returns
    if (transaction != null) this._transactionCallbacks[transaction.transactionNum] = transaction.callback;


    var document = this.getDocument(),
        body = this.getDocumentBody(),
        scriptElement = document.createElement("script");
    scriptElement.src = URL;
    body.appendChild(scriptElement);
},


performScriptIncludeReply : function (transactionNum, values) {
    // destroy auto-generated function for this transaction
    delete this["_scriptIncludeReply_"+transactionNum];
    var callback = this._transactionCallbacks[transactionNum];
    delete this._transactionCallbacks[transactionNum];

    this.logDebug("scriptInclude reply for transactionNum: " + transactionNum +
                  ", data: " + this.echoLeaf(values), "xmlBinding");

    this.fireCallback(callback, "transactionNum,results,wd", [transactionNum, values]);
},


// send via an xmlHttpRequest
sendXmlHttpRequest : function (request) {

    var URL = request.URL,
        fields = request.fields,
        httpMethod = request.httpMethod,
        contentType = request.contentType,
        headers = request.httpHeaders,
        data = request.data,
        transaction = request.transaction,
        blocking = request.blocking != null ? request.blocking : false,
        responseType = request.xmlHttpRequestResponseType
    ;

    

    this._transactionCallbacks[transaction.transactionNum] = transaction.callback;


    // set up a callback to notify us when the request completes
    var callback = "isc.Comm.performXmlTransactionReply(" +transaction.transactionNum+
                    ", xmlHttpRequest)";

    if (!httpMethod) httpMethod = "POST";
    var xmlHttpRequest = this.createXMLHttpRequest();

    var loadFunc;
    if (isc.Browser.isIE) {

        loadFunc = this._getStateChangeHandler();
        loadFunc.request = xmlHttpRequest;
        loadFunc.callback = callback;

    } else {
        // we'll install this function to fire onreadystatechange
        loadFunc = function () {

        if (xmlHttpRequest.readyState != 4) return;
                isc.Comm._fireXMLCallback(xmlHttpRequest, callback);
        }
    }
    xmlHttpRequest.onreadystatechange = request.onreadystatechange || loadFunc;

    if (isc.rpc.logIsDebugEnabled()) {
        this.lastXmlHttpRequest = xmlHttpRequest; // HACK for debugging
    }

    if (httpMethod == "POST" || httpMethod == "PUT") {
        // if data was passed in, use that as the body and encode any fields into the query
        // params
        if (data) {
            // assume the body being posted is XML if contentType is unset
            contentType = contentType || "text/xml";
            URL = isc.rpc.addParamsToURL(URL, fields);
        } else {
            // send fields like a form post
            contentType = contentType || "application/x-www-form-urlencoded; charset=UTF-8";
            data = isc.SB.create();
            var first = true;
            for (var fieldName in fields) {
                if (!first) data.append("&");
                var value = fields[fieldName];
                data.append(isc.rpc.encodeParameter(fieldName, value));
                first = false;
            }
            data = data.release(false);
        }
        if (isc.rpc.logIsDebugEnabled()) {
            isc.rpc.logDebug("XMLHttpRequest POST to " + URL + " contentType: " + contentType
                             + " with body -->"+decodeURIComponent(data)+"<--");
        }
        xmlHttpRequest.open(httpMethod, URL, !blocking);


        if (request.withCredentials) xmlHttpRequest.withCredentials = true;

        // In Firefox, before responseType can be set, open() must be called first:
        // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
        if (responseType != null) xmlHttpRequest.responseType = responseType;


        var contentTypeSet = this._setHttpHeaders(xmlHttpRequest, headers);
        if (!contentTypeSet) {
            contentType == xmlHttpRequest.setRequestHeader("Content-Type", contentType);
        }
        if (transaction) {
            transaction.xhrHeaders = headers;
            transaction.xhrData = data;
        }
        if (data != null && !isc.isA.String(data)) {
            this.logWarn("Non-string data object passed to sendXML as request.data:"+ this.echo(data) +
                        " attempting to convert to a string.");
            data = data.toString ? data.toString() : "" + data;
        }
        xmlHttpRequest.send(data);

    } else {  // httpMethod == GET, DELETE, HEAD
        var urlWithFields = isc.rpc.addParamsToURL(URL, fields);
        xmlHttpRequest.open(httpMethod, urlWithFields, !blocking);

        if (request.withCredentials) xmlHttpRequest.withCredentials = true;

        if (responseType != null) xmlHttpRequest.responseType = responseType;

        // If bypassCache is set, use if-modified-since header to prevent cacheing of
        // XMLHttp GET responses.
        if (request.bypassCache) {

            xmlHttpRequest.setRequestHeader("If-Modified-Since", "Thu, 01 Jan 1970 00:00:00 GMT");
        }

        this._setHttpHeaders(xmlHttpRequest, headers);

        if (isc.rpc.logIsDebugEnabled()) {
            isc.rpc.logDebug("XMLHttpRequest GET from " + URL +
                             " with fields: " + isc.Log.echoAll(fields) +
                             " full URL string: " + urlWithFields);
        }

        xmlHttpRequest.send(null);
    }
    return xmlHttpRequest;
},




performXmlTransactionReply : function (transactionNum, xmlHttpRequest) {
    //!OBFUSCATEOK
    var callback = this._transactionCallbacks[transactionNum]
    delete this._transactionCallbacks[transactionNum];
    this.fireCallback(callback, "transactionNum,results,wd", [transactionNum, xmlHttpRequest]);
},

_setHttpHeaders : function (request, headers) {
    if (headers == null) return;
    var sawContentType = false;
    for (var headerName in headers) {
        var headerValue = headers[headerName];
        if (headerValue != null) {
            request.setRequestHeader(headerName, headerValue);
            if (headerName.toLowerCase() == "content-type") sawContentType = true;
        }
    }
    return sawContentType;
}

});








//>    @class    HiddenFrame
// This class provides a hidden frame that you can use to send messages to (and receive data
// from) the server invisibly without requiring an external frameset.
//<

// create the class
isc.ClassFactory.defineClass("HiddenFrame");

// set up static properties
isc.HiddenFrame.addClassProperties({
    // handle to the window object inside the frame element
    //_windowHandle: null,

    // handle to the frame element (not available in IE 5.5 or earlier versions)
    //_frameDomHandle: null,

    _stats : {
        draws: 0,
        destroys: 0
    },

    // all currently instantiated hiddenFrames
    _hiddenFrames: [],


    _killLoadingIndicators : function () {
        // the create/destroy cycle must be done off the thread created by the onload handler
        // of the iframe that started the indicators - since this method is often called in
        // that thread, set up a timeout here.
        if (isc.Browser.isMoz) this.delayCall("_doKillLoadingIndicators");
    },

    _doKillLoadingIndicators : function () {
        var hf = isc.HiddenFrame.create();
        hf.draw();
        hf.destroy();
    }
});

// set up default instance properties
isc.HiddenFrame.addProperties({
    //>    @attr    hiddenFrame.text        (string : "nothing" : IRW)
    //            text written into the hidden frame when it is drawn.
    //        @group    appearance
    //<
    text:"&nbsp;",

    //>    @attr    hiddenFrame.location    (URL : null : IRW)
    //            URL to set the frame to, set the hiddenFrame.location
    //            to the URL you want to send to the server.
    //        @group appearance
    //<

    _generated: true,

    // see draw; used to keep track of actions that should be delayed until the
    // targetable frame is created (for some browsers, need to wait until page load for creation)
    _callbackQueue:[],

    // polling interval (in ms) for checking if the iframe has finished loading
    pollInterval:100,

    useHtmlfile: false
});

//!>Deferred

// give it some default methods
isc.HiddenFrame.addMethods({


//>    @method    hiddenFrame.init()    (A)
//      constructor
//
//        @param    [all arguments]    (object)    objects with properties to override from default
//        @param    props        (object)    properties for the frame
//<
init : function () {
    // get a unique, global ID for this HiddenFrame
    isc.ClassFactory.addGlobalID(this);

    isc.HiddenFrame._hiddenFrames.add(this);


},


//>    @method    hiddenFrame.getID()    (A)
//            Return the global ID of this object
//        @return    (string)    global identifier for this object
//<
getID : function () {
    return this.ID;
},


// callback is an optional argument; it's a string to be eval'ed after the frame is drawn.
draw : function (callback) {
    // if frame has already been drawn, eval the callback if any, and exit
    if (this.isDrawn()) {
        if (callback != null) this.fireCallback(callback);
        return this;
    }

    // if it's safe to draw the frame, go ahead, otherwise delay until page load, and add the
    // callback (if any) to the callback queue
    if (!this._safeToDraw()) {
        // set page load event to call draw if it hasn't been set before
        if (!this._markedForDrawing) {
            this._drawEvent = isc.Page.setEvent("load", this.getID() + ".draw()", isc.Page.FIRE_ONCE);
            this._markedForDrawing = true;
        }
        // add the callback (if any) to the callback queue
        if (callback != null) {
            this._callbackQueue[this._callbackQueue.length] = callback;
        }
    } else {
        this._draw();
        // iterate through the callbacks in the queue
        for (var i = 0; i < this._callbackQueue.length; i++) {
            this.fireCallback(this._callbackQueue[i]);
        }
        // perform the callback if there's one in the arguments
        if (callback != null) this.fireCallback(callback);
    }
    return this;
},


//>    @method    hiddenFrame._draw()    (A)
// Actually draw the hidden frame<br><br>
// Places a handle to the frame in the "_handle" variable
//
// @platformNotes    Very different manner of drawing for IE and Nav,
//                but the effect should be more or less the same
//<
_draw : function () {
    if (this._drawn) return this._windowHandle;

    // specifying the NAME attribute is necessary if we want to be able to target form submits
    // to this frame (targeting the ID attribute doesn't work)
    this.frameHTML = "<IFRAME ID=" + this.getName() +
        " NAME=" + this.getName() +
        " SRC=\"" + (this.location ? this.location : isc.Page.getBlankFrameURL()) +
        "\" STYLE='position:absolute;visibility:hidden;top:-1000px'" +
        "></IFRAME>";

    if (this.useHtmlfile) {
        try {
            // http://cometdaily.com/2007/11/18/ie-activexhtmlfile-transport-part-ii/
            this._transferDoc = new ActiveXObject("htmlfile");
        } catch (e) {
            // ActiveX may be disabled.
            this.useHtmlfile = false;
        }
    }
    if (!this.useHtmlfile) {
        var output = this.frameHTML;
        // add a new IFRAME to the body

        isc.Element.createAbsoluteElement(output);


        if (!(isc.Browser.isIE && isc.Browser.minorVersion < 5.5)) {
            // get the handle to the frame and the window object
            this._frameDomHandle = isc.Element.get(this.getName());
            if (!isc.Browser.isSafari) this._windowHandle = this._frameDomHandle.contentWindow;
        }

        if (this._windowHandle == null) {
            for (var i = 0; i < window.frames.length; i++) {
                var wh = window.frames[i];
                try {
                    if (wh.name == this.getName()) {
                        this._windowHandle = wh;
                        break;
                    }
                } catch (e) {
                    // The way to handle situations with denied access to frame
                }
            }
        }

    }

    // mark as drawn
    this._drawn = true;
    // and return it
    return this._windowHandle;
},


isDrawn : function () {
    return this._drawn;
},


_safeToDraw : function () {

    return isc.Page.isLoaded() || !isc.Browser.isMoz;
},


destroy : function () {
    //!OBFUSCATEOK
    // if there's a commCanvas associated with this hidden frame, destroy it.
    if (isc.isA.Canvas(this._commCanvas)) {
        this._commCanvas.destroy();
        delete this._commCanvas;
        isc.HiddenFrame._stats.destroys++;
    }

    // remove global pointer to this object
    if(window[this.ID]) window[this.ID] = null;

    isc.HiddenFrame._hiddenFrames.remove(this);

    // Don't attempt to draw on page load after we've been destroyed.
    if (this._markedForDrawing) {
        isc.Page.clearEvent("load", this._drawEvent);
    }

    if (this.useHtmlfile) {
        if (this._transferDoc) {
            this._transferDoc.parentWindow.isc = null;
            this._transferDoc = null;
            delete this._transferDoc;

            CollectGarbage();
        }
    } else {
        var handle = this.getHandle();
        if (!handle) return;

        if (isc.Browser.isSafari) handle.location = isc.Page.getBlankFrameURL();


        var canAccessWindowProps = this.evaluate("try{this.getHandle().name;true;}catch(e){false}");
        if (!canAccessWindowProps) {
            this.logDebug("Can't dispose of " + this.ID + " - property access denied.");
            return
        }


        if (isc.Browser.isIE) {
            if (document.domain == location.hostname) {
                handle.document.open();
                handle.document.write("");
                handle.document.close();
            } else {
                // XXX document.write() and document.close() throw exceptions if we've set
                // document.domain.  Can't be overcome by setting handle.document.domain here
                // manually, so use Safari workaround of targeting the blank url;
                handle.document.location.href = isc.Page.getBlankFrameURL();
            }
        }


        if (this._frameDomHandle != null) {
            isc.Element.clear(this._frameDomHandle);
            this._frameDomHandle = null;
        }
        if (this._windowHandle != null) this._windowHandle = null;
    }
    this.Super("destroy", arguments);

    this.logDebug("Destroyed " + this.ID);
},


//>    @method    hiddenFrame.getHandle()    (A)
//            return a handle to the frame
//        @return    (DOMObject)        handle to the frame
//<
getHandle : function () {
    return this._windowHandle;
},


//>    @method    hiddenFrame.getName()    (A)
//            get the name of this frame
//        @return    (string) name for the frame
//<
getName : function () {
    return this.getID();
},


//>    @method    hiddenFrame.getFrameDocument()    (A)
//            return a pointer to the document object of the frame
//        @return    (DOMObject)    pointer to the document object of the hidden frame
//<
getFrameDocument : function () {
    if (this.useHtmlfile) {
        return this._transferDoc;
    } else {

        var handle = (isc.Browser.isSafari && isc.Browser.safariVersion < 523.129
                        ? this._frameDomHandle : this._windowHandle);

        try {
            return handle.document;
        } catch (e) {
            return null;
        }
    }
},


//>    @method    hiddenFrame.getForm()    (A)
//            return a pointer to a form in the document of the frame
//
//        @param    [formID]    (number | string : 0)        identifier for the form, either a number or form name
//
//        @return    (form)    pointer to the form, or null if form not found
//<
getForm : function (formID) {
    if (formID == null) formID = 0;
    if (isc.Browser.isMoz) {
        return this.getFrameDocument().getElementById(formID);
    } else {
        return this.getFrameDocument().forms[formID];
    }
},


//>    @method    hiddenFrame.setInnerHTML()
//        Function to set the text of the frame to a block of text
//
//        @param    newText        (string)    text to put into the frame
//<
setInnerHTML : function (newText) {
    // remember the text for later
    if (newText) this.text = newText;

    var document = this.getFrameDocument();



    if (isc.Browser.isMoz) {
        var range = document.createRange();
        range.setStartBefore(document.body);
        var parsedHTML = range.createContextualFragment(this.text);
        document.body.appendChild(parsedHTML);
    } else {

    // open, write and close document

    document.open();
    // NOTE: current code does not write a complete document into the frame, just a FORM,
    // although all browsers seem to be happy with this.
    document.write(this.text);
    document.close();

    }
},




sendForm : function (formHTML, formName, fieldList) {
    if (formHTML != null) this.formHTML = formHTML;
    if (formName != null) this.formName = formName;
    if (fieldList != null) this.fieldList = fieldList;

    if (!this._safeToDraw()) {
        this.logDebug("delaying comm until page load");
        isc.Page.setEvent("load", this.getID()+".sendForm()", isc.Page.FIRE_ONCE);
        return;
    }

    this.draw();

    this.sendData();
},

sendData : function (isResend) {
    // somewhat hackish - we need RPCManager may resend() the form in some cases, and we need
    // to flag this for the server, but the form HTML has already been generated.  So use
    // regexp to hook a known part of the ACTION URL and write our flag in that way
    var formHTML = this.formHTML;
    if (isResend) {
        // note isc_rpc=1 appears more than once in the string
        formHTML = formHTML.replace(/isc_rpc=1/g, "isc_rpc=1&isc_resubmit=1");
    }


    if (this.getFrameDocument() == null)
    {
        //this.logWarn("delaying sendData because IFRAME document object isn't available yet");
        this.delayCall("sendData", [], 10);
        this.logDebug(this.getID() + ": sendData() - document not ready - deferring.");
        return;
    }

    var form;

    if (this.useHtmlfile) {
        var transferDoc = this._transferDoc;
        transferDoc.open();
        transferDoc.write("<html><body>");
        transferDoc.write(this.frameHTML);
        transferDoc.write(formHTML);
        transferDoc.write("</body></html>");
        transferDoc.close();
        transferDoc.parentWindow.isc = isc;

        form = transferDoc.getElementById(this.formName);
    } else {
        // In IE and Moz we write the form into a canvas and set its target to the ID of the iframe
        // managed by this hiddenFrame object.
        if (isc.isA.Canvas(this._commCanvas)) this._commCanvas.destroy();
        this._commCanvas = isc.Canvas.create({
            autoDraw: true,
            ID: this.getID() + "_commCanvas",
            visibility: "hidden",
            overflow:"ignore",
            top: -9999,
            width: 1,
            height: 1,
            contents: formHTML,
            _generated: true,
            // we don't want this canvas to show up in the log - so ignore stats for it
            _iscInternal: true
        });
        isc.HiddenFrame._stats.draws++;

        form = isc.Element.get(this.formName);
    }

    // Set the form element's `accept-charset' attribute if not set
    // https://developer.mozilla.org/en-US/docs/DOM/form.acceptCharset
    if (!form.acceptCharset) {
        form.acceptCharset = "UTF-8";
    }



    // assign the form values to the fields explicitly.

    for (var field in this.fieldList) {
        // need the null check here because otherwise we actually send an undefined
        if(this.fieldList[field] != null) form.elements[field].value = this.fieldList[field];
    }

    if (form) {
        form.submit();

        //>DEBUG
        this.logInfo("Form submitted to server");
        //<DEBUG

        // if a callback was set, start the timer for it
        if (this.callback) {
            this.convertToMethod("callback");
            this.delayCall("checkLoaded", [], this.pollInterval);
        }
    } else {
        // should never happend
        this.logWarn("couldn't get handle to comm form");
    }
},

// function for doing the form submit on a timeout.  Not currently used.
/*
submitForm : function () {
    var form = this.getForm(this.formName);
    form.submit();
},
*/

//> @method hiddenFrame.checkLoaded()
//<

checkLoaded : function () {
    var handle = this.getHandle();

    // see if the variable we're expecting has arrived in the iframe
    if (handle && handle[this.resultVarName]) {
        if (this.callback) this.callback(handle);
    } else {
        // var not yet available - wait for the server to respond
        this.delayCall("checkLoaded", [], this.pollInterval);
    }
}

}); // end addMethods()

// Register instance methods that can be defined as strings to eval
isc.HiddenFrame.registerStringMethods({
    callback:"frame"
});

//!<Deferred

// define a FileLoader stub for bootstrapping, if FileLoader has not been loaded
if (!isc.FileLoader) {
    isc.defineClass("FileLoader").addClassProperties({
        // flag for SA_Core -> defineClass, allowing redefinition
        _isStub: true,

        // Some of the required modules may be optional modules (RealtimeMessaging, for
        // example).  But even if the user has not purchased a license to these, we still allow
        // the use of them specifically for RemoteDebugging - which requires the bootstrap
        // So: load from development/
        modulesDir: "system/development/",

        ensureLoaded : function (callback) {
            isc.fileLoaderLoaded = function () {
                isc.fileLoaderLoaded = null;
                callback();
            };
            isc.Comm.sendScriptInclude({
                // Note: no callback param - since we control the code in FileLoader,
                // we have logic there in _pageLoad() to simply call a function on the isc
                // object, if registered once loaded.  This way we don't require server collusion
                URL: isc.Page.getIsomorphicDir()+this.modulesDir+"/ISC_FileLoader.js"
            });
        }
    });

    // FL synonym for FileLoader
    isc.addGlobal("FL", isc.FileLoader);
}





//>    @class    Timer
//
// The Timer class provides a predictable cross-browser system for creating
// timed events.
//
// @treeLocation Client Reference/System
// @visibility external
//<






// create the Timer object
isc.ClassFactory.defineClass("Timer");

// add class properties and constants
isc.Timer.addClassProperties(
{
    _eventList : null,                                //>    @classAttr    isc.Timer._eventList        (object : null : IRWA)
                                                            //        This is a single linked list of timerEvents that have been queued up for execution.
                                                            //        The attribute itself points to the first element in the list.
                                                            //
                                                            //        @group timer
                                                            //<

    listEvent : {action: null,                         //>    @classAttr    isc.Timer.listEvent        (object : {...} : IRWA)
                     iterationInterval: null,        //            Properties for a timerEvent (a pseudoclass used in the isc.Timer class)
                     iterationsRemaining: 0,        //
                     _nextEvent: null,            //                         action: reference to function for this timerEvent
                     _nextRunTime: null},            //                      condition: condition for continuing iteration, used by isc.Timer.setDoWhen() and isc.Timer.setDoUntil()
                                                            //              iterationInterval: time between iterations of a timerEvent
                                                            //            iterationsRemaining: counter for remaining iterations of a timerEvent
                                                            //                           time: time when timerEvent should fire, used by Timer.seAlarm()
                                                            //                 _nextEvent: reference to next timerEvent in the eventList
                                                            //                   _nextRunTime: absolute time when this timerEvent should be run
                                                            //                       _execute: routine fired when timerEvent is executed.
                                                            //<
    //>    @type    Units
    //        Multiplier for an amount of time specified in milliseconds.
    MSEC :       1,            //    @value    isc.Timer.MSEC        milliseconds
    SEC :     1000,            //    @value    isc.Timer.SEC        seconds
    MIN :    60000,            //    @value    isc.Timer.MIN        minutes
    HOUR : 3600000,            //    @value    isc.Timer.HOUR        hours
    //<

    DEFAULT_TIMEOUT_LENGTH : 100,                            //>    @classAttr isc.Timer.DEFAULT_TIMEOUT_LENGTH (number : 100 : R)
                                                            //        Default time to delay if an explicit delay is not specified.
                                                            //<


    _clockHandle : null                                     //>    @classAttr    isc.Timer.__clockHandle        (object : null : IRWA)
                                                            //        Reference to the setTimeout() instance that may be running at any given time.
                                                            //        Used to stop the timer, if necessary. If value is null, then the queue is not
                                                            //     processing.
                                                            //
                                                            //        @see Timer._stopClock()
                                                            //<
}
);// END isc.Timer.addClassProperties()



// add a bunch of methods to the Timer object
isc.Timer.addClassMethods({



//>    @classMethod    Timer.setTimeout()
//
// Execute an action in a given amount of time.  This method wraps the native setTimeout() method,
// correcting for browser-specific memory leaks.
//
// @see clear()
//
//
// @param action (string expression or function)
//                      Function to be called when delay has elapsed.
//                     Can also be a string representation of an expression.
//                     Passing a string is preferred.
//
// @param delay (number) Time until action is executed (in milliseconds). If not specified, the
//                       default is 100 milliseconds.
// @return      (timerEvent) Reference to the timerEvent created. Note that this reference is provided
//                              only so that it can be used as an argument for Timer.clear().
// @visibility external
//<



// - incrementing count to identify delayed actions uniquely
_timeoutCount:0,
// - map of native timer event IDs to action ID for the delayed action stored on the isc.Timer object
_tmrIDMap:{},
// - map from action ID to native timer event ID
_reverseDelayedTmrIDMap:{},
setTimeout : function (action, delay, units, frequentTimer) {

    if (action == null) return;

    // if an object is passed in the place of the action parameter,
    // then assign parameters from its values
    if (action.action != null) {
        delay = action.delay;
        units = action.units;
        action = action.action;
    }

    //defaults, loaded if not in parameters or in parameter object.
    if (units == null) units = isc.Timer.MSEC;
    if (delay == null) delay = isc.Timer.DEFAULT_TIMEOUT_LENGTH;

    // get the actual length to delay according to the units passed in
    delay = delay * units;


    if (isc.Browser.isMobileSafari) {
        if (isc.isA.String(action) || action._fireTime != null) action = {_action: action};
        action._fireTime = delay + isc.timeStamp();
    }

    var ID = "_timeout" + this._timeoutCount++;
    this[ID] = action;


    if ( this.logIsDebugEnabled("traceTimers")


       )
    {
        delete this.currentAction;
        action.timerTrace = this.getStackTrace(null, 1, null, true);
    }



    // actually set the native timeout to fire at the appropriate time.
    var tmrID = setTimeout(function () {
        isc.Timer._fireTimeout(ID, tmrID);
    }, delay);
    // Setting up a mapping between the native timer ID and the name of the temp slot we used
    // to store the action allows us to clear both if a developer calls 'clear()'

    this._tmrIDMap[tmrID] = ID;
    return tmrID;
},

_$TMR:"TMR",
_evalDurationThreshold:5000,
// method fired to actually execute a timeout
_fireTimeout : function (ID, tmrID, delayedTmrID) {
    // If an eval() is in mid execution, further delay the timeout until it completes
    // In FF 3 (seen on version 3.0.3), Mozilla introduced a behavior whereby if
    // a thread of code called the native "eval" function while there was a pending timeout,
    // the timeout would fire before the eval was evaluated, meaning essentially a timout could
    // interrupt an otherwise synchronous thread. We don't expect this behavior and it can cause
    // some bizarre errors - we workaround this by setting a flag before our wrapper around
    // the native eval method gets called, and if present not allowing any timeouts to fire
    if (isc._evalRunning != null) {
        if (this.logIsInfoEnabled()) {
            this.logInfo("timer ID:" + ID + " fired during eval. Delaying until this " +
                            "thread completes");
        }
        // Sanity check - if we've already waited for a long time, assume the eval
        // crashed and the _evalRunning flag is bogus.
        if (!this._evalDurationStart) this._evalDurationStart = isc.timeStamp();

        if ((isc.timeStamp() - this._evalDurationStart) > this._evalDurationThreshold) {
            this.logWarn("timer ID:" + ID + " fired during eval thread lasting more than " +
                        this._evalDurationThreshold + "ms. Thread may have caused an " +
                        "error and failed to complete. Allowing delayed action to fire.");
            delete isc._evalRunning;
        } else {

            delayedTmrID = setTimeout(function () {
                isc.Timer._fireTimeout(ID, tmrID, delayedTmrID);
            }, 0);
            // Store the native timer identifier so a call to clear() can suppress the new native
            // timeout from firing
            this._reverseDelayedTmrIDMap[ID] = delayedTmrID;
            return;
        }
    }

    delete this._evalDurationStart;

    var action = this[ID];


    if (action == null) {
        return;
    }


    if (action._action) action = action._action;



    // Clear out the temp action slot, and the mapping to native timer ID
    delete this[ID];

    delete this._tmrIDMap[tmrID];


    delete this._reverseDelayedTmrIDMap[delayedTmrID];

    isc.EH._setThread(this._$TMR);

    arguments.timerTrace = action.timerTrace;
    // this is not quite as good as having timerTraces stored on arguments, since it can only
    // show us the origin of the current timer thread, not multiple timers that set other timers
    this.currentAction = action;
    // fireCallback() will handle action specified as function, string to eval and
    // object with 'target' and 'methodName' attributes.
    // Since this is a new thread, pass in the param to catch errors - allows us to see JS
    // errors in the arbitrary code
    this.fireCallback(action, null, null, null, true);
    isc.EH._clearThread();
},




//>    @classMethod    Timer.clear()
//
// Cancels the processing of a timerEvent if it has not already fired.
//
// @param    timerEvent    (object)        timerEvent object previously returned from Timer.setTimeout()
//
// @visibility external
//<
clear : function (tmrID) {
    if (isc.isAn.Array(tmrID))
        for (var i = 0; i < tmrID.length; i++) this.clear(tmrID[i]);
    else {
        var ID = this._tmrIDMap[tmrID];
        // clear the temp action and the pointer to it
        delete this[ID]
        delete this._tmrIDMap[tmrID];


        if (this._reverseDelayedTmrIDMap.hasOwnProperty(ID)) {
            tmrID = this._reverseDelayedTmrIDMap[ID];
            delete this._reverseDelayedTmrIDMap[ID];
        }

        // natively clear the timeout
        clearTimeout(tmrID);
    }
    return null;
},

clearTimeout : function (tmrID) {
    return this.clear(tmrID);
},

_getTimeoutFireTime : function (ID) {
    var action = this[ID] || {};
    return action._fireTime;
},


firePendingTimeouts : function () {

    var tmrIDMapCopy = isc.addProperties({}, this._tmrIDMap),
        reverseDelayedTmrIDMap = this._reverseDelayedTmrIDMap,
        timeStamp = isc.timeStamp();
    for (var tmrID in tmrIDMapCopy) {
        if (!tmrIDMapCopy.hasOwnProperty(tmrID)) continue;

        var ID = tmrIDMapCopy[tmrID];
        if (ID == null) continue;
        // check whether each timeout is ready to fire
        var fireTime = this._getTimeoutFireTime(ID);
        if (fireTime != null && fireTime < timeStamp) {
            if (reverseDelayedTmrIDMap.hasOwnProperty(ID)) {
                var delayedTmrID = reverseDelayedTmrIDMap[ID];
                clearTimeout(delayedTmrID);
                this._fireTimeout(ID, tmrID, delayedTmrID);
            } else {
                clearTimeout(tmrID);
                this._fireTimeout(ID, tmrID);
            }
        }
    }
}



});    // END isc.Timer.addClassMethods()












//>    @object    EventRegistry
//
//    EventRegistry -- the event registry allows you to set global event handlers
//        that fire BEFORE the normal event processing fires.  This lets you
//        ensure that certain actions will happen when you want them to.
//
//    You define events by calling Page.setEvent, eg:
//
//        Page.setEvent("eventName","action", fireStyle)
//
//<

//
//    add properties to the Page object
//
isc.Page.addClassProperties(
{
    //>    @classAttr    isc.Page._eventRegistry        (array : [] : IRWA)
    //            Registry for global events registered with Page event registry
    //        @group    EventRegistry
    //        @see    Page.setEvent()
    //<
    _eventRegistry : {},

    //>    @classAttr    isc.Page._pageEventID        (number : 0 : IRWA)
    //            ID number for global events registered with Page event registry
    //        @group    EventRegistry
    //        @see    Page.setEvent()
    //<
    _pageEventID : 0,

    //>    @type    FireStyle
    // Flags to set automatic removal of events from the page event registry.
    //    @value    null                 Call the registered handler any time the event occurs
    //    @value    isc.Page.FIRE_ONCE   Call the registered handler the first time the event
    //                               occurs, then unregister the handler as though
    //                               +link{Page.clearEvent()} had been called
    // @group EventRegistry
    // @see Page.setEvent()
    // @visibility external
    //<
    FIRE_ONCE : "once",

    //>    @classAttr    isc.Page._keyRegistry        (array : [] : IRWA)
    //            Registry for keyboard events registered with Page key registry
    //        @group    KeyRegistry
    //        @see    Page.registerKey()
    //<
    _keyRegistry : {},


    _modifierKeysRegistry: new Array(32),
    _modifierKeysRegistryCount: 0,


    _OR: 0,
    _AND: 1
});


//
//    add methods for the
//
isc.Page.addClassMethods({

//>    @classMethod    Page.setEvent()
// Register to be called whenever a given type of event occurs, at the page level.
// <p>
// This includes events that also occur on widgets (like "click") and events that only occur at
// the page level ("resize" and "load").
// <p>
// For events that also occur on widgets, page level event registrations will fire BEFORE the
// event handlers on Canvases.   If your action returns <code>false</code>, this will prevent
// the event from getting to the intended Canvas.
// <p>
// Capturing events on widgets can be done by setting one of the event methods available on Canvas
// (and hence available to all widget classes).  See +link{group:widgetEvents}.
//
//        @group    EventRegistry
//
//        @param    eventType (pageEvent)        event type to register for ("mouseDown", "load", etc)
//        @param    action    (string)            string to be eval'd when event fires
//                        (function)            function to be executed when event fires
//                      (object)            an object to call on which a method named "page" +
//                                          eventType will be called
//        @param    [fireStyle](FireStyle)    Flag to set automatic removal of the event after
//                                                it fires one or more times
//      @param  [functionName] (string)     optional - if an object was passed in as the second
//                                          parameter, this is a name of a method to call on that
//                                          object.
//
//        @return            (number)    ID number of this event, may be used to remove the event later
//                                        via a call to <code>Page.clearEvent()</code>
// @see class:EventHandler
// @see classMethod:EventHandler.getX()
// @see classMethod:EventHandler.getY()
// @visibility external
//<
setEvent : function (eventType, action, fireStyle, functionName) {
    // make sure the action is a function
    if (isc.isA.String(action)) {

        if (eventType == isc.EH.LOAD || eventType == isc.EH.IDLE ||
            eventType == isc.EH.RESIZE || eventType == isc.EH.ORIENTATION_CHANGE)
        {
            action = isc._makeFunction("target,eventInfo", action);
        } else {
            action = isc.Func.expressionToFunction("target,eventInfo", action);
        }
    }


    //>DEBUG
    if (this.logIsDebugEnabled()) {
        this.logDebug("setEvent("+eventType+"): action => " +
                     (isc.isA.Function(action) ? isc.Func.getShortBody(action) : action));
                     //(eventType == "load" ? "\r\n" + Page.getStackTrace() : ""));
    }
    //<DEBUG

    var ID = isc.Page._pageEventID++,        // id of this event
        handler = {                    // create the handler object that we'll save
            action : action,
            functionName : functionName,
            fireStyle : fireStyle,
            ID : ID
        };

    // make sure there's a slot for this eventType
    var registry = this._eventRegistry;
    if (!isc.isAn.Array(registry[eventType])) registry[eventType] = [];

    // add the handler
    registry[eventType].add(handler);

    // if this is the "idle" event, start the idle timer if necessary
    if (eventType == isc.EH.IDLE) {
//        this.logWarn("scheduling idle event " + action);
        isc.EventHandler.startIdleTimer();
    }

    // return the ID of this event
    return ID;
},



//>    @classMethod    Page.clearEvent()
//    Clear event(s) under the given eventType.<p>
//    To clear all events, omit the ID parameter.  To clear a specific event,
//    pass the ID that was returned by Page.setEvent().
//        @group    EventRegistry
//
//        @param    eventType    (PageEvent, Event) event type to clear
//        @param    [ID]        (number)    ID of the event to clear.
//                                        If not specified, all events in eventType will be cleared.
// @see class:EventHandler
// @visibility external
//<
_$ID:"ID",
clearEvent : function (eventType, ID) {


    var registry = this._eventRegistry;
    if (ID == null) {
        registry[eventType] = [];
    } else {
        // If we're currently processing this event type, don't modify the length of the array
        // Clear the entry and allow the processing function to clear out the empty slots when
        // it completes
        if (this._processingEvent == eventType) {
            var reg = registry[eventType],
                index = isc.isA.Array(reg) ? reg.findIndex(this._$ID, ID) : -1;
            if (index != -1) reg[index] = null;

        // Otherwise just clear out the appropriate entry.
        } else {
            if (isc.isA.Array(registry[eventType])) {
                registry[eventType].removeWhere(this._$ID, ID);
            }
        }
    }
},

// Helper method to avoid reassembling 'pageClick' et all each time the event is fired
_getPageEventName : function (eventType) {
    var eventMap = this._pageEventMap = this._pageEventMap || {};
    if (!eventMap[eventType]) {
        eventMap[eventType] =
                "page" + eventType.charAt(0).toUpperCase() + eventType.substring(1);
    }
    return eventMap[eventType];
},

//>    @classMethod    Page.handleEvent()    (A)
//    Handle an event by firing all events in the EventRegistry under a given eventType.
//    Called automatically by the isc.EventHandler in the normal course of handling events.
//        @group    EventRegistry
//
//        @param    target        (object)    Canvas or DOM object that received the event
//        @param    eventType    (string)     name of this event
//        @param    eventInfo    (any)        information passed with a custom event (see e.g. Slider)
//
//        @return            (boolean)    false == cancel further event processing
//                                    anything else == continue processing
//<
handleEvent : function (target, eventType, eventInfo) {
    if (eventType == isc.EH.UNLOAD) isc.Canvas._handleUnload();

    // Check whether the set of modifier keys being held down has changed on every event.
    this._handleModifierKeysChanged();

    // get the list of handlers
    var list = isc.Page._eventRegistry[eventType];

    // if the list is empty, bail
    if (!isc.isAn.Array(list) || list.length == 0) return true;

    var pageEventName = this._getPageEventName(eventType);

    // execute each handler for this eventType in turn, as long as they don't return false
    var keepGoing = true;
    //    if any return false, return false to cancel event processing


    this._processingEvent = eventType;

    for (var i = 0, length = list.length; keepGoing && (i < length); i++) {
        var item = list[i];
        // Note: this array may be sparse - just skip empty entries
        if (!item) continue;

        // if an item is set to only fire once, remove it from the list.
        // NOTE: we want to do this immediately, that way if there's an error during processing of
        // the event, at least it will only happen once!
        if (item.fireStyle == isc.Page.FIRE_ONCE) list[i] = null;

        //>DEBUG
        if (this.logIsDebugEnabled()) {
            this.logDebug("handleEvent(" + eventType + "): firing action => " +
                                    isc.Func.getShortBody(item.action));
        }
        //<DEBUG

        // fire the action
        if (isc.isA.Function(item.action)) {
            // function / expression style
            keepGoing = (item.action(target,eventInfo) != false);
        } else {
            // object style: item.action is an Object (eg a Canvas), which should have either
            // "page"[eventName] invoked on it, or a custom function specified at registration
            // time and stored as item.functionName
            var object = item.action;

            if (!object || object.destroyed) {
                // if the item has been destroyed, remove the registration and continue
                list[i] = null;
                continue;
            }

            var functionName = item.functionName || pageEventName;
            if (isc.isA.Function(object[functionName])) {
                keepGoing = (object[functionName](target,eventInfo) != false);
            }
        }
    }
    this._processingEvent = null;

    // collapse the list of handlers to get rid of any that have been cleared
    // (including those set to fire once).

    this._eventRegistry[eventType].removeEmpty();

    // return whether or not other event handlers should be fired
    return keepGoing;
},

//>    @classMethod    Page.actionsArePendingForEvent()    (A)
//        Return whether any actions are currently pending for a specific event.
//        @group    EventRegistry
//
//        @param    eventType    (string)     name of this event
//
//        @return            (boolean)    true == at least one event is pending
//                                    false == no events pending
//<
actionsArePendingForEvent : function (eventType) {
    return (isc.isAn.Array(this._eventRegistry[eventType]) && this._eventRegistry[eventType].length != 0);
},



//
//    KeyRegistry -- global eventType for keyboard events
//



//>    @classMethod    Page.registerKey()
// Fire some action when the Page receives a keyPress event from a certain key.<br>
// Note that if a widget has keyboard focus, this action will fire only after any widget-level
// keyPress handlers have fired and bubbled the event up to the top of their ancestor chain.<br>
// Multiple actions can be registered to fire on a single keyPress using this method, and can
// be associated with different <code>target</code> objects (which will then be available as
// a parameter when the action is fired).
// <smartclient>
// <br>
// This differs from calling +link{Page.setEvent()} with the <code>"keyPress"</code>
// events registered via <code>setEvent()</code> will fire <i>before</i> widget level handlers
// respond to the event, and will fire for every <code>keyPress</code> event, not just those
// triggered by some specific key or key-combination.
// </smartclient>
//
//
// @group    KeyRegistry
//        @param    key        (KeyIdentifier) key name or identifier object.
//        @param    action    (string)        Action to fire when key is pressed.
//              This can be a string of script to evaluate or a javascript function.<br>
//              This action will be passed 2 parameters: The name of the key pressed will be
//              available as the first parameter or <code>key</code> keyword. The target
//              passed into this method will be available as the second parameter or
//             <code>target</code> keyword.
//      @param  [target]    (any)   If specified this object will be made available to the
//                                  action fired as a parameter.
// @see Canvas.keyPress()
// @see Page.setEvent()
// @see Page.unregisterKey()
// @visibility external
//<

registerKey : function (key, action, target) {

    if (key == null || action == null) return;

    // If passed an object for key, get keyName from it!
    var keyName = key;
    if (isc.isAn.Object(key)) {
        keyName = key.keyName;
    }

    // allow passing either "a" or "A".  Note toUpperCase() will simply no-op on numbers and
    // punctuation.
    if (keyName.length == 1) keyName = keyName.toUpperCase();

    // if we don't recognize the keyName, log a warning and bail
    // A definitive list of keyNames is in the '_virtualKeyMap' on EventHandler
    var isKeyName = false;
    for (var i in isc.EH._virtualKeyMap) {
        if (isc.EH._virtualKeyMap[i] == keyName) {
            isKeyName = true;
            break;
        }
    }

    if (!isKeyName) {
        this.logWarn(
            "Page.registerKey() passed unrecognized key name '" + key +"'. Not registering",
            "events"
        );
        return;
    }


    var keyRegistry = this._keyRegistry;
    // create an array under that key if necessary
    if (!keyRegistry[keyName]) keyRegistry[keyName] = [];

    // add the item to the key registry
    keyRegistry[keyName].add({target:target, action:action, key:key});
},

//>    @classMethod    Page.unregisterKey()
// Clears an action registered to fire on a specific a keyPress event via the +link{Page.registerKey()}
// method.
//        @group    KeyRegistry
//        @see    Page.registerKey()
//
//        @param    actionID (KeyName) Name of key to clear registry entries for.
//        @param    [target] (object) target specified when the action was registered for the key.
//
// @visibility external
//<
unregisterKey : function (key, target) {

    var keyName = key;

    // if the registry item under that key doesn't exist, bail
    if (!this._keyRegistry[keyName]) {
        isc.Log.logInfo("Page.unregisterKey(): No events registered for key " + isc.Log.echo(keyName) + ".", "events");
        return false;
    }
    // remove the item
    this._keyRegistry[keyName].removeWhere("target", target)
},


//>    @classMethod    Page.handleKeyPress()    (A)
//            Handle a key press by firing messages to all listeners of that key
//            registered with the Key Registry.
//        @group    KeyRegistry
//
//        @param    event    (DOM event) DOM event object (as passed by isc.EventHandler)
//        @return            (boolean)    false == stop further event processing
//
//<
handleKeyPress : function () {
    // Get the name for the key
    var EH = isc.EH,
        keyName = EH.getKey(),
        keyRegistry = this._keyRegistry;

    //this.logInfo("keyName is " + keyName +
    //             ", handlers are registered for: " + getKeys(Page._keyRegistry));

    // no one has registered an action for this key
    if (keyRegistry[keyName]) {


        // get the list of actions from the registry

        var actionsInReg = keyRegistry[keyName],
            actions = actionsInReg.duplicate(),
            length = actions.length,
            returnVal = true;

        // Pick up each action to fire from the registry

        for (var i = 0; i < length; i++) {
            var item = actions[i];
            // The item may have been unregistered by another item's action.
            // If so skip it.
            if (!actionsInReg.contains(item)) continue;

            if (!EH._matchesKeyIdentifier(item.key)) continue;

            // CALLBACK API:  available variables:  "key,target"
            // Convert a string callback to a function
            if (item.action != null && !isc.isA.Function(item.action)) {
                isc.Func.replaceWithMethod(item, "action", "key,target");
            }
            returnVal = ((item.action(keyName, item.target) != false) && returnVal);
        }
    }

    // if suppressBackspaceNavigation is true, return false here
    // Note that this will only fire if the event bubbled to the top of the widget
    // chain.

    if (returnVal != false &&
        isc.Page.suppressBackspaceNavigation &&
        keyName == this._$Backspace)
    {
        // Don't return false for backspace keypress on a RichTextCanvas as that suppresses
        // native behavior (deleting content)
        var target = isc.EH.lastEvent.keyTarget;
        if (!target  || !(isc.RichTextCanvas && isc.isA.RichTextCanvas(target))) {
            returnVal = false;
        }
    }

    return returnVal;
},
_$Backspace:"Backspace",


//> @classAttr Page.suppressBackspaceNavigation (boolean : true : IRWA)
// By default most modern browsers will navigate back one page when the user hits the
// backspace key.
// <P>
// Setting this attribute to true will suppress this native behavior. Alternatively,
// developers can explicitly return <code>false</code> from the keyPress event
// (either via event handlers applied to specific widgets, or via +link{Page.registerKey}
// for example) to suppress the native navigation behavior.
// @visibility external
//<
suppressBackspaceNavigation:true,


_registerModifierKeys : function (keys, logic, downAction, upAction, target) {
    if (keys == null || (downAction == null && upAction == null)) return;

    var registry = this._modifierKeysRegistry,
        index = this._getModifierKeysRegistryIndex(keys, logic);
    if (!registry[index]) registry[index] = [];
    registry[index].add({ target: target, downAction: downAction, upAction: upAction });
    ++this._modifierKeysRegistryCount;
},
_getModifierKeysRegistryIndex : function (keys, logic) {

    var flags = isc.Page._getModifierKeysFlags(keys);
    return ((logic == isc.Page._AND ? 0x1 : 0) | (flags << 1));
},
_getModifierKeysFlags : function (keys) {
    var ctrlKey = false, shiftKey = false, altKey = false, metaKey = false;
    if (isc.isAn.Array(keys)) {
        ctrlKey = keys.contains("Ctrl");
        shiftKey = keys.contains("Shift");
        altKey = keys.contains("Alt");
        metaKey = keys.contains("Meta");
    } else if (isc.isAn.Object(keys)) {
        ctrlKey = keys.ctrlKey;
        shiftKey = keys.shiftKey;
        altKey = keys.altKey;
        metaKey = keys.metaKey;
    } else if (keys == "Ctrl") {
        ctrlKey = true;
    } else if (keys == "Shift") {
        shiftKey = true;
    } else if (keys == "Alt") {
        altKey = true;
    } else if (keys == "Meta") {
        metaKey = true;
    }
    return (
        (ctrlKey ? 0x1 : 0) |
        (shiftKey ? 0x2 : 0) |
        (altKey ? 0x4 : 0) |
        (metaKey ? 0x8 : 0));
},

_unregisterModifierKeys : function (keys, logic, target) {

    var registry = this._modifierKeysRegistry,
        index = this._getModifierKeysRegistryIndex(keys, logic),
        items = registry[index];
    if (items) {
        var prevLength = items.length;
        items.removeWhere("target", target);
        this._modifierKeysRegistryCount -= (prevLength - items.length);
    }
},

_currentModifierFlags: 0,

_modifierKeysDown : function (keys) {
    var currentFlags = this._currentModifierFlags,
        flags = this._getModifierKeysFlags(keys);
    return (flags == (currentFlags & flags));
},

_handleModifierKeysChanged : function () {
    if (this._modifierKeysRegistryCount == 0) {
        return;
    }

    var registry = this._modifierKeysRegistry,
        prevFlags = this._currentModifierFlags,
        // This must match _getModifierKeysFlags() above:
        flags = (
            (isc.EH.ctrlKeyDown() ? 0x1 : 0) |
            (isc.EH.shiftKeyDown() ? 0x2 : 0) |
            (isc.EH.altKeyDown() ? 0x4 : 0) |
            (isc.EH.metaKeyDown() ? 0x8 : 0));

    if (flags != prevFlags) {
        for (var i = 0; i < 32; ++i) {
            if (registry[i] != null) {

                var f = (i >> 1),
                    prevDown = false, down = false;
                if (i < 16) {
                    prevDown = ((prevFlags & f) != 0);
                    down = ((flags & f) != 0);
                } else {
                    prevDown = ((prevFlags & f) == f);
                    down = ((flags & f) == f);
                }

                var prevUp = !prevDown,
                    up = !down,
                    wentDown = (prevUp && down),
                    wentUp = (prevDown && up),
                    actionProp = (wentDown ? "downAction" : (wentUp ? "upAction" : null));

                if (actionProp != null) {
                    var items = registry[i];
                    for (var j = 0, length = items.length; j < length; ++j) {
                        var item = items[j],
                            action = item[actionProp];
                        if (action != null) {
                            action(item.target);
                        }
                    }
                }
            }
        }
    }

    this._currentModifierFlags = flags;

}

});    // END isc.Page.addMethods




//>    @class    EventHandler
//
// <smartclient>
// The ISC system provides a predictable cross-browser event-handling mechanism for ISC
// widgets. Events can be handled both at the page level (i.e., globally), and at the level of
// individual widgets.
// <p>
// With the exception of a few page-specific events ('load', 'unload', 'idle' and 'resize'),
// events are processed in the following sequence:
// <p>
// 1. The event is sent to any global (page-level) event handlers. These handlers can cancel
// further propagation of the event by returning false.  You can register to listen for any of the
// events linked in the seeAlso section (below) by calling +link{classMethod:Page.setEvent()}
// method.
// <p>
// 2. If the event occurred on a form element or a link, it is passed on to the browser so that
// the element will perform its default action. No widget receives the event.
// <p>
// 3. If the event occurred on an enabled widget (but not on a form element or link inside
// the widget), it is sent to that widget's event handler, if any. This handler can cancel
// further propagation of the event by returning false.  An "enabled" widget is any widget that
// defines an event handler for one of the supported events.  Interceptable events are defined in
// the +link{class:Canvas#methods#events, "widgetEvents" section of Canvas}.
// <p>
// 4. The event is "bubbled" up to the widget's parent in the containment hierarchy, if any.
// Again, the parent's handler for the event can cancel further propagation by returning
// false. This step is repeated, with the event "bubbling" up through the containment
// hierarchy, until a top-level widget is reached or the event is explicitly canceled.
// In brief, the ISC event model offers the best features of browser event models:
// <ul>
// <li> Page-first event handling allows you to reliably process or cancel any event before it
//      affects the objects on the page.
// <li> Event "bubbling" ensures that parent widgets receive events sent to their children,
//      and allows you to create generalized parent-level handlers rather than duplicating
//      code in each child.
// </ul>
// Note: Canceling propagation of an event may cancel its side effects as well, including the
// generation of other (synthetic) events. For example, if a global mouseDown handler returns
// false, drag-and-drop events will not be generated. Specific effects are discussed in the
// descriptions of the various events in the following sections.
// <p>
// SmartClient libraries will not interfere with native event handling when events occur
// outside of a target widget. You can therefore have HTML that is not ISC-based on the same
// page as widget objects that will react to native events as you would expect.
// <p>
// You can use isc.Event as an alias for isc.EventHandler.
// </smartclient>
// <smartgwt>
// SmartGWT provides a predictable cross-browser event-handling mechanism for SmartGWT
// widgets, and the EventHandler class provides various static APIs for retrieving details
// about events which have occurred.
// <P>
// Events may be intercepted at the page level using standard GWT methods such as
// <i>addNativePreviewHandler()</i> on the
// <code>com.google.gwt.user.client.Event</code> class.
// <P>
// If the event occurred on an enabled widget it is sent to that widget's event handler,
// if any. This handler can cancel
// further propagation of the event by returning false.  An "enabled" widget is any widget that
// defines an event handler for one of the supported events.
// <p>
// The event is "bubbled" up to the widget's parent in the containment hierarchy, if any.
// Again, the parent's handler for the event can cancel further propagation by calling
// <code>event.cancel()</code>. This step is repeated, with the event "bubbling" up
//  through the containment hierarchy, until a top-level widget is reached or the event is
//  explicitly canceled.
// <P>
// Where applicable, canceling an event will also typically suppress the native behavior
// (for example canceling a keypress while focused in a form item may prevent the
// key character being inserted in the text box).
// <p>
// SmartGWT libraries will not interfere with native event handling when events occur
// outside of a target widget. You can therefore have HTML that is not ISC-based on the same
// page as widget objects that will react to native events as you would expect.
// </smartgwt>
//
// @see type:PageEvent
// @see classMethod:Page.setEvent()
// @see classMethod:Page.clearEvent()
// @see class:Canvas#methods#widgetEvents
//
// @treeLocation   Client Reference/System
// @visibility external
//<

//> @groupDef eventBubbling
// Event "bubbling" refers to the propagation of an event up the containment hierachy, so that
// it's fired on each widget in the chain, unless canceled.  See +link{EventHandler} for further
// discussion.
//<




// create the isc.EventHandler object
isc.ClassFactory.defineClass("EventHandler");
// nicknames - isc.Event is publicly documented as an alias
isc.EH = isc.Event = isc.EventHandler;
// add class properties and constants
isc.EventHandler.addClassProperties(
{
    //>    @classAttr    isc.EventHandler.lastEvent        (object : {} : IRWA)
    //        Last event that was processed by our event system.  We store the properties
    //         of the event in a separate object so we can access them uniformly on both
    //         platforms and so we can remember characteristics of the last event we've
    //         seen even when we're not in the script context of this event.<br><br>
    //
    //        To access properties of the last event, use:<ul>
    //            <li>isc.EventHandler.getLastEvent()
    //            <li>isc.EventHandler.getX()
    //            <li>isc.EventHandler.getY()
    //            <li>isc.EventHandler.getScreenX()
    //            <li>isc.EventHandler.getScreenY()
    //            <li>isc.EventHandler.getButtonNum()
    //            <li>isc.EventHandler.leftButtonDown()
    //            <li>isc.EventHandler.rightButtonDown()
    //            <li>isc.EventHandler.getKey()
    //          <li>isc.EventHandler.getKeyEventCharacterValue()
    //          <li>isc.EventHandler.getKeyEventCharacter()
    //            <li>isc.EventHandler.shiftKeyDown()
    //            <li>isc.EventHandler.ctrlKeyDown()
    //            <li>isc.EventHandler.altKeyDown()
    //            <li>isc.EventHandler.metaKeyDown()
    //            <li>isc.EventHandler.modifierKeyDown()
    //      </ul>
    //
    //        @group events
    //        @see    isc.EventHandler.getMouseEventProperties()
    //      @see    isc.EventHandler.getKeyEventProperties()
    //  @visibility eventhandler
    //<
    lastEvent : {},

    //>    @classAttr    isc.EventHandler._dropRegistry        (array : [] : IRWA)
    //        Registry of canvases that are interested in receiving drop events.
    //        @group dragdrop
    //        @see    isc.EventHandler.eventHandledNatively()
    //  @visibility internal
    //<
    _dropRegistry : [],

    //>    @classAttr    isc.EventHandler._maskRegistry        (array : [] : IA)
    //        Registry of canvases that have their own _eventMask peers to block mouse
    //        events. Implemented so that canvases with contentsURL (iframe contents)
    //        won't swallow events during drag & drop. When a drag operation begins,
    //        we show the masks for all canvases in this registry.
    // @visibility internal
    //<
    _maskRegistry : [],

    //>    @classAttr    isc.EventHandler.passThroughEvents        (boolean : true : IRWA)
    //            if true, we pass events to anchors and form elements automatically.
    //            false == trap these events
    //        @see    isc.EventHandler.eventHandledNatively()
    // @visibility internal
    //<
    passThroughEvents:true,

    //>    @classAttr    isc.EventHandler.maskNativeEvents (boolean : true : IRWA)
    //      Whether the clickmask should mask events on non ISC-elements as well.
    // @visibility internal
    //<
    maskNativeTargets:true,

    //>    @classAttr    isc.EventHandler.STILL_DOWN_DELAY (integer : 100 : IRWA)
    // amount of time between mouseStillDown messages (msec)
    // @visibility external
    //<
    STILL_DOWN_DELAY     : 100,

    //=    @classAttr    isc.EventHandler.DOUBLE_CLICK_DELAY    amount of time (in milliseconds) between doubleClicks (integer: 500: IRWA)

    DOUBLE_CLICK_DELAY  : 500,
    //> @classAttr isc.EventHandler.IDLE_DELAY (integer : 10 : IRWA)
    // amount of time between idle messages (msec)
    // @visibility external
    //<
    IDLE_DELAY             : 10,

    //> @classAttr isc.EventHandler.STOP_BUBBLING (string : "***STOP***" : IRA)
    // Return this constant from a child event to stop the event propagating to its parent,
    // without suppressing any native browser handling associated with the event.
    // Developers should not need to modify this value - it should be treated as read-only
    // in most circumstances.
    // @visibility external
    //<
    STOP_BUBBLING : "***STOP***",


    //>    @classAttr    isc.EventHandler.ALL_EDGES    (Array of string : ["T","L","B","R","TL","TR","BL","BR"] : IR)
    // Constant containing the full set of edges a component may be resized from.
    // When a component is marked as canDragResize, this will be the default set of edges
    // from which it may be resized.
    // @visibility external
    //<
    ALL_EDGES : ["T","L","B","R","TL","TR","BL","BR"],

    eventTypes :    {
        // Events are documented on Canvas as methods since that's how we expect users to register
        // them on widgets.  Some are also documented here for reference by Page.setEvent()

        //> @type PageEvent
        //
        // Events registerable via +link{classMethod:Page.setEvent()}
        //
        //
        // @value "idle"
        //        Fires repeatedly (every 10 ms by default) when the system is idle (i.e.,
        //        not busy running other scripts) after the page is loaded.
        // @value "load"
        //        Fires when the page has finished loading. It corresponds to the
        //        browser 'load' event normally handled by window.onload.
        // @value "unload"
        //        Fires when the page is exited or unloaded. It corresponds to the
        //        browser 'unload' event normally handled by window.onunload.
        // @value "resize"
        //        Fires when the browser window is resized by the user. It corresponds
        //        to the browser 'resize' event normally handled by window.onresize.
        //
        //
        // @value "mouseDown"
        //        Fires when the left mouse button is pressed on the Page.
        // @value "rightMouseDown"
        //        Fires when the right mouse button is pressed on the Page.
        // @value "mouseMove"
        //        Fires when the mouse moves on the Page.
        // @value "mouseUp"
        //        Fires when the left mouse button released on the Page.
        // @value "click"
        //        Fires when the user clicks the mouse on the Page.
        // @value "doubleClick"
        //        Fires when the uesr double-clicks on the Page.
        //
        // @value "showContextMenu"
        //        Fires when the right mouse button is clicked on the page.  If your event handler
        //        for this event returns false, the native browser context menu will be suppressed.<br>
        //        Note: On the Macintosh platform, <code>Command+Click</code> may be used instead
        //        of right-button click to trigger a context menu event.<br>
        //        On the Opera browser, <code>Ctrl+Shift+Click</code> should be used instead of
        //        right-button click.
        //
        // @value "keyPress" Fires when a user presses a key on the keyboard.
        //
        // @value "orientationChange" Fires when the +link{Page.getOrientation()} changes due
        //        to browser-window resize or rotation of a mobile device.
        //
        // see classMethod:Page.setEvent()
        // see classMethod:Page.clearEvent()
        // @visibility external
        //<

        MOUSE_LEAVE: "mouseLeave",

        MOUSE_DOWN : "mouseDown",
        RIGHT_MOUSE_DOWN : "rightMouseDown",
        MOUSE_MOVE : "mouseMove",
        MOUSE_UP : "mouseUp",
        SHOW_CONTEXT_MENU : "showContextMenu",

        CLICK : "click",
        DOUBLE_CLICK : "doubleClick",
        // the following mouse events are not available on Page
        MOUSE_OUT : "mouseOut",
        MOUSE_STILL_DOWN : "mouseStillDown",
        MOUSE_OVER : "mouseOver",

        POINTER_DOWN: "pointerDown",
        POINTER_MOVE: "pointerMove",
        POINTER_UP: "pointerUp",
        POINTER_CANCEL: "pointerCancel",

        //>Touch
        TOUCH_START: "touchStart",
        TOUCH_MOVE: "touchMove",
        TOUCH_END: "touchEnd",
        TOUCH_CANCEL: "touchCancel",
        LONG_TOUCH:"longTouch",
        //<Touch

        // XXX classify
        SET_DRAG_TRACKER : "setDragTracker",
        GET_DRAG_DATA : "getDragData",
        RELEASE_DRAG_DATA : "releaseDragData",


        DRAG_START:"dragStart",
        DRAG_STOP:"dragStop",
        DRAG_MOVE : "dragMove",
        DRAG_OUT : "dragOut",
        DRAG_REPOSITION_START : "dragRepositionStart",
        DRAG_REPOSITION_MOVE : "dragRepositionMove",
        DRAG_REPOSITION_STOP : "dragRepositionStop",
        DRAG_RESIZE_START : "dragResizeStart",
        DRAG_RESIZE_MOVE : "dragResizeMove",
        DRAG_RESIZE_STOP : "dragResizeStop",

        DROP_OVER : "dropOver",
        DROP_MOVE : "dropMove",
        DROP_OUT : "dropOut",
        DROP : "drop",

        TRANSITION_END : "transitionEnd",

        KEY_DOWN : "keyDown",
        KEY_UP : "keyUp",
        KEY_PRESS : "keyPress",
        MOUSE_WHEEL : "mouseWheel",

        SELECT_START : "selectStart",
        SELECTION_CHANGE : "selectionChange",
        FOCUS_IN : "focusIn",
        FOCUS_OUT : "focusOut",

        IDLE : "idle",
        LOAD : "load",
        UNLOAD : "unload",
        RESIZE : "resize",
        ORIENTATION_CHANGE : "orientationChange"
    },

    // Map used by getMouseEventProperties to convert from native mouse event names to
    // canonicalized versions (available as constants on the EH class).
    _nativeMouseEventMap: {
        // By default all browsers give lowercase event names for the following events*
        //  *Verified on IE6, Windows; Moz 1.73, Windows; Safari 2, Mac; Moz 1.6, Unix;
        mousemove:"mouseMove",
        mousedown:"mouseDown",
        mouseup:"mouseUp",
        click:"click",

        contextmenu:"contextMenu",

        // Proprietary to IE6
        mousewheel:"mouseWheel",
        selectionchange:"selectionChange",
        // Proprietary to Moz
        DOMMouseScroll:"mouseWheel",


        // Also handle being passed an already canonicalized version - may happen if the
        // event passed to getMouseEventProperrties was an ISC event rather than a native event
        mouseMove:"mouseMove",
        mouseDown:"mouseDown",
        mouseUp:"mouseUp",
        mouseWheel:"mouseWheel",

        pointerdown: "pointerDown",
        pointermove: "pointerMove",
        pointerup: "pointerUp",
        pointercancel: "pointerCancel",

        //>Touch
        touchstart:"touchStart",
        touchmove:"touchMove",
        touchend:"touchEnd",
        touchcancel:"touchCancel",
        touchStart:"touchStart",
        touchMove:"touchMove",
        touchEnd:"touchEnd",
        touchCancel:"touchCancel",
        //<Touch

        dragstart:"dragStart",
        drag:"drag",
        dragenter:"dragEnter",
        dragexit:"dragExit",
        dragleave:"dragLeave",
        dragover:"dragOver",
        drop:"drop",
        dragend:"dragEnd",

        selectionstart:"selectionStart",
        selectionStart:"selectionStart",
        selectionchange:"selectionChange",
        selectionChange:"selectionChange"
    },

    // mini state machine state used for firing synthetic mouseDown/mouseUp on Android
    _touchEventStatus : {
        READY_FOR_TOUCH: "ready",
        TOUCH_STARTED: "started",
        TOUCH_ENDING: "ending",
        TOUCH_COMPLETE: "complete"
    },


    _eventHandlerArgString:"event,eventInfo",


    //>    @type    DragOperation
    // Builtin types of drag and drop interactions
    //        @group    dragdrop
    //    @value    isc.EventHandler.DRAG_RESIZE            Resizing by dragging
    DRAG_RESIZE : "dragResize",
    //    @value    isc.EventHandler.DRAG_REPOSITION        Repositioning by dragging
    DRAG_REPOSITION : "dragReposition",
    //    @value    isc.EventHandler.DRAG_SCROLL            Scroll/pan by drag
    DRAG_SCROLL : "dragScroll",
    // @value isc.EventHandler.DRAG_SELECT  Select content via drag
    DRAG_SELECT : "dragSelect",

    //    @value    isc.EventHandler.DRAG            General drag (custom implementation)
    DRAG : "drag",
    //<

    //>    @type    DragAppearance
    //         Different types of effects for showing dragging behavior.
    //    @group    dragdrop
    //    @visibility external
    //
    //    @value    "none"
    //      No default drag appearance is indicated. Your custom dragging routines should
    //      implement some behavior that indicates that the user is in a dragging situation,
    //      and where the mouse is.
    NONE : "none",
    //    @value    "tracker"
    //      A "drag tracker" object is automatically shown and moved around with the
    //      mouse. This is generally set to an icon that represents what is being dragged. The
    //      default tracker is a 10 pixel black square, but you can customize this icon. This
    //      dragAppearance is not recommended for use with drag resizing or drag moving.
    TRACKER : "tracker",
    //    @value    "target"
    //      The target object is actually moved, resized, etc. in real time. This is
    //      recommended for drag repositioning, but not for drag resizing of complex objects.
    TARGET : "target",
    //    @value    "outline"
    //      An outline the size of the target object is moved, resized, etc. with the
    //      mouse. This is recommended for drag resizing, especially for objects that take a
    //      significant amount of time to draw.
    OUTLINE : "outline",
    //<

    //>    @type DragIntersectStyle
    // Different styles of determining intersection: with mouse or entire rect of target
    //
    // @value "mouse" Look for drop targets that are under the current mouse cursor position.
    INTERSECT_WITH_MOUSE : "mouse",
    // @value "rect" Look for drop targets by intersection of the entire rect of the drag
    //               target with the droppable target.
    INTERSECT_WITH_RECT : "rect",
    // @group dragdrop
    // @visibility external
    //<


    artificialDragTargetDefaults: {
        _constructor: "Canvas",
        canDrag: true,
        useNativeDrag: true,
        canDrop: true,
        dragAppearance: "none",

        cloneDragData : function () {
            return isc.EH.getNativeDragData();
        }
    },


    //>    @classAttr  dragTargetShadowDepth   (number : 10 : IRWA);
    //  If we are showing a shadow for some widget on drag, how deep should the shadow be.
    //  @group  dragdrop
    //<
    dragTargetShadowDepth : 10,


    dragOffsetX: 0,
    dragOffsetY: 0,

    _anchorTags : {
        A : true,
        AREA : true
    },
    _formTags : {
        INPUT : true,
        TEXTAREA : true,
        SELECT : true,
        OPTION : true
    },
    _labelString : "LABEL",

    // native event name to camelCase name
    _nativeKeyEventMap : {
        keydown:"keyDown",
        keyup:"keyUp",
        keypress:"keyPress",

        contextmenu:"contextMenu"
    },

    // In IE we don't get native keyPress events on non-character keys.
    // for these keys we generate synthetic keyPress events in handleKeyDown.
    // We use this map of non-character keys to determine which keys are not going to produce
    // a keyPress event natively in IE.

    _nonCharacterKeyMap : {
        Backspace:8,
        Tab:9,
        Shift:16,
        Ctrl:17,
        Alt:18,
        Pause_Break:19,
        Caps_Lock:20,
        // Note - escape seems to be a special case - it gives us no character value, but will fire
        // a keyPress event natively
//        Escape:27,
        Page_Up:33,
        Page_Down:34,
        End:35,
        Home:36,
        Arrow_Left:37,
        Arrow_Up:38,
        Arrow_Right:39,
        Arrow_Down:40,
        Insert:45,
        Delete:46,
        Meta:91,
        //Meta:92,
        f1:112,
        f2:113,
        f3:114,
        f4:115,
        f5:116,
        f6:117,
        f7:118,
        f8:119,
        f9:120,
        f10:121,
        f11:122,
        f12:123,
        Num_Lock:144,
        Scroll_Lock:145
    },

    // In IE, certain alpha keys don't generate a normal keyPress event if the ctrl key
    // is down at the same time.  The map _modifierAppliedKeyMap has bindings for known
    // keys with this behavior.

    _modifierAppliedKeyMap : {
        A: true,
        C: true,
        D: true,
        R: true,
        V: true
    },

    // In Safari / Chrome we get no native keyPress events for character keys as well.
    // However the list is slightly different from in IE - it includes Escape.

    _safariNonCharacterKeyMap : {
        Backspace:true,
        Tab:true,
        Shift:true,
        Ctrl:true,
        Alt:true,
        Pause_Break:true,
        Caps_Lock:true,
        Escape:true,
        Page_Up:true,
        Page_Down:true,
        End:true,
        Home:true,
        Arrow_Left:true,
        Arrow_Up:true,
        Arrow_Right:true,
        Arrow_Down:true,
        Insert:true,
        Delete:true,
        Meta:true,
        Menu:true,

        f1:true,
        f2:true,
        f3:true,
        f4:true,
        f5:true,
        f6:true,
        f7:true,
        f8:true,
        f9:true,
        f10:true,
        f11:true,
        f12:true,
        // Untested
        Num_Lock:true,
        Scroll_Lock:true
    },

    // Note, the F3 and F11 keys do not fire native keyPress OR keyDown events in Opera, so
    // there is nothing we can do about them, but they are recorded here anyway
    _operaNonCharacterKeyMap : {
        f3:true,
        f11:true
    },

    // Virtual key map
    // virtual key code mappings for every key on the keyboard.
    // Note: While each code maps to a separate key, we're normalizing to a key name - IE
    // we're not going to differentiate between Enter on the keyboard and Enter on the numeric
    // key pad (we can't in some cases on some browsers anyway, and this functionality would be
    // confusing if you weren't expecting it)


    // JSDoc the developer friendly keynames - these are required for accessKeys, registering
    // page level key events, etc.
    //> @type KeyName
    //
    // Strings to identify the various keys on the keyboard.
    // <ul>
    // <li>  For alpha keys, the single (uppercase) character value is used, such as "Q"
    // <li>  For Numeric keys, the number is used as in a single character string, like "1"
    // <li>  Function keys are identified as <code>"f1"</code> - <code>"f12"</code>
    // <li>  Non alpha-numeric character keys (such as the key for "[" / "{") are identified by
    //       their unmodified character value (the value obtained by hitting the key without
    //       holding shift down), by default - exceptions are listed below.
    // <li>  Additional key names:<br>
    //      - <code>Space</code><br>
    //      - <code>Tab</code><br>
    //      - <code>Enter</code><br>
    //      - <code>Escape</code><br>
    //      - <code>Backspace</code><br>
    //      - <code>Insert</code><br>
    //      - <code>Delete</code><br>
    //      - <code>Arrow_Up</code><br>
    //      - <code>Arrow_Down</code><br>
    //      - <code>Arrow_Left</code><br>
    //      - <code>Arrow_Right</code><br>
    //      - <code>Home</code><br>
    //      - <code>End</code><br>
    //      - <code>Page_Up</code><br>
    //      - <code>Page_Down</code><br>
    //      - <code>Shift</code><br>
    //      - <code>Ctrl</code><br>
    //      - <code>Alt</code>
    // </ul>
    // [Note: Some keys may not be available for capture on every platform]
    // @visibility external
    //<
    // Avoid doc'ing keys we may not be able to capture, or which are likely to vary based on
    // OEM keyboard layout, etc.
    //      - <code>Print_Screen</code><br>
    //      - <code>Scroll_Lock</code><br>
    //      - <code>Caps_Lock</code><br>
    //      - <code>Pause_Break</code><br>
    //      - <code>Num_Lock</code><br>
    //      - <code>Menu</code><br>

    // Key Identifiers differ from keyNames in that we include modifier detection as a
    // boolean - used in a few places in the code
    //> @object KeyIdentifier
    // Identifier for a key pressed by the user, optionally specifying whether the Shift, Control,
    // and/or Alt keys should be held or not held when the key is pressed, used by various methods.
    // @treeLocation Client Reference/System/EventHandler
    // @visibility external
    //<
    //> @attr keyIdentifier.keyName (KeyName : null : IR)
    // Name of the key.
    // @visibility external
    //<
    //> @attr keyIdentifier.shiftKey (Boolean : null : IR)
    // If set, whether the Shift key must be held down.
    // @see classMethod:EventHandler.shiftKeyDown()
    // @visibility external
    //<
    //> @attr keyIdentifier.ctrlKey (Boolean : null : IR)
    // If set, whether the Control key must be held down.
    // @see classMethod:EventHandler.ctrlKeyDown()
    // @visibility external
    //<
    //> @attr keyIdentifier.altKey (Boolean : null : IR)
    // If set, whether the Alt key must be held down.
    // @see classMethod:EventHandler.altKeyDown()
    // @visibility external
    //<
    // Not doc'ing Meta- we don't reliably get meta+key events cross platform.
    //> @attr keyIdentifier.metaKey (Boolean : null : IR)
    // If set, whether the meta key must be held down.
    // @see classMethod:EventHandler.metaKeyDown()
    //<

    _virtualKeyMap : {
        // Note - have to quote numeric property names for older browsers
        '0':'_undefined',
                        // 1  Left mouse button
                        // 2  Right mouse button
                        // 3  Control-break processing
                        // 4  Middle mouse button (three-button mouse)
        '8':'Backspace',
        '9':'Tab',

                        //  '12':'Clear',
        '13':'Enter',

        '16':'Shift',
        '17':'Ctrl',
        '18':'Alt',
        '19':'Pause_Break',
        '20':'Caps_Lock',
                        // 21-25  Reserved for Kanji systems

        '27':'Escape',
                        // 28-31  Reserved for Kanji systems


        '32':'Space',
        '33':'Page_Up',
        '34':'Page_Down',
        '35':'End',
        '36':'Home',
        '37':'Arrow_Left',
        '38':'Arrow_Up',
        '39':'Arrow_Right',
        '40':'Arrow_Down',
                        // 41  SELECT key
                        // 42  [Win32: "Original equipment manufacturer (OEM) specific"]
                        // 43  EXECUTE key
        '44':'Print_Screen',    // 44 PRINT SCREEN key for Win 3.0 and later
        '45':'Insert',
        '46':'Delete',
                        // 47  HELP key
        // Note: these are above the main keyboard (not on the numeric keypad)
        '48':'0', "49":"1", "50":"2", "51":"3", "52":"4",
        "53":"5", "54":"6", "55":"7", "56":"8", "57":"9",

        // 58-64  Undefined
        // Exception: These are used on mousedown / mouseup for certain keys normally in
        // the 187-222 range on mac osx / moz


        '58':';', // observed on shift+";" key (Mac osx, Moz)
        '59':';', // observed on ";" (mac osx, moz)
        '60':',', // observed on shift+ "," key (mac osx, moz)
        '61':'=', // mac osx, moz
        '62':"/", // observed on shift+ "/" key mac osx, moz


        // Standard Char keys
        '65':'A', '66':'B', '67':'C', '68':'D', '69':'E', '70':'F',
        '71':'G', '72':'H', '73':'I', '74':'J', '75':'K', '76':'L',
        '77':'M', '78':'N', '79':'O', '80':'P', '81':'Q', '82':'R',
        '83':'S', '84':'T', '85':'U', '86':'V', '87':'W', '88':'X',
        '89':'Y', '90':'Z',

        '91':'Meta',    // Meta Left
        '92':'Meta',    // Meta Right

        // 93  Application key [Win32: "Undefined"]
        //      - from observation, this is returned from the 'context menu' key (next to the right
        //        meta key on windows 2k, IE and Moz, US keyboard)
        '93':'Menu',

        //  94-95 Undefined

        // keys on the numeric keypad
        '96':'0', '97':'1', '98':'2', '99':'3', '100':'4',
        '101':'5', '102':'6', '103':'7', '104':'8', '105':'9',

        '106':'*',  //  The Multiply key
        '107':'+',  //  Add key  (on the keypad - not "=+")
                        // 108  Separator key
        '109':'-',  //  Minus key
        '110':'.',  //  Decimal key
        '111':'/',  //  Divide key

        '112':'f1', '113':'f2', '114':'f3', '115':'f4', '116':'f5', '117':'f6',
        '118':'f7', '119':'f8', '120':'f9', '121':'f10', '122':'f11', '123':'f12',
                        // 124-143  Unassigned

        '144':'Num_Lock',
        '145':'Scroll_Lock',    // OEM specific - true on Windows

                        // 146-159  Unassigned

        '160':'Shift',  //  Left SHIFT key [Win32: "Unassigned"]
        '161':'Shift',  //  Right SHIFT key [Win32: "Unassigned"]

        '162':'Ctrl',   //  Left CTRL key [Win32: "Unassigned"]
        '163':'Ctrl',   //  Right CTRL key [Win32: "Unassigned"]

        '164':'Alt',    //  Left ALT key [Win32: "Unassigned"]
        '165':'Alt',    //  Right ALT key [Win32: "Unassigned"]

                        //  166-185  Unassigned
                        //  186-192  OEM specific   * See below

                        //  193-218  Unassigned
                        //  219-228  OEM specific
                        //  229  Precedes extended key [Win32: "Unassigned"]
                        //  230  OEM specific
                        //  231-232  Unassigned
                        //  233-245  OEM specific

        // xxx
        // There is no guarantee for the punctuation keys.  They will vary by locale and
        // platform.
        // We can't ask for the keyboard mapping, and but let's handle the MS Windows US keyboard
        // layout by default.
        // NOTE: this is one reason to make use of Ascii keycodes when we have them.

        '186':';',      //  VK_OEM_1 0xBA ";:" for US
        '187':'=',      // '+',  VK_OEM_PLUS 0xBB "+" any country
        '188':',',      //  VK_OEM_COMMA 0xBC "," any country
        '189':'-',      //  VK_OEM_MINUS 0xBD "-" any country
        '190':'.',      //  VK_OEM_PERIOD 0xBE "." any country
        '191':'/',      //  VK_OEM_2 0xBF "/?" for US
        '192':'`',      //  VK_OEM_3 0xC0 "`~" for US


        '219':'[',      //  VK_OEM_4 0xDB "[{" for US
        '220':'\\',     //  VK_OEM_5 0xDC "\|" for US
        '221':']',      //  VK_OEM_6 0xDD "]}" for US
        '222':"'"       //  VK_OEM_7 0xDE "'"" for US


        ,'224':"Meta"

                        //  VK_OEM_AX 0xE1 AX key on Japanese AX keyboard
                        //  VK_OEM_102 0xE2 "<>" or "\|" on RT 102-key keyboard

    },



    _charsetValueToKeyNameMap : {

        // Don't worry about any control characters that aren't directly mapped to a key
        // on the keyboard
        '8':'Backspace',
        '9':'Tab',
        '13':'Enter',
        '27':'Escape',

        // Normalize the character to the key name
        // Note: This is occasionaly ambiguous - such as when hitting "*", it could be the
        // * above the 8, or it could be the * on the keypad
        // Note: Choosing somewhat arbitrary names for the keys - just make sure this stays
        // constant.
        '32':'Space',   //' '
        '33':'1',   //'!'
        '34':"'",   //'"'
        '35':'3',   //'#',
        '36':'4',   //'$',
        '37':'5',   //'%',
        '38':'7',   //'&',

        '39':"'",
        '40':'9',   //'(',
        '41':'0',   //')',

        '42':'8',   //'*',  // May be wrong if on the keypad
        '43':'=',   //'+'   // May be wrong if on the keypad

        '44':',',    '45':'-',     '46':'.',    '47':'/',

        '48':'0', '49':'1', '50':'2', '51':'3', '52':'4',
        '53':'5', '54':'6', '55':'7', '56':'8', '57':'9',

        '58':';',    //':',
        '59':';',

        '60':',',   //'<',
        '61':'=',
        '62':'.',   //'>',
        '63':'/',   //'?',

        '64':'2',   //'@',  // an example of US-Only mapping

        '65':'A', '66':'B', '67':'C', '68':'D', '69':'E', '70':'F', '71':'G',
        '72':'H', '73':'I', '74':'J', '75':'K', '76':'L', '77':'M', '78':'N',
        '79':'O', '80':'P', '81':'Q', '82':'R', '83':'S', '84':'T', '85':'U',
        '86':'V', '87':'W', '88':'X', '89':'Y', '90':'Z',

        '91':'[',   '92':'\\',   '93':']',

        '94':'6',   //'^',
        '95':'-',   //'_',
        '96':'`',

        '97':'A',   //'a',
        '98':'B',   //'b',
        '99':'C',   //'c',
        '100':'D',  //'d',
        '101':'E',  //'e',
        '102':'F',  //'f',
        '103':'G',  //'g',
        '104':'H',  //'h',
        '105':'I',  //'i',
        '106':'J',  //'j',
        '107':'K',  //'k',
        '108':'L',  //'l',
        '109':'M',  //'m',
        '110':'N',  //'n',
        '111':'O',  //'o',
        '112':'P',  //'p',
        '113':'Q',  //'q',
        '114':'R',  //'r',
        '115':'S',  //'s',
        '116':'T',  //'t',
        '117':'U',  //'u',
        '118':'V',  //'v',
        '119':'W',  //'w',
        '120':'X',  //'x',
        '121':'Y',  //'y',
        '122':'Z',  //'z',

        '123':'[',  //'{',
        '124':'\\',  //'|',
        '125':']',  //'}',
        '126':'`'  //'~'
        // Beyond this they are a bunch of special characters we should not need to worry about

    },


    _safariSpecialKeyPressMap : {
        '3':"Enter",

        '25':"Tab", // This happens with shift+tab

        '63232':"Arrow_Up",
        '63233':"Arrow_Down",
        '63234':"Arrow_Left",
        '63235':"Arrow_Right",

        // Note f8/f9/f10 don't fire an event - cos they take OS focus from the browser
        '64236':"f1", '64237':"f2", '64238':"f3", '64239':"f4", '64240':"f5", '64241':"f6",
        '64242':"f7", '64243':"f8", '64244':"f9", '64245':"f10", '64246':"f11", '63247':"f12",

        '63273':"Home",
        '63275':"End",
        '63276':"Page_Up",
        '63277':"Page_Down"
    },


    // _eventHandlerMap - mapping between normal event names and names for internal handler
    //  functions, eg "mouseDown" -> "handleMouseDown"
    // - Retrieve using "_getInternalHandlerName(event)"
    // - generated on the fly for any event name
    // (See comments in bubbleEvent())
    _eventHandlerMap : {
    },




    //>PluginBridges
    // if there are backMask-requring elements on the page, should we show/hide the backMask on the
    // dragMoveTarget on intersect or just show it all the time?
    //
    // Running intersection tests on every dragMove is expensive, so this is disabled.  Note
    // however, that these intersection tests are required to force correct repainting of
    // Applets obscured by drag and drop in realtime.  But that only happens on older JDKs and
    // can greatly slow down the browser.  See notes in Applet.repaintOnDragStop() for more info.
    dynamicBackMask: false,

    // don't bother to compute what may require backmasking, just always show the backMask.
    // Also useful if the page contains items that require backmasking but that SmartClient
    // doesn't know about - e.g custom iframes.
    alwaysBackMask: false,
    //<PluginBridges

    //>    @classAttr    isc.EventHandler.dragTrackerDefaults (object literal : _lookup_ : IA)
    //        Default properties for the drag tracker.
    // @visibility internal
    //<

    dragTrackerDefaults : {
            ID:"isc_dragTracker",
            _isDragTracker:true,
            width: 10,
            height: 10,
            offsetX: -10,
            offsetY: -10,
            autoDraw: false,
            visibility:"hidden",
            overflow:"visible",
            cursor:"arrow",
            // hide using display:none so it doesn't
            // impact the scroll size of the page as a whole when hidden
            hideUsingDisplayNone:true

    }
}
);// END isc.EventHandler.addClassProperties()

// Add each of the event types in isc.EventHandler.eventTypes directly to the event handler object
isc.EventHandler.addClassProperties(isc.EventHandler.eventTypes);


isc.EventHandler.addClassMethods({


handleSyntheticEvent : function (event) {

    var target = event.target;
    event._isSynthetic = true;
    //this.logWarn("synthetic event: " + isc.echoAll(event));

    if (target) {
        event.clientX += target.getPageLeft();
        event.clientY += target.getPageTop();


        if(isc.Browser.isIE) {
            /*
            this.logWarn("left margin: " +  target.getLeftMargin()
                         + " border: " + target.getLeftBorderSize()
                         + " padding: " + target.getLeftPadding());
            */
            event.clientX += target.getLeftMargin() + target.getLeftBorderSize()
                             + target.getLeftPadding() + 2;
            event.clientY += target.getTopMargin() + target.getRightBorderSize()
                             + target.getTopPadding() + 2;
        }
        /*
        this.logWarn("synthetic event on: " + target.getID()
                     + " ("+event.type+": "+event.clientX+", "+event.clientY+")");
        */

        switch (event.type) {
            case "mouseup": this.handleMouseUp(event); break;
            case "mousedown": this.handleMouseDown(event); break;
            case "mousemove": this.handleMouseMove(event); break;
        }
    }
},

//>    @classMethod    isc.EventHandler.handleEvent()  (A)
// Routine to handle generic events that are not handled specially
//     (currently everything but keyPress, mouseDown, mouseUp, mouseStillDown, mouseMove).
//
//        @group    eventHandling
//
//        @param    target        (object)    Canvas or DOM object that received the event
//        @param    eventType    (string)     name of this event
//        @param    eventInfo    (any)        information passed with a custom event (see e.g. Slider)
//
//        @return            (boolean)    false == cancel further event processing
//                                    anything else == continue processing
//      @visibility eventhandler
//<

handleEvent : function (target, eventType, eventInfo, eventItem) {

    this._handlingEvent = eventType;


        var EH = isc.EH;

    // process the event globally
    var returnVal;
      if (isc.Page.handleEvent(target, eventType, eventInfo, eventItem) == false) {
          returnVal = false;

    // if the target is enabled
    //     bubble the event up the target's chain
    } else if (EH.targetIsEnabled(target) &&
               EH.bubbleEvent(target, eventType, eventInfo, null, eventItem) == false)
    {
        returnVal =false;
    } else {
        returnVal = true;
    }

    delete this._handlingEvent;

    return returnVal;
},


// Handler for the page-level load event.  Internal - developers use Page.setEvent() instead
handleLoad : function (DOMevent) {
    // ensure that SA_Page onload fires before Page's onload handlers.  The History module in
    // particular registers onload handlers that must fire before the Page onload, but because
    // IE's attachEvent() mechanism doesn't fire events in order of registration, we need to
    // kick SA_Page here.
    if (isc.SA_Page) isc.SA_Page._firePageLoadCallbacks();

    if (!isc.Browser.isMoz) {

        if (isc.EH._useEventListenerForUnload() && document && document.body) {
            document.body.addEventListener("unload", isc.EH.handleUnload, false);
        }
    }

    if (isc.Log.supportsOnError) {
        return (isc.Page.handleEvent(null, isc.EH.LOAD) != false);
    } else {
        try {
            return (isc.Page.handleEvent(null, isc.EH.LOAD) != false);
        } catch (e) {

            isc.Log._reportJSError(e);
            throw e;; // extra semi for Safari
        }
    }
},


// Handler for the page-level unload event.  Internal - developers use Page.setEvent() instead
handleUnload : function (DOMevent) {

        var EH = isc.EH;

    var result = (isc.Page.handleEvent(null, EH.UNLOAD) != false);


    if (result == true) {
        this.releaseEvents();
    }
    return result;
},

//> @groupDef keyboardEvents
// SmartClient allows keyboard events to be captured at the page level via
// +link{isc.Page.registerKey()}
// <smartclient> or +link{Page.setEvent()} </smartclient>
// or at the widget level
// via +link{canvas.keyDown()}, +link{canvas.keyPress()}, and +link{canvas.keyUp}.
// <P>
// Details about the key events can be retrieved via static methods on the EventHandler class
// including +link{isc.EventHandler.getKey()}, +link{isc.EventHandler.getKeyEventCharacter()} and
// +link{isc.EventHandler.getKeyEventCharacterValue()}.
// <P>
// As with other SmartClient event handling code, returning <code>false</code> will suppress the
// default native browser behavior.<br>
// <b>Note:</b> browsers do not allow cancellation of some keys' default behaviors.
// These cases vary by browser, and wherever native cancellation is supported, returning false
// from your event handler should be sufficient to suppress the behavior.
// <br>
// Some specific cases where default behavior cancellation is not always possible include:
// <ul><li>Some function keys (<code>f1, f3, f5,</code> etc) which trigger native browser behavior.
//         [These can be suppressed in Internet Explorer and Mozilla Firefox but not in some other
//          browsers such as Safari / Chrome, etc]</li>
//     <li>Some accelerator key combos such as <code>Alt+f3</code></li>
//     <li>The "Meta" key (the <code>Windows</code> / <code>Apple</code> key to show OS level menu)
//     </li>
// </ul>
// If you do want to include functionality for these keys in your application, we'd recommend
// testing against your expected users' browser types. It is also worth considering whether by
// changing the functionality of these standard browser keys you may provide an unexpected
// user experience (for example a user may press "f5" in an attempt to reload the application
// and be surprised by this triggering some alternative functionality in your application).
//
// @treeLocation Concepts
// @visibility external
// @title Keyboard Events
//<











// NOTE: naming:
// - handleNativeKey*: directly called by DOM
// - handleKey*: called on EH object

// called directly by DOM
_$f10:"f10",
_$Escape:"Escape",
_keyDownKeyNames:[],
_syntheticKeypressFired:{},
_handleNativeKeyDown : function (DOMevent, fromOnHelp) {
    // Some browsers (like Mac IE) have problems dealing with events fired before the page finishes loading.
    //    Just skip key event processing if the page hasn't loaded yet.
    //!DONTCOMBINE
    if (!isc.Page.isLoaded()) return false;

    //isc.logWarn("Received native keyDown: " + DOMevent.keyIdentifier + ", " + DOMevent.which + ": " + isc.echoAll(DOMevent));


        var EH = isc.EH;




    var lastEvent = EH.lastEvent;

    if (!DOMevent) DOMevent = EH.getWindow().event;

    // Get the details of the event (stored in EH.lastEvent)
    EH.getKeyEventProperties(DOMevent);

    //isc.logWarn("IE F1 info:  " + isc.Browser.isIE + ", " + lastEvent.keyName + ", " + fromOnHelp);

    if (isc.Browser.isIE && lastEvent.keyName == this._$f1 && !fromOnHelp) {

        return;
    }



    var returnVal = true;


    var keyName = lastEvent.keyName,
        charValue = lastEvent.characterValue;

    //isc.logWarn("In native keydown handler, lastEvent.keyName is " + keyName +
    //            ", lastEvent.characterValue is " + charValue);

    var keyDownKeys = EH._keyDownKeyNames.duplicate();
    for (var i = 0; i < keyDownKeys.length; i++) {
        var prevKeyName = keyDownKeys[i];
        if (prevKeyName == null || prevKeyName == keyName) break;

        // skip this if it's a key where we always just fire a synthetic keypress on keyDown
        // since we will have already handled it.
        if (this._fireKeypressOnKeyDown(prevKeyName)) continue;




        lastEvent.characterValue = null;
        // copy the previous keyName onto the event so handleKeyPress gets the correct args
        lastEvent.keyName = prevKeyName;

        // Fire handleKeyPress with no arguments - this'll fire event handlers based on the
        // specified keyName, and remove it from keyDownKeyNames

        this.handleKeyPress();
        EH._syntheticKeypressFired[lastEvent.keyName] = true;
    }
    // We may have changed this to a previously-down keyName in the above loop. reset to the
    // current key.
    lastEvent.keyName = keyName;
    lastEvent.characterValue = charValue;

    // the above caught keyDown on another key.. this handles repeated keyDown events for the
    // same key, which should basically fire repeated keypress events.
    var fireSyntheticKeyPress = this._fireKeypressOnKeyDown(keyName);

    if (EH._keyDownKeyNames.indexOf(lastEvent.keyName) != -1) {
        // We can skip this logic if we know we'll fire keyPress (below).
        if (!fireSyntheticKeyPress) {
            returnVal = EH.handleKeyPress();
            EH._syntheticKeypressFired[lastEvent.keyName] = true;


        }
    } else {
        returnVal = EH.handleKeyDown(DOMevent);
    }


    if (returnVal != false && lastEvent.keyName) {
        EH._keyDownKeyNames[EH._keyDownKeyNames.length] = lastEvent.keyName;
    }

    EH._ctrlKeyOnLastUpDown = lastEvent.ctrlKey;
    EH._altKeyOnLastUpDown = lastEvent.altKey;


    if (returnVal != false && fireSyntheticKeyPress) {
        returnVal = EH.handleKeyPress(DOMevent);
        EH._syntheticKeypressFired[lastEvent.keyName] = true;
    }
    if (returnVal == false) {
        this.cancelKeyEvent(DOMevent);
    }
    return returnVal;
},

// Browser Specific _fireKeypressOnKeyDown() versions:
// for cases where we know we'll have to fire a synthetic keyPress on keyDown:

// default
_fireKeypressOnKeyDown : function (keyName) { return false; },

// Mozilla
_mozFireKeypressOnKeyDown : function (keyName) {
    return keyName == this._$f10 && this.shiftKeyDown();
},

// IE
_ieFireKeypressOnKeyDown : function (keyName) {
    var EH = isc.EH;
    if (EH._nonCharacterKeyMap[keyName] != null) return true;
    // Testing in IE6+ shows that hardly any Ctrl- or Alt- combinations fire a keyPress event,
    // and those that do, do not suppress native behavior if the custom event code returns
    // false.  So in IE, we always want synthetic keyPress events for Ctrl- and Alt-
    // combinations, and the old code base around the "_modifierAppliedKeyMap" map of keys
    // that need special handling is obsolete and removed
    return EH._modifierKeyDownOnly();
},

// Safari / Chrome non character key
_chromeSyntheticAltShiftKeys: {
    B: true,
    I: true,
    T: true
},
_safariFireKeypressOnKeyDown : function (keyName) {
    var EH = isc.EH;
    var event = EH.lastEvent;
    // Similar to IE, above, testing with Chrome on Windows and Linux shows that it actually
    // fires a native keyPress event for hardly any Ctrl+{character key} combinations, and those
    // it does fire are often problematic (eg, Ctrl+Enter, which indicates the wrong keyCode and
    // is indistinguishable from a Ctrl+J keyPress).  So similarly, we need to fire synthetic
    // events for all Ctrl- and Alt- combos, so client key handlers have a chance to cancel native
    // browser behavior tied to Ctrl-key combos like Ctrl-F, Ctrl-M, etc.
    // Shift-Ctrl- combinations, on the other hand, generally do fire a native keyPress event,
    // but it cannot be cancelled so there is no way to suppress the default browser behavior.
    // So we need to use synthetic events for Shift-Ctrl- combos as well.  Shift-Alt
    // combinations generally fire a regular, cancellable keyPress event, but there are a few
    // that cannot be cancelled, so we must synthesize those as well
    if (!isc.Browser.isMac) {
        if (EH.lastEvent.altKey && EH.lastEvent.shiftKey &&
                    EH._chromeSyntheticAltShiftKeys[keyName])
        {
            return true;
        }
        if (EH._modifierKeyDownOnly(EH.lastEvent, true)) return true;
    }
    if (EH._safariNonCharacterKeyMap[keyName] != null) return true;
    return EH._modifierAppliedKeyMap[keyName] != null && EH._modifierKeyDownOnly();
},

// Opera - fire synthetic keyPress for Ctrl- and Alt- combinations
_operaFireKeypressOnKeyDown : function (keyName) {
    var EH = isc.EH;
    var event = EH.lastEvent;
    // Same as Chrome, testing with Opera on Windows shows that it actually fires a native
    // keyPress event for hardly any Ctrl+{character key} combinations, so we need to fire
    // synthetic events
    if (!isc.Browser.isMac) {
        if (EH._modifierKeyDownOnly()) return true;
    }
    return !!EH._operaNonCharacterKeyMap[keyName];
},

// internal routines used for deciding whether to generate synthetic keypress
_modifierKeyDownOnly : function (event, shiftAlso) {
    if (!event) event = this.lastEvent;
    if (isc.Browser.isMac) return event.metaKey && !event.altKey && (shiftAlso || !event.shiftKey);
    // Return true if either the Ctrl key or Alt Key are down (but not both)
    else return (event.ctrlKey && !event.metaKey && !event.altKey && (shiftAlso || !event.shiftKey)) ||
                // "shiftAlso" only applies to Ctrl- combos - Alt- ones typically fire reliable keyPress events
                (event.altKey && !event.metaKey && !event.ctrlKey && !event.shiftKey);
},

// handleKeyDown() fires the keyDown handler on the event target.
// called in response to document.keyDown _handleNativeKeyDown().

_$Tab:"Tab",
handleKeyDown : function (nativeEvent, scEventProperties) {

    var EH = isc.EH,
        lastEvent = EH.lastEvent,
        returnVal;
    // If the event is handled natively, we will avoid doing any of our own processing and
    // return true to allow native processing

    var handledNatively = EH.eventHandledNatively(lastEvent.eventType, lastEvent.nativeKeyTarget);
    if (handledNatively) returnVal = EH._handledNativelyReturnVal;

    if (scEventProperties != null) isc.addProperties(lastEvent, scEventProperties);
    if (!handledNatively) {

        var eventInfo = [lastEvent, lastEvent.target, lastEvent.keyName];

        var target = lastEvent.keyTarget;
        //EH.logWarn("nativeEvent: " + EH.echoDOM(nativeEvent) +
        //           ", nativeTarget: " + EH.echoLeaf(lastEvent.nativeTarget));
        //EH.logWarn("lastEvent.target (before re-calling getEventTargetCanvas()):" + target);
        if (target == null) target = this.getEventTargetCanvas(nativeEvent,
                                                               lastEvent.nativeKeyTarget);
        if (EH.targetIsEnabled(target)) {
            returnVal = (EH.bubbleEvent(target, EH.KEY_DOWN, eventInfo) != false);
        }
    }

    return returnVal;
},

// called by DOM
_handleNativeKeyUp : function (DOMevent) {
    // Some browsers (like Mac IE) have problems dealing with events fired before the page finishes loading.
    //    Just skip key event processing if the page hasn't loaded yet.
    //!DONTCOMBINE
    if (!isc.Page.isLoaded()) return false;

    var EH = isc.EH,
        lastEvent = EH.lastEvent;

    if (!DOMevent) DOMevent = EH.getWindow().event;
    // get key event properties (stored in EH.lastEvent)
    EH.getKeyEventProperties(DOMevent);


    EH._ctrlKeyOnLastUpDown = lastEvent.ctrlKey
    EH._altKeyOnLastUpDown = lastEvent.altKey


    EH._syntheticKeypressFired[lastEvent.keyName] = null;


    if (EH._keyDownKeyNames.indexOf(EH.lastEvent.keyName) != -1) {
        if (EH.handleKeyPress(DOMevent) == false) {
            this.cancelKeyEvent(DOMevent);
            return false;
        }
    }

    var returnVal = EH.handleKeyUp(DOMevent)

    return returnVal
},

// called on EH
handleKeyUp : function (nativeEvent, scEventProperties) {
    var EH = isc.EH,
        lastEvent = EH.lastEvent,
        eventInfo = [lastEvent,  lastEvent.target, lastEvent.keyName];

    // If the event is handled natively, return true to allow native processing
    if (EH.eventHandledNatively(lastEvent.eventType, lastEvent.nativeKeyTarget)) {
        // Log.logWarn("keyup event handled natively - bailing");
        return EH._handledNativelyReturnVal;
    }


    var returnVal = true;

    if (scEventProperties != null) {
        isc.addProperties(lastEvent, scEventProperties);
    }

    var target = lastEvent.keyTarget;
    if (target == null) target = this.getEventTargetCanvas(nativeEvent,
                                                           lastEvent.nativeKeyTarget);

    if (EH.targetIsEnabled(target))
        returnVal = (EH.bubbleEvent(target, EH.KEY_UP, eventInfo) != false);


    // On Shift+f10 to show a SmartClient context menu, return false to cancel the keyUp event.
    if (!isc.Browser.isMac && lastEvent.keyName == EH._$f10 && EH.shiftKeyDown() &&
        isc.Menu && isc.Menu._openMenus && isc.Menu._openMenus.length > 0)
    {
        returnVal = false;
    }

    // Check whether the set of modifier keys being held down has changed on every event.
    isc.Page._handleModifierKeysChanged();

    // Clear EH.lastEvent's key properties
    EH.clearKeyEventProperties(lastEvent.keyName);

    // Return true to allow processing to continue unless something explicitly returned false.
    return returnVal;
},

// called by DOM
_handleNativeKeyPress : function (DOMevent) {
    // Some browsers (like Mac IE) have problems dealing with events fired before the page
    // finishes loading.  Just skip key event processing if the page hasn't loaded yet.
    //!DONTCOMBINE
    if (!isc.Page.isLoaded()) return false;

    //isc.logWarn("Received native keyPress: " + DOMevent.keyIdentifier + ", " + DOMevent.which);


        var EH = isc.EH;

    // We already got the keyEventProperties stored in EH.lastEvent from the keyDown handler
    // However call to getKeyEventProperties required as keyCodes returned in IE are different
    // on keyDown and keyPress.

    var lastEvent = EH.lastEvent,
        eventType = EH.KEY_PRESS;

    if (!DOMevent) DOMevent = EH.getWindow().event;

    EH.getKeyEventProperties(DOMevent);


    lastEvent.eventType = eventType;
    // Respect ctrl / alt key state recorded on keyDown/keyUp

    lastEvent.ctrlKey = EH._ctrlKeyOnLastUpDown;
    lastEvent.altKey = EH._altKeyOnLastUpDown;

    //isc.logWarn("In native keyPress handler for key " + lastEvent.keyName + ". eventType is " + eventType + ", Ctrl is " + (lastEvent.ctrlKey ? "down" : "up"));


    var syntheticKeyName = EH._testSyntheticKeypressFired(lastEvent.keyName);
    if (syntheticKeyName != null) {

        // Remove the flag - if we get a second native keyPress event we do want to fire the
        // handler (implies the key is being held down!)
        EH._syntheticKeypressFired[syntheticKeyName] = null;
        return;
    }

    var returnVal = EH.handleKeyPress(DOMevent);
    if (returnVal == false) {
        this.cancelKeyEvent(DOMevent);
    }
    return returnVal;

},

_testSyntheticKeypressFired : function(keyName) {
    // For Ctrl+Enter, all non-Mac browsers except Moz indicate a keyCode of 13 in the keyDown
    // event, and 10 in the keyPress event.  We can't trust the keyPress event because the
    // same keyCode is returned for Ctrl+J, so we have to use a synthetic keyPress, which means
    // we need to return true from here in order to cancel the native one.  This means we must
    // take account of the fact that the keyDown and the keyPress appear to be for different
    // keys.


        var EH = isc.EH;

    if (EH._syntheticKeypressFired[keyName] == true) return keyName;
    if (keyName == "J" && EH._syntheticKeypressFired["Enter"] == true) return "Enter";
    return null;
},

// cancelKeyEvent
// Fired when a key event handler returns false
// We use this to suppress native key event handling behavior where returning false from
// the native event isn't sufficient.

_IECanSetKeyCode:{keydown:true,  keyup:true, keypress:true},
cancelKeyEvent : function (DOMevent) {


    if (isc.Browser.isIE || isc.Browser.isSafari) {

        if (this._IECanSetKeyCode[DOMevent.type] == true) {

            try {
                DOMevent.keyCode = 0;
            } catch (e) {
            }
        }
    }

},

// called on EH
handleKeyPress : function (nativeEvent, scEventProperties) {
    // We already got the keyEventProperties stored in EH.lastEvent from the keyDown handler
    // However call to getKeyEventProperties required as keyCodes returned in IE are different
    // on keyDown and keyPress.
    var EH = isc.EH,
        lastEvent = EH.lastEvent,
        eventType = EH.KEY_PRESS;

    // if passed already-derived event properties, apply them to the EH.lastEvent.
    if (scEventProperties != null) {
        isc.addProperties(lastEvent, scEventProperties);
    }


    var eventInfo = {keyName:lastEvent.keyName, characterValue:lastEvent.characterValue};

    // update the eventType since this may be a synthetically generated keyPress event (from
    // keyUp or repeated keyDown events).
    lastEvent.eventType = eventType;


    EH._keyDownKeyNames.removeAt(0);

    // call the global keyPress event (Set up via Page.setEvent("keyPress",...) )
    if (isc.Page.handleEvent(lastEvent.keyTarget, eventType) == false) return false;
    // If eventHandledNatively returns true don't fire widget level handlers, or allow
    // registered keys to fire their actions.
    // NOTE: in IE, this will return the key number so we pass that value on
    var it = (EH.eventHandledNatively(eventType, lastEvent.nativeKeyTarget));

    if (it !== false) {
        //>DEBUG
        EH.logDebug("keyPress handled natively");
        //<DEBUG
        return EH._handledNativelyReturnVal;

    } else {
        //>DEBUG
        EH.logDebug("keyPress not handled natively");
        //<DEBUG
    }

    var target = lastEvent.keyTarget;
    if (target == null) target = this.getEventTargetCanvas(nativeEvent,
                                                           lastEvent.nativeKeyTarget);
    // Pass to the appropriate widget, and stop if this returns false.
    if (EH.targetIsEnabled(target)) {
        var handlerReturn = EH.bubbleEvent(target, lastEvent.eventType, eventInfo)
        if (handlerReturn == false) return false;
    }


    if (handlerReturn != EH.STOP_BUBBLING
        && isc.Page.handleKeyPress() == false) return false;


    // If we got a tab or shift-tab keypress, and we're showing a hard mask, explicitly stick
    // focus into the next widget in the page's tab order that isn't masked.


    if (lastEvent.keyName == this._$Tab) {
        var topHardMask,
            registry = this.clickMaskRegistry;
        if (this.clickMaskUp()) {
            for (var i = registry.length-1; i >=0; i--) {
                if (this.isHardMask(registry[i])) {
                    topHardMask = registry[i];
                    break;
                }
            }
        }
        var focusCanvas = EH._focusCanvas;

        var useSyntheticTabIndex = topHardMask != null ||
                                (focusCanvas && focusCanvas.useExplicitFocusNavigation())
        if (useSyntheticTabIndex) {

            if (focusCanvas != null) {

                //>DEBUG
                this.logInfo("Telling focus canvas:" + focusCanvas + " to shift focus",
                            "syntheticTabIndex")
                //<DEBUG
                focusCanvas._focusInNextTabElement(!this.shiftKeyDown(), topHardMask);
            } else {
                if (this.shiftKeyDown()) {
                    //>DEBUG
                    this.logInfo("Putting focus into last widget in response to Tab keydown",
                                "syntheticTabIndex")
                    //<DEBUG

                    this._focusInLastWidget(topHardMask);
                } else {
                    //>DEBUG
                    this.logInfo("Putting focus into first widget in response to Tab keydown",
                                "syntheticTabIndex")
                    //<DEBUG
                    this._focusInFirstWidget(topHardMask);
                }
            }
            // Always return false natively in this case - we don't want the focus to shift again
            return false;
        }
    }




    if (lastEvent.keyName == isc.EH._$f10 && isc.EH.shiftKeyDown()) {
        var returnVal = this.handleContextMenu(nativeEvent, true);

        if (isc.Browser.isIE && returnVal) {
            this._contextMenuShown = true;
        }
        return returnVal;
    }

    // In Moz hitting "Escape" during server turnaround (either XMLHttpRequest, or iframe)
    // kills the communication.
    // Avoid this by suppressing native Escape behavior during active comm.

    // Note: Opera has the same bug if using hidden frames (though not XMLHttpRequest)
    // but returning false from the Escape keypress doesn't resolve the issue in that browser.
    if (isc.Browser.isMoz &&
        isc.RPCManager && isc.RPCManager._activeTransactions.length > 0
        && lastEvent.keyName == isc.EH._$Escape)
    {
        return false;
    }

    // return true to allow normal event processing unless anything explicitly returned false
    return true;
},
// Helper methods to put focus at the beginning or end of our managed tab-index.
_focusInFirstWidget : function (mask) {
    // Don't allow this method to go recursive. Could happen if
    // _focusInNextTabElement() doesn't find anything focusable
    // so Canvas ends up calling back to this method

    if (this._focusInFirstWidgetRunning) return;
    this._focusInFirstWidgetRunning = true;
    var widget = this._firstTabWidget;
    if (widget) {
        if ((!mask || !this.targetIsMasked(widget, mask)) &&
              widget.isDrawn() && widget.isVisible() && !widget.isDisabled() &&
              widget._canFocus())
        {
            // Call 'focusAtEnd()' rather than focus()
            // if the widget manages the tab index of sub elements (EG DynamicForm), we want
            // to notify it to put focus in the first sub element.
            widget.focusAtEnd(true);
        } else {
            widget._focusInNextTabElement(true, mask);
        }
    }
    this._focusInFirstWidgetRunning = false;
},
_focusInLastWidget : function (mask) {
    if (this._focusInLastWidgetRunning) return;
    this._focusInLastWidgetRunning = true;

    var widget = this._lastTabWidget;

    if (widget) {
        if ((!mask || !this.targetIsMasked(widget, mask)) &&
             widget.isDrawn() && widget.isVisible() && !widget.isDisabled() &&
             widget._canFocus())
        {
            widget.focusAtEnd();
        } else {
            widget._focusInNextTabElement(false, mask);
        }
    }
    this._focusInLastWidgetRunning = false;

},

handleMouseLeaveDocument : function (DOMevent) {

        var EH = isc.EH;



    EH._mouseWasDownWhenLeftDocument = !!EH._mouseIsDown;
},

//>    @classMethod    isc.EventHandler.handleMouseDown()
//            Special handler for mouseDown events.
//          Starts a timer to fire mouseStillDown if the target implements it.
//            sets the following variables for use in subsequent events
//                ...
//
//        @group    mouseEvents
//        @param    DOMevent    (DOM event) DOM event object (as passed by isc.EventHandler)
//
//        @return                (boolean)    false == cancel native event processing
//                                        anything else == continue native event processing
//  @visibility internal
//<
handleMouseDown : function (DOMevent, syntheticEvent) {
    // In touch environments (iPhone etc), we respond to onTouchStart / onTouchStop events
    // and use these to fire our mouseDown/up/click events.
    // This is required to support drag/drop as the mouseDown/up series of events fires
    // after the touchStop event.
    // Simply no-op from the native mouseDown / Up etc event handlers so we don't get
    // doubled events and unpredictable behavior

    if ((isc.Browser.isTouch || navigator.pointerEnabled) && !syntheticEvent) return;


        var EH = isc.EH;

    EH._handlingMouseDown = true;
    var returnValue = EH.doHandleMouseDown(DOMevent, syntheticEvent);
    EH._handlingMouseDown = false;

    return returnValue;
},



_$IMG:"IMG",
_$alphaImgFilter:"progid:DXImageTransform.Microsoft.AlphaImageLoader",
doHandleMouseDown : function (DOMevent, syntheticEvent) {
    // Some browsers (like Mac IE) have problems dealing with events fired before the page finishes loading.
    //    Just skip mouse event processing if the page hasn't loaded yet.
    if (!isc.Page.isLoaded()) return false;

    var EH = this;

    // note that the mouse is down.  We do this BEFORE getting event properties to work around a bug
    // in Nav where the event.which (property to get the mouse button) is reported as 1 on a
    // mouseMove, even when the mouse is actually not pressed.
    EH._mouseIsDown = true;


    EH._firedSyntheticMouseUp = null;

    // get the properties of the event

    var event = syntheticEvent || EH.getMouseEventProperties(DOMevent);

    // if we switched event target, get rid of the focus

    var focusCanvas = EH._focusCanvas,
        forceBlur = focusCanvas != null &&
                    (focusCanvas != event.target) && !focusCanvas._useNativeTabIndex &&
                    !focusCanvas._useFocusProxy &&
                    !(isc.isA.DynamicForm!=null && isc.isA.DynamicForm(focusCanvas) && focusCanvas.getFocusSubItem()
                      && focusCanvas.getFocusSubItem().hasFocus);
    if (forceBlur) {
        // In IE if we blur() here, the thing we clicked on never gets native focus (not clear
        // why), so do this on a timeout, if appropriate
        if (isc.Browser.isIE) {
            var ID = EH._focusCanvas.getID();

            if (EH._delayedBlurArray == null)
                EH._delayedBlurArray = ["if (", ID, " && ", ID, ".hasFocus)", ID, ".blur();"]
            else
                EH._delayedBlurArray[1] = EH._delayedBlurArray[3] = EH._delayedBlurArray[5] = ID;
            isc.Timer.setTimeout(
                EH._delayedBlurArray.join(isc.emptyString),
                0
            );

        } else {
            EH._focusCanvas.blur();
        }
    }


    // remember a copy of the event particulars as mouseDownEvent
    EH.mouseDownEvent = isc.addProperties({}, event);

    // get the target Canvas
    var target = event.target;

    if (isc.Browser.isAndroid && isc.Browser.isChrome && isc.isA.Canvas(target) && target.isDrawn()) {
        var topLevelCanvas = target.getTopLevelCanvas();
        topLevelCanvas.getClipHandle().dataset.iscMouseDownEventTimeStamp = String(event.DOMevent.timeStamp);
    }

    // handle mouseDown on the virtual click mask, if it's showing.
    // If this is an hard clickMask, the click action will be cancelled by the
    // mask - since we actually do this on mouseDown, we need to set a flag to also
    // cancel mouseUp when it happens.


    var targetIsMasked = (EH.clickMaskClick(target) == false);
    if (targetIsMasked) {
        EH.__cancelNextMouseUp = true;

        // In Chrome, if the user clicks the scrollbar track/thumb of the page, if we
        // we return false from mouseDown, native scrolling is disallowed.
        // Catch this case and avoid killing the event
        if (isc.Browser.isChrome) {
            var sbWidth =  isc.Element.getNativeScrollbarSize();
            var pageHeight = isc.Page.getHeight(),
                pageWidth = isc.Page.getWidth(),
                hasHSB = isc.Page.getScrollWidth() > isc.Page.getWidth(),
                hasVSB = isc.Page.getScrollHeight() > isc.Page.getHeight();

            // Note that getWidth() reports size *inside* scrollbars
            // so we don't need to look at isc.Element.getNativeScrollbarSize() here
            // getHeight() reports size including space under scrollbars so we do need
            // to adjust there.
            if (hasHSB && isc.EH.getY() > (pageHeight - sbWidth) + isc.Page.getScrollTop()) {
                return true;
            }
            if (hasVSB && isc.EH.getX() > pageWidth + isc.Page.getScrollLeft()) {
                return true;
            }
        }
        return false;
    } else {
        // explicitly set the flag to NOT cancel the next mouseUp - this is required to note that
        // we've fired the clickMaskClick()
        // See comments in handleMouseUp() for more details
        EH.__cancelNextMouseUp = false;
    }

    // NOTE: although we do send a rightMouseDown, we don't send a rightMouseMove or rightMouseUp at
    // the moment.  rightMouseDown is needed to implement a record or cell selection model that
    // matches Windows Explorer and Excel respectively - rightMouseMove and rightMouseUp are more
    // exotic.
    var eventType = EH.rightButtonDown() ? EH.RIGHT_MOUSE_DOWN : EH.MOUSE_DOWN;
    // call the global mouseDown handler
    if (isc.Page.handleEvent(target, eventType) == false) {
        return false;
    }

    // see if we shouldn't pass this event on to DOM object, and return true if we should
    if (EH.eventHandledNatively(eventType, event.nativeTarget))
        return EH._handledNativelyReturnVal;

    // if the target is not enabled, we shouldn't continue
    if (!EH.targetIsEnabled(target)) return false;

    var forceIEFocusTarget;

    if (target && !target.hasFocus) {
        // call 'focus' to focus on the widget.



        if ( ((isc.Browser.isMoz && target.canSelectText) || isc.Browser.isSafari )
             && target._useFocusProxy )
        {
            EH.focusInCanvas(target);


        } else if (!target._useNativeTabIndex) {
            target.focus("focus on mousedown");

        } else if (isc.Browser.isMoz || isc.Browser.isSafari) {
            target.focus("focus on mousedown");


        } else if (isc.Browser.isIE) {

            var nativeElement = event.nativeTarget;
            if (isc.Browser.isStrict) {
                forceIEFocusTarget = target;
            } else {
                if (nativeElement && nativeElement.tagName == this._$IMG) {
                    var style = nativeElement.style,
                        filter = style ? style.filter : null;
                    if (filter.contains(this._$alphaImgFilter)) {
                        forceIEFocusTarget = target;
                    }
                }
            }
        }
    }

    // NOTE that we allow right drag, and treat it just like left drag, although you can do
    // something special on right drag by checking EH.rightButtonDown()
    if (target) EH.prepareForDragging(target);

    // bubble the mouseDown event to anyone who wants it
    var handlerReturn = EH.bubbleEvent(target, eventType, null, targetIsMasked);
    if (forceIEFocusTarget != null) forceIEFocusTarget.focus();

    if (handlerReturn == false) {
        // a an explicit "false" returned from mouseDown will cancel dragging
        delete EH.dragTarget;
        delete EH.dragTargetLink;
    }

    // if the right button is down, the return value can affect the context menu.
    // In DOM browsers, we receive a native showContextMenu event (see
    // this.handleContextMenu()), and our response to that affects whether the context
    // menu will be shown.
    if (EH.rightButtonDown()) {
        // Bail unless we're in a browser where we never get a separate right-mouse event
        if (!this.useSyntheticRightButtonEvents()) return true;


        if (target &&
            (EH.getBubbledProperty(target, "contextMenu") ||
             EH.getBubbledProperty(target, "showContextMenu", true) != isc.Canvas.getInstanceProperty("showContextMenu")))
        {

            // return false to suppress native context menu, since we'll show our own on mouseUp
            //this.logWarn("rightMouseDown: false");
            event.returnValue = false;
            return false;
        }
        // return true to allow the context menu in Nav4.  Note that when we return true here, we
        // never get mouseUp in Nav4.
        //Log.logWarn("rightMouseDown: true");
        return true;
    }
    // if the mouseDown handler didn't return false, set up a timer to send mouseStillDown events
    if (handlerReturn != false) {

        // if the target or a parent has a mouseStillDown message fire the mouseStillDown event,
        // this will keep firing on a timer until the mouse goes up
        if (EH.hasEventHandler(target, EH.MOUSE_STILL_DOWN)) {
            // call _handleMouseStillDown, which will start the timer automatically
            EH._handleMouseStillDown();
        }
    }



    var aboutToDrag = (EH.dragTarget != null &&
                       EH.dragOperation != EH.DRAG_SELECT);

    // Return false to cancel native drag mode if we're about to do an ISC drag.
    // Return false in Moz if text selection is diallowed
    // (type-casting target._allowNativeTextSelection() to a boolean - if this
    // returns undef we want to  return an explicit false so drag selection is disallowed)
    // Don't return false if we're handling a touch event because this cancels native touch
    // scrolling.
    // Also return false if app code returned false

    var returnVal = handlerReturn == false ? false :
                    (isc.Browser.hasNativeDrag && target._getUseNativeDrag()) ||
                    (!aboutToDrag &&
                     ((EH._handledTouch == EH._touchEventStatus.TOUCH_STARTED) ||
                      !(isc.Browser.isMoz || isc.Browser.isSafari) ||
                      !!target._allowNativeTextSelection(event)));
    return returnVal;
},

//>    @classMethod    isc.EventHandler.stillWithinMouseDownTarget()
//    Is the current event still within the last Canvas where the mouse went down?
//  Note: You need to call this method to get correct cross-platform determination of whether
//        the current event is still within the mouseDown target.
//        @group    mouseEvents
// @visibility internal
//<

stillWithinMouseDownTarget : function () {
    var mouseDownTarget = this.mouseDownTarget();
    if (!mouseDownTarget) return false; // mouse didn't go down in a Canvas

    var lastEvent = this.lastEvent;

    // see if we're within the same Canvas that the mouse went down in
    var stillWithin = (mouseDownTarget == lastEvent.target);
    if (!stillWithin) return false;

    if (lastEvent._stillWithin != null) return lastEvent._stillWithin;

    return stillWithin;
},

//>    @classMethod    isc.EventHandler.handleMouseMove()
// Starts dragging if the dragTarget is set and the mouse has moved more than [5] pixels
//
// Sets the dropTarget if we're dragging and are over a droppable target
//
// Generates mouseOver/mouseOut or dragOver/dragOut events on Canvas boundaries.
//
//        @group    mouseEvents
//
//        @param    DOMevent    (DOM event) DOM event object (as passed by isc.EventHandler)
//
//        @return                (boolean)    false == cancel native event processing
//                                        anything else == continue native event processing
// @visibility internal
//<
// called directly by DOM
handleMouseMove : function (DOMevent) {

    // Some browsers (like Mac IE) have problems dealing with events fired before the page
    // finishes loading.  Just skip mouse event processing if the page hasn't loaded yet.
    if (!isc.Page.isLoaded()) return false;

        var EH = isc.EH;

    // No-Ops in Touch environments
    // (See comments in handleMouseDown for why we do this)
    if (!EH.nativeDragging && (isc.Browser.isTouch || navigator.pointerEnabled)) return;


    if (EH._handlingMouseDown || EH._handlingMouseUp) return;

    var event = EH.getMouseEventProperties(DOMevent);


    if (EH._needMissedMouseupOutsideWindowWorkAround &&
        EH._mouseWasDownWhenLeftDocument != null)
    {
        if (EH._mouseWasDownWhenLeftDocument) {
            // If the mouse is no longer down, then fire a synthetic mouseUp.
            if (event.buttonNum == 0) {
                EH.handleMouseUp(DOMevent, true);
            }
        }
        EH._mouseWasDownWhenLeftDocument = null;
    }


    if ((isc.Browser.isMoz || isc.Browser.isIE)

        && !EH.immediateMouseMove

        && !EH.nativeDragging
    ) {
        //Log.logWarn("postponing mouseMove (last time: " + EH.lastMouseMoveTime +
        //            " exceeds threshold of " + EH.delayThreshold);
        // set a timer to fire mouseMove later
        if (EH.delayedMouseMoveTimer == null) {
            EH.delayedMouseMoveTimer =
                 isc.Timer.setTimeout({target:EH, methodName:"_delayedMouseMove",
                                       args:[isc.timeStamp()]}, 0, true);
        }


        return true;
    }


    var result = EH._handleMouseMove(DOMevent, event);

    return result;
},

_delayedMouseMove : function (ts) {
    //var now = isc.timestamp();
    //if ((now - ts) > 30) {
    //    this.logWarn("long timer firing delay: " + (now-ts) + "ms");
    //}

    this.delayedMouseMoveTimer = null;

    //var start = isc.timeStamp();
    this._handleMouseMove(null, this.lastEvent);
    //var end = isc.timeStamp();

    //if ((end - start) > 5) {
    //    this.logWarn("long mouse move: " + (now-ts) + "ms");
    //}
},


_handleMouseMove : function (DOMevent, event) {
    this._handlingMouseMove = true;

    var returnVal = this.__handleMouseMove(DOMevent, event);
    this._handlingMouseMove = null;
    return returnVal;
},

// When set to true, while the mouse is down, mouseMove() is only fired when the mouse is moved
// within the mouseDown target. This was the behavior of Nav4 and Mozilla Suite.
enableMouseMoveBackCompat: false,

__handleMouseMove : function (DOMevent, event) {
    var EH = this;

    var mouseDown = EH.mouseIsDown();

    // We might start dragging if:
    // - the mouse is down
    // - the mouse went down on a Canvas that allows dragging (EH.dragTarget, set up in
    //   prepareForDragging)
    // - the Canvas does not have useNativeDrag:true
    // - we're not already dragging
    // - the current mouseDown event didn't open a menu (we don't want to allow a user to
    //   long-touch, open a menu, and start dragging some other UI element on the same touch)
    var mightStartDrag = (mouseDown &&
                          EH.dragTarget &&
                          (!isc.Browser.hasNativeDrag || !EH.dragTarget._getUseNativeDrag()) &&
                          !EH.dragging)
    if (mightStartDrag && isc.Menu && isc.Menu._openMenus && isc.Menu._openMenus.length > 0) {

        if (!EH.dragTarget._isScrollThumb && !isc.isA.Menu(EH.dragTarget) &&
            EH.mouseDownEvent._menu_mouseDownEventID != null &&
            (EH.mouseDownEvent._menu_mouseDownEventID == isc.Menu.mouseDownEventID))
        {
            mightStartDrag = false;
        }
    }


    var missedMouseUp;
    if (isc.Browser.isIE && event.originalType !== EH.POINTER_MOVE) {
        var buttonNum = event.buttonNum;
        if (mouseDown) {

            if (!mightStartDrag && buttonNum == 0) {
                if (EH.dragging) {

                } else {
                    missedMouseUp = true;
                }
            }

        } else if (buttonNum == 1 && event.eventType == EH.MOUSE_MOVE) {
            if (EH._firedSyntheticMouseUp) {

            } else {
                event.eventType = EH.MOUSE_DOWN;
                EH.handleMouseDown(null, event);
                event.eventType = EH.MOUSE_MOVE;
            }
        }
    }


     var target = event.target,
         isNative = EH.eventHandledNatively(EH.MOUSE_MOVE, event.nativeTarget)
     ;

    if (EH._mouseIsDownInScrollbar) {

        EH.handleMouseUp(DOMevent, true);

    } else if (missedMouseUp) {
        EH.logInfo("sythesizing mouseUp " +
                (EH._outOfWindow ?
                    "due to mouseUp outside window," :

                    "[buttonNum cleared on mouseMove with no mouseUp event],") +
                " buttonNum: " +
                   event.buttonNum);
        EH.handleMouseUp(DOMevent, true);
    }
    delete EH._outOfWindow;

    // If we synthesized a mouseUp() event, then update the `mightStartDrag' and `mouseDown'
    // local variables.
    if (!EH.mouseIsDown()) {
        mightStartDrag = mouseDown = false;
    }



    // NOTE: we allow right mouse button dragging, and at the EventHandler level we treat it
    // just like normal dragging, however, a specific drag handler can implement special
    // semantics for right dragging.


    if (isc.Browser.isMoz && (isc.Browser.geckoVersion < 20100914) && mouseDown &&
        event.target && event.target._useMozScrollbarsNone
        && event.target != EH.mouseDownTarget())
    {
        event.nativeDraggingTarget = event.nativeTarget;
        event.nativeTarget = null;
        target = event.target = EH.mouseDownTarget();
    }

    // start dragging if:
    // - `mightStartDrag' is true
    // - the mouse has moved a certain distance, in either direction, from the mouseDown point
    if (mightStartDrag &&
        (Math.abs(event.x - EH.mouseDownEvent.x) > EH.dragTarget.dragStartDistance ||
         Math.abs(event.y - EH.mouseDownEvent.y) > EH.dragTarget.dragStartDistance))
    {
        EH.handleDragStart();
    }
    // if we're dragging, jump over to handleDragMove which does special processing
    if (EH.dragging) {
        return EH.handleDragMove();
    }
    // if the right button is down
    if (EH.rightButtonDown()) {
        // don't send mouseMove.  We could send a 'rightMouseMove' event, but we've decided not
        // to do that now.


        if (!isc.Browser.isMac || !EH.ctrlKeyDown()) return true;
    }


    if (EH.enableMouseMoveBackCompat && mouseDown) {
        target = EH.stillWithinMouseDownTarget() ? EH.mouseDownTarget() : null;
    } else {
        target = event.target;
    }
    // if the target is not the last object that got the move event,
    // send the mouseOut and mouseOver routines to the appropriate objects
    if (target != EH.lastMoveTarget) {
        //>DEBUG
        if (this.logIsDebugEnabled()) {
            this.logDebug((EH.lastMoveTarget ?
                           "mousing out of " + EH.lastMoveTarget + "  " : "") +
                           (target ? "mousing over " + target : ""));
        }
        //<DEBUG
        // send the mouseOut event to the last mover object
        var lastMoveTarget = EH.lastMoveTarget,
            hoverTarget,
            lastHoverTarget = EH.lastHoverTarget;

        if (lastMoveTarget) {
            delete EH.lastMoveTarget;
            EH.handleEvent(lastMoveTarget, EH.MOUSE_OUT, null, EH.lastMoveTargetItem);
        }

        // send the mouseOver event to the target
        if (target) {

            var hoverResult = EH.handleEvent(target, EH.MOUSE_OVER);
            // use 'getHoverTarget()' to determine which widget should receive a hover event.
            if (hoverResult != false) hoverTarget = target.getHoverTarget(event);
        }

        // Send hover events to the hover target/last hover target.
        // The Canvas level implementation handles actually setting up timers to fire
        // user-visible hover handlers.
        if (hoverTarget != lastHoverTarget) {
            if (lastHoverTarget) lastHoverTarget.stopHover();
            if (hoverTarget) hoverTarget.startHover();

            EH.lastHoverTarget = hoverTarget;
        }

        // remember that we're the last move object
        EH.lastMoveTarget = target;

        // remember the associated FormItem (if any)
        EH.lastMoveTargetItem = isc.DynamicForm && isc.isA.DynamicForm(target) ?
            isc.DynamicForm._getEventTargetItem() : null;
    }
    // call the global event handler
    if (isc.Page.handleEvent(target, EH.MOUSE_MOVE) == false) return false;

    // see if we shouldn't pass this event on to DOM object, and return true if we should
    if (isNative) return EH._handledNativelyReturnVal;

    // if the target isn't defined or isn't enabled, return false
    if (!EH.targetIsEnabled(target)) return false;
    // bubble the event
    EH.bubbleEvent(target, EH.MOUSE_MOVE);
    // update the cursor
    if (target) target._updateCursor();


    return true;

},

//> @classMethod isc.EventHandler.getNativeMouseTarget() [A]
// Returns the natively reported target (or source) DOM element for the current mouse event.
// <b>NOTE:</b> SmartClient cannot guarantee that the same element will
// be reported in all browser/platform configurations for all event types.
// If you wish to make use of this value, we recommend testing your use case
// in all target browser configurations.
//
// @return (HTML Element) native DOM element over which the mouse event occurred
// @visibility external
//<
// Common known issue - during drag/drop interactions some browsers may report
// the mouse down target (the target being dragged) rather than the target the user is currently
// hovering over.

getNativeMouseTarget : function (event) {
    if (!this.nativeTargetWarningLogged) {
        this.nativeTargetWarningLogged = true;
        this.logWarn("getNativeMouseTarget(). This method will return the DOM element " +
            "the browser reports as the target or source of the current mouse event. " +
            "Please note that SmartClient cannot guarantee that the same element will " +
            "be reported in all browser/platform configurations for all event types. " +
            "If you wish to make use of this value, we recommend testing your use case " +
            "in all target browser configurations.");

    }
    if (event == null) event = this.lastEvent;
    return event.nativeTarget || event.nativeDraggingTarget;

},


// handle a native mouseOut event
handleNativeMouseOut : function (DOMevent) {
    // we generally synthesize the mouseOut event during mouseMove.  However, for the special
    // case of mousing out of the browser window via exiting a Canvas which is which is flush
    // with the window border, we'll never get a mouseMove outside of our Canvas, so we have to
    // detect this case specially.


    if (isc.Browser == null) return;


        var EH = isc.EH;


    if (EH._handlingMouseDown || EH._handlingMouseUp) return;

    var event = (DOMevent ? DOMevent : EH.getWindow().event),
        target = (isc.Browser.isDOM ? event.target : event.srcElement),
        leavingWindow = false;

    if (isc.Browser.isIE) {

        leavingWindow = (event.toElement == null);

    } else {

        leavingWindow = (event.relatedTarget == null);

    }

    //EH.logWarn("leaving window:" + leavingWindow + ", lastMoveTarget: " + EH.lastMoveTarget);

    // used for detecting mouseUps that happen outside the window, where possible
    if (leavingWindow) EH._outOfWindow = true;

    var lastMoveTarget = EH.lastMoveTarget;
    if (leavingWindow && lastMoveTarget) {
        // Update properties on the lastEvent object before bubbling handlers.

        EH._updateMouseOutEventProperties(event);
        delete EH.lastMoveTarget;
        EH.handleEvent(lastMoveTarget, EH.MOUSE_OUT, null, EH.lastMoveTargetItem);
        if (EH.lastHoverTarget) {
            EH.lastHoverTarget.stopHover();
            delete EH.lastHoverTarget;
        }
    }
},


// update lastEvent with properties from a native 'mouseOut' event.
_updateMouseOutEventProperties : function (nativeEvent) {

        var EH = isc.EH;

    var lastEvent = EH.lastEvent;

    // Store the target we're moving into as the event target (rather than the target we're
    // moving out of!)
    if (isc.Browser.isIE) {
        lastEvent.nativeTarget = nativeEvent.toElement;
    } else {
        lastEvent.nativeTarget = nativeEvent.relatedTarget;
    }

    if (lastEvent.nativeTarget == null) lastEvent.target = null
    else lastEvent.target = this.getEventTargetCanvas(nativeEvent, lastEvent.nativeTarget);
},



// Send the mouseDown target a periodic, synthetic "still down" event while the mouse stays
// down
//
// Allows for things like repeated scrolling while the mouse button is held down in
// scrollbar buttons.
//
// NOTE: mouseStillDown is also fired once immediately on mouseDown
_handleMouseStillDown : function (timeStamp) {
    // Some browsers (like Mac IE) have problems dealing with events fired before the page
    // finishes loading.  Just skip mouse event processing if the page hasn't loaded yet.
    if (!isc.Page.isLoaded()) return false;
    var EH = this;

    // clear the old timeout if necessary
    EH._stillDownTimer = isc.Timer.clear(EH._stillDownTimer);

    // if the mouse is already up, or the mouseDownTarget can no longer be found, bail

    if (!EH.mouseIsDown() || !EH.mouseDownTarget()) return false;

    // send the event up the chain of the target
    if (EH.bubbleEvent(EH.mouseDownTarget(), EH.MOUSE_STILL_DOWN) == false) return false;

    // start the timer to call this again after a delay.

    var target = EH.mouseDownTarget(),
        delay = this._handlingMouseDown ? target.mouseStillDownInitialDelay :
                                          target.mouseStillDownDelay;
      EH._stillDownTimer = this.delayCall("_handleMouseStillDown", [], delay);

    // alternate code that allows checking the actual delay before the timer fired
    //if (!this._handlingMouseDown) {
    //    this.logWarn("mouseStillDown fired after: " + (isc.timeStamp() - timeStamp) + "ms");
    //}
      //EH._stillDownTimer =
    //    isc.Timer.setTimeout("isc.EH._handleMouseStillDown(" + isc.timeStamp() + ")", delay);

    return true;
},



//>    @classMethod    isc.EventHandler.handleMouseUp()
//            Special handler for mouse up events.
//
//            fires  showContextMenu, click and doubleClick events as necessary
//
//        @group    mouseEvents
//        @param    DOMevent    (DOM event) DOM event object (as passed by isc.EventHandler)
//
//        @return                (boolean)    false == cancel native event processing
//                                        anything else == continue native event processing
//  @visibility internal
//<
// called directly from DOM, and by other methods
handleMouseUp : function (DOMevent, fakeEvent) {



        var EH = isc.EH;

    // No-Ops in Touch environments
    // (See comments in handleMouseDown for why we do this)
    if (!EH.nativeDragging && (isc.Browser.isTouch || navigator.pointerEnabled) && !fakeEvent) return;


    if (isc.Browser.isIE && !EH._mouseIsDown) {


        if (EH._firedSyntheticMouseUp) return;

        var lastEvent = EH.lastEvent;
        lastEvent.eventType = EH.MOUSE_DOWN;
        EH.handleMouseDown(null, EH.lastEvent);
    }
    EH._firedSyntheticMouseUp = fakeEvent && EH._mouseWasDownWhenLeftDocument == null;


    if (!fakeEvent) EH._handlingMouseUp = true;
    var returnValue = EH._handleMouseUp(DOMevent, fakeEvent);
    EH._handlingMouseUp = false;


    if (isc.Browser.isSafari) returnValue = true;




    return returnValue;
},
_handleMouseUp : function (DOMevent, fakeEvent) {

    // Some browsers (like Mac IE) have problems dealing with events fired before the page
    // finishes loading.  Just skip mouse event processing if the page hasn't loaded yet.
    if (!isc.Page.isLoaded()) return false;
    var EH = this,
        // get the properties of the event
        event = (!fakeEvent ? EH.getMouseEventProperties(DOMevent) : EH.lastEvent),
        isNative = false;

    EH._mouseIsDown = false;
    delete EH.__handleClickReturnValue;

    // clear the stillDownTimer
    EH._stillDownTimer = isc.Timer.clear(EH._stillDownTimer);

    // switch focus if the one-time flag has been set
    var focusTarget = EH._delayedFocusTarget;

    if (focusTarget) {
        //EH.logWarn("focusing in delayed target:" + focusTarget);
        focusTarget.focus();
        EH._delayedFocusTarget = null;
    }

    // EH.__cancelNextMouseUp is a one-time flag to cancel mouseUp.
    // This is used when, on mouseDown, you want to cancel the entire click.
    // We set this flag to true on mouseDown if the target is masked and the clickEvent for the
    // click mask returned false.

    // Remember this flag's value, and clear it
    var cancelMouseUp = EH.__cancelNextMouseUp;
    EH.__cancelNextMouseUp = null;


    var targetIsMasked;
    if (cancelMouseUp == null) {
        cancelMouseUp = (EH.clickMaskClick(event.target) == false);
        targetIsMasked = cancelMouseUp;
    }

    // Return if cancelling the mouseUp
    if (cancelMouseUp == true) {
        if (EH.logIsDebugEnabled()) EH.logDebug("mouseUp cancelled by clickMask");
        return false;
    }

    var successfulDrag = false;
    // if we're dragging, stop dragging.  NOTE: this applies to right button down as well,
    // which is treated as normal dragging.
    if (EH.dragging) {
        successfulDrag = EH.handleDragStop();
    }

    // right mouse button just came up, it's a right click (handleContextMenu())
    if (EH.rightButtonDown(event)) {

        if (this.useSyntheticRightButtonEvents()) {
            EH.handleContextMenu();
        }

        // suppress the click event
        EH.__handleClickReturnValue = false;

    } else {
        // only send mouseUp and click if drag was unsuccessful (or never started)
        // NOTE: it's very important to send mouseUp and click if drag wasn't successful,
        // because among other problems, frequently a D&D interaction will be triggered by a
        // sloppy click where there is a small distance between mouseDown and mouseUp, and
        // then the click will appear to have mysteriously failed.



        if (!successfulDrag) {
            if (isc.Page.handleEvent(event.target, EH.MOUSE_UP) != false) {

                var mouseUpReturn = true,
                    x = event.x, y = event.y,
                    mouseDownTarget = EH.mouseDownTarget();

                isNative = EH.eventHandledNatively(EH.MOUSE_UP, event.nativeTarget);
                if (!isNative && EH.targetIsEnabled(mouseDownTarget)) {
                    if (mouseDownTarget.visibleAtPoint(x, y)) {
                        mouseUpReturn = EH.bubbleEvent(mouseDownTarget, EH.MOUSE_UP, null,
                                targetIsMasked);

                    // On touch-enabled devices, we might not get another event for a while.
                    // If we're in the middle of handling the end of a touch event sequence,
                    // then fire mouseOut() on the mouseDownTarget so that it has a chance to
                    // reset its appearance.
                    //
                    // For example, if the user touchstart's a tab (making the tab the mouseDownTarget,
                    // then drags their finger off of the tab, firing the mouseOut() event here
                    // resets the tab's appearance to the STATE_UP state.
                    } else if (EH._handledTouch === EH._touchEventStatus.TOUCH_ENDING || mouseDownTarget.containsPoint(x, y)) {
                        mouseUpReturn = EH.bubbleEvent(mouseDownTarget, EH.MOUSE_OUT, null,
                                targetIsMasked);
                    }
                }
                // NOTE: call handleClick even if the Canvas target is null or changed between
                // mouseDown and mouseUp, because we should still fire page-level click in that
                // circumstance.  handleClick will check (redundantly) for same target before
                // firing Canvas-level click.
                // If ending a touch event, then make sure that the distance between the mouseDown
                // ('touchstart') position is not too far away from the mouseUp position. Otherwise,
                // if the user native touch scrolls a component, then we would often fire handleClick.
                if (mouseUpReturn != false &&
                    (EH._handledTouch !== EH._touchEventStatus.TOUCH_ENDING ||

                     (EH.mouseDownEvent != null &&
                      Math.abs(EH.mouseDownEvent.x - x) <= 10 &&
                      Math.abs(EH.mouseDownEvent.y - y) <= 10)))
                {
                    // Fire a programmatic "fast click" on the DOMevent target if we're handling
                    // a touch event sequence.
                    // The reason for this is because we preventDefault() the 'touchend' event
                    // when the target is an element for which _shouldIgnoreTargetElem() returns
                    // false so that an input element will not receive keyboard focus if it wasn't
                    // the target of the original tap. However, this leads to the issue that the
                    // native action (such as navigation when a link is tapped, toggling a checkbox
                    // when a checkbox is tapped, etc.) is canceled. To counteract this, we fire
                    // a programmatic 'click' DOM event on the element. This performs the same native
                    // action that was canceled in _handleTouchEnd().
                    var targetElem;
                    if (EH._handledTouch === EH._touchEventStatus.TOUCH_ENDING &&
                        (targetElem = DOMevent.target && (DOMevent.target.nodeType == 1 ? DOMevent.target : DOMevent.target.parentElement)) != null &&
                        (!isc.Browser.isAndroid || event.originalType !== EH.CLICK))
                    {
                        if (!EH._shouldIgnoreTargetElem(targetElem)) {
                            var doc = DOMevent.view.document;

                            var clickDOMevent = doc.createEvent("MouseEvents");
                            clickDOMevent.initMouseEvent("click", true, true, DOMevent.view,
                                                         1, // one click
                                                         DOMevent.screenX, DOMevent.screenY,
                                                         DOMevent.clientX, DOMevent.clientY,
                                                         false, false, false, false,
                                                         0, null);
                            // Mark our 'click' events so that we know to ignore them in handleNativeClick().
                            clickDOMevent._fastClick = true;
                            window.setTimeout(function () {
                                targetElem.dispatchEvent(clickDOMevent);
                            }, 1);
                        }
                    }

                    EH.__handleClickReturnValue = EH.handleClick(event.target);
                }
            }
        }
    }

    // and always clear the redrawnWhileDown property
    delete EH.redrawnWhileDown;

    // clear all drag properties set by unscrupulous methods above
    EH.clearDragProperties();



    // EH._mouseIsDownInScrollbar must be cleared before we return, but *after* mouseUp and
    // click events been handled (and their bubbling averted by EH.eventHandledNatively()
    // immediately returning true) above
    if (EH._mouseIsDownInScrollbar) EH._mouseIsDownInScrollbar = false;

    //isc.Log.logWarn("handleMouseUp returning: " +
    //                (isNative && EH.__handleClickReturnValue == true) +
    //                ", isNative: " + isNative +
    //                ", handleClick: " + EH.__handleClickReturnValue);

    // If mouseUp or click returned false, __handleClickReturnValue will be false
    // return true if the event was handled natively, or if neither of these handlers
    // returned false.

    var target = event.target,
        overForm = isc.isA.DynamicForm!=null && isc.isA.DynamicForm(target);

    if (isNative && (overForm || EH.__handleClickReturnValue == true))
        return EH._handledNativelyReturnVal;
    // Return false unless this was over a form with an explicit true return val
    return (overForm && EH.__handleClickReturnValue == true);
},


// Clear all the miscellaneous isc.EventHandler properties set as a result of dragging.
clearDragProperties : function () {
    var EH = this;
    EH.wasNativeDragging = false;
    EH.crossFrameDragging = EH.nativeDragging = EH.dragging = false;
    delete EH._lastDragEnterTarget;
    if (EH._crossFrameDragCleanupTmrID != null) {
        isc.Timer.clear(EH._crossFrameDragCleanupTmrID);
        delete EH._crossFrameDragCleanupTmrID;
    }

    delete EH.dragTarget;
    delete EH.dragTargetStartRect;
    delete EH.dragTargetLink;

    delete EH.dragMoveTarget;
    delete EH.dragMoveAction;

    delete EH.dragOperation;
    delete EH.dragAppearance;

    delete EH.dropTarget;
    delete EH.lastDropTarget;
},


// handle context menu events.  Can be called directly by the browser or synthetically.

handleContextMenu : function (DOMEvent, synthetic) {
    // Some browsers (like Mac IE) have problems dealing with events fired before the page
    // finishes loading.  Just skip mouse event processing if the page hasn't loaded yet.
    if (!isc.Page.isLoaded()) return false;



        var EH = isc.EH;

    EH._handlingMouseUp = true;
    var returnValue = EH._handleContextMenu(DOMEvent, synthetic);
    EH._handlingMouseUp = false;

    return returnValue;
},

_handleContextMenu : function (DOMEvent, synthetic) {

    var fromMouseEvent = this.isMouseEvent(this.lastEvent.eventType);


    if (this._contextMenuShown) {
        delete this._contextMenuShown;
        if (!synthetic) {
            return true;
        }
    }

    // If this is not a synthetic event, pick up the event properties
    if (DOMEvent) this.getMouseEventProperties(DOMEvent);
    var EH = this,
        event = EH.lastEvent,
        target = !fromMouseEvent ? event.keyTarget || event.target : event.target;
    // record that this was a mouse or keyboard triggered event. It's much harder to determine
    // this once we've wiped the previous event type

    event.keyboardContextMenu = !fromMouseEvent;

    event.eventType = "contextMenu";

    // If this came from a keyboard event, in IE the coordinates reported will be the
    // mouse coordinates. In order to show the context menu in the right place, specify the
    // event coordinates as matching basically the top/left of the focus canvas
    if (!fromMouseEvent) {
        event.x = target ? target.getPageLeft() : 0;
        event.y = target ? target.getPageTop() : 0;
    }


    if (isc.Browser.isSafari && EH.clickMaskClick(target) == false) {
        return false;
    }

    // handle the page-level showContextMenu event
    if (isc.Page.handleEvent(target, EH.SHOW_CONTEXT_MENU) == false) {
        return false;
    }

    // if the target is enabled, send it a showContextMenu event.
    var returnValue = true;
    if (EH.targetIsEnabled(target)) {
        returnValue = EH.bubbleEvent(target, EH.SHOW_CONTEXT_MENU);
    }

    if (returnValue != false) {

        var lastMoveTarget = EH.lastMoveTarget;
        if (lastMoveTarget) {
            delete EH.lastMoveTarget;
            EH.handleEvent(lastMoveTarget, EH.MOUSE_OUT, null, EH.lastMoveTargetItem);
        }
    }
    return returnValue;
},


handleNativeClick : function (DOMevent) {
    var EH = isc.EH,
        value = (EH.__handleClickReturnValue != false);

    delete EH.__handleClickReturnValue;

    if (DOMevent._fastClick) return value;



    if (isc.Browser.isAndroid) {


        if (isc.Browser.isChrome) {
            var mouseDownEvent = EH.mouseDownEvent;
            if (mouseDownEvent != null) {
                var lastEventTarget = EH.lastEvent.target; // save because it's going to be overwritten.
                EH.DOMevent = DOMevent;
                var event = EH.getMouseEventProperties(DOMevent);


                if (isc.isA.Canvas(event.target)) {
                    // Find the top-level canvas.
                    var topLevelCanvas = event.target.getTopLevelCanvas();

                    var topLevelClipHandle = topLevelCanvas.getClipHandle();

                    var ts = topLevelClipHandle.dataset.iscMouseDownEventTimeStamp;
                    // If `ts' is null, then the top-level canvas and its descendants did not
                    // receive the last 'touchstart' event.
                    if (ts == null || parseFloat(ts) < mouseDownEvent.DOMevent.timeStamp) {

                        DOMevent.preventDefault();
                        return false;
                    }
                }


                if (lastEventTarget !== event.target ||
                    (lastEventTarget._differentEventCharacteristics != null &&
                     lastEventTarget._differentEventCharacteristics(mouseDownEvent, event)))
                {
                    event.originalType = EH.CLICK;
                    event.eventType = EH.MOUSE_MOVE;
                    EH._handleMouseMove(DOMevent, event);
                    event.eventType = EH.MOUSE_DOWN;
                    EH.doHandleMouseDown(DOMevent, event);
                    event.eventType = EH.MOUSE_UP;
                    EH._handleMouseUp(DOMevent, true);
                }
            }


        } else {
            EH.DOMevent = DOMevent;
            var event = EH.getMouseEventProperties(DOMevent);

            switch (this._handledTouch) {
                case EH._touchEventStatus.READY_FOR_TOUCH:
                    event.originalType = EH.CLICK;
                    // fire synthetic mouseMove
                    event.eventType = EH.MOUSE_MOVE;
                    EH._handleMouseMove(DOMevent, event);
                    // fire synthetic mouseDown
                    event.eventType = EH.MOUSE_DOWN;
                    EH.doHandleMouseDown(DOMevent, event);
                    // fall through to handle the mouseUp

                case EH._touchEventStatus.TOUCH_STARTED:
                    // fire synthetic mouseUp
                    event.originalType = EH.CLICK;
                    event.eventType = EH.MOUSE_UP;
                    EH._handleMouseUp(DOMevent, true);
                    break;

                case EH._touchEventStatus.TOUCH_COMPLETE:

                    if (isc.Browser.isAndroidWebView && isc.Browser.androidMinorVersion < 4.4) {
                        var targetElem = DOMevent.target && (DOMevent.target.nodeType == 1 ? DOMevent.target
                                                                                           : DOMevent.target.parentElement);
                        if (!EH._shouldIgnoreTargetElem(targetElem)) {
                            DOMevent.preventDefault();
                            return false;
                        }
                    }

                    break; // non-error case
            }
            // finished with synthetic events; return to resting state
            this._handledTouch = EH._touchEventStatus.READY_FOR_TOUCH;
        }
    }

    if (isc.Browser.isIE && !isc.Browser.isIE10) {
        EH.DOMevent = DOMevent;
        var event = EH.getMouseEventProperties(DOMevent);

        if (event.target && event.target._getUseNativeDrag()) return false;
    }

//    return value;
},

// NOTE: handleClick() is always called by handleMouseUp() during processing of a native
// mouseUp event, because we always synthesize the click event ourselves.  handleNativeClick()
// is what we do when we get a native click event.
handleClick : function (target, eventType) {
    // Some browsers (like Mac IE) have problems dealing with events fired before the page
    // finishes loading.  Just skip mouse event processing if the page hasn't loaded yet.
    if (!isc.Page.isLoaded()) return false;

    var EH = this,
        // get the properties of the event as 'lastEvent'
        event = EH.lastEvent,
        returnVal;

    // get the eventType if it wasn't passed in

    if (!eventType) eventType = (EH.isDoubleClick(target) ? EH.DOUBLE_CLICK : EH.CLICK);
    //EH.logWarn("target: " + target + ", mouseDownTarget: " + EH.mouseDownTarget() +
    //             ", stillWithinTarget: " + EH.stillWithinMouseDownTarget() +
    //             ", native target: " + this.echoLeaf(event.nativeTarget));

    // call the Page-level click handler.  Note we will fire page-level click even if there is
    // no Canvas target
    if (isc.Page.handleEvent(target, eventType) == false) {
        returnVal = false;

    // if the click event was handled natively, bail
    } else if (EH.eventHandledNatively(eventType, event.nativeTarget)) {
        returnVal = EH._handledNativelyReturnVal;

    // if we have an enabled target, bubble the event
    } else if (!EH.targetIsEnabled(target)) {
        returnVal = false;

    // don't fire click if the Canvas target changed between mouseDown and mouseUp
    // or when the target is the body of a menu (otherwise the menu will not register the click
    // when the menu is within a window). One exception is in handling a touch event. It is
    // very common for the mouseDown target (really the touchStart target) to be different than
    // the mouseUp (touchEnd/touchCancel) target.
    // In processing a touch event sequence, we have a tolerance in place where we consider
    // the distance from the touchStart position to the touchEnd position. If outside of the
    // tolerance, then handleClick() is not called.
    } else if (EH._handledTouch !== EH._touchEventStatus.TOUCH_ENDING &&
               !EH.stillWithinMouseDownTarget())
    {
        returnVal = false;

    // otherwise bubble the event through the target canvas chain
    } else {
        var target = EH.mouseDownTarget();
        returnVal = EH.bubbleEvent(target, eventType);
    }

    // Record when the event completed. We use this for double-click detection in some cases.
    EH._lastClickCompleteTime = isc.timeStamp();

    return returnVal;
},


//>    @classMethod    isc.EventHandler.isDoubleClick()    (A)
// Return true if this click in the target should be considered a double click,
// false for a single click
//
//        @group    mouseEvents
//        @param    target        (object)    Canvas or DOM object that received the event
//
//        @return                (boolean)    true == real double click
//                                        false == really a single click
// @visibility internal
//<
isDoubleClick : function (target) {
    var EH = this,
        target = target || EH.lastEvent.nativeTarget;

    // If this click event occurred within the double-click delay of the last event, fire the
    // double-click handler rather than the click handler.

    var useNativeEventTime = EH.useNativeEventTime != null ? EH.useNativeEventTime :
                            (isc.Browser.isMoz && isc.Browser.isWin),
        time, withinDoubleClickInterval;

    // Explicit flag to indicate second click within double-click delay. This is used
    // by auto-test systems to ensure we handle two clicks as double click or separate single clicks
    // regardless of the timing during playback!
    if (EH._isSecondClick != null) {
        withinDoubleClickInterval = EH._isSecondClick;
    } else {

        if (useNativeEventTime) {
            var domevent = EH.lastEvent.DOMevent
                time = domevent ? domevent.timeStamp : null;
            // Sanity check
            if (time == 0 || !isc.isA.Number(time)) {
                this.logDebug("Unable to derive native 'timeStamp' attribute from DOM event");
                time = isc.timeStamp();
            }
            withinDoubleClickInterval = ((time - EH.lastClickTime) < EH.DOUBLE_CLICK_DELAY);

        } else {
            time = isc.timeStamp();
            withinDoubleClickInterval =
                // if it took us less than the double click delay to process the first click
                ((EH._lastClickCompleteTime - EH.lastClickTime) < EH.DOUBLE_CLICK_DELAY) ?
                    // then check for a second click strictly within the normal interval
                    ((time - EH.lastClickTime) < EH.DOUBLE_CLICK_DELAY) :
                    // otherwise treat any click that closely follows completion of the first click
                    // as a double click
                    ((time - EH._lastClickCompleteTime) < 100);
        }
    }



    // remember the click time for later
    EH.lastClickTime = time;

    // clear the lastClickTarget if it's already too late
    if (!withinDoubleClickInterval) {
        delete EH.lastClickTarget;
    }

    // If the two clicks occurred on the same target this is a doubleClick,
    // unless the special "noDoubleClicks" flag is set on the target, (in which case
    // we fire multiple single clicks).

    var isDouble = false;
    if (target == EH.lastClickTarget) {
        isDouble = !target.noDoubleClicks;
        if (isDouble) {
            var current = target;
            while (current.parentElement) {
                current = current.parentElement;
                if (current.noDoubleClicks) {
                    isDouble = false;
                    break;
                }
            }
        }
    }

    // if this is a doubleClick, remove the lastClickTarget so we'll go back to clicking next
    // time
    // otherwise note that we were the last thing clicked in case a double-click comes in later
    EH.lastClickTarget = (isDouble ? null : target);

    return isDouble;
},


// If the target passed in has a concept of enabled/disabled, determine if it is enabled.
targetIsEnabled : function (target) {

    // if no target specified, return false
    if (!target) return false;

    // If the target has been marked as destroyed, don't attempt to fire the handler on it
    if (target.destroyed) return false;

    // if the target has a isDisabled function, return the results of that
    //    for canvases, this is defined to go up the parent chain for us
    if (isc.isA.Function(target.isDisabled)) return !target.isDisabled();

    // otherwise, the target doesn't have the concept of being enabled, so assume it is enabled
    return true;
},


// Pointer events
// ---------------------------------------------------------------------------------------
_handlePointerDown : function (DOMevent) {
    var EH = isc.EH;

    if (DOMevent.pointerType === "touch") {
        return EH._handleTouchStart(DOMevent);
    } else {
        EH.DOMevent = DOMevent;
        var event = EH.getMouseEventProperties(DOMevent);

        event.originalType = event.eventType;
        event.eventType = EH.MOUSE_DOWN;
        return EH.doHandleMouseDown(DOMevent, event);
    }
},

_handlePointerMove : function (DOMevent) {
    var EH = isc.EH;
    if (DOMevent.pointerType === "touch") {
        return EH._handleTouchMove(DOMevent);
    } else {
        EH.DOMevent = DOMevent;
        var event = EH.getMouseEventProperties(DOMevent);
        if (EH.eventHandledNatively(DOMevent.type, DOMevent.target)) return EH._handledNativelyReturnVal;
        event.originalType = event.eventType;
        event.eventType = EH.MOUSE_MOVE;
        return EH._handleMouseMove(DOMevent, event);
    }
},

_handlePointerUp : function (DOMevent) {
    var EH = isc.EH;

    if (DOMevent.pointerType === "touch") {
        return EH._handleTouchEnd(DOMevent);
    } else {
        EH.DOMevent = DOMevent;
        var event = EH.getMouseEventProperties(DOMevent);
        if (EH.eventHandledNatively(DOMevent.type, DOMevent.target)) return EH._handledNativelyReturnVal;
        event.originalType = event.eventType;
        event.eventType = EH.MOUSE_UP;
        return EH._handleMouseUp(DOMevent, true);
    }
},

_handlePointerCancel : function (DOMevent) {
    var EH = isc.EH;

    if (DOMevent.pointerType === "touch") {
        return EH._handleTouchCancel(DOMevent);
    } else {
        EH.DOMevent = DOMevent;
        var event = EH.getMouseEventProperties(DOMevent);
        if (EH.eventHandledNatively(DOMevent.type, DOMevent.target)) return EH._handledNativelyReturnVal;
        event.originalType = event.eventType;
        event.eventType = EH.MOUSE_UP;
        return EH._handleMouseUp(DOMevent, true);
    }
},


//>Touch

// Touch events
// ---------------------------------------------------------------------------------------

_handlingTouchEventSequence : function () {

        var EH = isc.EH;

    return (EH._handledTouch != null &&
            EH._handledTouch != EH._touchEventStatus.READY_FOR_TOUCH &&
            EH._handledTouch != EH._touchEventStatus.TOUCH_COMPLETE);
},


_handleTouchStart : function (DOMevent) {

        var EH = isc.EH;




    EH.DOMevent = DOMevent;
    var    event = EH.getMouseEventProperties(DOMevent);

    if (EH.eventHandledNatively(DOMevent.type, DOMevent.target)) return EH._handledNativelyReturnVal;


    delete event.touchStartReturnValue;

    // maintain touch state for synthetic mouseDown/mouseUp
    this._handledTouch = EH._touchEventStatus.TOUCH_STARTED;

    var returnValue = EH.handleEvent(event.target, EH.TOUCH_START);

    if (returnValue !== false) {
        event.originalType = EH.TOUCH_START;


        event.eventType = EH.MOUSE_MOVE;
        EH._handleMouseMove(DOMevent, event);

        event.eventType = EH.MOUSE_DOWN;
        returnValue = EH.doHandleMouseDown(DOMevent, event);

        // Treat the user holding the finger over an item as a "long touch" - this
        // will trip context menu behavior for mobile browsers (where right-click isn't
        // otherwise possible)
        // Could also trip hover prompt behavior at a pinch
        if (EH._longTouchTimer != null) isc.Timer.clear(EH._longTouchTimer);
        EH._longTouchTimer = this.delayCall("_handleLongTouch", [], EH.longTouchDelay);
    }

    return event.touchStartReturnValue;
},

// Number of ms before we fire the synthetic "longTouch" event (user holding their finger
// over a widget in a touch browser like iPad/safari)
longTouchDelay:500,
_handleLongTouch : function () {

        var EH = isc.EH;
    EH._longTouchTimer = null;

    // Showing a context menu and handling a drag operation are mutually exclusive. If already
    // dragging, then don't fire the long touch event (which could result in showing a context
    // menu).
    //
    // There is similar logic in __handleMouseMove() to not start a drag if there are open menus
    // on screen.
    if (EH.dragging) return;

    if (!EH.mouseIsDown() || !EH.mouseDownTarget() || !EH.stillWithinMouseDownTarget()) return;

    // send the event up the chain of the target
    EH.bubbleEvent(EH.mouseDownTarget(), EH.LONG_TOUCH);
},

_isDescendantOfNativeTouchScrollableElement : function (widget) {

    while (widget != null) {
        if (widget._usingNativeTouchScrolling() && (widget.hscrollOn || widget.vscrollOn)) {
            return true;
        }
        widget = widget.parentElement;
    }



    return false;
},

_handleTouchMove : function (DOMevent) {

        var EH = isc.EH;



    EH.DOMevent = DOMevent;

    var    event = EH.getMouseEventProperties(DOMevent);

    if (EH.eventHandledNatively(DOMevent.type, DOMevent.target)) return EH._handledNativelyReturnVal;

    var returnValue = EH.handleEvent(event.target, EH.TOUCH_MOVE);

    if (returnValue !== false) {
        event.originalType = EH.TOUCH_MOVE;
        event.eventType = EH.MOUSE_MOVE;

        EH._handleMouseMove(DOMevent, event);

        // prevent default full-page drag if we're doing an SC drag
        if (EH.dragging && window.event != null) window.event.preventDefault();
    }

    // kill "long touch" event on drag move - it's counter intuitive to have (for example)
    // both scrolling and a context menu when you drag.
    if (EH._longTouchTimer != null) {
        isc.Timer.clear(EH._longTouchTimer);
        EH._longTouchTimer = null;
    }


    if (isc.Browser.isChrome) {
        var targetElem = DOMevent.target && (DOMevent.target.nodeType == 1 ? DOMevent.target
                                                                           : DOMevent.target.parentElement);
        // Do not allow native touch scrolling if we're in the middle of a drag.
        if (EH.dragTarget != null) {
            DOMevent.preventDefault();
            return false;

        // <textarea>s may be natively touch-scrolled.

        } else if (targetElem != null && targetElem.tagName === "TEXTAREA" &&
                   (targetElem.scrollWidth > targetElem.clientWidth ||
                    targetElem.scrollHeight > targetElem.clientHeight)) {
            /*empty*/

        // Check whether this widget either is or is a descendant of a widget that is using
        // native touch scrolling and which can be scrolled.
        } else if (event.target != null) {
            var eventTarget = event.target;
            if (isc.isA.DrawItem && isc.isA.DrawItem(eventTarget)) {
                eventTarget = eventTarget.drawPane;
            }
            if (isc.isA.Canvas(eventTarget) && !EH._isDescendantOfNativeTouchScrollableElement(eventTarget)) {
                DOMevent.preventDefault();
                return false;
            }
        }
    }
},


_shouldIgnoreTargetElem : function (targetElem) {
    var EH = this;

    if (targetElem == null) return true;

    var tagName = targetElem.tagName;
    if (tagName === "INPUT") {
        var inputType = targetElem.type;


        if (inputType === "submit") {
            if (EH.mouseDownEvent != null &&
                EH.mouseDownEvent.DOMevent.target != null &&
                !targetElem.contains(EH.mouseDownEvent.DOMevent.target))
            {
                return true;
            }
        } else if (inputType !== "button" &&
                   inputType !== "checkbox" &&
                   inputType !== "file" &&
                   inputType !== "radio") {
            return true;
        }
    } else if (tagName === "LABEL" ||
               tagName === "SELECT" ||
               tagName === "TEXTAREA")
    {
        return true;
    }

    return false;
},


_handleTouchEnd : function (DOMevent) {

        var EH = isc.EH;



    EH.DOMevent = DOMevent;
    var    event = EH.getMouseEventProperties(DOMevent);

    if (EH.eventHandledNatively(DOMevent.type, DOMevent.target)) return EH._handledNativelyReturnVal;

    // maintain touch state for synthetic mouseDown/mouseUp
    if (EH._handledTouch == EH._touchEventStatus.TOUCH_STARTED) {
        EH._handledTouch = EH._touchEventStatus.TOUCH_ENDING;
    }

    var returnValue = EH.handleEvent(event.target, EH.TOUCH_END);
    if (returnValue !== false) {
        event.originalType = EH.TOUCH_END;
        event.eventType = EH.MOUSE_UP;
        EH._handleMouseUp(DOMevent, true);
    }

    if (EH._handledTouch == EH._touchEventStatus.TOUCH_ENDING) {
        EH._handledTouch = EH._touchEventStatus.TOUCH_COMPLETE;
    }

    if (EH._longTouchTimer != null) {
        isc.Timer.clear(EH._longTouchTimer);
        EH._longTouchTimer = null;
    }

    var targetElem = (DOMevent.target && (DOMevent.target.nodeType == 1 ? DOMevent.target
                                                                        : DOMevent.target.parentElement));
    if (!EH._shouldIgnoreTargetElem(targetElem)) {
        DOMevent.preventDefault();
        return false;
    }
},


_handleTouchCancel : function (DOMevent) {


        var EH = isc.EH;



    EH.DOMevent = DOMevent;
    var    event = EH.getMouseEventProperties(DOMevent);

    if (EH.eventHandledNatively(DOMevent.type, DOMevent.target)) return EH._handledNativelyReturnVal;

    // maintain touch state for synthetic mouseDown/mouseUp
    if (EH._handledTouch == EH._touchEventStatus.TOUCH_STARTED) {
        EH._handledTouch = EH._touchEventStatus.TOUCH_ENDING;
    }

    this.delayCall("_handleDelayedTouchCancel", [event, DOMevent]);
},

_handleDelayedTouchCancel : function (event, DOMevent) {

        var EH = isc.EH;
    var returnValue = EH.handleEvent(event.target, EH.TOUCH_END);
    if (returnValue !== false) {
        event.originalType = EH.TOUCH_CANCEL
        event.eventType = EH.MOUSE_UP;
        EH._handleMouseUp(DOMevent, true);
    }

    if (EH._handledTouch == EH._touchEventStatus.TOUCH_ENDING) {
        EH._handledTouch = EH._touchEventStatus.TOUCH_COMPLETE;
    }

    if (EH._longTouchTimer != null) {
        isc.Timer.clear(EH._longTouchTimer);
        EH._longTouchTimer = null;
    }
},

//<Touch

// Focus Handling
// ---------------------------------------------------------------------------------------


getFocusCanvas : function () {
    return this._focusCanvas;
},

// focusInCanvas and blurFocusCanvas
// Called as a result of an action that will focus in a canvas, such as calling widget.focus(),
// or clicking on the widget.




// helper to log native focus changes
_logFocus : function (target, isFocus) {
    if (!this.logIsDebugEnabled("nativeFocus")) return;

    this.logDebug((isFocus ? "onfocus" : "onblur") +
                  " fired on: " + target + this._getActiveElementText(),
                  "nativeFocus");
},

_getActiveElementText : function () {
    if (!isc.Browser.isIE) return isc._emptyString;
    var activeElement = this.getActiveElement();

    if (activeElement == null) return isc._emptyString;
    return ", activeElement: " + (
                                  activeElement.tagName);
},


blurFocusCanvas : function (target, isNative) {
    //>DEBUG isNative indicates this call came from a blur handler on a native element (either
    // the handle or a focusProxy).
    var oldThread = this._thread;
    if (isNative) {
        this._setThread("BLR");
        this._logFocus(target);
        isc.EH._unconfirmedBlur = null;
    } //<DEBUG

    this._blurFocusCanvas(target, isNative);

    //>DEBUG
    if (isNative) this._thread = oldThread; //<DEBUG
},
_blurFocusCanvas : function (target, isNative) {
    //this.logWarn("_blurFocusCanvas called with focusCanvas: " + this._focusCanvas);
    if (this._focusCanvas) {
        var focusCanvas = this._focusCanvas;


        if (target != null && focusCanvas != target) return;
        this._focusCanvas = null;
        focusCanvas._focusChanged(false);

    }
},

focusInCanvas : function (target, isNative, item) {

    //>DEBUG isNative indicates this call came from a focus handler on a native element (either
    // the handle or a focusProxy).
    var oldThread = this._thread;
    if (isNative) {
        this._setThread("FCS");
        this._logFocus(target, true);
        isc.EH._unconfirmedFocus = null;
    } //<DEBUG

    // In Moz by default focus outline shows up on both mouseDown and focus via tab-keypress
    // we only want it to show up via keypress (like in IE).
    // use setShowFocusOutline to update the css setting to hide the focus outline if this focus
    // came from a mouseDown.
    if (isc.Browser.isMoz) {
        if (isNative && (this.lastEvent.eventType != this.KEY_DOWN &&
                         this.lastEvent.eventType != this.KEY_PRESS &&
                         this.lastEvent.eventType != this.KEY_UP))
        {
            if (target && target.showFocusOutline) target.setShowFocusOutline(false,true);
        } else {
            if (target && target.showFocusOutline) target.setShowFocusOutline(true,true);
        }
    }
    this._focusInCanvas(target, isNative, item);

    //>DEBUG
    if (isNative) this._thread = oldThread; //<DEBUG
},
_focusInCanvas : function (target, isNative, item) {
    //this.logWarn("_focusInCanvas. Will set this._focusCanvas to target:"
    //             + target + ", current focus target:" + this._focusCanvas);
    // if no target, or target doesn't want focus, or target has focus already just bail

    if (!target || target.hasFocus || !target._canFocus() || target.isDisabled() ) return;
    // Bail if this._focusCanvas is already pointing to the target.
    // Normally we'd expect target.hasFocus to be set in this case but if the _focusChanged
    // method on either the previous focus target or the new one forces a focus change, that
    // can occur before target.hasFocus gets modified.
    if (this._focusCanvas == target) return;

    // Handle the case of focus going to a masked widget
    this.checkMaskedFocus(target, item);
    // If the target is masked, update the topmask's 'maskedFocusCanvas'

    if (this.targetIsMasked(target) && !target._ignoreClickMaskFocus) {
        var topMask = this.clickMaskRegistry.last();
        this.setMaskedFocusCanvas(target, topMask);
    }


    if (isNative && isc.Browser.isMoz) {
        if (target.parentElement) target.parentElement._handleCSSScroll(null, true);
    }

    // blur the previous focus item, and focus in this one
    var blurCanvas = this._focusCanvas;
    this._focusCanvas = target;
    if (blurCanvas) blurCanvas._focusChanged(false)

    // if the blur handler forced focus into *another* widget, bail - we don't want to
    // fire _focusChanged on a stale widget - that'd cause hasFocus to be set on that widget
    // and be essentially stale
    if (this._focusCanvas != target) return;
    target._focusChanged(true);


},

// Helper to set (or clear) the 'masked focus canvas' for some mask.
setMaskedFocusCanvas : function (target, mask) {
    if (!mask) return;
    mask._maskedFocusCanvas = target;
},

getMaskedFocusCanvas : function (mask) {
    if (mask == null) mask = this.clickMaskRegistry.last();
    else mask = this.getClickMask(mask);
    if (mask) return mask._maskedFocusCanvas;
},

// fired when focus goes onto a widget which may be covered by a clickmask.
// if the mask is soft, it automatically dismisses that clickMask and fires the click
// action.
checkMaskedFocus : function (target, item) {


    if (isc.Browser.isIE || isc.Browser.seleniumPresent) {

        var activeElement = this.getActiveElement();
        var handle = target ? target.getHandle() : null;
        // no handle - undrawn so bail
        if (!handle) return;
        var focusStillInCanvas;

        while (activeElement && activeElement.tagName) {

            if (activeElement == handle) {
                focusStillInCanvas = true;
                break;
            }
            // if "eventProxy" is specified look at that and bail early - it either is or isn't
            // the widget that fired the onfocus event.
            if (activeElement.eventProxy) {
                focusStillInCanvas = (activeElement.eventProxy == target.getID());
                break;
            }
            activeElement = activeElement.parentElement;
        }
        if (!focusStillInCanvas) return;
    }


    if (isc.Browser.isMobileWebkit) {
        if (isc.EH.isMouseEvent(isc.EH.lastEvent.eventType) &&
            (isc.EH.mouseDownTarget() == target))
        {
            return;
        }
    }

    var masks = this.clickMaskRegistry;
    for (var i = masks.length-1; i >= 0; i--) {
        var mask = masks[i];
        // As soon as we hit a mask we know we're ABOVE we know we're above all remaining
        // masks so we can bail.
        if (!this.targetIsMasked(target, mask, null, item)) return;
        else {
            // we should never be able to focus on a widget under an hard
            // clickmask - just return false if we do hit this case
            if (this.isHardMask(mask)) return false;
            this._clickMaskClick(mask);
        }
    }
},


// prepare for a drag interaction on "target" (a Canvas)
prepareForDragging : function (target) {
    var EH = this;


    if (EH.dragging) EH.handleDragStop();

    delete EH.dragMoveAction;
    delete EH.dragTarget;

    // send prepareForDragging event: target is expected to set various dragging-related flag,
    // especially dragTarget, if it wants to be dragged.  See default implementation in Canvas.
    EH.bubbleEvent(target, "prepareForDragging");
    // no one set a drag target
    if (!EH.dragTarget) {
        if (this.logIsDebugEnabled("dragDrop")) this.logDebug("No dragTarget, not dragging", "dragDrop");
        return;
    }

    //>DEBUG
    if (this.logIsInfoEnabled("dragDrop"))
        this.logInfo("target is draggable with dragOperation: " + EH.dragOperation +
                     ", dragTarget is : " + EH.dragTarget +
                     (EH.dragTarget != target ? " (delegated from: " + target + ")" : ""),
                     "dragDrop");
    //<DEBUG

    // Remember the original rect of the dragTarget in case we need it later.  It is used,
    // for example, to implement proportional resizing in Canvas.resizeToEvent().
    EH.dragTargetStartRect = EH.dragTarget.getRect();
},

// Handle the artificially generated dragStart event, sent to a draggable object when the mouse
// goes down in the object and then moves the dragStartDistance while still down.
//
// Fires Canvas.dragStart() on the target (which may cancel the event) and sets up the visual
// appearance of dragging.
handleDragStart : function (nativeDragging) {
    var EH = this,
        event = EH.lastEvent;

    if (!EH.mouseIsDown() || !EH.dragTarget) return false;


    delete EH.dropTarget;
    delete EH.dragMoveTarget;
    // reset the dragOffsetX and dragOffsetY in case somebody set it before
    // these properties indicate the offset of the last event coordinates (typically this is
    // the position of the mouse) from the drag target
    EH.dragOffsetX = -10;
    EH.dragOffsetY = -10;

    // during dragging no Canvii will get mouseOver/mouseOut, so we need to send a final mouse
    // out event to avoid a Canvas getting stuck in the "over" state.
    EH.handleEvent(EH.lastMoveTarget, EH.MOUSE_OUT, null, EH.lastMoveTargetItem);

    // likewise we need to send mouseOut to the mouseDownTarget to avoid it getting stuck in
    // the down state.

    if (EH.lastMoveTarget != EH.mouseDownTarget()) {
        EH.handleEvent(EH.mouseDownTarget(), EH.MOUSE_OUT);
    }

    // If we're currently showing a hover, hide it.
    // We're not checking for the lastHoverCanvas matching the drag target etc since dragging could
    // be delegated from one drag target to another and there are no obvious cases where we'd
    // want the hover to be visible during dragging
    if (isc.Hover) isc.Hover.clear();

    // remember the drag offset; this is the distance between the point where the mouse went
    // down to start D&D and the top/left corner of the element being dragged.  We want to
    // maintain that offset during dragging, otherwise, dragRepositioned objects would have
    // their top-left corner snap to the mouse position when dragging began, and dragResized
    // objects would jerk by the dragOffset when dragging starts.
    // NOTE: capture offset before dragStart since dragStart might deparent.
    EH.dragStartOffsetX = EH.mouseDownEvent.x - EH.dragTarget.getPageLeft();
    EH.dragStartOffsetY = EH.mouseDownEvent.y - EH.dragTarget.getPageTop();

    // bubble the appropriate [dragStart, dragRepositionStart, or dragResizeStart] message to
    // the target.  This is an opportunity to set EH.dragAppearance
    var eventType = EH.dragOperation + "Start";

    if (EH.handleEvent(EH.dragTarget, eventType) == false) {
        //>DEBUG
        this.logInfo("drag cancelled by false return from: " +
                      eventType + " on " + EH.dragTarget,
                      "dragDrop");
        //<DEBUG

        // if it returns false, cancel dragging
        delete EH.dragTarget;
        delete EH.dragTargetLink;

        // send the drag object a mouseOver since we sent it mouse out when dragging began
        EH.handleEvent(EH.dragTarget, EH.MOUSE_OVER);

        return false;
    }

    // clear the lastMoveTarget since we've sent a mouseOut with no mouseOver
    delete EH.lastMoveTarget;


    // if we're dragRepositioning, and the dragAppearance is not the tracker,
    // set the isc.EventHandler.dragOffsetX and .dragOffsetY to the offset from the drag target
    var dragAppearance = EH.dragTarget.getDragAppearance(EH.dragOperation);
    if (dragAppearance != EH.TRACKER)
    {
        EH.dragOffsetX = EH.dragStartOffsetX;
        EH.dragOffsetY = EH.dragStartOffsetY;
    }

    // dragAppearance
    // --------------
    // We set the action to be performed on mouseMove events during dragging, based on the
    // dragTarget's dragAppearance.  For all types of dragging, we have:
    // - a "dragMoveTarget", which is a Canvas, and is chosen on the basis of dragAppearance.
    //   It can be the dragTarget itself ("target" dragAppearance) or some other object which
    //   stands in, like an outline or small "tracker".
    // - a "dragMoveAction", which is a function called every mouseMove.  The two built-in
    //   dragOperations, dragResizing and dragRepositioning, work by setting the dragMoveAction
    //   to a function that drag resizes or drag repositions the dragMoveTarget.
    //
    // Note that the dragAppearance is independant of whether you are doing dragResizing,
    // dragRepositioning, or a custom drag.  If you set a dragAppearance and do a generic drag
    // (that is, set canDrag but not canDragReposition or canDragResize), then we default the
    // dragMoveAction to moving the dragMoveTarget around; this is often used to show a
    // tracker.
    if (EH.dragOperation == EH.DRAG_SCROLL ||
        nativeDragging)
    {
        EH.dragAppearance = EH.NONE;
    } else {
        EH.dragAppearance = EH.dragTarget.getDragAppearance(EH.dragOperation);
    }

    // "tracker" drag appearance
    // - a small Canvas, settable via setDragTracker, "tracks" the mouse cursor at a small offset
    //
    if (EH.dragAppearance == EH.TRACKER) {
        // using the drag tracker
        EH.dragMoveTarget = EH._makeDragTracker();
        // tracker moves to event
        if (!EH.dragMoveAction) EH.dragMoveAction = EH._moveDragMoveTarget;

        // if the target wants it, tell it to set the dragTracker image
        EH.dragTracker.setOverflow(isc.Canvas.VISIBLE);
        EH.bubbleEvent(EH.dragTarget, EH.SET_DRAG_TRACKER);

        // change the offset for the tracker -- default -10,-10 in dragTrackerDefaults, but
        // customizable in setDragTracker()
        EH.dragOffsetX = EH.dragTracker.offsetX;
        EH.dragOffsetY = EH.dragTracker.offsetY;

    // "outline" drag appearance
    //
    } else if (EH.dragAppearance == EH.OUTLINE) {
        EH.dragMoveTarget = EH.getDragOutline(EH.dragTarget);

        // on drag move, we'll move to the mouse
        if (!EH.dragMoveAction) EH.dragMoveAction = EH._moveDragMoveTarget;

    // "target" drag appearance
    //
    } else if (EH.dragAppearance == EH.TARGET) {
        EH.dragMoveTarget = EH.dragTarget;
        if (!EH.dragMoveAction) EH.dragMoveAction = EH._moveDragMoveTarget;

        // If the canvas wants to show a shadow on drag, show it now.
        if (EH.dragTarget.showDragShadow) this._showTargetDragShadow();

        // If the canvas should change opacity on drag, handle this now.
        if (EH.dragTarget.dragOpacity != null) this._setTargetDragOpacity();
    // custom move style
    //
    } else {
        // nothing special to do here -- your target should set things up manually in its
        // .dragStart() handler.  It can set EH.dragMoveTarget and/or EH.dragMoveAction if
        // desired.
    }

    // if a dragMoveTarget is set, bring it to the front and show it
    if (EH.dragMoveTarget) {
        // make sure dragMoveTarget and dragTarget agree on some basic stuff
        if (EH.dragMoveTarget != EH.dragTarget) {
            EH.dragMoveTarget.dragIntersectStyle = EH.dragTarget.dragIntersectStyle;

        }
        // show and bring to front
        EH.dragMoveTarget.show();
        EH.dragMoveTarget.bringToFront();
    }


    //>PluginBridges

    var backmaskTarget = EH.dragMoveTarget ? EH.dragMoveTarget : EH.dragTarget;
    if ((isc.Browser.isIE || isc.Browser.isMoz) && EH.dragAppearance != EH.OUTLINE
        // already backmasked or should never be backMasked
        && !(backmaskTarget._isBackMask || backmaskTarget.neverBackMask))
    {
        if (EH.alwaysBackMask) {
            this._showBackMask(backmaskTarget);
        } else {
            var burnThroughElements = [];


            if (isc.BrowserPlugin) {
                var pluginInstances = isc.BrowserPlugin.instances;
                for (var i = 0; i < pluginInstances.length; i++) {
                    var pluginInstance = pluginInstances[i];
                    if (pluginInstance.isVisible()
                        && (backmaskTarget.parentElement == null
                            || backmaskTarget.parentElement.contains(pluginInstance, true)))
                    {
                        burnThroughElements.add({instance: pluginInstance,
                                                 rect: pluginInstance.getPageRect()});
                    }
                }
            }


            if (isc.Browser.isIE && isc.Browser.minorVersion >= 5.5 && isc.NativeSelectItem) {
                var selectItems = isc.NativeSelectItem.instances;
                for (var i = 0; i < selectItems.length; i++) {
                    var selectItem = selectItems[i];
                    if (selectItem.isVisible()
                        && (backmaskTarget.parentElement == null
                            || backmaskTarget.parentElement.contains(selectItem.containerWidget, true)))
                    {
                        burnThroughElements.add({instance: selectItem, rect: selectItem.getPageRect()});
                    }
                }
            }

            // if dynamicBackMask is false and we have elements that we could intersect with that
            // require backMasking, just show the backMask
            if(burnThroughElements.length > 0 && EH.dynamicBackMask === false)
            {
                this._showBackMask(backmaskTarget);
            } else {
                // set up the cache so that handleDragMove can do fast intersect tests
                EH._burnThroughElementsCache = burnThroughElements;
            }
        }
    }
    //<PluginBridges


    EH.showEventMasks((EH.dragOperation == EH.DRAG_RESIZE));

    // set the 'dragging' flag to true since we're dragging
    EH.dragging = true;
    EH.nativeDragging = !!nativeDragging;
    EH.crossFrameDragging = false;

    if (EH.nativeDragging && EH.delayedMouseMoveTimer != null) {
        isc.Timer.clear(EH.delayedMouseMoveTimer);
        EH.delayedMouseMoveTimer = null;
    }

    //>DEBUG
    this.logInfo("Started dragOperation: " + EH.dragOperation +
                  " with dragTarget: " + EH.dragTarget +
                  " dragAppearance: " + EH.dragAppearance, "dragDrop");
    //<DEBUG

    return true;
},

// Methods to show/hide drag shadows for targets.

_showTargetDragShadow : function () {
    var EH = isc.EH;
    var target = EH.dragTarget;

    EH._hideShadowAfterDrag = (!target.showShadow);
    EH._afterDragShadowDepth = target.shadowDepth;

    target.shadowDepth = EH.dragTargetShadowDepth;
    target.updateShadow();
    if (!target.showShadow) target.setShowShadow(true);
},

_hideTargetDragShadow : function () {
    var EH = isc.EH;
    var target = EH.dragTarget;

    if (EH._hideShadowAfterDrag) target.setShowShadow(false);
    target.shadowDepth = EH._afterDragShadowDepth;
    target.updateShadow();

    delete EH._hideShadowAfterDrag;
    delete EH._afterDragShadowDepth;
},

// Methods to modify the opacity of the drag target
_setTargetDragOpacity : function () {
    var EH = isc.EH;
    var target = EH.dragTarget;

    // Remember the old opacity

    EH._dragTargetOpacity = target.opacity;

    target.setOpacity(target.dragOpacity);
},

_resetTargetDragOpacity : function () {
    var EH = isc.EH,
        target = EH.dragTarget;
    target.setOpacity(EH._dragTragetOpacity);
},


_showBackMask : function (target) {
    if (target._backMask) {
        if (!target._backMask.isVisible()) target._backMask.show();
    } else {
        target.makeBackMask({_eventHandlerDragMoveMask: true});
    }
},

_hideBackMask : function (target) {
    if(target._backMask && target._backMask._eventHandlerDragMoveMask
       && target._backMask.isVisible())
    {
        target._backMask.hide();
    }
},


_getDragMoveComponents : function () {
    var dmt = this.dragMoveTarget;
    if (!dmt) return;
    var components = [dmt];
    if (dmt._backMask) components.add(dmt._backMask);
    if (dmt._edgedCanvas) components.add(dmt._edgedCanvas);
    if (dmt._shadow) components.add(dmt._shadow);
    return components;
},

// Helper to speed up the 'dragRepositionMove' et al name assembly
_dragMoveEventNames:{},
_getDragMoveEventName : function (dragOperation) {
    var eventNames = this._dragMoveEventNames;
    if (!eventNames[dragOperation]) {
        eventNames[dragOperation] = dragOperation + "Move";
    }
    return eventNames[dragOperation];
},

//> @classAttr EventHandler.showNoDropIndicator (boolean : false : IRW)
// If set to true, when the user drags a +link{canvas.canDrop,canDrop:true} canvas
// over any component with +link{canvas.canAcceptDrop} set to false or where
// +link{canvas.willAcceptDrop()} returns false, the +link{canvas.noDropCursor,no-drop cursor}
// will be shown automatically to indicate this is not a valid drop point.
// <P>
// This property can be modified at runtime, meaning a developer could choose to show the
// no drop indicator for specific drag/drop interactions by changing the value from
// a dragStart handler or similar.
// <P>
// Note that when this property is false, developers may still use the
// +link{canvas.dropMove} handler for potential drop targets and use +link{canvas.setCursor()}
// to explicitly indicate invalid drop areas within a widget. This is the approach used
// by default for +link{TreeGrid} drag/drop interactions, for example.
// @visibility external
//<
showNoDropIndicator:false,
// Are we currently dragging a droppable widget?
dragDropInProgress : function () {

    return this.dragging && this.dragTarget &&
            this.dragTarget.canDrop &&
            (this.dragOperation != this.DRAG_RESIZE);

},

// Deliver the synthetic dragMove event, also handling the dragAppearance
handleDragMove : function () {
    var EH = this,
        event = EH.lastEvent;

    // get the drop target, if there is one
    isc._useBoxShortcut = true;
    EH.dropTarget = EH.getDropTarget(event);
    isc._useBoxShortcut = false;

    // if "showNoDropIndicator" is true we need to update cursor to potentially display
    // the no-drop indicator.

    if (this.showNoDropIndicator && event.target) event.target._updateCursor();

    //>PluginBridges


    if (EH._burnThroughElementsCache && EH.dynamicBackMask) {
        var showBackMask = false;
        var backmaskTarget = EH.dragMoveTarget ? EH.dragMoveTarget : EH.dragTarget;
        var backmaskTargetRect = backmaskTarget.getRect();

        for (var i = 0; i < EH._burnThroughElementsCache.length; i++) {
            var burnThroughElement = EH._burnThroughElementsCache[i];
            if (isc.Canvas.rectsIntersect(burnThroughElement.rect, backmaskTargetRect))
            {
                EH._lastBurnThroughElement = burnThroughElement.instance;
                showBackMask = true;
                break;
            }
        }

        // Applet/IFrame layering workaround - see doc in Applet.repaintIfRequired()
        if (EH._lastBurnThroughElement) {
            if (EH._lastBurnThroughElement.repaintIfRequired) EH._lastBurnThroughElement.repaintIfRequired();
        }

        if (showBackMask) {
            this._showBackMask(backmaskTarget);
        } else {
            this._hideBackMask(backmaskTarget);
            delete EH._lastBurnThroughElement;
        }
    } else if (isc.BrowserPlugin) {
        isc.BrowserPlugin.handleDragMoveNotify();
    }
    //<PluginBridges

    // if a dragMoveAction has been set, call it now
    if (EH.dragMoveAction) EH.dragMoveAction();

    // send the appropriate [dragMove, dragResizeMove, dragRepositionMove] event to the
    // dragTarget and bail if it returns false.  This is another way for your handler to stop
    // drop processing if you don't like what you're about to be dropped over.
    // NOTE: this cancels drop events being sent to the candidate drop target, not the
    // dragMoveAction, which eg moves the dragTracker with the mouse.
    if (EH.handleEvent(EH.dragTarget, this._getDragMoveEventName(EH.dragOperation)) == false) {
        delete EH.dropTarget;
        return false;
    }

    // if the dropTarget is not the last drop target that got a mouse event
    //    send the dropOver and dropOut routines to the targets
    if (EH.dropTarget != EH.lastDropTarget) {

        //>DEBUG
        this.logDebug("New drop target: " + EH.dropTarget, "dragDrop");
        //<DEBUG

        // send the mouseOut event to the last mover object
        if (EH.lastDropTarget) {
            EH.handleEvent(EH.lastDropTarget, EH.DROP_OUT);
        }

        // send the mouseOver event to the target
        if (EH.dropTarget) {
            EH.handleEvent(EH.dropTarget, EH.DROP_OVER);
        }

        // remember that we're the last move object
        EH.lastDropTarget = EH.dropTarget;
    }

    // call dropMove on the dropTarget
    if (EH.dropTarget) {
        EH.handleEvent(EH.dropTarget, EH.DROP_MOVE);
    }

    isc._useBoxShortcut = true;
    this._handleDragScroll();
    isc._useBoxShortcut = false;


    if (this.dragOperation == EH.DRAG_SELECT) return true;
    return false;
},

// Automatic scroll on drag: if we're dragging near the edge of a scrollable widget, scroll it
// in the appropriate direction.

_handleDragScroll : function () {
    var EH = this,
        dragTarget = EH.dragTarget;

    // don't use automatic drag scrolling at edges if the drag operation itself is scrolling
    // (the two behaviors would fight)
    if (EH.dragOperation == EH.DRAG_SCROLL) return;

    // Determine which widget would be scrolled (assuming we're over the right place)

    var scrollCandidates = [];
    // If this is a drag-select, we only ever want to scroll the widget itself or its
    // parent-list.
    // Otherwise respect dragScrollType
    var canvasList = (EH.dragOperation == EH.DRAG_SELECT) ||
                        dragTarget.dragScrollType == "parentsOnly" ?
                        dragTarget.getParentElements() : isc.Canvas._canvasList;
    ;
    if (EH.dragOperation == EH.DRAG_SELECT) canvasList.addAt(dragTarget, 0);

    // shortcut - if there are no valid scroll candidates, just bail
    // True for top level widgets with dragScrollType set to parentsOnly
    if (canvasList == null || canvasList.length == 0) return;

    for (var i = 0; i < canvasList.length; i++) {
        if (canvasList[i].isDrawn() && canvasList[i].isVisible() &&
            canvasList[i].shouldDragScroll()
        ) {
            scrollCandidates.add(canvasList[i]);
        }
    }

    var event = EH.lastEvent,
        eX = event.x, eY = event.y,
        matches = [];

    //this.logWarn("have dragScroll candidates: " + scrollCandidates);

    for (var i = 0; i < scrollCandidates.length; i++) {

        if (scrollCandidates[i].visibleAtPoint(eX, eY, false, EH._getDragMoveComponents()))
            matches.add(scrollCandidates[i]);
    }

    // If we end up with more than one scroll candidate, one must be an ancestor of the
    // other [as visibleAtPoint() will not return true for a widget covered by another widget]
    // Check each of these for whether we're over the scroll area of the widget,
    // and remove from the list of candidates if not

    if (matches.length > 0) {
        var scrollWidget;
        for (var i = 0; i < matches.length; i++) {
            // dragScrollDirection used to limit dragScrolling of ancestors to either
            // horizontal or vertical
            // This property is set on certain widgets such as the scrollbar thumb where
            // scrolling the parent in response to dragging only makes sense on one axis
            if (matches[i]._overDragThreshold(dragTarget.dragScrollDirection)) {
                if (scrollWidget == null || scrollWidget.contains(matches[i], true))
                    scrollWidget = matches[i];
            }
        }
        if (scrollWidget != null) {
            scrollWidget._setupDragScroll(
                dragTarget.dragScrollDirection,
                // scroll on drag select has some additional logic in Canvas.js to
                // avoid scrolling a parent too far
                EH.dragOperation == EH.DRAG_SELECT);
        }
    }
},


// Deliver the artificially generated 'dragStop' event when the mouse goes up at the end of a
// drag
handleDragStop : function () {

    var EH = this,
        event = EH.lastEvent,
        successfulDrag = false;

    EH.wasNativeDragging = EH.nativeDragging;

    // note that we're no longer dragging
    EH.crossFrameDragging = EH.nativeDragging = EH.dragging = false;

    //>DEBUG
    this.logInfo("end of drag interaction", "dragDrop");
    //<DEBUG

    // reset the drag offsets
    EH.dragOffsetX = EH.dragOffsetY = 0;

    var dragTarget = EH.dragTarget,
        dragMoveTarget = EH.dragMoveTarget,
        dragOperation = EH.dragOperation;

    // save the dragMoveTarget's pageRect for later before it is hidden
    var dragMoveTargetPageRect = dragMoveTarget && dragMoveTarget.getPageRect();

    // if the dragMoveTarget is the tracker or outline, hide it
    // And move offscreen so it doesn't take up screen real-estate/introduce scrollbars.
    if (dragMoveTarget &&
        (dragMoveTarget == EH.dragTracker || dragMoveTarget == EH.dragOutline))
    {
        dragMoveTarget.hide();

    } else {
        // If we're showing a drag-shadow, hide (or shrink) it
        if (dragTarget.showDragShadow) EH._hideTargetDragShadow();

        // If the target has a special drag-opacity, revert to orginal opacity
        // If we're showing a drag-shadow, hide (or shrink) it
        if (dragTarget.dragOpacity != null) EH._resetTargetDragOpacity();

    }

    // if the dragTracker was customized via setDragTracker(), destroy it now and re-create
    // next time we need it.
    if (this.dragTracker && this.dragTracker._isCustomized) {
        this.dragTracker.destroy();
        delete this.dragTracker;
    }

    //>PluginBridges
    var backmaskTarget = EH.dragMoveTarget ? EH.dragMoveTarget : EH.dragTarget;
    this._hideBackMask(backmaskTarget);

    if (EH._burnThroughElementsCache) delete EH._burnThroughElementsCache;
    //<PluginBridges

    // if there is a dropTarget,
    var dropTarget = EH.dropTarget;
    if (dropTarget) {
        // send it the 'dropOut' event so it can reset its visible state
        EH.handleEvent(EH.dropTarget, EH.DROP_OUT);

        EH.handleEvent(dropTarget, EH.DROP);

        successfulDrag = true;
    }

    // determine if we were dragging something other than the dragTarget (eg an outline)
    var wasDraggingTarget = (dragTarget == dragMoveTarget);

    // send the dragTarget the [ dragStop | dragRepositionStop | dragResizeStop ] event so it can
    // reset its visual state
    if (EH.handleEvent(dragTarget, dragOperation+"Stop") != false) {

        successfulDrag = true;

        if (dragOperation == EH.DRAG_RESIZE) {

            if (!wasDraggingTarget) {
                // if we're dragging a tracker, don't resize to fit it, rely on the event coords instead

                if (dragMoveTarget != null && this.dragAppearance != this.TRACKER) {

                    // resize the dragTarget to the size of the dragMoveTarget
                    dragTarget.setPageRect(  dragMoveTargetPageRect[0],
                                             dragMoveTargetPageRect[1],
                                             dragMoveTargetPageRect[2],
                                             dragMoveTargetPageRect[3],
                                             true   );
                // drag appearance "none"
                } else {
                    var resizeEdge = isc.EH.resizeEdge;
                    if (resizeEdge != null) {
                        var X = isc.EH.getX(),
                            Y = isc.EH.getY(),
                            lOffset = resizeEdge.contains("L") ? X- EH.dragTargetStartRect[0] : 0,
                            tOffset = resizeEdge.contains("T") ? Y- EH.dragTargetStartRect[1] : 0;

                        // One of "L", "R", "T", "B", "LR", etc
                        dragTarget.setPageRect(
                            resizeEdge.contains("L") ? X : EH.dragTargetStartRect[0],
                            resizeEdge.contains("T") ? Y : EH.dragTargetStartRect[1],
                            resizeEdge.contains("R") ? X - dragTarget.getPageLeft()
                                : EH.dragTargetStartRect[2] - lOffset,
                            resizeEdge.contains("B") ? isc.EH.getY()-dragTarget.getPageTop()
                                :  EH.dragTargetStartRect[3] - tOffset,
                            true
                        );
                    }
                }
            }

            var deltaX = dragTarget.getVisibleWidth() - EH.dragTargetStartRect[2],
                deltaY = dragTarget.getVisibleHeight() - EH.dragTargetStartRect[3];

            // fire 'dragResized()' one-time event to indicate we're done drag-resizing

            dragTarget.dragResized(deltaX, deltaY);

        // otherwise if a reposition operation
        } else if (dragOperation == EH.DRAG_REPOSITION) {
            if (!wasDraggingTarget) {
                if (dragMoveTarget != null) {
                    // move the target if we were moving a different drag-move target.
                    dragTarget.setPageRect(  dragMoveTargetPageRect[0],
                                             dragMoveTargetPageRect[1]  );
                } else {
                    dragTarget.setPageRect(isc.EH.getX(), isc.EH.getY());
                }
                // and bring it to the front
                dragTarget.bringToFront();
            }

            // Fire 'dragRepositioned' to indicate we have drag-moved the widget
            EH.dragTarget.dragRepositioned();
        }

    // drag[Reposition|Resize]Stop returned explicit "false", indicating cancel -
    // if we were moving the dragTarget, put it back the way we found it
    } else {
        if (dragOperation == EH.DRAG_RESIZE) {
            // if we were actually resizing the original target
            if (wasDraggingTarget) {
                // set its rect back to its original rect
                dragTarget.setRect(EH.dragTargetStartRect);
            }
        } else if (EH.dragOperation == EH.DRAG_REPOSITION) {
            // if we were actually moving the original target
            if (wasDraggingTarget) {
                // set its location back to its original location
                dragTarget.moveTo(EH.dragTargetStartRect[0],EH.dragTargetStartRect[1]);
            }
        }
        // Don't fire the one-time resized() / repositioned() events in this case.
    }

    // clear all drag properties (they may have been set by event handlers)
    EH.clearDragProperties();

    // 030801 jmd: hide eventMasks (which avoided swallowing of drag events in iframes)
    EH.hideEventMasks();

    // send the object under the mouse a 'mouseOver' event and make it the lastMoveTarget
    // In DOM browsers and IE4, mouseUp is sent to the object under the mouse, so we can
    // send mouseOver to the event target.
    // But, don't do this if handling the end of a touch event sequence because the overTarget
    // might be left thinking that the mouse is over it for a while. For example, if the user
    // drag-rearranges the header buttons of a ListGrid on a touch-enabled device, the user just
    // lifted his or her finger off of the display, so the header button might be shown in the
    // "Over" state for a while while EH waits for a touchstart event that might not ever come.
    if (EH._handledTouch != EH._touchEventStatus.TOUCH_ENDING) {
        var overTarget = EH.lastEvent.target;
        if (overTarget) EH.handleEvent(overTarget, EH.MOUSE_OVER);

        // remember the last move object
        EH.lastMoveTarget = overTarget;

        // remember the associated FormItem (if any)
        EH.lastMoveTargetItem = isc.DynamicForm && isc.isA.DynamicForm(overTarget) ?
            isc.DynamicForm._getEventTargetItem() : null;
    }

    // if "showNoDropIndicator" is true we need to update cursor to potentially clear
    // the no-drop indicator.
    // Otherwise it'll stick around til the next mouseMove
    if (this.showNoDropIndicator && event.target) event.target._updateCursor();

    // return whether the drag was successful
    return successfulDrag;
},

// Return the Canvas that is the intended recipient of this event.
//
// This maps events from the physical DOM into our logical Canvas event space,
// allowing us to process events in canvases easily.
//
// If the targeted canvas has an 'eventProxy', that will receive the event instead.
//
//        @param    DOMevent        (DOM event)         DOM event object (as passed by isc.EventHandler)
//        @param    target            (DOM element)         Native DOM element that got the event (default is DOMevent.target|srcElement).
//
//        @return                (Canvas || DOM object)    Canvas or DOM object that is event recipient
_$BODY:"BODY", _$HTML:"HTML",
_$eventProxyAttributeName:"eventProxy",
_$eventPartAttributeName:"eventpart",
getEventTargetCanvas : function (DOMevent, target, scEvent) {

    // DOMevent may be null if this method is being used to just
    // locate a canvas from a DOM element explicitly.

    if (DOMevent == null) DOMevent = {};

    var EH = this,
        wd = this.getWindow();



    if (!target) target = (isc.Browser.isIE ? DOMevent.srcElement : DOMevent.target);
    //this.logWarn("native target:"+ (target ? (target.tagName + ", " + target.id) : " null"));


    if (!EH._canAccessNativeTargetProperties(target)) {
        //this.logWarn("TextNode exception: had to return last target " + EH.lastTarget);
        return EH.lastTarget;
    }

    if (DOMevent && DOMevent._isSynthetic) return DOMevent.target;

    // optimization: if there is no target or the target is the body tag (so there is no
    // canvas target), bail immediately.  This means we don't burn CPU time while the mouse
    // is moving around outside all Canvas's
    if (!target || target.tagName == this._$BODY || target.tagName == this._$HTML) {
        //this.logWarn("event targetted at body");
        return (EH.lastTarget = null);
    }

    if (target && target.tagName && target.tagName == this._$applet) {
        var appletID = isc.Applet ? isc.Applet.idForName(target.name) : null;
        return appletID ? window[appletID] : EH.lastTarget;
    }


    if (isc.Browser.isIE && target.parentElement == null) {
//         this.logWarn("Defaulting to last target because target: " + Log.echoLeaf(target) +
//                      " has null parentElement");
        target = EH.lastTarget;
    } else {
        var eventProxyAttributeName = this._$eventProxyAttributeName,
            eventPartAttr = this._$eventPartAttributeName,
            eventPartElement = null,
            eventPart = null,
            eventPartID = null;

        // follow the DOM parent chain to find the nearest containing Element which has an
        // eventProxy attribute - the eventProxy attribute is the global ID of a Canvas
        // which will handle the event.
        // NOTE: all Canvii write out an eventProxy on the DIV that contains all
        // their content.  This is normal way events are routed, however, you can put an
        // "eventProxy" attribute in any HTML element to have its events handled by a Canvas.
        //var lookupChain = [];

        if (isc.Browser.isIE && !isc.Browser.isIE9) {
            // in IE, any attribute written in HTML is available as a property on the
            // HTMLElement object
            while (target != null) {
                //lookupChain.add(target);

                if (scEvent != null && eventPart == null && target[eventPartAttr] != null) {
                    eventPartElement = target;
                    eventPart = target.eventpart;
                    // Store the whole ID - no need for the performance hit of chopping
                    // off the leading widgetID_partName_ stuff unless this is
                    // actually required (let Canvas handle that).
                    eventPartID = target.id;
                }

                // stop if we've found the eventProxy attribute
                if (target.eventProxy) break;

                // otherwise continue to parent
                target = target.parentElement;
            }


            if (eventPartID == isc.emptyString) eventPartID = null;
        } else {
            // in DOM browsers, you have to use DOM methods like hasAttribute/getAttribute.
            while (target != null) {
                //lookupChain.add(target);
                var hasAttr = target.hasAttribute != null;
                if (scEvent != null && eventPart == null &&
                    (target.eventpart != null ||
                    (hasAttr && target.hasAttribute(eventPartAttr))) )
                {
                    eventPartElement = target;
                    eventPart = target.getAttribute(eventPartAttr);
                    eventPartID = target.getAttribute("id");
                }

                // stop if we've found the eventProxy attribute
                if (target.eventProxy != null ||
                    (hasAttr && target.hasAttribute(eventProxyAttributeName)))
                {
                    break;
                }

                // otherwise continue to parent
                target = target.parentNode;
            }
        }

        // If we found an eventPart, hang onto it now.
        // Otherwise clear the stored eventPart info.

        if (scEvent && target != null) {
            scEvent.eventPart = eventPart;
            scEvent.eventPartElement = eventPartElement;
            scEvent.eventPartID = eventPartID;
        }



        // we followed the parent chain until it ended without finding an eventProxy
        // attribute, so there's no Canvas to handle this event
        if (!target) return (EH.lastTarget = null);

        // "target" is the first DOM element in the parent chain with an eventProxy
        // attribute.  It's eventProxy attribute is a String that is the global ID of a
        // Canvas.  convert target to a Canvas
        target = wd[target.getAttribute(eventProxyAttributeName)];

        // Canvii can use the eventProxy attribute to delegate events to other Canvii
        while (target && target.eventProxy) {
            //if (DOMevent.type != "mousemove") {
            //    this.logWarn("Canvas: " + target + " delegates to: " + target.eventProxy);
            //}

            if (isc.isA.String(target.eventProxy)) {
                // if eventProxy is the string ID of a Canvas, convert it to a pointer to the
                // other Canvas, and store the looked-up Canvas.
                target.eventProxy = wd[target.eventProxy];
            }
            target = target.eventProxy;
        }

        // now we have the final target of the event

        if (this.logIsInfoEnabled() && !DOMevent ||
            (DOMevent.type != "mousemove" && DOMevent.type != "selectstart"))
        {
            if (target != null) {
                this.logInfo("Target Canvas for event '" + DOMevent.type + "': " + target);
            } else {
                this.logDebug("No target Canvas for event '" + DOMevent.type + "'");
            }
        }

        // if the event is in the drag tracker, send it to the last known object instead
        if ( target == EH.dragTracker ) {
           target = EH.lastTarget;
        }

        // remember the object for later, in case we get a weird event where we can't
        // figure out the target
        EH.lastTarget = target;
    }

    var targetIsDrawPane = false;
    if (scEvent != null && isc.isA.DrawPane &&
        (isc.isA.DrawItem(target) || (targetIsDrawPane = isc.isA.DrawPane(target))))
    {
        var drawPane = targetIsDrawPane ? target : target.drawPane;

        target = drawPane.getEventTarget(scEvent);
    }

    return isc.isA.BaseWidget(target) ? target : null;
},

_$textObjectString:"[object Text]",
_canAccessNativeTargetProperties : function(target) {


    // Optimization - if we're not in Moz, looking at a text node, assume we're ok
    try {
        if (!(isc.Browser.isMoz && target == this._$textObjectString)) return true;
        target.parentNode;
    } catch (e) {
        return false;
    }
    return true;

},



//>    @classMethod    isc.EventHandler.getDropTarget()    (A)
//        Return the first object that's registered that it's interested in drops that is under
//        the mouse.<br>
//      This method does not check the result of the dynamic 'willAcceptDrop()' method, so it's
//      possible that the canvas returned by this method will not actually accept drop from the
//      dragged widget.
//
//        @group    dragDrop
//        @param    event        (SC event)  Event object, as returned from EH.getMouseEventProperties
//
//        @return                (Canvas)    Canvas that should receive the drop, or null if none found
//  @visibility internal
//<
// Note: Not checking willAcceptDrop() is desired behavior - this allows behavior such as showing
// the no-drop indicator (for example no drop indicator on certain rows in a grid)
getDropTarget : function (event) {
    var EH = this;



    // if there is no target or the drag target can't be dropped,
    //    return null because there can't be a drop target!
    if (!EH.dragTarget || !EH.dragTarget.canDrop ||
        EH.dragOperation == EH.DRAG_RESIZE) return null;

    var target = (EH.dragMoveTarget || EH.dragTarget),

        dropCandidates = EH._dropRegistry,
        matches = [],
        i = 0,
        length = dropCandidates.length,

        // we'll always disallow dropping over self if dragAppearance is target
        canDropOnSelf = (target.getDragAppearance(EH.dragOperation) != isc.EH.TARGET)
    ;

    // perform different checks based on how we're supposed to intersect the drop targets
    if (target.dragIntersectStyle == EH.INTERSECT_WITH_MOUSE) {


        if ((event.target != this.mouseDownTarget() ||
            (isc.Browser.isIE || (isc.Browser.isSafari && !isc.Browser.isTouch) ||
            (isc.Browser.isMoz && isc.Browser.geckoVersion > 20040616 &&
             !this.mouseDownTarget()._useMozScrollbarsNone))) )
        {
            var dropTarget = event.target;

            // allow delegating dropTarget for eg dropLine indicators
            while (dropTarget && dropTarget.dropTarget) dropTarget = dropTarget.dropTarget;
            if ((canDropOnSelf || dropTarget != target) &&
                (dropCandidates.contains(dropTarget)))
            {
                //this.logWarn("used quick check, dropTarget: " + dropTarget +
                //              ", event target: " + event.target);
                return dropTarget;
            }
        }

        // check whether mouse coordinates are within candidate drop target
        // Note - we're using 'visibleAtPoint()' here rather than 'containsPoint()', as we don't
        // want to pick up a drop target that's occluded by another widget.
        // We may still pick up more than one match, as one canAcceptDrop:true widget may be
        // a child of another.
        // We ignore the dragMoveTarget in this check since it is likely to be under the mouse
        // (or near enough that a quick movement may put it under the mouse).
        for (;i<length;i++) {
            var candidate = dropCandidates[i];

            if (candidate.canAcceptDrop && !candidate.isDisabled() &&
                (
                 candidate.visibleAtPoint(event.x, event.y, false,
                                          EH._getDragMoveComponents())
                 // candidate.containsPoint(event.x, event.y))
                ) &&
                (canDropOnSelf || !target.contains(candidate, true))
               )
            {
                matches.add(candidate);
            }
        }
    } else {
        // check whether dragMoveTarget (tracker, outline, etc) intersects candidate drop target
        for (;i<length;i++) {
            var candidate = dropCandidates[i];
            if (!canDropOnSelf && candidate == target) continue;

            if (candidate.intersects(target) &&
                candidate.canAcceptDrop && !candidate.isDisabled())
            {
                matches.add(candidate);
            }
        }
    }

    //this.logWarn("dropTarget matches" + matches);

    // if there's only one possible drop target, return it
    if (matches.length < 2) return matches[0];

    // For mouse intersection, we may have multiple matches.
    // If some match is the parent of another, the child will always be given preference
    var nearestMatch = matches[0];
    for (var i = 1; i < matches.length; i++) {
        var currentMatch = matches[i];
        // if one is an ancestor of the other, the descendant always wins
        if (nearestMatch.contains(currentMatch, true)) {
            nearestMatch = currentMatch;

        // intersectRect check about doesn't handle the case of overlapping widgets occluding
        // each other catch the case of 1 match occluding another.
        } else if (target.dragIntersectStyle == EH.INTERSECT_WITH_RECT) {

            // Othewise we want to find a common ancestor of both widgets,
            // and compare the z-indices of their separate ancestors in that common scope
            var commonParent = null,
                nmCommonScopeAncestor = nearestMatch,
                cmCommonScopeAncestor = currentMatch;

            while (commonParent == null) {
                // if we've reached a top-level ancestor widget, the common scope is the document
                // body, so we'll compare the top-parent of each match widget.
                if (nmCommonScopeAncestor.parentElement == null) {
                    commonParent = true;    // to break out of the while loop
                    cmCommonScopeAncestor = currentMatch.topElement || currentMatch;

                // Otherwise check if the ancestor's parentElement is also the ancestor of the
                // currentMatch
                } else if (nmCommonScopeAncestor.parentElement.contains(currentMatch, true)) {
                        commonParent = nmCommonScopeAncestor.parentElement;
                        // iterate up the currentMatch's parents til we find one in the right scope
                        while (cmCommonScopeAncestor.parentElement != commonParent) {
                            cmCommonScopeAncestor = cmCommonScopeAncestor.parentElement;
                        }

                } else {
                    // look at the ancestor's parent (which we know is not a common ancestor of both
                    // matches)
                    nmCommonScopeAncestor = nmCommonScopeAncestor.parentElement;
                }
            }

            // compare the z-indices of the ancestors in the same scope, and adjust nearestMatch if
            // necessary
            if (cmCommonScopeAncestor.getZIndex() > nmCommonScopeAncestor.getZIndex()) {
                nearestMatch = currentMatch;
            }
        }
    }

    return nearestMatch;
},

// Register a canvas passed to receive drop events.
registerDroppableItem : function (item) {
    if (!item._dropRegistered) {
        this._dropRegistry.add(item);
        item._dropRegistered = true;
    }
},

// Un-register a canvas so it will no longer receive drop events
unregisterDroppableItem : function (item) {
    this._dropRegistry.remove(item);
    delete item._dropRegistered;
},


// Register this Canvas as needing to be "masked" during drag interactions, because it contains
// something that will otherwise swallow events.

registerMaskableItem : function (item, makeMask) {
    if (!this._maskRegistry.contains(item) &&
            (item._maskTarget == null || !this._maskRegistry.contains(item._maskTarget))) {
        // keep a list of items that need masking so we can show their masks when a drag begins
        this._maskRegistry.add(item);

        if (item.dragMaskType == "iframe") {
            if (makeMask) this.makeEventFrame(item, {eventProxy:item});
        } else if (item.dragMaskType == "hide") {
        } else if (item.dragMaskType == "hidePlugin") {
        } else {
            // make an event mask for the item that just passes events through to it.  It won't be
            // show()n yet.
            if (makeMask) this.makeEventMask(item, {eventProxy:item});
        }
    }
},

//>    @classMethod    isc.EventHandler.unregisterMaskableItem()    (A)
//        Remove this canvas from the _maskRegistry and destroy its
//        event mask peer.
//   @visibility internal
//<
unregisterMaskableItem : function (item) {
    this._maskRegistry.remove(item);
    if (item._eventMask) item._eventMask.destroy();
    delete item._eventMask;
},

// Make a transparent mask suitable for capturing events, as a peer of the target Canvas
makeEventMask : function (canvas, properties, rect) {
    if (isc.isA.Function(canvas.makeEventMask)) return canvas.makeEventMask(properties, rect);

    var defaults = this._eventMaskProperties;

    // In IE7, the spacerHTML isn't sufficient to mask IFRAMEs properly, but an image works
    // Note: if you update this code, also check and update ScreenSpan.getInnerHTML()
    if (!defaults.contents) defaults.contents = isc.Browser.isIE && isc.Browser.version > 6 ?
        isc.Canvas.blankImgHTML(3200,2400) : isc.Canvas.spacerHTML(3200,2400);
    var mask = isc.Canvas.create({
            ID:canvas.getID()+"_eventMask",
            cursor:canvas.cursor,
            _maskTarget: canvas
        }, defaults, properties);
    mask.setRect(rect ? rect : canvas.getRect());
    canvas._eventMask = mask;
    canvas.addPeer(mask);
    return mask;
},

//>    @classAttr    EventHandler._eventMaskProperties  (object : {...} : IRWA)
//  @visibility internal
//<
_eventMaskProperties : {
    autoDraw:false,

    // match the size of the Canvas we're masking
    _resizeWithMaster:true,
    _redrawWithMaster:false,

    // NOTE: we can't initialize the contents here because EventHandler loads before Canvas.
    // By setting very large contents with overflow:hidden we never need to redraw on resize.
    //contents:isc.Canvas.spacerHTML(3200, 2400),
    overflow:"hidden",

    // start out hidden, only show if explicitly shown
    visibility:"hidden",
    _showWithMaster:false,

    getTarget : function () {
        return this._maskTarget;
    },

    show : function () {
        // when we're show()n (because dragging has begun), move above the master.  NOTE: this
        // doesn't guarantee the eventMask stays above the master in general - only when
        // explicitly show()n
        var master = this.masterElement;
        this.moveAbove(master);
        return this.Super("show", arguments);
    }
},

// Show event masks for all registered canvases, or a single event mask
// spanning the entire screen if simpleMask is true.
showEventMasks : function (simpleMask, unmaskedItems) {
    var EH = this,
        maskedItems = EH._maskRegistry;
    if (simpleMask) {
        // just do a single screen-sized mask
        if (!EH._eventMask) EH._eventMask = isc.ScreenSpan.create({
            ID:"isc_EH_eventMask",
            mouseDown:function () {this.hide()},    // 030801 jmd: insurance against lock-out if stuck
            // if the screenspan gets destroyed() clear up our pointer to it
            pointersToThis:[{object:EH, property:"_eventMask"}]
        });
        EH._eventMask.show();
        EH._eventMask.bringToFront();
        //>BrowserPlugin
        // browser plugin masks typically cannot be replaced by a single screen mask, always
        // show these
        if (isc.BrowserPlugin) {
            maskedItems.intersect(isc.BrowserPlugin.instances).map("_showDragMask");
        }
        //<BrowserPlugin
    } else {
        // show masks for all components that need masking
        for (var i = 0; i < maskedItems.length; i++) {
            var item = maskedItems[i];

            // If we've been passed an explicit set of items to mask, ensure only those
            // items end up masked.
            if (unmaskedItems && unmaskedItems[item.getID()]) {
                item._hideDragMask();
            } else {
                item._showDragMask();
            }
        }
    }
},

// Hide event masks for all registered canvases, or the single event mask
// spanning the entire screen.
hideEventMasks : function () {
    var EH = this,
        maskedItems = EH._maskRegistry;

    if (EH._eventMask && EH._eventMask.isVisible()) {
        EH._eventMask.hide();
        if (isc.BrowserPlugin) {
            maskedItems.intersect(isc.BrowserPlugin.instances).map("_hideDragMask");
        }
    } else {
        for (var i = 0; i < maskedItems.length; i++) {
            maskedItems[i]._hideDragMask();
        }
    }
},


// Return true if the specified event should be handled by the native event mechanism rather
// than by our EventHandler mechanism.  Used to avoid interferance with native form event
// processing and other similar cases.

_handledNativelyReturnVal:isc.Browser.isIE ? isc.undef : true,
eventHandledNatively : function (eventType, nativeTarget, checkTargetOnly) {
    // If passed a native event name (standard behavior), convert the eventType to our ISC
    // eventType.
    // Note: if we fail to convert it, we will simply work with whatever we were passed as
    // an event type.
    var iscEventType = eventType;
    if (!this.reverseEventTypes[eventType]) {
        if (this._nativeMouseEventMap[eventType])
            iscEventType = this._nativeMouseEventMap[eventType];
        else if (this._nativeKeyEventMap[eventType])
            iscEventType = this._nativeKeyEventMap[eventType];
    }

    var returnValue = this._eventHandledNatively(iscEventType, nativeTarget, checkTargetOnly);
    if (returnValue && this.logIsDebugEnabled() && iscEventType != "mouseMove") {
        this.logDebug(eventType + " event on " +
                        (checkTargetOnly ? " native target:" + nativeTarget : this.lastTarget)
                        + " handled natively");
    }

    //if (eventType.indexOf("key") == 0) {
    //    isc.logWarn("Event type '" + eventType + "' with keyName '" + isc.EH.lastEvent.keyName + "' - handled natively: " + returnValue);
    //}

    return returnValue;
},

_$handleNativeEvents:"handleNativeEvents",
_$applet: "APPLET",
_eventHandledNatively : function (eventType, nativeTarget, checkTargetOnly) {
    //!DONTCOMBINE

    eventType = (eventType || "");


    var EH = this,
        event = EH.lastEvent;


    if (!EH._canAccessNativeTargetProperties(nativeTarget)) {
        //EH.logInfo("eventHandledNatively() can't get to event target properties." +
        //           "  Returning true");
        return true;
    }
    if (nativeTarget && nativeTarget.tagName == this._$applet) return true;


    // if there's no target canvas, the event did not occur over any ISC widgets...
    // don't interfere with event handling if it's a mouse event.  Return true

    var isMouseEvent = (EH.isMouseEvent(eventType)),
        iscTarget = isMouseEvent ? event.target : event.keyTarget;


    if (!checkTargetOnly && isMouseEvent && iscTarget == null) return true;

    //>DEBUG
    if ((this.logIsInfoEnabled() && eventType == EH.KEY_DOWN) ||
        (this.logIsDebugEnabled() && (eventType == EH.KEY_UP || eventType == EH.KEY_PRESS)))
    {
        this.logInfo(eventType + " event with Canvas target: " + this.lastEvent.keyTarget +
                     ", native target: " + this.echoLeaf(nativeTarget));
    }
    //<DEBUG
    // if it's a form element or an anchor, just return true so the event can be processed
    // automatically
    // NOTE: we may have an image (or something else) that is contained in an anchor,
    //         so we have to look through the list of parentElements for an anchor tag,
    //         we can't just look at the nativeTarget

    if (EH.passThroughEvents && nativeTarget) {


        //if (eventType.startsWith("key")) {
        //    this.logWarn("nativeTarget: " + this.echoDOM(nativeTarget));
        //}
        // testTarget will change to be successive parentElements of the nativeTarget
        //    until we get to the body tag
        var testTarget = nativeTarget,

            // isNative will be true if
            // - the target has been marked as handling native events, or
            // - we've found either a native form or anchor element, which is not a focusProxy
            handleNativeEvents = (testTarget.handleNativeEvents ||
                                    (testTarget.getAttribute ?
                                     testTarget.getAttribute(this._$handleNativeEvents) : null)),
            tagName = testTarget.tagName,
            isNative
        ;

        if (!EH._falseString) EH._falseString = "false";

        // If the 'handleNativeEvents' flag wasn't explicitly set, check for form items and
        // elements that will want to handle their own events.

        if (handleNativeEvents == null) {

            isNative = (!testTarget.focusProxy &&

                           ((testTarget.form != null && tagName != EH._labelString) ||

                            EH._formTags[tagName] != null ||
                            // editable DIVs (Not supported in Mozilla)

                            (testTarget.isContentEditable &&
                                !testTarget.getAttribute(this._$eventProxyAttributeName)))
                        );

            // if we didn't find a form, check if we're inside an anchor tag, because we want to
            // allow native processing (following the link).

            if (!isNative && (eventType != EH.MOUSE_WHEEL) && (eventType != EH.MOUSE_MOVE)) {
                while (testTarget &&
                        testTarget.tagName != EH.BODY_TAG && testTarget.tagName != this._$HTML)
                {
                    // Don't iterate up past any widget's handle - we don't expect canvii to be
                    // written out inside <A> tags

                    if (testTarget.eventProxy != null ||
                        (testTarget.hasAttribute != null &&
                         testTarget.hasAttribute(this._$eventProxyAttributeName))) break;

                    if (EH._anchorTags[testTarget.tagName] != null) {

                        var HNE = (testTarget.handleNativeEvents ||
                                    (testTarget.getAttribute ?
                                     testTarget.getAttribute(this._$handleNativeEvents) : null));

                        if (HNE != null && !isc.isA.emptyString(HNE)) {
                            if (isc.isA.String(HNE))
                                HNE = (HNE == isc.EH._falseString ? false : true);
                        }

                        if (HNE != false) {
                            isNative = true;
                            break;
                        }
                    }
                    testTarget = testTarget.parentNode;
                }
            }
        } else {

            // isNative derived directly from the "handleNativeEvents" property hung on the
            // DOM element.  This will be a string - convert "false" to false, so the check for
            //  if (isNative) {...
            // will do the right thing.
            isNative = handleNativeEvents;
            if (isNative == EH._falseString) isNative = false;
        }

        // if we found a native form or anchor element, return so we don't process the event
        // ourselves
        if (isNative) {
            return true;

        // if we had an explicit 'handleNativeEvents=false' specified on the target, avoid
        // further checking
        } else if (handleNativeEvents != null) {
            return false;
        }
    }

    // At this point we know that the event occurred on a canvas, and not over any of the
    // special elements that need native handling.
    //
    // if the event was a mouse-event in a CSS scrollbar let it be handled natively.
    if (!checkTargetOnly && isMouseEvent &&
        this._eventOverCSSScrollbar(iscTarget, eventType, event))
    {
        return true;
    }
    // return false so isc event processing continues
    return false;
},

// Is the event passed in a mouse event?
isMouseEvent : function (eventType, strict) {
    // This method is used by eventHandledNatively to determine whether the DOMevent it is
    // looking at is a mouse event.
    // As such the eventType passed in may be the native event name - which is all lowercase
    // rather than our camelCase event names.  Handle either case.

    eventType = eventType || this.lastEvent.eventType;

    // list of all mouse events, native and ISC names
    if (this._mouseEvents == null) {
        this._mouseEvents = {
            mouseOver:true, mouseover:true,
            mouseDown:true, mousedown:true, rightMouseDown:true,
            mouseMove:true, mousemove:true,
            mouseOut:true, mouseout:true,
            mouseUp:true, mouseup:true,

            DOMMouseScroll:true, mousewheel:true, mouseWheel:true,
            click:true,
            doubleClick:true, doubleclick:true,
            showContextMenu:true, showcontextmenu:true,
            selectStart:true, selectstart:true
        }
    }

    if (this._mouseEvents[eventType] == true) return true;

    // When differentiating mouse-events from keyboard events, touch and pointer events
    // qualify as "mouse" events

    if (!strict) {
        if (this.isPointerEvent(eventType)) return true;
        if (this.isTouchEvent(eventType)) return true;
        if (this.isNativeDragEvent(eventType)) return true;
    }
    // IE's selectionChanged event can be triggered by mouse or keyboard - this is the last event
    // we record when the user puts focus in a TextItem by mouse or keyboard.
    // Check for event.keyName having been recorded to determine if this was
    // Tab keypress or similar vs a mouse click
    if (eventType == "selectionChange") {
        return (this.lastEvent.keyName == null || this.lastEvent.keyName == "");
    }

    // context menu events can be mouse or keyboard triggered
    // We record a flag on the 'lastEvent' object as part of the handleContextMenu flow which
    // allows us to track this.
    if (eventType == "contextMenu" || eventType == "contextmenu") {
        return !this.lastEvent.keyboardContextMenu
    }
    // otherwise it's not a mouse event.
    return false;
},

_touchEventTypes: {
    touchstart: true,
    touchmove: true,
    touchend: true,
    touchcancel: true,
    touchStart: true,
    touchMove: true,
    touchEnd: true,
    touchCancel: true
},
isTouchEvent : function (eventType) {
    return (eventType in this._touchEventTypes);
},

_pointerEventTypes: {
    pointerdown: true,
    pointermove: true,
    pointerup: true,
    pointercancel: true,
    pointerDown: true,
    pointerMove: true,
    pointerUp: true,
    pointerCancel: true
},
isPointerEvent : function (eventType) {
    return (eventType in this._pointerEventTypes);
},

_nativeDragEventTypes: {
    dragStart: true,
    dragEnd: true,
    dragEnter: true,
    dragOver: true,
    dragLeave: true,
    dragstart: true,
    dragend: true,
    dragenter: true,
    dragover: true,
    dragleave: true,
    drop: true
},
isNativeDragEvent : function (eventType) {
    return (eventType in this._nativeDragEventTypes);
},


// Is the event passed in a key event?
isKeyEvent : function (eventType) {
    // This method is used by eventHandledNatively to determine whether the DOMevent it is
    // looking at is a key event.
    // As such the eventType passed in may be the native event name - which is all lowercase
    // rather than our camelCase event names.  Handle either case.

    eventType = eventType || this.lastEvent.eventType;

    if (this._keyEvents == null) {
        this._keyEvents = {};
        var ke = this._keyEvents;

        // ISC names:
        ke[this.KEY_DOWN] =true; ke[this.KEY_PRESS] = true; ke[this.KEY_UP] = true;

        // add native event names:
        var nativeMap = this._nativeKeyEventMap;
        for (var name in nativeMap) ke[name] = true;
    }

    if (this._keyEvents[eventType] == true) return true;

    if (eventType == "contextMenu" || eventType == "contextmenu") {
        return !!this.lastEvent.keyboardContextMenu
    }

    // otherwise it's not a key event.
    return false;
},

// Did the current mouse event occur over a native CSS scrollbar?
_eventOverCSSScrollbar : function (iscTarget, eventType, event) {


    if (isc.Browser.isTouch) return false;

    //this.logWarn("checking event over css scrollbar");
    var EH = this;


    // If there's no target or we're not showing native scrollbars, return false
    if (!iscTarget || iscTarget.showCustomScrollbars ||
        !(iscTarget.vscrollOn || iscTarget.hscrollOn)) return false;



    // if right to left, scrollbar on LEFT
    var scrollbarSize = isc.Element.getNativeScrollbarSize();
    if (iscTarget.isRTL()) {
        if ( (iscTarget.vscrollOn && (event.x < iscTarget.getPageLeft() + scrollbarSize) ) ||
             (iscTarget.hscrollOn && (event.y > iscTarget.getPageTop() +
                                  iscTarget.getHeight() - scrollbarSize) )
           )
        {
            if (eventType==EH.MOUSE_DOWN) EH._mouseIsDownInScrollbar = true;
            return true;
        }
    // else if left to right (normal), scrollbar on RIGHT
    } else {
        if ((iscTarget.vscrollOn && (event.x > iscTarget.getPageRight() - scrollbarSize)) ||
            (iscTarget.hscrollOn && (event.y > iscTarget.getPageBottom() - scrollbarSize)) )
        {
            if (eventType==EH.MOUSE_DOWN) EH._mouseIsDownInScrollbar = true;
            //this.logWarn(eventType + " in scrollbar");
            return true;
        }
    }

    return false;
},


//>    @classMethod    isc.EventHandler.bubbleEvent()    (A)
// Bubble the eventType in question up through the Canvas hierarchiy
//
//        @group    eventBubbling
//        @param    target        (object)    Canvas or DOM object that received the event
//        @param    eventType    (string)     name of this event
//        @param    eventInfo    (any)        information passed with a custom event (see e.g. Slider)
//      @param  [targetIsMasked] (boolean) If passed we have already tested whether this target
//                                         is masked, so don't re-check in this method
//
//        @return                (boolean)    false == cancel further event processing
//                                        anything else == continue processing
//      @visibility internal
//<

_dontLogBubble : {
    mouseMove : true,
    mouseOver : true,
    mouseOut : true
},

bubbleEvent : function (target, eventType, eventInfo, targetIsMasked, eventItem) {
    var EH = this,
        event = EH.lastEvent;

    //>DEBUG
    var logBubble = this.logIsDebugEnabled() && !this._dontLogBubble[eventType];
    //<DEBUG

    // check if this widget is masked, and, if a click on this widget would be cancelled, block
    // all mouse events from going to the target.  This prevents rollovers and other
    // indications of interactivity from appearing on components when in fact a click will do
    // nothing.
    //
    // Note that a mouseDown that dismisses a soft clickmask does so before reaching this
    // check.

    var isMouseEvent = this.isMouseEvent(eventType);
    if (isMouseEvent) {

        if (targetIsMasked == null) {

            targetIsMasked = this.targetIsMasked(target, null, true, eventItem);
        }
        if (targetIsMasked) {
            //>DEBUG
            if (logBubble) {
                this.logDebug(eventType + " on " + target + " blocked by clickmask");
            }
            //<DEBUG
            return false;
        }
    }

    // For each event, we check for the existance of the 'internal' handler function - named
    // 'handle' + eventType ("handleMouseDown", etc.).
    // If this is defined on the target, call that otherwise, if the event name itself is
    // defined, call that.
    // - Note: this means 'handleMouseDown' (etc.) as defined on the target widget is
    //   responsible for calling 'mouseDown'.
    var eventHandlerName = this._getInternalHandlerName(eventType);

    while (target != null) {
        // never fire an event for a destroyed widget
        if (target.destroyed) break;
        var nextTarget = null;
        var method = null;

        // go up the eventParent or parentElement chain, using an eventProxy if one is defined
        // NOTE: calculate the next target here, because parent hierarchy might change during
        // event handling (eg clear() self when tearing off from a Layout), but the former
        // parent should still receive the event that happened within it.

        // Allow only key events or only mouse events to be bubbled up the control heirarchy
        // by specifying keyEventParent or mouseEventParent respectively.
        if (target.mouseEventParent && (eventType.startsWith("mouse") || eventType == this.RIGHT_MOUSE_DOWN)) {
            nextTarget = target.mouseEventParent;
        } else if (target.keyEventParent && eventType.startsWith("key")) {
            nextTarget = target.keyEventParent;
        } else {
            nextTarget = (target.eventParent || target.parentElement);
        }
        if (nextTarget && nextTarget.eventProxy) nextTarget = nextTarget.eventProxy;

        // If target is in edit mode, use target.editProxy for the event if defined
        if (target.editingOn && target.editProxy) {
            var proxy = target.editProxy;

            if (proxy[eventHandlerName] != null) {
                method = eventHandlerName;
            } else if (proxy[eventType] != null && proxy[eventType] != isc.Class.NO_OP
                                            && !isc.is.emptyString(proxy[eventType])) {
                method = eventType;

                // if the eventType was defined as a string, convert it to a function
                if (isc.isA.String(proxy[eventType])) {
                    proxy.convertToMethod(eventType);
                }

                //>DEBUG
                if (logBubble) {
                    this.logDebug("Bubbling event '" + eventType + "', target '" + target +
                                  "' has handler: " + this.echoLeaf(proxy[eventType]));
                }
                //<DEBUG
            }

            // Using editProxy
            if (method) target = proxy;
        }

        if (!method) {
            if (target[eventHandlerName] != null) {
                method = eventHandlerName;
            } else if (target[eventType] != null && target[eventType] != isc.Class.NO_OP
                    && !isc.is.emptyString(target[eventType])) {
                method = eventType;


                // if the eventType was defined as a string, convert it to a function
                if (isc.isA.String(target[eventType])) {
                    target.convertToMethod(eventType);
                }

                //>DEBUG
                if (logBubble) {
                    this.logDebug("Bubbling event '" + eventType + "', target '" + target +
                            "' has handler: " + this.echoLeaf(target[eventType]));
                }
                //<DEBUG
            }
        }

        // if we have either a 'handleEvent' method or a straight 'event' method, fire it
        if (method != null && target[method] != null) {
            //this.logWarn(target + "[" + method + "]" + " is:" + target[method]);

            var result;
            //try {
                // now call the event handler, and if it returns false or cancels bubbling, bail
                if (method == "handleDrop" || method == "drop") {
                    // For backwards-compatibility, we only send drop() to an
                    // object if it returns "true" from willAcceptDrop(). We
                    // used to check for willAcceptDrop() before starting the
                    // bubble, so some code may assume that drop() will only be
                    // called if willAcceptDrop returned true.
                    var accept = target.willAcceptDrop();
                    if (accept) {
                        // If truthy, we do call drop(), then further bubbling depends on its return value.
                        result = target[method](event, eventInfo);
                    } else {
                        var originalTarget = target.isA("EditProxy") ? target.creator : target;
                        if (originalTarget) {
                            if (target.isA("EditProxy") && originalTarget == EH.dragTarget) {
                                // Attempt to drop component on self. This can only occur
                                // if the target of the drop should really be a parent.
                                // Allow bubble.
                                accept = null;
                            } else {

                                var altTarget = originalTarget.creator;
                                if (altTarget && altTarget.editingOn && altTarget.editProxy) {
                                    var altAccept = altTarget.editProxy.willAcceptDrop();
                                    if (altAccept || (altAccept == null)) {
                                        // If the alternative target would accept, or would allow bubbling,
                                        // then change the answer
                                        accept = altAccept;
                                    }
                                }
                            }
                        }

                        // Retest, since the answer may have changed
                        if (accept) {
                            // If truthy, we do call drop(), then further bubbling depends on its return value.
                            result = target[method](event, eventInfo);
                        } else if (accept == null) {
                            // If null, we don't call drop(), but we do bubble
                            result = true;
                        } else {
                            // If falsy but not null, we don't call drop(), and don't bubble (for back-compat)
                            result = false;
                        }
                    }
                } else {
                    result = target[method](event, eventInfo);
                }
            //} catch (e) {
            //    this.logWarn("error returned invoking event handler: " +
            //                 target.ID + "." + method + ": " + e.toString() + this.getStackTrace());
            //}

            if (result == false) {
                //>DEBUG
                if (logBubble) {
                    this.logDebug("Bubbling for event '" + eventType +
                                  "' cancelled via false return value by target: " + target);
                }
                //<DEBUG
                return false;
            }
            if (result == EH.STOP_BUBBLING) {
                //>DEBUG
                if (logBubble) {
                    this.logDebug("Bubbling for event '" + eventType +
                                  "' cancelled via STOP_BUBBLING return value by target: " + target);
                }
                //<DEBUG

                // Note: returning the stop-bubbling code, so callers of this method will see
                // the difference between
                // - events that returned false (typically return false to the DOM to cancel
                //   native propogation)
                // - events that stopped bubbling but didn't return false (return true to the
                //   DOM - allow native event handling to continue unhindered)
                // - events that made it all the way to the top of the object hierachy (may want
                //   to prevent further event processing / bubbling, but not cancel the event
                //   natively by returning false)

                return EH.STOP_BUBBLING;
            //} else {
            //    this.logDebug("Skipping " + target + ", no handler");
            }
        }


        if (target.bubbleEvents == false ||
            (target.bubbleMouseEvents == false && EH.isMouseEvent(eventType)))
        {
            //>DEBUG
            if (logBubble) {
                this.logDebug("Bubbling for event '" + eventType +
                              "' stopped by '" + target +
                              "' which does not allow bubbling");
            }
            //<DEBUG
            return true;
        } else if (isc.isAn.Array(target.bubbleMouseEvents)) {
            // target.bubbleMouseEvents is an array of event-names to suppress bubbling for
            if (target.bubbleMouseEvents.contains(eventType)) {
                //>DEBUG
                if (logBubble) {
                    this.logDebug("Bubbling for event '" + eventType +
                                  "' stopped by '" + target +
                                  "' which does not allow bubbling");
                }
                //<DEBUG
                return true;
            }
        }

        target = nextTarget;
    }

    // we got to the end and noone failed -- return true to keep propagating the event!
    //>DEBUG
    if (logBubble) this.logDebug("Event '" + eventType + "' bubbled to top");
    //<DEBUG
    return true;
},

//>    @classMethod    isc.EventHandler._getInternalHandlerName()    (A)
// For each event, return the name of the preferred handler function to be called
// by bubble handler.
// This consists of the event name (passed in) prefixed with 'handler', and with
// the first character converted to uppercase.
//
//        @group    eventBubbling
//        @param    event        (string)    Name of the event
//
//        @return            (string)    Name of preferred handler
//      @visibility internal
//<
_getInternalHandlerName : function (eventName) {

    if (!this._eventHandlerMap[eventName]) {
        this._eventHandlerMap[eventName] =
                        "handle" + eventName.charAt(0).toUpperCase() + eventName.substring(1);
//        isc.Log.logWarn("handler for eventType:" + eventName + " is " + this.eventHandlerMap[eventName]);
    }
    return this._eventHandlerMap[eventName];
},


// Determine whether a target canvas (or any of its parents up the event bubbling
// hierachy) have a handler defined for an event.
// Note: This means either having the event property itself defined, or 'handleEvent'
// defined.
hasEventHandler : function (target, event) {
    if (!isc.isAn.Object(target) || !isc.isA.String(event)) {
        isc.Log.logWarn(
            "EventHandler.hasEventHandler() passed bad parameters ["
                + [target, event] + "]. returning null;",
            "event"
        );
        return null;
    }
    var handlerName = this._getInternalHandlerName(event);
    if (this.getBubbledProperty(target, event, true, handlerName, true) != null) {
        return true;
    }
    return false;
},

// Return the value of a certain property for the target or, if not defined,
// for the first of the target's parents to define the property.
// When `expectingMethod' is true, then Class.NO_OP or an empty string are also considered to
// be "not defined".
getBubbledProperty : function (target, property, expectingMethod, property2, expectingMethod2) {
    while (target) {
        var val = target[property];
        if (val && (!expectingMethod || (val !== this.NO_OP &&
                                         !isc.isAn.emptyString(val))))
        {
            return val;
        }
        if (property2 != null) {
            val = target[property2];
            if (val && (!expectingMethod2 || (val !== this.NO_OP &&
                                              !isc.isAn.emptyString(val))))
            {
                return val;
            }
        }
        target = (target.eventParent || target.parentElement);
        if (target && target.eventProxy) target = target.eventProxy;
    }
    return null;
},


// handle the native "selectStart" event (IE specific)
// In general, we want to suppress selection of text on web pages as it conflicts
// with drag and drop (and looks bad on pages with absolute positioning stuff).

handleSelectStart : function () {

        var EH = isc.EH;

    //isc.Log.logDebug("handleSelectStart() triggered (handler for native onselectstart).");

    // In IE9, this event is fired when a selection occurs in response to a call to
    // programmatically select a block of text (as we do in FormItem.setSelectionRange())
    // In that case we want selection change to be allowed regardless of
    // event details such as the last mouseDown target.
    // We handle this by setting a flag to let us know we're explicitly selecting right now.
    if (EH._settingTextSelection) return true;

    // If the user is drag-selecting inside form items, allow selection to occur.
    // Don't allow selection to occur if the user is already performing an ISC recognized drag
    // and passes over a form item.

    var wd = EH.getWindow(),
        nativeTarget = wd.event ? wd.event.srcElement : null,
        mouseDownNativeTarget = EH.mouseDownEvent ? EH.mouseDownEvent.nativeTarget : null;

    if (nativeTarget && mouseDownNativeTarget == nativeTarget && nativeTarget.form
         && !EH.dragging)
    {
        return true;
    }



    // Allow text selection if
    // - theres no target / mouseDownTarget canvas (don't interfere with native selection)
    // - mouseDown target doesn't disallow text selection
    // - mouseMove target doesn't disallow text selection
    // - we're not performing a smartclient drag operation
    //
    // OnSelectStart is triggered from any type of selection (drag selection, shift+arrow
    // keys, programmatic selection).
    // If this is a drag-selection, we want to check the lastMouseDown target
    // If the mouse is not down this is not a drag selection - don't bother checking for
    // the last mouseDownTarget disallowing selection.
    // In this case getEventTargetCanvas(...) will still get us a pointer to the element
    // on which selection occurred from event.srcElement (set even though this may not be a
    // mouse event).

    if (isc.EH._allowTextSelection) return true;
    var mouseDownTarget = isc.EH.mouseIsDown() ? EH.mouseDownTarget() : null,
        target = EH.getEventTargetCanvas(wd.event);


    var dragging = (EH.dragging || EH.dragTarget) && EH.dragOperation != EH.DRAG_SELECT;
    var allowSelection = !dragging &&
                         (mouseDownTarget != null ?
                            mouseDownTarget._allowNativeTextSelection() : true) &&
                         (target != null ?
                            target._allowNativeTextSelection() : true);
    if (allowSelection) return true;
    return EH.killEvent();
},



// handle the 'onselectionchange' event.  This is an IE specific event.

_$selectionChange:"selectionChange",
handleSelectionChange : function (event) {

    if (!event) event = window.event;


        var EH = isc.EH;

    var lastEvent = EH.lastEvent;


    var nativeTarget = isc.Element._getElementFromSelection(document);
    if (nativeTarget) {
        // derive the target canvas from the target element

        var targetCanvas = EH.getEventTargetCanvas(event, nativeTarget);

        lastEvent.nativeKeyTarget = nativeTarget
        lastEvent.keyTarget = targetCanvas;
        lastEvent.eventType = this._$selectionChange;

        if (targetCanvas) {
            targetCanvas.keyTarget = targetCanvas;
            EH.bubbleEvent(lastEvent.keyTarget, "selectionChange");
        }
    }

    // We could return false here to cancel the selection change
    return true;
},

// native "onhelp" event - IE only
// This occurs when the user hits the f1 key and appears to be the only way to
// cancel the native help dialog in response to f1 keypress in IE
// Handle this event by firing a synthetic keyPress event, allowing the user to return false
// and suppress the native behavior

handleNativeHelp : function () {

    // call any native handler that we may have clobbered (manually for speed)

    if (this._documentOnHelp) {
        if (this._documentOnHelp() == false) return false;
    }
    if (this._windowOnHelp) {
        if (this._windowOnHelp() == false) return false;
    }

    // allow 'handleNativeKeyDown' to actually fire developer defined keyDown and keyPress
    // handlers, and if they return false, we'll return false here, killing the native onhelp
    // behavior.
    return isc.EH._handleNativeKeyDown(window.event, true);
},

//> @classMethod EventHandler.setDragTrackerImage()
// This API may be called to set the native HTML5 drag tracker image. The <code>x</code> and
// <code>y</code> parameters may be specified to affect the placement of the drag tracker image
// relative to the mouse cursor. The size of the drag tracker image is the intrinsic size of the
// image. Browsers may apply certain visual effects (such as a slight transparency) to this image.
// <p>
// Can only be called during the +link{Canvas.dragStart()} event (or methods called during the
// handling of that event).
// <p>
// <b>NOTES:</b>
// <ul>
// <li>Not supported in Opera 12.x or Safari.</li>
// <li>For best results, this image should be preloaded. Otherwise, the image might not appear
// for the first drag using this image.</li>
// <li>This API does not work in Chrome or Firefox on Windows 7 if the "Use visual styles on windows and buttons"
// setting is turned off.</li>
// </ul>
// @param src (SCImgURL) image source
// @param [x] (int) offset-x from the mouse cursor
// @param [y] (int) offset-y from the mouse cursor
// @group dragdrop
// @visibility external
//<

setDragTrackerImage : function (src, x, y) {
    var lastEvent = this.lastEvent,
        lastDOMevent,
        dt;
    if (!isc.Browser.hasNativeDrag ||
        lastEvent == null ||
        (lastDOMevent = lastEvent.DOMevent) == null ||
        (dt = lastDOMevent.dataTransfer) == null ||
        dt.setDragImage == null ||
        lastDOMevent.type != this._$dragstart ||
        !this.dragTarget)
    {
        return;
    }


    if (isc.Browser.isSafari && !isc.Browser.isChrome) return;

    var imgElem = document.createElement("img");
    imgElem.src = this.dragTarget.getImgURL(src == null ? isc.Canvas._blankImgURL : src);



    x = x << 0;
    y = y << 0;

    dt.setDragImage(imgElem, x, y);
},


_$encodedDragTypePrefix: "application/x-isc-dragtype",
_currentDragTypeEncodingSchemeVersion: 0,
encodeDragType : function (dragType) {
    if (!dragType) return this._$encodedDragTypePrefix + this._currentDragTypeEncodingSchemeVersion.toString(36);

    var sb = isc.SB.create(),
        lastPos = 0,
        len;
    sb.append(this._$encodedDragTypePrefix, this._currentDragTypeEncodingSchemeVersion.toString(36));
    for (var i = 0, len = dragType.length; i < len; ) {
        var hi = dragType.charCodeAt(i++),
            codePoint = hi,
            startI = i;
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
        if (0xD800 <= hi && hi <= 0xDBFF) {
            var low = dragType.charCodeAt(i++);
            codePoint = ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
        }

        // http://www.unicode.org/charts/PDF/U0000.pdf
        if ((0x30 <= codePoint && codePoint <= 0x39) ||
            (0x61 <= codePoint && codePoint <= 0x7A))
        {
            continue;
        }

        sb.append(dragType.substring(lastPos, startI - 1), '_', codePoint.toString(16), '_');
        lastPos = i;
    }
    sb.append(dragType.substring(lastPos, len));
    return sb.release(false);
},

_$utiPrefix: "dyn.a",
_utiLUT: {
    "a":  0, "b":  1, "c":  2, "d":  3, "e":  4,
    "f":  5, "g":  6, "h":  7, "k":  8, "m":  9,
    "n": 10, "p": 11, "q": 12, "r": 13, "s": 14,
    "t": 15, "u": 16, "v": 17, "w": 18, "x": 19,
    "y": 20, "z": 21, "0": 22, "1": 23, "2": 24,
    "3": 25, "4": 26, "5": 27, "6": 28, "7": 29,
    "8": 30, "9": 31
},
decodeDragDataItemTypeString : function (typeStr) {
    if (!typeStr) return null;
    typeStr = typeStr.toLowerCase();


    if (typeStr.startsWith(this._$utiPrefix)) {
        var lookupTable = this._utiLUT,
            outputCharCodes = [];
        // Each char of the base32-encoded string provides 5 bits of data.
        var numBits = 0,
            bits = 0;
        for (var i = this._$utiPrefix.length; i < typeStr.length; ++i) {
            var val = lookupTable[typeStr[i]];
            val <<= 3;
            bits |= val >>> numBits;
            numBits += 5;
            if (numBits >= 8) {
                outputCharCodes.add(bits & 255);
                numBits -= 8;
                if (numBits > 0) bits = (val << (5 - numBits)) & 255;
                else bits = 0;
            }
        }

        typeStr = String.fromCharCode.apply(String, outputCharCodes);
        var startPos = typeStr.indexOf(this._$encodedDragTypePrefix);
        if (startPos < 0) return null;
        var endPos = typeStr.indexOf(':', startPos + this._$encodedDragTypePrefix.length);
        if (endPos < 0) endPos = typeStr.length;
        typeStr = typeStr.substring(startPos, endPos);

    } else if (!typeStr.startsWith(this._$encodedDragTypePrefix)) {
        return null;
    }

    var str = typeStr.substring(this._$encodedDragTypePrefix.length),
        encodingSchemeVersion;
    if (// Empty string (no version)
        !str ||
        // or version too new
        (encodingSchemeVersion = parseInt(str[0], 36)) > this._currentDragTypeEncodingSchemeVersion)
    {
        return null;
    }

    var sb = isc.SB.create();
    if (0 == encodingSchemeVersion) {
        var lastPos = 0;
        for (var pos = str.indexOf('_'); pos >= 0; pos = str.indexOf('_', lastPos + 1)) {
            sb.append(str.substring(lastPos + 1, pos));
            lastPos = str.indexOf('_', pos + 1);
            if (lastPos < 0) return null;
            var codePoint = parseInt(str.substring(pos + 1), 16);
            if (isNaN(codePoint)) continue;
            if (codePoint >= 0x10000) {
                // http://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B10000_to_U.2B10FFFF
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode
                var d = codePoint - 0x10000,
                    hi = (d >> 10) + 0xD800,
                    low = (d & 0x3FF) + 0xDC00;
                sb.append(String.fromCharCode(hi, low));
            } else {
                if (0xD800 <= codePoint && codePoint <= 0xDFFF) return null;

                sb.append(String.fromCharCode(codePoint));
            }
        }
        sb.append(str.substring(lastPos + 1));
    }
    return sb.release(false);
},

_getEncodedDragType : function (dt) {
    var types;
    if (dt == null || (types = dt.types) == null) return null;

    var len = types.length;
    for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type && type.startsWith(this._$encodedDragTypePrefix)) {
            return type;
        }
    }

    // Look for UTIs
    for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type && type.startsWith(this._$utiPrefix)) {
            // Need to check that this UTI encodes a drag type.
            var dragType = this.decodeDragDataItemTypeString(type);
            if (dragType != null) return type;
        }
    }

    return null;
},

_getDragType : function (dt) {
    var type = this._getEncodedDragType(dt);
    if (type == null) return null;
    return this.decodeDragDataItemTypeString(type);
},

//> @classMethod EventHandler.getNativeDragData()
// For a cross-frame drag, retrieves the data made available when the drag was initiated in the
// foreign frame via +link{EventHandler.setNativeDragData()}.
// <p>
// Can only be called during the +link{Canvas.drop} event (or methods called during the handling
// of that event, such as +link{ListGrid.recordDrop}); will return null if called at any other
// time, or if called during a non-HTML5 drag and drop.
// @return (Object) data made available in the foreign frame
// @visibility external
//<
_$drop: "drop",
getNativeDragData : function () {
    var lastEvent = this.lastEvent,
        lastDOMevent;
    if (!isc.Browser.hasNativeDrag ||
        lastEvent == null ||
        (lastDOMevent = lastEvent.DOMevent) == null ||
        lastDOMevent.dataTransfer == null ||
        lastDOMevent.type != this._$drop)
    {
        return null;
    }

    var dt = lastDOMevent.dataTransfer,
        encodedDragData;
    if (isc.Browser.isIE || isc.Browser.isEdge) {
        encodedDragData = dt.getData("Text");
    } else {
        var type = this._getEncodedDragType(dt);
        if (type == null) return null;
        encodedDragData = dt.getData(type);
    }

    var dragData = null;

    try {
        if (encodedDragData != null) dragData = isc.JSON.decode(encodedDragData);
    } catch (e) {
        this.logWarn("Failed to decode as JSON: " + e);
    }

    return dragData == null ? null : dragData.data;
},

//> @classMethod EventHandler.setNativeDragData()
// Sets the data available in a cross-frame HTML5 drag (see +link{Canvas.useNativeDrag}).
// <p>
// Data provided to this method must be valid for serialization to JSON via the
// +link{JSONEncoder}, or can simply be a String.
// <p>
// Can only be called during the +link{Canvas.dragStart()} event (or methods called during the
// handling of that event).
// <p>
// Do not pass in sensitive data (e.g. passwords, auth/session tokens, credit card numbers, SSNs, etc.).
// @param data (Object | String) data to make available to foreign frames
// @param [strData] (String) text data to set. This is the text that users may see if the drag
// is dropped into an external application such as Notepad or a non-Smart&#67;lient/Smart&nbsp;GWT
// web application.
// @visibility external
//<
_dragDataEncodeSettings: {
    dateFormat: "xmlSchema",
    prettyPrint: false,
    skipInternalProperties: true,
    strictQuoting: true
},
_$dragstart: "dragstart",
setNativeDragData : function (data, strData, dragType) {
    var lastEvent = this.lastEvent,
        lastDOMevent;
    if (!isc.Browser.hasNativeDrag ||
        lastEvent == null ||
        (lastDOMevent = lastEvent.DOMevent) == null ||
        lastDOMevent.dataTransfer == null ||
        lastDOMevent.type != this._$dragstart ||
        !this.dragTarget)
    {
        return;
    }

    if (dragType == null) dragType = this.dragTarget.dragType;

    if (isc._windowUUID == null) isc._windowUUID = isc.Math.randomUUID();
    var dragData = {
        iscVersion: isc.version,
        iscVersionNumber: isc.versionNumber,
        windowUUID: isc._windowUUID,
        dragType: dragType,
        data: data
    };
    var encodedDragData = isc.JSON.encode(dragData, this._dragDataEncodeSettings);

    var dt = lastEvent.DOMevent.dataTransfer;

    // IE only supports "Text" and "URL" data types:
    // http://msdn.microsoft.com/en-us/library/ie/ms536744.aspx
    if (isc.Browser.isIE || isc.Browser.isEdge) {
        dt.setData("Text", encodedDragData);

    } else {
        dt.setData(this.encodeDragType(dragType), encodedDragData);
        if (strData == null || (strData = String(strData).trim()).length == 0) strData = "\u00A0";
        dt.setData("Text", strData);
    }
},

_effectAllowedMap: {
    "none": "none",
    "copy": "copy",
    "copyLink": "copyLink",
    "copylink": "copyLink",
    "copyMove": "copyMove",
    "copymove": "copyMove",
    "link": "link",
    "linkMove": "linkMove",
    "linkmove": "linkMove",
    "move": "move",
    "all": "all",
    "uninitialized": "uninitialized"
},

// native ondragstart
// the ondragstart event happens if you try to drag some selected text or an image - it allows
// you to drop the selected text into any text editor, or save the image to the desktop.  If we
// don't cancel the event, IE takes over the drag, modifies the cursor and stops sending
// mouseMove.

handleNativeDragStart : function (DOMevent) {
    // Check if the widget has useNativeDrag:true.
    if (isc.Browser.hasNativeDrag && DOMevent.dataTransfer) {
        var EH = isc.EH,
            dt = DOMevent.dataTransfer,
            event = EH.getMouseEventProperties(DOMevent),
            target = event.target;
        if (target != null && (target = target._getNativeDragTarget()) != null) {
            event.target = target;


            if (!target.useNativeDrag) return false;

            if (isc.Browser.isIE) {
                if (target.dragType == null) {
                    this.logWarn("No dragType string is set on " + target.getID() + ". Canceling native drag...");
                    return false;
                }

                var crossFrameDrag = isc.Canvas.getCrossFrameDragByDragType && isc.Canvas.getCrossFrameDragByDragType(target.dragType);
                if (crossFrameDrag == null) {
                    this.logWarn("No cross-frame drag settings have been registered for dragType:'" +
                                 target.dragType + "'. Canvas.registerCrossFrameDrags() must be " +
                                 "called to register cross-frame drag settings for this dragType. " +
                                 "Canceling native drag...");
                    return false;
                }

                dt.effectAllowed = EH._effectAllowedMap[crossFrameDrag.effectAllowed];
            } else {
                dt.effectAllowed = "copy";
            }

            // Set null drag data by default because Firefox 22.0 cancels the drag if no data
            // is set on 'dragstart'.
            if (!(isc.isA.DataBoundComponent && isc.isA.DataBoundComponent(target))) {
                EH.setNativeDragData(null, null, target.dragType);

            } else {
                EH.setNativeDragData(target.cloneDragData(), null, target.dragType);
            }

            EH.dragTarget = target;
            EH.dragOperation = "drag";
            var returnVal = EH.handleDragStart(true);
            EH.handleDragMove();
            return returnVal;
        }
    }

    // If an ISC drag is occurring, return false to suppress the native drag so we can
    // continue to get mouse-moves and respond to the drag.
    if (isc.EH.dragTarget) return false;


    var target = isc.EH.mouseDownTarget();

    // if within a Canvas, allow the drag if you can select text within the Canvas.
    // This will allow the user to drag out a selected chunk of text to a text editor, etc.
    // This setting also allows some other native drag behaviors, such as dragging selected text from
    // a TextItem, which allows a native drop-copy into a target (another TextItem, the URL bar, etc)

    if (target) return !!(target._allowNativeTextSelection());

    // call any native handler that we may have clobbered (manually for speed)
    if (this._documentDragStart) return this._documentDragStart();
    if (this._windowDragStart) return this._windowDragStart();


},


_useCrossFrameDragCleanupTimer: isc.Browser.isMoz && isc.Browser.version < 10,

_crossFrameDragCleanupDelayMillis: 600,
_setCrossFrameDragCleanupTimer : function () {
    var EH = this;
    if (EH._crossFrameDragCleanupTmrID != null) isc.Timer.clear(EH._crossFrameDragCleanupTmrID);
    EH._crossFrameDragCleanupTmrID = isc.Timer.setTimeout(EH._crossFrameDragCleanupAction, EH._crossFrameDragCleanupDelayMillis);
},
_crossFrameDragCleanupAction : function () {
    var EH = isc.EH;
    delete EH._crossFrameDragCleanupTmrID;
    if (EH.crossFrameDragging) {
        EH.artificialDragTarget.dragType = null;

        EH._handleNativeDragEnd(EH.lastEvent.DOMevent);
    } else if (EH.nativeDragging) {
        if (EH.dragMoveTarget) EH.dragMoveTarget.hide();
    }
},

_dropEffectsByEffectAllowed: {
    "none": "none",
    "copy": "copy",
    "copyLink": "copy",
    "copylink": "copy",
    "copyMove": "copy",
    "copymove": "copy",
    "all": "copy",
    "link": "link",
    "linkMove": "link",
    "linkmove": "link",
    "move": "move"
},
_$none: "none",
_handleNativeDragOver : function (DOMevent) {

    var dt = DOMevent.dataTransfer,
        initialDropEffect = dt.dropEffect,
        EH = isc.EH;



    var effectAllowed;


    if (isc.Browser.isIE) {
        try {
            effectAllowed = EH._effectAllowedMap[dt.effectAllowed];
        } catch (e) {
            effectAllowed = initialDropEffect;
        }
    } else {
        effectAllowed = dt.effectAllowed;
    }

    // This might be a cross-frame drag.
    if (!EH.nativeDragging) {
        var dragType = null;

        if (isc.Browser.isIE) {
            // Look up the cross-frame drag settings corresponding to the current effectAllowed
            // value.
            var crossFrameDrag = isc.Canvas.getCrossFrameDragByEffectAllowed(effectAllowed);

            // If no cross-frame drag is registered (see Canvas.registerCrossFrameDrags()), then
            // we don't know about this, so leave dropEffect set to "none" and return. By not
            // returning false here, the browser won't allow a drop in the application.
            if (crossFrameDrag == null) {
                return;
            }

            dragType = crossFrameDrag.dragType;

        } else {
            dragType = this._getDragType(dt);
            if (dragType == null) return;
        }

        // At this point we either obtained the dragType from the cross-frame drag settings or
        // recognize one of the drag data types as one of our special encoded type strings.

        // Initialize the dropEffect to "none".
        dt.dropEffect = EH._$none;

        // Create an artificial dragTarget.
        if (EH.artificialDragTarget) EH.artificialDragTarget.destroy();
        // faux createAutoChild
        var artificialDragTargetConstructor = EH.artificialDragTargetConstructor || EH.artificialDragTargetDefaults._constructor;
        EH.dragTarget = EH.artificialDragTarget = isc[artificialDragTargetConstructor].create(
            {
                autoDraw: false,
                _generated: true
            }, EH.artificialDragTargetDefaults, EH.artificialDragTargetProperties, {
                left: DOMevent.pageX,
                top: DOMevent.pageY,
                dragType: dragType
            }
        );

        var event = EH.getMouseEventProperties(DOMevent);
        event.target = EH.dragTarget;

        EH.dragOperation = "drag";
        EH._mouseIsDown = true;
        EH.mouseDownEvent = isc.addProperties({}, event);
        EH.handleDragStart(true);
        EH.crossFrameDragging = true;


        if (EH._useCrossFrameDragCleanupTimer) EH._setCrossFrameDragCleanupTimer();
    } else {
        if (EH._useCrossFrameDragCleanupTimer) EH._setCrossFrameDragCleanupTimer();

        // If a native drag is in progress, initialize the dropEffect to "none".
        dt.dropEffect = EH._$none;


        var lastEvent = EH.lastEvent;
        if (lastEvent != null &&
            lastEvent.screenX == DOMevent.screenX &&
            lastEvent.screenY == DOMevent.screenY)
        {
            if (lastEvent._lastDragOverReturnVal === false) {
                dt.dropEffect = EH._dropEffectsByEffectAllowed[effectAllowed];
            }
            return lastEvent._lastDragOverReturnVal;
        }
    }

    EH.handleMouseMove(DOMevent);


    var returnVal,
        dropTarget = EH.dropTarget;
    if (dropTarget && dropTarget.canAcceptDrop) {

        var altTarget = dropTarget.creator;
        if ((dropTarget.editingOn && dropTarget.editProxy && dropTarget.editProxy.willAcceptDrop()) ||
            (altTarget && altTarget.editingOn && altTarget.editProxy && altTarget.editProxy.willAcceptDrop()) ||
            dropTarget.willAcceptDrop())
        {
            returnVal = false;
            dt.dropEffect = EH._dropEffectsByEffectAllowed[effectAllowed];
        }
    }
    EH.lastEvent._lastDragOverReturnVal = returnVal;
    return returnVal;

},

_handleNativeDragEnter : function (DOMevent) {

    var EH = isc.EH;


    EH._lastDragEnterTarget = (DOMevent.srcElement || DOMevent.target);


    if (isc.Browser.isIE) {
        EH.handleMouseMove(DOMevent);


        var dropTarget = EH.dropTarget,
            returnVal;
        if (dropTarget && dropTarget.canAcceptDrop) {

            var altTarget = dropTarget.creator;
            if ((dropTarget.editingOn && dropTarget.editProxy && dropTarget.editProxy.willAcceptDrop()) ||
                (altTarget && altTarget.editingOn && altTarget.editProxy && altTarget.editProxy.willAcceptDrop()) ||
                dropTarget.willAcceptDrop())
            {
                if (DOMevent.preventDefault) DOMevent.preventDefault();
                returnVal = false;
            }
        }
        EH.lastEvent._lastDragOverReturnVal = returnVal;
        return returnVal;
    }
},

_handleNativeDragLeave : function (DOMevent) {

    var EH = isc.EH;

    if (EH._lastDragEnterTarget == (DOMevent.srcElement || DOMevent.target)) {
        EH._lastDragEnterTarget = null;

        if (!EH._useCrossFrameDragCleanupTimer) {
            if (EH.crossFrameDragging) {

                EH.artificialDragTarget.dragType = null;

                EH._handleNativeDragEnd(DOMevent);
            } else if (EH.nativeDragging) {
                if (EH.dragMoveTarget) EH.dragMoveTarget.hide();
            }
        }
    }
},

_handleNativeDragEnd : function (DOMevent) {

    var EH = isc.EH;
    EH.handleMouseUp(DOMevent);
},

_handleNativeDrop : function (DOMevent) {
    var EH = isc.EH,
        wasNativeDragging = EH.nativeDragging;
    EH.handleMouseUp(DOMevent);
    // Only return false if EH.nativeDragging was true. Otherwise, returning false here might disable
    // a drag and drop of files (for example, onto a file input).
    if (wasNativeDragging) return false;
},


_handleTransitionEnd : function (DOMevent) {
    var EH = isc.EH;

    var eventInfo = {
        DOMevent: DOMevent,
        eventType: EH.TRANSITION_END,
        nativeTarget: DOMevent.target,
        propertyName: DOMevent.propertyName,
        prefixedPropertyName: DOMevent.propertyName,
        elapsedTime: DOMevent.elapsedTime
    };
    if (DOMevent.propertyName != null && DOMevent.propertyName.startsWith(isc.Element.vendorCSSPrefix)) {
        eventInfo.propertyName = DOMevent.propertyName.substring(isc.Element.vendorCSSPrefix.length);
    }
    var target = eventInfo.target = EH.getEventTargetCanvas(DOMevent, eventInfo.nativeTarget, eventInfo);
    return EH.handleEvent(target, EH.TRANSITION_END, eventInfo);
},


// Handle a page-level resize event.
handleResize : function (DOMevent) {
    //Log.logWarn("page-level resize event");
    // delay briefly to avoid getting flooded by page-level resize events during drag resize on
    // Windows IE
    if (isc.EH.resizeTimer == null) {
        isc.EH.resizeTimer = isc.Timer.setTimeout("isc.EH._pageResize()", 0);
    }
    // Always return true. This will allow any 'window.onresize' handlers set up before
    // ISC was loaded to fire.

    return true;
},

// Fired when the user rotates a mobile device:
// Safari / iPhone and iPad only

handleOrientationChange : function (DOMEvent) {
    this._fireResizeEvent();
},


_pageResizePollMethod : function () { isc.EH._pageResize(true); },

// Note the "polling" param indicates that this method is not called from a native browser resize
// event - it either comes from the polling code if isc.Page.pollPageSize is true, or from some other
// case where we want to verify that the size hasn't changed.
// If this parameter is passed and the page size is not changed, this method will no-op
_pageResize : function (polling) {
    isc.EH.resizeTimer = null;
    var orientation = isc.Page.getOrientation();
    // !polling implies this came from a real resize event and the size has changed
    if (!polling) {
        // This both records the reported width, and ensures that it's up to date.
        this._previousInnerWidth = isc.Page.getWidth(window, true);
        this._previousInnerHeight = isc.Page.getHeight(window, true);

        if (this.resizingPollTimer != null) isc.Timer.clearTimeout(this.resizingPollTimer);
        this.resizingPollTimer = isc.Timer.setTimeout(this._pageResizePollMethod, 100);

    } else {
        // We want to force a recalculation of width / height here.
        // If the value has changed, re-run the resized handler to resize children etc.
        var newWidth = isc.Page.getWidth(window, true),
            newHeight = isc.Page.getHeight(window, true),
            unchanged = (orientation ==  this.currentOrientation) &&
                        (newWidth == this._previousInnerWidth &&
                         newHeight == this._previousInnerHeight)

        // If we're polling for content changes that introduce / hide scrollbars,
        // re-run this method on every idle
        if (isc.Page.pollPageSize) {
            isc.Page.setEvent(isc.EH.IDLE, this._pageResizePollMethod, isc.Page.FIRE_ONCE);
        }
        // Don't actually fire the handler if there was no resize
        if (unchanged) return;

        // record the size so we can no-op next time this method is run
        this._previousInnerWidth = newWidth;
        this._previousInnerHeight = newHeight;
    }
    this._fireResizeEvent(orientation);
},

currentOrientation:isc.Page.getOrientation(),
_currentWidth:isc.Page.getWidth(),


_fireResizeEvent : function (orientation) {
    isc.Page.handleEvent(null, isc.EH.RESIZE);

    var width = isc.Page.getWidth();
    if (width == this._currentWidth) return;

    // Fire orientationChange event from resize event rather only on the native
    // onOrientationChange - this means we can fire it
    // on a desktop browser if the user drags from a portrait type sizing to a landscape
    // type sizing

    if (orientation == null) orientation = isc.Page.getOrientation();
    if (orientation != this.currentOrientation) {
        this._currentWidth = width;
        this.currentOrientation = orientation;
        isc.Page.handleEvent(null, isc.EH.ORIENTATION_CHANGE);
    }
},

// handle a native "mousewheel" event, currently only available in IE6 and above, and Mozilla

handleMouseWheel : function (DOMevent) {

        var EH = isc.EH;
    if (!DOMevent) DOMevent = EH.getWindow().event;
    var nativeTarget = (DOMevent.srcElement || DOMevent.target);
    if (EH.eventHandledNatively(DOMevent.type, nativeTarget)) return EH._handledNativelyReturnVal;

    EH.getMouseEventProperties(DOMevent);

    // Pass to the appropriate widget, and stop if this returns false.
    var target = EH.lastEvent.target;
    var returnValue;
    if (EH.targetIsEnabled(target)) {
        returnValue = EH.bubbleEvent(target, EH.eventTypes.MOUSE_WHEEL);
    }

    if (returnValue == false) {

        if (DOMevent.preventDefault) DOMevent.preventDefault();
        return false;
    }
    // Return true to avoid interfering with native events
    return true;
},

//> @classMethod EventHandler.getWheelDelta()
// Applies to +link{canvas.mouseWheel(),mouseWheel} events only.
// Returns a numeric value indicating how far the mouse wheel was rotated. This value will be
// positive if the user scrolled the mousewheel forward or up, or negative if scrolled in the
// other direction. For a standard wheel-mouse, an increment of 1 relates to the smallest
// possible rotation of the mouse wheel. For other scrolling devices, such as scroll
// gestures on a track pad, wheel delta may be reported in finer grained increments
// (causing this method to return a fractional value).
// <P>
// Note that behavior for trackpad scroll-gestures may differ by browser, but where
// separate vertical and horizontal scroll information is available, this method
// refers to a vertical scroll gesture.
// <P>
// Developers should also be aware
// that some browsers and operating systems allow the user to configure the sensitivity
// of the mouse wheel or trackpad, which may change this value.
//
// @deprecated in favor of +link{EventHandler.getWheelDeltaY()}
// @return (float) numeric value indicating how far the mouse wheel was rotated.
// @visibility external
//<
// canvas.scrollWheelDelta is currently not exposed - we may want to interlink docs with
// that attribute if it becomes exposed.
getWheelDelta : function (event) {
    return (event || this.lastEvent).wheelDelta;
},

//> @classMethod EventHandler.getWheelDeltaX()
// Horizontal scroll delta reported by a +link{canvas.mouseWheel(),mouseWheel} event
// (such as a horizontal swipe on a track-pad).
// <P>
// Returns a numeric value indicating how far the mouse wheel was rotated / the magnitude
// of the scroll gesture. This value will be
// positive if the user scrolled the mousewheel to the right, negative if scrolled in the
// other direction.
//
// @see EventHandler.getWheelDeltaY()
// @return (float) numeric value indicating how far the mouse wheel was rotated.
// @visibility external
//<
// canvas.scrollWheelDelta is currently not exposed - we may want to interlink docs with
// that attribute if it becomes exposed.
getWheelDeltaX : function (event) {
    return (event || this.lastEvent).wheelDeltaX;
},

//> @classMethod EventHandler.getWheelDeltaY()
// Applies to +link{canvas.mouseWheel(),mouseWheel} events only.
// Returns a numeric value indicating how far the mouse wheel was rotated. This value will be
// positive if the user scrolled the mousewheel forward or up, or negative if scrolled in the
// other direction. For a standard wheel-mouse, an increment of 1 relates to the smallest
// possible rotation of the mouse wheel. For other scrolling devices, such as scroll
// gestures on a track pad, wheel delta may be reported in finer grained increments
// (causing this method to return a fractional value).
// <P>
// Note that behavior for trackpad scroll-gestures may differ by browser, but where
// separate vertical and horizontal scroll information is available, this method
// refers to a vertical scroll gesture.
// <P>
// Developers should also be aware
// that some browsers and operating systems allow the user to configure the sensitivity
// of the mouse wheel or trackpad, which may change this value.
//
// @see EventHandler.getWheelDeltaX()
// @return (float) numeric value indicating how far the mouse wheel was rotated.
// @visibility external
//<
// canvas.scrollWheelDelta is currently not exposed - we may want to interlink docs with
// that attribute if it becomes exposed.
getWheelDeltaY : function (event) {
    return (event || this.lastEvent).wheelDeltaY;
},


// Handle a "DOMMouseScroll" event
// This is the event Mozilla fires when the user spins the mouse scroll wheel.
// Fall through to the standard handleMouseWheel functionality, which will pick up the details
// for the event and cancel native behavior if appropriate

handleDOMMouseScroll : function (e) {
    return isc.EH.handleMouseWheel(e);
},

// Handle a scroll event
handleScroll : function (DOMevent) {

    //window.status = 'handleScroll ' + timeStamp();
    //return (EH.handleEvent(EH.getEventTargetCanvas(DOMevent), "_handleCSSScroll") != false);
},



prepareForLinkDrag : function (dragTarget, linkID) {
    this.dragTarget = (isc.isA.String(dragTarget) ?
                       this.getWindow()[dragTarget] : dragTarget);
    this.dragTargetLink = linkID;
    return false;
},


// Drag Tracker
// ----------------------------------------------------------------------------------------

//>    @classMethod EventHandler.setDragTracker()
// Set the HTML for the drag tracker that follows the mouse during a drag and drop interaction.
// <P>
// Your canvas can use this routine to set the drag tracker to whatever HTML you want like so:
// <pre>
//    dragStart : function () {
//        isc.EventHandler.setDragTracker('Your contents here');
//    }
// </pre>
//
// @param html (string) HTML for the tracker
// @param [newWidth] (int) new width for the tracker.  Default value: 10
// @param [newHeight] (int) new height for the tracker.  Default value: 10
// @param [offsetX] (int) x-offset for the tracker
// @param [offsetY] (int) y-offset for the tracker
// @param [properties] (Canvas Properties) properties to configure the dragTracker
// @group dragdrop, dragTracker
// @visibility external
//<

setDragTracker : function (html, newWidth, newHeight, offsetX, offsetY, properties) {
    var dragTracker = this._makeDragTracker(properties);

    // set size (or reset to small size if it was previously set larger)
    newWidth = newWidth || 10;
    newHeight = newHeight || 10;
    dragTracker.resizeTo(newWidth, newHeight);

    // update contents
    dragTracker.setContents(html);

    // redraw right away for responsiveness
    dragTracker.redrawIfDirty("setDragTracker");

    // apply drag offset if specified
    if (offsetX) dragTracker.offsetX = offsetX;
    if (offsetY) dragTracker.offsetY = offsetY;

    // we don't want these new settings to stick globally - require the user to call
    // setDragTracker() every time they want to deviate from the defaults only.  Otherwise any
    // single instance of deviation from defaults would require a setDragTracker() on all other
    // DnD interactions on the page simply to reset back to defaults.
    dragTracker._isCustomized = true;
},


// Create the 'drag tracker' -- a canvas that follows the mouse to indicate
// that something is being dragged.  See  isc.EventHandler.setDragTracker() for
// details on how to customize the tracker.
_makeDragTracker : function (overrides) {
    if (!this.dragTracker) {
        var defaults = this.dragTrackerDefaults;
        // set default contents just to make sure the drag tracker is visible if you enable it
        // but neglect to set contents.  NOTE that it's not expected that anyone would actually
        // use a black square and the contents are never restored to a black square.  NOTE also
        // that we don't want to use a background color which would bleed through transparent
        // images.
        defaults.contents = isc.Canvas.imgHTML("[SKIN]black.gif",10,10);
        this.dragTracker = isc.Canvas.create(defaults, overrides);
    } else if (overrides != null) this.dragTracker.setProperties(overrides);
    return this.dragTracker;
},

// Get a Canvas that draws an outline, whose initial size and position matches the Canvas
// passed as an argument.
getDragOutline : function (target, outlineSize, outlineColor) {

    if (!this.dragOutline) {
        this.dragOutline = isc.Canvas.create({
            autoDraw:false,
            overflow:isc.Canvas.HIDDEN,
            // hide using display:none so it doesn't
            // impact the scroll size of the page as a whole when hidden
            hideUsingDisplayNone:true
        })

        if (isc.Browser.isIE) this.dragOutline.setContents(isc.Canvas.spacerHTML(3200, 2400));
    }

    var outline = this.dragOutline;
    if (isc.Element.getStyleDeclaration(target.dragOutlineStyle)) {
        outline.setStyleName(target.dragOutlineStyle);
    } else {
        outline.setBorder((outlineSize || 1) + "px solid " + (outlineColor || "black"));
    }

    // size the outline so it matches the object being resized
    outline.setPageRect(target.getPageLeft(), target.getPageTop(),
                        target.getVisibleWidth(), target.getVisibleHeight());

    // if this outline will be used for a resize, the min and max sizes of the outline need to
    // match the object being resized
    outline.minWidth  = target.getDragMinWidth();
    outline.minHeight = target.getDragMinHeight();
    outline.maxWidth  = target.getDragMaxWidth();
    outline.maxHeight = target.getDragMaxHeight();


    // if the target wants to stay within its parent, the outline should stay there too
    outline.keepInParentRect = target.keepInParentRect;
    return outline;
},

//> @classMethod EventHandler.getDragRect()
// During a drag with +link{canvas.dragAppearance,dragAppearance} of either "target" or
// "outline", returns the page-relative coordinates of whatever element is being dragged.
// <P>
// Calling this method allows you to write drag and drop logic that works identically even if
// <code>dragAppearance</code> is subsequently changed.
//
// @return (Rect) global (page-relative) coordinates and size of the dragged element, as a
//                       4-element array [left,top,width,height], or null if not dragging
// @group dragdrop
// @visibility external
//<
getDragRect : function () {

    var target = this.dragMoveTarget || this.dragTarget;
    if (!target) return null;
    return target.getPageRect();
},



// move whatever component is intended to be moving during the drag (tracker, outline,
// dragTarget itself)
_moveDragMoveTarget : function () {
    //!DONTCOMBINE

    var EH = this;

    var target = EH.dragMoveTarget;
    if (!target) return true;


    //>Moz1.4
    var stayInParent = (isc.Browser.isMoz && isc.Browser.geckoVersion < 20031007 &&
                        !target.keepInParentRect);

    if (stayInParent &&
        (target.parentElement &&
         !target.parentElement.containsPoint(EH.lastEvent.x,EH.lastEvent.y)))
    {
        return true;
    }
    //<Moz1.4

    // move the dragMoveTarget to the event
    isc._useBoxShortcut = true;
    target.moveToEvent(EH.dragOffsetX, EH.dragOffsetY);
    isc._useBoxShortcut = false;

    target.show();
    return true;
},

// Routine to move the object that's being moved via the dragMove mechanism.
_resizeDragMoveTarget : function () {
    //!DONTCOMBINE
    var EH = this;
    // move the dragMoveTarget to the event
    if (EH.dragMoveTarget) EH.dragMoveTarget.resizeToEvent(EH.resizeEdge);
    return true;
},

// Kill the current native event
killEvent : function (DOMevent) {
    if (!DOMevent) DOMevent = isc.EH.getWindow().event;
    DOMevent.cancelBubble = true;
    return false;
},

// Return the value that will stop event bubbling

stopBubbling : function () {
    return isc.EH.STOP_BUBBLING;
},

// Start a timer to fire the synthetic 'idle' event after a short delay.  This should never
// need to be called directly - call Page.setEvent('idle', action) instead.
_$handleIdle:"_handleIdle",
startIdleTimer : function () {
    // idle shouldn't fire until after page load, and the idle timer is kicked off at page
    // load, no use setting timers in between
    if (!isc.Page.isLoaded()) return;

    // start the timer if we don't already have one running
    if (!this.idleTimer) {
        this.idleTimer = isc.Timer.setTimeout({target:isc.EH, methodName:this._$handleIdle},
                                              this.IDLE_DELAY);
    }
},

// Call registered actions for the idle event.
_handleIdle : function () {
    // allow a new timer to be set (note: code triggered from idle frequently sets further idle
    // events, so this needs to happen first)
    this.idleTimer = null;

    // handle the page-level idle stuff, as normal
    var result = isc.Page.handleEvent(null,this.IDLE);

    // if there are any remaining actions for the idle event, start the timer again
    if (isc.Page.actionsArePendingForEvent(this.IDLE)) this.startIdleTimer();
    return result;
},

_threadCounter : 0,
_setThread : function (threadCode) {
    // use a rotating counter to distinguish things like successive mouseMoves
    var newThread = threadCode + this._threadCounter++;

    if (this._thread != null) this._interruptedThread = this._thread;
    this._thread = newThread;
    if (isc.Log.logIsInfoEnabled("RpcTabTiming")) {
        this._setThreadTimeStamp = isc.timeStamp();
    }
    if (this._threadCounter > 9) this._threadCounter = 0;
},
_clearThread : function () {
    if (this._threadExitActions != null) this.runTeas();
    if (this._interruptedThread) {
        this._thread = this._interruptedThread;
        this._interruptedThread = null;
    } else {
        this._thread = null;
    }
},


_setThreadExitAction : function (action) {
    isc.Timer.setTimeout(action, 0);
    var actions = this._threadExitActions;
    if (actions == null) actions = this._threadExitActions = [];
    actions.add(action);
},


runTeas : function () {
    //!OBFUSCATEOK
    var origThread = this._thread;
    while (this._threadExitActions != null) {
        var actions = this._threadExitActions;
        this._threadExitActions = null;

        if (this.logIsDebugEnabled()) {
            this.logDebug("firing threadExitActions: " + this.echoAll(actions));
        }

        for (var i = 0; i < actions.length; i++) {
            this._thread = origThread + "[E" + i + "]";
            var action = actions[i];
            if (isc.isA.String(action)) isc.eval(action);
            else action();
        }
    }
},

// NOTE: other codes exist in eg FormItem.js for other places where we get a direct call from
// the DOM
_threadCodes : {
    load : "LOD",
    mousedown : "MDN",
    mouseup : "MUP",
    mousemove : "MMV",
    mouseout : "MOU",
    touchstart : "TDN",
    touchmove : "TMVP",
    touchend : "TUP",
    contextmenu : "CXT",
    keypress : "KPR",
    keydown : "KDN",
    keyup : "KUP",
    resize : "RSZ"
},


_$nativeEvents:"nativeEvents",

dispatch : function (handler, event) {

    if (!event) event = this.getWindow().event;


    if (isc._evalRunning != null) {
        delete isc._evalRunning;
    }


    this._setThread(this._threadCodes[event.type] || event.type);



    var result;
    if (isc.Log.supportsOnError) {
        result = handler.call(this, event);
    } else {

        try {
            result = handler.call(this, event);
        } catch (e) {
            isc.Log._reportJSError(e);

            throw e;;
        }

    }

    this._clearThread();

    if (result != false && this._replacedEvents[event.type]) {
        var baseResult = this._replacedEvents[event.type](event);
        if (baseResult == false) result = false;
    }

    return result;
},

// assign the handler
_$event: "event",



_$funcBody :

            "if (!isc.Browser.isIE && event == null) return;" +
            ((isc.Browser.isMoz && isc.Browser.version >= 6) || isc.Browser.isChrome ?
             "if(event.defaultPrevented)return;" :
             (isc.Browser.isMoz ? "if(event.getPreventDefault&&event.getPreventDefault())return;" :
               isc.Browser.isSafari ? "if(event.returnValue==false)return;" : ""))

    + "var returnVal=argu"+"ments.callee._window.isc.EH.dispatch(argu"+"ments.callee._handler,event);"
    + (!isc.Browser.isIE && isc.Browser.isDOM ?
    "if(returnVal==false)event.preventDefault();else if(returnVal==isc.EH.STOP_BUBBLING)event.stopPropogation();"
       : "")
    + "return returnVal;"
,
_replacedEvents: {},
_nativeEventName_TypeMap:{
    onmousedown:"mousedown",onmouseup:"mouseup",onclick:"click",ondblclick:"dblclick",
        oncontextmenu:"contextmenu",onmousewheel:"mousewheel",
    onmouseover:"mouseover",onmouseout:"mouseout",onmousemove:"mousemove",

    ondragstart:"dragstart",ondrag:"drag",ondragend:"dragend",
    ondragenter:"dragenter",ondragover:"dragover",ondragleave:"dragleave",
    ondrop:"drop",

    onresize:"resize", onload:"load",onunload:"unload",
    onselecttext:"selecttext",onselectionchanged: "selectionchanged",
    onkeydown:"keydown",onkeyup:"keyup",onkeypress:"keypress",

    // mobileIE support:
    // the MS* version of these works both on mobileIE10 and mobileIE11, but is technically
    // deprecated in favor of not having the "MS" prefix and being lowercase - so e.g.
    // MSPointerDown -> pointerdown.  We are not going to bother to support mobileIE < 11
    pointerdown: "pointerdown",
    pointermove: "pointermove",
    pointerup: "pointerup",
    pointercancel: "pointercancel"
},
_documentEventHandlers:{},

// the only way to register events on mobile IE11+ is with event listeners
_useEventListeners: isc.Browser.isMobileIE,

captureEvent : function (object, nativeEventName, eventName, handler) {



    var wd = this.getWindow(),
        useEventListeners = this._useEventListeners;


    //var indirect = new Function(this._$event, this._$funcBody);
    var indirect = isc._makeFunction(this._$event, this._$funcBody);
    indirect._window = wd;
    indirect._handler = handler;
    //this.logWarn("indirect created: " + indirect.toString());
    var nativeEventType;

    if (!useEventListeners) {
        // If there's a handler on the document object already, fire it synthetically from
        // our handler, so we don't clobber functionality from other JS loaded before us.

        if (object[nativeEventName] != null) {
            var nativeEventType = this._nativeEventName_TypeMap[nativeEventName] || nativeEventName.substring(2);
            this._replacedEvents[nativeEventType] = object[nativeEventName];
        }

        object[nativeEventName] = indirect;

    //    Using addEventListener / attachEvent rather than assigning directly to
    //    document.onXXX:
    // By default we assign handlers directly to document.onXXX [or window.onXXX].
    // This means that we overwrite any previously defined handlers, and if code executed
    // after the framework loads could also clobber us.
    // We overrwrite pre-existant handlers 'politely' - that is we fire our handler, then, if
    // we didn't return false, fire the pre existant handler with the correct parameters and
    // return the appropriate return value.
    // However this doesn't give us any protection against later code overwriting our onXXX
    // handlers.
    // By contrast we could use "eventListeners", created by document.addEventListener() [or
    // proprietary "attachEvent" in IE]. Events can support multiple listeners, and they
    // can't be clobbered by overwriting document.onXXX.
    // We activate this via the isc_useEventListeners flag.
    // ----
    // Problem with attachEvent/addEventListener as an interop strategy: when a handler
    // cancels an event, the other registered handlers fire anyway.
    //
    // IE: If we are using 'attachEvent' the raw 'onXXX'handler will fire before the
    // eventListener, and we have no way of knowing whether the handler canceled the event, as
    // event.returnVal is always reported as undefined (even if it has been explicitly set to
    // false).
    // Hence frameworks have no way of signalling to each other that they have completely
    // handled an event, and problems like doubled context menus might result.
    // Note: attachEvent and addEventListener are both supported in IE9
    // [running in "IE9" mode]
    //
    // Moz: If we are using 'addEventListener', we have the option of firing before or after the
    // native onXXX handler fires - this is governed by the third parameter passed to 'attachEvent'.
    // If we fire first we can call preventDefault() to cancel native behavior but this will not
    // stop a handler assigned to document.onXXX from firing.
    // A method 'getPreventDefault()' exists on the event object which allows the later handler
    // to detect a previous cancellation so we would be relying on some other library checking
    // the presence of this flag.
    // Alternatively, if we fire after some other framework's handler, we can check for that
    // handler having cancelled the native event. The only drawback in this case is that since
    // our logic fires later we're essentially giving precidence to the other library's handler
    // - if they show a context menu and kill the event we will not show ours, etc.
    //
    // Safari: Behaves like Moz, with the exception that while event.getPreventDefault() is not
    // available on the event object, you CAN check event.returnValue == false for a previous
    // cancellation.
    //
    // - By default we use "Polite clobbering of the direct handler function" - if a direct
    // handler was defined before our library loads, we retain the handler, then when the
    // event occurs, we fire our logic first, and if we did not cancel the event, fire the
    // original handler and propogate its return value back to the browser.
    // This generally achieves interop assuming the SmartClient framework is loaded after
    // any other frameworks on the page.
    // - if ISC can't be loaded last, or the direct handler gets clobbered after loading,
    // the developer can flip on 'isc_useEventListeners' for the application and hope for the
    // best in terms of doubled events (most likely only a problem in IE).
    // --
    // Order of firing:
    // - order (tested with oncontextmenu)
    //   - IE (6 and 7): window.onXXX first, then listeners in what appears to be random order
    //                   [tested with 4 "attachEvent()" calls in addition to setting
    //                    document.onXXX]
    //   - Moz (1.5.0.3): - with 3rd 'useCapture' param passed to attachEvent():
    //                      listeners first registered -> last registered, then window.onXXX
    //                    - with 'useCapture' false:
    //                      window.onXXX then listeners first registered -> lastRegistered
    //   - Safari (2.0.3): As with Moz
    //
    // W3c spec for event listeners: http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventListener
    } else {

        if (isc.Browser.isIE && isc.Browser.version < 11) {
            object.attachEvent(nativeEventName, indirect);
        } else if (isc.Browser.isDOM) {

            nativeEventType = this._nativeEventName_TypeMap[nativeEventName] ||
                                  nativeEventName.substring(2);

            object.addEventListener(nativeEventType, indirect, false);


        } else {
            this.logWarn("Unable to use event listeners in this browser");
            this._useEventListeners = false;
            return this.captureEvent(object, nativeEventName, eventName, handler);
        }
    }



    if (object === wd.document) {
        var propToRelease = (!useEventListeners || isc.Browser.isIE) ?
                                                   nativeEventName : nativeEventType;
        this._documentEventHandlers[propToRelease] = indirect;
    }


},

// Set the page up to capture events that we care about.
// Called automatically right below its definition.
_needMissedMouseupOutsideWindowWorkAround: isc.Browser.isIE && isc.Browser.version <= 8,
captureEvents : function (wd) {
    var EH = this;

    // Convert the public flag to use event listeners rather than directly specifying
    // handlers at the docment level to an internal flag
    if (window.isc_useEventListeners != null) EH._useEventListeners = window.isc_useEventListeners;


    var reverseEventTypes = isc.makeReverseMap(EH.eventTypes);
    isc.addProperties(EH, {reverseEventTypes:reverseEventTypes});

    if (wd == null) wd = this.getWindow();
    var document = wd.document;

    // add a 'load' handler to set up the Page.isLoaded parameter
    isc.Page.setEvent(EH.LOAD, isc.Page.finishedLoading);

    // DOM standard addEventListener and IE's proprietary attachEvent are mechanisms for doing
    // "event listening" - getting notified of events without assigning a function directly to a DOM
    // element.
    // We support both approaches in captureEvent() - switchable via the isc_useEventListeners
    // flag.
    // See comments in EH.captureEvent() for more on this.
    // Since the "load" event can't be cancelled, and since ISC is hosed if it never gets "load"
    // (eg, nothing responds to events, various actions will be indefinitely postponed), we're using
    // event listening for "load" even if the flag is set to false.
    // Note:
    //   - IE & Moz: only window.onload fires, not document or document.body onload
    //   - Safari: document, body, and window.onload all fire
    if (isc.Browser.isIE && isc.Browser.version < 11) {
        wd.attachEvent("onload", EH.handleLoad);
    // HACK: Opera: addEventListener for load fires load way too early, during ISC module load,
    // not clear why yet.
    } else if (isc.Browser.isDOM && !isc.Browser.isOpera) {
        wd.addEventListener("load", EH.handleLoad, true);
    } else {
        this.captureEvent(wd, "onload", EH.LOAD, EH.handleLoad);
    }


    if (!this._useEventListenerForUnload()) {
        this.captureEvent(wd, "onunload", EH.UNLOAD, EH.handleUnload);
    }

    this.captureEvent(wd, "onresize", EH.RESIZE, EH.handleResize);

    // { iscEventName : [DOMObject, nativeName, EHFunction], .. }


    if (this._needMissedMouseupOutsideWindowWorkAround) {
        this.captureEvent(document.documentElement, "onmouseleave", EH.MOUSE_LEAVE, EH.handleMouseLeaveDocument);
    }

    this.captureEvent(document, "onmousedown", EH.MOUSE_DOWN, EH.handleMouseDown);
    this.captureEvent(document, "onmousemove", EH.MOUSE_MOVE, EH.handleMouseMove);
    this.captureEvent(document, "onmouseup", EH.MOUSE_UP, EH.handleMouseUp);

    this.captureEvent(document, "onclick", EH.CLICK, EH.handleNativeClick);
    this.captureEvent(document, "ondblclick", EH.DOUBLE_CLICK, EH.handleNativeClick);


    this.captureEvent(document, "onscroll", "scroll", EH.handleScroll);

    // In IE6 we can capture the mousewheel event
    this.captureEvent(document, "onmousewheel", EH.MOUSE_WHEEL, EH.handleMouseWheel);

    // In Moz we also get events on mouse-wheel, but we have to capture them differently.
    if (isc.Browser.isMoz) {
        wd.addEventListener("DOMMouseScroll", EH.handleDOMMouseScroll, true);
    }


    // for all Canvii, we synthesize mouseOver/mouseOut by detecting that the target Canvas
    // changed.  However, we care about native mouseOut events in the case that the mouse
    // leaves the browser entirely.
    //this.captureEvent(document, "onmouseover", EH.MOUSE_OVER, EH.killEvent);
    this.captureEvent(document, "onmouseout", EH.MOUSE_OUT, EH.handleNativeMouseOut);

    // get the contextMenu trigger
    this.captureEvent(document, "oncontextmenu", EH.SHOW_CONTEXT_MENU, EH.handleContextMenu);

    // suppress the onselectstart event in a special way
    //    so we can still operate in form fields
    this.captureEvent(document, "onselectstart", EH.SELECT_START, EH.handleSelectStart);
    this.captureEvent(wd, "onselectstart", EH.SELECT_START, EH.handleSelectStart);


    if (isc.Browser.isIE) {


        this.captureEvent(document, "onselectionchange",
                          EH.SELECTION_CHANGE, EH.handleSelectionChange);



    }

    if (wd.isc_captureKeyEvents != false) {

        this.captureEvent(document, "onkeydown", EH.KEY_DOWN, EH._handleNativeKeyDown);
        this.captureEvent(document, "onkeypress", EH.KEY_PRESS, EH._handleNativeKeyPress);
        this.captureEvent(document, "onkeyup", EH.KEY_UP, EH._handleNativeKeyUp);

    }

    if (isc.Browser.hasNativeDrag || isc.Browser.isIE) {
        // ondragStart
        this._windowDragStart = wd.ondragstart;
        this._documentDragStart = document.ondragstart;
        wd.ondragstart = document.ondragstart = null;
        this.captureEvent(document, "ondragstart", EH.DRAG_START, EH.handleNativeDragStart);
    }

    if (isc.Browser.hasNativeDrag) {
        this.captureEvent(document, "ondragend", EH.DRAG_STOP, EH._handleNativeDragEnd);

        this.captureEvent(document, "ondragenter", EH.DROP_OVER, EH._handleNativeDragEnter);

        this.captureEvent(document, "ondragover", EH.DROP_MOVE, EH._handleNativeDragOver);
        this.captureEvent(document, "ondragleave", EH.DROP_OUT, EH._handleNativeDragLeave);
        this.captureEvent(document, "ondrop", EH.DROP, EH._handleNativeDrop);
    }

    if (isc.Browser._supportsCSSTransitions) {
        document.addEventListener(isc.Browser._transitionEndEventType, EH._handleTransitionEnd, false);
    }

    // IE specific 'help' event
    if (isc.Browser.isIE) {
        // onhelp (invoked from f1 keypress only). See comments about keypress handling/cancelling
        // native behavior for why we capture this.
        this._windowOnHelp = wd.onhelp;
        this._documentOnHelp = document.onhelp;
        document.onhelp = wd.onhelp = EH.handleNativeHelp;


    }

    //>Touch
    if (isc.Browser.isTouch) {
        // initialize mini state machine used for firing synthetic mousedown/mouseup on Android
        this._handledTouch = EH._touchEventStatus.READY_FOR_TOUCH;

        if (isc.Browser.isMobileIE) {
            this.captureEvent(document, "pointerdown", EH.TOUCH_START, EH._handleTouchStart);
            this.captureEvent(document, "pointermove", EH.TOUCH_MOVE, EH._handleTouchMove);
            this.captureEvent(document, "pointerup", EH.TOUCH_END, EH._handleTouchEnd);
            this.captureEvent(document, "pointercancel", EH.TOUCH_CANCEL, EH._handleTouchCancel);
        } else {
            this.captureEvent(document, "ontouchstart", EH.TOUCH_START, EH._handleTouchStart);
            this.captureEvent(document, "ontouchmove", EH.TOUCH_MOVE, EH._handleTouchMove);
            this.captureEvent(document, "ontouchend", EH.TOUCH_END, EH._handleTouchEnd);
            this.captureEvent(document, "ontouchcancel", EH.TOUCH_CANCEL, EH._handleTouchCancel);
        }
    } else //<Touch
    if (navigator.pointerEnabled) {


        this.captureEvent(document, "onpointerdown", EH.POINTER_DOWN, EH._handlePointerDown);
        this.captureEvent(document, "onpointermove", EH.POINTER_MOVE, EH._handlePointerMove);
        this.captureEvent(document, "onpointerup", EH.POINTER_UP, EH._handlePointerUp);
        this.captureEvent(document, "onpointercancel", EH.POINTER_CANCEL, EH._handlePointerCancel);
    }


    if (isc.Browser.isMobile) {
        isc.Page.pollPageSize = true;
    }

    // install browser specific routine to check if we need a synhetic keyPress on keyDown

    var helper = null;
    if      (isc.Browser.isMoz)    helper = isc.EH._mozFireKeypressOnKeyDown;
    else if (isc.Browser.isIE ||
             isc.Browser.isEdge)   helper = isc.EH._ieFireKeypressOnKeyDown;
    else if (isc.Browser.isSafari) helper = isc.EH._safariFireKeypressOnKeyDown;
    else if (isc.Browser.isOpera)  helper = isc.EH._operaFireKeypressOnKeyDown;
    if (helper) isc.EH.addClassMethods({ _fireKeypressOnKeyDown : helper });
},


_useEventListenerForUnload : function () {
    return (isc.Browser.isSafari && isc.Browser.safariVersion <= 412);
},

// releaseEvents
// Method fired when the page unloads - explicitly clear out event handlers applied to the
// document object

releaseEvents : function (wd) {
    var EH = this;

    if (wd == null) wd = this.getWindow();
    var document = wd.document,
        handlers = this._documentEventHandlers;

    for (var eventName in handlers) {
        if (!this._useEventListeners) {
            document[eventName] = null;
        } else {
            if (isc.Browser.isIE && isc.Browser.version < 11) {
                document.detachEvent(eventName, handlers[eventName]);
            } else if (isc.Browser.isDOM) {
                document.removeEventListener(eventName, handlers[eventName], false);
            }
        }
    }
    // special case for ondragstart which never went through captureEvents and got added to
    // our _documentEventHandlers map
    if (isc.Browser.hasNativeDrag || isc.Browser.isIE) {
        document.ondragstart = wd.onhelp = null;
    }
    if (isc.Browser.isIE) {
        // ditto for onhelp
        document.onhelp = wd.onhelp = null;
    }
    delete this._documentEventHandlers;
},




////////////////
// Cross-browser event property API
////////////////

//>    @classMethod    isc.EventHandler.getLastEvent()
//            Return the last event that was seen.
//
//        @group    mouseEvents
//        @return    (SCEvent) last event
//  @visibility eventhandler
//<
getLastEvent : function () {
    return this.lastEvent;
},

//>    @classMethod    isc.EventHandler.getEventType()
// Get the type of the event
//
//        @group    mouseEvents
//        @param    [event]    (SC Event) Event from a call to getEventProperties().
//                                 Default is to use isc.EventHandler.lastEvent.
//        @return            (int)    event type
//  @visibility eventhandler
//<
getEventType : function (event) {
    return (event || this.lastEvent).eventType;
},


//>    @classMethod    isc.EventHandler.getTarget()
// Return the canvas that is the target of the mouse event.
// Returns null if no canvas found.
//
// @group mouseEvents
// @return (Canvas)    event target canvas
// @visibility external
//<
//        @param    [event]    (SC Event) Event from a call to getEventProperties().
//                                 Default is to use isc.EventHandler.lastEvent.
getTarget : function (event) {
    var target = (event || this.lastEvent).target;
    if (isc.isA.DrawItem && isc.isA.DrawItem(target)) {
        target = target.drawPane;
    } else if (!isc.isA.Canvas(target)) {
        target = null;
    }
    return target;
},


//>    @classMethod    isc.EventHandler.getDragTarget() (A)
//
// Returns the current dragTarget.  This is the component on which the drag and drop
// interaction was initiated.  This only returns something meaningful during a drag and drop
// interaction.
//
// @group    mouseEvents
//
// @return            (Canvas)   The dragTarget.
//
// @see canvas.dragTarget
// @visibility external
//<
getDragTarget : function () {
    var dragTarget = this.dragTarget;
    if (isc.isA.DrawItem && isc.isA.DrawItem(dragTarget)) {
        dragTarget = dragTarget.drawPane;
    } else if (!isc.isA.Canvas(dragTarget)) {
        dragTarget = null;
    }
    return dragTarget;
},


//>    @classMethod    isc.EventHandler.getX()
//            Return the page-relative X (horizontal) coordinate of an event.
//
//        @group    mouseEvents
//        @return            (int)    x-coordinate in page coordinate space
//  @visibility external
//<
//        @param    [event]    (ISC Event) Event from a call to getEventProperties().
//                                 Default is to use isc.EventHandler.lastEvent.
getX : function (event) {
    return (event || this.lastEvent).x;
},

//>    @classMethod    isc.EventHandler.getY()
//            Return the page-relative Y (vertical) coordinate of an event.
//
//        @group    mouseEvents
//        @return            (int)    y-coordinate in page coordinate space
//  @visibility external
//<
//        @param    [event]    (ISC Event) Event from a call to getEventProperties().
//                                 Default is to use isc.EventHandler.lastEvent.
getY : function (event) {
    return (event || this.lastEvent).y;
},


//>    @classMethod    isc.EventHandler.getScreenX()
//            Return the screen-relative X (horizontal) coordinate of an event.
//
//        @group    mouseEvents
//        @param    [event]    (SC Event) Event from a call to getEventProperties().
//                                 Default is to use isc.EventHandler.lastEvent.
//        @return            (int)    x-coordinate in screen coordinate space
//  @visibility eventhandler
//<
getScreenX : function (event) {
    return (event || this.lastEvent).screenX;
},

//>    @classMethod    isc.EventHandler.getScreenY()
//            Return the screen-relative Y (vertical) coordinate of an event.
//
//        @group    mouseEvents
//        @param    [event]    (SC Event) Event from a call to getEventProperties().
//                                 Default is to use isc.EventHandler.lastEvent.
//        @return            (int)    y-coordinate in screen coordinate space
//  @visibility eventhandler
//<
getScreenY : function (event) {
    return (event || this.lastEvent).screenY;
},


//>    @classMethod    isc.EventHandler.mouseIsDown()
//        Is the mouse button currently down?
//        @return    (boolean)    true == mouse is currently down
//        @group    mouseEvents
//  @visibility eventhandler
//<
mouseIsDown : function () {
    return !!(this._mouseIsDown);
},

//>    @classMethod    isc.EventHandler.mouseDownTarget
//        Get the target of the last mouseDown event. May be null if the target has subsequently
//      been destroyed.
//        @return    (Canvas)    Canvas that got the mouseDown event, or null if not on a canvas
//        @group    mouseEvents
//<
mouseDownTarget : function () {
    return (this.mouseDownEvent ? this.mouseDownEvent.target : null);
},


//>    @classMethod    isc.EventHandler.getButtonNum()    (A)
//            Return the number of the button that was pressed:
//                1 == left mouse button (primary)
//                2 == right mouse button (secondary)
//            Tertiary mouse button is not supported as it not commonly found.
//
//        @group    mouseEvents
//        @param    event    (DOM event) DOM event object (as passed by isc.EventHandler)
//        @return            (int)    number of the mouse button
//  @visibility internal
//<
// which mouse button was pressed?  primary=1, secondary=2    (that's all we support)

getButtonNum : function (event) {
    return (event || this.lastEvent).buttonNum;
},

//>    @classMethod    isc.EventHandler.leftButtonDown()
//            Returns true if the left mouse button is being pressed.
//
//        @platformNotes    Mac:
//        Macintosh platform generally has only one mouse button - ISC considers it to be the "left"
//        mouse button, so this method will return true if the mouse is down on a single-button mouse Mac.
//
//        @group    mouseEvents
//        @return            (Boolean)    true == left button is down, false == up
//        @see EventHandler.middleButtonDown()
//        @see EventHandler.rightButtonDown()
//      @visibility external
//<
//        @param    [event]    (ISC Event) Event from a call to getEventProperties().  Default is to use isc.EventHandler.lastEvent.
leftButtonDown : function (event) {
    return ((event || this.lastEvent).buttonNum == 1);
},

//>    @classMethod    isc.EventHandler.rightButtonDown()
//            Returns true if the right mouse button is being pressed.
//
//        @platformNotes    Mac:
//        Macintosh platform generally has only one mouse button, and the
//        control key being held down serves the same purpose of the
//        right mouse button on Windows.  This is taken into account automatically.<br>
//      Opera:
//      The Opera browser does not pass right mouse button events to JavaScript code by default
//      (the user must explicitly enable this behavior via a menu item). Therefore we
//      treat <b>Shift+Ctrl+Click</b> as a context click in Opera.
//
//        @group    mouseEvents
//        @return            (Boolean)    true == right button is down, false == up
//        @see EventHandler.leftButtonDown()
//        @see EventHandler.middleButtonDown()
//      @visibility external
//<
//        @param    [event]    (ISC Event) Event from a call to getEventProperties().
//                                  Default is to use isc.EventHandler.lastEvent.
rightButtonDown : function (event) {
    if (!event) event = this.lastEvent;
    return (event.buttonNum == 2) || (event.button == 2) ||
           (isc.Browser.isMac && event.ctrlKey) ||
           // Notes:
           // We use shift+ctrl+click because
           // - ctrl + click has native meaning - shows a save-as dialog if it occurs over
           //   an image
           // - alt + click has meaning - it puts focus onto the native browser menus
           // we're unable to suppress either of these
           (isc.Browser.isOpera && (event.ctrlKey && event.shiftKey)) ||
           // Note, for early Safari, we get no event on ctrl+click nor on right button click
           // so if the altKey is down, we'll assume treat this as a context click
           ((isc.Browser.isSafari && (isc.Browser.safariVersion < 125)) && event.altKey);

},

//> @classMethod EventHandler.middleButtonDown() (A)
// Returns true if the middle mouse button is being pressed.
// <p>
// Checking whether the middle mouse button is pressed can be used to implement power user
// shortcuts; however, note that many pointing devices do not have a middle button. Thus, the
// application should <strong>not</strong> require the user to press a middle button in order
// to perform some action.
// @return (boolean) true if the middle mouse button is pressed; false otherwise.
// @see EventHandler.leftButtonDown()
// @see EventHandler.rightButtonDown()
// @group mouseEvents
// @visibility external
//<
middleButtonDown : function (event) {
    return (event || this.lastEvent).buttonNum == 4;
},

// In Nav, early Safari, and current Opera, we don't get real context menu events, so we
// have to synthesize them in response to mouseDown / mouseUp events.
useSyntheticRightButtonEvents : function () {
    return isc.Browser.isOpera ||

                (isc.Browser.isSafari && (isc.Browser.safariVersion < 125));
},

// Which key was pressed (for keyboard events)

//>    @classMethod    isc.EventHandler.getKeyEventCharacterValue()
//          Returns the numeric characterValue reported by the browser.
//          Only available on keyPress events, and only for character (or ascii control) keys
// @return (int) Numeric character value reported by the browser
//                  (ASCII value of the key pressed)
// @group    keyboardEvents
//  @visibility external
//<
getKeyEventCharacterValue : function (event) {
    return (event || this.lastEvent).characterValue;
},

//>    @classMethod    isc.EventHandler.getKeyEventCharacter()
//            Return the character for the current key being pressed.
//            Note that this is only set reliably for keyPress events on character keys.
//
// @return (string) Character the user entered. May be null for non-character keys.
//        @group    keyboardEvents
//      @visibility external
//<
getKeyEventCharacter : function (event) {
    return String.fromCharCode(this.getKeyEventCharacterValue(event));
},

//>    @classMethod    isc.EventHandler.getKey()
//            Return the name of the key for the event passed in.
//            Note that this is only set reliably for keyboard events.
//
//        @group    keyboardEvents
//        @return            (KeyName)        Key Name
//      @visibility external
//<
//        @param    [event]    (SC Event)  Event to return keyName for
//                                  Default is to use isc.EventHandler.lastEvent.
getKey : function (event) {
    return (event || this.lastEvent).keyName || null;
},

// Add getKeyName() as a synonym of getKey() since we refer to the property as event.keyName
getKeyName : function (event) {
    return this.getKey(event);
},

//>    @classMethod    isc.EventHandler.shiftKeyDown()
//            Return true if the shift key is being held down.
//            Note that this is only set reliably for keyboard events.
//
//        @group    keyboardEvents
//        @return            (Boolean)    true == shift key is down
//      @visibility external
//<
//        @param    [event]    (ISC Event) Event from a call to getEventProperties().
//                                  Default is to use isc.EventHandler.lastEvent.
shiftKeyDown : function (event) {
    return !!((event || this.lastEvent).shiftKey);
},

//>    @classMethod    isc.EventHandler.ctrlKeyDown()
//            Return true if the control key is being held down.
//            Note that this is only set reliably for keyboard events.
//
//        @group    keyboardEvents
//        @return            (Boolean)    true == control key is down
//      @visibility external
//<
//        @param    [event]    (ISC Event) Event from a call to getEventProperties().
//                                  Default is to use isc.EventHandler.lastEvent.
ctrlKeyDown : function (event) {
    return !!((event || this.lastEvent).ctrlKey);
},

//>    @classMethod    isc.EventHandler.altKeyDown()
//            Return true if the alt (option) key is being held down.
//            Note that this is only set reliably for keyboard events.
//
//        @group    keyboardEvents
//        @return            (Boolean)    true == alt key is down
//      @visibility external
//<
//        @param    [event]    (ISC Event) Event from a call to getEventProperties().
//                                  Default is to use isc.EventHandler.lastEvent
altKeyDown : function (event) {
    return !!((event || this.lastEvent).altKey);
},


//>    @classMethod    isc.EventHandler.metaKeyDown()
//            Return true if the meta (windows or apple) key is being held down.
//            Note that this is not supported in all versions of IE.
//            Note that this is only set reliably for keyboard events.
//
//        @group    keyboardEvents
//        @return            (Boolean)    true == meta key is being held down
//  @visibility internal
//<
//        @param    [event]    (SC Event) Event from a call to getEventProperties().
//                                 Default is to use isc.EventHandler.lastEvent.

metaKeyDown : function (event) {
    return !!((event || this.lastEvent).metaKey);
},

//>    @classMethod    isc.EventHandler.modifierKeyDown()
//            Return true if the control key (windows) or command/apple key (apple)
//          is being held down.
//            Note that this is not supported in all versions of IE.
//            Note that this is only set reliably for keyboard events.
//
//        @group    keyboardEvents
//        @return            (boolean)    true == control/command key is being held down
//  @visibility internal
//<
//        @param    [event]    (SC Event) Event from a call to getEventProperties().
//                                 Default is to use isc.EventHandler.lastEvent.

modifierKeyDown : function (event) {
    if (isc.Browser.isMac) return !!((event || this.lastEvent).metaKey);
    else                   return !!((event || this.lastEvent).ctrlKey);
},

// Checks whether a key event matches the key identifier `key'. If `event' is not provided,
// then `EH.lastEvent' is used.
//
// Parameters:
// - key (KeyName | KeyIdentifier) the key name or KeyIdentifier object to check for.
// - [event] (ISC Event) the key event to test.
//
// Returns:
// (boolean) `true' if `key' matches the given key event; `false' otherwise.
_matchesKeyIdentifier : function (key, event) {
    event = event || this.lastEvent;

    var keyName = key;
    if (isc.isAn.Object(key)) {
        keyName = key.keyName;
        if (key.shiftKey != null && !!key.shiftKey != this.shiftKeyDown(event)) return false;
        if (key.ctrlKey != null && !!key.ctrlKey != this.ctrlKeyDown(event)) return false;
        if (key.altKey != null && !!key.altKey != this.altKeyDown(event)) return false;
        if (key.metaKey != null && !!key.metaKey != this.metaKeyDown(event)) return false;
    }
    return keyName == this.getKey(event);
},

//>    @classMethod    isc.EventHandler.getMouseEventProperties()
//        Record the characteristics of a mouse event in the object passed in.
//
//        Sets the following properties:
//            eventType        type of the event
//            nativeTarget    DOM element that was the target of the event
//            target            Canvas that was the target of the event (may be null)
//            x                 page-level X coordinate
//            y                page-level Y coordinate
//            screenX            X coordinate relative to the top corner of the screen.
//            screenY            Y coordinate relative to the top corner of the screen.
//            buttonNum         Mouse button pressed.  <code>null</code> == mouse button not pressed.
//
//        Note: we don't try to make element-relative coordinates (offsetX/Y) available, since
//            the HTML element that catches the event may not be the HTML element that
//            represents the Canvas that will handle the event.  For example, the DOM-level
//            target could be a table cell, ultimately contained within a DIV which represents
//            a Canvas.
//
//            Use
//                    canvas.getOffsetX(), canvas.getOffsetY()
//            to get the coordinates of the event relative to the Canvas which is regarded as
//            the receiver of the event within ISC.
//
//        @group    events
//        @param    e        (DOM event) DOM event object (as passed by isc.EventHandler)
//      @visibility internal
//<
getMouseEventProperties : (isc.Browser.isIE ?
    function (e) {
        var scEvent = this.lastEvent;
    if (!e) e = this.getWindow().event;

        scEvent.DOMevent = e;

        scEvent.eventType = this._nativeMouseEventMap[e.type];

        scEvent.y = parseInt(e.clientY) + this.ns.Page.getScrollTop();
        scEvent.x = parseInt(e.clientX);

        if (!isc.Page.isRTL()) {
            scEvent.x += this.ns.Page.getScrollLeft();
        } else {




            if (isc.Browser.isIE && isc.Browser.version <= 7 && isc.Browser.isStrict &&
                isc.Page.getBodyOverflow() != isc.Canvas.HIDDEN)
            {
                if (!this._pageScrollbarThickness) {

                    if (isc.Browser.version <= 6) {
                        this._pageScrollbarThickness = document.documentElement.offsetWidth - document.documentElement.clientWidth;

                    } else if (isc.Browser.version <= 7) {
                        this._pageScrollbarThickness = document.documentElement.offsetWidth - document.body.offsetWidth;

                    } else {
                        this._pageScrollbarThickness = document.body.offsetWidth - document.body.clientWidth;
                    }
                }
                scEvent.x -= this._pageScrollbarThickness;
            }
        }

        scEvent.nativeTarget = e.srcElement;

        //this.logWarn(this.echoDOM(scEvent.nativeTarget));

        // Hang onto the wheelDelta - only defined for mouseWheel events

        var delta = e.wheelDelta;
        if (delta != null) {
            scEvent.wheelDelta = - delta/120;
            scEvent.wheelDeltaY = scEvent.wheelDelta;
            scEvent.wheelDeltaX = 0;
        } else {
            scEvent.wheelDelta = null;
            scEvent.wheelDeltaX = null;
            scEvent.wheelDeltaY = null;
        }

        scEvent.screenX = e.screenX;
        scEvent.screenY = e.screenY;

        if (isc.Browser.isIE9) {
            // For a 'pointerup' or 'mouseup' event, `buttons' is 0 because no mouse button is being pressed.
            if (scEvent.eventType === isc.EH.POINTER_UP ||
                scEvent.eventType === isc.EH.MOUSE_UP)
            {
                if (e.button == 0) scEvent.buttonNum = 1;
                else if (e.button == 1) scEvent.buttonNum = 4;
                else if (e.button == 2) scEvent.buttonNum = 2;
                else scEvent.buttonNum = 0;

            } else {
                scEvent.buttonNum = e.buttons;
            }

        } else {
            scEvent.buttonNum = e.button;
        }

        // getKeyEventProperties (fired when a key goes down) should handle updating shiftKey
        // et al
        // However if a native alert was fired in response to a key down event we don't get
        // the native keyUp, so will never clear these properties out. Avoid this by resetting
        // these properties on mouse events as well as key events.
        scEvent.shiftKey = (e.shiftKey == true);
        scEvent.ctrlKey = (e.ctrlKey == true);
        scEvent.altKey =  (e.altKey == true);
        scEvent.metaKey =  (e.metaKey == true);

        scEvent.target = this.getEventTargetCanvas(e, scEvent.nativeTarget, scEvent);

        /*
        this.logWarn("event: " + this.echo({
            type : e.type,
            button : e.button,
            target : e.srcElement,
            clientX : e.clientX,
            clientY : e.clientY,
            screenX : e.screenX,
            screenY : e.screenY
        }));
        */

        return scEvent;
    }
:   // isc.Browser.isDOM
    function (e) {

        var scEvent = this.lastEvent;
        scEvent.DOMevent = e;
        scEvent.eventType = this._nativeMouseEventMap[e.type];

        var ignoreCoordinates = false;

        if (isc.Browser.isMobileWebkit) {

            //>Touch
            if (isc.startsWith(scEvent.eventType, "touch")) {
                // e.touches is an array of event objects for each finger touching the screen.
                // Report the first finger's coordinates on the event object as a whole.
                if (scEvent.eventType == isc.EH.TOUCH_END) {
                    // "touchend" natively reports all coordinates as undefined or bogus (0) and
                    // has no e.touches Array.  This makes some sense since two or more fingers
                    // could have been touching the screen and so there is no single end coordinate
                    // to report.  In terms of this logic and mouse event handlers seeing analogous
                    // behavior to mouseUp, it means we need to avoid overwriting coordinates
                    // recorded from the last touchstart / touchmove.  Native behavior noted on
                    // iPhone OS 3.2.
                    ignoreCoordinates = true;
                } else if (e.touches != null && e.touches[0] != null) {
                    var touch = e.touches[0];
                    // relative to element viewport
                    scEvent.clientX = touch.clientX;
                    scEvent.clientY = touch.clientY;
                    // relative to screen
                    scEvent.screenX = touch.screenX;
                    scEvent.screenY = touch.screenY;
                    // relative to page (content start)
                    scEvent.x = touch.pageX;
                    scEvent.y = touch.pageY;


                    if (isc.Browser.isIPad && isc.Browser.isMobileSafari && isc.Browser.iOSVersion == 7 &&
                        isc.Page.getOrientation() === "landscape")
                    {
                        var documentBody = this.getDocumentBody(),
                            bodyBCR = documentBody.getBoundingClientRect();
                        var realScrollTop = Math.max(0, (-bodyBCR.top) << 0);

                        scEvent.screenY += ((-documentBody.scrollTop + realScrollTop) * isc.Page._getPageZoom()) << 0;
                        scEvent.y += -documentBody.scrollTop + realScrollTop;
                    }
                }

                /*
                 this.logWarn("native event: " + this.echo({
                 clientX : e.clientX,
                 clientY : e.clientY,
                 pageX : e.pageX,
                 pageY : e.pageY,
                 screenX : e.screenX,
                 screenY : e.screenY,
                 touchesLength : e.touches.length
                 }));
                 */
            } else if (isc.Browser.isAndroid && e.type == isc.EH.CLICK) {
                // Install valid coordinates for a native click so that same event
                // can be forwarded on and work properly for synthetic mouseDown/mouseUp.
                // See IDocument under EH.handleNativeClick() for explanation.
                scEvent.screenX = e.screenX;
                scEvent.screenY = e.screenY;

                scEvent.x = parseInt(e.clientX) + isc.Page.getScrollLeft(true);
                scEvent.y = parseInt(e.clientY) + isc.Page.getScrollTop();
            }
            //<Touch

        } else {
            scEvent.screenX = e.screenX;
            scEvent.screenY = e.screenY;




            if (scEvent.eventType != this.MOUSE_WHEEL) {
                var adjustForPageScroll = true;
                scEvent.x = parseInt(e.clientX) + (adjustForPageScroll ? isc.Page.getScrollLeft(true)
                                                                        : 0);
                scEvent.y = parseInt(e.clientY) + (adjustForPageScroll ? isc.Page.getScrollTop()
                                                                        : 0);
            }

        } // end else on MobileWebkit

        scEvent.nativeTarget = e.target;

        scEvent._stillWithin = null; // clear cached result of stillWithinMouseDownTarget

        scEvent.target = this.getEventTargetCanvas(e, scEvent.nativeTarget, scEvent);


        if (scEvent.eventType == this.MOUSE_WHEEL) {
            // deltaX / deltaY are available
            var deltaY = e.wheelDeltaY,
                deltaX = e.wheelDeltaX,
                wheelDelta = e.wheelDelta,
                delta = wheelDelta,

                detail = e.detail,
                axis = e.axis;

            // If deltaX / deltaY are available, use them!
            if (deltaY != null || deltaX != null) {

                // this.logWarn("Reported wheelDeltaX/Y:" + [scEvent.wheelDeltaX,scEvent.wheelDeltaY]);
                scEvent.wheelDeltaX = deltaX == null ? 0 : - deltaX/120;
                scEvent.wheelDeltaY = deltaY == null ? 0 : - deltaY/120;
                // for backCompat
                scEvent.wheelDelta = scEvent.wheelDeltaY;

            } else {
                // No detail, no wheelDeltaX / Y, just use "wheelDelta"
                if (detail == 0 || (detail == null && wheelDelta != null)) {

                    var delta = e.wheelDelta;
                    if (delta != null) {
                        // may be fractional - this is ok.
                        scEvent.wheelDelta = - delta/120;
                        scEvent.wheelDeltaY = scEvent.wheelDelta;
                        scEvent.wheelDeltaX = 0;
                    } else {
                        scEvent.wheelDelta = null;
                        scEvent.wheelDeltaX = null;
                        scEvent.wheelDeltaY = null;
                    }

                // No helpful "deltaX"/"deltaY", but we have event.detail, so use it!
                } else {
                    if (isc.Canvas.useNativeWheelDelta && e.detail == e.SCROLL_PAGE_UP) {
                        scEvent.wheelDelta = -Math.floor(
                            scEvent.target.height/isc.Canvas.scrollWheelDelta);
                    } else if (isc.Canvas.useNativeWheelDelta && e.detail == e.SCROLL_PAGE_DOWN) {
                        scEvent.wheelDelta =  Math.floor(
                            scEvent.target.height/isc.Canvas.scrollWheelDelta);
                    } else {
                        var vertical = axis == null || axis == 2;
                        // delta is a fraction, so that wheelDelta==1 when e.detail=3, but
                        // wheelDelta=0.333 when e.detail==1. This matches the earlier behavior
                        // for 3-line scrolling.
                        var delta = e.detail/3;
                        if (!isc.isA.Number(delta)) delta = 0;
                        if (vertical) {
                            scEvent.wheelDelta = delta;
                            scEvent.wheelDeltaY = delta;
                            scEvent.wheelDeltaX = 0;
                        } else {
                            scEvent.wheelDelta = 0;
                            scEvent.wheelDeltaY = 0;
                            scEvent.wheelDeltaX = delta;
                        }
                    }
                }
            }

        } else {
            scEvent.wheelDelta = null;

            scEvent.wheelDeltaX = null;
            scEvent.wheelDeltaY = null;
        }


        if (scEvent.eventType == isc.EH.MOUSE_MOVE || scEvent.eventType == isc.EH.TOUCH_MOVE ||
            scEvent.eventType == isc.EH.POINTER_MOVE)
        {
            // clear the button if the mouse is not down
            if (!this._mouseIsDown) scEvent.buttonNum = 0;

        // otherwise, a mouseDown/Up event - there's a button down, so which is it?

        //>Touch
        } else if (isc.Browser.isTouch) {
            if (e.targetTouches && e.targetTouches.length > 1) {
                // treat two fingers on a single target as context click by default
                scEvent.buttonNum = 2;
            } else {
                scEvent.buttonNum = 1;
            }

        //<Touch
        } else {
            if (e.which == 2) {
                scEvent.buttonNum = 4;


            } else {
                scEvent.buttonNum = (e.which == 1 || (isc.Browser.isSafari && e.which == 65536)
                                     ? 1 : 2);
            }
        }
        //this.logWarn("event: " + e.type + " which: " + e.which +
        //             " e.button: " + e.button + ", scEvent.buttonNum: " + scEvent.buttonNum);
        //scEvent.nativeWhich = e.which;


        scEvent.shiftKey = (e.shiftKey == true);
        scEvent.ctrlKey = (e.ctrlKey == true);
        scEvent.altKey = (e.altKey == true);
        scEvent.metaKey = (e.metaKey == true);
        /*
        this.logWarn("event: " + this.echo({
            type : e.type,
            button : scEvent.buttonNum,
            target : e.target,
            clientX : e.clientX,
            clientY : e.clientY,
            screenX : e.screenX,
            screenY : e.screenY
        }));
        */

        //this.logWarn("event: " + e.type + "\r\n" + this.echoEvent(e));
        return scEvent;
    }
),

//>    @classMethod    isc.EventHandler.getKeyEventProperties()
//        Record the characteristics of a keyboard event
//
//        Sets the following properties on isc.EventHandler.lastEvent:
//            nativeKeyTarget    DOM element that was the target of the event
//          keyTarget       Target Canvas for the key event - matches the item that currently
//                          has focus
//            keyName            Name of the key pressed. (available on keyDown, keyUp and keyPress)
//          characterValue  Numeric character value reported by the key event.  Only recorded
//                          for keypress events - may be null or zero for non-character keys.
//
//            shiftKey        Shift key is currently down.
//            ctrlKey            Control key is currently down.
//            altKey            Alt key is currently down.
//            metaKey         Meta key is currently down.
//                                Note: meta-key seems to not work on most platforms
//          eventType       Type of the event (keyDown, keyPress, etc.)
//
//        @group    events
//        @param    e        (DOM event) DOM event object (as passed by isc.EventHandler)
//  @visibility internal
//<

getKeyEventProperties : function (e) {

    if (e == null) e = this.getWindow().event;

    var scEvent = this.lastEvent;


    scEvent.nativeKeyTarget = (e.target || e.srcElement);
    scEvent.keyTarget = this._focusCanvas;
    if (isc.isA && isc.DynamicForm && isc.isA.DynamicForm(this._focusCanvas)) {
        var itemInfo = isc.DynamicForm._getItemInfoFromElement(scEvent.nativeKeyTarget,
                                                               scEvent.keyTarget);
        if (itemInfo && itemInfo.item) scEvent.keyTarget = itemInfo.item;
    }

    scEvent.eventType = this.getKeyEventType(e.type);
    //this.logWarn("getKeyEventProperties() - eventType " + scEvent.eventType +
    //              ", native key event target: " + scEvent.nativeKeyTarget +
    //              ", ISC calculated target: " + scEvent.keyTarget);

    // for keypresses only, record the character code (may be null or zero - assume the
    // developer knows what he's doing with this code)
    if (scEvent.eventType == this.KEY_PRESS) {
        scEvent.characterValue = this._determineKeyEventCharacterValue(e);
    }

    var keyName = this.determineEventKeyName(e);
    if (keyName != null) {
        scEvent.keyName = keyName;

    } else if (scEvent.eventType != isc.EH.KEY_PRESS) delete scEvent.keyName;




    scEvent.nativeKeyCode = e.keyCode;


    scEvent.shiftKey = (e.shiftKey == true || (isc.Browser.isMoz && scEvent.shiftKey));
    scEvent.ctrlKey = (e.ctrlKey == true);
    scEvent.altKey = (e.altKey == true);
    scEvent.metaKey = (e.metaKey == true);

    //this.logWarn("getKeyEventProperties() - keyName " + scEvent.keyName +
    //              ", ctrlKey: " + scEvent.ctrlKey +
    //              ", shiftKey: " + scEvent.shiftKey +
    //              ", altKey: " + scEvent.altKey);

},



getKeyEventType : function (nativeType) {
    if (!nativeType) return;
    return this._nativeKeyEventMap[nativeType];
},



// Return the charset value for the event.
// Note: returns null if we can't get a value, or if the value is zero (meaningless)
_determineKeyEventCharacterValue : function (DOMevent) {

     if (isc.Browser.isIE) return (DOMevent.keyCode || null);
     if (isc.Browser.isMoz) {
        return (DOMevent.which || null);
     }
     return (DOMevent.which || DOMevent.keyCode || null);
},
_$f1:"f1",
_$help:"help",
determineEventKeyName : function(DOMevent) {
    if (DOMevent == null) return;
    var keyCode = DOMevent.keyCode,
        which = DOMevent.which,
        EH = isc.EH,
        type = EH.getKeyEventType(DOMevent.type),
        windowEvent = this.getWindow().event
    ;

    // In IE we get have an onhelp handler tripped by f1 keypress only
    if (DOMevent.type == this._$help) return this._$f1;

    //this.logWarn("determineEventKeyName(): key properties to determine event: " +
    //             "keyCode:" + keyCode +
    //             ", which:" + which + ", type:" + type);


    if (isc.Browser.isIE) {
        //isc.logWarn("IE: Deriving keyName for keyCode " + keyCode + ", type is '" + type + "'");

        if (type == EH.KEY_DOWN || type == EH.KEY_UP) {
            //isc.logWarn("Type is " + type + ": keyName comes from the virtualKeyMap: " + keyCode + " = '" + EH._virtualKeyMap[keyCode] +"'");
            return EH._virtualKeyMap[keyCode];
        }


        if (type == EH.KEY_PRESS) {
            // If we have the keyDown key name, just make use of it
            var keyDownKeyName = EH._keyDownKeyNames[EH._keyDownKeyNames.length-1];
            if (keyDownKeyName != null) {
                //isc.logWarn("We already have a keyDown name of '" + keyDownKeyName + "'");
                return keyDownKeyName;
            }
            isc.logWarn("Trying to derive keyName from the charsetValueToKeyNameMap: " + keyCode + " = '" + EH._charsetValueToKeyNameMap[code] +"'");
            var name = EH._charsetValueToKeyNameMap[keyCode];

            if (!name && windowEvent && windowEvent.ctrlKey) {
                name = isc.EH._getKeyNameFromCtrlCharValue(keyCode);
                //isc.logWarn("Tried to get keyName by calling getKeyNameFromCtrlCharValue(): " + keyCode + " = '" + name +"'");

            }
            return name;

        }


    } else if (isc.Browser.isMoz) {

        if (type == EH.KEY_DOWN || type == EH.KEY_UP) {
            return EH._virtualKeyMap[keyCode];

        } else if (type == EH.KEY_PRESS) {

            if (which == 0 && keyCode != 0) return EH._virtualKeyMap[keyCode];

            // If we have the keyDown key name, just make use of it
            var keyDownKeyName = EH._keyDownKeyNames[EH._keyDownKeyNames.length-1];
            if (keyDownKeyName != null) return keyDownKeyName;


            if (keyCode == 0) {
                return EH._charsetValueToKeyNameMap[which];


            } else {
                return EH._virtualKeyMap[which];
            }

        }


    } else if (isc.Browser.isSafari) {
        if (type == EH.KEY_DOWN || type == EH.KEY_UP) {
            return EH._virtualKeyMap[keyCode];
        }

        var code = (which != null ? which : keyCode);
        if (code != null && code != 0) {

            if (windowEvent && windowEvent.ctrlKey) {
                var keyName = isc.EH._charsetValueToKeyNameMap[code];
                if (keyName == null) {

                    if ((isc.Browser.isChrome && isc.Browser.version < 33) ||
                        (!isc.Browser.isChrome && isc.Browser.version < 6))
                    {
                        if (code == 10) keyName = "Enter";
                        else keyName = isc.EH._getKeyNameFromCtrlCharValue(code);
                    } else {
                        keyName = isc.EH._getKeyNameFromCtrlCharValue(code);
                    }
                }
                return keyName;
            }


            var keyName = isc.EH._charsetValueToKeyNameMap[code];

            if (keyName == null) keyName = isc.EH._safariSpecialKeyPressMap[code]

            return keyName;

        // Note: we are aware of a bug where keypress events on arrow keys give a keyCode of zero
        // in Safari. Return null here without logging a warning (below)
        // - we have logic in the calling code to pick up the key name from the key-down
        // event instead, so this is both known and worked around.
        } else if (type == this.KEY_PRESS) {
            return null;
        }




    } else {

        var code = which;

        // If which is null or zero, use keyCode (if it's not null or zero)
        if (code == null || (code == 0 && keyCode)) code = keyCode

        if (code != null) return isc.EH._charsetValueToKeyNameMap[code];
    }

    // Should never get here
    isc.Log.logWarn("EventHandler.determineEventKeyName(): Unable to determine key for '" +
                    DOMevent.type + "' event. Returning null");
    return null;

},


_getKeyNameFromCtrlCharValue : function (ctrlCharValue) {

    if (ctrlCharValue == 30) return "6";
    if (ctrlCharValue == 31) return "-";

    return String.fromCharCode(ctrlCharValue + 64);

},

// Called from handleKeyUp
clearKeyEventProperties : function (keyName) {
    var scEvent = this.lastEvent;
    delete scEvent.eventType;
    delete scEvent.nativeKeyTarget;
    delete scEvent.characterValue;
    delete scEvent.keyName;
    delete scEvent.shiftKey;
    delete scEvent.ctrlKey;
    delete scEvent.altKey;
    delete scEvent.metaKey;
    // We should already have cleared the keyDownKeyNames entry as part of handleKeyPress
    // (whether fired from native onkeypress or synthetically) for the key in question - this
    // is really just a sanity check.
    this._keyDownKeyNames.remove(keyName);
},


// Destroyed targets
// We hang onto pointers to canvii in various places. Ensure these get cleared up when a canvas is
// destroyed, so we don't leak memory
// (Note many of these would be cleared on subsequent events in any case)
canvasDestroyed : function (canvas) {

    // if any clickMasks are showing, remove canvas from all clickMask "unmasked" lists
    if (this.clickMaskUp()) isc.EH.maskTarget(canvas);

    // if canvas was registered to receive the resize event, clear the registration

    if (canvas._resizeID) isc.Page.clearEvent(canvas._$resize, canvas._resizeID);


    if (this.mouseDownEvent && this.mouseDownEvent.target == canvas)
        this.mouseDownEvent.target = null;
    if (this.lastClickTarget == canvas) this.lastClickTarget = null;
    if (this.lastEvent.target == canvas) this.lastEvent.target = null;
    if (this.lastEvent.keyTarget == canvas) this.lastEvent.keyTarget = null;
    if (this._focusCanvas == canvas) this._focusCanvas = null;
    if (this._delayedFocusTarget == canvas) this._delayedFocusTarget = null;
},

// ClickMask
// ------------------------------------------------------------------------------------------------
//  Basic behavior:
//  - Suppress mouse events such as 'mouseOver' et. al on targets that are not marked as unmasked.
//    This is typically a visual indication to the user that the target is masked.
//  - Fire clickAction on mouseDown on masked target.
//  - mode:
//      o If "soft", hide the click mask on mouseDown on masked target, and allow the mouseDown
//        event to proceed.  [Use case: dismissing a pop up menu by clicking outside it]
//        * The mouseDown must be allowed to proceed as we don't want the click to be mysteriously
//          dropped in use cases like this one
//      o If "softCancel", dismiss the clickMask on mouseDown (as with a soft mask), but also
//        cancel the mouseDown event if it occurred over a SmartClient widget.
//        [Use case: we use this in modal editing of ListGrids where stopOnerrors is true.
//         We can't use a true "hard" mask in this case because we wouldn't be able to have
//         the edit form items be unmasked without unmasking the whole grid and all it's
//         ancestors].
//      o If "hard" prevent the mouseDown from reaching the intended target. (Also leave the click
//        mask in place, so future mouseDown's will fire the click action again).
//        [Use case: clicking outside a modal dialog box].
//       Hard masks:
//       o Prevent interaction with native HTML written into masked widgets
//       o Disallow focus on masked targets via
//          - tabbing - (we do this by capturing tab keypresses)
//          - accessKey (removed from widget handle)
//          - programmatic - just remember the (attempted) focus target and re-focus when the
//            mask gets hidden
//
//  Features:
//  - Layering / Stacking of multiple clickMasks.
//      Each call to showClickMask() returns a unique ID for the clickMask.
//      If showClickMask() is called multiple times, we create multiple stacked clickMask objects.
//      A click on a masked target will fire the click action of the topmost clickMask, and
//      depending on the 'mode' property of the clickMask, fire the click action on the masks
//      underneath.
//      Clickmasks are hidden using hideClickMask(), which, if passed an ID parameter will hide only
//      the specified mask.
//      This nesting behavior is made necessary by use cases like the following:
//      - Date picker widgets are modal and dismissable - they show an soft clickMask which
//        whill hide the date-picker if the user clicks outside it.
//        They contain 'year' and 'month' menus, which are also modal and dismissable.
//        If the user clicks outside the date-picker while it is showing it's year menu, both the
//        menu and the picker should be dismissed.
//        If the user clicks on the date-picker but outside the year menu (while it is visible),
//        the year menu should be dismissed and the date picker should receive a click event.
//        Therefore we need intelligent nesting of soft CM's where the masks track their
//        'unmaskedTargets' and click actions independantly.
//      - Modal window widgets can contain any other widget.  If a modal widow is shown containing
//        a data-bound listViewer, when the listViewer performs a server-side fetch, a click mask
//        is shown for the modal window, and another one for the server side fetch.
//        When the server side fetch returns, we should hide only the click-mask shown by the fetch.
//        Therefore we also need intelligent stacking of hard CM's (and the ability to
//        hide clickMasks shown from specific 'showClickMask()' calls)
//  - unmasked targets:
//      Targets can be marked as unmasked either when the clickMask is instantiated (as an optional
//      third parameter to showClickMask()) or via a call to canvas.unmask() (falls through to
//      EventHandler.addUnmaskedTargets()).
//      Deprecated: The Canvas 'bringToFront()' method automatically adds widgets to the
//      unmaskedTargets list of the formost clickMask - deprecated as of build 5.5, but
//      still works.  Developers are encouraged to use unmask() instead.
//      Note that when a widget is 'unmasked' wrt a particular clickMask, it is effectively
//      unmasked wrt any click masks underneath that one as well.
//      o If a "hard" clickMask is showing, we only support it having top-level
//        unmasked targets -- we can't support an unmasked child of a masked parent for
//        "hard" masks. [We DO support this for soft masks].
//       - the only known, cross-browser way to truly intercept all events, including events
//         that might be received by handlers directly written into native elements, is to
//         place a physical element ("screenspan") over the whole screen
//       - anything that is to be unmasked therefore has to be ready to have it's top-most
//         element change zIndex to get above the screenspan, and this is generally not ok to
//         for eg some widget nested deeply in a series of Layouts, since this might effectively
//         cause a full-screen Layout to come to the front, occluding things that had been
//         placed over it
//       - hard-unmasking a non-top-level widget comes about *only* for modal inline editing with
//         waitForSave *and* stopOnErrors set, which is a corner case where it would be acceptable
//         to place limitations or require special coding to make masking work
//       - alternatives include:
//         o individually masking everything else on the screen by generating elements to place
//           on top (too slow)
//         o creating a top-level mask composed of 4 pieces with a rectangular opening for the
//           unmasked, non-top-level widget: complicated, especially if multiple widgets
//           non-top-level widgets can become unmasked together, and they may move
//      o We never support an unmasked parent with a masked child widget.
//      o We always mask and unmask all peers (and descendants of peers) of a widget with
//        the widget. Use cases include scrollbars, edges, shadows.
//
// Future enhancements:
//  - Component level clickMasks:
//      In Windows and other multiple-window desktop systems, a "clickMask" only extends to the
//      current Window.  For example if you open a menu within a window, other windows still respond
//      normally to mouseOver et al.
//      At some point ISC may need to implement per-widget clickMasks as well.
// ------------------------------------------------------------------------------------------------



//> @type ClickMaskMode
// Passed as a parameter to +link{Canvas.showClickMask} to determine the masks behavior
// when clicked.
// @value "hard"   When the mask receives a click, it will fire its click action,
//                  and cancel the event, leaving the clickMask up.
HARD:"hard",
// @value "soft"   When the mask receives a click, it will fire its click action,
//                  then dismiss the clickMask and allow the event to proceed to its target.
SOFT:"soft",
// @group clickMask
// @visibility external
//<

SOFT_CANCEL:"softCancel",


//>    @classMethod    EventHandler.showClickMask()    (A)
//
// The clickmask intercepts all mouse events for everything on the screen except a list of
// "unmasked" targets.
// It is used in 2 ways:<br>
//  - To allow things such as modal dialogs which prevent interactions with widgets outside
//    themselves<br>
//  - To allow things such as menus which respond to clicks outside themselves (without preventing
//    the event).<br>
// When a mouseDown occurs anywhere on the screen outside of an unmasked target, the clickMask's
// "clickAction" fires.  <br>
// If the mask is soft it will disappear at this time. The event will be cancelled in this case
// unless mode is explicitly set to "softCancel" in which case we return false to kill the event.
// If the mask is hard, the event will be cancelled.<br>
// <br>
// This method returns an identifier for this clickMask.  If showClickMask() is called while a
// clickMask is already up, the clickmasks will 'layer', with the most recently shown clickMask
// recieving click events first, and if  the mask is soft, passing the click event down to the
// previously shown mask.
// The clickMask can be hidden with a call to EventHandler.hideClickMask(), which takes an optional
// clickMaskID parameter. (If this parameter is not passed, all clickMasks will be hidden).
//
// @group   clickMask
// @param   clickAction     (string | method)   action to fire when the clickMask is clicked
// @param   mode    (ClickMaskMode)
//      Should this mask be dismissed and allow events to proceed on outside click.
//      If passed <code>null</code> the mask will be drawn in <code>"hard"</code> mode.
// @param   unmaskedTargets (widget | Array of widgets)
//      Widget(s) to not be occluded by the clickMask. Note that if <code>mode</code> is
//      <code>"hard"</code> only top level canvases (with no
//      +link{Canvas.getParentCanvas()}) can be unmasked. If a canvas with a parentCanvas is passed
//      in, all its ancestors will also be unmasked.<br>
//      Also note that when a widget is unmasked, all its children are also unmasked (for both
//      <code>"soft"</code> and <code>"hard"</code> masks)
//
// @return  (string)    Unique identifier for this clickMask.
// @see method:Canvas.showClickMask
//
// @visibility eventhandler
//<
_maskCount : 0,
clickMaskRegistry : [],
showClickMask : function (clickAction, mode, unmaskedTargets, maskID) {
    // Set this flag to indicate showClickMask is running, even though
    // clickMaskUp won't yet return true

    this._showingClickMask = true;

    var autoHide;
    //>!BackCompat 2006.08.31 We used to take 'autoHide' rather than 'mode' as a parameter
    // for whether a clickMask should be hard or soft.
    // If passed a boolean, just treat 'true' as soft, 'false' as hard.
    if (mode == true) {
        autoHide = true;
        mode = isc.EH.SOFT;
    } else if (mode == false || mode == null) {
        autoHide = false;
        mode = isc.EH.HARD;
    } else {
    //<!BackCompat
        // If mode is "soft" or "softCancel", autoHide is true
        autoHide = (mode != isc.EH.HARD);
    //>!BackCompat 2006.08.31
    }   //<!BackCompat

    if (unmaskedTargets == null) unmaskedTargets = [];
    else if (!isc.isAn.Array(unmaskedTargets)) unmaskedTargets = [unmaskedTargets]

    var EH = this,
        registry = EH.clickMaskRegistry,
        focusCanvas = EH.getFocusCanvas();


    if (focusCanvas == null && isc.Browser.isIE) {
        focusCanvas = EH._unconfirmedFocus;
        // EH._unconfirmedFocus can be a FormItem; get Canvas
        if (isc.DynamicForm && isc.isA.FormItem(focusCanvas)) {
            focusCanvas = focusCanvas.containerWidget;
        }
        if (focusCanvas) this.focusInCanvas(focusCanvas);
    }

    if (this.logIsInfoEnabled("clickMask")) {
        this.logInfo("showing click mask, action: " + clickAction +
                 (autoHide ? ", autoHide true " : ", autoHide false ") +
                 (maskID ? ", ID: " + maskID : "") +
                 ", focusCanvas: " + focusCanvas,
                 "clickMask");
    }

    // send mouse out the to the last mouse over target, so it doesn't get stuck in the "Over"
    // state while the clickMask is up, suppressing mouseMove/Over/Out
    // (Do this before the mask is up, otherwise this event won't be passed through to the
    // last target!)
    var lastMoveTarget = EH.lastMoveTarget;
    if (lastMoveTarget) {
        delete EH.lastMoveTarget;
        EH.handleEvent(lastMoveTarget, EH.MOUSE_OUT, null, EH.lastMoveTargetItem);
    }

    // create a entry for this mask and add it to the registry

    var mask = {
        autoHide : autoHide,
        mode:mode,
        ID : (maskID != null ? maskID : "cm_" + EH._maskCount++),
        _unmaskedTargets : {}
        //,stackTrace:this.getStackTrace()
    };

    // Add the unmasked children to the mask object

    this._applyUnmaskedTargets(unmaskedTargets, mask);
    // remember what mask was on top before this one was created.
    var topMask = registry.last();

    registry.add(mask);
    // clear the flag indicating showClickMask is running
    // [since "clickMaskUp" will now return true]
    delete this._showingClickMask;


    // the click action will fire on mouseDown outside of the unmasked targets
    mask.clickAction = clickAction;

    // blur the Canvas that currently has focus and remember which one it was, for possible
    // restoration of focus on clickMask hide
    if (focusCanvas != null && !unmaskedTargets.contains(focusCanvas) &&
        !focusCanvas._ignoreClickMaskFocus)
    {
        focusCanvas.blur("showing clickMask");
        this.setMaskedFocusCanvas(focusCanvas, mask);
    } else if (topMask != null) {
        this.setMaskedFocusCanvas(topMask._maskedFocusCanvas, mask);
    }
    var isHardMask = this.isHardMask(mask);

    // If this is a hard mask, we need to
    // - pull all masked widgets out of the page level tab order
    // - If we're already showing a screenSpan, push masked top level elements behind it

    if (isHardMask) {

        var startTime = isc.timeStamp();

        // The canvii which will be hard-masked by this mask are basically all the canvii
        // down to the next visible hard clickMask.
        // If this is the only clickMask showing, or all the other masks are soft, this is
        // just all the canvii on the page other than our unmasked targets.

        var entireCanvasList;
        if (registry.length > 1) {
            var hasHardMaskBelow = false,
                otherMasks = [];
            // our position is registry.length-1, so start at registry.length -2
            for (var i = registry.length-2; i >=0; i--) {
                otherMasks.add(registry[i]);

                if (this.isHardMask(registry[i])) {
                    hasHardMaskBelow = true;
                    break;
                }
            }

            if (hasHardMaskBelow) {
                // the 'otherMasks' will list any masks below this one up to and including the
                // first hard mask - so their unmasked targets all need to get masked.
                for (var i = 0; i < otherMasks.length; i++) {
                    var newlyMasked = otherMasks[i]._unmaskedTargets;
                    if (newlyMasked) {
                        // pass in the flag to indicate that we're passing in an object
                        // rather than an array
                        // Also pass in the flag to indicate this is being called as part of showClickMask
                        this._hardMaskTargets(newlyMasked, unmaskedTargets, true, true);
                    }
                }
            // If no hard mask below, hard mask everything except our unmaskedTargets
            } else {
                entireCanvasList = true;
                this._hardMaskTargets(isc.Canvas._canvasList, unmaskedTargets, false, true);
            }

        // If no other mask showing, hard mask everything except our unmaskedTargets
        } else {
            entireCanvasList = true;
            this._hardMaskTargets(isc.Canvas._canvasList, unmaskedTargets, false, true);
        }

    }

    // If this is the first mask being shown, show the screenSpan if necessary

    if (this.maskNativeTargets) {

        if (topMask == null) {
            this.showScreenSpan(mask);

        // catch the case where the screenSpan is already showing and needs to be moved behind
        // the top level unmasked target.
        } else if (isHardMask) {
            this._adjustSpanZIndex(mask._unmaskedTargets)
        }
    }

    // updateEventMasks()
    // Shows / Clears individual event masks over canvii if necessary
    this.updateEventMasks();


    return mask.ID;
},


// Canvas-level event masks and "soft" clickMasks:
// Some widgets contain HTML that will swallow mouse events
// (Flashlets / IFrames etc).
// If we are showing a hard mask ovr these widgets, they will now be covered by a screenSpan
// which will intercept the events before they get swallowed (ok).
// However if these widgets are "under" a soft mask, they would swallow clicks so we'd fail
// to dismiss the soft mask / fire the click mask action when the user clicked on the widget
// in question.
// Handle this by showing widget level event masks for each registered maskable canvas
// that is covered by a soft mask (but not by a hard mask)
updateEventMasks : function () {
    var registry = this.clickMaskRegistry,
        topMask = registry ? registry[registry.length-1] : null;
    if (topMask && topMask.autoHide) {
        var softMaskedCanvii = {};
        isc.addProperties(softMaskedCanvii, topMask._unmaskedTargets);

        this.showEventMasks(false, softMaskedCanvii);

    // top mask is hard ==> no need for separate widget-level event masks
    // no masks are showing ==> clear any widget-level event masks
    } else {
        this.hideEventMasks();
    }
},



// Helper method to apply unmasked targets to a mask.
// Will not actually modify the widgets' handle.

_applyUnmaskedTargets : function (unmaskedTargets, mask) {

    // call the method to combine ancestors, descendants and peers of the targets into
    // the list.
    unmaskedTargets = this._getFullSetOfTargetsToUnmask(unmaskedTargets, mask);

    for (var i = 0; i < unmaskedTargets.length; i++) {
        var target = unmaskedTargets[i];
        if (target == null) continue;
        mask._unmaskedTargets[target.getID()] = target;
    }
},


// When we unmask canvases wrt a clickMask, we must also unmask:
// - for hard masks, all ancestors of the canvii
// - all peers of the canvii
// - all descendants of the canvii
// Call this method to add these additional canvii into the list to be unmasked
// Directly effects the list passed in (and returns the modified list)
_getFullSetOfTargetsToUnmask : function (unmaskedTargets, mask) {


    if (!unmaskedTargets || unmaskedTargets.length == 0 || !mask) return unmaskedTargets;

    // If we're passed any IDs, convert to pointers to the widget
    for (var i = 0; i < unmaskedTargets.length; i++)
        unmaskedTargets[i] = this._getCanvas(unmaskedTargets[i]);

    // If we are creating a hard mask, ensure that we include all ancestors of any unmaskedTargets
    // passed in.
    var alreadyUnmasked = mask._unmaskedTargets;
    if (!mask.autoHide && unmaskedTargets.length > 0) {
        var length = unmaskedTargets.length;
        for (var i = 0; i < length; i++) {
            var target = unmaskedTargets[i];
            if (target.topElement && !alreadyUnmasked[target.topElement.getID()] &&
                                     !unmaskedTargets.contains(target.topElement))
            {
                this.logWarn(
                    "Attempting to unmask target canvas:" +
                     target.getID() + " with respect to a hard click mask. " +
                     "This is not a top level Canvas - all ancestors of "+
                     "this Canvas will also be unmasked.", "clickMask"
                );
                unmaskedTargets.add(target.topElement);
            }
        }
    }

    // also recursively mask any peers of the targets.
    // Use cases: scrollbars, shadows, edge-canvii, etc.
    // - Note this is only necessary for the highest level targets being masked, since
    //   peers are at the same level in widget hierachy, so get masked (along with other
    //   descendants) when the higher level parent is masked
    this._combineTopPeersIntoList(unmaskedTargets);

    // this method will modify the unmaskedTargets to include all descendants recursively.
    this._combineDescendantsIntoList(unmaskedTargets);

    return unmaskedTargets;
},


// Helper methods for determining targets to mask/unmask - takes a list of widgets and
// recursively adds children of each widget to the list
_combineDescendantsIntoList : function (list) {
    var originalLength = list.length;
    for (var i = 0; i < originalLength; i++) {
        if (list[i] == null) continue;
        this._addDescendantsToList(list[i], list);
    }
},

// - Called directly from maskTargets(), addPeersToList, and _combineDescendantsIntoList()
_addDescendantsToList : function (widget, list, recursive) {

    // On the first (non-recursive) call we know that the widget is already in the list.
    if (recursive && !list.contains(widget)) list.add(widget);
    if (widget.children) {
        for (var i = 0; i < widget.children.length; i++) {
            this._addDescendantsToList(widget.children[i], list, true);
        }
    }

    // CanvasItems and containerWidgets
    // DynamicForm items can be rendered into a masked containerWidget, but the form itself be
    // unmasked (we do this for ListGrid editing where the editorForm is unmaksed, but the
    // Listgrid body is masked so a click outside an edit item dismisses the editor).
    // Currently if the form contains any CanvasItems the canvasItems will NOT be unmasked in
    // this case since their parent is masked.
    // We need to handle this case if we want to support modalEditing and CanvasItems.
    // In order to handle this:
    // - when adding unmasked targets, if a DF is an unmasked target we ensure any CanvasItems'
    //   canvii are also unmasked even if they're contained in a different containerWidget
    // - in CanvasItem, when adding the canvas to the containerWidget as a child we explicitly check
    //   for the DF being unmasked and unmask explicitly if necessary.
    if (isc.DynamicForm && isc.CanvasItem && isc.isA.DynamicForm(widget)) {
        var items = widget.getItems() || [];
        for (var i = 0; i < items.length; i++) {
            if (items[i].containerWidget == widget) continue;
            if (isc.isA.CanvasItem(items[i]) && isc.isA.Canvas(items[i].canvas)) {
                this._addDescendantsToList(items[i].canvas, list, true);
            }
        }
    }

},

// Helper methods for determining targets to mask/unmask - takes a list of widgets and
// recursively adds peers (and descendents thereof) of the highest level widgets to the list
_combineTopPeersIntoList : function (list) {
    for (var i = 0, length = list.length; i < length; i++) {
        var t = list[i];
        if (t.parentElement && list.contains(t.parentElement)) continue;
        this._addPeersToList(list[i], list);
    }
},

// - Called directly from maskTargets() and _combineTopPeersIntoList()
_addPeersToList : function (widget, list, recursive) {
    if (recursive && !list.contains(widget)) list.add(widget);
    var peers = widget.peers;
    if (peers) {
        for (var i = 0; i < peers.length; i++) {
            this._addPeersToList(peers[i], list, true);
        }
    }

    // We also want to pick up descendants of peers.
    // (example might be a button with a floating label title)
    this._addDescendantsToList(widget, list);
},


// Given the ID of a click mask return a pointer to the mask object itself

_$ID:'ID',
getClickMask : function (ID) {
    var registry = this.clickMaskRegistry;
    if (isc.isAn.Object(ID)) {
        return registry.contains(ID) ? ID : null;
    }
    return registry.find(this._$ID, ID);
},

changeClickMaskID : function (oldID, newID) {
    var mask = this.getClickMask(oldID);
    if (mask) mask.ID = newID;
},

// is a specific click mask "hard" (IE should suppress events from passing through it) or "soft"
// (Should respond to clicks but not mask events).

isHardMask : function (mask) {
    if (!isc.isAn.Object(mask)) mask = this.getClickMask(mask);
    return mask == null ? false : (mask.mode == isc.EH.HARD);
},

getTopHardMask : function () {
    var registry = this.clickMaskRegistry;
    for (var i = registry.length -1; i >= 0; i--) {
        if (this.isHardMask(registry[i])) return registry[i];
    }
    return null;
},

// Given an array of widgets, ensure they are "hard masked".
// This means they are obscured by the screenSpan
// [If we're in the process of showing a clickMask, this is handled by the calling method]
// Their accessKey is cleared, if necessary.
// no update to tabIndex is necessary
_hardMaskTargets : function (widgets, unmaskedTargets, targetsAsObject, fromShowClickMask) {
    if (!widgets) return;

    //this.logWarn("masking widgets: " + widgets +
    //             ", unmaskedTargets is: " + this.echo(unmaskedTargets));

    // Allows us to pass in an 'unmaskedTargets' object on a mask which is a map like this:
    // {canvasName:true, canvasName:true, ...}
    if (targetsAsObject) {
        for (var canvasName in widgets) {
            var canvas = widgets[canvasName];
            this._hardMaskTarget(canvas, unmaskedTargets, fromShowClickMask);
        }
    } else {
        for (var i = 0; i < widgets.length; i++) {
            var canvas = this._getCanvas(widgets[i]);
            this._hardMaskTarget(canvas, unmaskedTargets, fromShowClickMask);
        }
    }

},

// Actually hard mask a target
_hardMaskTarget : function (canvas, unmaskedTargets, fromShowClickMask) {

    // handle the case where some member of the canvas list is not a valid canvas

    if (!isc.isA.Canvas(canvas) || canvas.destroyed) {
        isc.Log.logWarn(
            "showClickMask - attempting to remove invalid object :" +
             isc.Log.echo(canvas) +
            " from tab order",
            "clickMask"
        );
        return;
    }


    // Don't actually mask anything that's explicitly unmasked
    if (unmaskedTargets && unmaskedTargets[canvas.getID()]) return;



    if (canvas.isDrawn()) {

        // we just need to ensure that the top-parent of the masked canvii is behind the span
        // Note: we are guaranteed to have the top-parent in the unmasked canvii already, so skip
        // any non top level widgets
        if (canvas.getParentCanvas() == null) {
            // Widgets to show behind the screenspan - 2 possibilities:
            // - the mask is in the process of being shown:
            //  o If this is the only mask up, we haven't yet created the screenSpan, but when
            //    we do we'll position it over all top level masked widgets
            //  o If the span is already showing due to another mask below us, we'll adjust the
            //    zIndex at the end of the showClickMask method
            //  [Therefore no action to take in this case]
            // - this mask is already showing and this method was called from maskTarget(), so
            //   we need to sink this widget explicitly behind the screenSpan.
            if (!fromShowClickMask && this._screenSpan && this._screenSpan.isDrawn() &&
                canvas.getZIndex() >= this._screenSpan.getZIndex())
            {
                //>DEBUG
                this.logDebug("lowering zIndex of: " + canvas, "clickMask");
                //<DEBUG


                canvas.setZIndex(isc.EH._screenSpan.getZIndex() -1);
            }


        }
    }

    // clear the accessKey from the canvas - note that we don't have to clear the
    // tabIndex as we explicitly manage tab-keypresses while the mask is up
    if (canvas.accessKey != null && canvas.isDrawn()) {
        canvas._setHandleAccessKey(null);
    }
},


//>    @classMethod    EventHandler.hideClickMask()    (A)
//  Hide the click mask.
// @param [ID]  (string)
//      Which clickMask to hide?  If not specified, hide all clickMasks.
// @group clickMask
// @see EventHandler.showClickMask()
// @see method:canvas.hideClickMask
// @visibility eventhandler
//<
hideClickMask : function (ID) {



    if (this.logIsInfoEnabled("clickMask"))
        this.logInfo("hideClickMask called with ID: " + ID, "clickMask");

    var registry = this.clickMaskRegistry;
    // Ensure we have at least one CM showing
    if (registry.length == 0) return;

    // if there's no ID, just hide all clickmasks
    if (ID == null) {

        // Hide the first CM in the array
        this.hideClickMask(registry[0].ID)

        // call this method with no ID again (will hide the next item in the array, and so on)
        if (registry.length > 0) {
            this.hideClickMask();
        } else {
            this.logInfo("all clickmasks hidden", "clickMask");
        }
        return;
    }

    var mask = this.getClickMask(ID);

    // if we were passed a bad ID just return (the CM in question's probably already hidden!)
    if (mask == null) return;

    //this.logWarn("hiding mask that had unmasked targets: " + this.echo(mask._unmaskedTargets));

    // At this point we're working with a specific mask in the registry.

    // Get all the information we need from the clickMask being destroyed, and remove it from
    // the clickMaskRegistry
    var index = registry.indexOf(mask),
        isTopMask = (index == (registry.length -1)),
        isHardMask = this.isHardMask(mask),
        nextMaskDown = (index > 0 ? registry[index -1] : null),
        isTopHardMask,
        nextHardMaskDown;

    if (this.logIsInfoEnabled("clickMask")) {
        var msg = "hiding clickMask ID: " + ID;
        if (isHardMask) msg += "[autoHide:false]";
        else msg += "[autoHide:true]";
        if (registry.length < 2) {
            msg += ", all masks hidden";
        } else {
            // report index
            msg += " with index: " + index + " of " + (registry.length - 1);
        }
        this.logInfo(msg, "clickMask");
    }

    // If this is a 'hard' clickMask with no hard mask on top of it,
    // hard unmask any unmasked newly targets
    if (isHardMask) {
        nextHardMaskDown = this._getNextHardMask(index, false);
        var nextHardMaskUp = this._getNextHardMask(index, true);
        isTopHardMask = (nextHardMaskUp == null);
    }

    var focusCanvas = mask._maskedFocusCanvas,
        unmaskedTargets = mask._unmaskedTargets;
    // Actually remove the clickMask from the registry at this point

    registry.remove(mask);

    // At this point
    // - if we hid the topmost mask we need to restore focus to the previous focus widget
    // - if the mask we hid had another mask under it, we need to notify that mask of this
    //   mask's unmaskedTargets
    // - if we hid the only visible mask we need to hide the screenSpan
    // - if we hid a hard mask
    //    - if there's a hard mask below it, the screenspan should go behind that mask's
    //      unmaskedTargets
    //    - otherwise we need to shift the screenSpan to the back of the visible set of widgets.

    // If we have a 'nextMaskDown', update it with the focus canvas, etc.
    if (nextMaskDown != null) {

        if (unmaskedTargets != null) {
            if (nextMaskDown._unmaskedTargets == null) nextMaskDown._unmaskedTargets = {};
            isc.addProperties(nextMaskDown._unmaskedTargets, unmaskedTargets);
        }

        // We attempt to focus on the maskedFocusCanvas below... but if it's still masked
        // we can't.
        // Instead record the maskedFocusCanvas on the next mask down
        if (focusCanvas && !nextMaskDown._unmaskedTargets[focusCanvas.getID()]) {
            this.setMaskedFocusCanvas(focusCanvas, nextMaskDown);
        }
    }

    if (this._screenSpan) {
        // if this is the only mask showing, hide the screenspan
        // True whether soft or hard
        if (isTopMask && nextMaskDown == null) {

            if (isc.Browser.isIE) {
                isc.Timer.setTimeout({target:this._screenSpan, methodName:"hide"}, 0);
            } else {
                this._screenSpan.hide();
            }

        // If we're hiding the top-most hard mask we need to reposition the screenspan
        } else if (isTopHardMask) {
            if (nextHardMaskDown) {
                // slot the screenspan behind all unmasked targets down to the next hard-mask
                // (May be soft masks over that hard mask - have to put the screenspan behind those
                // unmasked targets)
                var unmaskedTargets = isc.addProperties({}, nextHardMaskDown._unmaskedTargets);
                var currentMaskIndex = registry.length-1,
                    currentMask = registry[currentMaskIndex];
                while (currentMask != nextHardMaskDown) {
                    isc.addProperties(unmaskedTargets, currentMask._unmaskedTargets);
                    currentMaskIndex--;
                    currentMask = registry[currentMaskIndex];
                }
                this._adjustSpanZIndex(unmaskedTargets);
            } else this._screenSpan.sendToBack();
        }

        // If this was a hard mask we need to ensure that all newly revealed targets
        // ("unmaskedTargets" of the mask below if there was one, otherwise all canvii)
        // have their accessKeys cleared

        if (isHardMask) {

            var unmasked;
            if (nextHardMaskDown != null) {
                unmasked = [];
                // iterate through each of the masks below us up to (and including) the
                // hard mask below us, to determine which widgets will be no longer be
                // hard-masked when this mask is hidden.
                for (var i = index-1; i >= 0; i--) {
                    var lowerMask = registry[i];
                    unmasked.addList(isc.getKeys(lowerMask._unmaskedTargets));
                    if (lowerMask == nextHardMaskDown) break;
                }
            } else {
                // everything is unmasked

                unmasked = isc.Canvas._canvasList;
            }

            // Call _hardUnmaskTargets to restore accessKeys.
            this._hardUnmaskTargets(unmasked, true);
        }

        // If we have a masked focus canvas, focus on it if it's unmasked
        if (focusCanvas != null && !focusCanvas.destroyed && !this.targetIsMasked(focusCanvas)
            && !focusCanvas._keyboardEventsDisabled)
        {
            if (this.logIsInfoEnabled("clickMask")) {
                this.logInfo("focusing in " + focusCanvas + " on clickMask hide " +
                             "with current focusCanvas: " + isc.EH._focusCanvas, "clickMask");
            }


            var delayedFocus = (isc.Browser.isIE && this.lastEvent.eventType == this.MOUSE_DOWN)

            if (delayedFocus) {
                this._delayedFocusTarget = focusCanvas;
            } else {
                // We've seen an "Unexpeced call to method or property access with the
                // following stack in IE:
                // Canvas.setFocus(_1=>true) Canvas.focus()
                // EventHandler?.hideClickMask(_1=>"isc_globalPrompt")
                // Canvas.hideClickMask(_1=>undef) Window.clear(_1=>undef, _2=>undef, _3=>undef, _4=>undef) [a]Dialog.clearMessage() anonymous()
                // RPCManager.doClearPrompt(_1=>Obj) RPCManager.$528(_1=>23)
                //
                // so encase in try/catch block
                try {
                    focusCanvas._restoreFocusForClickMaskHide();
                } catch (e) {}
            }
        }
    }

    // updateEventMasks()
    // Shows / Clears individual event masks over canvii if necessary
    this.updateEventMasks();

    // If we hid the bottom mask, but other masks are showing on top of it, we currently
    // do nothing.
    // This is appropriate with 'unmaskedTargets', since nothing will be masked below
    // this widget.
    // We passed the 'maskedFocusCanvas' from up to the masks above it when we showed them (when
    // appropriate), so it should not matter that we're dropping the masked focus canvas for the
    // bottom mask.
},

// Given a clickMask in the registry determine the index of the next hard mask above or below
// it.
_getNextHardMask : function (maskIndex, above) {

    var registry = this.clickMaskRegistry;

    if (above) {
        for (var i = maskIndex+1; i < registry.length; i++) {
            if (this.isHardMask(registry[i])) return registry[i];
        }
    } else {
        for (var i = maskIndex-1; i >=0; i--) {
            if (this.isHardMask(registry[i])) return registry[i];
        }
    }
    // No hard mask was found above (or below) this mask
    return null;
},

// Resolve a canvas ID (or pointer to a canvas) to a canvas.
_getCanvas : function (canvas) {
    if (isc.isA.String(canvas)) return window[canvas];
    return canvas;
},


// Ensure widgets are not "hard masked"
_hardUnmaskTargets : function (widgets, fromHideClickMask) {
    if (!widgets || widgets.length == 0) return;

    for (var i = 0; i < widgets.length; i++) {
        // We pass either an array of widgets or an array of widget IDs - so we need to resolve
        // these to canvii
        var canvas = this._getCanvas(widgets[i]);
        if (!canvas) continue;

        // If we cleared the accessKey, reset it now
        if (canvas.accessKey != null && canvas.isDrawn()) {
            canvas._setHandleAccessKey(canvas.accessKey);
        }


        if (!canvas.isDrawn() && isc.isA.DynamicForm && isc.isA.DynamicForm(canvas) &&
            canvas.items && canvas.items.length > 0)
        {
            var item = canvas.items[0];

            if (item.containerWidget != canvas) canvas = item.containerWidget;
        }

        // Ensure that the canvas isn't obscured by the screenSpan
        // If the top level targets are behind the screenSpan, move it above it.

        if (!fromHideClickMask && canvas.getParentCanvas() == null &&
            canvas.getZIndex() <= this._screenSpan.getZIndex() &&
            canvas != this._screenSpan)
        {
            canvas.setZIndex(this._screenSpan.getZIndex() +1);
            //>DEBUG
            this.logDebug("raised above screenspan: " + canvas, "clickMask");
            //<DEBUG
        }
    }

},

//>    @classMethod    EventHandler.clickMaskUp()    (A)
//  Determine whether a clickMask is currently showing.
//
// @param [ID]  (string)
//      Which clickMask to check?  If not specified, check whether any clickMask is showing.
// @group clickMask
// @return (boolean)    true if the click mask is showing
// @visibility eventhandler
//<
clickMaskUp : function (ID) {
    var registry = this.clickMaskRegistry;

    if (ID == null) return (registry.length > 0);
    else return (registry.find("ID", ID) != null);
},


//>    @classMethod    EventHandler.getAllClickMaskIDs()    (A)
//  Get the IDs for every click mask that's currently up.
// @group clickMask
// @return (Array)  Array of clickmask ID strings.
// @visibility internal
//<
getAllClickMaskIDs : function () {
    var registry = this.clickMaskRegistry;
    if (registry.length < 1) return [];

    return registry.getProperty("ID");
},

//>    @classMethod    EventHandler.showScreenSpan()    (A)
// @visibility internal
//<
showScreenSpan : function (mask) {

    if (!this._screenSpan) {
        this._screenSpan = isc.ScreenSpan.create(
            {ID:"isc_EH_screenSpan",
             // If the screenspan gets destroyed, have it clear up our pointer to it.
             pointersToThis:[{object:this, property:"_screenSpan"}]
            },
            this.clickMaskProperties
         );
    }
    var span = this._screenSpan;
    span.show();

    if (!this.isHardMask(mask)) {
        span.sendToBack();
    } else {
        this._adjustSpanZIndex(mask._unmaskedTargets);
    }
},

// We show the screenSpan for clickMasks to suppress native interactions with DOM element such
// as form elements / links
_adjustSpanZIndex : function (unmaskedTargets) {
    // set a flag so we don't respond to 'bringToFront()' calls on widgets by 'unmasking' them

    this._adjustSpanZIndexRunning = true;

    var zIndex;
    for (var ID in unmaskedTargets) {
        var canvas = this._getCanvas(ID);
        // We only need to move the top level unmasked targets above the screenSpan.


        if (!canvas || canvas.destroyed || canvas.getParentCanvas() != null) {
            continue;
        }

        // If the canvas is a peer of an unmasked master, assume the masterElement manages
        // the zIndex of the peer, rather than calling bringToFront() here.
        // Avoids, for example, a shadow showing up in front of its target widget.

        if (canvas.getMasterCanvas() && unmaskedTargets[canvas.getMasterCanvas().getID()]) continue;

        canvas.bringToFront();
        if (zIndex == null) zIndex = canvas.getZIndex(true);

        // Remember zIndex is going to be the lowest zIndex of all unmasked canvii so we can
        // slot the screenSpan underneath it.
        // We know that all peers unmask with their master (and allow the master to
        // handle assigning the zIndex), so ensure the zIndex of the span is less than
        // the zIndex of any peers.

        if (canvas.peers) {
            for (var i = 0; i < canvas.peers.length; i++) {
                if (!canvas.peers[i].isDrawn()) continue;
                zIndex = Math.min(zIndex, canvas.peers[i].getZIndex(true));
            }
        }
    }


    if (zIndex != null) this._screenSpan.setZIndex(zIndex -1);
    else this._screenSpan.bringToFront();

    this._adjustSpanZIndexRunning = false;

},

//> @classMethod    isc.EventHandler.maskTarget()
//
//      Ensure that a widget (or array of widgets) is below (obscured by) by the clickMask.
//
//      @group  clickMask
//      @param  target      (widget | Array of widgets)
//                  target[s] to unmask
//      @param  [maskID]    (string)
//                  ID of clickmask to move this target below.  If not passed in, will move below
//                  all visible clickMasks
//  @visibility eventhandler
//<

maskTarget : function (target, maskID) {
    // synonym for maskTargets
    return this.maskTargets(target, maskID);
},

//> @classMethod    isc.EventHandler.maskTargets()
//
//      Synonym for +link{classMethod:EventHandler.maskTarget()}
//
//      @group  clickMask
//      @param  target      (widget | Array of widgets)
//                  target[s] to unmask
//      @param  [maskID]    (string)
//                  ID of clickmask to move this target below.  If not passed in, will move below
//                  all visible clickMasks
// @visibility eventhandler
//<
maskTargets : function (targets, maskID, dontMaskChildren) {

    var registry = this.clickMaskRegistry;
    if (targets == null || registry.length == 0) return;

    if (!isc.isAn.Array(targets)) targets = [targets];
    else if (targets.length == 0) return;

    var mask =  (maskID == null ? registry[0] :
                    (isc.isA.String(maskID) ? this.getClickMask(maskID) : maskID)
                );

    // If we couldn't get a mask, bail.
    if (mask == null) {
        // log at the info level -- this is likely to happen if the mask was hidden already, so
        // a logWarn is a little strong
        this.logInfo("maskTargets called with invalid maskID - returning.", "event")
        return;
    }

    // At this point we have a valid mask and a set of targets to mask.

    // Iterate through targets adding any children or ancestors that need to also get masked
    var originalTargetsLength = targets.length
    for (var i = 0; i < originalTargetsLength; i++) {

        var target = targets[i];

        // By default if this method is called we will mask all the widget's children as well as
        // the widget itself. This means if you call (for example) 'mask' on a currently unmasked
        // ListGrid, the body will also get masked.
        if (!dontMaskChildren && target.children != null) {
            this._addDescendantsToList(target, targets);
        }

        // We support having a parent be masked but a child be unmasked, but not a child be masked
        // but its parent be unmasked.
        // Therefore we will also iterate up through this widget's ancestor chain, masking all
        // ancestors -- but not all of their children as this could mask just about everything on
        // the page if one of our targets is a child of a pageLayout, for example.
        //
        // Also: Always mask / unmask peers with their masters
        // Use cases: Scrollbars, edged canvii, etc

        var parent = target.parentElement;
        while (parent != null) {
            if (!targets.contains(parent)) {
                targets.add(parent);
                if (dontMaskChildren) this._addPeersToList(parent, targets);
            }
            parent = parent.parentElement;
        }

        // At this point 'parent' is the top-level element, if defined
        if (dontMaskChildren || !parent) {
            this._addPeersToList(target, targets);
        }
        if (parent) this._addPeersToList(parent, targets);
    }

    // Now actually mask every target
    // When masking a widget we're essentially moving it down some number of layers in
    // the clickmask stack. (The simplest case of course is moving it from top to bottom).


    var maskIndex = registry.indexOf(mask);

    // Determine where the top hard mask is above / including this mask.
    // This will be used to determine whether the widget(s) being masked need to be hard masked
    var topHardMask;
    for (var i = maskIndex; i < registry.length; i++) {
        currentMask = registry[i];
        if (this.isHardMask(currentMask)) topHardMask = i;
    }

    var targetsToHardMask;
    if (topHardMask != null) targetsToHardMask = [];
    for (var n = 0; n < targets.length; n++) {
        var target = targets[n];
        // always blur if it has focus.
        if (target.hasFocus && !target._ignoreClickMaskFocus) target.blur();

        var currentMask,
            topHardMask,
            targetLevel = null;

        for (var i = maskIndex; i < registry.length; i++) {
            currentMask = registry[i];
            if (currentMask._unmaskedTargets[target.getID()]) {
                targetLevel = i;
                // Always remove 'masked' targets from the masks' "unmaskedTargets" lists
                var map = currentMask._unmaskedTargets;
                if (map[target.getID()] === target) delete map[target.getID()];

            }
        }

        // If the target was unmasked wrt the top hard mask we need to hard mask it now.
        if (topHardMask != null && targetLevel != null && (topHardMask <= targetLevel)) {
            targetsToHardMask.add(target);
        }
    }
    // HardMaskTargets will handle
    // - putting the targets behind the screenSpan if necessary
    // - getting rid of accessKey on the handle.
    if (topHardMask != null) this._hardMaskTargets(targetsToHardMask, null, false, false);
},

//> @classMethod    isc.EventHandler.addUnmaskedTarget()
//
//      Ensure that a widget (or array of widgets) is not masked by the clickMask.
//
//      @group  clickMask
//      @param  target      (widget | Array of widgets)
//                  target[s] to unmask
//      @param  [maskID]    (string)
//                  ID of clickmask to move this target above.  If not passed in, will move above
//                  all visible clickMasks
// @visibility eventhandler
//<
addUnmaskedTarget : function (target, maskID) {
    // synonym for addUnmaskedTargets
    return this.addUnmaskedTargets(target, maskID);
},

//> @classMethod    isc.EventHandler.addUnmaskedTargets()
//
//      Synonym for addUnmaskedTarget.
//
//      @group  clickMask
//      @param  target      (widget | Array of widgets)
//                  target[s] to unmask
//      @param  [maskID]    (string)
//                  ID of clickmask to move this target above.  If not passed in, will move above
//                  all visible clickMasks
// @visibility eventhandler
//<
// @param [recursive] (boolean) Internal debugging parameter indicating this is a call from
//      within an addUnmaskedTargets() call, adding children of some target to the unmasked
//      targets list

addUnmaskedTargets : function (targets, maskID) {

    // avoid unmasking targets in response to adjusting z-index as part of adjustSpanZIndex
    if (isc._unmaskOnBringToFront && this._adjustSpanZIndexRunning) return;

    var registry = this.clickMaskRegistry;
    if (targets == null || registry.length == 0) return;
    // support 'targets' being an array or a single widget
    if (!isc.isAn.Array(targets)) targets = [targets];

    if (targets.length == 0) return;
    var mask;

    // if passed no mask ID, completely unmask (so add to TOP mask's list of unmaskedTargets)
    if (maskID == null) {
        mask = registry.last();
    } else {
        if (isc.isA.String(maskID)) mask = this.getClickMask(maskID);
        // support being passed a mask object as well as an ID
        else mask = maskID;
    }
    // If we couldn't get a mask, bail.
    if (mask == null) {
        // log at the info level -- this is likely to happen if the mask was hidden already, so
        // a logWarn is a little strong
        this.logInfo("addUnmaskedTargets called with invalid maskID - returning.", "clickMask")
        return;
    }

    // If we're "hard unmasking" anything, we need to ensure we hard unmask its ancestors as
    // well as children. We don't support a masked parent with unmasked children for
    // hard masks.
    var hardMask = mask;
    while (hardMask && !this.isHardMask(hardMask)) {
        hardMask = registry[registry.indexOf(hardMask) -1];
    }
    if (hardMask != null) {

        if (isc._unmaskOnBringToFront && targets.length == 1 && targets[0].topElement != null) {
            //this.logWarn("not treating bringToFront as unmask because widget is not top-level: " +
            //             targets[0] + ", topElement: " + targets[0].topElement);
            return;
        }
    }

    // Combine ancestors (where appropriate), peers, descendants into the unmaskedTargets list
    targets = this._getFullSetOfTargetsToUnmask(targets, mask);

    //>DEBUG
    if (this.logIsDebugEnabled("clickMask")) {
        this.logDebug("Added unmasked targets:" + targets.getProperty("ID") +
                      " [+ decendants] to clickMask with ID: " + mask.ID , "clickMask");
    }
    //<DEBUG

    var hardMaskAbove = false;
    for (var i = registry.indexOf(mask)+1; i < registry.length; i++) {
        if (this.isHardMask(registry[i])) hardMaskAbove = true;
    }

    for (var n = 0; n < targets.length; n++) {
        var target = targets[n];


        if (mask._unmaskedTargets == null) mask._unmaskedTargets = {};
        mask._unmaskedTargets[target.getID()] = target;
    }

    // Each target will be unmasked relative to the mask in question and any masks
    // underneath it
    // If it was previously masked by a hard mask, and there is no hard mask ABOVE this one
    // we need to shift above the screenSpan / reset accessKey

    if (!hardMaskAbove) {
        this._hardUnmaskTargets(targets);
    }
},

//> @classMethod isc.EventHandler.targetIsMasked() (A)
// Return whether this Canvas is masked by a clickMask (see +link{Canvas.showClickMask()}).
//
// @param target (Canvas) widget to check
// @return (Boolean)   true if masked, false if not masked.
// @group clickMask
// @visibility external
//<
// Internal-only parameters:
// @param [maskID] (string) ID of click mask to check against - if not passed in, method
//                          will determine whether the widget is above the top clickMask.
// @param [hardMaskedOnly] (boolean) whether to consider only hard masks when checking
//                                   for masking
targetIsMasked : function (target, maskID, cancelOnly, item) {
    var registry = this.clickMaskRegistry;
    if (registry.length == 0) return false;

    // if we weren't given a target, a clickmask is up and the event occurred over a
    // native page element rather than a widget - so the target is masked.
    if (target == null) return true;

    // If we weren't passed a maskID, just look at the topmost mask
    var mask;
    if (maskID == null) mask = registry.last();
    else if (isc.isA.String(maskID)) mask = registry.find("ID", maskID);
    else mask = maskID;
    if (!isc.isAn.Object(mask)) {
        this.logWarn("EventHandler.targetIsMasked() passed invalid maskID:" + maskID,
                     "clickMask");
        return false;
    }

    var initialIndex = registry.indexOf(mask);
    var wouldCancelClick = false;
    for (var i = initialIndex; i < registry.length; i++) {
        // On the first iteration we already have a pointer to the mask
        if (i != initialIndex) mask = registry[i];

        // consider only masks that would cancel a click
        if (cancelOnly) {
            if (mask.mode == isc.EH.HARD || mask.mode == isc.EH.SOFT_CANCEL) {
                wouldCancelClick = true;
            } else {
                //this.logWarn("ignoring mask with mode: " + mask.mode);
                continue;
            }
        }

        if (mask._unmaskedTargets) {
            if (mask._unmaskedTargets[target.getID()]) return false;


            if (isc.DrawItem && isc.isA.DrawItem(target)) {
                var pane = target.drawPane;

                if (pane && pane.getID && mask._unmaskedTargets[pane.getID()]) return false;
            }

            // Special case: form items written into an unmasked container item should be treated as
            // unmasked (even if the form itself is masked)


            if (isc.isA.DynamicForm!=null && isc.isA.DynamicForm(target)) {
                if (!item && isc.EH.lastEvent.target == target) {
                    item = isc.DynamicForm._getEventTargetItem();
                }
                if (item && item.containerWidget != target &&
                    mask._unmaskedTargets[item.containerWidget.getID()]) return false;
            }
        }
    }

    return (cancelOnly && !wouldCancelClick ? false : true);
},

//> @classMethod    isc.EventHandler.clickMaskClick()
//
//      Called when a mouseDown occurred over a widget that may be masked by a clickMask.
//      If the target is masked, fire the appropriate clickMask action.
//      Returns true if the target is not masked, or the clickMask auto-hides (allows the
//      mouseDown event to proceed to it's target)
//      Returns false if the target is masked, and the clickMask is hard or has mode "softCancel" --
//      prevents the target from recieving the mouseDown event.
//
//      @group  clickMask
//      @param  target  (widget)    target of the mouseDown event.
//      @return         (boolean)
//          True to allow the mouseDown event to proceed, false to cancel the event.
//      @visibility internal
//<
clickMaskClick : function (target) {

    // copy the clickMaskRegistry, so we don't get confused if the registry is modified by
    // the click action showing additional masks(for example)
    var maskReg = this.clickMaskRegistry.duplicate(),
        mask = maskReg.last();

    while (mask != null && (this.targetIsMasked(target) || target == this._screenSpan)) {
        if (this.logIsInfoEnabled("clickMask")) {
            this.logInfo("mouseDown on masked " + target +
                          (mask.clickAction != null ? " firing clickAction, " : "") +
                          (mask.autoHide ?
                            "will hide mask" +
                                (mask.mode == isc.EH.SOFT_CANCEL ? " and block click" : "") :
                           "will block click"));
        }
        var cancel = (mask.mode != isc.EH.SOFT);
        this._clickMaskClick(mask)


        // If the mask is hard return false to cancel the event -- we're done
        if (cancel) return false;

        // If the mask is soft (and not "softCancel"), fire clickMaskClick on the mask underneath it
        mask = maskReg[maskReg.indexOf(mask) -1];
    }

    // if we got here we've hit an unmasked target (possibly after hiding some autoHide true CM's)
    return true;
},

// actually fire the click action and (if appropriate) hide the mask.
_clickMaskClick : function (mask) {

    var autoHide = mask.autoHide,
        clickAction = mask.clickAction;

    if (autoHide == true) this.hideClickMask(mask.ID);

    // Fire the action if there is one.
    // Note: we don't care about the return value from the clickAction.
    if (clickAction != null) this.fireCallback(clickAction);
}

});    // END isc.EventHandler.addClassMethods()

// call captureEvents now to set things up for our event handling.
isc.EventHandler.captureEvents();




//------------------------------------------------------------------------------------
// full duplex RPC over Messaging
//
// MessagingDMISocket binds a Messaging channel to receive responses and pairs requests sent
// through it with responses to those requests - exposing a simple send(payload, callback)
// mechanism
isc.defineClass("MessagingDMISocket").addProperties({

// This is the channel we register with Messaging for receiveing realtime push updates from the
// server.
receiveChannel: null,

// how long we wait for a reply before deleting the outstandingRequest
defaultRequestTimeout: 300000,  // 5 min
// how often the request reaper timer runs
requestReaperInterval: 5000,

// unique identifier for the request we send - we use these to pair responses with requests
sequence: 0,

// requests waiting to be sent pending Messaging channel subscription
pendingRequests: null,

// outstanding requests for which we are waiting on a response to our private channel
// XXX: how do we handle failure to respond?  implement timeouts?
outstandingRequests: null,


init : function () {
    this.Super("init");

    // Note: must init here so we definitely have an instance copy...sigh
    this.pendingRequests = [];
    this.outstandingRequests = [];

    // this is for direct binding, but create regardless because a receiving server socket can
    // support both remote and direct binding modes concurrently - but needs an ID to work with
    // direct binding
    this.ns.ClassFactory.addGlobalID(this);
    // likewise for the queue
    this.directBindingQueue = [];

    // force directBindingOnly if we are passed a directBinding target
    if (this.directBinding) this.directBindingOnly = true;

},

bind : function (callback) {
    var _this = this;
    this.logDebug("bind");

    if (!this.receiveChannel) {
        this.logError("Unable to bind null receiveChannel");
        return;
    }

    if (this.directBindingOnly) {
        this._bound = true;
        if (callback) this.fireCallback(callback);
        return;
    }

    if (!isc.Messaging) {
        this.logError("Messaging not available - unable to bind() socket");
        return;
    }



    isc.Messaging.isRemoteDebug = this.isRemoteDebug;
    isc.Messaging.subscribe(
        this.receiveChannel,
        function (data) {
           _this.receive(data);
        },
        function () {
            _this._bound = true;
            if (callback) _this.fireCallback(callback);
        }
    );
    delete isc.Messaging.isRemoteDebug;
},
close : function (callback) {
    if (!this.directBindingOnly) isc.Messaging.unsubscribe(this.receiveChannel);

    delete this._bound;
    this._clearReaperTimer();
    if (callback) this.fireCallback(callback);
},

_clearReaperTimer : function () {
    isc.Timer.clear(this._requestReaperTimer);
    delete this._requestReaperTimer;
},
_setReaperTimer : function (timeout) {
    this._clearReaperTimer();
    var _this = this;
    this._requestReaperTimer = isc.Timer.setTimeout(function () {
        _this._reapTimedOutRequests();
    }, timeout);
    this._nextReap = isc.timeStamp()+timeout;
},
_reapTimedOutRequests : function () {
    var now = isc.timeStamp();
    var timeToNextReap = -1;
    for (var i = 0; i < this.outstandingRequests.length;) {
        var request = this.outstandingRequests[i];
        if (now >= request.expiresAt) {
            this.outstandingRequests.removeAt(i);
            if (this.logIsDebugEnabled()) {
                this.logDebug("Reaped request: " + isc.echo(request));
            }
        } else {
            i++;
            // schedule nextReap for the next expiring request
            if (timeToNextReap == -1) timeToNextReap = request.timeout;
            else if (request.timeout < timeToNextReap) timeToNextReap = request.timeout;
        }
    }
    if (timeToNextReap != -1) this._setReaperTimer(timeToNextReap);
},

getNextSequence : function () {
    this.sequence += 1;
    return this.sequence;
},
send : function (sendChannel, payload, callback, packetProperties, requestProperties) {
    // a packet is what we actually send to the server - it contains the payload and additional
    // properties that allow the remote endpoint to properly respond
    var packet = isc.addProperties({
        payload: payload,
        sequence: this.getNextSequence(),
        originChannel: this.receiveChannel,
        expectsReply : callback != null
    }, packetProperties);

    // a request wraps the packet and any additional metadata we need in order to return the
    // response to the caller (e.g. callback)
    var request = isc.addProperties({
        sendChannel: sendChannel,
        packet: packet,
        callback: callback,
        // copy sequence from packet for ease of searching later
        sequence: packet.sequence
    }, requestProperties);

    // if channel doesn't exist, create it
    var _this = this;
    if (!this._bound) {
        // queue the request and establish receipt channel
        this.pendingRequests.add(request);
        this.bind(function () {
            // push all pending requests down the wire
            while(_this.pendingRequests.length) _this._send(_this.pendingRequests.shift());
        });
        return;
    }

    // we are bound - proceed
    this._send(request);
},
_send : function (request) {
    if (this.logIsDebugEnabled()) {
        this.logDebug("_send: "+isc.echo(request));
    }

    // if we expect a response, keep track of the request so we can pair up the response
    if (request.callback) {
        this.outstandingRequests.add(request);

        var now = isc.timeStamp();
        request.sendTime = now;

        if (request.timeout == null) request.timeout = this.defaultRequestTimeout;
        request.expiresAt = now+request.timeout;
        if (this._nextReap == null) {
            // schedule the reaper
            this._setReaperTimer(request.timeout);
        } else {
            // if the outbound request is scheduled to expire sooner than we would otherwise run
            // the reaper, pull the reaper forward to match request timeout
            if (this._nextReap > request.expiresAt) this._setReaperTimer(request.timeout);
        }
    }

    if (this.directBindingOnly) {
        var directBindingSocket;
        try {
            // targetWindow may have gone away - don't produce copious error messages if so
            this.directBinding.window.isc;
            directBindingSocket = this.directBinding.getSocket(request.sendChannel);
        } catch (e) {
            return;
        }

        if (!directBindingSocket) {
            this.logWarn("Unable to obtain direct binding socket for channel: "+request.sendChannel);
            return;
        }


        this.sendDirectBindingPacket(request.packet, directBindingSocket, this.directBinding.window);
    } else {

        isc.Messaging.isRemoteDebug = this.isRemoteDebug;
        isc.Messaging.send(request.sendChannel, request.packet, null, {sequenced: true, doNotTrackRPC: this.doNotTrackRPC});
        delete isc.Messaging.isRemoteDebug;
    }
},

sendDirectBindingPacket : function (packet, directBindingSocket, targetWindow) {

    directBindingSocket.directBindingQueue.add({
        serializedPacket: isc.Comm.serialize(packet),
        originSocket: this,
        originWindow: window
    });
    try {
        var sockID = directBindingSocket.ID;
        targetWindow.setTimeout("if (window."+sockID+") "+sockID+".processDirectBindingQueue()", 0);
    } catch (e) {
        // window may have gone away - ignore error
    }
},
processDirectBindingQueue : function () {
    while (this.directBindingQueue.length) {
        var obj = this.directBindingQueue.shift();

        try {
            var packet = isc._makeFunction("return " + obj.serializedPacket)();
            this.delayCall("receive", [packet, obj.originSocket, obj.originWindow]);
        } catch (e) {
            // ignore any error
        }
    }
},

sendReply : function (requestPacket, replyPayload, originSocket, originWindow) {

    if (!requestPacket.expectsReply) return;

    var replyPacket = {
        payload: replyPayload,
        originChannel: this.receiveChannel,
        sequence: this.getNextSequence(),
        inResponseTo: {
            originChannel: requestPacket.originChannel,
            sequence: requestPacket.sequence
        }
    }

    if (this.logIsDebugEnabled()) {
        this.logDebug("sendReply to :" +requestPacket.originChannel+": "+isc.echo(replyPacket));
    }

    if (originSocket) {
        // direct binding

        try {
            // targetWindow may have gone away - don't produce copious error messages if so
            originWindow.isc;
        } catch (e) {
            return;
        }

        this.sendDirectBindingPacket(replyPacket, originSocket, originWindow);
    } else {

        isc.Messaging.isRemoteDebug = this.isRemoteDebug;
        isc.Messaging.send(requestPacket.originChannel, replyPacket, null, {sequenced: true, doNotTrackRPC: this.doNotTrackRPC});
        delete isc.Messaging.isRemoteDebug;
    }
},

// this fires for non-reply packets
packetReceived : function (packet, originSocket, originWindow) {

},

receive : function (data, originSocket, originWindow) {
    // this could be a reply to one of our messages or not -
    var packet = data;

    if (packet.inResponseTo) {
        // this is a reply
        var request;
        var request = this.outstandingRequests.find("sequence", packet.inResponseTo.sequence);
        if (!request) {
            if (this.logIsWarnEnabled()) {
                this.logWarn("Unable to find originating request for response packet: "+isc.echo(packet));
                this.logWarn("Outstanding requests: " + isc.echo(this.outstandingRequests));
            }
            return;
        }
        if (this.logIsDebugEnabled()) {
            this.logDebug("original request: " + isc.echo(request));
            this.logDebug("callback args "+isc.echoFull([packet.payload]));
        }
        if (request.callback) this.fireCallback(request.callback, "payload", [packet.payload]);
    } else {
        // this is not a reply
        this.packetReceived(packet, originSocket, originWindow);
    }
}

});





//------------------------------------------------------------------------------------
// when you call MessagingDMI.connect() - you get one of these in the callback
isc.defineClass("MessagingDMIClient").addProperties({

socketConstructor: "MessagingDMISocket",

// this has an async interface so we can e.g. call the server for a truly unique GUID
getGUID : function (callback) {
    if (!this.GUID) this.GUID = isc.Math.randomUUID();
    this.fireCallback(callback, "GUID", [this.GUID]);
},


call : function (methodName, args, callback) {
    //!OBFUSCATEOK
    var _this = this;

    var props = {};
    if (isc.isAn.Object(methodName)) {
        // take a shallow copy because we will remove properties meant for the
        // MessagingDMISocket class later
        props = isc.addProperties({}, methodName);
        methodName = props.methodName;
        args = props.args;
        callback = props.callback;
    }


    if (!args) args = [];
    if (!isc.isAn.Array(args)) {
        this.logError("Expected Array as second arg or props.args in "
         + "MessagingDMIClient.call(), but got:" + isc.echo(args));
        return;
    }

    // wrap the callback so we can supply the "retVal" arg
    var wrappedCallback = null;
    if (callback) {
        wrappedCallback = function (retVal) {
            _this.fireCallback(callback, "retVal", [retVal]);
        };
    }

    // canonicalize to props format
    isc.addProperties(props, {
        methodName: methodName,
        args: args
    });

    // remove property overrides meant for MessagingDMISocket
    var packetProperties = props.packetProperties;
    var requestProperties = props.requestProperties;
    delete props.packetProperties;
    delete props.requestProperties;

    // can override sendChannel - notify(), for example, does this
    var sendChannel = props.sendChannel || this.sendChannel;
    delete props.sendChannel;

    if (!sendChannel) {
        this.logError("Error in call() - unable to resolve sendChannel"+this.getStackTrace());
        return;
    }

    // if no socket has been provided, auto-connect one now
    if (!this.socket) this.connect(sendChannel);

    this.socket.send(sendChannel, props, wrappedCallback, packetProperties, requestProperties);
},

// target is either:
//   - a channel name (string) - typically the GUID or broadcast channel of a server - this
//     becomes our sendChannel
//   - a serverConfig properties block - we then derive our sendChannel from the receiveChannel
//     specified on this properties block
//   - a MessagingDMIServer instance - providing one of these triggers special short-circuit
//     logic that simply calls APIs on the provided instance without transiting the network.
//     This mode is useful for testing and is used by the Developer Console window-to-window
//     comm
connect : function (target, callback) {
    var _this = this;

    // Note: below we store the serverProperties on this object for possible future use

    // direct binding - store and return
    // Note: don't use isA checks cross frame - that may fail on IE
    if (target.getServerProperties) {
        this.directBinding = target;
        target = target.getServerProperties();
    }

    if (isc.isA.String(target)) {
        // channel directly provided
        this.serverProperties = {
            GUID: target,
            receiveChannel: target
        };
        this.sendChannel = this.serverProperties.receiveChannel;
    } else if (target.receiveChannel) {
        // serverProperties block from MessagingDMIServer.getServerProperties() provided
        this.serverProperties = target;
        this.sendChannel = this.serverProperties.receiveChannel;
    }

    if (this.socket) this.socket.close();


    if (!this.receiveChannel) {
        // use GUID for receiveChannel - if not set, generate and call ourselves back
        this.getGUID(function (GUID) {
            _this.receiveChannel = GUID;
            _this.connect(target, callback);
        });
        return;
    }

    // socket will auto-connect when we send() on it
    this.socket = isc.ClassFactory.getClass(this.socketConstructor, true).create({
        receiveChannel: this.receiveChannel,
        directBinding: this.directBinding
    }, this.socketDefaults, this.socketProperties);

    // if a callback has been provided, round trip a message to the server before calling back
    if (callback) this.call("connect", null, callback);
},

disconnect : function (callback) {
    var _this = this;

    if (!this.socket) {
        if (callback) this.fireCallback(callback);
        return;
    }

    var closeSocket = function (callback) {
       _this.socket.close(function () {
            delete _this.socket;
            delete _this.directBinding;
            if (callback) _this.fireCallback(callback);
       });
    }

    if (callback) {
        // disconnect() call first goes to server
        this.call("disconnect", [], function () {
            closeSocket(callback);
        });
    } else {
        // just close the socket
        closeSocket();
    }
},

// convenience method
ping : function (callback, timeout) {
    var requestProperties = timeout ? {timeout: timeout} : null;
    this.call({
        methodName: "ping",
        callback: callback,
        requestProperties: requestProperties
    });
}

});

//------------------------------------------------------------------------------------
isc.defineClass("MessagingDMIServer").addProperties({

socketConstructor: "MessagingDMISocket",

// set this to start a second socket that listens for discover() calls on the named channel
// - typically used as a broadcast discovery mechanism
// discoverableOnChannel: null,

init : function () {
    if (!this.visibleMethods) this.visibleMethods = [];

    // for direct binding
    this.window = window;
},

// this has an async interface so we can e.g. call the server for a truly unique GUID
getGUID : function (callback) {
    if (!this.GUID) this.GUID = isc.Math.randomUUID();
    this.fireCallback(callback, "GUID", [this.GUID]);
},

handlePacket : function (packet, originSocket, originWindow) {
    if (this.logIsDebugEnabled()) {
        this.logDebug("packetReceived: " + isc.echo(packet));
    }

    var _this = this;

    // patch our callback and invoke call()
    var props = isc.addProperties({}, packet.payload);
    props.callback = function (retVal) {
        if (this.logIsDebugEnabled) _this.logDebug("invocation of: " + packet.payload.methodName + " returned");
        _this.socket.sendReply(packet, retVal, originSocket, originWindow);
    };
    this.call(props);
},

getServerProperties : function () {
    return {
        // every server should have a global unique identifier (GUID)
        // there are several uses, but one is for unique id by DMIDiscovery
        GUID: this.GUID,
        // the receiveChannel is usually the same as the GUID, but could be a multicast or
        // broadcast channel or something custom instead
        receiveChannel: this.receiveChannel,
        discoverableOnChannel: this.discoverableOnChannel,

        generatedDate: new Date(),

        userAgent: navigator.userAgent,
        platform: navigator.platform,
        vendor: navigator.vendor,

        // these are the methods that the client is allowed to call - excepting builtins
        visibleMethods: this.visibleMethods
    };
},

getSocket : function (receiveChannel) {
    if (this.sockets) return this.sockets.find("receiveChannel", receiveChannel);
    return null;
},

start : function (callback) {
    var _this = this;

    // don't leak sockets in case start() is called more than once
    if (this.sockets) {
        this.logWarn("start() called when socket is connected - restarting");
        this.stop(); // synchronous - we don't care to wait for ack in this case
    }

    if (!this.receiveChannel) {
        // use GUID for receiveChannel - if not set, generate and call ourselves back
        this.getGUID(function (GUID) {
            _this.receiveChannel = GUID;
            _this.start(callback);
        });
        return;
    }

    this.sockets = [];
    this.socket = isc.ClassFactory.getClass(this.socketConstructor, true).create({
        receiveChannel: this.receiveChannel,
        packetReceived : function (packet, originSocket, originWindow) {
            // Note: receiveChannel will be auto-generated by the socket
            _this.handlePacket(packet, originSocket, originWindow);
        }
    }, this.socketDefaults, this.socketProperties);
    this.sockets.add(this.socket);


    if (this.discoverableOnChannel) {
        this.discoverySocket = isc.ClassFactory.getClass(this.socketConstructor, true).create({
            receiveChannel: this.discoverableOnChannel,
            packetReceived : function (packet, originSocket, originWindow) {
                _this.handlePacket(packet, originSocket, originWindow);
            }
        }, this.socketDefaults, this.socketProperties);
        this.sockets.add(this.discoverySocket);
    }

    var _this = this;
    var numSocketsConnected = 0;
    for (var i = 0; i < this.sockets.length; i++) {
        var socket = this.sockets[i];
        socket.bind(function () {
            if (++numSocketsConnected == _this.sockets.length) {
               _this.isAvailable = true;
               if (callback) _this.fireCallback(callback);
            }
        });
    };
},

stop : function (callback) {
    this.isAvailable = false;

    if (!this.sockets) {
        this.fireCallback(callback);
        return;
    }

    var _this = this;
    var numSocketsConnected = this.sockets.length;
    // careful: our callback below deletes this.sockets
    for (var i = 0; this.sockets && i < this.sockets.length; i++) {
        var socket = this.sockets[i];
        socket.close(function () {
            if (--numSocketsConnected == 0) {
                delete _this.sockets;
                if (callback) _this.fireCallback(callback);
            }
        });
    }
},

// builtins

discover : function (callback) {
    this.logDebug("discover invoked - callback: "+(callback ? callback.toString() : "null"));
    // respond with metadata about the server - at minimum what's required in
    // MessagingDMI.connect() to create a MessagingDMIClient that can talk to this server
    if (callback) this.fireCallback(callback, "serverProperties", [this.getServerProperties()]);
},


ping : function (callback) {
    this.logDebug("ping");
    if (callback) this.fireCallback(callback);
},
connect : function (callback) {
    this.logDebug("connect");
    if (callback) this.fireCallback(callback);
},
disconnect : function (callback) {
    this.logDebug("disconnect");
    if (callback) this.fireCallback(callback);
},


call : function (methodName, args, callback) {
    //!OBFUSCATEOK
    var _this = this;

    var targetName;
    var props = {};
    if (isc.isAn.Object(methodName)) {
        props = methodName;
        targetName = props.targetName;
        methodName = props.methodName;
        args = props.args;
        callback = props.callback;
    }

    // targetName may be encoded in methodName or may be supplied separately
    if (!targetName) {
        var lastDotIndex = methodName.lastIndexOf(".");
        if (lastDotIndex != -1) {
            // parse the target and method
            targetName = methodName.substring(0, lastDotIndex);
            methodName = methodName.substring(lastDotIndex+1);
        }
    }

    if (targetName && !this.allowUnrestrictedCallTarget) {
        this.logError("Attempt to call: " + targetName+"."+methodName+"()"
            + " REJECTED - to enable, set allowUnrestrictedCallTarget on your "+this.getClassName());
        return;
    }
    var target = targetName ? eval(targetName) : this;

    // check that the user is invoking a visibleMethod or builtinMethod
    // Note: "*" in visibleMethods means all methods on this class are invocable (except for
    // set(), which also requires the special allowUnrestrictedCallTarget property to be set);
    if (!(this.visibleMethods.contains("*") || this.allowUnrestrictedCallTarget)) {
        if (!(this.visibleMethods.contains(methodName) || isc.MessagingDMI.builtinMethods.contains(methodName))) {
            this.logError("Attempt to call non-visible method: " + methodName + " DENIED."
                + " To allow this action, declare this method in your "
                + this.getClassName()+".visibleMethods list.");

            return;
        }
    }

    // execute
    var method = target[methodName];
    if (!method) {
        this.logError("Unable to find method named '"+methodName+"' on class: " + this.getClassName());
        return;
    }

    if (!args) args = [];

    if (!isc.isAn.Array(args)) {
        this.logError("Expected Array as second arg or props.args in "+this.getClassName()
         + ".call(), but got:" + isc.echoFull(args));
        return;
    }

    if (target == this) {
        // if the call is on this class, then we mandate that the call is asynchronous here -
        // i.e. the last argument of the local method is going to be a callback that passes us
        // the retVal (unless the method is not intended to return a value, in which case no
        // callback need be passed).  This allows fully asynchronous calls from the DMI client
        method.apply(this, args.concat([function (retVal) {
            if (callback) _this.fireCallback(callback, "retVal", [retVal]);
        }]));
    } else {
        // if the method is being invoked on something else, we can't control how/where we pass
        // a callback, so it has to be synchronous here - we take the return value and pass it
        // back to the DMI client
        var retVal = method.apply(target, args);
        if (callback) _this.fireCallback(callback, "retVal", [retVal]);
    }

}



});



isc.defineClass("DebugTarget", "MessagingDMIServer").addProperties({

allowUnrestrictedCallTarget: true,

discoverableOnChannel: "isc_DebugTarget",

socketDefaults: {
    doNotTrackRPC: true,
    isRemoteDebug: true
},
discoverySocketDefaults: {
    doNotTrackRPC: true,
    isRemoteDebug: true
},

getGUID : function (callback) {
    if (!this.GUID) {
        // special handling - whenever the page is reloaded, the DebugTarget obtains a new
        // GUID.  This is bad for us because we'll end up showing duplicate entires in our
        // list of available remotes.
        //
        // To deal with this, we store the generated GUID in a cookie for this page specifically
        // and reuse it.  This also allows us to re-use the comm channel the master is already
        // using to talk to us.
        //
        // Also: per URL so that navigating to a different remoteDebug-enabled page does not
        // cause us to auto-rebind with the same GUID there and effectively have multiple logs
        // going to the same log window.
        var GUID = isc.LogViewer.getGlobalLogCookieValue("isc_pageGUID");
        var URL = isc.LogViewer.getGlobalLogCookieValue("isc_pageURL");
        if (!GUID || URL != location.href) {
            var _this = this;
            this.Super("getGUID", [function (GUID) {
                _this.GUID = GUID;
                isc.LogViewer.setGlobalLogCookieValue("isc_pageURL", location.href);
                isc.LogViewer.setGlobalLogCookieValue("isc_pageGUID", _this.GUID);
                _this.fireCallback(callback, "GUID", [_this.GUID]);
            }], arguments);
            return;
        } else {
            this.GUID = GUID;
        }
    }

    this.fireCallback(callback, "GUID", [this.GUID]);
},

sendTargetAvailableNotify : function () {
    this.socket.send("isc_DebugMaster", {
        methodName: "targetAvailable",
        args: [this.getServerProperties()]
    });
},

getServerProperties : function () {
    var formFactor = "Desktop";
    if (isc.Browser.isTablet) formFactor = "Tablet";
    else if (isc.Browser.isHandset) formFactor = "Handset";

    return isc.addProperties(this.Super("getServerProperties", arguments), {
        // supply this additional context to distinguish the available servers from each other
        userAgent: navigator.userAgent,
        documentTitle: document.title,
        URL: location.href,
        formFactor: formFactor,
        browserVersion: isc.Browser.version,
        browserMinorVersion: isc.Browser.minorVersion
    });
},

pushRPCUpdate : function (transaction) {
    if (!isc.debugMaster) return;

    var transactionRecord = {
        cancelled: transaction.cancelled,
        receiveTime: transaction.receiveTime,
        URL: transaction.URL,
        transactionNum: transaction.transactionNum,
        serializedCommResults: transaction.serializedCommResults,
        serializedCommResultsAreFormatted: transaction.serializedCommResultsAreFormatted,
        transport: transaction.transport
    };

    var rpcs = [];
    for (var i = 0; i < transaction.operations.length; i++) {
        var rpcRequest = transaction.operations[i];
        var rpcResponse = transaction.responses[i];
        rpcs[i] = this.rpcToRecord(transaction, rpcRequest, rpcResponse);

        if (transaction.operations.length > 1) rpcs[i]._queueIndex = i;
    }
    transactionRecord.rpcs = rpcs;

    isc.debugMaster.call("isc.RPCTracker.updateTransactionRecord", [transactionRecord]);
    transaction.pushedToDebugMaster = true;
},

rpcToRecord : function (transaction, rpcRequest, rpcResponse) {
    var dsRequest = rpcRequest._dsRequest || rpcRequest.$374;

    var type = "RPCRequest";
    if (dsRequest != null) type = "DSRequest";
    else if (rpcRequest.data && rpcRequest.data.is_ISC_RPC_DMI) type = "RPC DMI";
    else if (rpcRequest.wsOperation) type = "WSRequest";

    var operationType;
    if (rpcRequest.operationType) {
        operationType = rpcRequest.operationType;
        if (rpcRequest.operationId) {
            operationType += "&lt;" + rpcRequest.operationId + "&gt;";
        }
        // a DataSource operation that invokes a web service operation
        if (rpcRequest.wsOperation) operationType += "[" + rpcRequest.wsOperation + "]";

    } else if (rpcRequest.wsOperation) {
        // a direct webService.callOperation() call
        operationType = rpcRequest.wsOperation
    } else {
        if (rpcRequest.data && rpcRequest.data.methodName) operationType = rpcRequest.data.methodName;
        else operationType = "RPC";
    }

    var ds;
    if (rpcRequest.dataSource) {
        ds = rpcRequest.dataSource;
    } else {
        if (rpcRequest.data && rpcRequest.data.appID) ds = rpcRequest.data.appID+"/"+rpcRequest.data.className;
    }

    var componentInfo = rpcRequest.componentId || "",
        compContext = rpcRequest.componentContext;
    if (compContext) {
        componentInfo += " &lt;" + compContext + "&gt;"
    }

    var url = transaction.mergedActionURL ? transaction.mergedActionURL
                                          : rpcRequest.actionURL;
    if (transaction.isProxied) url = transaction.proxiedURL;
    if (transaction.allClientOnly) url = "[client only]";

    var rpcRecord = {
        url : url,
        transactionNum: transaction.transactionNum,
        type: type,
        ds: ds,
        operationType:operationType,
        componentId: componentInfo,
        transport: rpcRequest.transport,
        httpMethod: rpcRequest.httpMethod,
        timeSent: new Date(transaction.sendTime),
        proxied: rpcRequest.isProxied,
        timeout: transaction.timeout,
        xhrData: transaction.xhrData,
        xhrHeaders: transaction.xhrHeaders,
        callStack: rpcRequest._callStack,
        clientTiming: rpcRequest.clientTiming
    };
    if (rpcResponse && rpcResponse.clientOnlyData) {
        // use JSON encode because isc.echo() doesn't indent but echoFull not safe
        // (clientOnly responses are not network responses, and so records where users
        // might have hung various kinds of objects)
        rpcRecord.clientOnlyData = isc.JSON.encode(rpcResponse.clientOnlyData,
                                             {prettyPrint:true,
                                              strictQuoting:false,
                                              serializeInstances:"short",
                                              skipInternalProperties:true});
    }

    if (rpcRecord.transport == "xmlHttpRequest" || rpcRecord.transport == "hiddenFrame") {
        var mask = ["actionURL","showPrompt","prompt","transport",
         "useSimpleHttp","promptStyle","timeout","params",
         "httpMethod","contentType","httpHeaders",
         "ignoreTimeout","sendNoQueue","paramsOnly","bypassCache","isProxied"];

        if (rpcRecord.type == "RPCRequest") {
            mask.addList(["callback","willHandleError","evalResult","evalVars",
                          "serverOutputAsString","containsCredentials","clientContext","internalClientContext"]);
        }
        mask.add("data");

        var req = isc.applyMask(rpcRequest, mask);
        //addToLog("serializing rpcRequest: " + isc.echo(req));
        // use short form for instances of ISC classes found in the DSRequest
        rpcRecord.decoded = isc.JSON.encode(req, {prettyPrint:true, serializeInstances:"short"});
    }

    var dsReq = rpcRequest._dsRequest || rpcRequest.$374;
    if (dsReq) {
        // properties we want to show, in order
        var mask = ["dataSource", "operationType", "operationId", "componentId",
            "data", "startRow", "endRow", "sortBy", "textMatchStyle",
            "resultSet", "resultTree", "parentNode",
            "callback", "willHandleError",
            "showPrompt", "prompt",
            "oldValues",
            "requestId",
            "clientContext",
            "internalClientContext"
        ];
        // We only want to show operationId if it's not auto-generated
        var omitOpId =
            (dsReq.operation && dsReq.operation.source == "auto");
        // copy everything in the mask first, which puts them first and in a specific order
        var dsReqData = {};
        for (var i = 0; i < mask.length; i++) {
            var propName = mask[i];

            if (propName == "operationId" && omitOpId) continue; // omit if "auto"

            var value = dsReq[propName];

            if (value == null) continue;

            if (propName == "parentNode") {
                // we want to show only the immediate properties here or we will end up
                // dumping the whole tree recursively
                dsReqData[propName] = this.getShallowData(value);
            } else if (propName == "clientContext" || propName == "internalClientContext") {
                // go one level deeper (but still not fully recursive) on
                // clientContext, since there's often interesting stuff in there like
                // ListGrid editing context
                var safeCopy = dsReqData[propName] = {};
                for (var contextProp in value) {
                    safeCopy[contextProp] = this.getShallowData(value[contextProp]);
                }
            } else {
                dsReqData[propName] = value;
            }
        }

        // go through the full set of keys from the dsRequest, selectively copying
        // things not in the mask
        var omitProps = ["originalData", "operation", "unconvertedDSRequest"];
        var props = isc.getKeys(dsReq);
        for (var i = 0; i < props.length; i++) {
            var propName = props[i];

            if (mask.contains(propName)) continue; // already copied
            if (omitProps.contains(propName)) continue; // explicitly omit
            var value = dsReq[propName];
            if (value == null) continue; // null property

            // otherwise, show only atomic values and SC instances - anything else that's
            // an Object is too dangerous to serialize (could be DOM elements or other
            // surprises)
            if (!isc.DS.isSimpleTypeValue(value) && !isc.isAn.Instance(value)) continue;

            dsReqData[propName] = value;
        }

        //addToLog("serializing dsRequest: " + isc.echo(dsReq));
        // don't serialize instances of ISC classes found in the DSRequest, and hide
        // internal properties
        var requestJSON = isc.JSON.encode(dsReqData, {prettyPrint:true,
                                                      strictQuoting:false,
                                                      serializeInstances:"short",
                                                      skipInternalProperties:true});
        rpcRecord.dsReqJSON = requestJSON;
    }


    if (rpcResponse) {
        // note: we explicitly avoid serializing response data here - instead we read it
        // from transaction.serializedCommResults - which is is already in text form an guaranteed not to
        // have been messed with by the user
        var mask = ["operationId", "transactionNum", "httpResponseCode",
            "transport", "status", "clientOnly", "httpHeaders", "isStructured",
            "isDSResponse", "invalidateCache", "startRow", "endRow",
            "totalRows", "clientTiming", "timing"];
        var resp = isc.applyMask(rpcResponse, mask);
        rpcRecord.rpcResponseRecord = isc.JSON.encode(resp,
                                             {prettyPrint:false,
                                              strictQuoting:false,
                                              serializeInstances:"short",
                                              skipInternalProperties:false});
    }

    if (rpcResponse) {
        isc.addProperties(rpcRecord, {
            status: rpcResponse.status,
            httpCode: rpcResponse.httpResponseCode,
            responseReceived: new Date(transaction.receiveTime)
        });
    } else if (transaction.cancelled) {
        isc.addProperties(rpcRecord, {
            status: "CANCELLED"
        });
    }
    return rpcRecord;
},

// give an object, return a copy that when serialized to JSON by the JSONEncoder will
// look similar to isc.echo() of that object.
// NOTE: superior to just pre-echoing the object using isc.echo() since that:
// - will be a String, so when encoded by JSONEncoder will have extra quotes
// - won't get indented correctly
getShallowData : function (object) {
    if (isc.DS.isSimpleTypeValue(object)) return object;


    var safeCopy = {},
        isInstance = isc.isA.Instance(object),
        instancePrototype = isInstance ? object.getClass().getPrototype() : null;
    for (var propName in object) {
        var value = object[propName];

        if (value == null) continue;

        // For instances, avoid copying props off the instance-prototype
        // We only care about modified properties, but more importantly, this
        // will skip internal properties, methods etc as well
        if (isInstance && instancePrototype && instancePrototype[propName] == value) continue;

        if (isc.DS.isSimpleTypeValue(value)) {
            safeCopy[propName] = value;
        } else {
            // do this via a custom _serialize() function because if we were to simply
            // put the output of echoLeaf in the object as a String, there would be
            // extra quotes when serialized to JSON
            safeCopy[propName] = {
                output : isc.echoLeaf(value),
                _serialize : function () { return this.output; }
            }
        }
    }
    return safeCopy;

},

_$count : "count",
//_staticFormUpdates: 0,
updateStats : function (stat) {
    if (!isc.debugMaster) return;

    // don't update stats during timeExpression() runs
    if (isc._timingRun) return;

    //this._staticFormUpdates++;

    var canvas = isc.Canvas;
    var value, values;
    if (stat == null) {
        // push all stats (initial debug enable)
        var targetIsc = isc,
            canvas = targetIsc.Canvas,
            stats = canvas._stats,
            lastTarget = targetIsc.EH.lastTarget,

            focusTarget = targetIsc.EH.getFocusCanvas()
        ;

        // Note: copied from developerConsole targetsDisplay.grabValues - at this point we can
        // probably just move that code here...
        values = {
            draws : stats.draws,
            clears : stats.clears,
            redraws : stats.redraws,
            destroys : stats.destroys,
            count : canvas._canvasList.length - canvas._iscInternalCount,
            currentCanvas : lastTarget != null ? lastTarget.getID() : "",
            currentFocusCanvas : focusTarget != null ? focusTarget.getID() : ""

        }
    } else if (stat == this._$count) {
        value = canvas._canvasList.length - canvas._iscInternalCount;

    } else if (stat) {
        value = canvas._stats[stat];
    }

    if (values) {
        isc.debugMaster.call("countsDisplay.setValues", [values]);
    } else {
        // push single stat
        isc.debugMaster.call("countsDisplay.setValue", [stat, value]);
    }
},

displayEventTarget : function () {
    if (!isc.debugMaster) return;

    var targetID = isc.EH.lastTarget && isc.EH.lastTarget.getID ? isc.EH.lastTarget.getID() : "";
    if (targetID == this._currentTarget) return;
    this._currentTarget = targetID;

    isc.debugMaster.call("targetsDisplayEventHandler.setValue", ["currentCanvas", targetID]);

    var nativeTarget = isc.EH.lastEvent.nativeTarget;
    var nativeID = (nativeTarget? (nativeTarget.id || nativeTarget.ID || nativeTarget.tagName) : 'none')

    isc.debugMaster.call("targetsDisplayEventHandler.setValue", ["nativeTarget", nativeID]);
},
displayFocusTarget : function () {
    if (!isc.debugMaster) return;

    var target = isc.EH.getFocusCanvas(),
        targetID = target ? target.getID() : "";
    if (targetID == this._currentFocusTarget) return;
    this._currentFocusTarget = targetID;

    isc.debugMaster.call("targetsDisplayEventHandler.setValue", ["currentFocusCanvas", targetID]);
},
displayMouseDownTarget : function () {
    if (!isc.debugMaster) return;

    var target = isc.EH.mouseDownEvent.target,
        targetID = target ? target.getID() : "";

    isc.debugMaster.call("targetsDisplayEventHandler.setValue", ["lastMouseDown", targetID]);
    if (isc.AutoTest != null && isc.Log.showLocatorOnMouseDown) {
        var autoTestLocator = isc.AutoTest.getLocator();
        isc.debugMaster.call("targetsDisplayEventHandler.setValue", ["autoTestLocator", autoTestLocator || "none"]);
    }
},





// Debug establish APIs
// ============================================================================================
showFocus : function () {
    isc.DebugFocus.showFocus();
},
clearFocus : function () {
    isc.DebugFocus.clearFocus();
},

debugDisable : function (callback) {
    if (isc.debugMaster) {
        isc.debugMaster.disconnect();

        this.ignore(isc.Log, "addToMasterLog");
        this.ignore(isc.EventHandler, "getEventTargetCanvas");
        this.ignore(isc.EventHandler, "_focusInCanvas");
        this.ignore(isc.EventHandler, "doHandleMouseDown");

        isc.debugMaster = null;
    }
    if (callback) callback();
},

debugEnable : function (masterServerConfig, callback) {
    // disconnect from any current master
    var _this = this;
    this.debugDisable();
    var debugMaster = isc.MessagingDMIClient.create({
        socketProperties: {
            doNotTrackRPC: true,
            isRemoteDebug: true
        }
    });

    if (masterServerConfig == null) {
        // direct binding - reach into the log window and grab the debugMaster instance directly
        masterServerConfig = isc.Log.logViewer._logWindow.debugMaster;
    }

    debugMaster.connect(masterServerConfig, function () {
        // We want to send all messages cached so far to the new master, but this is a
        // little tricky because as soon as isc.RemoteDebug.debugMaster is set, any logs
        // will be automatically sent to that debugMaster which means there's a potential
        // out of order problem wherein isc.Log remotely streams some messages to the new
        // master before our cache dump arrives there.
        //

        // First call back so the DeveloperConsole can set flags that it is working remote
        if (callback) _this.fireCallback(callback, "props", [_this.getProps()]);

        // we are about to send the log cache - clear the log first
        debugMaster.call("clearLog");

        // then send the current log cache to the server
        // XXX break these up into smaller chunks to avoid exceeding max post size?
        debugMaster.call("addToLog", [isc.Log.getMessages()]);

        // now set the global flag that will copy messages to the remote master - do this
        // after the addToLog call above so there's no chance of log messages arriving out
        // of order
        isc.debugMaster = debugMaster;

        // push current stats to the targetsDisplay
        _this.updateStats();

        if (isc.RPCManager) isc.RPCManager.pushBufferedTransactionsToDebugMaster();
        // push latest xmlResponses
        if (isc.xml && isc.xml.xmlResponses) {
            debugMaster.call("window.updateCommWatcher", [isc.xml.xmlResponses]);
        }

        // careful: clear observations in debugDisable() above!
        _this.observe(isc.Log, "addToMasterLog", "isc.Log.logViewer.addToLog(message)");
        _this.observe(isc.EventHandler, "getEventTargetCanvas", "observer.displayEventTarget()");
        _this.observe(isc.EventHandler, "_focusInCanvas", "observer.displayFocusTarget()");
        _this.observe(isc.EventHandler, "doHandleMouseDown", "observer.displayMouseDownTarget()");
    });
},

// various pieces of the Developer Console need to check for flags on the page that has the
// debugTarget.  Rather than make individual calls for every single property, we return some
// commonly used or those that are convenient to access in a one shot property block that gets
// applied directly to the debugTarget object on in the DeveloperConsole.
getProps : function () {
    // these are applied directly to the debugTarget object on remote for easy access
    var globalLogCookie = this.getGlobalLogCookie();
    if (!globalLogCookie) globalLogCookie = {};

    var props = {
        isc_version: isc.version,
        isc_Browser_isIE: isc.Browser.isIE,
        isc_Browser_isMoz: isc.Browser.isMoz,
        isc_Browser_isSGWT: isc.Browser.isSGWT,
        isc_RPCManager: isc.RPCManager != null,
        isc_AutoTest: isc.AutoTest != null,
        isc_Log_showLocatorOnMouseDown: isc.Log.showLocatorOnMouseDown,
        isc_xml: isc.xml != null,
        globalLogCookie: globalLogCookie,

        // for nativeMozStackButton
        _includeOriginalMozStack: window._includeOriginalMozStack,

        // for remoteControlLogs button
        _remoteControlEnabled: isc.Log.logViewer._remoteControlEnabled
    };
    return props;
},

// Results Tab APIs
// ============================================================================================
evalJSWithDevConsoleVars : function (expression, evalVars, delayed) {
    // note: the call to logViewer.evaluate() will generate a log message with the result that
    // will be pushed to the debugMaster

    // resolve watchedId to a 'watched' widget instance for DeveloperConsole doEval() support
    // of the watch tab
    // make sure "watched" always has a Canvas value, which is nice so evals don't crash
    var watched = isc.Canvas._canvasList[0];
    watched = window[evalVars.watchedId];


    // patch on evalVars that cannot be passed from the DevConsole - such as functions etc.
    isc.addProperties(evalVars, {
        watched: watched,

        time : function (object, method) {
            isc.Log.timeMethod(object, method);
        },
        trace : function (object, method) {
            isc.Log.traceMethod(object, method);
        },
        traceCall : function (object, method) {
            // trace method calls, but with a call trace, not a stack trace
            isc.Log.traceMethod(object, method, true);
        },
        timeExpression : function (expression, setupCode, iterations) {
            isc.Log.timeExpression(expression, setupCode, iterations);
        },
        log : function (message, category) {
            return isc.Log.logWarn.call(isc.Log, message, category);
        },
        echo : function (obj) { return isc.Log.echo(obj); },
        echoAll : function (obj) { return isc.Log.echoAll(obj); },
        echoFull : function (obj) { return isc.Log.echoFull(obj); }
    });




    if (delayed) {
        isc.Log.logViewer.delayCall("evaluate", [expression, evalVars], 3000);
    } else {
        isc.Log.logViewer.evaluate(expression, evalVars);
    }
},


// Evaluate XML section
//--------------------------

browserEvalXML : function (xmlData) {
    if (isc.DS.get("Canvas") == null) {
        isc.Log.logWarn("Browser eval XML: couldn't find schema for Canvas, please load it using"
                       +" the <isomorphic:loadSystemSchema/> jsp tag");
    }
    isc.XMLTools.toComponents(xmlData);
},


browserXMLToJS : function (xmlData) {
    if (isc.DS.get("Canvas") == null) {
        isc.Log.logWarn("Browser eval XML: couldn't find schema for Canvas, please load it using"
                       +" the <isomorphic:loadSystemSchema/> jsp tag");
    }
    var jsObj = isc.XMLTools.toComponents(xmlData, {propertiesOnly: true});
    isc.Log.logInfo("Browser xmlToJS: \n\n" + isc.echoFull(jsObj));
},

literalTextAsCanvasContents : function (literalText) {
    isc.Canvas.create({
        ID:"literalHTMLCanvas",
        autoDraw:true,
        contents:literalText,
        backgroundColor:"gray"
    })
    window.literalHTMLCanvas.bringToFront();
},

getVersionCanvasContents : function (callback) {
    // use non-breaking-spaces everywhere, except right before "License" so it breaks there
    // if forced to wrap
    var str = "SmartClient&nbsp;Version:&nbsp;<b>${isc.version}</b>&nbsp;";
    // customer SDKs won't have these vars which come from the 'license' db table, so don't
    // add them to the string.
    if (["Eval", "PNC", "IDev"].contains(isc.licenseType)) {
        if (isc.licenseType == "Eval") {
            str += "(expires&nbsp;${isc.expirationDate})";
        } else {
            str += "(built&nbsp;${isc.buildDate})";
        }

        str += " Licensed&nbsp;to:&nbsp;${isc.licenseCompany}&nbsp;(#${isc.licenseSerialNumber})";
    } else {
        str += "(built&nbsp;${isc.buildDate})";
    }
    callback(str.evalDynamicString(this));
},

toggleRuler : function () {
    if (window.isc_dev_ruler) {
        window.isc_dev_ruler.destroy();
        return;
    }
    isc.Canvas.create({
        ID:"isc_dev_ruler",
        // 5px offset makes it more obvious in case entire page background is grid.gif
        left:isc.Page.getScrollLeft() + 5,
        top:isc.Page.getScrollTop() + 5,
        overflow:"hidden",
        canDragResize:true,
        dragAppearance: "target",
        canDragReposition:true,
        backgroundImage:"[SKIN]/grid.gif",
        // grid is no longer available in some skins (including the default)
        backgroundColor:"powderBlue",
        opacity:75,
        moved : function () { this.markForRedraw(); },
        getInnerHTML : function () {
             var size = this.getWidth() + "w x " + this.getHeight() + "h<br>at: "+this.getPageLeft()+","+this.getPageTop();
             return "<span title='" + size + "'>" + size + "</span>";
        },
        // Draw even if everything else is auto-draw false
        autoDraw:true
    });
    window.isc_dev_ruler.bringToFront();
},




// get a set of records describing all the Canvii in the page
getCanvasList : function (showGenerated, showUndrawn, showHidden, callback) {
    var canvasList = isc.Canvas._canvasList,
        canvasData = [],
        nodeIndex = {};

    //isc.Log.logWarn("generating canvas list: " + showGenerated);


    var sizeTemplate = [ , "w x ", , "h"];
    var positionTemplate = [ , ", "];
    for (var i = 0; i < canvasList.length; i++) {
        var canvas = canvasList[i];

        if (isc.Page._eT == canvas) continue;
        else if (isc.Log._hiliteCanvas == canvas) continue;
        else if (!showHidden && !canvas.isVisible()) continue;
        else if (!showUndrawn && !canvas.isDrawn()) continue;
        else if (canvas._generated && !showGenerated) continue;

        var canvasItem = {
            id: canvas.getID(),
            theClass: canvas.Class,
            drawn: canvas.isDrawn(),
            visible: canvas.isVisible(),
            zIndex: canvas.getZIndex(),
            pageLeft: canvas.getPageLeft(),
            pageTop: canvas.getPageTop(),
            overflow: canvas.overflow,
            // NOTE: because generated components may or may not be shown, we can't determine
            // parent status until we've found a child or peer that will be shown.
            hasChildren : nodeIndex[canvas.getID()]
        };
        sizeTemplate[0] = canvas.getWidth();
        sizeTemplate[2] = canvas.getHeight();
        canvasItem.size = sizeTemplate.join(isc.emptyString);

        sizeTemplate[0] = canvas.getVisibleWidth();
        sizeTemplate[2] = canvas.getVisibleHeight();
        canvasItem.drawnSize = sizeTemplate.join(isc.emptyString);

        // frequent crasher
        try {
            positionTemplate[0] = canvasItem.pageLeft;
            positionTemplate[2] = canvasItem.pageTop;
            canvasItem.position = positionTemplate.join(isc.emptyString);
            // trees do not yet support multi-column sort, so combine left/top into a single
            // int value where left takes precedence
            canvasItem.positionSortField = canvasItem.pageLeft*100000+canvasItem.pageTop;
        } catch (e) {
            canvasItem.position = "Error: " + e;
        }
        var treeParent = canvas;
        while (treeParent && (treeParent.masterElement || treeParent.parentElement)) {
            // create a synthetic parent pointer that shows peers as children of their master

            treeParent = (treeParent.masterElement || treeParent.parentElement);
            // if we are skipping generated components, skip past generated masters and parents
            // to find the next non-generated master, so we don't orphan non-generated children
            if (showGenerated || !treeParent._generated) break;
        }
        if (treeParent != canvas) {
            // mark our the item for our parent, or if no item exists for our parent yet, leave
            // a marker for it
            var parentItem = nodeIndex[treeParent.getID()];
            if (parentItem) parentItem.hasChildren = true;
            else nodeIndex[treeParent.getID()] = true;

            canvasItem.treeParentId = treeParent.ID;
        }
        nodeIndex[canvas.ID] = canvasItem;
        canvasData.add(canvasItem);
    }


    //isc.Log.logWarn("treeParents: " + canvasData.getProperty("treeParentId"));

    callback(canvasData);
},

measureGC : function () {
    isc.debugMaster.call("addToLog", ["GC Time: " + isc.Log.getGCTime().toFixed(2) + "ms"]);
},


// -------------------------------------------------------
// Updating log categories' logging priorities on the fly:

// synthetic log categories of broad interest
// ******************* NOTE: this order is the order the categories appear in the drop-down
// menu.  So put likely to be used stuff first, and try to preserve logical grouping
DEFAULT_CATEGORIES: [
    // sizing / clipping / layout
    // ---------------------------------------------------------------------------------------
    {name:"layout", description:"Logs from Layout and Stack about members and layout policy."},
    {name:"sizing", description:"Reporting drawn sizes"},
    {name:"scrolling", description:"Detecting the need for scrolling and custom scrollbars"},
    {name:"animation", description:"Animation logs"},
    // form-specific layout


    // comm and databinding
    // ---------------------------------------------------------------------------------------
    {name:"RPCManager", description:"RPC and DataSource requests and responses"},
    {name:"RPCManagerResponse", description:"Enable logging of full length RPC responses (can be slow)"},
    // XML-related
    {name:"xmlComm", description:"Inbound and outbound XML messages"},
    {name:"xmlSelect", description:"XPath expressions and their results"},
    {name:"xmlBinding", description:"DataSource and WebService XML request/response handling"},
    {name:"xmlToJS", description:"XML to JavaScript translation in databinding"},

    {name:"ResultSet", description:"Load on demand and cache update management for ListGrids"},
    {name:"ResultTree", description:"Load on demand for TreeGrids"},
    {name:"FileLoader", description:"Background download and caching of files"},
    {name:"fetchTrace", description:"Shows a stack trace for all fetches initiated through a ResultSet"},

    // events
    // ---------------------------------------------------------------------------------------
    {name:"dragDrop", description:"Drag and drop related logs"},
    {name:"EventHandler", description:"Mouse and keyboard events, bubbling, cancellation"},
    {name:"visualState", description:"Visual state transitions for buttons, bars, and other stateful widgets"},


    // other
    // ---------------------------------------------------------------------------------------
    {name:"RpcTabTiming", description:"Show detailed timing data for RPC/DSRequests in the RPC tab"},
    {name:"gridEdit", description:"Inline editing in grids"},

    {name:"Page", description:"Page-wide events"},
    {name:"loadTime", description:"ISC load / parse time"},

    // crude application metrics
    {name:"redraws", description:"Logging of redraw()s and reasons for them"},
    {name:"redrawTrace", description:"Logs a stack trace for every redraw when both 'redraws' "
                                    + "and 'redrawTrace' are set to debug priority" },
    {name:"clears", description:"Logs all clear()s"},
    {name:"destroys", description:"Logs all destroy()s"},
    {name:"draws", description:"All component draws"},
    {name:"resize", description:"Resizes of drawn components"},


    // Selenium
    {name:"testReplay", description:"Details of why Selenium commands are failing during playback"},

    // key widgets
    {name:"DynamicForm"},
    {name:"ListGrid"},
    {name:"TreeGrid"},
    {name:"CubeGrid"},

    // from here down are categories that exist for very narrow debugging purposes



    // notifications for deprecated attributes [typically logged at the info level]
    {name:"deprecated", description:"Notify when deprecated attributes are used"}

],


getDefaultLogCategories : function () {
    return this.DEFAULT_CATEGORIES.getProperty("name");
},

// Function to get the current log priority categories from the logPriority map
// Will always include 'DEFAULT_CATEGORIES' map as well as anything that has been set in the
// window.
getLogCategories : function (objectId, callback) {
    // categories we always want to show
    var categories = this.getDefaultLogCategories();

    // getLogPriorities returns a category -> priority map for all categories that have an
    // explicitly set priority
    var fullMap = isc.Log.getLogPriorities(objectId);

    // combine the two into a list
    for (var categoryName in fullMap) {
        if (categories.contains(categoryName)) continue;
        categories[categories.length] = categoryName;
    }

    // support being called remotely and locally
    if (callback) isc.Class.fireCallback(callback, "categories", [categories]);
    return categories;
},


// grab the logCategories and turn them into a set of records suitable for ListGrid display
getLogCategoryData : function (objectId, callback) {
    var overrides = (objectId ? isc.Log.getLogPriorities(objectId, true) : null),
        categories = this.getLogCategories(objectId),
        log = isc.Log
    ;
    var categoryData = [],
        defaultPriority;

    for (var i = 0; i < categories.length; i++) {
        var category = categories[i];
        if (objectId) {
            if (category == isc.Log._allCategories) continue;
            else if (category == isc.Log._default) {
                defaultPriority = window[objectId].getDefaultLogPriority();
                continue;
            }
        }

        var explicitPriority = log.getPriority(category, objectId);

        var defaultCategoryIndex = this.DEFAULT_CATEGORIES.findIndex("name", category);
        var description;
        if (defaultCategoryIndex != -1) description = this.DEFAULT_CATEGORIES[defaultCategoryIndex].description;

        categoryData.add({
            category:category,
            description: description,
            priority:explicitPriority || log.defaultPriority,
            custom:overrides && overrides[category]!=null
        });
    }
    categoryData.add({
        category:"[default]",
        priority:(defaultPriority || log.defaultPriority),
        custom:(defaultPriority ? true : false)

    });
    this.fireCallback(callback, "categoryData", [categoryData]);
},



generateLogMenuItems : function (componentId, numberOfCategories, callback) {
    var categories = this.getLogCategories(),
        componentMenuItems = [],
        menuItems = []
    ;

    // Don't show more menu items than will fit comfortably
    var maxItemsLeft = Math.min(categories.length, numberOfCategories);
    for (var i = 0; i < maxItemsLeft; i++) {
        var category = categories[i];

        var currentPriority = isc.Log.getPriority(category, componentId);
        if (currentPriority == null) currentPriority = isc.Log.getDefaultPriority();

        menuItems.add({title:category,
                       selectedLevel: currentPriority,
                       category:category,
                       addPrioritiesSubmenu: true,
                       enableIf:"menu.allCategoriesOverride() == null"})
    }

    menuItems.add({isSeparator:true});
    menuItems.add({title:"[default]", category:"_default",  addPrioritiesSubmenu: true,
                        selectedLevel: isc.Log.getDefaultPriority(componentId),
                        enableIf:"menu.allCategoriesOverride() == null"})

    menuItems.add({title:"More...", click: "menu.setCustomLogPriorities()"});

    componentMenuItems = menuItems.duplicate();

    menuItems = componentId != null ? componentMenuItems : menuItems;
    for (var i = 0; i < menuItems.length; i++) {
        var menuItem = menuItems[i],
            category = menuItem.category;

        if (category) {
            // hilite categories with a setting higher than WARN
            //log.logWarn("category: " + category + ", priority: " + priority);
            var priority = isc.Log.getPriority(category, componentId),
                cssText = (priority > isc.Log.WARN ? "color:blue;" : null)
            ;
            if (cssText != menuItem.cssText) {
                menuItem.cssText = cssText;
            }
        }
    }
    this.fireCallback(callback, "menuItems", [menuItems]);
},


// read global log cookie, adding some default stored state
getGlobalLogCookie : function (callback) {
    var globalLogCookie = isc.LogViewer.getGlobalLogCookie();
    if (globalLogCookie == null) globalLogCookie = {};

    // log priorities also must be stored in the global log cookie because these are consulted
    // for log threshold during framework init
    globalLogCookie.priorityDefaults = isc.Log.getLogPriorities();
    globalLogCookie.defaultPriority = isc.Log.defaultPriority;


    if (callback) this.fireCallback(callback, "globalLogCookie", [globalLogCookie]);
    return globalLogCookie;
},

// note: not listed in visibleMethods by default
set : function (lValue, value, callback) {
    //!OBFUSCATEOK
    var lValue = isc.Class.globalEvalWithCapture(lValue+"="+value);
    if (callback) this.fireCallback(callback, "lValue", [eval(lValue)]);
},
// note: not listed in visibleMethods by default
get : function (propertyName, callback) {
    //!OBFUSCATEOK
    this.fireCallback(callback, "value", [eval(propertyName)]);
}



});





isc.defineClass("DebugFocus").addClassProperties({

// If we do not hear a heartbeat from the developer console for this long, hide the focus
///
// this is set to be 1750ms longer than the heartbeat from the developer console to account for
// possible network latency.  Amazingly, 500ms was not enough on android (Nexus 7,
// specifically) - possibly because of native clock quantization?
//
// It's ok for this delay to be pretty long because we do explicitly cancel the focus effect
// when the focus moves on to a different remote, but there may be uncaught cases where the
// clearFocus() call never arrives (e.g. DevConsole reloaded, network disconnected etc), so it
// is good to auto-cancel due to lack of heartbeat.
hideTimeout: 2000,

opacityMax: 75,
opacityMin: 50,
oscillationFrequency: 2000,

showFocus : function () {
    if (this._focusCanvas && this._focusCanvas.isVisible()) {
        // keep alive
        this.clearHideTimer();
        this.setHideTimer();
        return;
    }

    // create and cache the canvas we're going to use to show the focus
    if (!this._focusCanvas) {
        this._focusCanvas = isc.Canvas.create({
            width: "100%",
            height: "100%",
            overflow: "hidden",
            backgroundColor: "#4169E1",

            hideUsingDisplayNone: true
        });
    }
    var fc = this._focusCanvas;

    // reset opacity
    fc.setOpacity(this.opacityMin);

    // draw offscreen
    fc.show();

    // make sure it's in front of everything else
    fc.bringToFront();

    this.setHideTimer();
    this.startFadeInAnimation();
},
clearFocus : function () {
    this.clearHideTimer();
    this.hideFocus();
},

startFadeOutAnimation : function () {
    this._focusCanvas.cancelAnimation(this.fadeAnimationID);
    this.fadeAnimationID = this._focusCanvas.animateFade(this.opacityMin, "isc.DebugFocus.startFadeInAnimation()", this.oscillationFrequency/2, "smoothStart");
},

startFadeInAnimation : function () {
    this._focusCanvas.cancelAnimation(this.fadeAnimationID);
    this.fadeAnimationID = this._focusCanvas.animateFade(this.opacityMax, "isc.DebugFocus.startFadeOutAnimation()", this.oscillationFrequency/2, "smoothStart");
},

hideFocus : function () {
    if (this._focusCanvas != null) {
        this._focusCanvas.cancelAnimation(this.fadeAnimationID);
        this._focusCanvas.hide();
    }
},

clearHideTimer : function () {
    if (this._hideTimer != null) {
        isc.Timer.clearTimeout(this._hideTimer);
        delete this._hideTimer;
    }
},

setHideTimer : function () {
    this._hideTimer = isc.Timer.setTimeout("isc.DebugFocus.hideFocus()", this.hideTimeout);
}

});



isc.defineClass("RemoteDebug").addClassProperties({

isEnabled: false,

// Some of the required modules may be optional modules (RealtimeMessaging, for
// example).  But even if the user has not purchased a license to these, we still allow
// the use of them specifically for RemoteDebugging.
// So: load from development/
modulesDir: "system/development/",

getUniqueChannelName : function () {
    return navigator.userAgent;
},

// this is called on page load at the end of this file
conditionallyEnable : function () {
    this.logDebug("conditionally enabling debug");

    // by default only enable on mobile to avoid noise in remote dropdown
    if (window.isc_remoteDebug && isc.Browser.isMobile) {
        this.enable();
    } else if (isc.params["isc_remoteDebug"] == "true") {
        // but explicit query param forces it on
        this.enable();
    }
},

requiredModules: ["RealtimeMessaging"],
loadRequiredModules : function (callback) {
    var _this = this;
    isc.FileLoader.ensureLoaded(function () {
        var modulesDir = isc.FileLoader.modulesDir;
        isc.FileLoader.modulesDir = _this.modulesDir
        isc.FileLoader.loadModules(_this.requiredModules, function () {
            // restore modulesDir
            isc.FileLoader.modulesDir = modulesDir;
            _this.fireCallback(callback);

        });
        // restore modulesDir - note: doing this twice to make really sure - it's possible
        // that callback above would fire synchronously on some platforms - in which case
        // any logic requiring FileLoader in the callback may be broken by the reset modulesDir
        isc.FileLoader.modulesDir = modulesDir;
    });
},

// call this method to enable RemoteDebug on the page that you want to debug
enable : function (callback) {
    if (this.isEnabled) {
        _this.fireCallback(callback);
    }

    // we need the SCServer for messaging to enable remoting
    if (!isc.hasOptionalModules("SCServer")) {
        // alert() because remoting is typically enabled on mobile where logging to the dev
        // console won't help
        alert("Remote debugging requires a Pro or better license.");
        return;
    }

    if (!isc.Log.logViewer) isc.Log.logViewer = isc.LogViewer.create();

    var _this = this;
    this.loadRequiredModules(function () {
        isc.debugTarget = isc.DebugTarget.create({

        });
        isc.debugTarget.start(function () {
            // let all listening debug masters know we are available
            isc.debugTarget.sendTargetAvailableNotify();
            _this.isEnabled = true;
            _this.logInfo("Remote debug enabled");
            _this.fireCallback(callback);
        });
    });
},

enableLocal : function (callback) {
    // kill any remote debug session
    if (isc.debugTarget) {
        isc.debugTarget.debugDisable();
    }

    var _this = this;

    this.isEnabled = false;
    isc.debugTarget = isc.DebugTarget.create({
        socketProperties: {
            directBindingOnly: true
        }
    });
    isc.debugTarget.start(function () {
        _this.fireCallback(callback);
    });
}

});

if (isc.Page.isLoaded()) {
    isc.RemoteDebug.conditionallyEnable();
} else {
    isc.Page.setEvent("load", "isc.RemoteDebug.conditionallyEnable()", isc.Page.FIRE_ONCE);
}






//>    @class    Element
//
// Helper class containing methods for direct DOM interaction. Note that even if
// +link{isc, isc_useSimpleNames} is true, this class is not available in the global scope
// as <code>window.Element</code> - to access it developers must always use
// <code>isc.Element</code>
//
//  @treeLocation Client Reference/Foundation
//  @visibility internal
//<
// Currently has no exposed methods - Developers typically will only need to interact with
// higher level canvas methods
isc.ClassFactory.defineClass("Element", null, null, true);

isc.Element.addClassProperties({

// The browser's prefix for experimental/unspec'd CSS properties, as it would appear in CSS text.
vendorCSSPrefix: (isc.Browser.isMoz ? "-moz-" :
                  isc.Browser.isChrome ? "-webkit-" :
                  isc.Browser.isSafari ? "-webkit-" :
                  isc.Browser.isOpera ? "-o-" :
                  isc.Browser.isIE ? "-ms-" :
                  ""),

// The browser's prefix for CSSStyleDeclaration properties corresponding to experimental/unspec'd
// CSS properties.
// https://github.com/Modernizr/Modernizr/blob/master/src/omPrefixes.js
vendorStylePrefix: (isc.Browser.isMoz ? "Moz" :
                    isc.Browser.isChrome ? "Webkit" :
                    isc.Browser.isSafari ? "Webkit" :
                    isc.Browser.isOpera ? "O" :
                    isc.Browser.isIE ? "ms" :
                    "")

});

isc.Element.addClassMethods({


// --------------------------------------------------------------------------------------------
// DOM Access / Manipulation

//>    @classMethod    Element.get()
//        Like the DOM method document.getElementById(), but works in all supported browsers.
//<
get : function (id, doc) {
    doc = doc || this.getDocument();
    if (isc.Browser.isDOM) return doc.getElementById(id);
},


// _getElementFromSelection()
// Determine which DOM element contains the current selection.
// 'doc' param allows caller to pass in a pointer to the document element - (may be document
// element from some frame/iframe - if not specified the main page document is used).

_getElementFromSelection : function (doc) {



    if (!doc) doc = document;

    if (isc.Browser._hasDOMRanges) {
        var selection = doc.getSelection();
        if (!selection.rangeCount) return null;

        var commonAncestorContainer = selection.getRangeAt(0).commonAncestorContainer;
        while (commonAncestorContainer != null && commonAncestorContainer.nodeType != 1) {
            commonAncestorContainer = commonAncestorContainer.parentNode;
        }
        return commonAncestorContainer;
    } else if (isc.Browser.isIE) {

        var selection = doc.selection;
        // In some cases, Internet Explorer can throw an exception when
        // attempting to access the selection.type attribute (though the
        // attribute does appear to be defined).

        try {
            var type = selection.type.toLowerCase();
        } catch (e) {
            return null;
        }
        var isText = (type == "text" || type == "none");

        if (!selection) return null;

        // If it's a text range use the 'parentElement()' method to determine what element
        // contains the text.
        // NOTE: an empty selection will be reported as type "None", but can be used to create
        // a zero char text range, so we treat it like a "Text" selection.
        if (isText) {
            var range;

            try {
                range = selection.createRange();
            } catch (e) {

            }
            return range ? range.parentElement() : null;

        // If it's a control range, we can get at the elements in the control range
        // by index.    Iterate through the elements and find the common ancester.

        } else {
            // If this is a control range
            // We're interested in the first common ancestor of the elements
            var range = selection.createRange(),
                commonParent;
            for (var i = 0; i < range.length; i++) {

                if (!commonParent) {
                    commonParent = range(i).parentElement;

                } else {
                    // To determine whether the element is contained by the common parent,
                    // we're creating a textRange from both elements and using the inRange
                    // method.
                    while (!commonParent.contains(range(i))) {
                        commonParent = commonParent.parentElement;
                    }
                }

            }
            return commonParent;
        }
    }
},

// From SmartGWT.mobile's `com.smartgwt.mobile.client.internal.util.ElementUtil'
hasClassName : function (element, className) {
    if (!className) return false;
    var str = element.className,
        pos = str.indexOf(className);
    while (pos != -1) {
        if (pos == 0 || str.charAt(pos - 1) == ' ') {
            pos += className.length;
            if (pos == str.length || str.charAt(pos) == ' ') {
                return true;
            }
        } else pos += className.length;
        if (pos >= str.length) break;
        pos = str.indexOf(className, pos);
    }
    return false;
},

// Calls `elementCallback' on each descendant element of `element' having the given CSS class.
// https://developer.mozilla.org/en-US/docs/Web/API/element.querySelectorAll
forEachDescendantHavingClass : function (element, className, elementCallback) {
    if (element == null || !className) return;

    if (element.querySelectorAll) {
        var matches = element.querySelectorAll("." + className),
            len = matches.length;
        for (var ri = len; ri > 0; --ri) {
            elementCallback(matches[ri - 1]);
        }
    } else {
        var children = element.childNodes,
            len = children.length;
        for (var ri = len; ri > 0; --ri) {
            var child = children[ri - 1];

            // Skip the child node if it is not an element.
            if (child.nodeType != 1) continue;

            // Recurse over children of the child.
            this.forEachDescendantHavingClass(child, className, elementCallback);

            if (this.hasClassName(child, className)) elementCallback(child);
        }
    }
},

// Given an element attribute, iterate recursively through child nodes till you find a match.
// May be slow for deep hierarchies
findAttribute : function (element, attribute, value) {
    if (!element) return null;
    if (element[attribute] == value ||
    (element.getAttribute && element.getAttribute(attribute) == value)) {
        return element;
    }
    var children = element.childNodes;
    for (var i = 0; i < children.length; i++) {
        var subElement = this.findAttribute(children[i], attribute, value);
        if (subElement) return subElement;
    }
    return null;

},

// http://stackoverflow.com/questions/10596417/is-there-a-way-to-get-element-by-xpath-in-javascript
evaluateXPath : function (xpathExpression, contextNode, namespaces, resultType) {


    var doc;
    if (contextNode == null) {
        doc = contextNode = document;
    } else if (contextNode.nodeType == 9) {
        doc = contextNode;
    } else {
        doc = contextNode.ownerDocument;
    }
    var namespaceResolver = function (nsPrefix) {
        var namespaceURI = namespaces[nsPrefix];
        return namespaceURI == null ? null : String(namespaceURI);
    };
    if (resultType == null) resultType = 9;
    var xpathResult = doc.evaluate(xpathExpression, contextNode, namespaces == null ? null : namespaceResolver, resultType, null);
    switch (resultType) {
        case 0: // ANY_TYPE
            break;

        case 1: // NUMBER_TYPE
            return xpathResult.numberValue;

        case 2: // STRING_TYPE
            return xpathResult.stringValue;

        case 3: // BOOLEAN_TYPE
            return xpathResult.booleanValue;

        case 4: // UNORDERED_NODE_ITERATOR_TYPE
        case 5: // ORDERED_NODE_ITERATOR_TYPE
            // TODO
            return xpathResult;

        case 6: // UNORDERED_NODE_SNAPSHOT_TYPE
        case 7: // ORDERED_NODE_SNAPSHOT_TYPE
            var len = xpathResult.snapshotLength;
            var snapshot = new Array(len);
            for (var i = 0; i < len; ++i) {
                snapshot[i] = xpathResult.snapshotItem(i);
            }
            return snapshot;

        case 8: // ANY_UNORDERED_NODE_TYPE
        case 9: // FIRST_ORDERED_NODE_TYPE
            return xpathResult.singleNodeValue;
    }
    return xpathResult;
},

// helpers for createAbsoluteElement
_insertAfterBodyStart : window.isc_insertAfterBodyStart,
_globalInsertionMarker : "isc_global_insertion_marker",
getInsertionMarkerHTML : function () {
    return "<span id='"+this._globalInsertionMarker+"' style='display:none'></span>";
},
getInsertionMarker : function () {
    return document.getElementById(this._globalInsertionMarker);
},
// create a new, absolutely positioned element, after page load
_$afterBegin : "afterBegin",
_$afterEnd : "afterEnd",
_$beforeBegin: "beforeBegin",
_$beforeEnd : "beforeEnd",
createAbsoluteElement : function (html, targetWindow) {
    var wd = targetWindow || this.getWindow(),

        body = this.getDocumentBody(true);



    //>DEBUG
    // if there's no body tag, we bail
    if (body == null && !isc.Element.noBodyTagMessageShown) {
        isc.Element.noBodyTagMessageShown = true;
        var msg ="Error: Attempt to write content into a page outside the BODY tag.  Isomorphic " +
            "SmartClient requires this tag be present and all widgets be written out inside " +
            "it.\r" +
            "Please ensure your file has a BODY tag and any code to draw SmartClient widgets " +
            "is enclosed in this tag."
            ;
        //alert(msg);
        this.logError(msg);
        return;
    }
    //<DEBUG



    // safety valve - use a global var to switch back to our previous rendering mode - set
    // window.isc_insertAfterBodyStart to enable this rendering mode.
    if (this._insertAfterBodyStart) {
        return isc.Element.insertAdjacentHTML(body, this._$afterBegin, html, true);
    }

    if (isc.Browser.isIE) {
        if (!this._insertionMarker) {
            if (body.childNodes.length < 2) {
                // empty body or body with just one element, in either case insert afterBegin
                // of the body on the assumption that the one element may not be closed.
                isc.Element.insertAdjacentHTML(body, this._$afterBegin, this.getInsertionMarkerHTML());
            } else {
                // insert right before the last element
                //
                // If the last element is a text node, spin back through the siblings until we
                // find one that isn't a text node because calling
                // textNode.insertAdjacentHTML() results in a "no such method" in IE
                //
                // One natural way in which such text elements get created is by the use of an
                // <INPUT> element with no enclosing <FORM> tag, right at the end of the page.
                var node = body.lastChild;
                while (node && node.nodeType == 3) node = node.previousSibling;
                if (node != null) {
                    isc.Element.insertAdjacentHTML(node, this._$beforeBegin,
                                                  this.getInsertionMarkerHTML());
                } else {
                    // all nodes of the body are text nodes, insert after body begin
                    isc.Element.insertAdjacentHTML(body, this._$afterBegin, this.getInsertionMarkerHTML());
                }
            }
            this._insertionMarker = this.getInsertionMarker();
        }
        return isc.Element.insertAdjacentHTML(this._insertionMarker, this._$afterEnd, html, true);
    } else {
        return isc.Element.insertAdjacentHTML(body, this._$beforeEnd, html, true);
    }
},

// emulate IE's insertAdjacentHTML on any fully DOM-compliant browser
insertAdjacentHTML : function (element, where, html, singleElement) {
    where = where.toLowerCase(); // case-insensitive match

    // handle string element IDs
    if (isc.isA.String(element)) element = isc.Element.get(element);

    //>DEBUG
    if (!element) this.logWarn("insertAdjacentHTML: element is null for where: '" + where +
                                "' with html: " + html);
    //<DEBUG

    // Use insertAdjacentHTML() if it is available.

    if (isc.Browser.useInsertAdjacentHTML) {
        try {
            element.insertAdjacentHTML(where, html);

            if (singleElement) {

                switch (where) {
                    case "beforebegin":
                        return element.previousSibling;
                    case "afterbegin":
                        return element.firstChild;
                    case "beforeend":
                        return element.lastChild;
                    case "afterend":
                        return element.nextSibling;
                }
            }
            return;
        } catch (e) {
            // In IE 6, 7, 8, and 9, insertAdjacentHTML() does not work on some elements,
            // notably TABLE, THEAD, TBODY, TFOOT, and TR elements. Attempting to call
            // insertAdjacentHTML() on one of those elements results in an exception
            // "Invalid target element for this operation.", error number -2146827688.
            //
            // If that happens, fall through to the alternative implementation.
        }
    }

    //this.logWarn("inserting at element: " + this.echoLeaf(element) +
    //             " at position " + where + ", html: " + this.echoLeaf(html));



    var newElement,
        doc = element.ownerDocument;
    if (isc.Browser._supportsCreateContextualFragment) {
        // create a document fragment from the HTML via Range.createContextualFragment()
        var range = doc.createRange();
        range.setStartBefore(element);
        newElement = range.createContextualFragment(html);
        if (singleElement) newElement = newElement.firstChild;
    } else {
        var wrapper = doc.createElement("DIV");

        if (element.tagName == "TR" && isc.Browser.isIE) {
            wrapper.innerHTML = "<table><tbody><tr>" + html + "</tr></tbody></table>";
            wrapper = wrapper.firstChild.firstChild.firstChild;
        } else {
            wrapper.innerHTML = html;
        }
        if (singleElement || wrapper.firstChild == wrapper.lastChild) newElement = wrapper.firstChild;
        else {
            newElement = doc.createDocumentFragment();
            var child;
            while ((child = wrapper.firstChild)) {
                newElement.appendChild(child);
            }
        }
    }

    // insert it into the given parent
    switch (where){
    case "beforebegin":
        element.parentNode.insertBefore(newElement, element);
        break;
    case "afterbegin":
        element.insertBefore(newElement, element.firstChild);
        break;
    case "beforeend":
        element.appendChild(newElement);
        break;
    case "afterend":
        element.parentNode.insertBefore(newElement, element.nextSibling);
        break;
    }
    if (singleElement) return newElement;
},

// clear the element passed in (removing its HTML from the DOM)
clear : function (element, useRemoveChild) {
    if (element == null) return;


    if (!useRemoveChild && isc.Page.isLoaded() && isc.Browser.isIE &&
        element.ownerDocument.documentElement.contains(element))
    {
        element.outerHTML = isc.emptyString;
        return;
    }

    if (element.parentNode != null) {
        element.parentNode.removeChild(element);
    } else {

        //>DEBUG
        isc.Log.logWarn("element parentNode null"); //<DEBUG
        element.innerHTML = "";
    }
},

// ----------------------------------------------------------------------------------------
// Deriving sizing/positioning + margins etc information from HTML elements
// ----------------------------------------------------------------------------------------
// As with Canvii, these methods will work with the size of the HTML element, INCLUDING any
// margins wherever appropriate.
// This means:
// - getOffsetLeft(element) / getOffsetTop(element) return the offset top / left of the element's
//   margin, rather than of the element itself
// - getVisibleWidth(element) / getVisibleHeight(element) return the height / width of the element
//   including top and bottom margins.


_boxSizingCSSName: ("boxSizing" in document.documentElement.style
                    ? "box-sizing"
                    : isc.Element.vendorCSSPrefix + "box-sizing"),
_boxSizingStyleName: ("boxSizing" in document.documentElement.style
                      ? "boxSizing"
                      : isc.Element.vendorStylePrefix + "BoxSizing"),

// helper: Does this element adhere to the border-box model or the content-box model for sizing?
isBorderBox : function (element) {
    if (!element) return false;
    if (!isc.Browser.isMoz) return isc.Browser.isBorderBox;

    return (element.style[this._boxSizingStyleName] === "border-box");
},

// Return the scrollHeight (scrollable height) for the element.
getScrollHeight : function (element) {

    if (element == null) return 0;


    var height = ((element.scrollHeight!= null && element.scrollHeight != "undefined")
                                                ? element.scrollHeight : element.offsetHeight);


    var largestBottom = this._getPositionedChildrenBottom(element);

    return largestBottom > height ? largestBottom : height;
},

// get the largest bottom coordinate for any explicitly positioned DOM children of this element
_getPositionedChildrenBottom : function (element) {
    if (element.childNodes == null) return 0;

    var largest = 0,
        // constants for determining whether a DOM node is an element.

        elementType = document.ELEMENT_NODE || 1,
        debug = this.logIsDebugEnabled("sizing");

    for (var i = 0; i < element.childNodes.length; i++) {
        var child = element.childNodes.item(i);

        // ignore anything that isn't an element (only elements report any size information)
        if (child.nodeType != elementType) continue;

        var childPosition = isc.Element.getComputedStyleAttribute(child, "position");

        // get the top coordinate of the child
        var childTop = 0;
        if (childPosition == isc.Canvas.ABSOLUTE || childPosition == isc.Canvas.RELATIVE) {
            childTop += isc.Element.getOffsetTop(child);
        } else {
            // inline content ("position" property unset).  We don't inspect this because the
            // scrollWidth reported by the element includes inline content
            continue;
        }


        var canvas = child.getAttribute("eventProxy"),
            childVisibleHeight;
        if (canvas != null &&
            !isc.isAn.emptyString(canvas) &&
            !window[canvas]._retrievingScrollHeight &&
            isc.isA.Function(window[canvas].getVisibleHeight))
        {
            childVisibleHeight = window[canvas].getVisibleHeight();
        } else {
            // For regular DOM elements call isc.Element.getVisibleHeight(element) instead
            childVisibleHeight = isc.Element.getVisibleHeight(child);
        }

        var childBottom = childTop + childVisibleHeight;
        // Notes:
        // - the 'visibleHeight' is the height of this child, including any margins.
        //   if this (parent) is scrollable, and the child is absolutely positioned, we
        //   natively can't scroll to the right/bottom margin, so deduct this from the reported
        //   parent scroll-width.
        // - This child will be drawn over the top of any padding applied to the element, so we
        //   don't need to add that to the childBottom value.  Only inline elements will force
        //   the parents' padding to show up below them.
        if (childPosition == isc.Canvas.ABSOLUTE &&
            (element.style.overflow == isc.Canvas.SCROLL ||
             element.style.overflow == isc.Canvas.AUTO ||
             element.style.overflow == isc.Canvas.HIDDEN))
             childBottom -= isc.Element.getBottomMargin(child);



        if (childBottom > largest) largest = childBottom;


    }
    return largest;
},

// isc.Element.getScrollWidth(element) - See comments for getScrollHeight
getScrollWidth : function (element) {
    if (element == null) return 0;


    var width = ((element.scrollWidth != null && element.scrollWidth != "undefined") ?
                     element.scrollWidth : element.offsetWidth);

    // if we have any position:absolute or position:relative children, find the right-most one
    var largestRight = this._getPositionedChildrenRight(element);

    return largestRight > width ? largestRight : width;
},

// get the largest right coordinate for any explicitly positioned DOM children of this element
_getPositionedChildrenRight : function (element) {
    if (element.childNodes == null) return 0;

    var largest = 0,
        // constants for determining whether a DOM node is an element.

        elementType = document.ELEMENT_NODE || 1,
        debug = this.logIsDebugEnabled("sizing");

    for (var i = 0; i < element.childNodes.length; i++) {
        var child = element.childNodes.item(i);

        if (child.nodeType != elementType) continue;

        var childStyle = isc.Element.getComputedStyle(child, ["position", "display", "left"]);

        var childLeft = 0;
        if (childStyle.position == isc.Canvas.ABSOLUTE ||
            childStyle.position == isc.Canvas.RELATIVE)
        {
            childLeft = isc.Element.getOffsetLeft(child);
        } else {
            // inline content ("position" property unset).  We don't inspect this because the
            // scrollWidth reported by the element includes inline content
            continue;
        }


        var canvas = child.getAttribute("eventProxy"),
            childVisibleWidth;
        if (canvas != null &&
            !isc.isAn.emptyString(canvas) &&
            !window[canvas]._retrievingScrollWidth &&
            isc.isA.Function(window[canvas].getVisibleWidth))
        {
            childVisibleWidth = window[canvas].getVisibleWidth();
        } else {
            // For regular DOM elements call isc.Element.getVisibleWidth(element) instead
            childVisibleWidth = isc.Element.getVisibleWidth(child);
        }

        var childRight = childLeft + childVisibleWidth;
        if (element.style.overflow == isc.Canvas.SCROLL ||
            element.style.overflow == isc.Canvas.HIDDEN ||
            element.style.overflow == isc.Canvas.AUTO) {
                childRight -= isc.Element.getRightMargin(child);
       }

        if (childRight > largest) largest = childRight;

        //>DEBUG
        if (debug) {
            this.logInfo("getChildNodesRight: child node " + i + " of " +
                         element.childNodes.length + " (" + this.echoLeaf(child) + ")" +
                         " left:" + childLeft + ", width: " + childVisibleWidth +
                         ", right:" + childRight, "sizing");
        }
        //<DEBUG
    }
    return largest;
},

getClientWidth : function (element) {

    if (isc.Browser.isIE && (isc.Browser.isIE9 || isc.Browser.version >= 10)) {
        // IE 9 Strict Mode and IE 10 have getComputedStyle().
        var cssStyleDecl = window.getComputedStyle(element, null),

            clientWidth = parseFloat(cssStyleDecl.width) + parseFloat(cssStyleDecl.paddingRight) +
                          parseFloat(cssStyleDecl.paddingLeft);
        return Math.ceil(clientWidth);
    } else {
        return element.clientWidth;
    }
},

getElementRect : function (element) {
    var body = this.getDocumentBody(),
        left = this.getLeftOffset(element, body),
        top = this.getTopOffset(element, body);

    var width = 0, height = 0;
    if (element.style && element.style.overflow == "visible") {
        width = this.getScrollWidth(element);
        height = this.getScrollHeight(element);
    }

    width = Math.max(element.offsetWidth, element.clientWidth, width);
    height = Math.max(element.offsetHeight, element.clientHeight, height);
    return [ left, top, width, height ];
},

// get the inner width of an arbitrary dom element
// Note: we use this for widgets with htmlElement and matchElement set.
// Implementation doesn't cache results - don't use this in critical path code as it may be
// somewhat slow
getInnerWidth : function (element) {
    // assume content-box sizing (the default)
    // If specified style.width will be the available 'inner' width, excluding padding,
    // margin, border
    // (ignore element overflow for now)
    var styleWidth = element.style.width;
    if (styleWidth != null && !isc.isAn.emptyString(styleWidth)) {
        styleWidth = parseInt(styleWidth);
        if (isc.isA.Number(styleWidth)) return styleWidth;
    }

    // If width is unspecified - measure how large the element rendered out.
    //
    // element.clientWidth will be the width of the element excluding border and margin,
    // but including padding. Delete the padding thickness to get the widget we want.
    var clientWidth = element.clientWidth,
        paddingLeft = parseInt(this.getComputedStyleAttribute("paddingLeft")),
        paddingRight = parseInt(this.getComputedStyleAttribute("paddingRight")),
        padding = paddingLeft + paddingRight;
    if (isc.isA.Number(padding)) clientWidth -= padding;
    return clientWidth;
},
getInnerHeight : function (element) {
    // assume content-box sizing (the default)
    // If specified style.width will be the available 'inner' width, excluding padding,
    // margin, border
    // (ignore element overflow for now)
    var styleHeight = element.style.height;
    if (styleHeight != null && !isc.isAn.emptyString(styleHeight)) {
        styleHeight = parseInt(styleHeight);
        if (isc.isA.Number(styleHeight)) return styleHeight;
    }

    // If height is unspecified - measure how large the element rendered out.
    var clientHeight = element.clientHeight,
        paddingTop = parseInt(this.getComputedStyleAttribute("paddingTop")),
        paddingBottom = parseInt(this.getComputedStyleAttribute("paddingBottom")),
        padding = paddingTop + paddingBottom;
    if (isc.isA.Number(padding)) clientHeight -= padding;
    return clientHeight;
},


getNativeInnerWidth : function (element) {
    if (isc.Browser.isMoz) return this.getInnerWidth(element);
    var width = element.offsetWidth;
    // 0 or null
    if (!width) width = this.getInnerWidth(element);
    return width;
},
getNativeInnerHeight : function (element) {
    if (isc.Browser.isMoz) return this.getInnerHeight(element);
    var height = element.offsetHeight;
    // 0 or null
    if (!height) height = this.getInnerHeight(element);
    return height;
},




// Methods to get the margin sizes for an element

getTopMargin : function (element) {
    if (element != null) {
        var topMargin;
        if (element.style != null) topMargin = parseInt(element.style.marginTop);
        if (isc.isA.Number(topMargin)) return topMargin;
        if (element.className != null) return isc.Element._getTopMargin(element.className);
    }
    return 0;
},
getBottomMargin : function (element) {
    if (element != null) {
        var bottomMargin;
        if (element.style != null) bottomMargin = parseInt(element.style.marginBottom);
        if (isc.isA.Number(bottomMargin)) return bottomMargin;
        if (element.className != null) return isc.Element._getBottomMargin(element.className);
    }
    return 0;
},
getLeftMargin : function (element) {
    if (element != null) {
        var leftMargin;
        if (element.style != null) leftMargin = parseInt(element.style.marginLeft);
        if (isc.isA.Number(leftMargin)) return leftMargin;
        if (element.className != null) return isc.Element._getLeftMargin(element.className);
    }
    return 0;
},
getRightMargin : function (element) {
    if (element != null) {
        var rightMargin;
        if (element.style != null) rightMargin = parseInt(element.style.marginRight);
        if (isc.isA.Number(rightMargin)) return rightMargin;
        if (element.className != null) return isc.Element._getRightMargin(element.className);
    }
    return 0;
},

getHMarginSize : function (element) {
    return isc.Element.getLeftMargin(element) + isc.Element.getRightMargin(element);
},
getVMarginSize : function (element) {
    return isc.Element.getTopMargin(element) + isc.Element.getBottomMargin(element);
},

// element.currentStyle gives us the computed style of an element in IE / Opera
// Not available in IE9 [rendering in IE9 rendering mode]
_useCurrentStyle:(isc.Browser.isIE && !isc.Browser.isIE9) || isc.Browser.isOpera,

getTopBorderSize : function (element) {
    if (element == null) return 0;
    if (isc.Browser.isOpera && element.currentStyle.borderTopStyle == this._$none) return 0;
    var borderSize = (this._useCurrentStyle
                        ? Math.ceil(parseFloat(element.currentStyle.borderTopWidth))
                        : parseInt(isc.Element.getComputedStyleAttribute(element, "borderTopWidth"))
                      );

    return isNaN(borderSize) ? 0 : borderSize;
},

getBottomBorderSize : function (element) {
    if (element == null) return 0;
    if (isc.Browser.isOpera && element.currentStyle.borderBottomStyle == this._$none) return 0;
    var borderSize = (this._useCurrentStyle
                        ? Math.ceil(parseFloat(element.currentStyle.borderBottomWidth))
                        : parseInt(isc.Element.getComputedStyleAttribute(element, "borderBottomWidth"))
                     );
    return isNaN(borderSize) ? 0 : borderSize;
},

getLeftBorderSize : function (element) {
    if (element == null) return 0;
    if (isc.Browser.isOpera && element.currentStyle.borderLeftStyle == this._$none) return 0;
    var borderSize = (this._useCurrentStyle
                        ? Math.ceil(parseFloat(element.currentStyle.borderLeftWidth))
                        : parseInt(isc.Element.getComputedStyleAttribute(element, "borderLeftWidth"))
                     );
    return isNaN(borderSize) ? 0 : borderSize;
},

getRightBorderSize : function (element) {
    if (element == null) return 0;
    if (isc.Browser.isOpera && element.currentStyle.borderRightStyle == this._$none) return 0;
    var borderSize = (this._useCurrentStyle
                        ? Math.ceil(parseFloat(element.currentStyle.borderRightWidth))
                        : parseInt(isc.Element.getComputedStyleAttribute(element, "borderRightWidth"))
                      );
    return isNaN(borderSize) ? 0 : borderSize;
},

getBorderSizes : function (element) {
    var result = {
        top: isc.Element.getTopBorderSize(element),
        bottom: isc.Element.getBottomBorderSize(element),
        left: isc.Element.getLeftBorderSize(element),
        right: isc.Element.getRightBorderSize(element)
    };
    result.Top = result.top;
    result.Bottom = result.bottom;
    result.Left = result.left;
    result.Right = result.right;
    return result;
},

getVBorderSize : function (element) {
    return isc.Element.getTopBorderSize(element) + isc.Element.getBottomBorderSize(element);
},
getHBorderSize : function (element) {
    return isc.Element.getLeftBorderSize(element) + isc.Element.getRightBorderSize(element);
},

getTopPaddingSize : function (element) {
    if (element == null) return 0;
    var paddingSize = (this._useCurrentStyle
                        ? parseInt(element.currentStyle.paddingTop)
                        : parseInt(isc.Element.getComputedStyleAttribute(element, "paddingTop"))
                      );
    return isNaN(paddingSize) ? 0 : paddingSize;
},

getBottomPaddingSize : function (element) {
    if (element == null) return 0;
    var paddingSize = (this._useCurrentStyle
                        ? parseInt(element.currentStyle.paddingBottom)
                        : parseInt(isc.Element.getComputedStyleAttribute(element, "paddingBottom"))
                      );
    return isNaN(paddingSize) ? 0 : paddingSize;
},

getLeftPaddingSize : function (element) {
    if (element == null) return 0;
    var paddingSize = (this._useCurrentStyle
                        ? parseInt(element.currentStyle.paddingLeft)
                        : parseInt(isc.Element.getComputedStyleAttribute(element, "paddingLeft"))
                      );
    return isNaN(paddingSize) ? 0 : paddingSize;
},

getRightPaddingSize : function (element) {
    if (element == null) return 0;
    var paddingSize = (this._useCurrentStyle
                        ? parseInt(element.currentStyle.paddingRight)
                        : parseInt(isc.Element.getComputedStyleAttribute(element, "paddingRight"))
                      );
    return isNaN(paddingSize) ? 0 : paddingSize;
},

getVPaddingSize : function (element) {
    return isc.Element.getTopPaddingSize(element) + isc.Element.getBottomPaddingSize(element);
},
getHPaddingSize : function (element) {
    return isc.Element.getLeftPaddingSize(element) + isc.Element.getRightPaddingSize(element);
},

// getVisibleWidth / getVisibleHeight:
// when passed a DOM element, return the drawn size of the element, including any overflow,
// border, margin or padding.
getVisibleWidth : function (element) {
    if (element == null) return 0;

    var overflow = isc.Element.getComputedStyleAttribute(element, "overflow"),
        width;
    if (overflow == isc.Canvas.VISIBLE || !isc.isA.Number(parseInt(element.style.width))) {
        width = isc.Element.getScrollWidth(element) +
                isc.Element.getHBorderSize(element);

    } else {
        // use the specified width
        width = parseInt(element.style.width);
    }
    return width + isc.Element.getHMarginSize(element);
},

getVisibleHeight : function (element) {
    if (element == null) return 0;

    var overflow = isc.Element.getComputedStyleAttribute(element, "overflow"),
        height;
    if (overflow == isc.Canvas.VISIBLE || !isc.isA.Number(parseInt(element.style.height))) {
        height = isc.Element.getScrollHeight(element) + isc.Element.getVBorderSize(element);
    } else {
        // use the specified height
        height = parseInt(element.style.height);
    }
    return height + isc.Element.getVMarginSize(element);
},


// Element.getOffsetLeft()
//  Takes 'element'
//  element should be a pointer to a DOM element or the ID for a DOM element
//  (To get the offsetLeft for a widget use use widget.getOffsetLeft() instead)
//  Returns the true offsetLeft - the absolute left coordinate with respect to whatever is
//  reported by the DOM as the offsetParent of the element.
getOffsetLeft : function (element) {

    // Note: This method is used by the canvas instance 'getOffsetLeft()' method to calculate
    // the offset position.
    // We work with coordinates / sizes relative to the outside of any margins around our
    // widgets - do the same with this method.

    if (element == null) {
        this.logWarn("getOffsetLeft: passed null element");
        return 0;
    }

    // IE and Moz both return somewhat unreliable values for element.offsetLeft by default.
    // Paper over these bugs and differences.
    var left = element.offsetLeft;
    // --- caching code:
    // If we've already calculated a value (based on a reported offsetLeft value), and
    // the reported value has not changed, return the previously calculated value.
    // This caching is safe except for cases where an indirect parent's styling changes in a
    // way that would affect this element's true offsetLeft.
    if (element._cachedReportedOffsetLeft == left) {
        return element._cachedCalculatedOffsetLeft;
    } else {
        // debug message for sanity checking coordinate caching
        //this.logWarn(element.getAttribute("eventProxy") + ": new DOM value for offsetLeft");
    }

    // always subtract the left margin (if there is one) to get the position OUTSIDE the
    // margins.
    // Note: for a negative margin, the reported offsetLeft does not need to be adjusted by the
    // specified margin size - it represents the position of the element - and in this case there
    // is no margin outside the element (rather the specified margin shifts the element to the
    // left / up)
    var leftMargin = parseInt(isc.Element.getComputedStyleAttribute(element, "marginLeft"));
    if (isc.isA.Number(leftMargin) && leftMargin > 0) {
        left -= leftMargin;
    }


    var documentBody = this.getDocumentBody(),
        parentStyle,
        px = "px",
        // determine whether the element is absolutely / relatively / etc. positioned
        elementPosition = element.style.position;

    // Workarounds for Moz
    if (isc.Browser.isMoz) {
        // In moz we get some unexpected results

        if (element.offsetParent == null) return left;

        if (element.offsetParent != documentBody) {

            parentStyle =
                this.ns.Element.getComputedStyle(element.offsetParent, ["borderLeftWidth", "overflow"]);

            // The behavior changes with different releses of Moz / Firefox
            var geckoVersion = isc.Browser.geckoVersion,


                scrollingAdjustment = geckoVersion < 20100101 &&
                                     ((parentStyle.overflow != "visible") &&
                                      (geckoVersion >= 20051111 ||
                                      (elementPosition == isc.Canvas.ABSOLUTE && parentStyle.overflow != "hidden"))),

                accountForBorderBox = (geckoVersion > 20020826 &&
                                        (element.offsetParent.style[this._boxSizingStyleName] === "border-box"));


            if (isc.Browser.version < 8 && accountForBorderBox != scrollingAdjustment) {


                if (accountForBorderBox) {
                    left -= (isc.isA.Number(parseInt(parentStyle.borderLeftWidth)) ?
                                            parseInt(parentStyle.borderLeftWidth) : 0);

                }

                if (scrollingAdjustment) {
                    left += (isc.isA.Number(parseInt(parentStyle.borderLeftWidth)) ?
                                            parseInt(parentStyle.borderLeftWidth) : 0);

                }
            }

        }
    }

    // Workarounds for IE
    // IE8 Strict mode (HTML4 strict doctype or HTML5 doctype) - includes parents' border
    // in reported offsetLeft/offsetTop
    if (isc.Browser.isIE8Strict && !isc.Browser.isIE9) {
        var currentParent = element.offsetParent,
            parentStyle = currentParent ? currentParent.currentStyle : null,
            borderLeftWidth = parentStyle ? parentStyle.borderLeftWidth : null;
        if (isc.isA.String(borderLeftWidth) && borderLeftWidth.contains(px)) {
            left -= parseInt(borderLeftWidth);
        }


    } else if (isc.Browser.isIE && !isc.Browser.isIE9) {



        var currentParent = element.offsetParent,
            parentStyle;
        if (parentStyle != documentBody) parentStyle = currentParent.currentStyle;


        var hasSpecifiedSize = (element.currentStyle.height != isc.Canvas.AUTO ||
                                element.currentStyle.width != isc.Canvas.AUTO);


        var continueDeductingBorders = true;

        // iterate up the offsetParents till we reach the doc. body
        while (currentParent != documentBody) {




            if (parentStyle.position == isc.Canvas.ABSOLUTE) continueDeductingBorders = false;


            if (parentStyle.width == isc.Canvas.AUTO &&
                parentStyle.height == isc.Canvas.AUTO &&
                parentStyle.position == isc.Canvas.RELATIVE) {


                if (continueDeductingBorders &&
                    isc.isA.String(parentStyle.borderLeftWidth) &&
                    parentStyle.borderLeftWidth.contains(px)        ) {
                        left -= parseInt(parentStyle.borderLeftWidth);
                }


                if (hasSpecifiedSize) {

                    if (isc.isA.String(parentStyle.marginLeft) &&
                        parentStyle.marginLeft.contains(px))
                    {
                        var parentMarginLeft = parseInt(parentStyle.marginLeft);
                        if (parentMarginLeft > 0) left -= parentMarginLeft;
                    }


                    if (currentParent.offsetParent != documentBody) {

                        var superPadding = currentParent.offsetParent.currentStyle.padding;
                        if (isc.isA.String(superPadding) && superPadding.contains(px)) {
                            left -= parseInt(superPadding);
                        }
                    } else {

                        left -= (documentBody.leftMargin ? parseInt(documentBody.leftMargin) : 0);
                    }
                }

            } // end of if


            elementPosition = currentParent.style.position;
            currentParent = currentParent.offsetParent;
            if (currentParent != document.body) {
                parentStyle = currentParent.currentStyle;
            }

        }   // End of while loop

    }

    // Workarounds for Safari
    if (isc.Browser.isSafari && isc.Browser.safariVersion < 525.271) {
        // In some versions of Safari, if the offsetParent has a border, the offsetLeft / top
        // reported is relative to the outside of that border, rather than the inside, so deduct
        // that value
        // No longer the case in Safari 3.2.1 (525.27.1)
        if (element.offsetParent != null && element.offsetParent != documentBody) {
            var parentBorder =
                this.ns.Element.getComputedStyle(element.offsetParent, ["borderLeftWidth"]).borderLeftWidth;
            if (parentBorder != null) parentBorder = parseInt(parentBorder);
            if (isc.isA.Number(parentBorder)) left -= parentBorder;
        }

    } else if (isc.Browser.isOpera && isc.Browser.version >= 12 && element.offsetParent) {
        if (element.offsetParent.id.endsWith("_clipDiv")) {
            var parentBCR = this.getBoundingClientRect(element.offsetParent),
                bcr = this.getBoundingClientRect(element);
            left = bcr.left - parentBCR.left;
        }
    }

    // --- cacheing code:
    // Cache the calculated and reported value, by saving it as attributes on the DOM element
    element._cachedReportedOffsetLeft = element.offsetLeft;
    element._cachedCalculatedOffsetLeft = left;

    return left;
},

// Element.getOffsetTop()
//  Takes 'element'
//  element should be a pointer to a DOM element or the ID for a DOM element (doesn't
//  handle getting a widget ID - in that case use widget.getOffsetTop() instead)
//  Returns the true offsetTop - the absolute top coordinate with respect to (the inside of any
//  border of) whatever is reported by the DOM as the offsetParent of the element.

getOffsetTop : function (element) {
    // In theory the value element.offsetTop should be what we want here. However it is
    // unreliable in a number of ways.
    if (element == null) {
        this.logWarn("getOffsetTop: passed null element");
        return 0;
    }

    // IE and Moz both return somewhat unreliable values for element.offsetTop by default.
    // Paper over these bugs and differences.
    var top = element.offsetTop;  // This is what we'd return if the browsers worked correctly!


    if (isc.Browser.isFirefox && isc.Browser.isStrict && top < 0) {
        var parent = element.offsetParent;
        if (parent != null) {
            if (this.getBoundingClientRect(parent).top ==
                this.getBoundingClientRect(element).top)
            {
                top = 0;
            }
        }
    }

    // --- caching code:
    // If we've already calculated a value (based on a reported offsetTop value), and
    // the reported value has not changed, return the previously calculated value.
    if (element._cachedReportedOffsetTop == top) {
       return element._cachedCalculatedOffsetTop;
    } else {
        // debug message for sanity checking coordinate caching
        //this.logWarn(element.getAttribute("eventProxy") + ": new DOM value for offsetTop");
    }

    // The reported offsetTop is the offset from the element, INSIDE of margins to the
    // offsetParent - if we have a top margin we should subtract it to get the position OUTSIDE
    // the margins.
    // Exception: If the margin is negative, we don't need to adjust for it. In this case the
    // reported offset is still to the outside of the element, even though the element is
    // essentially shifted above where it would normally appear.

    var topMargin = parseInt(isc.Element.getComputedStyleAttribute(element, "marginTop"));
    if (isc.isA.Number(topMargin) && topMargin > 0) {
        top -= topMargin;
    }

    var documentBody = this.getDocumentBody(),
        parentStyle,
        px = "px",
        elementPosition = element.style.position;

    // Workarounds for Moz
    if (isc.Browser.isMoz) {



        if (element.offsetParent == null) return top;
        if (element.offsetParent != documentBody) {

            // get the offsetParent's style info
            parentStyle = this.ns.Element.getComputedStyle(element.offsetParent, ["overflow", "borderTopWidth"]);

            var geckoVersion = isc.Browser.geckoVersion;

            var scrollingAdjustment = geckoVersion < 20100101 &&
                                     ((parentStyle.overflow != "visible") &&
                                      (geckoVersion >= 20051111 ||
                                      (elementPosition == isc.Canvas.ABSOLUTE && parentStyle.overflow != "hidden"))),
                accountForBorderBox = (isc.Browser.geckoVersion > 20020826 &&
                                        element.offsetParent.style[this._boxSizingStyleName] === "border-box");

            if (isc.Browser.version < 8 && accountForBorderBox != scrollingAdjustment) {
                if (accountForBorderBox) {
                    top -= (isc.isA.Number(parseInt(parentStyle.borderTopWidth)) ?
                                            parseInt(parentStyle.borderTopWidth) : 0);

                }
                if (scrollingAdjustment) {
                    top += (isc.isA.Number(parseInt(parentStyle.borderTopWidth)) ?
                                            parseInt(parentStyle.borderTopWidth) : 0);
                }
            }
        }
    }

    // Workarounds for IE
    // IE8 Strict mode (HTML4 strict doctype or HTML5 doctype) - includes parents' border
    // in reported offsetLeft/offsetTop
    if (isc.Browser.isIE8Strict && !isc.Browser.isIE9) {
        var currentParent = element.offsetParent,
            parentStyle = currentParent ? currentParent.currentStyle : null,
            borderTopWidth = parentStyle ? parentStyle.borderTopWidth : null;
        if (isc.isA.String(borderTopWidth) && borderTopWidth.contains(px)) {
            top -= parseInt(borderTopWidth);
        }


    } else if (isc.Browser.isIE && !isc.Browser.isIE9) {

        if (element.offsetParent && element.offsetParent != documentBody) {

            parentStyle = element.offsetParent.currentStyle;


            if (    parentStyle.position == isc.Canvas.RELATIVE &&
                    parentStyle.height == isc.Canvas.AUTO &&
                    parentStyle.width == isc.Canvas.AUTO &&
                    isc.isA.String(parentStyle.borderTopWidth) &&
                    parentStyle.borderTopWidth.contains(px)         ) {
                        top -= parseInt(parentStyle.borderTopWidth);
            }
        }
    }

    // Workarounds for Safari
    if (isc.Browser.isSafari && isc.Browser.safariVersion < 525.271) {
        // As noted in 'getOffsetLeft()', in Safari the width of the parent's border is included
        // in the offsetLeft/top value reported.
        if (element.offsetParent && element.offsetParent != documentBody) {
            var parentBorder =
                this.ns.Element.getComputedStyle(element.offsetParent,
                                                ["borderTopWidth"]).borderTopWidth;

            if (parentBorder != null) parentBorder = parseInt(parentBorder);
            if (isc.isA.Number(parentBorder)) top -= parentBorder;
        }

    } else if (isc.Browser.isOpera && isc.Browser.version >= 12 && element.offsetParent) {
        if (element.offsetParent.id.endsWith("_clipDiv")) {
            var parentBCR = this.getBoundingClientRect(element.offsetParent),
                bcr = this.getBoundingClientRect(element);
            top = bcr.top - parentBCR.top;
        }
    }

    // --- cacheing code:
    // Cache the calculated and reported value, by saving it as attributes on the DOM element
    element._cachedReportedOffsetTop = element.offsetTop;
    element._cachedCalculatedOffsetTop = top;

    return top;
},

// getLeftOffset(element, targetElement, rtl)
//
// DOM Only method to return the absolute (offset) position for some element within some other
// DOM parent element.  We will return this value from the outside of any border / margin on
// the child to the inside of the ancestor element.
//

getLeftOffset : function (element, targetElement, rtl, canvasArgs) {
    return this.getOffset(isc.Canvas.LEFT, element, targetElement, rtl, canvasArgs);
},

// Return the absolute position of an element within a DOM parent element.
// If no target parent element is passed, we return page level position.
getTopOffset : function (element, targetElement, canvasArgs) {
    return this.getOffset(isc.Canvas.TOP, element, targetElement, null, canvasArgs);
},


_$borderLeftWidth: "borderLeftWidth",
_$borderTopWidth: "borderTopWidth",
_$marginLeft: "marginLeft",
_$marginTop: "marginTop",
_$none:"none",



_$leftCoords: "_$leftCoords",
_$topCoords: "_$topCoords",

_$BODY: "BODY",
_$HTML: "HTML",
_isDocElemBCROkay: !isc.Browser.isIE && !isc.Browser.isOpera,
getBoundingClientRect : function (element) {

    var isDocElemBCROkay = this._isDocElemBCROkay;
    if (element.tagName === this._$BODY ||
        (!isDocElemBCROkay && element.tagName === this._$HTML))
    {
        var doc = element.ownerDocument,
            docElem = doc.documentElement;
        if (isDocElemBCROkay) {
            return docElem.getBoundingClientRect();
        } else {
            var isIEQuirks = isc.Browser.isIE && !isc.Browser.isStrict;
            if (isIEQuirks && isc.Browser.version == 6) {

                var bcr = element.getBoundingClientRect(),
                    left = -doc.body.scrollLeft + (docElem.clientLeft || 0),
                    top = -doc.body.scrollTop + (docElem.clientTop || 0),
                    width = Math.max(docElem.offsetWidth, bcr.right),
                    height = Math.max(docElem.offsetHeight, bcr.bottom);
                return {
                    left: left,
                    top: top,
                    right: left + width,
                    bottom: top + height,
                    width: width,
                    height: height
                };
            } else {
                var bcr = element.getBoundingClientRect(),

                    width = Math.max(docElem.clientWidth, bcr.right),
                    height = Math.max(docElem.clientHeight, bcr.bottom),
                    left = docElem.clientLeft || 0,
                    top = docElem.clientTop || 0;
                if (isIEQuirks) {
                    left -= doc.body.scrollLeft;
                    top -= doc.body.scrollTop;
                } else {
                    var win = doc.defaultView || window;
                    left -= win.pageXOffset || docElem.scrollLeft;
                    top -= win.pageYOffset || docElem.scrollTop;
                }
                return {
                    left: left,
                    top: top,
                    right: left + width,
                    bottom: top + height,
                    width: width,
                    height: height
                };
            }
        }
    } else {

        var bcr = element.getBoundingClientRect();
        if (bcr.width == null) {
            return {
                left: bcr.left,
                top: bcr.top,
                right: bcr.right,
                bottom: bcr.bottom,
                width: bcr.right - bcr.left,
                height: bcr.bottom - bcr.top
            };
        } else {
            return bcr;
        }
    }
},

//> @object ElementOffsets
//<
//> @attr elementOffsets.left (integer : 0 : R)
//<
//> @attr elementOffsets.top (integer : 0 : R)
//<

// cacheOffestCoordinates: If set we will cache calculated offsets between SmartClient
// ancestor/descendent components.
// This improves performance on repeated lookups during (EG) drag/drop, etc

cacheOffsetCoords:true,

//> @classMethod element.getOffsets() [A]
// @param (DOMElement or Canvas) sourceElement
// @param (DOMElement or Canvas) origTargetElement
// @param (Boolean) rtl
// @return (ElementOffsets)
//<
getOffsets : function (sourceElement, origTargetElement, rtl, canvasArgs) {
    var sourceIsCanvas = canvasArgs || isc.isA.Canvas(sourceElement),
        targetIsCanvas = canvasArgs || origTargetElement == null || isc.isA.Canvas(origTargetElement);

    var cacheCoords = sourceIsCanvas && targetIsCanvas && this.cacheOffsetCoords &&
                      (sourceElement.cacheOffsetCoords != false),
        targetID = origTargetElement ? origTargetElement.ID : this._$none;
    if (cacheCoords && sourceElement[this._$leftCoords] != null &&
        sourceElement[this._$topCoords] != null)
    {
        var cachedLeftCoord = sourceElement[this._$leftCoords][targetID],
            cachedTopCoord = sourceElement[this._$topCoords][targetID];
        if (cachedLeftCoord != null && cachedTopCoord != null) {

            return {
                left: cachedLeftCoord,
                top: cachedTopCoord
            };
        }
    }


    var element = sourceIsCanvas ? sourceElement.getClipHandle() : sourceElement;
    var targetElement;

    // if we're not passed an element, determine the offset from the top level HTML element.
    if (origTargetElement == null) targetElement = this.getDocumentBody();

    else if (targetIsCanvas) targetElement = origTargetElement.getHandle();
    else targetElement = origTargetElement;

    //!DONTCOMBINE
    //>DEBUG
    if (targetElement == null || element == null) {

        return {
            left: 0,
            top: 0
        };
    }
    //<DEBUG

    var offsets;

    if (isc.Browser._hasGetBCR) {

        var elementBCR = this.getBoundingClientRect(element),
            targetElementBCR = this.getBoundingClientRect(targetElement);

        offsets = {
            left: (elementBCR["left"] - targetElementBCR["left"]) << 0,
            top: (elementBCR["top"] - targetElementBCR["top"]) << 0
        };
    } else {
        var nextParent = element.offsetParent;


        if (isc.Browser.isMoz && nextParent == null) return 0;


        // To get the offsetLeft / Top with respect to the passed in targetElement,
        // iterate through the offsetParents, summing 'offsetLeft' until we reach the targetElement.
        // If we reach the targetElement's offsetParent before we hit the targetElement we've jumped
        // over the target - this is Ok - just deduct the offsetLeft of the targetElement to adjust
        // for it.
        // For each iteration adjust for scrolling and border / margin thickness
        // (see comments in the while loop below).
        var targetParent = targetElement.offsetParent,
            currentNode = element;

        offsets = {
            left: 0,
            top: 0
        };

        if (rtl == null) rtl = isc.Page.isRTL();

        // iterate up until we reach the targetElement, or the targetElement's offsetParent
        // We could also check for documentBody to avoid crashing in the case where we were
        // passed bad params.
        var iterations = 0;
        while (nextParent != targetElement && nextParent != targetParent) {

            this._adjustOffsets(offsets, currentNode, nextParent, rtl);

            // Move up the DOM chain
            currentNode = nextParent;
            nextParent = currentNode.offsetParent;
            iterations++;
        }

        // At this point the nextParent is either the target or its offsetParent.
        this._adjustOffsets(offsets, currentNode, nextParent, rtl);

        // OffsetLeft from the last iteration was relative to the target's offsetParent -
        // deduct the target's offsetLeft to get the offset relative to the target instead.
        if (nextParent == targetParent) {
            // deduct the targetElement's offsetLeft
            // No need to adjust for border / padding in this case
            offsets.left -= this.getOffsetLeft(targetElement);
            offsets.top -= this.getOffsetTop(targetElement);
        }


    }

    if (cacheCoords) {
        var coordCache = sourceElement[this._$leftCoords] = sourceElement[this._$leftCoords] || {};
        coordCache[targetID] = offsets.left;
        coordCache = sourceElement[this._$topCoords] = sourceElement[this._$topCoords] || {};
        coordCache[targetID] = offsets.top;
    }

    return offsets;
},

_adjustOffsets : function (offsets, currentNode, nextParent, rtl) {
    // Add the currentNode's offsetLeft/top - left w.r.t. its offsetParent
    offsets.left += this.getOffsetLeft(currentNode);
    offsets.top += this.getOffsetTop(currentNode);

    // The offsetLeft/top value is relative to the content of the parent's element - so if
    // the parent is scrolled, and we want the floating position of this element within
    // its parent we have to deduct the scrollLeft of the parent to page coordinate
    // relative to the parent's element's top/left
    if (!rtl) {
        // deduct the scrollLeft
        offsets.left -= nextParent.scrollLeft || 0;
    } else {
        // rtl var is only ever true when calculating left offset.



        var scrollLeft = nextParent.scrollLeft;
        if (isc.isA.Number(scrollLeft)) {
            var overflow = nextParent.style ? nextParent.style.overflow : isc.emptyString;
            if (overflow != isc.Canvas.VISIBLE && overflow != isc.emptyString) {
                var nativeScrollNegativeOrigin = this._nativeScrollNegativeOrigin,
                    nativeScrollInverse = this._nativeScrollInverse;

                // inverse - we can just flip the polarity of the reported scrollLeft to give
                // negative origin.
                if (nativeScrollInverse) {
                    scrollLeft = -scrollLeft;
                    nativeScrollNegativeOrigin = true;

                }
                // convert negative origin to zero origin (so zero = scrolled hard left)
                if (!nativeScrollNegativeOrigin) {
                    scrollLeft = isc.Canvas._adjustScrollLeftForRTL(
                                    scrollLeft, nextParent.scrollWidth,
                                    nextParent.clientWidth,
                                    // param indicates we're currently in zero origin coords and
                                    // want to move to negative origin
                                    true, true);
                }

                offsets.left -= scrollLeft;
            }
        }
    }

    offsets.top -= nextParent.scrollTop || 0;



    // add the border / margin thickness, because when we add the parent's offsetLeft
    // this will be the distance from the OUTSIDE of this element's border/margin
    // to the inside of the next parent's element.
    // Note: Skip this if the margin is negative as in this case the value we have from
    // getOffsetTop() / Left() is actually relative to the outside of the element
    var styleObj, borderLeftWidth, borderTopWidth, marginLeft, marginTop;
    if (this._useCurrentStyle) {

        styleObj = nextParent.currentStyle;


        if (!isc.Browser.isOpera || styleObj.borderLeftStyle != this._$none) {
            borderLeftWidth = parseInt(styleObj.borderLeftWidth);
            if (borderLeftWidth > 0) offsets.left += borderLeftWidth;
        }
        if (!isc.Browser.isOpera || styleObj.borderTopStyle != this._$none) {
            borderTopWidth = parseInt(styleObj.borderTopWidth);
            if (borderTopWidth > 0) offsets.top += borderTopWidth;
        }


        marginLeft = parseInt(styleObj.marginLeft);
        if (marginLeft > 0) offsets.left += marginLeft;
        marginTop = parseInt(styleObj.marginTop);
        if (marginTop > 0) offsets.left += marginLeft;
    } else if (isc.Browser.isMoz) {

        styleObj = window.getComputedStyle(nextParent, null);

        offsets.left += Math.ceil(parseFloat(styleObj.borderLeftWidth));
        offsets.top += Math.ceil(parseFloat(styleObj.borderTopWidth));

        marginLeft = parseInt(styleObj.marginLeft);
        if (marginLeft > 0) offsets.left += marginLeft;
        marginTop = parseInt(styleObj.marginTop);
        if (marginTop > 0) offsets.top += marginTop;
    } else {
        borderLeftWidth = Math.ceil(parseFloat(this.getComputedStyleAttribute(nextParent,
                                                                              this._$borderLeftWidth)));
        if (borderLeftWidth > 0) offsets.left += borderLeftWidth;
        borderTopWidth = Math.ceil(parseFloat(this.getComputedStyleAttribute(nextParent,
                                                                             this._$borderTopWidth)));
        if (borderTopWidth > 0) offsets.top += borderTopWidth;

        marginLeft = parseInt(this.getComputedStyleAttribute(nextParent,
                                                             this._$marginLeft));
        if (marginLeft > 0) offsets.left += marginLeft;
        marginTop = parseInt(this.getComputedStyleAttribute(nextParent,
                                                            this._$marginTop));
        if (marginTop > 0) offsets.top += marginTop;
    }
},


getOffset : function (dir, sourceElement, origTargetElement, rtl, canvasArgs) {
    var offsets = this.getOffsets(sourceElement, origTargetElement, rtl, canvasArgs);
    return offsets[dir];
},

// one-time flags for RTL mode coordinate calculations
_nativeScrollNegativeOrigin:(isc.Browser.isMoz || (isc.Browser.isIE && isc.Browser.minorVersion < 5.5)),
_nativeScrollInverse:(isc.Browser.isIE9 && isc.Browser.isStrict),



// ----------------------------------------------------------------------------------------
// CSS / Styling Lookups
// ----------------------------------------------------------------------------------------
// Retrieval of CSS style declaration and computed styles

// Styling: what we need and why:
// We need to be able to look up border, padding and margin sizes in order to:
// - compensate for errors in reported offsetLeft / offsetTop to have correct page-level
//   coordinates when relatively positioned (needed for arbitrary containing elements not
//   created by ISC)
// - when using the CSS standard box model, be able to write HTML that will render with
//   predictable sizes even when using author-specified CSS styling.  This is critical for grid
//   cell rendering, where correcting sizes after draw is not even close to feasible.
// - get correct scrollHeight when allowing natively positioned children



// cache of CSS style objects
_styleCache:{},
// get the edge widths (border, margin, padding) for a CSS style
getStyleEdges : function (className) {

    if (isc.Browser.isSafari && !isc.Element._safariStrictChecked) {
        isc.Browser.isStrict = isc.Element._testForSafariStrictMode();
        isc.Element._safariStrictChecked = true;
    }


    if (className == null) return null;

    // check whether cache value is defined, so we can cache failed lookups as nulls
    var undef;
    if (this._styleCache[className] !== undef) return this._styleCache[className];

    //this.logWarn("style lookup: " + className + this.getStackTrace());


    var cantDeriveStyles = (isc.Browser.isMoz && isc.Browser.geckoVersion < 20040616),
        styleInfo;

    if (cantDeriveStyles) {
        styleInfo = this.getStyleDeclaration(className);
    } else {

        var mask = isc.Browser.isIE ? this._styleEdgeMaskArray : this._styleEdgeMask;
        styleInfo = this._deriveStyleProperties(className, mask);
    }


    this._styleCache[className] = styleInfo;
    return styleInfo;
},

// In Safari, document.compatMode is not available, so we rely on the fact that
// table cells render their padding outside their specified height in strict mode but not in
// normal compat mode to determine whether we're currently in strict mode
_testForSafariStrictMode : function () {
    if (document.compatMode != null) {

        return document.compatMode == "CSS1Compat";
    }

    var tableHTML = "<TABLE cellspacing=0 cellpadding=2 border=0><tr><td height=30>x</td></tr></TABLE>"

    var tester = isc.Element.createAbsoluteElement(tableHTML);

    var isStrict = tester.offsetHeight > 30;
    isc.Element.clear(tester);

    return isStrict;
},

// get certain key properties of a style by applying it to an element and inspecting that
// element.  Edge-related properties are reliably derivable this way, cssText is known not
// available, other properties would need testing.

_deriveStyleProperties : function (className, mask) {

    var requiresDivTester = (isc.Browser.isIE || isc.Browser.isOpera || isc.Browser.isSafari
                                || (isc.Browser.isMoz && isc.Browser.geckoVersion >=20080205));
    if (!this._cellStyleTester) {

        this.createAbsoluteElement(
            "<TABLE CELLPADDING=81 STYLE='position:absolute;left:0px;top:-2000px;-webkit-user-select:none;'><TR><TD " +

            //(isc.Browser.isSafari ? "style='position:absolute;left:0px;top:0px;' " : "") +
            (isc.Browser.isIE8Strict ?
            " ID=isc_cellStyleTester STYLE='border:0px;margin:0px'><DIV ID=isc_cellInnerStyleTester>" +
                isc.Canvas.blankImgHTML(30,30) + "</DIV></TD>"
            :
            " ID='isc_cellStyleTester'>&nbsp;</TD><TD ID='isc_cellNoStyleTester'>&nbsp;</TD>"
            ) +
            "</TR></TABLE>"
        );
        this._cellStyleTester = isc.Element.get("isc_cellStyleTester");
        if (isc.Browser.isIE8Strict) {
            this._cellInnerStyleTester = isc.Element.get("isc_cellInnerStyleTester");
        }
        // we set the table cellPadding to 81px - this will then be reported back
        // if the padding on the style was unset (allows us to differentiate between
        // null and explicit zero)

        this._$81px = "81px";
        if (isc.Browser.isSafari || isc.Browser.isChrome) {
            var noStyleElement = isc.Element.get("isc_cellNoStyleTester");
            var paddingLeft = ["paddingLeft"];
            var reported81 = this.getComputedStyle(noStyleElement, paddingLeft).paddingLeft;
            if (reported81 != this._$81px) {
                this.logDebug("Browser natively misreporting cell-padding (81px reported as:"
                        + reported81 + "). This behavior is known to occur when the view is " +
                        "zoomed in certain browsers but is worked around by SmartClient and " +
                        "should have no visible effect on the application.", "sizing");
                this._$81px = reported81;
            }
        }
        this._$16384px = "-16384px";

        if (requiresDivTester) {
            this.createAbsoluteElement(
                "<DIV ID=isc_styleTester STYLE='position:absolute;left:0px;top:-2000px;-webkit-user-select:none;'>&nbsp;</DIV>"
            );
            this._styleTester = isc.Element.get("isc_styleTester");
            this._marginMask = ["marginLeft", "marginTop", "marginRight", "marginBottom"];
            if (isc.Browser.isIE8Strict) {
                this._marginMask.addList(["borderLeftWidth", "borderTopWidth",
                                          "borderRightWidth", "borderBottomWidth"]);
            }
        }
    }

    this._cellStyleTester.className = className;
    var style = this.getComputedStyle(this._cellStyleTester, mask);

    //this.logWarn(className + " style is: " + this.echo(style));

    // test for unset padding
    var nullIndicator = this._$81px;
    if (style.paddingLeft == nullIndicator) style.paddingLeft = null;
    if (style.paddingTop == nullIndicator) style.paddingTop = null;
    if (style.paddingRight == nullIndicator) style.paddingRight = null;
    if (style.paddingBottom == nullIndicator) style.paddingBottom = null;

    if (isc.Browser.isIE8Strict) {
        var innerTester = this._cellInnerStyleTester,
            offsetLeft = innerTester.offsetLeft,
            offsetTop = innerTester.offsetTop;

        if (offsetLeft == 81) style.paddingLeft = null;
        if (offsetTop == 81) style.paddingTop = null;
        if (this._cellStyleTester.offsetWidth - offsetLeft - 30 == 81) {
            style.paddingRight = null;
        }
        if (this._cellStyleTester.offsetHeight - offsetTop - 30 == 81) {
            style.paddingBottom = null;
        }
    }

    if (isc.Browser.isSafari) {
        // older Safari versions report unset padding as "auto" instead of reporting the
        // cellPadding
        if (isc.Browser.safariVersion < 419.3) {
            nullIndicator = isc.Canvas.AUTO;
            if (style.paddingLeft == nullIndicator) style.paddingLeft = null;
            if (style.paddingTop == nullIndicator) style.paddingTop = null;
            if (style.paddingRight == nullIndicator) style.paddingRight = null;
            if (style.paddingBottom == nullIndicator) style.paddingBottom = null;
        }

        // serious bug introduced in Safari 419.3 / 2.0.4, aka Tiger update 10.4.7: unset
        // marginTop/Bottom on cells reported as "-16384px".  Chimp factor 9.89
        nullIndicator = this._$16384px;
        if (style.marginTop == nullIndicator) style.marginTop = null;
        if (style.marginBottom == nullIndicator) style.marginBottom = null;
    }



    if (requiresDivTester) {
        this._styleTester.className = className;
        var results = this.getComputedStyle(this._styleTester, this._marginMask);
        style.marginLeft = results.marginLeft;
        style.marginRight = results.marginRight;
        style.marginTop = results.marginTop;
        style.marginBottom = results.marginBottom;
        if (isc.Browser.isIE8Strict) {
            style.borderLeftWidth = results.borderLeftWidth;
            style.borderRightWidth = results.borderRightWidth;
            style.borderTopWidth = results.borderTopWidth;
            style.borderBottomWidth = results.borderBottomWidth;
        }
    }
    return style;

},

//> @classMethod Element.getComputedStyle()
//  Returns an object containing the current (computed) style for a DOM element.  This object
//  includes all the attributes set directly on the element's style property, and those inherited
//  from the element's CSS class.
//  @param  ID  (string | object)   element, or ID of the element
//  @param  mask    (array)         list of propertyNames to include in the returned object
//  @return (object)    object containing computed style attributes.
//<
getComputedStyle : function (ID, mask) {

    var element, style, styleInfo;

    if (isc.isA.String(ID)) {
        element = isc.Element.get(ID);
    } else {
        // Otherwise just assume the DOM element was passed in directly
        element = ID;
    }

    if (element == null || !isc.isAn.Object(element)) {
        //>DEBUG
        this.logWarn("getComputedStyle: Unable to get to DOM element specified by '" + ID + "'." + this.getStackTrace());
        //<DEBUG
        return null;
    }

    if (this._useCurrentStyle) {

        style = element.currentStyle;
        // NOTE: use Array form of mask, faster with applyMask
        if (mask == null) mask = this._styleFullMaskArray;
        var results = isc.applyMask(style, mask);
        return results;
    }

    // prepare a mask from camelCaps property to CSS dashed-property-name, because we want to
    // return camelCaps'd values but native getPropertyValue() uses dashed versions
    if (mask == null) {
        // retrieve all properties
        mask = this._styleFullMask;
    } else if (isc.isAn.Array(mask)) {
        // if we have an explicit list of properties to retrieve, build a mask of camelCaps
        // name to CSS standard name (dash-separated) for just the desired properties.
        var obj = {},
            fullMask = this._styleFullMask;
        for (var i = 0; i < mask.length; i++) {
            obj[mask[i]] = fullMask[mask[i]];
        }
        mask = obj;
    }


    var safariPre13 = isc.Browser.isSafari && isc.Browser.safariVersion < 312,
        classStyleObject;
    if (safariPre13) {
        style = element.style;
        classStyleObject = this.getStyleDeclaration(element.className);

        styleInfo = {};
        for (var property in mask) {
            styleInfo[property] = style.getPropertyValue(mask[property]);

            if (styleInfo[property] == null &&
                classStyleObject != null && classStyleObject[property] != null &&
                !isc.isAn.emptyString(classStyleObject[property]))
            {

                styleInfo[property] = classStyleObject[property];
            }
        }
    } else {
        if (document.defaultView && document.defaultView.getComputedStyle) {
            style = document.defaultView.getComputedStyle(element, null);

        }
        if (style == null) {
            style = {};
            this.logWarn("getComputedStyle() not natively available - can't " +
                "guarantee accurate styling information for element:" + this.echoLeaf(element));
            if (this.logIsDebugEnabled()) {
                this.logDebug(this.getStackTrace());
            }
        }
        styleInfo = {};
        for (var property in mask) {
            styleInfo[property] = style[property];
        }
    }

    //this.logWarn("styleInfo for style: " + className + " is: " + this.echo(styleInfo));
    return styleInfo;

},

// return an individual attribute from the computed style.  Quicker than getting the full set
// of properties if you need only one.

_$operaBorderStyles:{
    border:"borderStyle",
    borderWidth:"borderStyle",
    borderLeft:"borderLeftStyle",
    borderRight:"borderRightStyle",
    borderTop:"borderTopStyle",
    borderBottom:"borderBottomStyle",
    borderLeftWidth:"borderLeftStyle",
    borderRightWidth:"borderRightStyle",
    borderBottomWidth:"borderBottomStyle",
    borderTopWidth:"borderTopStyle"
},
getComputedStyleAttribute : function (element, property) {

    if (element == null || property == null) return null;

    // Use currentStyle for IE (easy!)
    if (this._useCurrentStyle) {

        // we've seen element.currentStyle be reported as null (not sure why)
        if (element.currentStyle == null) return null;
        // special opera logic for undefined borders returning 3
        if (isc.Browser.isOpera && this._$operaBorderStyles[property] != null &&
            element.currentStyle[this._$operaBorderStyles[property]] == this._$none) return 0;
        return element.currentStyle[property];
    }

    //>Safari
    if (isc.Browser.isSafari && isc.Browser.version < 5) {

        var propertyValue = null;
        if (element.style) propertyValue = element.style[property];
        if ((propertyValue == null || isc.isAn.emptyString(propertyValue)) &&
            element.className)
        {
            var styleDecl = isc.Element.getStyleEdges(element.className);
            if (styleDecl) propertyValue = styleDecl[property];
        }
        if (isc.isAn.emptyString(propertyValue)) return null;
        return propertyValue;
    } //<Safari

    // DOM and not broken (eg Moz).  Convert camelCaps to the CSS property name (only works for
    // a specific list of props)
    var mask = this._styleFullMask;

    var docView = this._docView = this._docView || document.defaultView;

    var cssProperty = (mask[property] || property),
        // get the style object for the element
        style = docView.getComputedStyle(element, null);


    return style.getPropertyValue(cssProperty);
},





_matchesSelector : function (element, selectorText) {

    try {
        if (!!element.matches) return element.matches(selectorText);

        if (isc.Browser.isIE9) return element.msMatchesSelector(selectorText);
        else if (isc.Browser.isChrome || isc.Browser.isWebKit) return element.webkitMatchesSelector(selectorText);
        else if (isc.Browser.isMoz) return element.mozMatchesSelector(selectorText);
        else if (isc.Browser.isOpera) return element.oMatchesSelector(selectorText);
    } catch (e) {

        return false;
    }

    // Incomplete fallback implementation for browsers that do not support the matches() DOM
    // method (formerly called matchesSelector()).




    if (isc.isAn.emptyString(element.className)) return false;
    var classNameSelector = "." + element.className,
        selectorTextArray = selectorText.split(/(?:,\s*)+/);
    for (var k = 0; k < selectorTextArray.length; k++) {
        if (selectorTextArray == classNameSelector) return true;
    }
    return false;
},



// look up a style declaration via document.stylesheets

//_defaultReferenceElement: null,
getStyleDeclaration : function (className, checkMultiples, referenceElement) {

    if (!className) return null;

    if (referenceElement == null) {
        referenceElement = this._defaultReferenceElement;
        if (referenceElement == null) {

            referenceElement = this._defaultReferenceElement = document.createElement("div");
            referenceElement.id = "isc_getStyleDeclaration_defaultReferenceElement";
            referenceElement.style.display = "none";
            document.body.appendChild(referenceElement);
        }
        referenceElement.className = className;
    }


    if (!isc.allowDuplicateStyles) checkMultiples = false;



    // Check the array of style rules from any styleSheets
    // - This will include <STYLE> tags in the doc
    // - Start with the most recently loaded
    var styleObj, styleObjs = checkMultiples ? [] : null;
    for (var i = document.styleSheets.length - 1; i >= 0; i--) {
        var rules = this._getCSSRules(document.styleSheets[i]);


        if (rules == null) continue; // stylesheet inaccessible

        // iterate backward through style declarations, since last wins
        for (var j = rules.length - 1; j >= 0; j--) {
            var selectorText = rules[j].selectorText;

            // @import css tags result in entries with no 'selectorText' property.
            if (selectorText == null) continue;


            if (isc.Browser.isSafari && 530.17 > isc.Browser.safariVersion && isc.Browser.safariVersion >= 312) {
                selectorText += ", " + selectorText.toLowerCase()
            }

            if (this._matchesSelector(referenceElement, selectorText)) {
                var styleObj = rules[j].style;
                if (checkMultiples) styleObjs[styleObjs.length] = styleObj;
                else return styleObj;
            }
        }
    }
    if (checkMultiples && styleObjs.length > 0) return styleObjs;
    return null;
},

// retrieve the css rules property from a stylesheet definition
_getCSSRules : function (styleSheet) {

    if (!this._fetchStyle) {

        // "cssRules" in Moz, "rules" in IE.
        this._fetchStyle = function (sheet) {
            try {
                return sheet.rules || sheet.cssRules;
            } catch (e) {
                isc.Page._remoteStyleSheet = true;
            }
        };

    }
    return this._fetchStyle(styleSheet);
},





//>    @classMethod Element.getStyleText()    ([A])
// Gets the raw CSS style text associated with a CSS className. For example, if you have
// defined the following class:<br><br>
// <code>.cellSelected {font-family:Verdana; font-size:10px; background-color:#FFFF99;<br>
// border-top:1px solid #FFFF99;<br>
// border-bottom:1px solid #FFFF99;<br>
// }</code><br><br>
// Then calling getStyleText("cellSelected") will return:<br><br>
// <code>font-family:Verdana; font-size:10px; background-color:#FFFF99;<br>
// border-top:1px solid #FFFF99; border-bottom:1px solid #FFFF99;</code>
//        @group    drawing
//
//      @param  className   (string)       The CSS ClassName for which you wish to get the style
//      @param  [checkMultiples]    (boolean)   If specified this will ensure we check for
//                                          multiple definitions of the same className and pick
//                                          up cssText from each definition. False by default.
//                                          No effect if isc.allowDuplicateStyles is false.
//      @return (string)       The cssText property of this CSS style rule
//<
_cssTextCache:{},
_$semi:";",
getStyleText : function (className, checkMultiples) {


    if (!isc.allowDuplicateStyles) checkMultiples = false;




    // check cache.

    var cache = this._cssTextCache,
        cssText = cache[className];
    if (cssText != null) return cssText;

    var style = this.getStyleDeclaration(className, checkMultiples);

    // if we didn't find anything, return the empty string (rather than null)
    if (style == null) {

        if (!isc.Browser.isSafari || isc.Page.isLoaded())
            this._cssTextCache[className] = isc.emptyString;
        return isc.emptyString;
    }

    // "style" will be an array if we checked multiple styles


    if (checkMultiples) {
        for (var i = style.length-1; i >-1; i--) {
            var actualStyle = style[i];
            var currentCssText = actualStyle.cssText;
            if (currentCssText == null) continue;
            if (!isc.endsWith(currentCssText, this._$semi)) currentCssText += this._$semi;
            if (cssText == null) cssText = currentCssText;
            else cssText += currentCssText;
        }
        if (cssText == null) cssText = isc._emptyString;
    } else {
        cssText = (style.cssText || isc._emptyString);
    }

    // ensure it ends with a semicolon so it can be appended to
    if (!isc.endsWith(cssText, isc.semi)) cssText += isc.semi;
    // cache it and return it

    return (cache[className] = cssText);
},


// wipe out any cached CSS information
// helper for Canvas._clearCSSCaches
_clearCSSCaches : function () {
    //isc.Log.logWarn("styleCache is: " + isc.echoFull(isc.Element._styleCache));

    // wipe out the central style definition caches
    isc.Element._styleCache = {};
    isc.Element._cssTextCache = {};

    // wipe out central edge size caches
    isc.Element._borderSizeCache = isc.Element._marginsCache =
        isc.Element._padSizeCache = null;
},

// Border, Padding and Margin on css classes
// --------------------------------------------------------------------------------------------
// We provide the static Element class methods to handle getting border and padding
// thicknesses on each side ('getTopBorderSize()', 'getBottomBorderSize()', 'getTopPadding()',
// etc.) for css classes from their classNames.





//>    @classMethod    Element._getTopMargin()
// Get the size of the top margin for the style passed in.
//
//  @param  className   (string)    className to test for margin size
//  @return             (number)    size of top margin in pixels
//<
_getTopMargin : function (className) {
    return this._calculateMargins(className).top;
},

//>    @classMethod    Element._getBottomMargin()
// Get the size of the bottom margin for the style passed in.
//
//  @param  className   (string)    className to test for margin
//  @return             (number)    size of bottom margin in pixels
//<
_getBottomMargin : function (className) {
    return this._calculateMargins(className).bottom;
},

//>    @classMethod    Element._getLeftMargin()
// Get the size of the left margin for the style passed in.
//
//  @param  className   (string)    className to test for margin size
//  @return             (number)    size of left margin in pixels
//<
_getLeftMargin : function (className) {
    return this._calculateMargins(className).left;
},

//>    @classMethod    Element._getRightMargin()
// Get the size of the right margin for the style passed in.
//
//  @param  className   (string)    className to test for margin size
//  @return             (number)    size of right margin in pixels
//<
_getRightMargin : function (className) {
    return this._calculateMargins(className).right;
},

//>    @classMethod    Element._calculateMargins()
// Calculate the sizes of the margins on each side for the css class passed in.
//
//  @param  className   (string)    className to test for margin sizes
//  @return             (object)    Object with 'left', 'right', 'top', 'bottom' defined as the
//                                  sizes of the margin on each side
//<
_calculateMargins : function (className) {

    if (this._marginsCache == null) this._marginsCache = {};
    else if (this._marginsCache[className] != null) {
        return this._marginsCache[className];
    }
    var margins = {top:0, bottom:0, left:0, right:0},
        styleObject = isc.Element.getStyleEdges(className);

    if (styleObject == null) return margins;

    var topMarginString = styleObject.marginTop,
        bottomMarginString = styleObject.marginBottom,
        leftMarginString = styleObject.marginLeft,
        rightMarginString = styleObject.marginRight,
        pxString = isc.px;


    if (isc.isA.String(topMarginString) && isc.endsWith(topMarginString, pxString)) {
        margins.top = parseInt(topMarginString);
    }
    if (isc.isA.String(bottomMarginString) && isc.endsWith(bottomMarginString, pxString)) {
        margins.bottom = parseInt(bottomMarginString);
    }
    if (isc.isA.String(leftMarginString) && isc.endsWith(leftMarginString, pxString)) {
        margins.left = parseInt(leftMarginString);
    }
    if (isc.isA.String(rightMarginString) && isc.endsWith(rightMarginString, pxString)) {
        margins.right = parseInt(rightMarginString);
    }

    this._marginsCache[className] = margins;

    return margins;

},

//>    @classMethod    Element._getTopBorderSize()
// Get the size of the top border for the style passed in.
//
//  @param  className   (string)    className to test for border size
//  @return             (number)    size of top border in pixels
//<
_getTopBorderSize : function (className) {
    return this._calculateBorderSize(className).top;
},

//>    @classMethod    Element._getBottomBorderSize()
// Get the size of the bottom border for the style passed in.
//
//  @param  className   (string)    className to test for border size
//  @return             (number)    size of bottom border in pixels
//<
_getBottomBorderSize : function (className) {
    return this._calculateBorderSize(className).bottom;
},

//>    @classMethod    Element._getLeftBorderSize()
// Get the size of the left border for the style passed in.
//
//  @param  className   (string)    className to test for border size
//  @return             (number)    size of left border in pixels
//<
_getLeftBorderSize : function (className) {
    return this._calculateBorderSize(className).left;
},

//>    @classMethod    Element._getRightBorderSize()
// Get the size of the right border for the style passed in.
//
//  @param  className   (string)    className to test for border size
//  @return             (number)    size of right border in pixels
//<
_getRightBorderSize : function (className) {
    return this._calculateBorderSize(className).right;
},

//>    @classMethod    Element._calculateBorderSize()
// Calculate the sizes of the borders on each side for the css class passed in.
//
//  @param  className   (string)    className to test for border sizes
//  @return             (object)    Object with 'left', 'right', 'top', 'bottom' defined as the
//                                  sizes of the border on each side
//<
_calculateBorderSize : function (className) {

    if (this._borderSizeCache == null) this._borderSizeCache = {};
    else if (this._borderSizeCache[className] != null) {
        return this._borderSizeCache[className];
    }

    var borderSize = {top:0, bottom:0, left:0, right:0},
        styleObject = isc.Element.getStyleEdges(className);

    if (styleObject == null) return borderSize;

    var topBorderString = styleObject.borderTopWidth,
        bottomBorderString = styleObject.borderBottomWidth,
        leftBorderString = styleObject.borderLeftWidth,
        rightBorderString = styleObject.borderRightWidth,
        pxString = isc.px;


    if (isc.isA.String(topBorderString) && isc.endsWith(topBorderString, pxString)) {
        borderSize.top = Math.ceil(parseFloat(topBorderString));
    }
    if (isc.isA.String(bottomBorderString) && isc.endsWith(bottomBorderString, pxString)) {
        borderSize.bottom = Math.ceil(parseFloat(bottomBorderString));
    }
    if (isc.isA.String(leftBorderString) && isc.endsWith(leftBorderString, pxString)) {
        borderSize.left = Math.ceil(parseFloat(leftBorderString));
    }
    if (isc.isA.String(rightBorderString) && isc.endsWith(rightBorderString, pxString)) {
        borderSize.right = Math.ceil(parseFloat(rightBorderString));
    }

    this._borderSizeCache[className] = borderSize;

    return borderSize;

},

//>    @classMethod    Element._getVBorderSize()
// Get the total vertical border size for the style passed in. (Top border size + bottom border size)
//
//  @param  className   (string)    className to test for padding size
//  @return             (number)    total size of vertical (top and bottom) borders in pixels
//<
_getVBorderSize : function (className) {
    return this._getTopBorderSize(className) + this._getBottomBorderSize(className);
},

//>    @classMethod    Element._getHBorderSize()
// Get the total horizontal border size for the style passed in.
// (Left border size + Right border size)
//
//  @param  className   (string)    className to test for padding size
//  @return             (number)    total size of horizontal (left and right) borders in pixels
//<
_getHBorderSize : function (className) {
    return this._getLeftBorderSize(className) + this._getRightBorderSize(className);
},

//>    @classMethod    Element._getTopPadding()
// Get the size of the top padding for the style passed in.
//
//  @param  className   (string)    className to test for padding size
//  @param  [explicit]  (boolean)   If no passed, when no padding was specified, return null
//                                  rather than true.
//  @return             (number)    size of top padding in pixels
//<
_getTopPadding : function (className, explicit) {
    var padding = this._calculatePadding(className);
    if (explicit && padding.nullTop) return null;
    return padding.top;
},

//>    @classMethod    Element._getBottomPadding()
// Get the size of the bottom padding for the style passed in.
//
//  @param  className   (string)    className to test for padding size
//  @param  [explicit]  (boolean)   If passed, when no padding was specified, return null
//                                  rather than true.
//  @return             (number)    size of bottom padding in pixels
//<
_getBottomPadding : function (className, explicit) {
    var padding = this._calculatePadding(className);
    if (explicit && padding.nullBottom) return null;
    return padding.bottom;
},

//>    @classMethod    Element._getLeftPadding()
// Get the size of the left padding for the style passed in.
//
//  @param  className   (string)    className to test for padding size
//  @param  [explicit]  (boolean)   If passed, when no padding was specified, return null
//                                  rather than true.
//  @return             (number)    size of left padding in pixels
//<
_getLeftPadding : function (className, explicit) {
    var padding = this._calculatePadding(className);
    if (explicit && padding.nullLeft) return null;
    return padding.left;
},

//>    @classMethod    Element._getRightPadding()
// Get the size of the right padding for the style passed in.
//
//  @param  className   (string)    className to test for padding size
//  @param  [explicit]  (boolean)   If passed, when no padding was specified, return null
//                                  rather than true.
//  @return             (number)    size of right padding in pixels
//<
_getRightPadding : function (className, explicit) {
    var padding = this._calculatePadding(className);
    if (explicit && padding.nullRight) return null;
    return padding.right;
},

//>    @classMethod    Element._calculatePadding()
// Calculate the sizes of the padding on each side for the css class passed in.
//
//  @param  className   (string)    className to test for padding sizes
//  @return             (object)    Object with 'left', 'right', 'top', 'bottom' defined as the
//                                  sizes of the padding on each side
//<
_calculatePadding : function (className) {
    if (this._padSizeCache == null) this._padSizeCache = {};
    else if (this._padSizeCache[className] != null) {
        return this._padSizeCache[className];
    }

    var padSize = {top:0, bottom:0, left:0, right:0},
        styleObject = isc.Element.getStyleEdges(className);

    if (styleObject == null) {
        padSize.nullLeft = true; padSize.nullRight = true;
        padSize.nullTop = true; padSize.nullBottom = true;
        return padSize;
    }

    var topPadding = styleObject.paddingTop,
        bottomPadding = styleObject.paddingBottom,
        leftPadding = styleObject.paddingLeft,
        rightPadding = styleObject.paddingRight,
        pxString = isc.px;

    // In some cases we will want to know whether a style contains specified padding *at all*,
    // as opposed to explicit zero.
    padSize.nullTop = (topPadding == null || topPadding == isc.emptyString);
    padSize.nullBottom = (bottomPadding == null || bottomPadding == isc.emptyString)
    padSize.nullLeft = (leftPadding == null || leftPadding == isc.emptyString);
    padSize.nullRight = (rightPadding == null || rightPadding == isc.emptyString);


    if (isc.isA.String(topPadding) && isc.endsWith(topPadding, pxString)) {
        padSize.top = parseInt(topPadding);
    }
    if (isc.isA.String(bottomPadding) && isc.endsWith(bottomPadding, pxString)) {
        padSize.bottom = parseInt(bottomPadding);
    }
    if (isc.isA.String(leftPadding) && isc.endsWith(leftPadding, pxString)) {
        padSize.left = parseInt(leftPadding);
    }
    if (isc.isA.String(rightPadding) && isc.endsWith(rightPadding, pxString)) {
        padSize.right = parseInt(rightPadding);
    }
    this._padSizeCache[className] = padSize;

    return padSize;
},

//>    @classMethod    Element._getVPadding()
// Get the total size of the vertical padding for the style passed in.
//
//  @param  className   (string)    className to test for padding size
//  @return             (number)    size of vertical padding in pixels
//<
_getVPadding : function (className) {
    return this._getTopPadding(className) + this._getBottomPadding(className);
},

//>    @classMethod    Element._getHPadding()
// Get the total size of the horizontal padding for the style passed in.
//
//  @param  className   (string)    className to test for padding size
//  @return             (number)    size of horizontal padding in pixels
//<
_getHPadding : function (className) {
    return this._getLeftPadding(className) + this._getRightPadding(className);
},

//>    @classMethod    Element._getVBorderPad()
// Get the total size of the padding and border for this style, for the vertical axis.
//
//  @param  className   (string)    className to test for VBorderPad
//  @return             (number)    size of VBorderPad in pixels
//<
_getVBorderPad : function (className) {
    return this._getVBorderSize(className) + this._getVPadding(className);
},

//>    @classMethod    Element._getHBorderPad()
// Get the total size of the padding and border for this style, for the horizontal axis.
//
//  @param  className   (string)    className to test for HBorderPad
//  @return             (number)    size of HBorderPad in pixels
//<
_getHBorderPad : function (className) {
    return this._getHBorderSize(className) + this._getHPadding(className);
},

// ----------------------

// getNativeScrollbarSize()
//
// If the browser is showing native scrollbars, we have no way of knowing their thickness by
// default. This can be set at the OS level (via the Control Panel in windows), and the
// defaults vary based on which OS is being used.
// This method determines the size of the scrollbars by writing a DIV into the DOM and
// examining it

getNativeScrollbarSize : function () {
    if (isc.Element._nativeScrollbarSize == null) {
        if (isc.Browser.isMobileWebkit) {
            // native scrollbars don't exist in iPhone
            return (isc.Element._nativeScrollbarSize = 0);
        }
        var elementHTML = "<div id=isc_ScrollbarTest "
                            + "style='position:absolute;top:-100px;border:0px;padding:0px;margin:0px;height:100px;width:100px;overflow:scroll;'>"
                            + isc.nbsp // XHTML
                            + "</div>";
        this.createAbsoluteElement(elementHTML);
        var sbTest = this.get('isc_ScrollbarTest');
        isc.Element._nativeScrollbarSize = parseInt(sbTest.style.height) - sbTest.clientHeight;

        // At this point we've determined the scrollbar size, and can clear the test div out
        // from the DOM
        this.clear(sbTest);
    }

    return isc.Element._nativeScrollbarSize;
},

// ---------------------------------------------------------------------------------------




// Return CSS to transform by degrees around an origin

_transformCSSName: (!("transform" in document.documentElement.style)
                    ? isc.Element.vendorCSSPrefix + "transform"
                    : "transform"),
_transformOriginCSSName: (!("transformOrigin" in document.documentElement.style)
                          ? isc.Element.vendorCSSPrefix + "transform-origin"
                          : "transform-origin"),
getRotationCSS : function (degrees, origin) {
    degrees = +degrees;

    var prefix = this.vendorCSSPrefix;

    var text = this._transformCSSName + ": rotate(" + degrees.toFixed(3) + "deg);";
    if (origin != null) {
        text += this._transformOriginCSSName + ": " + origin + ";";
    }
    return text;
},

_transformStyleName: (!("transform" in document.documentElement.style)
                      ? isc.Element.vendorStylePrefix + "Transform"
                      : "transform"),
_transformOriginStyleName: (!("transformOrigin" in document.documentElement.style)
                            ? isc.Element.vendorStylePrefix + "TransformOrigin"
                            : "transformOrigin"),
_updateTransformStyle : function (sourceElement, transformFunctions, origin, transient_) {


    var handle = sourceElement.getClipHandle();
    if (handle == null) return;


    sourceElement._$leftCoords = sourceElement._$topCoords = null;
    sourceElement._childrenCoordsChanged();

    if (!transformFunctions) {
        origin = transformFunctions = "";
    }

    var style = handle.style;
    style[this._transformStyleName] = transformFunctions;
    if (origin != null) {
        style[this._transformOriginStyleName] = origin;
    }
},

// Calculates the "used" X translation of the given canvas.
_getComputedTranslateX : function (element) {


    var computedStyle = element.getWindow().getComputedStyle(element.getClipHandle(), null),
        computedTransform = computedStyle[isc.Element._transformCSSName],
        computedTranslateX;
    if (computedTransform === "none") {
        computedTranslateX = 0;
    } else {

        var parts = computedTransform.split(/,\s*(?:)/);
        computedTranslateX = parseFloat(parts[4]);
    }

    return computedTranslateX;
}

});

isc.Element._ElementInit = function () {

    var edgeMask = this._styleEdgeMask = {

            borderLeftWidth:"border-left-width",
            borderRightWidth:"border-right-width",
            borderTopWidth:"border-top-width",
            borderBottomWidth:"border-bottom-width",
            marginLeft:"margin-left",
            marginRight:"margin-right",
            marginTop:"margin-top",
            marginBottom:"margin-bottom",


            paddingLeft:"padding-left",
            paddingRight:"padding-right",
            paddingTop:"padding-top",
            paddingBottom:"padding-bottom"
    }

    var fullMask = this._styleFullMask = isc.addProperties({
            position:"position",
            overflow:"overflow",
            top:"top",
            left:"left",
            width:"width",
            height:"height",

            // display - block vs. inline (etc.)
            display:"display"
    }, edgeMask);

    if (isc.Browser.isIE || isc.Browser.isOpera) {
        this._styleFullMaskArray = isc.getKeys(fullMask);
        this._styleEdgeMaskArray = isc.getKeys(edgeMask);
    }
}
isc.Element._ElementInit();




//> @groupDef domIntegration
// SmartClient provides a huge variety of pre-built components and allows you to create new
// components via combining and composing the existing components.  However in rare cases, it can
// make sense to write code that works directly with raw HTML and the browser's DOM (document
// object model) APIs.  This level of coding is also involved when integrating third-party
// JavaScript components into SmartClient applications.
// <P>
// First, a warning: when you use HTML and the DOM directly, all of SmartClient's guarantees of
// cross-browser consistent behavior no longer apply.  When you use SmartClient's API, SmartClient
// is automatically compensating for many, many browser bugs - not just trivial things like
// different property names or missing utility methods, but problems where browsers fail to fire
// certain events, report sizes wrong only in certain modes with certain styling, or bugs that
// only occur with specific timing.
// <P>
// Before deciding to do direct HTML coding, consider whether you really want to expose yourself
// to all of these possible issues.  If you can achieve the same look and feel and behavior
// through SmartClient's APIs, that's usually best.
// <P>
// <h3>Adding or modifying the DOM</h3>
// <P>
// The DOM structures used by SmartClient necessarily differ by browser in order to work around
// each browser's specific bugs.  This DOM structure is intentionally undocumented because it is
// subject to change without notice - in may be necessary to modify the DOM structure to work
// around the bugs in each new browser release.
// <P>
// Instead of trying to modify the SmartClient-generated DOM, you should always <b>add new
// elements</b>.  For a new standalone component that will be based on direct use of HTML, you
// usually do this by subclassing Canvas and overriding +link{Canvas.getInnerHTML()} and returning
// an HTML string representing the components you want to create.
// <P>
// You can use a similar approach anywhere HTML is allowed in a widget property: formatting APIs
// for StaticTextItem, DetailViewer, TileGrid, and other DataBoundComponents, as well as places
// such as +link{tab.title} or +link{button.title}.
// <P>
// <h3>Third-party components</h3>
// <P>
// Most third-party JavaScript components have the ability to generate their HTML content into a
// DOM element specified by ID, or to replace such an element with new HTML.  This is true of
// Google Maps, +externalLink{http://ckeditor.com,CKEditor} and many other libraries.
// <P>
// To use this form of integration, implement a +link{canvas.getInnerHTML()} function that returns
// a DOM element with a known ID, then have the third-party library target that DOM element once
// the Canvas is drawn.  For example, CKEDITOR.replace() takes the ID of a &lt;textarea&gt;
// element, and the following code would create a &lt;textarea&gt; and have the CKEditor replace
// it with a CKEditor widget:
// <smartclient>
// <pre>
// isc.defineClass("CKEditor", "Canvas");
// isc.CKEditor.addProperties({
//     // write out a textarea with a known ID
//     getInnerHTML : function () {
//         return "&lt;textarea style="width:100%;height:100%" ID='" +
//                           this.getID() + "_ckEditor'>&lt;/textarea>";
//     },
//     // call superclass method to draw, then have CKEditor replace the textarea we
//     // wrote out with the CKEditor widget
//     draw : function () {
//         if (!this.readyToDraw()) return this;
//         this.Super("draw", arguments);
//         CKEDITOR.replace(this.getID() + "_ckEditor");
//         return this;
//     },
//     redrawOnResize:false // see next section
// });
// </pre>
// </smartclient>
// <smartgwt>
// <pre>
// public class CKEditor extends Canvas {
//
//     private static native void replace(String id) &#47;*-{
//         $wnd.CKEDITOR.replace(id);
//     }-*&#47;;
//
//     public CKEditor() {
//         setRedrawOnResize(false);
//     }
//
//     &#64;Override
//     public String getInnerHTML() {
//         return "&lt;textarea id='" + getID() + "_ckEditor' style='width:100%;height:100%'>&lt;/textarea>";
//     }
//
//     &#64;Override
//     protected void onDraw() {
//         CKEditor.replace(getID() + "_ckEditor");
//     }
// }
// </pre>
// </smartgwt>
// <P>
// This same approach can be used when you want to insert third-party generated HTML into just a
// specific part of a SmartClient widget.  For example, you might want to insert
// +externalLink{https://www.google.com/search?q=jquery+sparklines,JQuery 'sparklines'}, which are
// essentially miniature charts, into cells of a ListGrid.  You could use
// +link{listGridField.formatCellValue,a cell formatter} to write out &lt;div&gt; elements with
// known IDs into the cells, then target them with JQuery.
// <P>
// <h3>Resizing and Redraw</h3>
// <P>
// When implementing <code>canvas.getInnerHTML()</code>, your getInnerHTML() function will be
// called every time the component redraw()s, and the new HTML will replace the old.  This is also
// true of something like a ListGrid cell formatter.
// <P>
// Also by default, your component will redraw() if it is resized.  In the example above with
// CKEditor, we wouldn't want this because it would wipe out the CKEditor widget every time it was
// resized, so we set +link{canvas.redrawOnResize} to false.  In other circumstances you may want
// to redraw on every resize in order to generate new HTML.
// <P>
// If you do not redraw HTML on resize, you either have to write the HTML in a way that makes it
// flow into available space (width/height 100% may be enough here) <b>or</b> you need to manually
// resize the DOM element when the +link{canvas.resized,resized event} fires.
// <P>
// In the latter case, you should adjust the size of the DOM element to match the
// +link{canvas.getInnerWidth(),inner width} and
// +link{canvas.getInnerHeight(),inner height} of the containing Canvas.  The "inner" dimensions
// are the dimensions after border and margins have been subtracted, so this will work even if a
// border is added to your Canvas subclass via CSS or +link{canvas.setBorder()}.
// <P>
// <h3>Other redraws</h3>
// <P>
// Once you have set +link{canvas.redrawOnResize} to false you may still see redraws from other
// sources.  Generally this would be from code in your application which calls
// +link{canvas.redraw()} or +link{canvas.markForRedraw()} unnecessarily.  To troubleshoot, you
// can enable the "redraws" log category in the Developer Console - this will log the source of
// any redraws in the system.
// <P>
// <h3>Masking during drags</h3>
// <P>
// Third-party components that utilize iframes, browser plugins or other special elements will
// "swallow" events such that SmartClient never receives them.  This is a problem whenever a
// drag interaction goes over the component, including drag resizing of the component itself.
// To avoid this issue, set +link{canvas.useDragMask} for any component that contains an iframe
// or browser plugin, or that appears to be swallowing events during drag.  The telltale sign
// is that when the mouse goes over the plugin, the visual effect of the drag (differs by
// +link{canvas.dragAppearance}) stops updating or stutters.
// <P>
// <h3>Overflow &amp; Auto-Sizing</h3>
// <P>
// Consider which +link{canvas.overflow} setting to use for your custom component:
// <ul>
// <li> <code>overflow:"hidden"</code> is the most common.  In the context of third-party
// components, it means the component is prepared to render itself at any requested size (above
// a minimum).
// <li> <code>overflow:"visible"</code> means you want SmartClient to attempt to automatically
// determine a minimum size based on the HTML content generated by the custom component
// <li> <code>overflow:"auto"</code> is similar to <code>overflow:"hidden"</code>, but means
// your custom component needs SmartClient to create scrollbars whenever its HTML content does
// not fit in the allocated space.
// </ul>
// Note that with the automatic measurement of HTML content enabled by
// <code>overflow:"visible"</code> or <code>overflow:"auto"</code>, if you make on-the-fly
// modifications to the HTML you returned from <code>getInnerHTML()</code>, there is no
// cross-browser-reliable way for the Canvas to detect this and auto-size again.  Instead, call
// +link{canvas.adjustForContent()} to trigger auto-sizing again.
// <P>
// <h3>zIndex</h3>
// <P>
// zIndex values control what component is rendered "on top" when multiple components appear in
// the same area of the page.
// <P>
// To work around various browser issues, SmartClient components use a very high range of
// zIndex values.  If a component creates pop-up widgets such as hovers or floating toolbars
// via direct HTML/DOM usage, these pop-up widgets will appear <b>behind</b> all SmartClient
// components unless they set a very high zIndex.
// <P>
// For your own custom HTML/DOM components, the simplest strategy is to create pop-up widgets
// based on SmartClient components, even if they are triggered by interacting with
// hand-created HTML.  For example, even if you've written some kind of advanced SVG-based data
// visualization component, you can still implement pop-up configuration dialogs based on the
// SmartClient +link{Window} class; there's no reason to implement such dialogs directly in
// low-level HTML/DOM code.
// <P>
// If a third-party widget is creating pop-ups you don't directly control, you may be able to
// configure the third-party widget to use a certain zIndex range, or you may be able to
// directly reach into the widget's DOM and modify zIndexes that way.  You can use
// +link{canvas.getZIndex()} to discover the zIndex of any SmartClient widget you need to
// appear above, then set a higher value.
// <P>
// Finally, as a last resort and completely unsupported approach, you can modify the zIndex
// range used by SmartClient using the following JavaScript code:
// <pre>
// isc.Canvas.addClassProperties({
//    // default zIndex for the next item to be drawn
//    _nextZIndex:200000,
//
//    // zIndex of the next item to be sent to the back
//    _SMALL_Z_INDEX:199950,
//
//    // zIndex of the next item to be brought to the front
//    _BIG_Z_INDEX:800000
// });
// </pre>
// <P>
// <h3>Other issues</h3>
// <P>
// There are several other issues, listed below, for which there really is no general strategy
// for solving the issue, although some general pointers are provided.
// <P>
// Because of problems like these, it's a very very bad idea to freely intermix components from
// multiple component libraries.  While mixing components may appear to be an appealing
// strategy and you may experience apparent success with early attempts, the issues below will
// ultimately prevent you from completing an application of sufficient quality for enterprise
// use.
// <P>
// In the following discussion, "third-party widgets" should be understood to include
// widgets that you write using direct DOM/HTML techniques.
// <ul>
// <li> <b>tabbing order / accessibility</b>: a correct tabbing order that visits all
// components on the page is a requirement for your application to be considered accessible, as
// is ARIA markup (for more information, see +link{groupDef:accessibility}).  Third-party
// widgets may completely lack ARIA markup, such that you may be required to modify them or
// reach into their DOM to add ARIA attributes.  It may be necessary to add manual keyDown or
// keyPress event handlers to handle focus moving from SmartClient components to third-party
// widgets and back.
//
// <li> <b>modality</b>: aside from zIndex issues covered above, modality means that the tab
// order should be a closed loop that reaches only active widgets, which can create additional
// complexity in getting tabbing to work correctly.  Also, keyboard shortcuts should be
// disabled for inactive widgets; this may require calls to
// +link{EventHandler.targetIsMasked()} to make third-party widgets respect SmartClient
// modality, or may require calls to +link{Canvas.showClickMask()} to cause SmartClient
// components to consider themselves inactive when a third-party widget opens a pop-up that is
// intended to be modal.  Multi-layered modality, such as a modal window that in turn pops a
// modal dialog, is yet more complex.
//
// <li> <b>bad CSS</b>: some third-party widgets introduce CSS selectors that target, for
// example, every table cell on the entire page.  This very bad practice will interfere with
// SmartClient (or any other HTML on the page).  This may require modifying the third-party
// component, or extensively modifying SmartClient CSS to reverse any changes caused by
// third-party CSS.  For example, it may be necessary to modify every SmartClient CSS style
// that may be applied to a table cell to reverse a change in padding for all table cells that
// is introduced by bad third-party CSS.
//
// <li> <b>skinning</b>: third-party widgets may lack sufficient skinning APIs to allow you to match
// look and feel to SmartGWT, which may necessitate creating a custom SmartGWT skin to match
// the look and feel of third-party widgets (see +link{groupDef:skinning,Skinning Overview})
//
// <li> <b>event interference</b>: third-party widgets may register page-wide event handling
// logic that conflicts with or destroys similar event handling logic in SmartClient.  For best
// results, load third-party JavaScript libraries <b>before</b> SmartClient since SmartClient
// makes a best effort to preserve any previously installed handlers and allows such handlers to
// cancel native browser behaviors if they do so.
//
// <li> <b>RTL / i18n</b>: third party widgets may not allow all user-visible messages to be
// replaced, a requirement for internationalization / localization, or they may not support
// RTL/BIDI (Right-To-Left / Bi-Directional) rendering
// </ul>
//
// Because of issues like the above, not all of which may be resolvable for some third-party
// widgets, we recommend the following overall approach:
// <ul>
// <li> avoid using third-party widgets if you can build equivalent functionality in
//      SmartClient
// <li> if the third-party component is completely non-interactive, either does not require
//      ARIA markup or already includes such markup, and there are no conflicting look and feel
//      issues, go ahead and use it
// <li> if you anticipate issues, consider the
// +externalLink{http://www.smartclient.com/services/index.jsp#features,Feature Sponsorship Program}
//      as a means of getting new supported functionality added to SmartClient
// <li> search for existing posts and/or ask about the feasibility of integration on the
//      +externalLink{http://forums.smartclient.com/,SmartClient Forums}.
// <li> finally, you could attempt to tackle the issues above on your own.  To avoid wasting
//      time on dead ends, we would recommend assessing the amount of work involved in fixing
//      <b>all</b> problems that need to be solved before attempting actual fixes for any one issue.
// </ul>
//
// @title DOM Integration &amp; Third-party Components
// @treeLocation Concepts
// @visibility external
//<






//> @class BaseWidget
// Base class for +link{Canvas} and +link{DrawItem}.
// @treeLocation Client Reference/Foundation
// @visibility external
//<
isc.ClassFactory.defineClass("BaseWidget");


//> @class Canvas
// Base class for all SmartClient visual components (except +link{FormItem,FormItems}).
// <p>
// Canvas provides:
// <ul>
// <li> basic visual lifecycle support - creation and destruction of HTML via
//      +link{canvas.draw,draw()} and +link{canvas.clear,clear()}, visibility via
//      +link{canvas.show,show()} and +link{canvas.hide,hide()}, z-layering via
//      +link{canvas.bringToFront,bringToFront()} and +link{canvas.sendToBack,sendToBack()}.
// <li> consistent cross-browser +link{canvas.moveTo,positioning},
//      +link{canvas.resizeTo,sizing} and +link{canvas.getScrollHeight,size detection}, with
//      automatic compensation for +link{type:CSSStyleName,browser CSS behavior differences}.
// <li> clipping, scrolling and overflow management of content via +link{canvas.overflow}
// <li> consistent cross-browser +link{canvas.keyPress,key} and +link{canvas.mouseDown,mouse}
//      events, including +link{group:mobileDevelopment,mapping touch events} to mouse events
// <li> built-in drag and drop capabilities including +link{canvas.canDragReposition,moving},
//      +link{canvas.canDragResize,resizing}, +link{canvas.canDragScroll,drag scrolling}
//      and +link{canvas.snapToGrid,snap-to-grid} behavior.
// <li> the ability to either contain +link{canvas.contents,HTML content} or
//      +link{canvas.children,contain other Canvases}, including
//      +link{canvas.snapTo,an edge-based positioning} and
//      +link{canvas.percentSource,percent sizing system} for children.  For more advanced layout
//      capabilities, see +link{Layout}.
// <li> various other details like +link{canvas.cursor,cursors},
//      +link{canvas.showClickMask,modal masking}, +link{canvas.animateMove,animation},
//      +link{canvas.ariaRole,accessibility properties}, and
//      +link{canvas.locateChildrenBy,settings} for +link{group:automatedTesting,automated testing}.
// </ul>
// @inheritsFrom BaseWidget
// @treeLocation Client Reference/Foundation
// @visibility external
//<

// declare the class itself
isc.ClassFactory.defineClass("Canvas", "BaseWidget");

isc.defer("isc.Canvas.addProperties({ _browserSupportsNativeTouchScrolling: isc.Browser._getSupportsNativeTouchScrolling() });" +
"if (isc.Canvas._instancePrototype.edgeMarginSize == null) isc.Canvas.addProperties({ edgeMarginSize: isc.Browser.isTouch ? 10 : 5 });" +
"isc.Page._applyDefaultViewport();");

// for speed, override the default isA function provided by ClassFactory.  The marker property
// "_isA_Canvas" is added below as both a class and instance property.
// Note that this approach could be extended to all classes via generating unique marker
// properties (so that iterating up the inheritance chain would not be required) but that would
// slow down init time, and isA.Canvas is 99% of the critical path usage anyway
isc.isA.Canvas = function (object) { return (object != null && object._isA_Canvas); };

// define groups for documentation purposes

    //> @groupDef positioning
    //  Horizontal and vertical location on the page
    //<
    //> @groupDef visibility
    //  Whether an object can be seen
    //<
    //> @groupDef sizing
    // Width and height of an object
    //<
    //> @groupDef appearance
    // Properties defining an object's appearance
    //<
    //> @groupDef drawing
    // Rendering an object on the page.
    // <smartgwt>Include the Drawing module your SmartGWT application
    // by including <code>&lt;inherits name="com.smartgwt.Drawing"/&gt;</code>
    // in your GWT module XML.</smartgwt>
    //<
    //> @groupDef zIndex
    // Object's "stacking order" above or below other objects
    //<
    //> @groupDef scrolling
    // Scrolling and clipping of objects when part of the object is obscured
    //<
    //> @groupDef events
    // Handling mouse and keyboard events generated by the user
    //<
    //> @groupDef containment
    // Canvases containing other objects as children or peers
    //<
    //> @groupDef cues
    // Visual hints for the user that something can be done to this object
    //<
    //> @groupDef dragdrop
    // Dragging objects and dropping them onto other objects
    // @title Drag and Drop
    //<
    //> @groupDef image
    // Utilities to render images
    //<
    //> @groupDef images
    // Referring to and loading images.
    // <P>
    // The two main URL settings relevant to loading images are:<br>
    // * imgDir (where application-specific images live)<br>
    // * skinImgDir (where system supplied images live)<br>
    //<
    //> @groupDef skins
    // Properties used to manage to the the overall appearance of the application.
    // <P>
    // A "skin" consists of
    // <ul>
    // <li><code>skin_styles.css</code>: a .css file defining the set of
    //     classes to apply to SmartClient components' visual elements</li>
    // <li><code>images/</code>: a directory of image files used as part of visual
    //     components</li>
    // <li><code>load_skin.js</code>: a .js file containing overrides for various
    //     SmartClient component properties that affect the appearance of those components.</li>
    // </ul>
    // Skins are loaded via the <code>skin</code> attribute of the +link{group:loadISCTag} or
    // by including the appropriate <code>load_skin.js</code> source file with a standard script
    // include tag.
    // <P>
    // To create a custom skin, we suggest making a complete copy of an existing skin, then
    // modifying the media, css class definitions and component property overrides you wish to
    // change.
    // <P>
    // Note that the <code>load_skin.js</code> file contains a +link{Page.setSkinDir()}
    // directive to set up the skin dir (used to ensure media is retrieved from the appropriate
    // directory), and a +link{Page.loadStyleSheet()} directive to load the .css file.
    // <P>
    // See the +link{group:skinning,Skinning Overview} for more information.
    //
    // @see group:appearance
    // @see group:images
    // @see group:files
    //<
    //> @groupDef files
    // Referring to and loading other files.
    // <P>
    // The two main URL settings relevant to file loading are:<br>
    // * appDir  (where application-specific files live)<br>
    // * isomorphicDir (where system supplied files live)<br>
    //<

    //> @groupDef utils
    // Misc utilities
    // @visibility internal
    //<
    //> @groupDef form
    // Utilities to deal with forms and form elements.<P>
    //
    // Internal because DynamicForm exposes the functionality we support for forms - dealing with
    // forms directly is a minefield.
    // @visibility internal
    //<
    //> @groupDef handles
    // Pointers to the DOM structures of objects that have been drawn
    // @visibility internal
    //<


//  Add class-level properties
//      You can access these properties on the static class object.
//      e.g.,   Canvas.myStaticProperty

isc.Canvas.addClassProperties({


    _isA_Canvas : true,

    //  Class constants
    AUTO:"auto", // the "use default" setting.
    ANYTHING:"**anything**", // generally means "any value is acceptable".


    //> @type   Positioning
    //          @visibility external
    //          @group  positioning
    ABSOLUTE:"absolute",        //  @value  isc.Canvas.ABSOLUTE     The canvas is absolutely positioned with respect to its parent.
    RELATIVE:"relative",        //  @value  isc.Canvas.RELATIVE     The canvas is relatively positioned according to the document flow.
    //<

    //> @type   Visibility
    //          @visibility external
    //          @group  visibility
    INHERIT:"inherit",          //  @value  isc.Canvas.INHERIT      The widget visibility will match that of its parent (usually visible).
    VISIBLE:"visible",          //  @value  isc.Canvas.VISIBLE      The widget will always be visible whether its parent is or not.
    HIDDEN:"hidden",            //  @value  isc.Canvas.HIDDEN       The widget will always be hidden even when its parent is visible.
    //<

    //> @type   DrawnState
    //          @group  drawing
    COMPLETE:"complete",
    //  @value  isc.Canvas.COMPLETE     the canvas is completely drawn, including children and peers, set up events, etc.
    DRAWN:"complete",
    //  @value  isc.Canvas.DRAWN        the canvas is completely drawn (synonym for isc.Canvas.COMPLETE)
    DRAWING_HANDLE:"drawingHandle",
    //  @value  isc.Canvas.DRAWING_HANDLE     the canvas is in the process of writing it's handle to the page / DOM
    HANDLE_DRAWN:"handleDrawn",
    //  @value  isc.Canvas.HANDLE_DRAWN     the canvas has completely written its handle to DOM
    UNDRAWN:"undrawn",
    //  @value  isc.Canvas.UNDRAWN     the canvas has not been drawn
    //<

    //> @type Overflow
    // @visibility external
    //          @group  sizing
    //  @value  Canvas.VISIBLE      Content that extends beyond the widget's width or height is
    //                              displayed.
    //                              Note: To have the content be sized only by the drawn size of
    //                              the content set the overflow to be Canvas.VISIBLE and specify
    //                              a small size, allowing the size to expand to the size required
    //                              by the content.
    //                              Leaving the width / height for the widget undefined will use the
    //                              default value of 100, and setting the size to zero may cause the
    //                              widget not to draw.
    //  @value  Canvas.HIDDEN       Content that extends beyond the widget's width or height is
    //                              clipped (hidden).
    //  @value  Canvas.AUTO         Horizontal and/or vertical scrollbars are displayed only if
    //                              necessary. Content that extends beyond the remaining visible
    //                              area is clipped.
    //  @value  Canvas.SCROLL       Horizontal and vertical scrollbars are always drawn inside the
    //                              widget. Content that extends beyond the remaining visible area
    //                              is clipped, and can be accessed via scrolling.
    SCROLL:"scroll",
    //  @value  Canvas.CLIP_H       Clip horizontally but extend the canvas's clip region
    //                              vertically if necessary.
    CLIP_H:"clip-h",
    //  @value  Canvas.CLIP_V       Clip vertically but extend the canvas's clip region
    //                              horizontally if necessary.
    CLIP_V:"clip-v",
    //<



    //  @value  Canvas.IGNORE       Clipping is ignored by the ISC system. This setting may be used
    //                              for improved performance, with frequently-drawn widgets whose
    //                              dimensions always agree exactly with the size of their contents.
    IGNORE:"ignore",

    //> @type   ScrollMechanism
    //          @group  scrolling
    NATIVE:"native",
    //  @value  isc.Canvas.NATIVE   Scroll by "native" mechanism - assigning directly to scrollLeft
    //                              and scrollTop
    CLIP:"clip",
    //  @value  isc.Canvas.CLIP     Scroll by repositioning / resizing handle and moving a clip
    //                              region as a viewport
    NESTED_DIV:"nestedDiv",
    //  @value  isc.Canvas.NESTED_DIV   Scroll by moving a handle around within an outer handle.
    //<

    //> @type Alignment
    CENTER:"center",            //  @value  isc.Canvas.CENTER       Center within container.
    LEFT:"left",                //  @value  isc.Canvas.LEFT         Stick to left side of container.
    RIGHT:"right",              //  @value  isc.Canvas.RIGHT        Stick to right side of container.
    // @group appearance
    // @visibility external
    //<

    //> @type VerticalAlignment
    //  @value  isc.Canvas.TOP          At the top of the container
    TOP:"top",
    //  @value  isc.Canvas.CENTER       Center within container.
    //  @value  isc.Canvas.BOTTOM       At the bottom of the container
    BOTTOM:"bottom",
    // @group appearance
    // @visibility external
    //<

    //> @type Side
    // Side of a component.
    //  @value  isc.Canvas.LEFT         Left side
    //  @value  isc.Canvas.RIGHT        Right side
    //  @value  isc.Canvas.TOP          Top side
    //  @value  isc.Canvas.BOTTOM       Bottom side
    // @visibility external
    //<


    //> @type   Direction
    //          @visibility external
    //          @group  appearance
    //  @value  isc.Canvas.UP           above
    UP:"up",

    //  @value  isc.Canvas.DOWN         below
    DOWN:"down",
    //  @value  Canvas.LEFT         to the left of
    //  @value  Canvas.RIGHT        to the right of
    //<

    // other generic constants
    BOTH:"both",
    NONE:"none",
    VERTICAL:"vertical",
    HORIZONTAL:"horizontal",
    // layoutResizeBarPolicy constants
    MARKED:"marked",
    MIDDLE:"middle",
    ALL:"all",

    //> @type Cursor
    //
    // You can use whatever cursors are valid for your deployment platforms, but keep in mind that
    // visual representation may vary by browser and OS. See the
    // +externalLink{https://developer.mozilla.org/en-US/docs/Web/CSS/cursor,MDN <code>cursor</code> page}
    // for a live demonstration.
    //
    //  @value  Canvas.DEFAULT      Use the default arrow cursor for this browser/OS.
    //  @value  Canvas.AUTO         Use the default cursor for this element type in this browser/OS
    //  @value  Canvas.WAIT         Use the wait cursor.
    //  @value  Canvas.HAND         Use the hand cursor.
    //  @value  Canvas.MOVE         Use the "move" (crosshairs) cursor.
    //  @value  Canvas.HELP         Use the 'help' cursor.
    //  @value  Canvas.TEXT         Use the 'text' (i-beam) cursor.
    //  @value  POINTER             Use the normal hand pointer that appears when you hover over a link
    //  @value  "arrow"
    //  @value  "all-scroll"
    //  @value  "crosshair"         Use the 'crosshair' ( + ) cursor.
    //  @value  "col-resize"        Use the column resize cursor (horizontal double-tipped arrow)
    //  @value  "row-resize"        Use the row resize cursor (vertical double-tipped arrow)
    //  @value  "e-resize"          Use the "east resize" cursor.
    //  @value  "w-resize"          Use the "west resize" cursor.
    //  @value  "n-resize"          Use the "north resize" cursor.
    //  @value  "s-resize"          Use the "south resize" cursor.
    //  @value  "se-resize"         Use the "south-east resize" cursor.
    //  @value  "ne-resize"         Use the "north-east resize" cursor.
    //  @value  "nw-resize"         Use the "north-west resize" cursor.
    //  @value  "sw-resize"         Use the "south-west resize" cursor.
    //  @value  "not-allowed"       Use the "not-allowed" cursor.
    //
    //  @group  cues
    //  @see    attr:Canvas.cursor
    //
    //  @visibility external
    //  @example cursors
    //<
    //  @value  Canvas.ARROW        Synonym for "default"
    // NOTE: there is a difference between Canvas.DEFAULT and Canvas.AUTO - auto is as if there
    // was no cursor specified - if the element has text in it, the I-Beam text selection cursor
    // will show up when the user rolls over it. If the cursor is set to 'default' however the
    // cursor will show the standard default cursor (arrow) over the entire element.
    DEFAULT:"default",
    ARROW:"default",

    WAIT:"wait",
    // in Moz and in Safari/Chrome strict mode we have to use "pointer" rather than "hand"
    HAND:(isc.Browser.isMoz || (isc.Browser.isSafari && isc.Browser.isStrict)
            || (isc.Browser.isIE && isc.Browser.version >= 9 && isc.Browser.isStrict)
             ? "pointer" : "hand"),
    MOVE:"move",
    HELP:"help",
    TEXT:"text",
    CROSSHAIR:"crosshair",
    // Used for no-drop indication - not supported on Safari

    NOT_ALLOWED:"not-allowed",

    // NOTE: e-resize means "east resize".  On Windows, there's no distinction between east and west
    // resize (it's just horizontal resize), but on some OS' it may look directional, so we may need
    // to add a conditional to fall back to the "move" cursor on non-Windows platforms.
    COL_RESIZE:(isc.Browser.isIE && isc.Browser.version >= 6 ? "col-resize" : "e-resize"),
    RTL_COL_RESIZE:(isc.Browser.isIE && isc.Browser.version >= 6 ? "col-resize" : "w-resize"),

    ROW_RESIZE:(isc.Browser.isIE && isc.Browser.version >= 6 ? "row-resize" : "n-resize"),

    //> @type   ImageStyle
    //          @visibility external
    //          @group  appearance
    //  @value  isc.Canvas.CENTER   Center (and don't stretch at all) the image if smaller than its enclosing frame.
    //CENTER:"center",
    //  @value  isc.Canvas.TILE     Tile (repeat) the image if smaller than its enclosing frame.
    TILE:"tile",
    //  @value  isc.Canvas.STRETCH  Stretch the image to the size of its enclosing frame.
    STRETCH:"stretch",
    //  @value  isc.Canvas.NORMAL   Allow the image to have natural size
    NORMAL:"normal",
    //<

    //> @type BackgroundRepeat
    // Possible values for +link{canvas.backgroundRepeat}.
    REPEAT:"repeat",            //  @value  isc.Canvas.REPEAT       Tile the background image horizontally and vertically.
    NO_REPEAT:"no-repeat",      //  @value  isc.Canvas.NO_REPEAT    Don't tile the background image at all.
    REPEAT_X:"repeat-x",        //  @value  isc.Canvas.REPEAT_X     Repeat the background image horizontally but not vertically.
    REPEAT_Y:"repeat-y",        //  @value  isc.Canvas.REPEAT_Y     Repeat the background image vertically but not horizontally.
    // @group appearance
    // @visibility external
    //<

    //> @type   Canvas.TextDirection
    //      Specifies RTL or LTR direction for text -- IE 5+ only
    //      Specify this to have your text show up "right to left" (rtl), eg: in Arabic or Hebrew
    //      Note: more efficient to leave blank for default of "left to right" (ltr)
    //  @group  appearance
    LTR:"ltr",              //  @value  isc.Canvas.LTR      Show text left-to-right (eg: English)
    RTL:"rtl",              //  @value  isc.Canvas.RTL      Show text right-to-left (eg: Arabic)
    //<

    //> @type   Canvas.SnapDirection
    //      Specifies which direction to snap to, when snap-to-grid is enabled
    //  @group  dragdrop
    BEFORE:"before",    //  @value  isc.Canvas.BEFORE   Always snap up or left
    AFTER:"after",      //  @value  isc.Canvas.AFTER    Always snap down or right
    NEAREST:"nearest",  //  @value  isc.Canvas.NEAREST  Snap to the nearest grid point
    //<

    //> @type   Canvas.SnapAxis
    //      Specifies which axis or axes we consider when snap-to-grid is enabled
    //  @group  dragdrop
                        //  @value  isc.Canvas.HORIZONTAL   Snap on the horizontal axis
                        //  @value  isc.Canvas.VERTICAL     Snap on the horizontal axis
                        //  @value  isc.Canvas.BOTH         Snap on both axes
    //<





    // default zIndex for the next item to be drawn
    _nextZIndex:200000,

    // zIndex of the next item to be sent to the back
    _SMALL_Z_INDEX:199950,

    // zIndex of the next item to be brought to the front
    _BIG_Z_INDEX:800000,


    //> @classAttr isc.Canvas.TAB_INDEX_GAP (integer : 80 : R)
    //      Specifies the gap to leave between automatically assigned tab indices for focusable
    //      canvii
    //<
    TAB_INDEX_GAP:50,

    //> @classAttr isc.Canvas.TAB_INDEX_FLOOR (integer : 1000 : R)
    //      Specifies the lower limit for automatically assigned tab indices for focusable canvii.
    // @group focus
    // @visibility external
    //<
    TAB_INDEX_FLOOR:1000,

    //> @classAttr isc.Canvas.TAB_INDEX_CEILING (integer : 32766 : RA)
    // This is the native browser upper limit for tabIndices
    // @visibility internal
    //<

    TAB_INDEX_CEILING:32766,

    // List of CSS attributes that apply to text only:
    textStyleAttributes : [ "fontFamily", "fontSize", "color", "backgroundColor",
                            "fontWeight", "fontStyle", "textDecoration", "textAlign"
                            // Optionally also include: fontSizeAdjust, fontVariant, whiteSpace
                          ],

    // IE Filter settings
    // ---------------------------------------------------------------------------------------


    // Preventing style doubling
    // In various places we render widgets as a <table> inside a <div> but want to
    // allow a single CSS style for the combined DOM structure.
    // In this case we have to re-apply the css class applied to the widget to the TD as otherwise
    // text based styling options will not be applied because it doesn't cascade through table
    // elements.
    // However we DON'T want every CSS setting to apply to both the outer <div> and inner <td>
    // or we end up with (for example) doubled borders.
    // We usually handle this by writing out explicit "null" styling options on the TD to
    // override the properties we don't want doubled from the css class. These options then take
    // presidence over the attributes specified in the CSS class.
    // Use this central string to clear out
    // - margin, border, padding, bg color, filter (eg CSS gradient), background-image

    // Note: called once on framework init. May be called after framework init due to
    // changing the value of neverUseFilters / allowExternalFilters etc.
    _doublingStringObservers:[],
    _setDoublingStrings : function () {
        this._$noStyleDoublingCSS = isc.Browser.isIE && (!this.neverUseFilters || this.allowExternalFilters)
                ? "margin:0px;border:0px;padding:0px;background-image:none;background-color:transparent;-webkit-box-shadow:none;box-shadow:none;filter:none;"
                : "margin:0px;border:0px;padding:0px;background-image:none;background-color:transparent;-webkit-box-shadow:none;box-shadow:none;";
        // NOTE: actually a constant used in button rendering
        isc.Canvas.addProperties({
            _$tableNoStyleDoubling : "' style='" + isc.Canvas._$noStyleDoublingCSS
        });
        // Since this string is dynamic (see setNeverUseFilters()), but may be cached
        // in various places, those places will need to be notified when it changes
        // We're using standard 'target' / 'methodName' terminology here and passing in the
        // new string.
        for (var i = 0; i < this._doublingStringObservers.length; i++) {
            var callback = this._doublingStringObservers[i];
            if (callback.target == null || callback.target.destroyed) continue;
            callback.target[callback.methodName](this._$noStyleDoublingCSS);
        }
    },

    //> @groupDef IEFilters
    // In order to compensate for various bugs and missing features in Internet Explorer, it's
    // necessary to use Microsoft-proprietary "filter" settings, as follows:
    // <ul>
    // <li> IE6-8: Opacity filter required for opacity to work at all
    // <li> IE6: AlphaImageLoader filter required for PNG transparency to work at all
    // <li> IE7-8: AlphaImageLoader filter required for PNG transparency to work properly with
    //      opacity (eg, translucent rounded windows), otherwise, PNGs will turn entirely black
    //      or show other severe artifacts when opacity is applied
    // </ul>
    // Using these filters has a range of side-effects:
    // <ul>
    // <li> AlphaImageLoader will cause the UI to appear frozen until users have downloaded all
    //      PNG media shown on the page
    // <li> moderate to severe impact on rendering speed (20-60%)
    // <li> font smoothing is disabled
    // </ul>
    // <P>
    // For an application that is frequently used (where images will typically be cached) on
    // recent machines, and where font smoothing is not considered important, no special steps
    // need to be taken.
    // <P>
    // If any of the above side effects are important, our recommendations are:
    // <ul>
    // <li> minimize use of PNG media - use .gif instead
    // <li> for IE7-8, +link{canvas.neverUsePNGWorkaround,disable AlphaImageLoader} and
    //      +link{canvas.useOpacityFilter,disable Opacity} globally since these browsers
    //      can only render PNGs correctly in the absence of opacity settings.  Selectively
    //      enable opacity only in widgets that do not contain PNGs (eg the modalMask shown by
    //      a Window).  Avoid the use of opacity fades as a transition effect for IE unless you
    //      have eliminated all or almost all PNG media and the remaining artifacts are considered
    //      acceptable.  Also eliminate all use of filter effects in CSS, and
    //      +link{canvas.allowExternalFilters,disable the workaround} that makes this possible.
    // <li> if IE6 performance is critically important, eliminate all PNG media and all use of
    //      opacity and +link{canvas.neverUseFilters,disable all filters}.
    // </ul>
    // Note that the .gif format does not support partially transparent pixels, hence can't be
    // used for very high-quality antialiasing effects.  However, certain specific tools can
    // produce high-quality anti-aliased images in the less known PNG8 format, and this
    // particular format has the least artifacts in the above situations.  Details
    // +externalLink{http://blogs.sitepoint.com/2007/09/18/png8-the-clear-winner/, here}.
    //
    // @title Internet Explorer "filter" effects
    // @visibility external
    //<

    //> @classAttr Canvas.neverUsePNGWorkaround (boolean : null : IR)
    // If set, the AlphaImageLoader IE filter will never be used.   Does not remove
    // AlphaImageLoader usage in already-drawn components.
    // <P>
    // See +link{group:IEFilters} for background.
    //
    // @group IEFilters
    // @visibility external
    //<

    //> @classAttr Canvas.neverUseFilters (boolean : null : IR)
    // Disables automatic use of filters in IE by default.  Filters will only be used if
    // +link{canvas.useOpacityFilter} is explicitly set to true on a component.
    // <P>
    // Does not remove filters on already drawn components, or which are applied via CSS.
    // <P>
    // See +link{group:IEFilters} for background.
    //
    // @group IEFilters
    // @visibility external
    //<

    //> @classMethod Canvas.setNeverUseFilters()
    // Changes the system-wide +link{Canvas.neverUseFilters} setting.
    // @param neverUseFilters (boolean) new setting
    //
    // @group IEFilters
    // @visibility external
    //<
    setNeverUseFilters : function (neverUseFilters) {
        this.neverUseFilters = neverUseFilters;
        this._setDoublingStrings();
    },

    //> @classAttr Canvas.allowExternalFilters (boolean : true : IR)
    // If enabled, uses a moderately expensive workaround to allow the use of IE filters in CSS
    // to produce gradient effects for buttons, grid rows, and other elements, without the use
    // of image backgrounds.
    // <P>
    // See +link{group:IEFilters} for background.
    //
    // @group IEFilters
    // @visibility external
    //<
    allowExternalFilters:true,

    //> @classMethod Canvas.setAllowExternalFilters()
    // Changes the system-wide +link{Canvas.allowExternalFilters} setting.
    // @param allExternalFilters (boolean) new setting
    //
    // @group IEFilters
    // @visibility external
    //<
    setAllowExternalFilters : function (allowExternalFilters) {
        this.allowExternalFilters = allowExternalFilters;
        this._setDoublingStrings();
    },

    //> @attr canvas.useOpacityFilter (boolean : null : IR)
    // Configures where the Opacity filter is used for IE6-8.
    // <P>
    // With the default of null, opacity filters are used unless
    // +link{classAttr:Canvas.neverUseFilters} has been set.  When set explicitly to true,
    // opacity filters are used even if <code>neverUseFilters</code> is true.
    // <P>
    // See +link{group:IEFilters} for background.
    //
    // @group IEFilters
    // @visibility external
    //<


    // Delayed Redraw
    // -----------------------------------------------------------------------------------------
    //> @classAttr  isc.Canvas._redrawQueue     (array of canvas objects : [] : IRWA)
    //          array to hold pointers to canvases that need to be redrawn
    //          these items will be redrawn automatically after "a little while"
    //      @group  handles
    //      @see    Canvas.clearRedrawQueue()
    //<
    _redrawQueue:[],

    //> @classAttr  Canvas._redrawQueueDelay        (number : 0 : IRWA)
    //          (msec) delay after which canvases that need to be redrawn are actually redrawn
    //      @group  handles
    //      @see    Canvas.clearRedrawQueue()
    //<
    // NOTE: redraws are generally done on a timer because it batches many changes which require
    // redraws into a single redraw.  Redraws can be done immediately, in specific circumstances
    // like drag resizing, in order to provide more immediate response.
    _redrawQueueDelay:(0),
    _delayedAdjustOverflowQueueDelay:200,

    // Stats and global Canvas tracking
    // -----------------------------------------------------------------------------------------
    //> @classAttr  isc.Canvas._canvasList      (array of canvas objects : [] : IRWA)
    //          array to hold pointers to all of the canvases that have been created
    //          so we can clear them out later
    //      @group  handles
    //      @platformNotes  Used in IE only to clear all handles when the page is unloaded.
    //      @see    Canvas._clearDOMHandles()
    //<
    _canvasList:[],

    // count of canvases which are flagged as _iscInternal used e.g. in the Developer Console to
    // report the end-user canvas count number
    _iscInternalCount: 0,

    // object where we record/update various statistics
    _stats : {
        redraws:0,
        clears:0,
        destroys:0,
        draws:0
        // NOTE: number allocated is just Canvas._canvasList.length
    },
    // object for tracking redraws by widget ID
    _redraws : {
    },

    // cache for partwise-event handler names
    _partHandlers : {},

    // Wrapping HTML in Canvii
    // -----------------------------------------------------------------------------------------
    _wrapperCanvasStack : [],


    useMozBackMasks : false,

    //> @classAttr canvas.useNativeWheelDelta (boolean : true: RWA)
    // If set, use the magnitude of the wheel delta as reported by the browser
    // to estimate the OS wheel sensitivity setting. Currently, this only applies
    // to Firefox, and controls whether or not SCROLL_PAGE_UP or SCROLL_PAGE_DOWN
    // events are parsed (a facility which is wholly undocumented). All other browsers
    // return wheelDeltas in multiples of 120, depending on how fast the user
    // scrolls the wheel, and regardless of OS sensitivity settings.
    // @group scrolling
    // @visibility internal
    //<
    useNativeWheelDelta: true,

    //> @classAttr canvas.scrollWheelDelta (number : 50 : RWA)
    //
    // How far should this canvas be scrolled in response to mouse scroll wheel
    // events? This value governs how far the canvas will scroll, in pixels, when the
    // user moves the mouse wheel by the smallest possible increment.
    // <P>
    // For most browsers, this is the sole option controlling the sensitivity of the
    // scroll wheel, though some systems allow the user to configure the sensitivity of
    // the mouse wheel.
    // <P>
    // For Firefox, this value represents the distance to scroll when the user
    // moves the mousewheel by the smallest possible increment with a browser/OS
    // configured wheel sensitivity of 3 lines. If the sensitivity is increased or reduced,
    // the scroll scroll distance will be equal to scrollWheelDelta * (lines/3).<br>
    // If the OS is set to page-at-a-time scrolling, for Firefox, the distance scrolled is the
    // height of the window, rounded down to a multiple of scrollWheelDelta.
    // <P>
    // See also +link{EventHandler.getWheelDelta()}.
    // @group scrolling
    //<
    scrollWheelDelta: 50,

    //> @classAttr canvas.loadingImageSrc (SCImgURL : "[SKINIMG]loadingSmall.gif" : RWA)
    // Image URL to be displayed while data is being loaded (if enabled for the widget
    // waiting for data). Must be square; +link{loadingImageSize} specifies the width
    // and height.
    // @group animation
    // @see listGrid.loadingDataMessage
    // @see detailViewer.loadingMessage
    // @see HTMLFlow.loadingMessage
    // @see ViewLoader.loadingMessage
    // @visibility external
    //<
    loadingImageSrc: "[SKINIMG]loadingSmall.gif",

    //> @classAttr canvas.loadingImageSize (integer : 16 : RWA)
    // Specifies the width and height of +link{loadingImageSrc}.
    // @group animation
    // @visibility external
    //<
    loadingImageSize: 16,

    //> @classAttr Canvas.defaultPageSpace (int : 0 : IRA)
    // A fixed number of pixels at the top of the page in which components will not be placed.
    // This is overridable per-instance via the +link{Canvas.leavePageSpace} attribute.
    // Essentially, the effect is that all top-level components are shifted down this number of
    // pixels, and the page height is treated as this number of pixels <em>less</em> than the
    // real page height.
    // <p>
    // This attribute can be useful on certain mobile devices, when components should not be
    // placed in a top portion of the screen. For example, on iOS devices in certain configurations,
    // this can be set to 20 to avoid placing any component into the status bar area. Or, if
    // using iOS 7.1's 'minimal-ui' viewport parameter, this can be set to 20 to avoid placing
    // any component into the top 20px area of the screen, which if tapped on iPhone in landscape,
    // causes Mobile Safari's address bar and tab bar to be shown.
    // <p>
    // This setting can be changed at runtime by calling +link{Canvas.setDefaultPageSpace()}.
    // <p>
    // <strong>Note:</strong> As documented by the +link{group:mobileDevelopment,Mobile Application Development}
    // page, when the SmartClient application is running in Mobile Safari on iPhone running iOS 7.1 or
    // later, and neither the <code>isc_useDefaultViewport</code> nor the <code>isc_useMinimalUI</code>
    // global is set to <code>false</code> when the framework is loaded, then the framework
    // will automatically set the <code>defaultPageSpace</code> to 0 in portrait orientation,
    // and to 20 in landscape orientation.
    //
    // @group positioning
    // @visibility external
    //<

    defaultPageSpace: 0,

    //> @classMethod canvas.setDefaultPageSpace() (A)
    // Changes the global +link{Canvas.defaultPageSpace}.
    //
    // @param newDefaultPageSpace (int) the new value for <code>defaultPageSpace</code>.
    // @visibility external
    //<
    setDefaultPageSpace : function (newDefaultPageSpace) {
        this.defaultPageSpace = newDefaultPageSpace;
        isc.EH._pageResize();
    },



    _contentMeasureCanvasDefaults : {
        width: 1,
        height: 1,
        top: -1000,
        autoDraw: false
    },
    measureContent : function (content, widget, returnHeight, canvasProps) {
        var props = isc.addProperties({}, isc.Canvas._contentMeasureCanvasDefaults);
        props.contents = content;
        if (widget && widget.styleName) props.styleName = widget.styleName;
        if (canvasProps) isc.addProperties(props, canvasProps);
        var canvas = isc.Canvas.create(props);
        canvas.draw();
        var result = returnHeight ? canvas.getScrollHeight() : canvas.getScrollWidth();
        canvas.clear();
        canvas.destroy();
        canvas = null;
        return result;
    }
});
isc.Canvas._setDoublingStrings();

isc.Canvas.addProperties({

    _isA_Canvas : true,

    //> @attr   canvas.ID       (string : null : IR)
    // Global identifier for referring to a widget in JavaScript.  The ID property is optional if
    // you do not need to refer to the widget from JavaScript, or can refer to it indirectly
    // (for example, by storing the reference returned by +link{class.create,create()}).
    // <P>
    // An internal, unique ID will automatically be created upon instantiation for any canvas
    // where one is not provided.
    // <P>
    // The ID property should be unique in the global scope. If <code>window[<i>ID</i>]</code>
    // is already assigned to something else a warning will be logged using the developer console,
    // and the existing reference will be replaced, calling +link{Canvas.destroy(),destroy()} on the
    // previous object if it is a SmartClient Class instance.
    // <P>
    // Automatically generated IDs will be unique as long as the canvases they refer to remain
    // active - once a canvas with an automatically generated ID has been destroyed, its ID may be
    // reused for the next canvas created with no explicitly specified ID.
    //
    // @group basics
    // @visibility external
    //<

    //> @attr   canvas.autoDraw     (Boolean : true : IR)
    // If true, this canvas will draw itself immediately after it is created.
    // <P>
    // <b>Note</b> that you should turn this OFF for any canvases that are provided as children
    // of other canvases, or they will draw initially, then be clear()ed and drawn again when
    // added as children, causing a large performance penalty.
    // <P>
    // For example, the following code is incorrect and will cause extra draw()s:
    // <P>
    // <pre>
    //     isc.Layout.create({
    //         members : [
    //             isc.ListGrid.create()
    //         ]
    //     });
    // </pre>
    // It should instead be:
    // <pre>
    //     isc.Layout.create({
    //         members : [
    //             isc.ListGrid.create(<b>{ autoDraw: false }</b>)
    //         ]
    //     });
    // </pre>
    // In order to avoid unwanted autoDrawing systematically, it is recommend that you call
    // +link{classMethod:isc.setAutoDraw(),isc.setAutoDraw(false)} immediately after SmartClient is loaded
    // and before any components are created, then set <code>autoDraw:true</code> or call
    // draw() explicitly to draw components.
    // <P>
    // Otherwise, if the global setting for autoDraw remains <code>true</code>, you must set
    // autoDraw:false, as shown above, on every component in your application that
    // should not immediately draw: all Canvas children, Layout members, Window items, Tab
    // panes, etc, however deeply nested.  Forgetting to set autoDraw:false will result in one
    // more clear()s - these are reported on the Results tab of the
    // +link{group:debugging,Developer Console}, and can be tracked to individual components by
    // using the "clears" log category in the Developer Console.
    //
    //  @example autodraw
    //  @visibility external
    //  @group  drawing
    //<
    autoDraw:true,

    // Children and Peers
    // --------------------------------------------------------------------------------------------

    //> @attr   canvas.parentElement    (Canvas : null : [IRA])
    // This Canvas's immediate parent, if any.
    // <BR>
    // Can be initialized, but any subsequent manipulation should be via
    // +link{canvas.addChild(),addChild()} and +link{canvas.removeChild(),removeChild()} calls
    // on the parent.
    //
    //  @visibility external
    //  @group  containment
    // @deprecated As of Smartclient version 9.1, deprecated in favor of +link{canvas.parentCanvas}
    //             and +link{canvas.getParentCanvas()}
    //<

    //> @attr   canvas.parentCanvas    (Canvas : null : [IR])
    // This Canvas's immediate parent, if any.
    // <BR>
    // Can be initialized, but any subsequent manipulation should be via
    // +link{canvas.addChild(),addChild()} and +link{canvas.removeChild(),removeChild()} calls
    // on the parent. The parent Canvas should be fetched using
    // +link{canvas.getParentCanvas(),getParentCanvas()}.
    //
    //  @visibility external
    //  @group  containment
    //<

    //> @attr   canvas.topElement    (Canvas : null : [RA])
    // The top-most Canvas (i.e., not a child of any other Canvas), if any, in this widget's
    // containment hierarchy.
    //  @visibility external
    //  @group  containment
    //<

    //> @attr   canvas.masterElement    (Canvas : null : [RA])
    // This Canvas's "master" (the Canvas to which it was added as a peer), if any.
    //  @visibility external
    //  @group  containment
    // @deprecated In favor or +link{canvas.getMasterCanvas()} as of SmartClient release 9.1
    //<

    //> @attr canvas.children (Array of Canvas : null : IR)
    // Array of all Canvii that are immediate children of this Canvas.
    // <P>
    // Use +link{addChild()} and +link{removeChild()} to add and remove children after a Canvas
    // has been created/drawn.
    //
    // @visibility external
    // @group containment
    //<

    //> @attr canvas.peers (Array of Canvas : null : IRA)
    // Array of all Canvii that are peers of this Canvas.
    // <P>
    // Use +link{addPeer()} and +link{removePeer()} to add and remove peers after a Canvas
    // has been created/drawn.
    //
    // @visibility external
    // @group  containment
    //<

    //> @attr canvas.autoParent (String : null : IRA)
    // This initialization property allows developers to create a canvas using the
    // +link{class.addAutoChild()} method, and have it added as a child to some other
    // component.  This property may be set to the <code><i>childName</i></code> of another
    // already-created auto-child, or <code>"none"</code> to cause the component to be
    // created without being added as a child to any other widget.<br>
    // If unset, the canvas will be added as a child to the component on which
    // <code>addAutoChild(...)</code> was called.
    // <P>
    // See +link{group:autoChildren} for an overview of the autoChild subsystem.
    // @visibility external
    // @group autoChildren
    //<

    //> @attr canvas.allowContentAndChildren (boolean : true : [IA])
    // If true this widget supports having content specified via the content property and
    // children specified in the normal way.  Normally, if children are present, content
    // returned from getInnerHTML() is shown but is not refreshed by redraw().
    // <P>
    // Enabling entails a small performance reduction on redraw()s.
    // @visibility internal
    //<

    allowContentAndChildren:true,

    //> @attr canvas.drawChildrenThenContent (boolean : false : [IA])
    // If true, and this widget supports having content and children, when this widget is
    // drawn, the children will be written into the handle, then the content will be created
    // and inserted before the first child in the DOM.
    // <P>
    // This is used by widgets who need to create content based on the rendered size of their
    // children.
    // @visibility internal
    //<

    // --------------------------------------------------------------------------------------------

    //> @object DrawContext
    // Object that expresses the position in the DOM where a Canvas should draw itself, used
    // for insertion into an existing DOM structure.
    // @treeLocation Client Reference/Foundation/Canvas
    // @group drawContext
    // @visibility internal
    //<



    //> @attr drawContext.element (DOMElement : null : [IRA])
    // Element in the DOM
    // @group drawContext
    // @visibility internal
    //<

    //> @attr drawContext.position (DrawPosition : "beforeBegin" : [IRA])
    // Position where Canvas should be inserted relative to <code>drawContext.element</code>.
    // @group drawContext
    // @visibility internal
    //<

    //> @attr canvas.drawContext (DrawContext : null : [IRWA])
    // Location in the DOM where this Canvas should draw itself, specified as an existing DOM
    // element and a position relative to that element.
    // <P>
    // This feature is intended for temporary integration with legacy page architectures only;
    // the native browser's reaction to DOM insertion is unspecified and unsupported.  For
    // consistent cross-browser layout and positioning semantics, use Canvas parents
    // (especially Layouts) and use absolute positioning at top level.
    // <P>
    // NOTE: persistence of drawContext: if a Canvas is clear()d and then draw()n again, it will
    // keep the same drawContext unless the <code>drawContext.position</code> was "replace".<P>
    // If a Canvas is added as a child to Canvas parent, its drawContext will be dropped.
    // @group drawContext
    // @visibility internal
    //<

    // HTMLElement
    // ---------------------------------------------------------------------------------------

    //> @type DrawPosition
    // @value "beforeBegin" insert before the target element
    // @value "afterBegin"  insert as the target element's first child
    // @value "beforeEnd"   insert as the target element's last child
    // @value "afterEnd"    insert after the target element
    // @value "replace"     replace the target element
    // @visibility external
    //<

    //> @attr canvas.htmlElement (DOMElement : null : IRWA)
    // If specified as a pointer to an HTML element present in the DOM, this canvas will be
    // rendered inside that element on +link{Canvas.draw(), draw()}.
    // <P>
    // <i>NOTES:</i><br>
    // This feature is intended for temporary integration with legacy page architectures only;
    // the native browser's reaction to DOM insertion is unspecified and unsupported. For
    // consistent cross-browser layout and positioning semantics, use Canvas parents
    // (especially Layouts) and use absolute positioning at top level.
    // <P>
    // Persistence of htmlElement: If +link{canvas.htmlPosition} is set to <code>"replace"</code>
    // the htmlElement will be removed from the DOM when the canvas is drawn - therefore the
    // htmlElement attribute will be cleared at this time.
    // Otherwise if a Canvas is clear()d and then draw()n again it will
    // be rendered inside the same htmlElement.<br>
    // If a Canvas is added as a child to Canvas parent, its htmlElement will be dropped.
    // <P>
    // +link{canvas.position} should typically be set to <code>"relative"</code> if the widget
    // is to be rendered inline within a standard page.
    // @group htmlElement, positioning
    // @visibility external
    //<

    //> @attr canvas.htmlPosition (DrawPosition : "afterBegin" : [IRWA])
    // If +link{canvas.htmlElement} is specified, this attribute specifies the position where
    // the canvas should be inserted relative to the <code>htmlElement</code> in the DOM.
    // @group htmlElement, positioning
    // @visibility external
    //<
    htmlPosition:"afterBegin",

    //> @attr canvas.matchElement (boolean : null : [IRWA])
    // If +link{canvas.htmlElement} is specified, should this canvas initially be drawn
    // at the same dimensions as the htmlElement?<br>
    // Note: setting this property will not force the canvas to resize if the element
    // subsequently resizes (for example due to page reflow).
    // @visibility external
    //<

    // Positioning
    // --------------------------------------------------------------------------------------------

    //> @attr   canvas.position     (Positioning : null : IRWA)
    // Absolute or relative, corresponding to the "absolute" (with respect to parent) or
    // "relative" (with respect to document flow) values for the CSS position attribute.
    // <P>
    // Setting <code>position:"relative"</code> enables SmartClient components to be embedded
    // directly into the native HTML flow of a page, causing the component to be rendered
    // within an existing DOM structure.
    // This attribute should only be set to <code>"relative"</code> on a top level component
    // (a component with no +link{canvas.getParentCanvas()}).
    // <P>
    // There are 2 ways to embed relatively positioned canvases in the DOM - by default the
    // component will be written out inline when it gets +link{canvas.draw(),drawn()n}. For example
    // to embed a canvas in an HTML table you could use this code:
    // <pre>
    // &lt;table&gt;
    //   &lt;tr&gt;
    //     &lt;td&gt;
    //       &lt;script&gt;
    //         isc.Canvas.create({autoDraw:true, backgroundColor:"red", position:"relative"});
    //       &lt;/script&gt;
    //     &lt;td&gt;
    //   &lt;/tr&gt;
    // &lt;/table&gt;
    // </pre>
    // Alternatively you can make use of the +link{canvas.htmlElement} attribute.
    // <P>
    // Relative positioning is intended as a short-term integration scenario while incrementally
    // upgrading existing applications.
    // Note that relative positioning is not used to manage layout within SmartClient components -
    // instead the +link{class:Layout} class would typically be used.
    // For best consistency and flexibility across browsers, all SmartClient layout managers
    // use absolute positioning.
    // <P>
    // For canvases with a specified +link{canvas.htmlElement}, this attribute defaults to
    // <code>"relative"</code>. In all other cases the default value will be
    // <code>"absolute"</code>.
    //
    // @visibility external
    // @group positioning
    // @example inlineComponents
    //<
    position:null,

    //> @attr canvas.left (Number or String : 0 : IRW)
    // Number of pixels the left side of the widget is offset to the right from its default
    // drawing context (either its parent's topleft corner, or the document flow, depending on
    // the value of the +link{position} property).
    // <P>
    // Can also be set as a percentage, specified as a String ending in '%', eg, "50%".  In
    // this case the top coordinate is considered as a percentage of the specified width of
    // the +link{canvas.getParentCanvas(),parent}.
    //
    // @visibility external
    // @group  positioning
    //<
    left:0,

    //> @attr canvas.top (Number or String : 0 : IRW)
    // Number of pixels the top of the widget is offset down from its default drawing context
    // (either its parent's top-left corner, or the document flow, depending on the value of
    // the +link{position} property).
    // <P>
    // Can also be set as a percentage, specified as a String ending in '%', eg, "50%".  In
    // this case the top coordinate is considered as a percentage of the specified height of
    // the +link{canvas.getParentCanvas(),parent}.
    //
    // @visibility external
    // @group  positioning
    //<
    top:0,

    //> @attr canvas.leavePageSpace (Integer : null : IRWA)
    // If set, overrides the global +link{Canvas.defaultPageSpace}.
    //
    // @group positioning
    // @visibility external
    //<
    //leavePageSpace: null,

    // Sizing
    // --------------------------------------------------------------------------------------------

    // Notes on width/height vs defaultWidth/defaultHeight:
    //
    // Layouts will resize widgets that don't have their height/width explicitly set.
    // Important to use defaultHeight/defaultWidth to set defaults for a widget, otherwise the
    // defaults will be taken to be the "fixed" size of the widget, and its size will not be
    // managed by layouts
    // In some cases, we WANT certain dimensions to be regarded as fixed by a Layout (they may
    // still be overridden by the user) so we set the height/width properties

    //> @attr   canvas.width        (Number or String : null : [IRW])
    // Size for this component's horizontal dimension.
    // <P>
    // Can be a number of pixels, or a percentage like "50%". Percentage sizes are resolved to
    // pixel values as follows:
    // <UL>
    // <LI>If a canvas has a specified +link{canvas.percentSource,percentSource}, sizing will be
    //     a percentage of the size of that widget (see also +link{canvas.percentBox}).</LI>
    // <LI>Otherwise, if a canvas has a +link{canvas.getMasterCanvas(),master canvas}, and
    //     +link{Canvas.snapTo,snapTo} is set for the widget, sizing will be a percentage of
    //     the size of that widget (see also +link{canvas.percentBox}).</LI>
    // <LI>Otherwise if this is a child of some other canvas, percentages will be based on the
    //     inner size of the +link{canvas.getParentCanvas(),parent canvas}'s viewport.</LI>
    // <LI>Otherwise, for top level widgets, sizing is calculated as a percentage of page size.</LI>
    // </UL>
    // <P>
    // +link{Layout,Layouts} may specially interpret percentage sizes on their children,
    // and also allow "*" as a size.
    // <P>
    // Note that if +link{Canvas.overflow,overflow} is set to "visible", this size is a
    // minimum, and the component may overflow to show all content and/or children.
    // <P>
    // If trying to establish a default width for a custom component, set
    // +link{Canvas.defaultWidth,defaultWidth} instead.
    //
    //  @visibility external
    //  @group  sizing
    //  @setter setWidth
    //  @getter getWidth
    //<

    //> @attr   canvas.height       (Number or String : null : [IRW])
    // Size for this component's vertical dimension.
    // <P>
    // Can be a number of pixels, or a percentage like "50%". See documentation for
    // +link{canvas.width} for details on how percentage values are resolved actual size.
    // <P>
    // Note that if +link{Canvas.overflow,overflow} is set to "visible", this size is a
    // minimum, and the component may overflow to show all content and/or children.
    // <P>
    // If trying to establish a default height for a custom component, set
    // +link{Canvas.defaultHeight,defaultHeight} instead.
    //
    //  @visibility external
    //  @group  sizing
    //  @setter setHeight
    //  @getter getHeight
    //<


    //> @attr canvas.defaultWidth (int : 100 : IRWA)
    // For custom components, establishes a default width for the component.
    // <P>
    // For a component that should potentially be sized automatically by a Layout, set this
    // property rather than +link{width} directly, because Layouts regard a width setting as
    // an explicit size that shouldn't be changed.
    //
    //  @visibility external
    //  @group  sizing
    //<
    defaultWidth:100,

    //> @attr canvas.defaultHeight (int : 100 : IRWA)
    // For custom components, establishes a default height for the component.
    // <P>
    // For a component that should potentially be sized automatically by a Layout, set this
    // property rather than +link{height} directly, because Layouts regard a height setting as
    // an explicit size that shouldn't be changed.
    //
    // @group sizing
    // @visibility external
    //<
    defaultHeight:100,

    //> @attr canvas.minWidth (number : null : IRWA)
    // Minimum width available to this Canvas.
    // <P>
    // The <code>minWidth</code> and +link{minHeight} settings apply to:
    // <ul>
    // <li> determining size within a +link{Layout}
    // <li> determining size for a Canvas in a +link{CanvasItem} (<code>minHeight</code> only)
    // <li> end user +link{canDragResize,drag resizing}
    // <li> minimum size when using +link{overflow} "visible" outside of a Layout - minimum
    //      size will be the greater of this setting or the minimum size needed to make all
    //      content visible
    // </ul>
    // <p>
    // Minimum sizes do not apply in various other circumstances where sizes are being
    // determined, such as +link{listGrid.showRecordComponents,ListGrid recordComponents}.
    // <p>
    // See also +link{layout.minMemberLength} as a way of establishing minimum sizes along
    // the length axis for all members of a +link{Layout} with a single setting.
    //
    // @group sizing
    // @see canvas.dragMinWidth
    // @visibility external
    //<
    minWidth: null,

    //> @attr canvas.minHeight (number : null : IRWA)
    // Minimum height available to this Canvas.  See +link{minWidth} for details of behavior.
    //
    // @group sizing
    // @see canvas.dragMinHeight
    // @visibility external
    //<
    minHeight: null,

    //> @attr canvas.maxWidth (number : 10000 : IRWA)
    // Maximum width available to this Canvas.
    // <p>
    // The <code>maxWidth</code> and +link{maxHeight} settings apply to:
    // <ul>
    // <li> determining size within a +link{Layout}
    // <li> determining size for a Canvas in a +link{CanvasItem} (<code>maxHeight</code> only)
    // <li> end user +link{canDragResize,drag resizing}
    // </ul>
    // Maximum sizes do not apply in various other circumstances where sizes are being
    // determined, such as +link{listGrid.showRecordComponents,ListGrid recordComponents}.
    //
    // @group sizing
    // @see canvas.dragMaxWidth
    // @visibility external
    //<
    maxWidth:10000,

    //> @attr canvas.maxHeight (number : 10000 : IRWA)
    // Maximum height available to this Canvas.  See +link{maxWidth} for details of behavior.
    //
    // @group sizing
    // @see canvas.dragMaxHeight
    // @visibility external
    //<
    maxHeight:10000,


    //> @attr canvas.dragMinWidth (number : 10 : IRWA)
    // Minimum width that this Canvas can be resized to by a user.  Actual limit will be maximum
    // of <code>dragMinWidth</code> and +link{minWidth}.
    // <P>
    // Note that a Canvas with overflow:"visible" has an implicit minimize size based on it's
    // contents.
    // <p>
    // Note that <code>dragMinWidth</code> affects only user-initiated drag resizes.  To set
    // the minimum width of a Canvas embedded in a Layout, you can set +{minWidth}, or
    // +link{layout.minMemberLength} to constrain the minimum size along the length axis of all
    // members of the +link{Layout}.
    //
    // @group sizing
    // @visibility external
    //<
    dragMinWidth:10,

    //> @attr canvas.dragMinHeight (number : 10 : IRWA)
    // Minimum height that this Canvas can be resized to by a user.  See +link{dragMinWidth}
    // for details of behavior.
    //
    // @group sizing
    // @see canvas.minHeight
    // @visibility external
    //<
    dragMinHeight:10,

    //> @attr canvas.dragMaxWidth (number : 10000 : IRWA)
    // Maximum width that this Canvas can be resized to by a user.  Actual limit will be minimum
    // of <code>dragMaxWidth</code> and +link{maxWidth}.
    //
    // @group sizing
    // @visibility external
    //<
    dragMaxWidth:10000,

    //> @attr canvas.dragMaxHeight (number : 10000 : IRWA)
    // Sets maximum height that this Canvas can be resized to by a user.  Actual limit will be
    // minimum of <code>dragMaxHeight</code> and +link{maxHeight}.
    //
    // @group sizing
    // @visibility external
    //<
    dragMaxHeight:10000,


    // --------------------------------------------------------------------------------------------

    //> @attr   canvas.allowNativeContentPositioning    (boolean : false : IRW)
    //  Allow HTML content which includes native elements that use relative or absolute positioning.
    //<


    //> @attr   canvas.zIndex       (number : Canvas.AUTO | Canvas.AUTO : IRWA)
    //
    // Stacking order of this Canvas with respect to other content and components on the page.
    //
    // The default zIndex of "auto" means that a zIndex will be decided at draw time,
    // so that if many Canvii are draw with zIndex "auto", the last Canvas drawn is on top.
    // <p>
    // If you want native HTML content to appear in front of this canvas, set zIndex to zero.
    //
    // @group   zIndex
    // @value   (number)
    // @value   Canvas.AUTO
    //<
    zIndex:isc.Canvas.AUTO,

    //> @attr canvas.shrinkElementOnHide (boolean : false : IRWA)
    // This is an advanced setting. If set to <code>true</code>, when a widget is
    // +link{canvas.hide(),hidden}, the widget's handle will be resized such that
    // it takes up no space, in addition to having its css <code>visibility</code>
    // property set to <code>"hidden"</code>.
    // <P>
    // In addition to preventing the size of this widget from impacting the
    // +link{canvas.getScrollWidth,scroll size} of any parent widget while hidden, this
    // setting works around a native bug observed in Internet Explorer 10, whereby
    // an <code>&lt;IFRAME&gt;</code> element with visibility set to hidden can
    // cause rendering problems, if the HTML loaded by the <code>&lt;IFRAME&gt;</code>
    // contains a <code>&lt;frameset&gt;</code>. In this case the browser may
    // refuse to draw other elements at the same coordinates with a lower z-index than
    // the hidden frame. Setting this property to <code>true</code> works around
    // this problem for cases where an <code>&lt;IFRAME&gt;</code> containing a
    // <code>&lt;frameset</code> will be rendered out, for example in an
    // +link{HTMLFlow} with <code>contentsType</code> set to <code>"page"</code>.
    //
    // @group visibility
    // @visibility external
    //<
    shrinkElementOnHide: false,

    //> @attr   canvas.autoShowParent       (Boolean : false : IRWA)
    //      If set to true, the widget's parent (if any) will automatically be shown whenever the
    //      widget is shown.
    //  @visibility external
    //  @group appearance
    //<
    autoShowParent:false,

    //> @attr   canvas.visibility       (Visibility : isc.Canvas.INHERIT : IRW)
    //      Controls widget visibility when the widget is initialized. See Visibility type for
    //      details.
    //  @getter isVisible
    //  @setter show, hide
    //  @visibility external
    //  @group appearance
    //<
    visibility:isc.Canvas.INHERIT,

    //> @attr canvas.hideUsingDisplayNone (boolean : false : IRA)
    // When this widget is hidden (see +link{Canvas.visibility} and +link{Canvas.hide()}),
    // should display:none be applied to the +link{Canvas.getOuterElement(),outer element}?
    // <p>
    // This setting is not supported for general use, but in certain cases, it has been shown
    // that display:none is a work-around for browser bugs involving burn-through of iframes or
    // plugins, where the content of the iframe or plugin may still be visible despite the
    // containing widget being hidden.
    // @group appearance
    // @visibility external
    //<

    hideUsingDisplayNone: false,

    // A widget is hidden via CSS display:none iff this.hideUsingDisplayNone is explicitly set
    // or this counter value is greater than 0.
    _hideUsingDisplayNoneCounter: 0,

    //> @attr canvas.canSelectText      (Boolean : false : IRWA)
    // Whether native drag selection of contained text is allowed within this Canvas.
    // <P>
    // Note that setting this property to <code>false</code> will not avoid text selection
    // which is initiated outside this Canvas from continuing into this Canvas, even if text
    // selection began in another Canvas.
    //
    //      @group  events
    // @visibility external
    //<

    //> @type CSSStyleName
    // CSS class name to apply to some HTML element on this page. This is a string that should
    // match the css class defined for the page in an external stylesheet or in inline
    // html &lt;STYLE&gt; tags.
    // <P>
    // As a general rule, wherever it is possible to provide a CSS styleName (such as
    // +link{Canvas.styleName} or +link{Button.baseStyle}, your CSS style can specify border,
    // margins, padding, and any CSS attributes controlling background or text styling.  You
    // should not specify any CSS properties related to positioning, clipping, sizing or
    // visibility (such as "overflow", "position", "display", "visibility" and "float") - use
    // SmartClient APIs for this kind of control.
    // <P>
    // Because text wrapping cannot be consistently controlled cross-browser from CSS alone,
    // you should use SmartClient properties such as +link{Button.wrap} instead of the
    // corresponding CSS properties, when provided.
    // <P>
    // Content contained within SmartClient components can use arbitrary CSS, with the
    // caveat that the content should be tested on all supported browsers, just as content
    // outside of SmartClient must be.
    // <P>
    // <b>Special note on CSS margins</b>: wherever possible, use CSS padding and border in
    // lieu of CSS margins, or non-CSS approaches such as +link{Layout.layoutMargin},
    // +link{Canvas.snapTo}, or absolute positioning (including specifying percentage left/top
    // coordinates).  We recommend this because CSS specifies a very complicated and widely
    // criticized "margin-collapse" behavior which has surprising effects when margins exist on
    // both parents and children.  Compounding the problem, margins are implemented very
    // differently on different browsers, especially when it comes to HTML margins.
    // <p>
    // <b>Note about CSS "box models"</b>
    // <p>
    // The CSS "box model" defines whether the size applied to a DOM element includes padding,
    // borders or margins, or whether such settings effectively <b>increase</b> the size of the
    // component beyond the size specified in CSS.
    // <p>
    // In SmartClient, the size configured for a component <i>includes</i> border, padding and
    // margins if specified (in CSS terminology, the box model is "margin-box").  This allows
    // CSS borders, margins and padding to be treated as purely visual properties with no
    // effect on sizing or layout.
    //
    // @group appearance
    // @visibility external
    // @example consistentSizing
    //<

    //> @type CSSColor
    // CSS color specification applied to a specific HTML element on this page.
    // <P>
    // This is a string matching the syntax as specified in CSS1, and can be
    // formatted in one of the following ways:
    // <ul>
    // <li>A keyword color, &ldquo;white&rdquo;</li>
    // <li>Six-digit hex notation, &ldquo;#ffffff&rdquo;</li>
    // <li>Three-digit hex notation, &ldquo;#fff&rdquo;</li>
    // <li>8-bit decimal notation, &ldquo;rgb(255, 255, 255)&rdquo;</li>
    // <li>Percentage notation, &ldquo;rgb(100%, 100%, 100%)&rdquo;</li>
    // </ul>
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr canvas.className      (CSSStyleName : "normal" : [IRW])
    // The CSS class applied to this widget as a whole.
    // @group appearance
    // @visibility external
    // @deprecated In favor or +link{canvas.styleName} as of SmartClient release 5.5
    //<

    //> @attr canvas.styleName    (CSSStyleName : "normal" : [IRW])
    // The CSS class applied to this widget as a whole.
    // @group appearance
    // @setter setStyleName()
    // @visibility external
    // @example styles
    //<
    styleName:"normal",

    //> @attr   canvas.textDirection    (TextDirection : null : IRW)
    //          Use this to specify a text direction for the canvas:
    //                  Canvas.LTR (left to right, eg English)
    //                  Canvas.RTL (right to left, eg Arabic)
    //          Leave as null to pick up the text direction automatically
    //           from that set at the Page level, set to one of the above to override.
    //      @group  textDirection
    //      @platformNotes  IE only.
    //<

    //> @attr canvas.eventProxy     (canvas object : null : IRWA)
    // Set to another canvas to have that process events for us.
    // Useful for event processing of peers (borders, decorators, etc.)
    // @group events
    //<

    //> @attr canvas.cssPointerEvents (String : null : IRA)
    // In browsers that support the CSS <code>pointer-events</code> property applied to HTML
    // elements, <code>cssPointerEvents</code> corresponds to the value of the <code>pointer-events</code>
    // property applied to this component's handle element.
    // <p>
    // Note that unlike CSS <code>pointer-events</code>, which is inherited, if <code>cssPointerEvents</code>
    // is unset, then the default <code>pointer-events:auto</code> will be applied to the
    // handle element.
    //<
    //cssPointerEvents: null,

    //> @type HTMLString
    // A String of HTML, such as "<span class='somestyle'>text</span>".
    // <P>
    // In many contexts, such as +link{button.title} and +link{ListGrid.formatCellValue()}, an
    // HTML String can be specified, allowing you to use normal HTML tags and CSS to do
    // formatting or styling.
    // <P>
    // However, bear in mind that if you attempt any kind of layout or advanced styling in such
    // an HTML string, different browsers may render the HTML differently - use SmartClient
    // +link{Layout,layout} and +link{canvas.styleName,styling} features wherever possible to
    // avoid this.  See also +link{type:CSSStyleName}.
    //
    // @visibility external
    //<

    //> @type CSSText
    // A String of CSS that can be added directly to a <code>style</code> attribute.
    // @visibility external
    //<

    //> @attr canvas.contents       (HTMLString : "&nbsp;" : IRWA)
    // The contents of a canvas or label widget. Any HTML string is acceptable.
    //
    // @see dynamicContents
    // @group contents
    // @visibility external
    //<
    contents:isc.nbsp,

    //> @attr canvas.dynamicContents (Boolean : false : IRWA)
    //
    // Dynamic contents allows the contents string to be treated as a simple, but powerful
    // template.  When this attribute is set to true, expressions of the form &#36;{arbitrary JS
    // here} are replaced by the result of the evaluation of the JS code inside the curly
    // brackets.  This evaluation happens at draw time.  If you want to trigger a re-evaluation
    // of the expressions in the contents string you can call markForRedraw() on the canvas.
    // <p>
    // You can use this feature to build some simple custom components. For example, let's say
    // you want to show the value of a Slider in a Canvas somewhere on the screen.  You can do
    // this by observing the valueChanged() method on the slider and calling setContents() on
    // your canvas with the new string or you can set the contents of the canvas to something
    // like:
    // <p><code>
    // "The slider value is &#36;{sliderInstance.getValue()}."
    // </code><p>
    // Next you set dynamicContents: true on the canvas, observe valueChanged() on the slider
    // and call canvas.markForRedraw() in that observation.  This approach is cleaner than
    // setContents() when the Canvas is aggregating several values or dynamic expressions.
    // Like so:
    // <p>
    // <pre>
    // Slider.create({
    //     ID: "mySlider"
    // });
    //
    // Canvas.create({
    //     ID: "myCanvas",
    //     dynamicContents: true,
    //     contents: "The slider value is &#36;{mySlider.getValue()}."
    // });
    //
    // myCanvas.observe(mySlider, "valueChanged",
    //                  "observer.markForRedraw()");
    // </pre>
    // You can embed an arbitrary number of dynamic expressions in the contents string.  The
    // search and replace is optimized for speed.
    // <p>
    // If an error occurs during the evaluation of one of the expressions, a warning is logged
    // to the ISC Developer Console and the error string is embedded in place of the expected
    // value in the Canvas.
    // <p>
    // The value of a function is its return value.  The value of any variable is the same as
    // that returned by its toString() representation.
    // <p>
    // Inside the evaluation contentext, <code>this</code> points to the canvas instance that
    // has the dynamicContents string as its contents - in other words the canvas instance on
    // which the template is declared.
    //
    // @see contents
    // @see canvas.dynamicContentsVars
    // @example dynamicContents
    // @group contents
    // @visibility external
    //<

    //> @attr canvas.dynamicContentsVars (ValueMap : null : IRWA)
    //
    // An optional map of name:value parameters that will be available within the scope of the
    // dynamicContents evaluation.  For example - if you have e.g:
    // <pre>
    // Canvas.create({
    //   dynamicContents: true,
    //   dynamicContentsVars: {
    //       name: "Bob"
    //   },
    //   contents: "hello &#36;{name}"
    // });
    // </pre>
    // The above will create a canvas with contents <code>hello Bob</code>.  You can add, remove, and
    // change values in the dynamicContentsVars object literal, just call
    // <code>markForRedraw()</code> on the canvas to have the dynamicContents template re-evaluated.
    // <p>
    // Note that <code>this</code> is always available inside a dynamic contents string and points to
    // the canvas instance containing the dynamic contents.
    // <p>
    // Used only if +link{attr:Canvas.dynamicContents} : true has been set.
    //
    // @see dynamicContents
    // @visibility external
    //<



    // Per-Canvas CSS overrides.
    // --------------------------------------------------------------------------------------------
    // Consider defining a style for the individual Canvas instead of using these overrides, since
    // this makes that Canvas skinnable from CSS.

    //> @attr canvas.margin (number : null : IRW)
    // Set the CSS Margin, in pixels, for this component.  Margin provides blank space outside
    // of the border.
    // <P>
    // This property sets the same thickness of margin on every side.  Differing per-side
    // margins can be set in a CSS style and applied via +link{styleName}.
    // <P>
    // Note that the specified size of the widget will be the size <b>including</b> the margin
    // thickness on each side.
    //
    // @visibility external
    // @group appearance
    //<

    //> @attr canvas.padding (number : null : IRW)
    // Set the CSS padding of this component, in pixels.  Padding provides space between the
    // border and the component's contents.
    // <P>
    // This property sets the same thickness of padding on every side.  Differing per-side
    // padding can be set in a CSS style and applied via +link{styleName}.
    // <P>
    // Note that CSS padding does not affect the placement of +link{canvas.children}.  To
    // provide a blank area around children, either use +link{canvas.margin,CSS margins} or use
    // a +link{Layout} as the parent instead, and use properties such as
    // +link{layout.layoutMargin} to create blank space.
    //
    // @visibility external
    // @group appearance
    //<

    //> @attr canvas.border (string : null : IRW)
    // Set the CSS border of this component, as a CSS string including border-width,
    // border-style, and/or color (eg "2px solid blue").
    // <P>
    // This property applies the same border to all four sides of this component.  Different
    // per-side borders can be set in a CSS style and applied via +link{styleName}.
    // <p>
    // If +link{canvas.isGroup} is set to true then border is derived from the
    // +link{canvas.groupBorderCSS} attribute, not from the explicit border property.
    //
    // @visibility external
    // @group appearance
    //<

    //> @attr canvas.backgroundColor (CSSColor : null : IRW)
    // The background color for this widget. It corresponds to the CSS background-color
    // attribute. You can set this property to an RGB value (e.g. #22AAFF) or a named color
    // (e.g. red) from a list of browser supported color names.
    //
    // @visibility external
    // @group appearance
    //<

    //> @attr canvas.backgroundImage (SCImgURL : null : IRW)
    // URL for a background image for this widget (corresponding to the CSS "background-image"
    // attribute).
    // @visibility external
    // @group appearance
    //<

    //> @attr canvas.backgroundRepeat (BackgroundRepeat : null : IR)
    // Specifies how the background image should be tiled if this widget
    // is larger than the image. It corresponds to the CSS <code>background-repeat</code>
    // attribute.
    // <p>
    // The default of null means no <code>background-repeat</code> CSS will be
    // written out.  See +link{BackgroundRepeat} type for details on other settings.
    // <p>
    // NOTE: this setting directly sets the CSS property <code>background-repeat</code> but
    // does not attempt to work around various known bugs with this setting, or lack of support
    // in IE6.  If you need to apply CSS-based workarounds for browser limitations with
    // this setting, it's best to do so via setting +link{canvas.styleName}.
    //
    // @visibility external
    // @group appearance
    //<
    backgroundRepeat:isc.Canvas.REPEAT,

    //> @attr   canvas.backgroundPosition       (string : null : IR)
    //      Specifies how the background image should be positioned on the widget.
    //      It corresponds to the CSS background-position attribute. If unset,
    //      no background-position attribute is specified if a background image is
    //      specified.
    // @visibility external
    // @group appearance
    //<

    //> @attr   canvas.mozOutlineOffset (string : "-1px": [IRA])
    // Only applies to Moz Firefox 1.5 and above.
    // When this widget receives focus, how far should the dotted focus outline appear from
    // the edge of the canvas. A negative value will render the dotted outline inside the
    // canvas
    // @visibility internal
    //<
    mozOutlineOffset:"-1px",

    //> @attr   canvas.mozOutlineColor (string : null : [IRA])
    // Only applies to Moz Firefox 1.5 and above.
    // When this widget receives focus, what color should the dotted focus outline appear.
    // Unspecified by default - gives us the native browser behavior.
    // @visibility internal
    //<
    //mozOutlineColor:null,

    // Skinning
    // --------------------------------------------------------------------------------------------

    //> @attr   canvas.appImgDir        (URL : "" : IRWA)
    // Default directory for app-specific images, relative to the Page-wide
    // +link{Page.getAppImgDir(),appImgDir}.
    // @group images
    // @visibility external
    //<
    appImgDir:"",

    //> @attr   canvas.skinImgDir       (URL : "images/" : IRWA)
    // Default directory for skin images (those defined by the class), relative to the
    // Page-wide +link{Page.getSkinDir(),skinDir}.
    // @group images
    // @visibility external
    //<
    skinImgDir:"images/",

    // --------------------------------------------------------------------------------------------

    //> @attr   canvas.cursor       (Cursor : Canvas.DEFAULT : IRWA)
    //      Specifies the cursor image to display when the mouse pointer is
    //      over this widget. It corresponds to the CSS cursor attribute. See Cursor type for
    //      different cursors.
    //      <P>
    //      See also +link{canvas.disabledCursor} and +link{canvas.noDropCursor}.
    //  @visibility external
    //  @group  cues
    //  @example dragCreate
    //  @example cursors
    //<
    cursor:isc.Canvas.DEFAULT,

    //> @attr   canvas.disabledCursor       (Cursor : Canvas.DEFAULT : IRWA)
    //      Specifies the cursor image to display when the mouse pointer is
    //      over this widget if this widget is disabled. It corresponds to the CSS cursor
    //      attribute. See Cursor type for different cursors.
    //  @visibility external
    //  @group  cues
    //<
    disabledCursor:isc.Canvas.DEFAULT,

    //> @attr   canvas.noDropCursor       (Cursor : Canvas.NOT_ALLOWED : IRWA)
    //      Specifies the cursor image to display when the user drags a droppable canvas
    //      over this if it is not a valid drop target for the event and
    //      +link{EventHandler.showNoDropIndicator} is true.
    // @visibility external
    //  @group  cues
    //<

    noDropCursor:isc.Canvas.NOT_ALLOWED,

    //> @attr   canvas.opacity      (number : null : IRWA)
    //      Renders the widget to be partly transparent. A widget's opacity property may
    //      be set to any number between 0 (transparent) to 100 (opaque).
    //      Null means don't specify opacity directly, 100 is fully opaque.
    //      Note that heavy use of opacity may have a performance impact on some older
    //      browsers.
    //      <P>
    //      In older versions of Internet Explorer (Pre IE9 / HTML5), opacity is achieved
    //      through proprietary filters. If
    //      +link{canvas.neverUseFilters,filters have been disabled} within this application
    //      developers must set +link{canvas.useOpacityFilter} to true for specific components
    //      on which opacity support is required.
    //      <P>
    //      Also note that opacity is incompatible
    //      with +link{canvas.useBackMask,backMasks}.
    //
    //  @visibility external
    //  @setter setOpacity()
    //  @group  cues
    //<


    //> @attr canvas.smoothFade (boolean : null : [IRWA])
    // Avoids a visible flash (native browser repaint) for canvases when setting opacity
    // to / from 100% in  Mozilla browsers.
    // @visibility internal
    //<



    //>Moz
    _useMozOpacity : (isc.Browser.isMoz && isc.Browser.geckoVersion < 20081201),
    //<Moz

    //> @attr   canvas.overflow     (Overflow : Canvas.VISIBLE : [IRW])
    //          Controls what happens when the drawn size of the content of a Canvas is either
    //          greater or smaller than the specified size of the Canvas.  Similar to the CSS
    //          property overflow, but consistent across browsers.  See Overflow type for
    //          details.
    //  @visibility external
    //  @setter setOverflow()
    //  @group  sizing
    //<
    overflow:isc.Canvas.VISIBLE,



    //--------------------------------------------------------------------------------
    // *** ADAPTIVE LAYOUT ***

    //> @attr canvas.canAdaptWidth (Boolean : null : IRW)
    // Indicates that this component is able to render itself at multiple possible sizes, in order
    // to fit into less space when very little space is available, or to display more information
    // or provide more immediate access to functionality when more space is available.
    // <p>
    // Unlike simply indicating a flexible size via width:"*", setting <code>canAdaptWidth</code>
    // indicates that a component has 2 (or more) different ways of rendering itself with different
    // <i>discrete</i> sizes, but does not have the ability to use every additional available pixel.
    // <p>
    // For example, a menu embedded in a toolbar might show as only a fixed-size icon which reveals
    // menu options when clicked, or if enough space is available, could show all of the menu
    // options directly in the toolbar.  In this example, the menu should either be allocated just
    // enough space for an icon, or enough space for <i>all</i> options to appear inline; any other
    // amount of space being allocated is just a waste.
    // <p>
    // When a component with <code>canAdaptWidth</code> is part of a Layout, +link{adaptWidthBy()}
    // will be called every time component sizes are being calculated, passing a positive or
    // negative pixel value:
    // <ul>
    // <li> a <i>positive</i> pixel value indicates a surplus - all other component's minimum sizes
    //      can be accommodated, including any +link{minWidth} declared on the
    //      <code>canAdaptWidth</code> component itself
    // <li> a <i>negative</i> pixel value indicates that the containing layout is going to be
    //      forced to +link{overflow} (introduce scrollbars, clip content, etc) unless some
    //      component or set of components gives up at least this many pixels
    // </ul>
    // <p>
    // If a non-zero value is returned from <code>adaptWidthBy</code>, this means that the
    // component is willing to shrink or expand by that many pixels.  Returning 0 means that the
    // component is unable to reduce size further, or for a surplus, cannot make good use of the
    // surplus space.
    // <p><ul>
    // <li>A call to +link{adaptWidthBy()} may surrender as many pixels as desired
    // (as long as the widget won't drop below its minimum allowed width), no matter whether a
    // positive (surplus) or negative (overflow) pixel value is supplied, but
    // <li>A call to +link{adaptWidthBy()} may not increase its size by more than the number of
    // offered pixels - so if an overflow is present, it may not increase its size at all.
    // </ul>
    // <p>
    // Caution: you must either determine the current size of the canvas by maintaining your own
    // internal state, or use the <code>unadaptedWidth</code> parameter passed to
    // +link{adaptWidthBy()}.  You must not call +link{getWidth()} or +link{getVisibleWidth()}
    // on the canvas itself inside +link{adaptWidthBy()} as the size is in the processing of
    // being determined, but you may draw children or call +link{getVisibleWidth()} on them, as
    // we guarantee that the adaptive-width canvas is drawn before the first call to
    // +link{adaptWidthBy()}.  An example of drawing children in +link{adaptWidthBy()} to
    // compute overall width may be seen in the
    // +explorerExample{inlinedMenuMobileSample, Inlined Menu Mobile Sample}.
    // <p>
    // Note that reasonable settings for +link{minWidth} should be applied to all other
    // flexible-sized members of a layout where a <code>canAdaptWidth</code> component appears,
    // because when too little space is available, a <code>canAdaptWidth</code> component will
    // absorb all available space until minimums for other components are hit (or the
    // <code>canAdaptWidth</code> component reaches its maximum size).  If more than one
    // <code>canAdaptWidth</code> component is present, +link{adaptiveWidthPriority} to give priority
    // to a particular component when allocating space.
    // <p>
    // All of the above behaviors are exactly the same for height, using
    // +link{canvas.canAdaptHeight} and +link{canvas.adaptHeightBy()}.
    //
    // @see canAdaptHeight
    // @see adaptWidthBy
    // @see adaptHeightBy
    // @visibility external
    // @example inlinedMenuMobileSample
    //<



    //> @attr canvas.canAdaptHeight (Boolean : null : IRW)
    // See +link{canvas.canAdaptWidth}.
    // @visibility external
    //<

    //> @method canvas.adaptWidthBy()
    // See +link{canAdaptWidth}.
    // @param pixelDifference (integer) surplus (if positive) or overflow (if negative)
    // @param unadaptedWidth (integer) width of member currently assumed by parent layout
    // @return sizeDelta (integer)
    // @visibility external
    //<

    //> @method canvas.adaptHeightBy()
    // See +link{canAdaptWidth}.
    // @param pixelDifference (integer) surplus (if positive) or overflow (if negative)
    // @param unadaptedHeight (integer) height of member currently assumed by parent layout
    // @return sizeDelta (integer)
    // @visibility external
    //<

    //> @attr canvas.adaptiveWidthPriority (integer : null : IR)
    // If multiple widgets in the same Layout have +link{canAdaptWidth,adaptive width},
    // <code>adaptiveWidthPriority</code> can be set to indicate which of the components should be
    // given priority access to space.
    // <p>
    // The widget with the highest priority setting will be offered surplus space first, and asked
    // to give up space last.  Lack of a priority setting is treated as zero.  Any adaptive widgets
    // with the same priority setting will be asked to give up or release space according to their
    // order in +link{layout.members}.
    //
    // @see canAdaptWidth
    // @visibility external
    //<

    //> @attr canvas.adaptiveHeightPriority (integer : null : IR)
    // See +link{canvas.adaptiveWidthPriority}.
    // @visibility external
    //<

    //> @attr canvas.allowAdaptSizeBeforeDraw (boolean : false: IR)
    // For a canvas configured as +link{canAdaptWidth}/+link{canAdaptHeight}: true, setting this
    // property indicates that you don't need it drawn, and thus the "visible sizes" of its
    // children available, before the first call to +link{adaptWidthBy}/+link{adaptHeightBy}.
    // For an adaptive-width canvas with a static set of fixed sizes, measuring the children is
    // not necessary, and this setting offers increased performance over the default.
    //
    // @see canAdaptWidth
    // @see canAdaptHeight
    // @see adaptWidthBy
    // @see adaptHeightBy
    //<

    // *** END ADAPTIVE LAYOUT ***
    //--------------------------------------------------------------------------------

    //> @attr canvas.alwaysShowVScrollbar (boolean : false : [IRWA])
    // If this canvas has <code>overflow</code> set to <code>"auto"</code>, and is showing
    // custom scrollbars, settting this property to true will ensure that a custom vertical
    // scrollbar is shown even if the scrollHeight of the widget is less than the specified
    // height
    //  @visibility internal
    //  @group  sizing
    //<

    alwaysShowVScrollbar:false,

    //> @attr canvas.forceHandleOverflowHidden (boolean : ? : [IR])
    // Controls whether the handle's CSS overflow value is forced to "hidden" even
    // if the value of canvas.overflow would normally set it to a different value.
    // Only applies to IE Browsers; set automatically in certain certain situations.
    //  @visibility internal
    //  @group  sizing
    //<
    forceHandleOverflowHidden: false,

    // Scrolling
    // --------------------------------------------------------------------------------------------



    //> @attr canvas.showCustomScrollbars (boolean : true : IRA)
    // Whether to use the browser's native scrollbars or SmartClient-based scrollbars.
    // <P>
    // SmartClient-based scrollbars are skinnable, giving you complete control over look and
    // feel.  SmartClient-based scrollbars also enable some interactions not possible with
    // native scrollbars, such as +link{ListGrid.fixedRecordHeights,variable height records}
    // in grids in combination with +link{listGrid.dataPageSize,data paging}.
    // <P>
    // Native browser scrollbars are slightly faster simply because there are less SmartClient
    // components that need to be created, drawn and updated.  Each visible SmartClient-based
    // scrollbar on the screen has roughly the impact of two StretchImgButtons.
    // <P>
    // SmartClient is always aware of the size of the scrollbar, regardless of whether native
    // or custom scrollbars are used, and regardless of what operating system and/or operating
    // system "theme" or "skin" is in use.  This means SmartClient will correctly report the
    // +link{canvas.getViewportHeight(),viewport size}, that is, the interior area of the
    // widget excluding space taken by scrollbars, which is key for exactly filling a component
    // with content without creating unnecessary scrolling.
    // <P>
    // The <code>showCustomScrollbars</code> setting is typically overridden in load_skin.js in
    // order to change the default for all SmartClient components at once.
    // This may be achieved via the static +link{Canvas.setShowCustomScrollbars()} method or
    // via a simple addProperties block, like so:
    // <pre>
    //     isc.Canvas.addProperties({ showCustomScrollbars:false });
    // </pre>
    // <p>
    // On +link{Browser.isTouch,touch devices}, custom scrollbars are disabled in favor of enabling
    // native touch scrolling if available. However, custom scrollbars <em>and</em> native touch
    // scrolling can be enabled for the component by setting +link{Canvas.alwaysShowScrollbars}
    // to <code>true</code>.
    //
    // @group scrolling
    // @visibility external
    //<
    // <P>
    // Note: If +link{Canvas.useNativeTouchScrolling,useNativeTouchScrolling} is <code>true</code> and
    // native touch scrolling is used, then <code>showCustomScrollbars</code> is set to <code>false</code>.
    showCustomScrollbars:true,

    //> @attr canvas.alwaysShowScrollbars (Boolean : null : IRA)
    // On +link{Browser.isTouch,touch devices} that support native touch scrolling, if
    // +link{Canvas.showCustomScrollbars,showCustomScrollbars} is <code>true</code> and touch
    // scrolling has not been disabled by the +link{Canvas.useTouchScrolling} and/or
    // +link{Canvas.disableTouchScrollingForDrag} settings, should custom scrollbars <em>and</em>
    // native touch scrolling be enabled for this component? If <code>false</code> or unset,
    // then only native touch scrolling will be enabled. If <code>true</code>, then both scrolling
    // mechanisms will be enabled.
    // <p>
    // <strong>NOTE:</strong> Because native touch scrolling (also called momentum scrolling)
    // is computationally intensive, some mobile browsers implement an optimization where the state
    // of the DOM for the element being scrolled will be frozen or partially frozen during
    // the scroll animation. This results in a delay between when the scroll position reaches
    // a certain point in the animation and when the positions of the custom scrollbar thumbs
    // are updated to reflect that scroll position.
    // @group scrolling
    // @visibility external
    //<

    //alwaysShowScrollbars: null,

    //> @attr canvas.useTouchScrolling (Boolean : null : IRA)
    // On +link{Browser.isTouch,touch devices}, if this <code>Canvas</code> can be scrolled,
    // should touch-dragging the content area result in scrolling? Set to <code>false</code>
    // if touch-dragging should not cause scrolling. Note that setting to <code>false</code>
    // enables the use of +link{Canvas.showCustomScrollbars,custom scrollbars} on touch devices.
    // <p>
    // <code>useTouchScrolling</code> can default to <code>false</code> if
    // +link{Canvas.disableTouchScrollingForDrag,disableTouchScrollingForDrag} is <code>true</code>
    // and various built-in drag operations are enabled that normally interfere with touch scrolling
    // (e.g. +link{ListGrid.canDragSelect} and +link{ListGrid.canReorderRecords}).
    // <p>
    // When touch scrolling is disabled, it can be difficult to interact with parts of the
    // custom scrollbars at their default size of 16 pixels. In touch browsers, any touch 8px
    // before the thumb of a +link{Scrollbar,custom scrollbar} will be mapped to the thumb, but
    // the other parts of the scrollbar do not have a similar tolerance applied. The width of
    // the custom scrollbars can be increased by setting the +link{Canvas.scrollbarSize} to a
    // larger value, but note that when +link{group:skinning,spriting is enabled}, changing the
    // <code>scrollbarSize</code> may cause tiling of certain images and backgrounds that make
    // up the custom scrollbar. This can be fixed for a component by creating it with
    // +link{Canvas.scrollbarConstructor} set to "Scrollbar"&mdash;a basic scrollbar class that
    // does not employ spriting.
    // @group scrolling
    // @visibility external
    //<
    //useTouchScrolling: null,

    //> @attr canvas.useNativeTouchScrolling (boolean : true : IRA)
    // On touch devices, if +link{Canvas.useTouchScrolling} is not explicitly false, should
    // native touch scrolling be used if available? Note: If native touch scrolling is used,
    // then +link{Canvas.showCustomScrollbars,showCustomScrollbars} is set to <code>false</code>.
    //
    // @group scrolling
    //<

    useNativeTouchScrolling: true,

    //> @attr canvas.disableTouchScrollingForDrag (Boolean : null : IR)
    // Disables +link{useTouchScrolling} whenever a built-in drag operation has been enabled which is
    // known to be non-functional if touch scrolling is enabled.  Default behavior is to leave touch
    // scrolling enabled even if it makes other enabled drag operations non-functional, since any
    // +link{group:accessibility,accessible} application must provide an alternative way to perform
    // drag and drop operations anyway.
    // <p>
    // <code>disableTouchScrollingForDrag</code> exists so that applications can change the default
    // setting on a per-component basis (via
    // <smartclient>+link{Class.changeDefaults}),</smartclient>
    // <smartgwt><code>setDefaultProperties</code>),</smartgwt> in order to make a system-wide or
    // per-component-type decision about whether to favor touch scrolling vs retaining the ability to
    // drag and drop via finger drags, instead of having to set <code>useTouchScrolling</code> on each
    // individual instance.
    // <p>
    // See the +link{group:mobileDevelopment,Mobile Development overview} for more background
    // information.
    // @group scrolling
    // @visibility external
    //<
    //disableTouchScrollingForDrag: null,

    //> @attr   canvas.scrollbarSize        (number : 16 : IRWA)
    // How thick should we make the scrollbars for this canvas. This only applies if
    // +link{Canvas.showCustomScrollbars} is <code>true</code>.
    // <p>
    // <strong>NOTE:</strong> When +link{group:skinning,spriting is enabled}, changing the
    // <code>scrollbarSize</code> may cause tiling of certain images and backgrounds that make
    // up the custom scrollbar. This can be fixed for a component by creating it with
    // +link{Canvas.scrollbarConstructor} set to "Scrollbar"&mdash;a basic scrollbar class
    // that does not employ spriting.
    //      @group  scrolling
    //      @visibility external
    //      @see getScrollbarSize()
    //<
    scrollbarSize:16,

    // NOTE: the following properties only apply when showCustomScrollbars is true

    //> @attr canvas.scrollbarConstructor (String : "Scrollbar" : [IA])
    // The class that will be used to create custom scrollbars for this component. Set this
    // attribute to a Scrollbar subclass with e.g. a different skinImgDir, to customize scrollbar
    // appearance for this component only.
    // <p>
    // When +link{group:skinning,spriting is enabled} and supported by the skin, the default
    // <code>scrollbarConstructor</code> is changed to a different scrollbar class which handles
    // scrollbar spriting. Spriting of the scrollbars of an individual component can therefore
    // be disabled by creating the component with <code>scrollbarConstructor</code> set to the
    // "Scrollbar" class. "Scrollbar" is a basic scrollbar class that does not employ spriting.
    // @group   scrolling
    // @visibility external
    //<
    scrollbarConstructor:"Scrollbar",

    //> @attr   canvas.scrollLeft       (number : 0 : IRWA)
    //          number of pixels that this canvas is shifted leftwards due to scrolling.
    //      @group  scrolling
    //<
    scrollLeft:0,
    _scrollRight:0,

    //> @attr   canvas.scrollTop        (number : 0 : IRWA)
    //          number of pixels that this canvas is shifted upwards due to scrolling.
    //      @group  scrolling
    //<
    scrollTop:0,

    //>     @attr   canvas.scrollDelta (number : 20 : RWA)
    // Amount to scroll when the scroll button is pressed
    //              @group  scrolling
    //<
    scrollDelta:20,

    // Disabling
    // --------------------------------------------------------------------------------------------

    //> @attr canvas.disabled (boolean : false : IRW)
    // If set to true, the widget will be disabled. A widget is only considered enabled
    // if it is individually enabled and all parents above it in the containment hierarchy
    // are enabled. This allows you to enable or disable all components of a complex
    // nested widget by enabling or disabling the top-level parent only.
    //
    // @getter isDisabled
    // @setter enable, disable
    // @group enable
    // @visibility external
    //<
    //disabled:false,

    //> @attr   canvas.enabled  (boolean : "unset" : IRWA)
    // If set to true, this widget will be enabled, if set to false, or null, this
    // widget will be disabled.
    // @visibility external
    // @group enable
    // @deprecated As of SmartClient version 5.5 this property has been deprecated. The
    //   +link{canvas.disabled} property will be used to govern enabled/disabled state instead
    //  if <code>this.enabled</code> has not been changed from its default value.
    //<

    _$unset:"unset",
    enabled:"unset",

    //> @attr   canvas.redrawOnDisable      (boolean : false : IRWA)
    //          do we redraw when the disabled state changes ?
    //      @group  drawing, enable
    //<
    redrawOnDisable:false,

    //> @attr  canvas.redrawOnEnable       (boolean : false : IRWA)
    // do we redraw when the enabled state changes ?
    // @group  drawing, enable
    // @deprecated As of SmartClient 5.5 use +link{canvas.redrawOnDisable} instead
    //<

    //> @attr canvas.visibleWhen (AdvancedCriteria : null : IR)
    // Criteria to be evaluated to determine whether this Canvas should be visible.  Re-evaluated
    // whenever data in the +link{canvas.ruleScope} changes.
    // <P>
    // A basic criteria uses textMatchStyle:"exact". When specified in
    // +link{group:componentXML,Component XML} this property allows
    // +link{group:xmlCriteriaShorthand,shorthand formats} for defining criteria.
    // @group ruleCriteria
    // @visibility external
    //<

    //> @attr canvas.enableWhen (AdvancedCriteria : null : IR)
    // Criteria to be evaluated to determine whether this Canvas should be enabled.  Re-evaluated
    // whenever data in the +link{canvas.ruleScope} changes.
    // <P>
    // A basic criteria uses textMatchStyle:"exact". When specified in
    // +link{group:componentXML,Component XML} this property allows
    // +link{group:xmlCriteriaShorthand,shorthand formats} for defining criteria.
    // @group ruleCriteria
    // @visibility external
    //<

    // Peers: for which actions should we mimic what the master does?
    // --------------------------------------------------------------------------------------------

    //> @attr   canvas._redrawWithMaster        (boolean : true : IRWA)
    //      For a peer, should we redraw automatically when our masterElement is redrawn?
    //      @group  drawing, containment
    //<
    _redrawWithMaster:true,

    //> @attr   canvas._resizeWithMaster        (boolean : true : IRWA)
    //      For a peer, should we resize automatically when our masterElement is resized?
    //      @group  drawing, containment
    //<
    _resizeWithMaster:true,

    //> @attr   canvas._moveWithMaster      (boolean : true : IRWA)
    //      For a peer, should we move automatically when our masterElement moves?
    //      @group  drawing, containment
    //<
    _moveWithMaster:true,

    //> @attr   canvas._setOpacityWithMaster    (boolean : true : IRWA)
    // For a peer, should our opacity be automatically updated to match that of our
    // masterElement that changes?
    // @group drawing, containment
    //<
    _setOpacityWithMaster:true,


    //> @attr   canvas.redrawOnResize       (Boolean : true : IRWA)
    // Should this element be redrawn in response to a resize?
    // <P>
    // Should be set to true for components whose +link{getInnerHTML,inner HTML} will not
    // automatically reflow to fit the component's new size.
    //
    // @group drawing
    // @visibility external
    //<


    //> @attr   canvas._showWithMaster (boolean : true : IRWA)
    //      For a peer, should we be shown automatically when our master is shown?
    //      @group  drawing, containment
    //<
    _showWithMaster:true,


    // --------------------------------------------------------------------------------------------

    //> @attr   canvas._redrawWithParent        (boolean : true : IRWA)
    //      Should we redraw automatically when our parentElement is redrawn?
    //      Turn this off ONLY if you're completely committed to redrawing an element
    //       manually yourself.
    //      @group  drawing, containment
    //<
    _redrawWithParent:true,

    // Focus
    // --------------------------------------------------------------------------------------------

    // We track focus via canvas.hasFocus.
    // Not exposed - instead we have a public accessor canvas.isFocused()

    //> @attr   canvas.canFocus     (boolean : null : IRWA)
    // Can this widget be allowed to become the target of keyboard events?
    // <P>
    // If canFocus is unset (the default), only scrollable widgets with visible scrollbars are
    // focusable, to allow for keyboard scrolling.
    // <P>
    // A widget normally receives focus by being clicked on or tabbed to.
    //
    //      @group  focus, events
    //      @setter setCanFocus()
    // @visibility external
    // @example focus
    //<

    //> @attr   canvas.showFocusOutline    (boolean : true : IRWA)
    // For focusable widgets, should the native dotted focus outline be shown, where supported?
    // @visibility internal
    //<
    showFocusOutline:true,

    //> @attr   canvas.redrawOnFocus        (boolean : false : IRWA)
    //          should we redraw automatically when this object accepts the focus?
    //      @group  drawing, focus
    //<

    //> @attr   canvas.tabIndex (number : null : IRWA)
    // If specified this governs the tabIndex of the widget in the page's tab order.
    // Note that by default SmartClient auto-assigns tab-indices, ensuring focusable widgets
    // are reachable by tabbing in the order in which they are drawn on the page.
    // <code>canvas.tabIndex</code> cannot be set to greater than
    // +link{classAttr:Canvas.TAB_INDEX_FLOOR} - as we reserve the values above this range for
    // auto-assigned tab-indices.
    // @group focus
    // @visibility external
    //<
    // Some comments on manual assignment of tabIndex:
    // - useful for inserting into native tab order:
    //   - setting tabIndex to 0 to allow an ISC widget to be inserted into the native, automatic
    //     tab order of a series of native elements which surround it and which have no tabIndex
    //     assigned (where the ISC widget would be drawn either relpos or via Canvas.drawContext)
    //   - setting explicit tabIndex to allow an ISC widget to be inserted into a series of
    //     native elements with explicit tab indices
    //   - NOTE: with both of the above use cases, if a compound widget is inserted, all
    //     focuseable children will need an explicit tabIndex.  In some cases this works
    //     automatically, eg, in a ListGrid, the body and header receive the same tabIndex by
    //     default
    //  - Cannot be used to slot a widget into the middle of the ISC auto-assigned tab loop,
    //    as we enforce the TAB_INDEX_FLOOR upper limit on manually assigned tabindices


    _useNativeTabIndex:(isc.Browser.isIE && isc.Browser.version >= 5) || isc.Browser.isSafari ||
                        (isc.Browser.isMoz && isc.Browser.geckoVersion >= 20051111),


    _useFocusProxy:(isc.Browser.isMoz && isc.Browser.geckoVersion < 20051111)
                   || isc.Browser.isOpera,


    //> @attr   canvas.accessKey (string : null : IRWA)
    // If specified this governs the HTML accessKey for the widget.
    // <P>
    // This should be set to a character - when a user hits the html accessKey modifier for
    // the browser, plus this character, focus will be given to the widget in question.
    // The accessKey modifier can vary by browser and platform.
    // <P>
    // The following list of default behavior is for reference only, developers should also
    // consult browser documentation for additional information.
    // <ul>
    // <li><b>Internet Explorer (all platforms)</b>: <code>Alt</code> + <i>accessKey</i></li>
    // <li><b>Mozilla Firefox (Windows, Unix)</b>: <code>Alt+Shift</code> + <i>accessKey</i></li>
    // <li><b>Mozilla Firefox (Mac)</b>: <code>Ctrl+Opt</code> + <i>accessKey</i></li>
    // <li><b>Chrome and Safari (Windows, Unix)</b>:  <code>Alt</code> + <i>accessKey</i></li>
    // <li><b>Chrome and Safari (Mac)</b>:  <code>Ctrl+Opt</code> + <i>accessKey</i></li>
    // </ul>
    //
    // @group focus
    // @visibility external
    //<

    // Context Menu
    // --------------------------------------------------------------------------------------------

    //> @attr   canvas.contextMenu      (Menu : null : IRWA)
    // Context menu to show for this object, an instance of the Menu widget.
    // <P>
    // Note: if +link{canvas.destroy()} is called on a canvas, any specified context menu is
    // not automatically destroyed as well. This is in contrast to +link{MenuButton}s which
    // automatically destroy their specified +link{MenuButton.menu} by default. The behavior
    // is intentional as context menus are commonly reused across components.
    //      @group  cues
    //  @see canvas.showContextMenu()
    // @visibility external
    // @example contextMenus
    //<

    //> @attr   canvas.contextMenuProperties        (object : object : IRW)
    // Default properties for automatically generated context menus
    //<

    contextMenuProperties:{
        autoDraw:false,
        width:200,
        showIcons:true
    },

    //> @attr canvas.menuConstructor (SCClassName : "Menu" : IR)
    //  Default class used to construct menus created by this component, including context menus.
    //
    // @group   cues
    // @see canvas.showContextMenu()
    // @visibility external
    //<
    menuConstructor: "Menu",

    //>CornerClips
    // -----------------------------------------------------------------------------------------

    //> @attr canvas.clipCorners    (boolean : false : [IR])
    // Whether to clip corners
    // @visibility cornerClips
    //<
    //clipCorners:false,

    //> @attr canvas.clippedCorners   (Array : ["TL", "TR", "BL", "BR"] : [IR])
    // List of corners that should be clipped
    // @visibility cornerClips
    //<
    clippedCorners:["TL","TR","BL","BR"],

    //> @attr canvas.noCornerClipImages  (boolean : false : [IR])
    // For development purposes, create corner clips without requiring images.  Only works for
    // corners where width and height are equal.
    // <P>
    // Highly experimental and IE specific.
    //
    // @visibility cornerClips
    //<
    //noCornerClipImages:false,

    //> @attr canvas.cornerClipColor     (CSSColor : "FFFFFF" : [IR])
    // HEX color code (WITHOUT #) to match the background.
    //
    // @visibility cornerClips
    //<
    cornerClipColor:"FFFFFF",

    //> @attr canvas.cornerClipImage   (SCImgURL : "[SKIN]roundcorner.gif" : [IR])
    // Base name of image to use for corner clipping images.
    // <P>
    // The full name of each corner image is (base + color + corner name), eg,
    // "roundcorner_FFFFFF_TL.gif"
    //
    // @visibility cornerClips
    //<
    cornerClipImage:"[SKIN]corner.gif",

    //> @attr canvas.cornerClipSize        (number of pixels : 10 : [IR])
    // Size in pixels for corner clips
    // @visibility cornerClips
    //<
    cornerClipSize:10,

    //> @attr canvas.cornerClipWidth       (number of pixels : null : [IR])
    // Width in pixels for corner clips.  Defaults to cornerClipSize when unset.
    // @visibility cornerClips
    //<

    //> @attr canvas.cornerClipHeight      (number of pixels : null : [IR])
    // Height in pixels for corner clips.  Defaults to cornerClipSize when unset.
    // @visibility cornerClips
    //<

    //_cornerClips:null,    // refs to the generated corner cap elements

    _cornerProperties:{
        _generated:true,
        overflow:"hidden",

        _redrawWithMaster:false,
        _resizeWithMaster:false,
        autoDraw:false,
        skinImgDir:"images/corners/",

        // scroll cornercap contents to appropriate position after drawing
        // (should only apply to no-image corners)
        draw : function () {
            this.Super("draw",arguments);

        }
    },



    //<CornerClips

    // --------------------------------------------------------------------------------------------
    //> @attr canvas.prompt (HTMLString : null : IRW)
    // Prompt displayed in hover canvas if +link{canvas.showHover,showHover} is true.
    // @visibility external
    // @group   hovers
    // @example customHovers
    //<

    // Drag and Drop
    // --------------------------------------------------------------------------------------------

    //> @attr canvas.useNativeDrag (Boolean : null : IR)
    // If set, native HTML5 drag and drop will be used for all drags initiated on this widget
    // (on browsers where this is supported).
    // <p>
    // When using native HTML5 drags, the same series of events fires as for a normal drag
    // (+link{dragStart}, +link{dropMove}, etc.), and the +link{dragType,dragType} / +link{dropTypes,dropTypes}
    // system works. +link{Canvas.dragAppearance,dragAppearance} is not supported; however,
    // basic customization of the browser's tracker image is supported in certain browsers via
    // the +link{EventHandler.setDragTrackerImage()} API.
    // <p>
    // The primary difference with a native drag is that it can be cross-frame; that is, the
    // user can drag out of the current browser window and drop into a different window or tab.
    // <p>
    // To provide information that will be available to a foreign frame, use
    // +link{EventHandler.setNativeDragData()}.  This API must be called when the +link{dragStart}
    // event fires, and will not work if called at any other time.
    // <p>
    // However, due to browser bugs and/or browser-imposed limitations, the information provided to
    // <code>setNativeDragData</code> cannot be accessed in the foreign frame until the actual drop
    // occurs (mouse button released).  This means drop eligibility cannot be determined dynamically
    // based on the dragged data; instead, eligibility can only be determined based on the
    // +link{dragType} / +link{dropTypes} system. For this reason, a +link{dragType} <b>must</b>
    // be set on the source of a drag.
    // <p>
    // NOTE: Although Internet Explorer 10+ supports a subset of the +externalLink{http://www.w3.org/TR/html5/editing.html#dnd,HTML5 drag and drop standard},
    // native drag and drop is disabled in IE because cross-window drags&mdash;the primary purpose
    // of this API&mdash;are not possible.
    // @group dragdrop
    // @example nativeDragCreate
    // @visibility external
    //<

    _getUseNativeDrag : function () {
         return (this._getNativeDragTarget() != null);
    },
    _getNativeDragTarget : function () {
        var target = this;
        while (target != null) {
            if (target.useNativeDrag != null) {
                if (target.useNativeDrag) {
                    if (!!target.canDrag) return target;
                // useNativeDrag explicitly false
                } else {
                    return null;
                }
            // useNativeDrag unset - if we're draggable return null so we perform a
            // standard "SmartClient" drag [not a 'native' drag].
            // If we're not draggable, loop up the poarent chain.
            } else if (target.canDrag) {
                return null;
            }
            target = target.getParentCanvas();
        }
        return null;
    },

    //> @attr canvas.canDrag (Boolean : false : IRWA)
    // Indicates whether this widget can initiate custom drag-and-drop operations (other than
    // reposition or resize). Normally +link{canDragReposition} or +link{canDragResize} would
    // be used instead of this property.
    // <p>
    // Note: this property may be manipulated by higher-level dragging semantics.
    // <p>
    // If +link{useNativeDrag} is true and this widget has been drawn, then this widget must be
    // +link{redraw(),redrawn} in order for a change of the value of this attribute to take effect.
    // @visibility external
    // @group  dragdrop
    // @example dragCreate
    //<

    dragOutlineStyle:"dragOutline",

    //> @attr   canvas.dragStartDistance        (number : 5 : IRWA)
    //
    // Number of pixels the cursor needs to move before the EventHandler starts a drag operation.
    //
    // @group dragdrop
    // @visibility external
    //<
    dragStartDistance:5,

    //>DragScrolling
    //> @attr   Canvas.canDragScroll (boolean : true : IRWA)
    //      If this Canvas is canAcceptDrop:true, when the user drags a droppable widget over
    //      an edge of the widget, should we scroll to show the rest of the widget's content?
    //      Returned from canvas.shouldDragScroll() if there are scrollbars.
    //      @visibility external
    //      @see    shouldDragScroll()
    //      @group  dragging
    //<
    canDragScroll : true,

    //> @attr   canvas.dragScrollDelay    (number : 100 : IRWA)
    //      If this widget supports drag-scrolling, This property specifies how many ms the
    //      user must hover over the drag-scroll threshold before scrolling begins.
    //      @visibility external
    //      @group  dragging
    //<
    dragScrollDelay:100,


    //> @attr canvas.dragScrollThreshold (measure : null : IRWA)
    // If this widget allows drag-scrolling, the <code>dragScrollThreshold</code> is the distance
    // from the edge of the widget's viewport that the user must drag-hover to be in the
    // scrolling area.  This can be specified as a percentage value like "10%" or a number for
    // an absolute pixel value.
    // <p>
    // When +link{Browser.isTouch} is <code>true</code>, the default setting is "30%". Otherwise,
    // the default is "10%".
    // @group dragging
    // @visibility internal
    //<
    dragScrollThreshold:null,

    //> @attr   canvas.minDragScrollIncrement (measure : 1 : IRWA)
    //      If this widget allows drag-scrolling, the rate at which the widget will be scrolled
    //      while the user drag-hovers close to the edge of the widget is determined by how
    //      far the mouse pointer is from the edge.
    //      We provide 2 properties to control this:<br>
    //      - minDragScrollIncrement denotes what size increments will be used to scroll the
    //        widget while the pointer is exactly 1*this.dragScrollThreshold from the edge of
    //        the widget<br>
    //      - maxDragScrollIncrement denotes what size increments will be used to scroll the
    //        widget while the pointer is exactly over the edge of the widget<br>
    //      Each of these properties can be specified as an absolute pixel value to scroll, or
    //      a percentage of the scrollSize of the widget.
    //      @visibility internal
    //      @group  dragging
    //<
    minDragScrollIncrement:1,

    //> @attr   canvas.maxDragScrollIncrement (measure : "5%" : IRWA)
    //      If this widget allows drag-scrolling, the rate at which the widget will be scrolled
    //      while the user drag-hovers close to the edge of the widget is determined by how
    //      far the mouse pointer is from the edge.
    //      We provide 2 properties to control this:<br>
    //      - minDragScrollIncrement denotes what size increments will be used to scroll the
    //        widget while the pointer is exactly 1*this.dragScrollThreshold from the edge of
    //        the widget<br>
    //      - maxDragScrollIncrement denotes what size increments will be used to scroll the
    //        widget while the pointer is exactly over the edge of the widget<br>
    //      Each of these properties can be specified as an absolute pixel value to scroll, or
    //      a percentage of the scrollSize of the widget.
    //      @visibility internal
    //      @group  dragging
    //<
    maxDragScrollIncrement:"5%",
    //<DragScrolling


    //> @attr canvas.dragIntersectStyle (DragIntersectStyle : "mouse" : IRWA)
    // This indicates how the system will test for droppable targets: either by intersection
    // with the mouse or intersection with the rectangle of the dragMoveTarget.
    // @group dragdrop
    // @visibility external
    //<
    dragIntersectStyle : isc.EventHandler.INTERSECT_WITH_MOUSE,

    //> @attr   canvas.canDragReposition    (Boolean : false : IRWA)
    //      Indicates whether this widget can be moved by a user of your application by simply
    //      dragging with the mouse.
    //  @visibility external
    //  @group  dragdrop
    //  @example dragEffects
    //<

    //> @attr   canvas.dragRepositionCursor (Cursor : isc.Canvas.MOVE : IRWA)
    // Cursor to switch to if the mouse is over a widget that is drag repositionable.
    //  @visibility external
    //  @group  dragdrop
    //<
    dragRepositionCursor:isc.Canvas.MOVE,

    //> @attr   canvas.canDragResize        (Boolean : false : IRWA)
    //      Indicates whether this widget can be resized by dragging on the edges and/or corners of
    //      the widget with the mouse.
    //  @visibility external
    //  @group  dragdrop
    //  @example dragResize
    //<

    setCanDragResize : function (canDragResize) {
        if (this.canDragResize != canDragResize) {
            this.canDragResize = canDragResize;
            this._checkProportionalResizing();
        }
    },

    //> @type ProportionalResizeMode
    // @value "none" proportional resizing is never used
    // @value "always" proportional resizing is always used
    // @value "modifier" proportional resize is off by default, but holding down one of the
    // +link{canvas.proportionalResizeModifiers} turns proportional resize on for a given
    // resize interaction
    // @value "modifierOff" proportional resize is on by default, but holding down one of the
    // +link{canvas.proportionalResizeModifiers} turns proportional resize off for a given
    // resize interaction
    // @group dragdrop
    // @visibility external
    //<

    //> @attr canvas.proportionalResizing (ProportionalResizeMode : "none" : IR)
    // If +link{canvas.canDragResize} is true, this property specifies the conditions for when
    // proportional resizing is used.  The default is <smartclient>"none"</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.ProportionalResizeMode#MODIFIER_OFF}</smartgwt>
    // , which means that proportional resizing is disabled.
    // @see proportionalResizeModifiers
    // @group dragdrop
    // @visibility external
    //<
    proportionalResizing: "none",

    //> @attr canvas.proportionalResizeModifiers (Array of KeyName : ["Shift"] : IR)
    // If +link{proportionalResizing} is set to <smartclient>"modifier"</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.ProportionalResizeMode#MODIFIER}</smartgwt>
    // or <smartclient>"modifierOff"</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.ProportionalResizeMode#MODIFIER_OFF}</smartgwt>
    // then proportional resizing of the widget is activated or deactivated, respectively,
    // whenever at least one key in this set of modifier keys is pressed.
    // <p>
    // The keys allowed in this set are:  "Alt", "Ctrl", and "Shift".  If this set
    // of keys is empty then proportional resizing is always used if
    // <code>proportionalResizing</code> is <smartclient>"modifier"</smartclient>
    // <smartgwt><code>MODIFIER</code></smartgwt> and is never used if
    // <code>proportionalResizing</code> is <smartclient>"modifierOff"</smartclient>
    // <smartgwt><code>MODIFIER_OFF</code></smartgwt>.
    // @group dragdrop
    // @visibility external
    //<
    proportionalResizeModifiers: ["Shift"],

    _getProportionalResizing : function () {

        var proportionalResizing = this.proportionalResizing,
            always = proportionalResizing == "always",
            modifier = !always && proportionalResizing == "modifier",
            modifierOff = !(always || modifier) && proportionalResizing == "modifierOff";
        if (!(always || modifier || modifierOff)) { // including "none"
            return "none";
        }
        var resizeFrom = this.resizeFrom,
            supportsProportionalResizing = (
                this.canDragResize &&
                // If the widget is being destroyed then the `proportionalResizing` mode
                // should be "none" so that the widget will stop listening for the modifier
                // keys.
                !this.destroying &&
                !this.destroyed &&
                // Proportional resizing is only applicable when resizing can be from a corner.
                (resizeFrom == null || (
                    isc.isAn.Array(resizeFrom) &&
                    resizeFrom.length > 0 && (
                        resizeFrom.contains("TL") || resizeFrom.contains("TR") ||
                        resizeFrom.contains("BL") || resizeFrom.contains("BR")))));
        if (!supportsProportionalResizing) {
            return "none";
        } else {
            // If the set of keys is empty then proportional resizing is always used if
            // `modifier` (and never used if `modifierOff`).
            var emptyModifierSet = (
                    isc.Page._getModifierKeysFlags(this.proportionalResizeModifiers) == 0);
            if (emptyModifierSet) {
                if (modifier) {
                    return "always";
                } else if (modifierOff) {
                    return "none";
                }
            }

            // Otherwise simply return the property value.
            return proportionalResizing;
        }
    },

    //> @type EdgeName
    // An edge or corner of a rectange, or it's center.  Used in APIs such as
    // +link{canvas.resizeFrom} and +link{canvas.getEventEdge()}.
    // @value "T" top edge
    // @value "B" bottom edge
    // @value "L" left edge
    // @value "R" right edge
    // @value "TL" top-left corner
    // @value "TR" top-right corner
    // @value "BL" bottom-left corner
    // @value "BR" bottom-right corner
    // @value "C" center
    //
    // @visibility external
    //<

    //> @attr canvas.resizeFrom (Array of EdgeName : null : IRWA)
    // When drag resizing is enabled via +link{canDragResize}, restricts resizes to only
    // certain edges or corners.
    // <P>
    // The default of null indicates the widget can be resized from any corner or edge (if
    // <code>canDragResize</code> is true).
    // <P>
    // To restrict resizing to only certain corners, set <code>resizeFrom</code> to an Array of
    // +link{EdgeName}s.
    //
    // @group dragdrop
    // @example dragResize
    // @visibility external
    //<

    setResizeFrom : function (resizeFrom) {
        if (this.resizeFrom != resizeFrom) {
            this.resizeFrom = resizeFrom;
            this._checkProportionalResizing();
        }
    },

    //> @attr   canvas.dragScrollType       (string : "any" : IRWA)
    //      If this canvas is a dragTarget and this property is set to "parentsOnly", then only its
    //      parent chain should be checked for possible scrollers.
    //  @group  dragdrop
    //<
    dragScrollType:"any",

    //> @attr   canvas.dragScrollDirection (string : null : IRWA)
    // If this canvas is a dragTarget, this property may be set to limit which direction the
    // parent / other scrollable widget is scrolled on drag-over.<br>
    // Options are "vertical" or "horizontal".
    //  @group  dragdrop
    //<
    //dragScrollDirection:null,

    //> @attr canvas.useDragMask (boolean : false : IRW)
    // This flag controls whether we register the component as a maskable item with the
    // EventHandler. If enabled, a backmask will be automatically created for the
    // dragMoveTarget on the fly to avoid burnthrough e.g. by plugins or frames.
    //
    // @visibility external
    // @group dragdrop
    //<
    useDragMask:false,

    //> @type DragMaskType
    // What kind of mask to use for masking dragged element.
    // @value   "div"     creates an element with ordinary HTML content that will block events
    // @value   "iframe"  creates an iframe with empty content
    // @value   "hide"    hides the contents of this widget temporarily
    // @group dragdrop
    // @visibility external
    //<

    //> @attr canvas.dragMaskType (DragMaskType : "div" : IRW)
    // This property controls what kind of mask is used in case +link{useDragMask} is
    // enabled.
    //
    // @group dragdrop
    // @visibility external
    //<
    dragMaskType:"div",

    // Default placeholder message and style
    dragPlaceholderMessage: "Dragging...",
    dragPlaceholderStyle: "normal",

    //> @attr canvas.canHover (boolean : null : IRW)
    // Will this Canvas fire hover events when the user hovers over it, or one of its children?
    //  @group hovers
    //  @visibility external
    //  @see canvas.showHover
    //  @see canvas.hover()
    //<
    //canHover:null,

    //> @attr canvas.hoverDelay (number : 300 : IRW)
    // If <code>this.canHover</code> is true, how long should the mouse be kept over this
    // widget before the hover event is fired
    //  @group hovers
    //  @visibility external
    //  @see canvas.canHover
    //  @see canvas.hover()
    //<
    hoverDelay:300,

    //> @attr canvas.showHover (Boolean : true : IRW)
    // If <code>this.canHover</code> is true, should we show the global hover canvas by default
    // when the user hovers over this canvas?
    //  @group hovers
    //  @visibility external
    //  @see canvas.getHoverHTML()
    //<
    showHover:true,

    // By default, dismiss the hover on mouseDown
    hideHoverOnMouseDown:true,

    //> @attr canvas.hoverWidth (int : null : IRW)
    // If +link{canvas.showHover,this.showHover} is true, this property can be used to customize the
    // width of the hover canvas shown.
    //  @group hovers
    //  @visibility external
    //  @see canvas.showHover
    //  @example customHovers
    //<
    //hoverWidth:null,

    //> @attr canvas.hoverHeight (int : null : IRW)
    // If <code>this.showHover</code> is true, this property can be used to customize the
    // height of the hover canvas shown.
    //  @group hovers
    //  @visibility external
    //  @see canvas.showHover
    //<
    //hoverHeight:null,

    //> @attr canvas.hoverAlign (Alignment : null : IRW)
    // If <code>this.showHover</code> is true, this property can be used to customize the
    // alignment of content in the hover canvas.
    //  @group hovers
    //  @visibility external
    //  @see canvas.showHover
    //<
    //hoverAlign:null,

    //> @attr canvas.hoverVAlign (VerticalAlignment : null : IRW)
    // If <code>this.showHover</code> is true, this property can be used to customize the
    // vertical alignment of content in the hover canvas.
    //  @group hovers
    //  @visibility external
    //  @see canvas.showHover
    //<
    //hoverVAlign:null,

    //> @attr canvas.hoverWrap (boolean : null : IRW)
    // If <code>this.showHover</code> is true, this property can be used to customize the
    // whether content in the hover canvas is displayed in a single line, or wraps.
    //  @group hovers
    //  @visibility external
    //  @see canvas.showHover
    //<
    //hoverWrap:null,

    //> @attr canvas.hoverStyle (CSSStyleName : null : IRW)
    // If <code>this.showHover</code> is true, this property can be used to specify the
    // css style to apply to the hover canvas.
    //  @group hovers
    //  @visibility external
    //  @see canvas.showHover
    //  @example customHovers
    //<
    //hoverStyle:null,

    //> @attr canvas.hoverOpacity (number : null : IRW)
    // If <code>this.showHover</code> is true, should the hover canvas be shown with opacity
    // other than 100?
    // @visibility external
    // @group hovers
    // @see canvas.showHover
    //  @example customHovers
    //<
    //hoverOpacity:null,

    //> @attr canvas.hoverMoveWithMouse (boolean : null : IRW)
    // If <code>this.showHover</code> is true, should this widget's hover canvas be moved with
    // the mouse while visible?
    // @visibility external
    // @group hovers
    // @see canvas.showHover
    //<

    //> @attr canvas.hoverAutoDestroy (boolean : null : IRW)
    // If <code>this.showHover</code> is true and +link{getHoverComponent()} is implemented, should
    // the hoverCanvas returned from it be automatically destroyed when it is hidden?
    // <P>
    // The default of null indicates that the component <b>will</b> be automatically
    // destroyed.  Set to false to prevent this.
    //
    // @visibility external
    // @group hovers
    // @see canvas.showHover
    //<

    //> @attr   canvas.edgeMarginSize       (number : 5 : IRWA)
    // How far into the edge of an object do we consider the "edge" for drag resize purposes?
    // @group dragdrop
    // @example dragResize
    // @visibility external
    //<
    edgeMarginSize: null, // isc.Browser.isTouch ? 10 : 5

    //> @attr canvas.minNonEdgeSize (int : 0 : IRWA)
    // If the widget has drag resize configured on one or more of it's edges, and the
    // edgeMarginSize is large enough that the remaining space is less than
    // <code>minNonEdgeSize</code>, the edgeMarginSize will be reduced such that the non-edge
    // part of the widget is at least 1/3 of the total space (with two draggable edges) or half
    // of it (with one draggable edge).
    // @group dragdrop
    // @example dragResize
    // @visibility external
    //<
    minNonEdgeSize: 0,

    //> @attr   canvas.edgeCursorMap        (object : {...} : IRWA)
    // Cursor to use when over each edge of a Canvas that is drag resizable.
    // <P>
    // To disable drag resize cursors, set the edgeCursorMap property to null.
    //
    //  @see resizeFrom
    //  @visibility external
    //  @group  dragdrop
    //<
    // NOTE: cursor change is actually accomplished in isc.EventHandler.handleMouseMove()
    edgeCursorMap: {
            "T":"n-resize",
            "L":"w-resize",
            "B":"s-resize",
            "R":"e-resize",
            "TL":"nw-resize",
            "TR":"ne-resize",
            "BL":"sw-resize",
            "BR":"se-resize"
    },

    //> @attr canvas.keepInParentRect (Boolean | Array of Integer : null : IRWA)
    // Constrains drag-resizing and drag-repositioning of this canvas to either the rect of its
    // parent (if set to true) or an arbitrary rect based its parent (if set to a
    // [Left,Top,Width,Height] rect array).  In the latter mode you may use negative offsets
    // for left/top and a width/height greater than the visible or scroll width of the parent
    // to allow positioning beyond the confines of the parent.
    // <p>
    // If this canvas has no parent, constrains dragging to within the browser window.
    // <p>
    // Affects target and outline dragAppearance, not tracker.
    // <p>
    // Note: keepInParentRect affects only user drag interactions, not programmatic moves.
    // <p>
    // <u>Example use cases:</u><br>
    // <code>keepInParentRect: true</code> - confine to parent<br>
    // <code>keepInParentRect: [0, 0, 500, 500]</code> - confine to top left 500x500 region within parent<br>
    // <code>keepInParentRect: [0, 0, 10000, 10000]</code> - in combination with
    // oveflow: "auto", confine to parent, but allow moving off the right and bottom of the
    // parent to force scrolling (and hence enlarge the scrollWidth of the parent).
    //
    // @group dragdrop
    // @visibility external
    // @example dragCreate
    //<

    //> @attr canvas.dragAppearance (DragAppearance : isc.EventHandler.OUTLINE : IRWA)
    // Visual appearance to show when the object is being dragged. May be overridden for
    // dragResize or dragReposition events via +link{canvas.dragResizeAppearance}
    // and +link{canvas.dragRepositionAppearance}.
    // @group dragdrop
    // @visibility external
    //<
    dragAppearance:isc.EventHandler.OUTLINE,

    //> @attr canvas.dragResizeAppearance (DragAppearance : null : IRWA)
    // If +link{canvas.canDragResize} is true, this attributes specifies the visual appearance
    // to show during drag resize. If unset +link{canvas.dragAppearance} will be used.
    // @group dragdrop
    // @visibility external
    //<

    //> @attr canvas.dragRepositionAppearance (DragAppearance : null : IRWA)
    // If +link{canvas.canDragReposition} is true, this attributes specifies the visual appearance
    // to show during drag reposition. If unset +link{canvas.dragAppearance} will be used.
    // @group dragdrop
    // @visibility external
    //<

    getDragAppearance : function (dragOperation) {
        if (dragOperation == isc.EH.DRAG_RESIZE && this.dragResizeAppearance != null)
            return this.dragResizeAppearance;
        if (dragOperation == isc.EH.DRAG_REPOSITION && this.dragRepositionAppearance != null)
            return this.dragRepositionAppearance;
        return this.dragAppearance;
    },

    //> @attr canvas.dragType (String : null : IRWA)
    // Sets a <code>dragType</code> for this widget used, to be compared to
    // +link{Canvas.dropTypes,dropTypes} on possible drop target widgets.  See
    // +link{Canvas.dropTypes} for a full explanation.
    // @group dragdrop
    // @visibility external
    //<

    //> @attr canvas.dropTypes (Array of String | String : isc.Canvas.ANYTHING : IRWA)
    // When a drag and drop interaction occurs, if a +link{Canvas.dragType,dragType} is
    // configured on the source widget, it is compared to the <code>dropTypes</code> configured
    // on the target widget, and a drop is only allowed if the <code>dragType</code> is listed
    // in the target widget's <code>dropTypes</code> array.
    // <p>
    // The default setting means any <code>dragType</code> is eligible for dropping on this
    // widget, including no <code>dragType</code> setting.
    // <p>
    // See also +link{willAcceptDrop} for dynamic determination of drop eligibility.
    //
    // @group dragdrop
    // @visibility external
    //<
    dropTypes:isc.Canvas.ANYTHING,

    //> @attr canvas.dragTarget (Canvas | String : null : IRWA)
    // A different widget that should be actually dragged when dragging initiates on this
    // widget. One example of this is to have a child widget that drags its parent, as with a
    // drag box. Because the parent automatically repositions its children, setting the drag
    // target of the child to the parent and then dragging the child will result in both
    // widgets being moved.<br>
    // Valid dragTarget values are:<br>
    // - <code>null</code> (default) [this widget is its own drag target]<br>
    // - another widget, or widget ID<br>
    // - <code>"parent"</code> drag target is this widget's
    //    +link{Canvas.getParentCanvas(), parentCanvas}<br>
    // - <code>"top"</code> drag target is this widget's
    //    +link{Canvas.topElement, topElement}<br>
    // @see EventHandler.getDragTarget()
    // @group dragdrop
    // @visibility external
    //<

    //> @attr canvas.showDragShadow (Boolean : null : IRWA)
    // When this widget is dragged, if its dragAppearance is <code>"target"</code>, should
    // we show a shadow behind the canvas during the drag.
    //
    // @group dragdrop
    // @visibility external
    // @example dragEffects
    //<

    //> @attr canvas.dragOpacity (int : null : IRWA)
    // If this widget has dragAppearance <code>"target"</code>, this value specifies the
    // opacity to render the target while it is being dragged. A null value implies we do
    // not modify the opacity.
    //
    // @group dragdrop
    // @visibility external
    // @example dragEffects
    //<

    //> @attr canvas.canDrop (Boolean : false : IRWA)
    // Indicates that this object can be dropped on top of other widgets. Only valid if
    // canDrag or canDragReposition is true.
    // @group dragdrop
    // @visibility external
    // @example dragCreate
    //<

    //> @attr canvas.canAcceptDrop (Boolean : false : IRWA)
    // Indicates that this object can receive dropped widgets (i.e. other widgets can be
    // dropped on top of it).
    // @group dragdrop
    // @visibility external
    // @example dragCreate
    //<


    //> @attr canvas.canDropBefore (boolean : null : IRWA)
    // When explicitly set to false, disallows drop before this member in the Layout.
    //
    // @group layoutMember
    // @see Layout
    // @visibility external
    //<


    //> @attr canvas.mouseStillDownInitialDelay (int : 400 : IRWA)
    // Amount of time (in milliseconds) before mouseStillDown events start to be fired for this object.
    //
    // @group events
    // @visibility external
    //<

    mouseStillDownInitialDelay:400,

    //> @attr canvas.mouseStillDownDelay (int : 100 : IRWA)
    // Amount of time (in milliseconds) between 'mouseStillDown' events for this object
    //
    // @group events
    // @visibility external
    //<
    mouseStillDownDelay:100,

    //> @attr canvas.doubleClickDelay (int : 250 : IRWA)
    // Amount of time (in milliseconds) between which two clicks are considered a single click
    // @group events
    // @visibility external
    //<
    doubleClickDelay:250,

    //> @attr canvas.noDoubleClicks (Boolean : null : IRWA)
    // If true, this canvas will receive all mouse-clicks as single +link{canvas.click,click}
    // events rather than as +link{canvas.doubleClick,doubleClick} events.
    // @group events
    // @visibility external
    //<
    //noDoubleClicks:false,

    // --------------------------------------------------------------------------------------------
    // variable name to use with refreshFromServer / replaceFromServer
    refreshVariable : "refresh",

    // --------------------------------------------------------------------------------------------


    //>Moz
    _useMozScrollbarsNone : (isc.Browser.isMoz &&
                               (!isc.Browser.isUnix || isc.Browser.geckoVersion > 20031007)),
    _canScrollHidden:isc.Browser.isMoz && isc.Browser.version >= 18,
    //<Moz

    // Whether to create a clipDiv/contentDiv pair vs a single DIV.
    // NOTE: we have a function shouldCreateClipDiv() which tells us under what circumstances we
    // really need to use a clipDiv.

    // Writing two DIVs has a performance impact, so specific subclasses which don't rely on all of
    // Canvas' features working correctly might want to override this in order to have a lighter
    // weight DOM representation.  NOTE: the strategy of using nested DIVs can actually be used in
    // any browser, in fact, it works in IE and corrects some bugs, although it is noticeably slower
    useClipDiv: isc.Browser.useClipDiv,
    //useClipDiv: false,


    manageChildOverflow:true,

    //> @attr Canvas.useBackMask (Boolean : false : IRWA)
    // In earlier versions of Internet Explorer (pre IE9), a native limitation
    // exists  whereby if HTML elements are
    // overlapping on the page, certain elements can appear to "burn through"
    // elements in the same position with a higher z-index.
    // Specific cases in which this have been observed include Applets,
    // &lt;IFRAME&gt; elements, and for
    // older versions of IE, native &lt;SELECT&gt; items.
    // <P>
    // The backMask is a workaround for this issue. If <code>useBackMask</code> is
    // set to <code>true</code>, the component will render an empty &lt;IFRAME&gt; element
    // behind the canvas, which prevents this effect in all known cases.
    // <P>
    // Has no effect in other browsers.
    // @visibility external
    //<

    //> @attr canvas.useEventParts  (boolean : false : IRWA)
    // If true, when this widget receives events, it will check whether the native DOM element
    // that received the event has been marked as a special "part" of this widget, and if so
    // fire the appropriate part events.<br>
    // Elements written into this canvas can be marked as 'parts' by setting the 'eventpart'
    // attribute to the name of the part type. The events fired are then based upon this
    // property. For example an element with eventpart set to "rect" would cause this widget
    // to fire "rectMouseOver", "rectMouseOut" handlers. The element, and a unique ID for the
    // part would be passed into those custom handlers
    // @visibility eventParts
    //<


    // _lastOverPart - if we're handling partwise events, this is used to track what the user
    // was last over within this canvas.
    // Format: {part:[parttype], element:[element], ID:[ID]}
    _lastOverPart:{},

    //> @type PercentBoxModel
    // Determines sizing model when sizing / positioning a canvas relative to its
    // +link{canvas.percentBox,percentBox}.
    // @value "visible" use coordinates relative to the
    // {+link{canvas.getVisibleHeight()},visibleHeight} and width of the other canvas
    // @value "viewport" use coordinates relative to the
    // {+link{canvas.getViewportHeight()},viewportHeight} and width of the other canvas
    // @visibility external
    //<

    //> @attr canvas.percentSource (Canvas : null : IRWA)
    // If this canvas has its size specified as a percentage, this property allows the user to
    // explicitly designate another canvas upon which sizing will be based.
    // <P>
    // If unset percentage sizing is based on<br>
    // - the +link{canvas.getMasterCanvas(),master canvas} if there is one and
    //   +link{canvas.snapTo,snapTo} is set,<br>
    // - otherwise on the amount of space available in this widget's parent canvas, if this is
    //   a child of some other widget<br>
    // - otherwise the page size.
    // @group sizing
    // @see attr:canvas.percentBox
    // @visibility external
    //<

    //> @attr canvas.percentBox (PercentBoxModel : "visible" : IRA)
    // Governs the model to be used when sizing canvases with percentage width or height, or
    // positioning widgets with a specified +link{canvas.snapTo,snapTo}.
    // <P>
    // Only affects widgets with a a specified +link{canvas.percentSource,percentSource}, or
    // widgets that have +link{canvas.snapTo} set and are peers of some
    // +link{canvas.getMasterCanvas(),other canvas}.
    // <P>
    // Determines whether the coordinates used for sizing (for percentage sized widgets) and
    // positioning (if <code>snapTo</code> is set) should be relative to the visible size or the
    // viewport size of the percentSource or +link{canvas.getMasterCanvas(),master canvas} widget.
    // @group sizing
    // @visibility external
    //<
    percentBox:"visible",
    _$viewport:"viewport",

    //> @attr canvas.snapTo (String : null : IRW)
    // Position this widget such that it is aligned with ("snapped to") an edge of its
    // +link{canvas.getMasterCanvas(),master} (if specified), or its
    // +link{canvas.getParentCanvas(),parent canvas}.
    // <P>
    // Note that this property also impacts the sizing of this widget. If this widgets size
    // is specified as a percent value, and has no explicit
    // +link{Canvas.percentSource}, sizing will be calculated based on the size of the
    // +link{canvas.getMasterCanvas(),master canvas} when snapTo is set.
    // <P>
    // Possible values: BR, BL, TR, TL, R, L, B, T, C where B=Bottom, T=Top, L=Left, R=right
    // and C=center
    // <P>
    // Standard snapTo behavior will attach the outer edge of the widget to the parent or master
    // element - for example setting <code>snapTo</code> to <code>"B"</code> would align the
    // bottom edge of this component with the bottom edge of the master or parent element
    // (and center this component horizontally over its master or parent element).
    // +link{Canvas.snapEdge} can be specified to change this behavior allowing the developer
    // to, for example, align the top edge of this component with the bottom edge of its
    // +link{canvas.getMasterCanvas(),master canvas}.
    // <P>
    // +link{Canvas.snapOffsetLeft} and +link{Canvas.snapOffsetTop} may also be specified to
    // offset the element from exact snapTo alignment.
    // @group sizing
    // @see canvas.snapEdge
    // @see canvas.percentBox
    // @visibility external
    //<

    //> @attr canvas.snapEdge (String : null : IRW)
    // If +link{canvas.snapTo,snapTo} is defined to this widget, this property can be used to
    // define which edge of this widget should be snapped to an edge of the master or parent
    // element.
    // <P>
    // If unspecified the, default snapTo behavior is set up to align the "snapTo" edge of this
    // widget with the snapTo edge of the master or parent.
    //
    // @group sizing
    // @see canvas.snapTo
    // @visibility external
    //<

    //> @attr canvas.snapOffsetLeft (integer : null : IRW)
    // If +link{canvas.snapTo,snapTo} is defined for this widget, this property can be used to
    // specify an offset in px or percentage for the left coordinate of this widget.
    // <P>
    // For example if <code>snapTo</code> is specified as <code>"L"</code> and
    // <code>snapOffsetLeft</code> is set to 6, this widget will be rendered 6px inside the left
    // edge of its parent or master element. Alternatively if <code>snapTo</code> was set
    // to <code>"R"</code>, a <code>snapOffsetLeft</code> value of -6 would cause the
    // component to be rendered 6px inside the right edge of its parent or +link{canvas.getMasterCanvas(),master canvas}.
    // @group sizing
    // @see canvas.snapTo
    // @visibility external
    //<

    //> @attr canvas.snapOffsetTop (integer : null : IRW)
    // If +link{canvas.snapTo,snapTo} is defined for this widget, this property can be used to
    // specify an offset in px or percentage for the top coordinate of this widget.
    // <P>
    // For example if <code>snapTo</code> is specified as <code>"T"</code> and
    // <code>snapOffsetTop</code> is set to 6, this widget will be rendered 6px below the top
    // edge of its parent or master element. . Alternatively if <code>snapTo</code> was set
    // to <code>"B"</code>, a <code>snapOffsetTop</code> value of -6 would cause the
    // component to be rendered 6px inside the bottom edge of its parent or +link{canvas.getMasterCanvas(),master canvas}.
    // @group sizing
    // @see canvas.snapTo
    // @visibility external
    //<

    //> @attr canvas.snapToGrid (boolean : null : IRW)
    // Causes this canvas to snap to its parent's grid when dragging.
    // @visibility external
    // @see Canvas.childrenSnapToGrid
    // @group dragdrop
    //<

    //> @attr canvas.snapResizeToGrid (boolean : null : IRW)
    // Causes this canvas to snap to its parent's grid when resizing.
    // Note that this value defaults to the Canvas's
    // +link{Canvas.snapToGrid, snapToGrid} value if undefined.
    // @visibility external
    // @group dragdrop
    //<

    //> @attr canvas.childrenSnapToGrid (boolean : null : IRW)
    // If true, causes this canvas's children to snap to its grid when dragging.
    // This behavior can be overridden on a per-child basis by setting the
    // +link{Canvas.snapToGrid, snapToGrid} value on the child.
    // @visibility external
    // @group dragdrop
    //<

    //> @attr canvas.childrenSnapResizeToGrid (boolean : null : IRW)
    // If true, causes this canvas's children to snap to its grid when resizing.
    // This behavior can be overridden on a per-child basis by setting the
    // +link{Canvas.snapToGrid, snapToGrid} or
    // +link{Canvas.snapResizeToGrid, snapResizeToGrid} value on the child.
    // @visibility external
    // @group dragdrop
    //<

    //> @attr canvas.snapHGap (number : 20 : IRW)
    // The horizontal grid size to use, in pixels, when snap-to-grid is enabled.
    // @visibility external
    // @group dragdrop
    // @see Canvas.snapToGrid
    // @see Canvas.snapResizeToGrid
    // @see Canvas.childrenSnapToGrid
    // @see Canvas.childrenSnapResizeToGrid
    //<
   snapHGap: 20,

    //> @attr canvas.snapVGap (number : 20 : IRW)
    // The vertical grid size to use, in pixels, when snap-to-grid is enabled.
    // @visibility external
    // @group dragdrop
    // @see Canvas.snapToGrid
    // @see Canvas.snapResizeToGrid
    // @see Canvas.childrenSnapToGrid
    // @see Canvas.childrenSnapResizeToGrid
    //<
   snapVGap: 20,

    //> @attr canvas.snapHDirection (string : "after" : IRW)
    // The horizontal snap direction.
    // Set this value to "before" to snap to the nearest gridpoint to the left;
    // set it to "after" to snap to the nearest gridpoint to the right; and set
    // it to "nearest" to snap to the nearest gridpoint in either direction.
    // @visibility external
    // @group dragdrop
    // @see Canvas.snapToGrid
    // @see Canvas.snapResizeToGrid
    // @see Canvas.childrenSnapToGrid
    // @see Canvas.childrenSnapResizeToGrid
    //<
   snapHDirection: isc.Canvas.AFTER,

    //> @attr canvas.snapVDirection (string : "after" : IRW)
    // The vertical snap direction.
    // Set this value to "before" to snap to the nearest gridpoint above;
    // set it to "after" to snap to the nearest gridpoint below; and set
    // it to "nearest" to snap to the nearest gridpoint in either direction.
    // @visibility external
    // @group dragdrop
    // @see Canvas.snapToGrid
    // @see Canvas.snapResizeToGrid
    // @see Canvas.childrenSnapToGrid
    // @see Canvas.childrenSnapResizeToGrid
    //<
   snapVDirection: isc.Canvas.AFTER,

    //> @attr canvas.snapAxis (string : "both" : IRW)
    // Describes which axes to apply snap-to-grid to.
    // Valid values are "horizontal", "vertical" or "both".
    // @visibility external
    // @group dragdrop
    // @see Canvas.snapToGrid
    // @see Canvas.snapResizeToGrid
    // @see Canvas.childrenSnapToGrid
    // @see Canvas.childrenSnapResizeToGrid
    //<
   snapAxis: isc.Canvas.BOTH,

    //> @attr canvas.snapOnDrop (Boolean : true : IRWA)
    // When this canvas is dropped onto an object supporting snap-to-grid, should it snap
    // to the grid (true, the default) or just drop wherever the mouse is (false).
    // @visibility external
    // @group dragdrop
    // @see Canvas.snapToGrid
    // @see Canvas.shouldSnapOnDrop()
    //<
   snapOnDrop: true
});


isc.Canvas.addMethods({

// basic terms
_$resize: "resize",
_$draw: "draw",
_$hidden: "hidden",
_$redraw: "redraw",
_$undefined: "undefined",

// various log and stat categories
_$draws: "draws",
_$drawing: "drawing",
_$redraws: "redraws",
_$autoDraw: "autoDraw",
_$masterElement: "masterElement",

// insertAdjacentHTML positions

_$beforeBegin : "beforeBegin",
_$afterBegin: "afterBegin",
_$beforeEnd: "beforeEnd",
_$afterEnd: "afterEnd",

// characters
_$rightAngle : ">",
_$singleQuote : "'",
_$doubleQuote : '"',

// Initialization
// --------------------------------------------------------------------------------------------

//> @method canvas.init()   (A)
//
// This method performs some basic initialization common to all UI components.  To do custom UI
// component initialization, you should generally override +link{Canvas.initWidget()}.  This
// method does the following, in order:
// <ul>
// <li>Sets up a global reference to this instance as described in +link{Canvas.ID}.
// <li>Ensures certain numeric properties have numeric values (e.g. width, height, padding,
// margin)
// <li>Ensures +link{canvas.children} and +link{canvas.peers} are Arrays.
// <li>Calls +link{Canvas.initWidget()}
// <li>Creates +link{showEdges,edges} and +link{showShadow,shadow}, if so configured.
// <li>Calls +link{Canvas.draw()} if +link{Canvas.autoDraw} is set on instance or globally.
// </ul>
// Unless you're in an advanced scenario where you need to inject code before the above
// logic executes, place your initialization logic in initWidget() rather than init().  If you
// do decided to override this method, you must call the superclass implementation like so:
// <pre>
//    this.Super("init", arguments);
// </pre>
//
// @param   [arguments 0-N] (any)   All arguments initially passed to +link{Class.create()}
//
// @visibility external
//<
init : function (A,B,C,D,E,F,G,H,I,J,K,L,M) {
    var undef;
    //this.addProperties(isc.getRegisteredInstanceProperties(this.ID));
    if (isc._traceMarkers) arguments.__this = this;

    // Perform a one time check to see if we're creating any canvases in the <head>
    // If so log a warning.
    // We don't support drawing widgets outside the body at all.
    // Creating widgets without drawing outside the body is unreliable - in some
    // cases, even having autoDraw set to false, we will attempt to write out HTML on widget
    // init to (EG) derive styling information.

    if (!isc.Canvas._outsideBodyCheck) {
        if (this.getDocumentBody(true) == null) {
            isc.logWarn("Canvas created in a page outside the BODY tag. This is not supported. " +
                "Isomorphic Software requires the tag to be present and all widgets be created " +
                "and drawn inside it. Canvas details follow:\n" +
                isc.Log.echo(this));

        }
        isc.Canvas._outsideBodyCheck = true;
    }

    // get a global ID so we can be called in the global scope
    this.ns.ClassFactory.addGlobalID(this);
    if (this.useTouchScrolling == false) {
        if (isc.Browser.isTouch) this.showCustomScrollbars = true;
        this.useNativeTouchScrolling = false;
    } else if (this.useNativeTouchScrolling && this._browserSupportsNativeTouchScrolling &&
               !this.alwaysShowScrollbars)
    {
        this.showCustomScrollbars = false;
    }

    // put this object in the master list of Canvases that have been created so it can be
    // deallocated later
    this._canvasList(true);

    // if position has not been set, default it to relative if htmlElement is set.
    if (this.position == null) {
        this.position = this.htmlElement != null ? isc.Canvas.RELATIVE : isc.Canvas.ABSOLUTE;
    }


    if (this.className != null && this.logIsInfoEnabled(this._$styleName)) {
        this.logInfo("'className' property specified. This property has been deprecated in "
                    + "favor of 'styleName' as of SmartClient 5.5.", this._$styleName);
    }
    if (this.styleName != null) {
        // both stylename and className are set
        if (this.className != null) {
            // Either .styleName and .className were explicitly passed in, or just one of the
            // properties was.
            // - respect the styleName passed in, if present, otherwise the className passed in
            var proto = this.getPrototype(),
                explicitStyle = (this.styleName != proto.styleName),
                explicitClassName = (this.className != proto.className);
            if (explicitStyle) this.className = this.styleName;
            else if (explicitClassName) this.styleName = this.className;
            // Both set on the prototype - respect the older .className attribute name
            else this.styleName = this.className;

        // .className property unset - just duplicate this.styleName
        } else {
            this.className = this.styleName;
        }
    // className set, but not styleName - copy it across
    } else if (this.className != null) {
        this.styleName = this.className;
    }

    // convenience for square components, only documented for Img/ImgButton
    if (this.size != null) this.height = this.width = this.size;

    // save the current width/height so we can tell if a width/height was
    // explicitly set, and default any dimensions that weren't set. Also, if
    // width or height are numeric strings, parse them to numbers. Since width
    // and height can be strings (e.g. "100%" or "*", they will deserialize as
    // strings even if numeric (e.g. "275"). However, it's more convenient to deal
    // with them as actual numbers in that case.
    this._userWidth = this.width = isc.NumberUtil.parseIfNumeric(this.width);
    this._userHeight = this.height = isc.NumberUtil.parseIfNumeric(this.height);

    if (this.width == null) this.width = this.defaultWidth;
    if (this.height == null) this.height = this.defaultHeight;

    // copy the height property to this._height.  This is what we'll rely upon internally
    // for sizing

    this._height = this.height;

    // Ensure margin / padding is a numeric value
    if (isc.isA.String(this.margin)) {
        var margin = parseInt(this.margin);
        if (isc.isA.Number(margin)) this.margin = margin;
        else {
            this.logWarn("Invalid setting for this.margin:" + this.margin +
                         ". This should be a numeric value - ignoring");
            this.margin = null;
        }
    }
    if (isc.isA.String(this.padding)) {
        var padding = parseInt(this.padding);
        if (isc.isA.Number(padding)) this.padding = padding;
        else {
            this.logWarn("Invalid setting for this.padding:" + this.padding +
                         ". This should be set to a numeric value - ignoring");
            this.padding = null;
        }
    }

    // Handle the case where a border was (incorrectly) specified as a number directly
    if (this.border != null && !isc.isA.String(this.border)) {
        this.border = this._convertBorderToString(this.border);
    }
    if (this.borderRadius != null && !isc.isA.String(this.borderRadius)) {
        this.borderRadius = this._convertBorderRadiusToString(this.borderRadius);
    }

    // resolve percentSource (if specified) to a widget, and observe it's inner size changing
    if (this.percentSource) this.setPercentSource(this.percentSource, true);

    // Call moveTo() and resizeTo() to resolve percentage positions and sizes to pixels.  If
    // coords are already numeric this is a no-op.
    // NOTE: if we have a parentElement, our percent size should be a proportion of it's size,
    // which we will only know when our parent draws us, so our parent tells us to
    // resolvePercentageSizes again right when we are about to draw().  However, if we delay
    // resolving this.width til draw:
    // - classes that override draw() won't support percent width automatically
    // - it won't be safe to manipulate this.width until right before draw (eg, for layout)
    //   - if you had to call getWidth(), you could at least get a correct value for widths
    //     that are a percentage of the page
    // For this reason child layout code should generally run from layoutChildren(), right
    // before drawChildren().
    this._canvas_initializing = true; // HACK to allow resized() notifications to be ignored
    this.resizeTo(this.width, this._height, undef, undef, "init");
    this.moveTo(this.left, this.top);
    this._canvas_initializing = null;

    // - Normalize children / peers properties into arrays
    if (this.children && !isc.isAn.Array(this.children)) this.children = [this.children];
    if (this.peers && !isc.isAn.Array(this.peers)) this.peers = [this.peers];

    // NOTE: we ensure a unique children Array via instantiateChildren.
    // The usage of declaring children as an instance prototype property is OK so long as the
    // children are specified as objects, not live Canvii, and none of classes involved assume
    // they have a unique copy of any shared subobjects.
    //if (this.children != null && this.children === this._scPrototype.children) {
        //this.logWarn("Detected children array as instance property")
        //this.children = this.children.duplicate();
    //}
    // We have a mechanism to avoid this - we could call 'registerDupProperty' to
    // register children as a special property for duplication (IE shallow cloning) in this
    // case - but we don't currently have a use case where this is required

    // If the deprecated 'enabled' property is set, set the disabled property to match it.

    if (this.enabled != this._$unset) {
        this.logWarn("Widget initialized with explicitly specified 'enabled' property. " +
                     "This property has been deprecated - use 'disabled' instead.");
        this.disabled = !this.enabled;
    }

    if (this.redrawOnEnable != null) {
        this.logWarn("Widget initialized with deprecated 'redrawOnEnable' - use 'redrawOnDisable' instead.");
        this.redrawOnDisable = this.redrawOnEnable;
    }

    if (this._needHideUsingDisplayNone()) {
        this._hideUsingDisplayNoneCounter = 1;
    }

    this._checkProportionalResizing();

    // call initWidget() to give each subclass of canvas a chance to initialize its child
    // structures
    this.initWidget(A,B,C,D,E,F,G,H,I,J,K,L,M);

    //>RoundCorners create a Canvas to show edges (eg rounded corners) around this Canvas
    this._createEdges();
    //<RoundCorners

    // automatically create a drop shadow
    if (this.showShadow) this._createShadow();

    //>CornerClips
    if (this.clipCorners) this._makeCornerClips(); //<CornerClips


    if (this.shouldUseBackMask()) {
        this.makeBackMask();
    }

    // Show group frame if appropriate
    if (this.isGroup) {
        this.isGroup = null;
        this.setIsGroup(true);
    }

    if (this.showTriggerArea) this._createTriggerArea();

    // Make sure each child and peer knows that it is not to auto-draw.
    // This prevents the children from drawing outside of our context.
    // Do this after initWidget so that if you add a new child it gets the proper setting.
    if (this.children) this.children.setProperty(this._$autoDraw, false);
    if (this.peers) this.peers.setProperty(this._$autoDraw, false);

    // if the canvas has a 'observes' property, set those observations up
    if (this.observes) {

        var item,
            source,
            list = this.observes,
            len = list.length;

        for (var i = 0; i < len; i++) {
            // get the next item in the list
            var item = list[i];
            if (!item) continue;
            // if item.source is a string, treat it as a reference to a global object
            //  and call getGlobalReference() to get the reference to the actual object
            if (isc.isA.String(item.source)) source = this.getGlobalReference(item.source);
            else                         source = item.source;

            // if the source was found, set up the observation
            if (source) {
                this.observe(source, item.message, item.action);
            }
        }
    }

    // create child instances (if necessary) and add them as children
    this._instantiateChildren();

    // set up the masterElement link for any initial peers
    if (this.peers != null) this.peers.setProperty(this._$masterElement, this);

    // if any autoChildren are speicified in the autoChildren array, add them via the
    // addAutoChild() mechanism
    if (this.autoChildren) this.addAutoChildren(this.autoChildren);

    // designated for us by skins and instances to add autoChildren to existing components.
    // Custom components should not use this.
    if (this.addOns) this.addAutoChildren(this.addOns);

    //>!BackCompat 2004.08.05
    if (this._adjacentHandle && !this.drawContext) {
        this.drawContext = { element : this._adjacentHandle };
    } //<!BackCompat

    if (this.htmlElement) {
        var element = this.htmlElement;
        delete this.htmlElement;
        this.setHtmlElement(element);
    }

    // If we have an eventProxy, add a pointer on that widget back to this one - used by EH.
    if (this.eventProxy != null) {
        if (!isc.isA.Canvas(this.eventProxy)) {
            this.logWarn("Canvas ID:'" +this.getID() + "' initialized with bad eventProxy. " +
                         "This property should be set to another Canvas instance. Clearing this property.")
            delete this.eventProxy;
        } else {
            if (this.eventProxy._proxiers == null) this.eventProxy._proxiers = [];
            this.eventProxy._proxiers.add(this);
        }
    }

    // Allow initialization of parentElement through parentCanvas.
    if (this.parentCanvas) {
        this.parentElement = this.parentCanvas;
    }

    // allow initialization of parentElement.
    // NOTE: needs to be done before autoDraw, and should probably be done after all of this
    // Canvii's children have been created
    var parentElement = this.parentElement;
    if (parentElement) {
        if (isc.isA.String(parentElement)) parentElement = window[parentElement];
        if (parentElement.children == null || !parentElement.children.contains(this)) {
            this.parentElement = null; // need to null parentElement or else addChild() will no-op
            parentElement.addChild(this);
        }
    }

    //>!BackCompat 2009.7.7
    // We created and exposed 'autoFetchAsFilter' for the 7.0 release candidate builds.
    // If specified use it to override autoFetchTextMatchStyle
    // databinding /
    if (this.autoFetchAsFilter != null) {
        var aftms = this.autoFetchAsFilter ? "substring" : "exact";
        this.logWarn("This component has autoFetchAsFilter explicitly specified as:" +
                    this.autoFetchAsFilter + ". This attribute is deprecated in favor of " +
                    "this.autoFetchTextMatchStyle. Defaulting autoFetchTextMatchStyle to \"" +
                    aftms + "\" based on this setting.");
        this.autoFetchTextMatchStyle = aftms;
    }
    //<!BackCompat


    // On init(), if we have a specified valuesManager, or a dataPath implying we should
    // attach to one, set that relationship up.
    // This is implemented in dataBoundComponent and will no-op in most cases
    this.initializeValuesManager();

    // panelHeader implementation
    if (this.showPanelHeader == true) {
        if (this.setupPanelHeader) this.setupPanelHeader();
        if (this.refreshPanelControls) this.refreshPanelControls();
    }

    // if we're supposed to autoDraw, and we don't have a parentElement already,
    //  draw us now.  This allows us to avoid sprinkling canvas.draw() commands
    //  in our XML or JS source.
    //
    // isc.noAutoDraw is a special internal flag to suppress autoDraw even for components that
    // explicitly request it - currently used in the ExampleViewer where we reparent components
    // as part of example loading.
    if (this.autoDraw && !this.parentElement && !isc.noAutoDraw) {

        if (isc.Browser.isSafari && !isc.Browser.isChrome &&
            isc.deferAutoDraw && !isc.Page.isLoaded() &&
            this.position != "relative")
        {
            isc.Page.setEvent("load", "if(window." + this.getID() + ")" + this.getID() + "._deferredAutoDraw()");
        } else {
            this.draw();
        }
    }

    if (this.showSnapGrid) {
        this._showSnapGrid();
    }

    var snapToAlign = this.childrenSnapAlign;
    if (this.editingOn && this.editProxy) {
        snapToAlign = this.editProxy.childrenSnapAlign;
    }

    if (snapToAlign) {
        this._initSnapAlign();
    }

    if (this.rulesEngine) this.rulesEngine.addMember(this);

},


_deferredAutoDraw : function () {
    if (this.destroyed || this.isDrawn()) return;
    this.draw();
},

//> @method canvas.initWidget()
//
// For custom components, perform any initialization specific to your widget subclass.
// <P>
// When creating a subclass of any Canvas-based component, you should generally override
// this method rather than overriding +link{Class.init()}.  This is because Canvas has its own
// +link{Class.init()} override which performs some generally desirable initialization - see
// +link{Canvas.init()} for details.
// <p>
// This method is called by +link{Canvas.init()} when a component is create()d.  When
// overriding this method, You must call the superClass initWidget implementation, like
// so:
// <pre>
//    this.Super("initWidget", arguments);
// </pre>
// <P>
// In general, if you are going to call functionality supported by your superclass (eg calling
// addTab() when your superclass is a TabSet), call Super() first.  However, you can generally
// assign properties to <code>this</code> before calling Super() as a way of mimicking the
// effect of the property being passed to +link{Class.create(),create()} on normal instance
// construction.  For example, when subclassing a DynamicForm, you could set this.items to a
// generated set of items before calling Super().
// <P>
// NOTE: child creation: if you are creating a component that auto-creates certain children (eg
// a Window which creates a Header child), typical practice is to create those children
// immediately before drawing by overriding draw().  This postpones work until it is really
// necessary and avoids having to update children if settings are changed between creation and
// draw().  Alternatively, if you prefer callers to directly manipulate auto-created children,
// it's best to create them earlier in initWidget(), in order to allow manipulation before
// draw.
//
// @param   [arguments 0-N] (any)   All arguments initially passed to +link{Class.create()}
//
// @visibility external
//<
initWidget : function () { },
_$initWidget : "initWidget", // for calling Super

//>EditMode
setID : function (id) {
    // leave the old global name intact so that generated expressions that depend on a stable
    // id (such as timers or page events) continue to work.  Adding an entry to pointersToThis
    // means we'll clean up our old name on destroy.  However this won't handle renaming a
    // widget to the old name of another, so this is strictly editMode.
    var pointersToThis = this.pointersToThis = this.pointersToThis || [];
    pointersToThis.add({ object: window, property: this.ID });

    this.ns.EH.changeClickMaskID(this.getID(), id);

    this.ID = id;

    // new global reference
    window[id] = this;

    // regenerate DOM, which may have inline event handlers pointing to our old ID
    this.clear(); this.draw();
},
//<EditMode

// recursively clear out all global references to a Canvas and it's children and peers.  Used
// when we want to destroy and recreate a component, and want to delay the destroy (for
// performance reasons), but need to avoid colliding on IDs as the new component is created.
// NOTE: may be imperfect if the target has a non-peer, non-child component that it creates
// with a predictable global ID.
clearIDs : function () {
    this.clear();

    window[this.ID] = null;

    if (this.children) {
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].clearIDs();
        }
    }
    if (this.peers) {
        for (var i = 0; i < this.peers.length; i++) {
            this.peers[i].clearIDs();
        }
    }
},

//> @method canvas.getByLocalId()
// Retrieve a child of this Canvas by it's +link{canvas.getLocalId,local ID}.
//
// @param localId (String) local ID of the Canvas
// @return (Canvas) the Canvas, or null if not found
// @visibility external
//<
getByLocalId : function( localId ) {


    if (this._localIds) {
        return this._localIds[localId];
    } else if (this._screen && this._screen._localIds) {
        return this._screen._localIds[localId];
    } else {
        return null;
    }
},

//> @method canvas.getLocalId()
// Retrieve the local ID of this canvas. If no local ID is assigned the normal
// canvas ID is returned making this method a safe replacement for +link{canvas.getID,getID()}.
// <p>
// A "local ID" is name for a child widget which is unique only for this parent, and not globally
// unique as is required for +link{Canvas.ID}.  Widgets receive local IDs when loaded via
// +link{RPCManager.loadScreen()} or +link{RPCManager.cacheScreens()} and
// +link{RPCManager.createScreen()}.
//
// @return (String) the local ID or standard ID of the Canvas
// @visibility external
//<
getLocalId : function () {
    return this._localId || this.getID();
},

// Drawn state
// --------------------------------------------------------------------------------------------

//> @method canvas.getDrawnState()
//      What state of drawing is this canvas in? Options:
//      - undrawn       :   has never been drawn or has been cleared
//      - drawingHandle :   in the process of drawing - handle not yet fully written out to the DOM
//      - handleDrawn   :   handle completely written out to the DOM, but children, peers etc. not drawn
//      - complete      :   fully drawn, including children, peers, etc.
//      @group  drawing
//
//<
getDrawnState : function () {
    // Note: In theory only one of the 3 possible drawing flags should be true at a time
    // (guaranteed if cavas.setDrawnState() is used to set the drawn state).
    // However, check them in reverse order from which they would be applied, in case
    // this._drawn gets set on drawing completion, but this._handleDrawn is not cleared at the same
    // time.
    if (this._drawn == true) return isc.Canvas.COMPLETE;
    if (this._handleDrawn == true) return isc.Canvas.HANDLE_DRAWN;
    if (this._drawingHandle == true) return isc.Canvas.DRAWING_HANDLE;
    return isc.Canvas.UNDRAWN;

},

//> @method canvas.setDrawnState()
//      Set state of drawing for this canvas.
//      This should be called rather than directly setting this._drawn, etc. flags.
//      Options:
//      - undrawn       :   has never been drawn or has been cleared
//      - drawingHandle :   in the process of drawing - handle not yet fully written out to the DOM
//      - handleDrawn   :   handle completely written out to the DOM, but children, peers etc. not drawn
//      - complete      :   fully drawn, including children, peers, etc.
//      @group  drawing
//
//<
setDrawnState : function (state) {
    if (state == isc.Canvas.COMPLETE) this._drawn = true;
    else this._drawn = false;

    if (state == isc.Canvas.HANDLE_DRAWN) this._handleDrawn = true;
    else this._handleDrawn = false;

    if (state == isc.Canvas.DRAWING_HANDLE) this._drawingHandle = true;
    else this._drawingHandle = false;

    // If state is isc.Canvas.UNDRAWN, no need to do anything as we will have already cleared
    // all the drawn flags
},


//> @method canvas.isDrawn()    ([])
//      Returns the boolean true, if the widget has been completely drawn, and false otherwise.
//  @visibility external
//  @group  drawing
//  @return (Boolean)   true if drawn, false if not drawn
//<
isDrawn : function () {
    return !!this._drawn;
},

handleDrawn : function () {
    return !!this._handleDrawn;
},

// ----------------------------------------------------------------------------------------

//> @method canvas.getID()  ([])
//      When a widget instance is created, it is assigned a unique global identifier that can be
//      used to access the instance by name. The getID method returns this ID for a particular
//      instance. Global IDs are essential when you need to embed a widget reference in a string,
//      usually a string that will be evaluated in the future and/or in another object, where you
//      may not have access to a variable or parameter holding the widget's reference.
//
//  @visibility external
//  @return (string)    global identifier for this canvas
//<
getID : function () {
    if (this.ID == null) this.ns.ClassFactory.addGlobalID(this);
    return this.ID;
},

// so that we look more like DOM objects
getAttribute : function (attributeName) { return this[attributeName] },

// Drawing
// --------------------------------------------------------------------------------------------

//> @method canvas.getInnerHTML() (A)
// Return the inner HTML for this canvas. Called when the canvas is drawn or redrawn;
// override to customize.
//
// @return (HTMLString) HTML contents of this canvas
// @group drawing
// @visibility external
//<

getInnerHTML : function (printCallback) {
    var html;
    if (!this.containsIFrame()) html = this.getContents();
    else {
        var url = this.getContentsURL();
        // support special prefixes, eg [APPFILES]
        url = isc.Page.getURL(url);
        // support params, actually doc'd under HTMLFlow only
        if (isc.rpc) url = isc.rpc.addParamsToURL(url, this.contentsURLParams);


        isc.EventHandler.registerMaskableItem(this, true);
        html = this.getIFrameHTML(url);
    }
    return html;
},

_getIFrameID : function () {
    return this._getDOMID("iframe");
},

getIFrameHTML : function (url) {

    return ("<iframe id='" + this._getIFrameID() +
            "' scrolling='" + (this.overflow == isc.Canvas.HIDDEN ? "no" : "auto") +
            "' width='" + this.getInnerContentWidth() +
            "' height='" + this.getInnerContentHeight() +
            "' frameborder='0' src='" + String.asAttValue(url) +"'></iframe>");
},

// In some browsers IFRAMEs with 100% are not sized correctly / don't react to resizes,
// so we we manually resize after draw and resize.

iFrameHeightAdjustment:0,
_sizeIFrame : function () {
    var drawnState = this.getDrawnState();
    if (drawnState != isc.Canvas.COMPLETE && drawnState != isc.Canvas.HANDLE_DRAWN) return;

    var handle = this.getHandle(),
        frameElement = handle ? handle.firstChild : null;
    // handle should be drawn so these sanity checks to get at the frame element may be
    // unnecessary.
    if (frameElement == null) return; // should never happen


    frameElement.style.height =
        (this.getInnerContentHeight() - this.iFrameHeightAdjustment) + isc.px;
},

// internal signature, allows timing all getInnerHTML overrides from the Canvas level
_getInnerHTML : function (printCallback) {
    if (isc._traceMarkers) arguments.__this = this;
    
    var self = this;
    var completeInnerHTMLFun = function completeInnerHTMLFun(HTML) {

        if (self._appendHTML) {
            var appendHTML = self._appendHTML.join(isc.emptyString);
            HTML = (HTML == null || HTML == isc.nbsp ? appendHTML : HTML + appendHTML);
        }
        if (printCallback != null) self.fireCallback(printCallback, "HTML", [HTML]);
        return HTML;
    };
    var HTML = this.getInnerHTML(completeInnerHTMLFun);
    if (HTML === false) {
        return false;
    } else {
        printCallback = null;
        return completeInnerHTMLFun(HTML);
    }
},

//> @method canvas.setSnapOffsetLeft()
// Setter for +link{Canvas.snapOffsetLeft}.
// @param snapOffsetLeft (Integer) new snapOffsetLeft value.
// @visibility external
//<
setSnapOffsetLeft : function (snapOffsetLeft) {
    var oldSnapOffsetLeft = this.snapOffsetLeft;
    this.snapOffsetLeft = snapOffsetLeft;
    if (oldSnapOffsetLeft != snapOffsetLeft) this._resolvePercentageSize();
},

//> @method canvas.setSnapOffsetTop()
// Setter for +link{Canvas.snapOffsetTop}.
// @param snapOffsetTop (Integer) new snapOffsetTop value.
// @visibility external
//<
setSnapOffsetTop : function (snapOffsetTop) {
    var oldSnapOffsetTop = this.snapOffsetTop;
    this.snapOffsetTop = snapOffsetTop;
    if (oldSnapOffsetTop != snapOffsetTop) this._resolvePercentageSize();
},

//> @method canvas.readyToDraw()
// Determines whether there's any reason why draw() should not proceed and draw the canvas at this
// time.  Logs errors and warnings if appropriate, so if you override draw() just add a check
// like:<br>
// &nbsp;&nbsp;if (!this.readyToDraw()) return this;
//      @group  drawing
//
//      @return (boolean)   True if draw() should proceed.
//<
readyToDraw : function () {

    // If we're already drawn, or in the process of drawing, log a warning and return false
    var drawingState = this.getDrawnState();
    if (this.getDrawnState() != isc.Canvas.UNDRAWN) {
        var drawingState = this.getDrawnState();

        this.logWarn("draw() called on widget with current drawn state: " + drawingState +
                     (drawingState == isc.Canvas.COMPLETE ?
                      ", use redraw() instead." : ", ignoring.") + this.getStackTrace(),
                     "drawing");
        return false;
    }

    // If showIf returns false, we're not ready to draw.
    // if showIf has not been overridden don't bother to evaluate it
    if (this.showIf != null) {
        // CALLBACK API:  available variables:  "canvas"
        // Convert a string callback to a function
        this.convertToMethod("showIf");

        // don't draw if the showIf returns false
        // (Will still draw if this function returns no explicit value - EG observation function /
        //  no-op function)
        if (this.showIf(this) == false) return false;
    }

    // refuse to draw if we have zero or negative area
    var width = this.getWidth(),
        height = this.getHeight();
    if (width <= 0 || height <= 0) {

        if (this._pendingPageResizeForZeroSize) {
            this._deferDrawForPageSize();
            return false;
        }

        // NOTE: drawing with negative area appears to work in all browsers, then in Nav4 you get
        // non-local partial failures
        //>DEBUG
        if (!isc.NativeScrollbar || !isc.isA.NativeScrollbar(this) || width < 0 || height < 0) {
            this.logWarn("negative or zero area: height: " + this.getHeight() + ", width: " + this.getWidth() +
                         ", refusing to draw" + this.getStackTrace(), "drawing");
        }
        //<DEBUG
        return false;
    }

    // If we have a pending delayed draw event, don't draw.
    // (NOTE: we could have this clear that event, and attempt to proceed instead, but
    //  the desired usage of the deferred draw feature is simply to delay drawing while it is
    //  not legal for some reason...
    //  If we instead wanted to have a draw occur on some other event like a click, we'd probably
    //  use a call to show() at the appropriate time instead).
    if (this.deferredDrawEvent != null) {
        //>DEBUG
        this.logInfo("draw() called while object already pending a delayed draw - no action to take",
                        "drawing");
        //<DEBUG
        return false;
    }

    // If we have a parent element:
    //
    // If the parentElement has written out it's start tag it's ok to proceed, as we'll
    // document.write() the child in the correct scope
    // If the parentElement has completely written out it's HTML, it's ok to proceed, as we'll
    // use the _insertHTML method to add the child to the parent using the DOM.
    //
    // If the parent has never drawn though we don't want to proceed, as we will either
    // document.write() into the wrong scope, or attempt to _insertHTML() into a non-existent handle
    if (this.parentElement != null &&
            (!isc.isA.Canvas(this.parentElement) ||
             this.parentElement.getDrawnState() == isc.Canvas.UNDRAWN) )
    {
        this.logWarn("Attempt to draw child of an undrawn parent - ignoring" +
                     this.getStackTrace(), "drawing");
        return false;
    }

    //>Safari
    if (isc.Browser.isSafari && !isc.Page.isLoaded()) {
        var safariVersion = isc.Browser.safariVersion;

        if (parseInt(safariVersion) < 100) {
            this.drawDeferred();
            return false;

        } else {
            // this hasn't been the case for quite some time - no longer makes sense to carp
            // about this
            /*
            if (!isc.Canvas._safariDeferDrawWarned) {
                isc.Canvas.logWarn(
                    "Isomorphic recommends drawing components after page load in Safari, as " +
                    "some sizing information may not be available until the page has " +
                    "completely loaded.  If you are encountering sizing issues for any " +
                    "component try setting 'autoDraw' to false, and setting up an event " +
                    "to draw the component on the Page level 'load' event.",
                    "drawing"
                );
                isc.Canvas._safariDeferDrawWarned = true;
            }
            */
        }
    }
    //<Safari

    // Otherwise it's ok to draw.
    return true;

},


// Both IE and Chrome can hit a case where on initial page render the
// page size isn't yet reported.
// In this case we delay draw of top level %-sized canvases using this method

_deferDrawForPageSize : function () {
    // If the page is already marked as loaded, draw on next idle loop
    if (isc.Page.isLoaded()) this.drawDeferred();
    else {
        // draw on, or after page load
        isc.Page.setEvent("load", this.getID() + "._fireDeferredDrawForPageResize()");

    }
},
_fireDeferredDrawForPageResize : function () {
    if (this.destroyed) return;

    // In Chrome we've seen the page size still be zero during the page.onload event handlers
    // In this case delay draw further

    if (isc.Page.getWidth() == 0 || isc.Page.getHeight() == 0) {
        this.delayCall("draw", null, 100);
    }
    else {
        this.draw();
    }

},

// determine whether the Canvas must draw via doc.write(), which is needed for Canvii created
// by isc.Canvas.start(), in order to allow any <SCRIPT> blocks embedded in their
// Canvas.contents to execute in IE.
// Automatically checks for situations where its impossible to use doc.write() (parent handle
// already drawn).
_mustDocumentWrite : function () {

    return false;
},
// determine whether a Canvas would like to draw via doc.write()
_requestsDocumentWrite : function () {
    // flag set by isc.Canvas.start()
    if (this._forceDocumentWrite) return true;

    // if a parent is in the middle of drawing via doc.write()ing, we have to draw via
    // doc.write() or we won't insert into the parent.  A parent will be forced to doc.write()
    // if any of its children must doc.write() - and once it's doc.write()ing, all its children
    // must do so - otherwise they'll crash while looking for the parent handle (which is only
    // partially written in this mode)
    var theParent = this.parentElement;
    while (theParent) {
        if (theParent._forceDocumentWrite) return true;
        theParent = theParent.parentElement;
    }

    // if we have any children, recursively, that need to document.write(), then we have to use
    // document.write()
    if (this.children) {
        //this.logWarn("checking children: " + this.children.getProperty("_forceDocumentWrite"));
        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i]._mustDocumentWrite()) return true;
        }
    }
    return false;
},

//> @method canvas.draw()   ([])
//      Draws the widget on the page.
//  @visibility external
//  @group  drawing
//  @return (canvas)    Pointer to this canvas.  Returned so statements like the following will
//                      work:<br>
//                          var myCanvas = Canvas.newInstance({...}).draw();
//<
//  "showing" parameter: if true, draw() was called from show().  By default draw() will call show()
//  on completion if the widget is visible as some widgets use show() as an entry point to
//  initialize certain widget properties.  If draw() was called from show(), always avoid calling
//  show() a second time.
draw : function (showing) {

    if (isc._traceMarkers) arguments.__this = this;
    // verifies that it is legal to draw
    if (!this.readyToDraw()) return this;



    // auto-assigned tab-index:
    // If this widget is focusable, getTagStart will call 'getTabIndex()' to determine the
    // tabIndex to write into the handle / focusProxy.
    // If this widget has no specified tabIndex, this method will auto-assign the next available
    // tab index to this widget.
    // The behavior this gives us is that focusable canvii with no specified tab index are
    // inserted into the tab order for the page in the order in which they are drawn, which
    // is appropriate.
    // We make any widgets showing scrollbars focusable by default.  If a widget has
    // overflow:auto, however we don't know whether it will be scrollable until it has been
    // drawn and adjustOverflow gets fired.  This can happen on a delay / after page load in
    // some browsers, so that widget will end up at the end of the page's tab order rather than
    // at the expected position.
    // Avoid this issue by calling 'getTabIndex()' on draw() for any overflow:auto widgets to
    // ensure auto-allocated tab-indices are allocated in the order in which these are drawn
    // onto the page.

    if (this.overflow == isc.Canvas.AUTO) this.getTabIndex();

    //>DEBUG
    if (this.logIsInfoEnabled(this._$draws)) {
        this.logInfo("draw(): drawing " + this.Class +
                     (this.parentElement ? " with parent: " + this.parentElement : "") +
                     (!isc.Page.isLoaded() ? " before page load" : "") +
                     (this.logIsDebugEnabled(this._$draws) ? this.getStackTrace() : ""),
                     this._$draws);
    }
    // track total draws
    this._addStat(this._$draws);

    //<DEBUG

    // Determine ruleScope on first draw if needed.
    // Must be done before children are drawn.
    if (!this._ruleScopeComputed) {
        // Save ruleScope
        this.ruleScope = this.getRuleScope();

        // Record this component if a DBC
        if (isc.isA.DataBoundComponent(this)) {
            var component = this.getRuleScopeComponent();
            if (component) {
                if (!component._ruleScopeDBCs) component._ruleScopeDBCs = [];
                component._ruleScopeDBCs.add(this);
            }
        }

        this._ruleScopeComputed = true;
    }

    // If we are databound, and autoFetchData is true, do a one time fetch on initial draw.
    var fetchQueued = this.doInitialFetch();

    // If we have any peers, call the 'predrawPeers()' method.
    // This method will draw any peers marked with the "_drawBeforeMaster" flag (set up by passing
    // a parameter to addPeer()), before continuing with the drawing process.
    // We do this because it allows developers to specify some peers to be drawn before the master
    // gets drawn, when the master is controlling the drawing of the peers.
    // This is valuable in some cases as the master is guaranteed that such preDraw peers will be
    // drawn while its own draw() is firing - for example this is used in stretchImgButtons, where
    // the getInnerHTML() method makes use of the drawn size of the label (peer) for the button
    // to determine the desired size of the images.
    // See the methods:
    //  predrawPeers(), drawPeers(), redrawPredrawnPeers(), redrawPeers() and addPeer()
    if (this.peers != null && this.peers.getLength() > 0) {


        this.predrawPeers();

    }


    var fixOpacity = (isc.Browser.isIE && this.fixIEOpacity && !this.masterElement),
        shouldCacheOffsetCoords = isc.Element.cacheOffsetCoords,
        shouldDisableOffsetCoordsCaching = this.parentElement != null && this.parentElement._offsetCoordsCacheDisabled;

    if (this.position == isc.Canvas.RELATIVE) {
        shouldCacheOffsetCoords = false;
    }

    if (fixOpacity || shouldCacheOffsetCoords) {
        var parent = this.parentElement;
        while (parent != null) {
            if (parent.opacity != null && parent.opacity != 100) {
                //this.logWarn("opacity set on parent: " + parent);
                this.setOpacity(100, null, true);
                fixOpacity = false;
                if (!shouldCacheOffsetCoords) break;
            }
            if (parent.position == isc.Canvas.RELATIVE) {
                shouldCacheOffsetCoords = false;
                if (!fixOpacity) break;
            }

            parent = parent.parentElement;
        }
    }


    if (shouldDisableOffsetCoordsCaching) {
        this._$leftCoords = this._$topCoords = null;
        this._offsetCoordsCacheDisabled = true;
        this._origCacheOffsetCoords = shouldCacheOffsetCoords;
        this.cacheOffsetCoords = false;
    } else {
        this._offsetCoordsCacheDisabled = false;
        this.cacheOffsetCoords = shouldCacheOffsetCoords;
        delete this._origCacheOffsetCoords;
    }

    // if this.htmlElement and this.matchElement are set, resize the canvas to fit the
    // target element before drawing
    if (this.htmlElement != null && this.matchElement) {
        if (isc.isA.String(this.htmlElement)) this.htmlElement = isc.Element.get(this.htmlElement);

        // We want the available inner width of the element.

        // For things that don't overflow this will be the specified width or, if there isn't
        // one, the clientWidth - padding

        var width = isc.Element.getNativeInnerWidth(this.htmlElement),
            height = isc.Element.getNativeInnerHeight(this.htmlElement);
        this.setWidth(width);
        this.setHeight(height);
    }



    var parentElement = this.parentElement;
    var mustDocumentWrite =
        // the page is not loaded
        (!isc.Page.isLoaded() &&
         // if this widget is going to draw at a specified, pre-existing position in the DOM,
         // it needs to do DOM insertion, not document.write()
         !this.drawContext &&
         // this Canvas is relative and has no parent, hence needs to doc.write() HTML at
         // the current document position.  Note that children of a relatively positioned
         // parent insert into the parent via DOM insertion, not doc.write()
         (parentElement == null && this.position == isc.Canvas.RELATIVE)
        );


    mustDocumentWrite = mustDocumentWrite || this._mustDocumentWrite();



    // Determine whether we should insert innerHTML as a separate commit.  This allows children
    // to be drawn before, during or after innerHTML generation.
    var separateContentInsertion = this.separateContentInsertion;

    if (isc.Page.isLoaded() || !mustDocumentWrite) {



        this._insertHTML(!separateContentInsertion);



        if (separateContentInsertion) this._updateParentHTML();

        this.drawChildren();


        this._completeHTMLInit();


    } else {


        var parent = this.parentElement;

        // detect the case of getting fooled about whether the page is loaded and fix it in
        // IE, warning for other browsers.
        if ((isc.Browser.isOpera || isc.Browser.isIE) && this.getDocument().readyState == "complete")
        {
            isc.Page.finishedLoading();

        }


        this._writeHTML();


    }

    // If we queued the fetch, lets send it off now.  Note this is *after* children have drawn,
    // hence naturally combines the initial fetches of any hierarchy of databound widgets.
    if (fetchQueued) isc.RPCManager.sendQueue();

    //>FocusProxy If we're using a focusProxy, create it now
    if (this._useFocusProxy && this._canFocus()) this.makeFocusProxy();
    //<FocusProxy


    if (this.accessKey != null && this._useAccessKeyProxy() && this._canFocus()) {
        this._makeAccessKeyProxy();
    }

    // If we're enforcing scroll size, ensure the scroll-size-enforcer div is present
    if (this._enforcingScrollSize != null)
        this.enforceScrollSize(this._enforcingScrollSize[0], this._enforcingScrollSize[1]);

    // If we're masked by a hard clickmask, ensure EH takes the necessary
    // action to physically mask us

    if (this._isHardMasked()) isc.EH._hardMaskTargets([this]);

    //>CornerClips
    if (this.clipCorners) this._finishCornerClips(); //<CornerClips




    // set up the _currentlyVisible flag so we fire visibilityChanged at the right times.
    // (That notification is suppressed while we're undrawn)
    this._currentlyVisible = this.isVisible();
    // At this point we've written out the HTML into the DOM.
    // If the widget is visible, call show() on it; certain widgets override show() to do
    // perform miscellaneous tasks associated with displaying the widget - we would want to
    // perform these when the widget is drawn, too

    if (!showing && this._currentlyVisible) this.show();
    // for uses like Canvas.draw().moveTo(...)



    // notify parent / masterElement that we've been drawn
    if (this.parentElement) this.parentElement.childDrawn(this);
    if (this.masterElement) this.masterElement.peerDrawn(this);

    // If we're a top level canvas and our bottom / right exceed the edges of the browser
    // viewport, we effectively change the size of the window.
    // We don't get a native browser resize notification on this, so
    // explicitly run the _pageResize() method now.
    // We also do this on moved / resized for top level canvii.
    if (this.parentElement == null && isc.Page.isLoaded() && !isc.Page.pollPageSize)
    {
        if (this.getPageRight() >= isc.Page.getWidth() ||
            this.getPageBottom() >= isc.Page.getHeight())
        {
            isc.EH.fireOnPause("checkForBodyOverflowChange",
                                {target:isc.Canvas, methodName:"checkForPageResize"},
                                100);
        }
    }


    // If we're relatively positioned, and we're a top level canvas, fire moved() on page
    // resize to allow our peers to reposition themselves
    // Note: this initial setup needs to fire on draw even if the widget is not visible
    // as our peers still need to be informed of when the masterElement moves.
    if (this.parentElement == null && this.position == this._$relative) {
        // remember our current page coordinates
        this._preResizePageLeft = this.getPageLeft();
        this._preResizePageTop = this.getPageTop();
        isc.Page.setEvent(
            "resize",
            this,
            isc.Page.FIRE_ONCE,
            "_relativePageResized"
        );
    }

    if (this.useDragMask) {
        isc.EH.registerMaskableItem(this, true);
    }






    this.onDraw();

    //>EditMode
    if (this.editProxy && this.editingOn) {
        if (this.editProxy.hasEditMask()) this.editProxy.showEditMask(this.parentElement);
        if (this.editContext.isComponentSelected(this)) this.editContext.refreshSelectedAppearance(this);
    }
    //<EditMode

    // Create *When rules if needed
    this._createCanvasWhenRules();

    // For a non-DBC with *When rules we need to make sure the RulesEngine processes
    // rules at least once initially. This is an issue if RuleContext contributors
    // are drawn first and no additional context changes occur to trigger the rules.
    if (!isc.isA.DataBoundComponent(this) && this.rulesEngine) {
        this.rulesEngine.processContextChanged();
    }

    // If we're overflow visible and we've overflowed, fire the _resized notification

    if (!this._deferredOverflow && this.overflow == isc.Canvas.VISIBLE) {
        var visWidth = this.getVisibleWidth(),
            visHeight = this.getVisibleHeight(),
            w = this.getWidth(), h = this.getHeight();

        if (visWidth > w || visHeight > h) {
            this._resized(visWidth - w, visHeight - h, "Overflow on initial draw");
        }
    }
    return this;
},

// Add dataSource prefix to fields in advancedCriteria

_globalizeWhenAdvancedCriteria : function (criteria) {
    var fieldPrefix = (this.hasStableLocalID()
            ? this.getLocalId() + ".values."
            : (this.dataSource ? this.getDataSource().ID + "." : null));
    if (!fieldPrefix) return;

    if (criteria.fieldName && !criteria.fieldName.contains(".") && !criteria.fieldName.contains("/")) {
        criteria.fieldName = fieldPrefix + criteria.fieldName;
    }
    if (criteria.valuePath && !criteria.valuePath.contains(".") && !criteria.valuePath.contains("/")) {
        criteria.valuePath = fieldPrefix + criteria.valuePath;
    }
    if (criteria.criteria) {
        var innerCriteria = criteria.criteria;
        if (isc.isAn.Array(innerCriteria)) {
            for (var i = 0; i < innerCriteria.length; i++) {
                this._globalizeWhenAdvancedCriteria(innerCriteria[i]);
            }
        } else {
            this._globalizeWhenAdvancedCriteria(innerCriteria);
        }
    }
},


onDraw:function () {
},

// empty implementation overridden by DBC
doInitialFetch : function () {},

// output this widget's HTML via document.write()
_writeHTML : function () {

    // mark that we've started drawing the handle - this allows us to detect recursive calls to
    // draw() and other invalid cases.
    this.setDrawnState(isc.Canvas.DRAWING_HANDLE);

    var doc = this.getDocument(),
        separateContentInsertion = this.separateContentInsertion;

    if (this.children != null && this._mustDocumentWrite()) {
        // now that the parent is using doc.write(), all children must do so as well,
        // regardless of whether the children are marked _forceDocumentWrite - otherwise
        // they'll try to look up our handle for insertAdjacentHTML() and fail because it'll
        // only be partially written.
        this._forceDocumentWrite = true;

        //this.logWarn("using legacy doc.write() path");

        var tagStart = this.getTagStart(),
            tagEnd = this.getTagEnd();
        doc.write(separateContentInsertion ? tagStart : tagStart + this._getInnerHTML())
        this.drawChildren();
        doc.write(separateContentInsertion ? this._getInnerHTML() + tagEnd : tagEnd);

        // Mark that we've finished drawing the handle into the DOM
        this.setDrawnState(isc.Canvas.HANDLE_DRAWN);

    } else {

    // write the complete parent handle into the DOM, then have children, if any, insert into
    // completed handle
    doc.write(
        isc.SB.concat(this.getTagStart(),
                      (separateContentInsertion ? null : this._getInnerHTML()),
                      this.getTagEnd()
        )
    );

    // Mark that we've finished drawing the handle into the DOM
    this.setDrawnState(isc.Canvas.HANDLE_DRAWN);

    // if we are separately inserting content, insert the parent's content now.  Note that it
    // is legal for some children to get manually drawn at this point, which allows parents to
    // write out content that is dependent on child sizes.
    if (separateContentInsertion) this._updateParentHTML();

    // draw children if we have any
    this.drawChildren();

    }

    // call completeHTMLInit to draw peers, set up events, adjustOverflow, and mark us as
    // completely drawn
    this._completeHTMLInit();


    if (isc.Browser.isMoz && this.getScrollingMechanism() == isc.Canvas.NATIVE)
        this.checkNativeScroll();

    // return a pointer to the object
    return this;
},

// Draw after a pause (by default on page load or the next idle)
// Holds onto the deferred draw event as this.deferredDrawEvent, so you can keep track of
// cases where we're waiting to draw, and do the appropriate thing with calls to clear, etc.

drawDeferred : function () {

    var eventType = (isc.Page.isLoaded() ? "idle" : "load");

    if (this.deferredDrawEvent != null) {
        this.logInfo("drawDeferred() called when object is already pending drawing " +
                        "- No action to take.");

        return;
    }

    var ID = this.getID();

    this.deferredDrawEvent =
            isc.Page.setEvent(eventType,
                              "delete " + ID + ".deferredDrawEvent;" + ID + ".draw();",
                              isc.Page.FIRE_ONCE);
},

// Printing
// --------------------------------------------------------------------------------------------



//> @groupDef printing
// The browser's built-in support for printing will at best print what you see, which in the
// case of a web application will often be useless, illegible, or partial.
// <P>
// SmartClient has specialized printing support that can take any page built with SmartClient
// components and provide a reasonable printed view.  The default printed view:
// <P>
// <ul>
// <li> renders components without clipping or scrolling regions, so that a scrolling grid
// shows all loaded rows
// <li> removes certain decorative images, such as image-based backgrounds, which may print
// poorly in black and white
// <li> converts editing controls into static representations of the data being edited
// <li> removes interactive elements such as buttons and menus, which don't work on paper and
// waste space
// </ul>
// The default printed view can be customized with settings and method overrides as necessary,
// including the ability to created printed representations of custom components you have
// created.
// <P>
// For simple, built in printing support, see the +link{Canvas.showPrintPreview()} and
// +link{Canvas.getPrintPreview()} APIs, or for finer grained control developers may call
// +link{canvas.getPrintHTML()} directly and work with the +link{PrintCanvas}
// or +link{PrintWindow} class.
// <P>
// Note that the +link{CubeGrid} component does not currently support WYSIWYG
// printing (as documented +link{CubeGrid.getPrintHTML,in that class}).
//
// @title Printing
// @visibility external
//<

//> @attr canvas.printChildrenAbsolutelyPositioned (Boolean : false : IRWA)
// Should this canvas print its children absolutely positioned when generating
// +link{classMethod:canvas.getPrintHTML(),printable HTML}.
// <P>
// By default explicitly specified absolute positioning and sizing is ignored when generating
// print HTML. This is done intentionally: there is no way for the framework to predict how
// explicit sizes will translate to a the printed page and if HTML for printing includes
// the same absolute positioning and sizing as is displayed within an application it is very
// common to encounter undesirable effects, such as seeing tables get broken over several
// pages horizontally when there is enough room to print them on a single page of paper.
// <P>
// In some cases, however, a developer may wish to have explicit sizing and positioning
// respected within the print-view.
// Setting this attribute to <code>true</code> will cause this to occur.
//
// @group printing
// @visibility external
//<

//> @method canvas.getPrintHTML() [A]
// Retrieves printable HTML for this component and all printable subcomponents.
// <P>
// By default any Canvas with children will simply collect the printable HTML of its children
// by calling getPrintHTML() on each child that is considered +link{canvas.shouldPrint,printable}.
// If a callback is provided, then null is always returned and the callback is fired asynchronously.
// <P>
// If overriding this method for a custom component, you should <b>either</b> return a String
// of printable HTML directly <b>or</b> return null and fire the provided callback using
// +link{Class.fireCallback}.
// <P>
// To return an empty print representation, return an empty string ("") rather than null.
// <P>
// The <code>printProperties</code> argument, if passed, must be passed to any subcomponents on
// which <code>getPrintHTML()</code> is called.
// <P>
// Default implementation will set +link{canvas.isPrinting} flag to <code>true</code> to indicate
// printing is in progress, and clear this flag when the printing has completed (possibly via
// an asynchronous callback).
// <P>
// <B>NOTE:</B> Expecting a direct return value from the default implementation is deprecated usage.
// This is because small changes to an application (such as adding a few more data points to a chart
// or adding another button) or using certain browsers can make it necessary to generate the HTML
// asynchronously. Thus, application code should not rely on the return value and always pass
// a callback.
//
// @param [printProperties] (PrintProperties) properties to configure printing behavior - may be null.
// @param [callback] (Callback) optional callback. This is required to handle cases where HTML
//                  generation is asynchronous - if a method generates HTML asynchronously, it should return
//                  null, and fire the specified callback on completion of HTML generation. The
//                  first parameter <code>HTML</code> should contain the generated print HTML.
//                  The callback is only called if null is returned. Furthermore, the default
//                  getPrintHTML() implementation always returns null and fires the callback
//                  when a callback is provided.
// @return (HTMLString) null if the print HTML is being generated asynchronously and/or a callback
// is provided; otherwise, the direct print HTML for this component (but note that returning
// direct print HTML is a deprecated feature).
// @group printing
// @visibility external
//<
_$html:"html",
getPrintHTML : function (printProperties, callback) {
//!DONTOBFUSCATE  (obfuscation breaks the inline function definitions)

    var haveUserCallback = callback && !(isc.isAn.Object(callback) && callback._isInternal);

    this.isPrinting = true;
    // Always copy this.printProperties onto the printProperties block passed in
    // [Allows you to always suppress controls for certain components only, etc.]
    printProperties = isc.addProperties({}, printProperties,this.printProperties);
    // store the top level canvas so we know not to writing out positioning info
    // for it.
    if (printProperties.topLevelCanvas == null) {
        printProperties.topLevelCanvas = this;
        printProperties.isDrawn = this.isDrawn();
        printProperties.isVisible = this.isVisible();
    }

    // omitControls / includeControls
    // omitControls is an array of widget classes which should be ommitted as they are
    // controls.
    // By default all subclasses of these controls will also be ommitted - however we can
    // override that behavior by including a subclass in the 'includeControls' array
    if (printProperties.omitControls == null)
        printProperties.omitControls = isc.Canvas.printOmitControls;
    if (printProperties.includeControls == null)
        printProperties.includeControls = isc.Canvas.printIncludeControls;

    // pick up the abs-pos flag (set by our parent if we are to be absolutely positioned)
    var absPos = printProperties.absPos;
    this.currentPrintProperties = printProperties;
    var HTML = [this.getPrintTagStart(absPos), , , this.getPrintTagEnd(absPos)];

    var wentAsync = false;

    var self = this;
    var continuePrintHTMLFun = function continuePrintHTMLFun(printInnerHTML) {
        HTML[1] = printInnerHTML;

        // Not all print properties should be passed onto our children.
        // clear the "inline" setting before passing the printProperties block on.
        delete printProperties.inline;

        // set the abs-pos flag so our children render out absolutely positioned within us.

        printProperties.absPos = self.printChildrenAbsolutelyPositioned;

        // clear up any gaps etc in the user-defined omitComponents block
        if (printProperties.omitComponents) {
            var omitComponents = printProperties.omitComponents
            for (var i = 0; i < omitComponents.length; i++) {
                if (isc.isA.String(omitComponents[i]))
                    omitComponents[i] = window[omitComponents[i]];
                if (!isc.isAn.Instance(omitComponents[i])) omitComponents[i] = [];
            }
            omitComponents.removeEmpty();
        }

        var children = self.getPrintChildren();

        var completePrintHTML = function completePrintHTML(childrenHTML) {
            // pass the closure vars through to the completePrintHTMLCallback method
            return self.completePrintHTMLCallback(childrenHTML, HTML, wentAsync, callback);
        };

        if (children != null && children.length > 0) {
            var childrenHTML = [],
                childCount = children.length,
                completedCount = 0;

            var childHTMLComplete = function childHTMLComplete(childIndex, html) {
                childrenHTML[childIndex] = html;
                ++completedCount;
                //self.logDebug("Child: " + childIndex + " - " + completedCount + "/" + childCount);
                if (completedCount == childCount) {
                    return completePrintHTML(childrenHTML);
                }
            };

            var thisHTML = null;
            for (var i = 0; i < childCount; i++) {
                var child = children[i];

                //this.logDebug("HTML for child: " + i);

                // assembly body string to hard-code index of HTML insertion point to ensure
                // correct order
                var func = (function (i) {
                    return function (html) {
                        return childHTMLComplete(i, html);
                    }
                })(i);

                // ask child to generate HTML and pass optional async callback
                var childHTML = self.getChildPrintHTML(child, printProperties, func);

                // child didn't go async, so it won't be calling its async callback and we need
                // to do it.
                if (childHTML != null) {
                   //this.logDebug("child: " + i + " returned HTML synchronously");
                   thisHTML = childHTMLComplete(i, childHTML);

                // child went async
                } else {
                    //this.logDebug("child: " + i + " went async -> " + child.getID());
                    wentAsync = true;
                }
            }

            if (wentAsync || haveUserCallback) {
                return null;
            } else {
                return thisHTML;
            }
        } else {
            // no children, finish up
            return completePrintHTML();
        }
    };

    // Omit content if we have children (matches standard rendering behavior)
    // - Check this.children - this may include children (such as controls) which are omitted from
    //   the print children [but still mean the content needs to be rendered]
    if (!this.children || this.children.length == 0 || this.allowContentAndChildren) {
        var printInnerHTML = this.getPrintInnerHTML(continuePrintHTMLFun);
        if (printInnerHTML == null) {
            wentAsync = true;
            return null;
        } else {
            return continuePrintHTMLFun(printInnerHTML);
        }
    } else {
        return continuePrintHTMLFun();
    }
},

getChildPrintHTML : function (child, printProperties, callback) {
    return child.getPrintHTML(printProperties, callback);
},

//> @attr canvas.isPrinting (Boolean : false : R)
// This boolean flag will be set to true by framework logic while generating print HTML
// for this widget as a result to a call to +link{Canvas.showPrintPreview()}
// (or just +link{Canvas.getPrintHTML()}). Note that this flag is set recursively as
// parent widgets generate print HTML for their children.
// <P>
// This is a read-only property and should not be modified by application code.
// @visibility external
//<
isPrinting:false,

// This is a callback fired once we've got printHTML for all our children stuffed into
// an array.
// Either returns the HTML or fires the original print callback
completePrintHTMLCallback : function (childrenHTML, HTML, wentAsync, callback) {
    this.isPrinting = false;

    HTML[2] = this._joinChildrenPrintHTML(childrenHTML);
    HTML = HTML.join(isc.emptyString);

    if (this.currentPrintProperties) delete this.currentPrintProperties.absPos;
    delete this.currentPrintProperties;

    // If printHTML generation went asynchronous or a callback was provided, then fire
    // the provided callback in a timeout. This resets the stack and makes the closures
    // and other temporary objects eligible for garbage collection.
    if (wentAsync || callback != null) {
        this.delayCall("fireCallback", [callback, "HTML,callback", [HTML, callback]]);
        return null;

    } else {
        if (!isc.Canvas._loggedGetPrintHTMLDeprecatedUsageWarning) {
            isc.logWarn("Expecting a direct return value from getPrintHTML() is deprecated. " +
                         "The recommended usage is to pass a callback always. See the documentation " +
                         "for more information on the reason for always passing a callback.");
            isc.Canvas._loggedGetPrintHTMLDeprecatedUsageWarning = true;
        }
        return HTML;
    }
},

_joinChildrenPrintHTML : function (childrenHTML) {
    if (isc.isAn.Array(childrenHTML)) childrenHTML = childrenHTML.join(isc.emptyString);
    return childrenHTML;
},


_$nbsp:isc.nbsp,
getPrintInnerHTML : function (callback) {

    var self = this;
    var completePrintInnerHTMLFun = function completePrintInnerHTMLFun(HTML) {
        var hasChildren = self.children != null && self.children.length > 0;
        // allowContentAndChildren is now true by default but typically widgets will have no
        // content (actually &nbsp;). Don't write out this character if the widget also has children.
        // Since print views render children stacked up, relying on normal relative positioning, it'll
        // introduce odd blank lines.
        if (hasChildren && HTML == self._$nbsp) HTML = isc.emptyString;
        if (callback != null) self.fireCallback(callback, "HTML", [HTML]);
        return HTML;
    };
    var HTML = this._getInnerHTML(completePrintInnerHTMLFun);
    if (HTML === false) {
        return null;
    } else {
        callback = null;
        if (HTML == null) HTML = isc.emptyString;
        return completePrintInnerHTMLFun(HTML);
    }
},

// getPrintChildren() -- returns the set of children we will include in our printHTML
// Split into a separate method for ease of overriding
getPrintChildren : function () {
    var children = this.children;
    if (!children || children.length == 0) return;
    var printChildren = [];
    for (var i = 0 ; i < children.length; i++) {
        if (this.shouldPrintChild(children[i])) printChildren.add(children[i]);
    }
    return (printChildren.length > 0) ? printChildren : null;
},

//> @attr canvas.shouldPrint (boolean : null : IRW)
// Whether this canvas should be included in a printable view.
// <P>
// Default is to:
// <ul>
// <li> omit all peers (edges generated by showEdges:true, etc)
// <li> omit anything considered a "control", such as a button or menu (see
// +link{PrintProperties.omitControls})
// <li> include everything else not marked shouldPrint:false
// </ul>
//
// @group printing
// @visibility external
//<

// shouldPrintChild - called by getPrintChildren() to determine which children need printing
shouldPrintChild : function (child) {

    if (child.shouldPrint != null) return child.shouldPrint;

    // omit peers for now to suppress edges, backmask, etc.
    if (child.masterElement) return false;

    var printProperties = this.currentPrintProperties,
        omitControls = printProperties.omitControls,
        omitComponents = printProperties.omitComponents;

    if (!isc.isAn.Instance(child) ||
        (omitComponents && omitComponents.contains(child)))
    {
        return false;
    }
    // omitControls is an array of widget classNames to skip
    if (omitControls) {
        // exception, if control is present in "includeControls" array, don't skip it. This is
        // useful for cases where we have a specific subclass of an ommitted controls class which
        // we want to include

        var includeControls = printProperties.includeControls;
        if (includeControls && includeControls.length > 0) {
            for (var i = 0; i < includeControls.length; i++) {
                var cName = includeControls[i];
                if (isc.isA[cName] && isc.isA[cName](child)) return true;
            }
        }
        for (var i = 0; i < omitControls.length; i++) {
            var cName = omitControls[i];
            if (isc.isA[cName] && isc.isA[cName](child)) {
                return false;
            }
        }
    }

    // If a developer calls getPrintHTML() on something undrawn or hidden directly we should
    // respect it. However if the method is called on a parent with undrawn/hidden children
    // we should skip the children by default.
    if ((!child.isDrawn() && printProperties.isDrawn) ||
         (!child.isVisible() && printProperties.isVisible)) return false;

    return true;
},

// _fixPNG() -- apply the .png workaround in IE.
// Will only be called if _fixPNG() is true at the Canvas level - allows us to disable
// the png workaround for specific canvii on the fly (EG when printing)
_fixPNG : function () {
    if (this.isPrinting) return false;
    return true;
},

getPrintStyleName : function () {
    return this.printStyleName || this.styleName;
},

// getPrintTagStart / end -- returns the DIV / SPAN tags written out around our HTML in printing
// mode.
getPrintTagStart : function (absPos) {
    var props = this.currentPrintProperties,
        topLevel = props.topLevelCanvas == this,
        inline = !topLevel && !absPos && props.inline,
        className = this.getPrintStyleName();

    var groupTagStart;
    if (this.isGroup) {
        groupTagStart = this.getPrintHTMLTagStart();
    }

    return [groupTagStart, (inline ? "<span " : "<div "),
            (className ? "class='" + className + "' " : null),
            // could add borders etc here
            this.getPrintTagStartAttributes(absPos),
            ">"].join(isc.emptyString);
},

// If the widget is marked as a group, write "fieldset" tags around the print HTML DIV
// element - this basically matches the appearance of a group.
getPrintHTMLTagStart : function () {
    var groupTagStart = "<fieldset>";
    if (this.groupTitle != null) {
        groupTagStart += "<legend>" + this.groupTitle + "</legend>";
    }
    return groupTagStart;
},

getPrintHTMLTagEnd : function () {
    return "</fieldset>";
},


getPrintTagStartAttributes : function (absPos) {
    if (absPos) {
        return " style='position:absolute;left:" + this.getLeft() + "px;top:"
                + this.getTop() + "px;width:" + this.getWidth() + "px;height:"
                + this.getHeight() + "px;' ";
    // If we have absolutely positioned children:
    // - we're going to have to be relatively positioned so the abs-pos children are
    //   rendered within us
    // - we're going to have to have explicit sizing so we take up the right amount of space
    //   in document flow.
    // Handle this by writing out width/height set as calculated scrollWidth/height.

    } else if (this.printChildrenAbsolutelyPositioned) {
        return " style='position:relative;width:" + this.getScrollWidth() +
                "px;height:" + this.getScrollHeight() + "px;background-color:lightblue;' ";
    }

    return null;
},

getPrintTagEnd : function (absPos) {
    var props = this.currentPrintProperties,
        topLevel = props.topLevelCanvas == this,
        inline = !topLevel && !absPos && props.inline;

    var groupTagEnd;
    if (this.isGroup) {
        groupTagEnd = this.getPrintHTMLTagEnd();
    }

    var endTag = (this.wrap == false) ? "</div>" : inline ? "</span>" : "</div>";
    if (this.isGroup) endTag += groupTagEnd;
    return endTag;
},


// Backmask
// --------------------------------------------------------------------------------------------

//>BackMask

// Should we use a backMask
shouldUseBackMask : function () {
    if (!this.useBackMask) return false;
    if (isc.Browser.isIE && isc.Browser.minorVersion < 5.5) return false;
    if (!isc.Canvas.useMozBackMasks && isc.Browser.isMoz) return false;
    return true;
},


makeBackMask : function (props) {
    // in Moz, defer backmask creation until page load.  Otherwise the pre-page load heuristics
    // kick in for the iframe, causing crazy rendering (iframe burns through what it's supposed
    // backmask)
    if (isc.Browser.isMoz && !isc.Page.isLoaded()) {
        this._deferredBackMaskProps = props;
        isc.Page.setEvent("load", this, isc.Page.FIRE_ONCE, "makeBackMask");
        return;
    }
    // Note: there's code in BrowserPlugin.draw() that somewhat hackishly reaches into the
    // _deferredBackMaskProps, so be careful if you make changes to this.
    if (this._deferredBackMaskProps) {
        props = this._deferredBackMaskProps;
        delete this._deferredBackMaskProps;
    }
    this._backMask = isc.BackMask.create(props);
    this.addPeer(this._backMask);
    this._backMask.setZIndex(this.getZIndex(true)-2);
    this._sizeBackMask();
},
//<BackMask

// Focus Proxy
// --------------------------------------------------------------------------------------------



//>FocusProxy create the focusProxy to manage focus for this Canvas
makeFocusProxy : function () {
    // This is actually an almost trivial wrapper for _makeFocusProxy, allowing us to set a
    // '_makingFocusProxy' flag on this widget, and clear it on return, without having to clear
    // it in every possible return case from the function that does the work

    // Bail if
    // - we're not using focusProxies on this element
    // - we already have a focusProxy written into the DOM
    // - we're already running this method (so a call to getTabIndex() or something else fell back
    //   through to this method)
    // - we're not drawn
    // - we're waiting to create a f.p on page load
    if (!this._useFocusProxy || this._hasFocusProxy || this._makingFocusProxy || !this.isDrawn()
        || this.__delayedMakeFocusProxy != null) return;

    // set a temporary flag that we're in the middle of creating a focusProxy
    this._makingFocusProxy = true;

    this._makeFocusProxy();

    this._makingFocusProxy = null;
},

_makeFocusProxy : function () {
    // We know that the widget's handle is completely drawn at this point - therefore we can
    // use insertAdjacentHTML to write the focusProxy handle next to the widget's handle.
    // Note - if the page isn't loaded, using insertAdjacentHTML() to plug the handle into the
    // DOM can cause crashes on some browsers.

    if (!isc.Page.isLoaded() && isc.Browser.isSafari) {
        // call this.getTabIndex() to force auto-allocation of tab index to occur in the
        // expected order
        this.getTabIndex();
        // Delay actually writing out the focusProxy until the page is loaded to avoid problems
        // with manipulating the DOM before page load
        this.__delayedMakeFocusProxy =
            isc.Page.setEvent("load", this, null, "delayedMakeFocusProxy");

        return;
    }

    var tabIndex = this.getTabIndex();
    if (this.isDisabled()) tabIndex = -1;

    if (isc.Browser.isSafari && tabIndex == -1) {
        // In Safari, there's no way to write a (natively) focusable element into the page, and
        // exclude it from the page's tab order.
        // In this case just don't write the focusProxy into the DOM at all, and we'll deal
        // with virtual ISC focus only.
        // Note that this means you can't have a focusable widget with a working accessKey and
        // tabIndex -1 in Safari.
        return;
    }

    // Size the focus proxy to match the canvas unless we're in Safari

    var width = (isc.Browser.isSafari ? 1 : this.getViewportWidth()),
        height = (isc.Browser.isSafari ? 1 : this.getViewportHeight());

    var focusProxyString = isc.Canvas.getFocusProxyString(
                            this.getCanvasName(),
                            true,
                            this.getOffsetLeft() - 1, this.getOffsetTop() -1,
                            width, height,
                            this.isVisible(), this._canFocus(),
                            tabIndex, this.accessKey,
                            // this param determines whether the element should handle events
                            // directly, or allow page level EH handling.
                            false,
                            // returns a string causing the ISC level focus to be updated
                            this._getNativeFocusHandlerString(),
                            this._getNativeBlurHandlerString()
        );

    // Insert the focusProxyParent into the DOM in the same scope as the widget's clip handle.
    // Note: we insert AFTER not before the clip handle because redraw (for the special case
    // where we're allowing both children and content) makes the assertion that there's nothing
    // between the canvas's start tag and it's first child's start tag except for 'innerHTML'
    // type content. (If this was the first child of some widget and we inserted the
    // focusProxyParent before the widget's handle, we'd be writing the focus proxy between
    // this widget's start tag and the end of the parent's innerHTML)
    isc.Element.insertAdjacentHTML(this.getClipHandle(), "afterEnd", focusProxyString)

    // For simplicity, hang a flag on the widget saying that it has a focusProxy already.
    // Saves us having to get the F.P. from the DOM to check if it's written out already
    this._hasFocusProxy = true;
},

delayedMakeFocusProxy : function () {
    this.__delayedMakeFocusProxy = null;
    this.makeFocusProxy();
},

//> @method Canvas._clearFocusProxy()   (IA)
//      @group  focus
//          Internal Method to clear this widget's "focusProxy" from the DOM.
//<
_clearFocusProxy : function () {

    if (!this._useFocusProxy) return;

    // If there's a pending event to make the focus proxy, clear that out.
    if (this.__delayedMakeFocusProxy != null) {
        isc.Page.clearEvent("load", this.__delayedMakeFocusProxy);
        this.__delayedMakeFocusProxy = null;
    }

    // If we never create focusProxy, bail
    if (!this._hasFocusProxy) return;

    var fpp = this._getFocusProxyParentHandle();
    if (fpp != null) {

        // Note: focusProxyParentHandle has no pointers to this widget (if it did we should clear
        // them now)
        if (isc.Browser.isDOM) {
            // remove object tree from the DOM.
            if (fpp.parentNode) {
                fpp.parentNode.removeChild(fpp);
            } else {
                this.logWarn("Unable clear focusProxy for this widget - element has no parentNode.");
            }

        }

        // and clear the '_focusProxy' property from this widget
        this._focusProxy = null;

    }
    // Clear out our helper '_hasFocusProxy' flag so makeFocusProxy doesn't NoOp in the future.
    this._hasFocusProxy = null;

},
//<FocusProxy


_useAccessKeyProxy : function () {
    var result = (isc.Browser.isChrome || (isc.Browser.isMoz && this._useNativeTabIndex));
    return result;
},
_makeAccessKeyProxy : function () {
    var accessKey = this.accessKey;
    if (!accessKey || !this.isDrawn() || !this._canFocus()) return;
    var handleName = this._getDOMID("focusProxy");
    var proxyString = isc.StringBuffer.concat(
        "<a id='", handleName,
        "' href='javascript:void(0)'",
        (isc.Browser.isChrome ? "' onClick" : "' onfocus"),
        "='var _0=window.", this.getID(), ";if(_0){_0.focus();}' ",
        "accessKey='" + accessKey + "'></a>");

    isc.Element.insertAdjacentHTML(this.getClipHandle(), "beforeEnd", proxyString);
    this._accessKeyProxy = isc.Element.get(handleName);
},

_clearAccessKeyProxy : function () {
    var element = this._accessKeyProxy;
    delete this._accessKeyProxy;
    if (element) isc.Element.clear(element);
},


// Drawing children and peers
// --------------------------------------------------------------------------------------------

// Draw all children of this Canvas
_$initial_draw : "initial draw",
drawChildren : function () {

    // if no children defined, simply return true
    if (this.children == null) return true;

    // drawChildren is only safe to call BEFORE this canvas has been drawn
    if (this.isDrawn()) {
        //>DEBUG
        this.logWarn("drawChildren() is only safe to call BEFORE a canvas has been drawn" +
                     this.getStackTrace());
        //<DEBUG
        return;
    }

    //>DEBUG
    if (this.children && this.logIsInfoEnabled(this._$drawing)) {
        this.logInfo("drawChildren(): " + this.children.length + " children", this._$drawing);
    }
    //<DEBUG

    // make sure that everything in the children array is a Canvas, and has us as its parentElement
    this._instantiateChildren();

    // NOTE: this entrypoint needs to be exactly here, because this moment - where the parent's
    // HTML exists in the DOM but no children have been drawn - is the only time you could draw some
    // children before deciding on the size of other children.  Otherwise you'd have to resize the
    // other children after drawing them, potentially causing Canvas redraws/native repaints
    this.layoutChildren(this._$initial_draw);

    if (this.manageChildOverflow) this._suppressOverflow = true;

    // draw all children (unless they have a masterElement, in which case the master will draw them
    // itself)
    for ( var i = 0; i < this.children.length; i++) {
        var child = this.children[i];

        // Allow certain children to be kept undrawn when their parent draws
        if (!this.drawChildWithParent(child)) continue;

        // NOTE: the only legitimate way in which this child might already have been drawn
        // is via a custom override of layoutChildren() above.  Otherwise all children should be
        // undrawn, since:
        // - everything in the this.children array has gone through addChild(), hence was clear()d
        //   if it drew in another context
        // - this Canvas has never drawn it's children
        // - we don't allow Canvii that have undrawn parents to draw()
        // - we're skipping elements that have been drawn as a peer
        if (!child.isDrawn()) child.draw();

    }
    // Fix the zIndex / tab-index of masked children if we're showing the component mask
    // Normally this happens when 'showComponentMask' is called, so this handles the case where a
    // developer clears and re-draws the parent while the mask is still up.
    if (this.componentMaskShowing) {
        this._updateChildrenForComponentMask();
    }

},

drawChildWithParent : function (child) {

    // if the child has a masterElement, it's a peer of another child
    //  the other child will handle drawing it, so skip the draw here.
    if (child.masterElement) return false;
    // Don't show the componentMask if we've had it showing but it shouldn't be showing now
    if (this.componentMask == child && !this.componentMaskShowing) {
        return false;
    }
    return true;
},


_$parentDrawn:"parentDrawn",
_completeChildOverflow : function (children) {
    if (!this.manageChildOverflow) return;

    this._suppressOverflow = null;

    this._browserDoneDrawing(); // allows for easier timing
    //this.getHandle().scrollHeight;

    var count = 0;
    for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child != null && child._deferredOverflow) {
            count++;
            child._deferredOverflow = null;
            child.adjustOverflow(this._$parentDrawn);
        }
    }
    //if (count > 0) this.logWarn("completed child overflow for " + count + " children");
},


//> @method canvas.predrawPeers()   (A)
//          Draw all peers of this Canvas marked for pre-drawing
//      @group  drawing
//<
predrawPeers : function () {
    if (!this.peers) return;

    for (var i =0; i < this.peers.getLength(); i++) {
        var peer = this.peers[i];
        if (peer._drawBeforeMaster == true) {

            // if the peer is not a canvas, or doesn't recognize us as its master
            // call addPeer() to create it and/or add it to our list of peers
            if (!isc.isA.Canvas(peer) || peer.masterElement != this) {
                this.peers.remove(peer);
                this.addPeer(peer);
            }

            if (!peer.isDrawn()) peer.draw();
        }
    }
},

//> @method canvas.drawPeers()  (A)
//          Draw all peers of this Canvas
//      @group  drawing
//<
drawPeers : function () {
    // if no peers defined, simply return true
    if (!this.peers) return true;

    //>DEBUG
    if (this.logIsInfoEnabled(this._$drawing)) {
        this.logInfo("drawPeers(): " + this.peers.length + " peers", "drawing");
    }
    //<DEBUG

    // go in two passes through the peers array
    //   1) make sure that everything in there is a canvas, and has us as its masterElement
    //          if either is not true, call addPeer() to add it as a proper child
    //   2) draw everything that hasn't been drawn already

    // rebuild the peers array to ensure that it contains real canvases, and each one
    // has us as its master element
    var oldPeers = this.peers;
    this.peers = [];

    for (var i = 0, peer; i < oldPeers.length; i++) {
        peer = oldPeers[i];

        // if the peer is not a canvas, or doesn't recognize us as its master
        // call addPeer() to create it and/or add it to our list of peers
        if (!isc.isA.Canvas(peer) || peer.masterElement != this) {
            this.addPeer(peer);

        // otherwise, it's already been set up correctly (by a previous call to addPeer())
        //  so we'll just add it back to our peers array (which we cleared out earlier)
        } else {
            this.peers.add(peer);
        }
    }

    // pass 2 -- draw all peers
    // All peers now recognize this as the masterElement - so it can safely handle their drawing
    // (Even if they have a parent element, that will recognize that the peer has a master element
    //  and cede drawing to the masterElement)
    for (i = 0; i < this.peers.length; i++) {
        var peer = this.peers[i];

        // set the peers position if snapTo or snapEdge are set
        if (peer.snapTo || peer.snapEdge) peer._resolvePercentageSize();
        // if the peer is not already drawn, draw it
        if (!peer.isDrawn()) peer.draw();
    }

},


//> @method canvas._insertHTML()    (A)
//          Internal routine to insert the HTML for this canvas AFTER the page has loaded
//
//      @group  drawing
//
//      @return (canvas)    Pointer to this canvas.  Returned so statements like the following will work:
//                              var myCanvas = Canvas.newInstance({...}).draw()
//
//<
_insertHTML : function (includeInnerHTML, givenDrawContext) {

    // mark that we've starting drawing
    this.setDrawnState(isc.Canvas.DRAWING_HANDLE);

    var innerHTML = includeInnerHTML ? this._getInnerHTML() : null,


        buffer = this.getTagStart(true),
        gotArray = isc.isAn.Array(buffer),
        HTML;

    if (gotArray) {
        var origLength = buffer.length;

        buffer[buffer.length] = innerHTML;
        buffer[buffer.length] = this.getTagEnd();
        HTML = buffer.join(isc._emptyString);
        buffer.length = origLength;
    } else {
        HTML = isc.SB.concat(buffer, innerHTML, this.getTagEnd());
    }

    var newElement;
    var logEnabled = this.logIsInfoEnabled(this._$drawing);
    // if a specific DOM insertion position was specified
    var drawContext = givenDrawContext || this.drawContext;
    if (drawContext) {
        var element = drawContext.element,
            position = drawContext.position || "beforeBegin";
        //>DEBUG
        this.logInfo("_insertHTML(): drawing with " + position +
                     " relative to element: " + this.echoLeaf(element), "drawing");
        //<DEBUG

        if (position == "replace") {
            // insert before, then remove
            position = "beforeBegin";
            if (isc.isA.String(element)) element = isc.Element.get(element);
            newElement = this._insertAdjacentHTML(element, position, HTML, true);
            element.parentNode.removeChild(element);

            // drop drawContext (and htmlElement [same reason]);
            this.drawContext = null;
            if (this.htmlElement) this.htmlElement = null;
        } else {
            newElement = this._insertAdjacentHTML(element, position, HTML, true);
        }

    // if there's a drawn master Canvas, draw next to it
    // Note: peer vs master draw order
    // There are cases where we wish to draw a peer before we draw a master element into the
    // DOM - the specific example is the StretchImgButton, where in order to make the button
    // images auto-size to an overflow:visible label, we need to first draw the label out and
    // determine its drawn size before calling the 'getInnerHTML()' method.
    // In order to handle these cases we've introduced the concept of marking some peers for
    // 'predrawing' - which forces them to be written out before their masters (when draw() is
    // called on the master widget).
    // TODO: to prevent accidental out of order drawing, log an error if a peer draws before
    // its master and hasn't been explicitly marked for predrawing.

    } else if (this.masterElement && (this.masterElement.getClipHandle() != null)) {
        //>DEBUG
        if (logEnabled) {
            this.logInfo("inserting HTML next to master element: " + this.masterElement,
                         "drawing");
        } //<DEBUG

        // insert our HTML next to our masterElement in the document flow
        var master = this.masterElement.getClipHandle();
        newElement = this._insertAdjacentHTML(master, this._$afterEnd, HTML, true);

    // if there's a parent Canvas
    } else if (this.parentElement) {

        //>DEBUG
        if (logEnabled) {
            this.logInfo("inserting HTML into parent: " + this.parentElement,
                         "drawing");
        } //<DEBUG
        // insert our HTML within our parent's content handle
        drawContext = {
            element: this.parentElement.getHandle(),
            position: this._$beforeEnd
        };
        if (isc.screenReader && this.parentElement.children) {

            var siblings = this.parentElement.children,
                i = siblings.indexOf(this);
            for (var ri = i; ri > 0; --ri) {
                var sibling = siblings[ri - 1];
                if (sibling.handleDrawn() || sibling.isDrawn()) {
                    drawContext.element = sibling.getClipHandle();
                    drawContext.position = this._$afterEnd;
                    break;
                }
            }
            if (ri == 0) {
                ++i;
                for (var len = siblings.length; i < len; ++i) {
                    var sibling = siblings[i];
                    if (sibling.handleDrawn() || sibling.isDrawn()) {
                        drawContext.element = sibling.getClipHandle();
                        drawContext.position = this._$beforeBegin;
                        break;
                    }
                }
            }
        }
        newElement = this._insertAdjacentHTML(drawContext.element, drawContext.position, HTML, true);

    } else {
        // there is no parent Canvas, this is a top-level (absolute) Canvas.  Insert the HTML at
        // the end of the <BODY> tag to create a top-level element

        //>DEBUG
        if (logEnabled) {
            this.logDebug("inserting HTML at top level", "drawing");
        } //<DEBUG
        newElement = this._createAbsoluteElement(HTML);
    }


    if (newElement != null) {
        if (this._drewClipDiv) {
            //this.logWarn("caching handle: " + this.echoLeaf(newElement));
            this._clipDiv = newElement;
            this._handle = newElement.firstChild;
        } else {
            this._handle = newElement;
        }
    }

    this.setDrawnState(isc.Canvas.HANDLE_DRAWN);
},


_createAbsoluteElement : function (html) {
    return this.ns.Element.createAbsoluteElement(html);
},
_insertAdjacentHTML : function (element, position, html, singleElement) {
    return this.ns.Element.insertAdjacentHTML(element, position, html, singleElement);
},

// _completeHTMLInit() : helper method for draw() and _insertHTML()
//
// Finishes up the drawing process
//
//  - Assumes we have already drawn the handle into the DOM, and called this.drawChildren()
//
//  - Sets up events
//  - marks as drawn and not dirty
//  - calls adjustOverflow
//  - calls this.drawPeers()
_completeHTMLInit : function () {

    // opportunity to modify content before overflow is adjusted
    this.modifyContent();

    // Moz strict / transitional mode requires explicit sizing of iframe if present
    // (100%/100% not respected)
    // Also true with Chrome / HTML5 mode
    if ((isc.Browser.isSafari || isc.Browser.isMoz) && isc.Browser.isStrict && this.containsIFrame()) this._sizeIFrame();


    if (this.manageChildOverflow && this.children != null) {
        this._completeChildOverflow(this.children);
    }

    // set up the handle for the canvas
    this.setUpEvents();

    // If a resize was attempted while the handle was being written out, resize the actual
    // handle
    if (this._resizeHandleOnDrawComplete) {
        // actually resize the handle by calling _setHandleRect
        this._setHandleRect(this.left, this.top, this.width, this._height);
        // if we have a clip region set, it will have been clobbered by _setHandleRect.
        // restore it:
        // Note: already modified this._clip
        var clip = this._clip;
        if (isc.isAn.Array(clip)) this.setClip(clip);

        // AdjustOverflow will get called below
    }

    // mark that we've been drawn successfully and that we're not dirty
    this.setDrawnState(isc.Canvas.COMPLETE);
    this._dirty = false;

    this._updateHandleDisplay();

    if (this._needHideUsingDisplayNone()) {
        var parent = this.parentElement;
        while (parent != null) {
            parent._incrementHideUsingDisplayNoneCounter();
            parent = parent.parentElement;
        }
    }

    // If we don't have a parentElement, add to the list of top level canvii
    if (this.parentElement == null) isc.Canvas._addToTopLevelCanvasList(this);

    // adjust according to our overflow property

    if (this.parentElement != null && this.parentElement._suppressOverflow) {
        this._deferredOverflow = true;
    } else {
        this.adjustOverflow(this._$draw);
    }

    // if we have any peers defined, draw them now

    this.drawPeers();
},

//> @method canvas.setHtmlElement()
// Setter for the +link{canvas.htmlElement}.
// @param element (DOM element) New htmlElement for this canvas, or Null to clear the existing
//      htmlElement
// @group htmlElement
// @visibility external
//<
setHtmlElement : function (element) {
    if (this.htmlElement == element) return;
    this.htmlElement = element;
    if (!this.htmlPosition) this.htmlPosition = "afterBegin";
    var context = element ? {position:this.htmlPosition, element:this.htmlElement}  : null;
    // setDrawContext will handle clearing / drawing / etc.
    this.setDrawContext(context);
},

//> @method canvas.setHtmlPosition()
// Setter for the +link{canvas.htmlPosition}.
// @param element (DrawPosition) New htmlPosition for this canvas
// @group htmlElement
// @visibility external
//<
setHtmlPosition : function (position) {
    if (position == null) position = "afterBegin";
    if (this.htmlPosition == position) return;

    this.htmlPosition = position;
    if (this.htmlElement == null) return;
    var context = {position:this.htmlPosition, element:this.htmlElement};

    // setDrawContext will handle clearing / drawing / etc.
    this.setDrawContext(context);

},

// Redrawing
// --------------------------------------------------------------------------------------------

//> @method canvas.isDirty()    (A)
// Returns whether a canvas is waiting to be redrawn. Will return true if
// +link{canvas.markForRedraw()} has been called, but this canvas has not yet been
// redrawn.
// @group drawing
// @return (Boolean) true is this canvas needs to be redrawn; false otherwise
// @visibility external
//<
isDirty : function () {
    return this._dirty == true && this.isDrawn();
},


//> @method canvas.markForRedraw()  ([])
// Marks the widget as "dirty" so that it will be added to a queue for redraw. Redraw of dirty
// components is handled by a looping timer and will after a very short delay (typically less than
// 100ms). In most cases it is recommended that developers use <code>markForRedraw()</code>
// instead of calling +link{canvas.redraw()} directly. Since this method queues the redraw, multiple
// calls to markForRedraw() within a single thread of execution will only lead to a single DOM
// manipulation which greatly improves application performance.
//
//  @visibility external
//  @group  drawing
//  @param  [reason]    (string : "no reason provided") reason for performing the redraw
//<
markForRedraw : function (reason) {

    if (isc._traceMarkers) arguments.__this = this;

    // If we've been drawn already, add this to the queue of items to be redrawn automatically.
    // If we're already dirty, we're already in the redraw list.
    if (this.isDrawn() && !this.isDirty()) {
        this._logRedraw(reason);
        isc.Canvas.scheduleRedraw(this);

        // mark the item as dirty so we don't schedule the event again later
        this._dirty = true;
    }
},

readyToRedraw : function (reason, askedToRedraw) {
    if (isc._traceMarkers) arguments.__this = this;

    if (!this.isDrawn()) {

        return false;
    }

    // NOTE: unsafe times to redraw
    // When we redraw a widget, we throw away the old HTML and replace it with new HTML - a
    // subtle consequence of this is that the DOM object that is the target of the current event
    // is *destroyed*.  Various browsers on various platforms while processing particular types
    // of events with various HTML contents react badly to this.
    //
    // So now, whenever there is an attempt to redraw during mouseDown or mouseUp, we delay the
    // redraw regardless of the browser, since we would prefer not to learn about the rest of
    // the obscure cases where an immediate redraw won't work.
    //
    // However, postponing this redraw means that this redraw, which the caller wanted to happen
    // immediately, will be done in a batch of redraws, which means no actual native repaint
    // will occur until every widget that needs to redraw is done redrawing, which might take a
    // while.  So we set a "priority redraw" flag so the redraw of this object is done in a
    // batch of its own.

    var returnVal = true;

    var EH = this.ns.EH;
    if (EH.lastTarget == this &&
        (EH._handlingMouseUp || EH._handlingMouseDown ||
         (isc.Browser.isMobileWebkit && EH.dragOperation == EH.DRAG_SCROLL)
        )
       )
    {
        returnVal = false;
    }


    if (EH._handlingTouchEventSequence()) {
        if (isc.Browser.isChrome) {
            var mouseDownEvent = EH.mouseDownEvent;
            if (mouseDownEvent != null &&
                mouseDownEvent.DOMevent.target != null &&
                this.getClipHandle().contains(mouseDownEvent.DOMevent.target))
            {
                returnVal = false;
            }
        } else if (isc.Browser.isMobileWebkit) {
            var mouseDownEvent = EH.mouseDownEvent,
                lastEvent = EH.lastEvent;

            if (mouseDownEvent != null && lastEvent.DOMevent.target != null &&
                lastEvent.DOMevent.target === mouseDownEvent.DOMevent.target &&
                this.getClipHandle().contains(lastEvent.DOMevent.target))
            {
                returnVal = false;
            }
        }
    }

    if (returnVal == false && askedToRedraw) {
        // if actually asked to redraw, schedule for later
        this._logRedraw(reason, true);
        this.priorityRedraw = true;
        // Mark as non-dirty (otherwise markForRedraw is a no-op)
        this._dirty = false;
        this.markForRedraw(false);
    }

    return returnVal;
},

_logRedraw : function (reason, type) {
    //>DEBUG

    // NOTE: some callers pass reason = false to suppress this log, since the redraw is already
    // logged elsewhere (clearRedrawQueue and redrawChildren)
    if (reason == false || !this.logIsInfoEnabled(this._$redraws)) return;

    // log a stack if 'redrawTrace' log is enabled, or in debug mode and no reason was provided
    var logTrace = (!reason && this.logIsDebugEnabled(this._$redraws) ||
                    this.logIsDebugEnabled("redrawTrace"));

    var message;
    if (type == null) message = "Scheduling redraw ";
    else message = (type == true ? "DEFERRED " : "") + "Immediate redraw ";

    this.logInfo(message +
                 // log that widget is dirty only if an immediate redraw was requested (whether
                 // it was deferred or not)
                 (this.isDirty() && type != null ? "of dirty widget " : "") +
                 // redrawing with children indicates all children redraw
                 (this.children && this.children.length > 0 ?
                  "(" + this.getChildCount() + " children) " : "") +
                 // reason for redraw
                 "(" + (reason ? reason : "no reason provided") + ")" +
                 // log trace
                 (logTrace ? this.getStackTrace() : ""),
                 this._$redraws);
    //<DEBUG
},

//> @method canvas.redraw() ([A])
// Redraws the widget immediately with its current property values.
//
// Generally, if you want a Canvas to redraw, call markForRedraw() - this will cause the Canvas to
// be redrawn when current processing ends, so that a series of modifications made to a Canvas will
// cause it to redraw only once.
//
// Only call redraw() directly if you need immediate responsiveness, for example you are redrawing
// in response to continuous mouse motion.
//
//  @visibility external
//  @group  drawing
//  @param  [reason]    (string : "no reason provided") reason for performing the redraw
//<
//
// NOTE: this does not necessarily have to redraw all of the HTML of a Canvas.  Subclasses can
// override redraw to do something smarter.
redraw : function (reason) {
    if (isc._traceMarkers) arguments.__this = this;

    if (!this.readyToRedraw(reason, true)) return this;

    //>DEBUG
    this._logRedraw(reason, false);
    // track total redraws
    this._addStat(this._$redraws);


    //<DEBUG

    var start = isc.timeStamp();


    this._updateHTML();


    // track last redraw time
    this._lastRedrawTime = isc.timeStamp() - start;

    return this;
},

redrawIfDirty : function (reason) {
    if (this.isDrawn() && this.isDirty()) return this.redraw(reason);
},

//> @method canvas._updateHTML()    (A)
//      Redraw an existing layer by generating new HTML and replacing the existing HTML.
//
//      NOTE: non-framework code should call redraw(), not this method
//
//      @group  drawing
//
//      @return (canvas)    Pointer to this canvas.  Returned so statements like the following will
//                          work:
//                              var myCanvas = Canvas.newInstance({...}).draw()
//<
_updateHTML : function () {

    //>DEBUG
    var logDebugEnabled = this.logIsDebugEnabled(this._$drawing),
        logInfoEnabled = this.logIsInfoEnabled(this._$drawing),
        startTime;
    if (logDebugEnabled) startTime = isc.timeStamp();
    if (logInfoEnabled) this.logInfo("_updateHTML(): redrawing", "drawing");
    //<DEBUG

    // if we have any peers, call the redrawPredrawnPeers() method to check for any peers marked
    // for drawing before the master element, and redraw them first.
    // (See addPeer() and predrawPeers() methods for more info).
    if (this.peers != null && this.peers.getLength() > 0) this.redrawPredrawnPeers();

    var hasChildren = this.children && this.children.length > 0,
        childrenAndContent = this.allowContentAndChildren && hasChildren;

    // special case: if shouldRedrawOnResize() assume redraw should always redraw content - if
    // we have children, flip on 'allowChildrenAndContent'

    if (hasChildren && !childrenAndContent && this.shouldRedrawOnResize()) {
        childrenAndContent = true;
    }


    if ((!hasChildren || childrenAndContent) &&
        (this.getVisibleWidth() > this.getWidth() ||
         this.getVisibleHeight() > this.getHeight()))
    {
        //this.logWarn("resizing overflow Canvas before redraw");
        if (this.notifyAncestorsOnReflow && this.parentElement != null) {
            this.notifyAncestorsAboutToReflow();
        }
        this._setHandleRect(null, null, this.width, this._height);
    }

    if (hasChildren) {
        // update the HTML that came from parent.getInnerHTML().
        if (childrenAndContent) this._updateParentHTML();

        this.redrawChildren();
    } else {
        // childless - update inner HTML
        this._updateInnerHTML();
    }

    // If we're writing out a placeholder div to enforce scroll-size, and we just
    // redraw our innerHTML, reapply it now.

    if (this._enforcingScrollSize && !hasChildren) {
        // The old div will no longer be present, so if this._scrollSizeDiv (if set)
        // will be out of date (pointing to an element that's no longer written into the DOM).
        // Clear the pointer out to ensure we create a fresh div.
        delete this._scrollSizeDiv;
        this.enforceScrollSize(this._enforcingScrollSize[0], this._enforcingScrollSize[1]);
    }

    // opportunity to modify new content before overflow is adjusted
    this.modifyContent();

    // set up events in the handle
    this.setUpEvents();

    // mark this item as not dirty any more

    this._dirty = false;
    // adjust the overflow again
    this.adjustOverflow(this._$redraw, null, true);

    // if we have any peers, redraw them

    this.redrawPeers();


    //>DEBUG
    if (logDebugEnabled) {
        this.logDebug("Redraw() - Total time to redraw in DOM:" + (isc.timeStamp() - startTime),
                      "drawing");
    }
    //<DEBUG

    if (this.notifyAncestorsOnReflow && this.parentElement != null) {
        this.notifyAncestorsReflowComplete();
    }

    // return "this" for chaining calls (canvas.redraw().moveTo(..).. )
    return this;
},

// If this widget is overflow:"visible", on redraw, we force a handle resize to specified size
// before refreshing content.
// This may causes us to shrink, changing the scroll-size of our ancestors.
// If they are scrolled, this can cause a native scroll-back to 0,0.
// The "notifyAncestorsOnReflow" flag is a way to workaround this - in this case we notify
// our parents before changing our size allowing them to remember their scroll position, then
// when the redraw completes, the parents are notified again, allowing them to bounce back to
// the original scroll position if possible.

notifyAncestorsOnReflow:true,

notifyAncestorsAboutToReflow : function () {
    if (this.parentElement) this.parentElement._childAboutToReflow(this);
},

notifyAncestorsReflowComplete : function () {
    if (this.parentElement) this.parentElement._childReflowComplete(this);
},

_childAboutToReflow : function (child) {
    if (this.overflow != isc.Canvas.VISIBLE) {
        this._preReflowScrollTop = this.getScrollTop();
        this._preReflowScrollLeft = this.getScrollLeft();
        // Suppress adjustOverflow - we don't want to temporarily hide scrollbars etc.
        this._suppressAdjustOverflow = true;
    // Note that if we're overflow:visible, the child reflowing may cause our size to change as well
    // so we have to notify our ancestors.
    } else {
        if (this.parentElement) this.parentElement._childAboutToReflow(child);
    }
},

_childReflowComplete : function (child) {
    if (this.overflow != isc.Canvas.VISIBLE && this._suppressAdjustOverflow) {
        delete this._suppressAdjustOverflow;
        var shouldScroll = false,
            scrollLeft, scrollTop;
        if (this._preReflowScrollTop != null && this._preReflowScrollTop != this.getScrollTop()) {
            shouldScroll = true;
            scrollTop = this._preReflowScrollTop;
            delete this._preReflowScrollTop;
        }
        if (this._preReflowScrollLeft != null && this._preReflowScrollLeft != this.getScrollLeft()) {
            shouldScroll = true;
            scrollLeft = this._preReflowScrollLeft;
            delete this._preReflowScrollLeft;
        }
        if (shouldScroll) {
            this.scrollTo(scrollLeft, scrollTop,
                "Reset scroll position for child content reflow");
        }
    } else {
        if (this.parentElement) this.parentElement._childReflowComplete(child);
    }
},

// update the HTML of a parent without changing the HTML of its children

_updateParentHTML : function () {
    var wasPrinting = this.isPrinting;
    this.isPrinting = false;
    var innerHTML = this._getInnerHTML();
    this.isPrinting = wasPrinting;

    var thisHandle = this.getHandle();

    // We achieve this by removing all the text inside the content handle for the
    // widget up to the handle of the first child, and then inserting the new innerHTML
    // in the same place
    //
    // Note: within the content handle for a canvas, we will always have the innerHTML
    // (returned from getInnerHTML()) for the canvas, followed by the child nodes.
    // Therefore everything up to the first child's handle is the parents content (this
    // assumption could only be violated by unsupported manual DOM manipulation).



    // remove everything up to the first Canvas.  NOTE: we can't compare against
    // this.children[0].getHandle() because our children may draw out of order, get clear()d,
    // etc.
    while (thisHandle.hasChildNodes()) {
        var eventProxy = thisHandle.firstChild.getAttribute ?
                         thisHandle.firstChild.getAttribute(this._$eventProxy) : null;
        if (eventProxy && isc.isA.Canvas(window[eventProxy])) break;
        //this.logWarn("removing element: " + this.echoLeaf(thisHandle.firstChild));
        thisHandle.removeChild(thisHandle.firstChild);
    }
    // add the parent's new HTML
    isc.Element.insertAdjacentHTML(thisHandle, this._$afterBegin, innerHTML);
},
_$eventProxy : "eventProxy",

// update the innerHTML of a childless Canvas
_updateInnerHTML : function () {
    var wasPrinting = this.isPrinting;
    this.isPrinting = false;
    var innerHTML = this._getInnerHTML();
    this.isPrinting = wasPrinting;

    this.getHandle().innerHTML = innerHTML;
},

// opportunity to modify drawn or redrawn content before overflow is adjusted
modifyContent : function () {},

//> @method canvas.redrawChildren() (A)
//      Redraw all of our children
//      @group  drawing
//<
redrawChildren : function () {
    // if no children defined, simply return true
    if (! this.children) return true;

    //>DEBUG
    this.logInfo("redrawChildren(): " + this.children.length + " children", "drawing");
    //<DEBUG

    // redraw each child
    for (var list = this.children, i = 0; i < list.length; i++) {
        var child = list[i];

        if (!isc.isA.Canvas(child)) continue;
        if (child._redrawWithParent) {
            child.redraw(false);
        }
    }
},

//> @method canvas.redrawPredrawnPeers()    (A)
//      Redraw any of our peers marked for preDraw via the '_drawBeforeMaster' flag
//      @group  drawing
//      @see    predrawPeers()
//      @see    addPeer()
//<
redrawPredrawnPeers : function () {
    // bail if we have no peers.
    if (!this.peers || this.peers.getLength < 1) return;

    // draw each peer marked for predrawing
    for (var list = this.peers, i = 0; i < list.length; i++) {
        if (list[i] && list[i]._redrawWithMaster && list[i]._drawBeforeMaster) {
            list[i].redraw("redrawPeers");
        }
    }

},


//> @method canvas.redrawPeers()    (A)
//      Redraw all of our peers (excluding those marked for drawing / redrawing before their
//      master element)
//      @group  drawing
//<
redrawPeers : function () {
    // if no peers defined, simply return true
    if (!this.peers) return true;

    //>DEBUG
    this.logInfo("redrawPeers(): " + this.peers.length + " peers", "drawing");
    //<DEBUG

    // redraw each peer
    for (var list = this.peers, i = 0; i < list.length; i++) {
        if (list[i] && list[i]._redrawWithMaster && !list[i]._drawBeforeMaster) {
            list[i].redraw("redrawPeers");
        }
    }
},

// Update / Refresh / Replace from server
// --------------------------------------------------------------------------------------------

//> @method canvas.updateFromServer()   (A)
//
// A flexible way to update a component from the server.
// <p>
// Makes a request to the server at the URL specified by the actionURL of the provided RPCRequest.
// Sets +link{attr:RPCRequest.evalResult} and +link{attr:RPCRequest.suppressAutoDraw} to true in
// the provided request and automatically makes available the component on which this method is
// called under the name 'targetComponent' in the response received from the server (i.e. in the
// +link{attr:RPCRequest.evalVars} of the request).
// <p>
// For example, let's say you wanted to add a component available from the server at the URL
// '/myComponent.jsp' to a layout on the current page called 'myLayout'.  You can accomplish this by
// calling this on the client:
// <pre>
// myLayout.updateFromServer({actionURL: "/myComponent.jsp"});
// </pre>
// In the body of myComponent.jsp you could then do e.g:
// <pre>
// var newComponent = Label.create({contents: "hello world"});
// targetComponent.addMember(newComponent);
// </pre>
// The URL targeted by updateFromServer must produce valid JavaScript code, but how that happens is
// up to you - this can be a static file, a JSP or a Servlet.
// <p>
// Note that you can use all other features of +link{class:RPCRequest} as part of
// updateFromServer().  For example, if you wanted show a prompt with the contents "loading
// component" while the update is in progress and get a callback when it completes while also
// sending some parameters to the server that would be available via request.getParameter() in
// e.g. your JSP, you can issue the above request as follows:
// <pre>
// myLayout.updateFromServer({
//     actionURL: "/myComponent.jsp",
//     showPrompt: true,
//     prompt: "loading component",
//     params : {
//         "componentId": myLayout.getID(),
//         "foo": "bar"
//     },
//     callback: "alert('done updating "+myLayout.getID()+"')"
// });
// </pre>
//
// @param rpcRequest (RPCRequest) minimally must specify the actionURL, but all other RPCRequest
//                                features are available.
//
// @visibility internal
//<
updateFromServer : function(request) {
    // make a copy so we don't modify user's object
    request = isc.clone(request);
    isc.addProperties(request, {

        useXmlHttpRequest: true,
        evalResult : true,
        suppressAutoDraw : true
    });

    // this component is autogically made available as part of the evalVars
    if(!request.evalVars) request.evalVars = {};
    if(!request.evalVars.targetComponent) request.evalVars.targetComponent = this;

    isc.rpc.sendRequest(request);
},


refreshFromServer : function(url, data, prompt, callback) {
    this._refreshOrReplaceFromURL("refresh", url, data, prompt, callback);
},

replaceFromServer : function(url, data, prompt, callback) {
    this._refreshOrReplaceFromURL("replace", url, data, prompt, callback);
},



_refreshOrReplaceFromURL : function(action, url, data, prompt, callback) {
    // don't more than one attempted refresh/replace, because we don't want to write a bunch of
    // logic to guarantee the correct order (i.e. server may respond to the second request before
    // the first)
    if (this._refreshing) {
        this.logWarn("Attempt to "+action+" while "+this._refreshAction+" is in progress - ignoring.");
        return;
    }
    this._refreshing = true;
    this._refreshAction = action;
    this._refreshCallback = callback;



    this.logDebug("Submitting to " + action + " URL: " + url + ", with data: " + this.echo(data));

    isc.Comm.sendFieldsToServer({
        URL:url,
        fields:data,
        prompt:prompt,
        callback: this.getID() + "._refreshReply(frame)",
        resultVarName: this.refreshVariable
    });
},

_refreshReply : function (frame) {
    // release the refresh lock
    this._refreshing = false;

    var action = this._refreshAction;
    var newConfig = frame[this.refreshVariable];

    if (!isc.isAn.Object(newConfig)) {
        this.logError("Expected object literal for " + action +
                      ", but got: " + isc.Log.echo(newConfig));
        return;
    }
    // need to clone the newConfig since it came from another frame
    newConfig = isc.clone(newConfig);

    var visibleInstance = this;
    // if it's a refresh just setProperties on the existing object
    if (action == "refresh") this.setProperties(newConfig);
    else { // it's a replace
        // if a constructor property was not passed in for the item that we're replacing this Canvas
        // with, assume it's going to be of the same type as whatever it is replacing.
        if (!newConfig._constructor) newConfig._constructor = this.getClassName();
        visibleInstance = this.replaceWith(newConfig);
    }

    // possibly call after callback?
    isc.clearPrompt();

    // call the registered callback, if any
    if (this._refreshCallback) {
        if (!isc.isA.Function(this._refreshCallback)) {
            this._refreshCallback = isc.Func.expressionToFunction("canvas", this._refreshCallback);
        }
        // make sure the conversion worked
        if (!isc.isA.Function(this._refreshCallback)) {
            this.logError("Can't convert "+action+" callback '"+this._refreshCallback
                          +" to a function - not firing callback!");
            return;
        }
        this._refreshCallback(visibleInstance);
    }

},

// Clear and Destroy
// --------------------------------------------------------------------------------------------

//> @method canvas.clear() [A]
// Remove all visual representation of a Canvas, including all child or member Canvases, or
// managed top-level components such as the ListGrid drop location indicator.
// <P>
// This is more expensive than hide(), because in order to become visible again, the Canvas must
// be draw()n again.  Generally, application code has no reason to call clear() unless it is
// attempting to do advanced memory management.  If you want to temporarily hide a Canvas, use
// hide() and show(), and if you want to permanently destroy a Canvas, use +link{destroy()}.
// <P>
// You would only use clear() if you were managing a very large pool of components and you
// wanted to reclaim some of the memory used by components that had not been used in a while,
// while still being able to just draw() them to make them active and visible again.
// <P>
// Note: a clear() will happen as part of moving a Canvas to a different parent.  See
// +link{addChild()}.
//
// @visibility external
//<
clear : function (dontReport) {
    this._clearing = true;

    //>DEBUG
    // increment total clears (if not called from parent or as part of destroy)
    if (!dontReport && this.logIsInfoEnabled("clears")) {
        var message = "clear()" +
                      // clearing with children indicates all children clear (without
                      // individually reporting it)
                      (this.children && this.children.length > 0 ?
                       " (" + this.getChildCount() + " children) " : "") +
                      (this.logIsDebugEnabled("clears") ? this.getStackTrace() : "");

        // NOTE: in the log, we only report the first call to clear(), but for the stat, we
        // report each individual handle clear (from clearHandle())
        this.logInfo(message, "clears");


    }
    //<DEBUG

    // blur - don't let undrawn items have focus
    this._updateFocusForHide();

    // remove from EventHandler mask registry if necessary
    // NOTE: This must be called before we clear peers, since unregisterMaskableItem()
    //  will try to destroy the event mask, which is a peer.
    if (this._eventMask) this.ns.EH.unregisterMaskableItem(this);

    // clear the handle for this widget

    //if (!this._clearedByParent && this.getHandle()) this.clearHandle();

    //>FocusProxy If we have a focusProxy, clear it from the DOM as well.
    if (this._useFocusProxy) this._clearFocusProxy();
    //<FocusProxy

    // tell all of our children to clear so they clean up their own act
    if (this.children) {
        for (var list = this.children, i = 0; i < list.length; i++) {
            var child = list[i];
            if (!isc.isA.Canvas(child)) continue;
            child._clearedByParent = true;
            child.clear(true);
            child._clearedByParent = null;
        }
    }

    if (this.getHandle()) {
        this.clearHandle();

        if (this._needHideUsingDisplayNone()) {
            var parent = this.parentElement;
            while (parent != null) {
                parent._decrementHideUsingDisplayNoneCounter();
                parent = parent.parentElement;
            }
        }
    }

    if (this.parentElement) this.parentElement.childCleared(this);
    if (this.masterElement) this.masterElement.peerCleared(this);

    // Clear the scroll-size enforcer div if present
    // (Don't call stopEnforcing - if we get drawn again, continue to enforce the scrollSize)
    delete this._scrollSizeDiv;

    // clear the pointer to the accessKeyProxy element, if there is one
    delete this._accessKeyProxy;



    // clear any delayed draw event
    if (this.deferredDrawEvent) {
        isc.Page.clearEvent(this.deferredDrawEvent);
        delete this.deferredDrawEvent;
    }

    // if we have any peers, clear them as well
    if (this.peers) {
        for (var list = this.peers, i = 0; i < list.length; i++) {
            // if we were cleared by our parent, our peers were too
            if (this._clearedByParent) list[i]._clearedByParent = true;
            list[i].clear(true);
            list[i]._clearedByParent = null;
        }
    }

    // note that we're no longer droppable
    if (this.canAcceptDrop) this.ns.EH.unregisterDroppableItem(this);

    // and note that we're no longer drawn
    this.setDrawnState(isc.Canvas.UNDRAWN);

    delete this._clearing;
},


//> @groupDef memoryLeaks
// Care must be taken to avoid memory leaks in your application:<ul>
// <li>Any +link{Canvas} (including subclasses) that you're done using should be destroy()d to
// avoid memory leaks.  Since +link{Canvas.destroy(),destroy()} is recursive, you only need to
// call destroy() on the topmost component in any hierarchy of widgets you don't need.  This
// includes +link{DynamicForm} automatically destroying +link{FormItem}s and +link{DrawPane}
// automatically destroying +link{DrawItem}s.
// <li>Any +link{ValuesManager}s that you are done using should be destroy()d to avoid memory
// leaks, and will never be automatically destroyed as a consequence of destroying any related
// Canvas.
// <li>+link{ResultSet} and +link{ResultTree} instances that you <b>manually</b> create need to
// be destroy()d to avoid leaks.  ResultSet and ResultTree instances automatically created by
// +link{ListGrid}s and +link{TreeGrid}s (see +link{ListGrid.fetchData()}) do not need to be
// destroy()d as they are automatically destroyed with the creating ListGrid or TreeGrid.
// <smartgwt>+link{RecordList}s must be destroy()d as they are registered with the
// +link{IDManager}.</smartgwt>
// <li>If your application creates an unbounded number of DataSources while it is running
// (this is very rare), DataSources that are given a +link{DataSource.ID} need to be destroy()d
// to avoid leaks.  Most applications do not need to worry about this, as they create a fixed set of
// DataSources, and +link{DataSource.get()} will never cause a leak.
// <li>Any other kinds of SmartClient objects you create will be garbage collected normally.
// </ul>
// <p>
// <h3>Testing for memory leaks</h3>
// <p>
// Seeing the browser's memory use rise dramatically after a given operation does not demonstrate
// a memory leak.  It's normal for browser memory usage to fluctuate wildly, because the browser
// will generally not reclaim resources immediately, and in some cases will not reclaim resources
// until memory is nearly exhausted.  Some browsers will also build up pools of resources for
// later re-use.
// <p>
// The only way to demonstrate a real memory leak is to demonstrate <i>memory exhaustion</i>:
// showing that the browser memory usage rises until all memory is exhausted and errors begin
// to occur.  No other pattern of increasing memory usage - no matter how large - is considered
// evidence of a leak, because the browser may suddenly reclaim very large amounts of memory
// after memory usage rises to a certain trigger point.  Memory exhaustion is the <i>only</i>
// way to demonstrate a real memory leak.
// <p>
// Note that all debugging tools must be closed in order to demonstrate memory exhaustion
// because debugging tools may themselves consume large amounts of memory:
// <ul>
// <li>On the RPC tab of the SmartClient Developer Console, make sure that "Track RPCs" is
//     <strong>un</strong>checked and then close the SmartClient Developer Console window.
// <li>If using Chrome's or Safari's developer tools, make sure that the developer tools are
//     closed.
// <li>If using Firebug, close Firebug and restart Firefox, as Firebug may still be active
//     even though closed.
// <li>If using Internet Explorer's Developer Tools, close Developer Tools and restart IE, as
//     the Developer Tools may still be active even though closed.
// </ul>
// <p>
// To demonstrate memory exhaustion, you generally need to take whatever operation you suspect
// of leaking memory and cause it to be repeated thousands or hundreds of thousands of times -
// generally, by performing the same operation multiple times in a loop, or, for asynchronous
// operations like +link{DataSource} saves, performing the operation again each time you receive
// notification of completion (via callbacks).
// <p>
// In Windows, you can speed up the process of demonstrating memory exhaustion by disabling
// paging of memory to disk, which causes Windows to use the physical memory of the system
// (RAM) only.  To disable paging, go to Advanced System Settings, and in the "Virtual Memory"
// section of the "Performance" settings, uncheck the "Automatically manage paging file size
// for all drives" checkbox and select "No paging file" (this process may differ slightly on
// different versions of Windows).  The system will need to be rebooted for these new settings
// to take effect.
// <p>
// Once paging is disabled, verify that you can still open the browser and load the application
// you intend to test.  There needs to be ample physical memory available for the application
// to use.  A rule of thumb is to have enough available memory for the browser's memory footprint
// to at least quadruple in size or at least 500 MB, which ever is greater.  If the system does
// not have enough physical memory, one option is to re-enable paging, but limit the maximum
// size of the page file to 500 MB.  Then begin the process of repeating the operation being
// tested for a memory leak.
// <p>
// If Windows shows a warning about low system memory, you have demonstrated memory exhaustion
// and therefore a memory leak.  If you are working with a minimal, ready-to-run test case,
// you may have found a framework bug or a browser bug that SmartClient can work around.  You
// should post your minimal test case to the +externalLink{http://forums.smartclient.com/,SmartClient forums}
// for analysis by Isomorphic Support.
// <p>
// If you do not have a minimal test case and have simply shown that your application is leaking
// memory, consider the possible coding errors that could cause memory leaks (explained above),
// and work toward creating a minimal test case if you suspect a framework or browser bug is the
// underlying cause.
// @see Canvas.destroy()
// @see DrawItem.destroy()
// @see Class.destroy()
// @see ValuesManager
// @see DataSource.ID
// @title Memory Leaks
// @treeLocation Concepts
// @visibility external
//<



//> @method canvas.destroy()    (A)
// Permanently destroy a Canvas and all of it's children / members, recursively.
// <P>
// Like +link{clear()}, calling <code>destroy()</code> removes all HTML for the component;
// unlike clear(), a destroyed Canvas is permanently unusable: it cannot be draw()'n again,
// cannot be referenced by its global ID, and is eligible for garbage collection (assuming
// that application code is not holding a reference to the Canvas).
// <P>
// Any attempt to call a method on a destroyed Canvas will generally result in an error.  If your
// application is forced to hold onto Canvas's that might be destroy()d without warning, you can
// avoid errors by checking for the +link{canvas.destroyed} property.  If you override certain Canvas
// methods, your code may be called while a Canvas is being destroy()d; in this case you can avoid
// extra work (and possibly errors) by checking for the +link{canvas.destroying} property.
// <P>
// Note that <code>destroy()</code> should not be called directly in event handling code for this
// canvas. For this reason, wherever possible we recommend using +link{canvas.markForDestroy()}
// instead of calling this method directly.
//
// @see canvas.markForDestroy()
// @see group:memoryLeaks
// @visibility external
//<


//> @attr canvas.destroyed (boolean : null : RA)
// If this property is set to <code>true</code>, the +link{canvas.destroy(), destroy()} method
// has been called on this canvas. This implies the canvas is no longer valid. Its ID has been
// removed from global scope, and calling standard canvas APIs on it is likely to result in
// errors.
// @see canvas.destroy()
// @visibility external
//<

//> @attr canvas.destroying (boolean : null : RA)
// This property is set to true when the +link{Canvas.destroy()} method is called on a widget.
// If this property is true, but +link{Canvas.destroyed} is not, this indicates the canvas is
// in the process of being destroyed.
// @see canvas.destroy()
// @visibility external
//<


destroy : function (indirectDestroy,b,c,d,e) {

    if (this.selectionComponent) {
        this.ignore(this.selectionComponent, "selectionChanged");
        this.ignore(this.selectionComponent, "cellSelectionChanged");
    }

    // if we're marked doNotDestroy, just clear()
    if (this.doNotDestroy) {
        this.clear();
        return;
    }

    // if we're already destroyed don't do it again
    if (this.destroyed) return;

    // set a flag so we don't do unnecessary work during a destroy()
    this.destroying = true;

    // Split the majority of the custom destroy implementation into a separate method
    // This will allow us to override and add to destroy functionality per subclass while
    // retaining the "destroying" / "destroyed" flags at the appropriate point

    this.prepareForDestroy(indirectDestroy,b, c, d, e);

    // set a destroyed flag so that if someone still has a pointer to this widget, they can tell
    // it's destroyed
    this.destroyed = true;


    this.invokeSuper(isc.Canvas, "destroy", indirectDestroy,b,c,d,e);

},

prepareForDestroy : function (indirectDestroy, b, c, d, e) {

    // shouldn't need to blur, as both 'hide()' and 'clear()' do a blur, and if this isn't
    // drawn it won't have focus

    // Remove canvas *When rules from rulesEngine
    this._removeCanvasWhenRules();

    // remove this widget from the toplevel component's list of local ids
    if (this._screen && this._screen._localIds) {
        for (i in this._screen._localIds) {

            if (this._screen._localIds[i] == this) {
                delete this._screen._localIds[i];
            }
        }
    }

    // clear the overflow timer for delayed adjustoverflow
    if (this._overflowQueued) isc.Timer.clearTimeout(this._overflowTimer);

    // if this widget is showing a clickMask (eg modal Dialog), get rid of it.  This will no-op
    // if this widget is not showing a clickMask.
    this.hideClickMask();

    this._logDestroy(true, indirectDestroy);

    // If we're showing the hover canvas, clear it.
    if (isc.Hover.lastHoverCanvas == this) isc.Hover.hide();

    // destroy our DOM representation.
    this.clear(true);

    // sever parent/peer connection as early as possible to prevent any code that traverses the
    // parent hierarchy from doing extra work
    // Note that depeer() automatically handles deparenting so no need to call both.
    if (this.masterElement) {
        this.depeer();
    } else if (this.parentElement) {
        this.deparent();
    }

    // tell all of our children to destroy so they clean up their own act
    if (this.children) {
        for (var list = this.children.duplicate(), i = 0; i < list.length; i++) {
            var child = list[i];
            if (!isc.isA.Canvas(child)) continue;

            if (child.destroyWithParent === false) child.deparent();
            else child.destroy(true);
        }
    }

    // if we have any peers, destroy them as well
    if (this.peers) {
        for (var list = this.peers.duplicate(), i = 0; i < list.length; i++) {
            if (list[i].destroyWithMaster === false) list[i].depeer();
            else list[i].destroy(true);
        }
    }

    // wipe out our links to our children
    delete this.peers;
    delete this.children;

    // Verify that we have no scrollbars. May not have been caught in the peer class
    // if the scrollbar was never rendered out.
    if (this.hscrollbar && !this.hscrollbar.destroyed) {
        this.hscrollbar.destroy(true);
        delete this.hscrollbar;
    }
    if (this.vscrollbar && !this.vscrollbar.destroyed) {
        this.vscrollbar.destroy(true);
        delete this.vscrollbar;
    }

    // AutoChildren: By default destroy any autochildren we created
    // We set up the _createdAutoChildren object in createAutoChild
    // This is of the format:   {childName:<array of IDs>}
    // Auto destroy these and clear this[childName] at the same time, if appropriate

    var autoChildren = this._createdAutoChildren;
    if (autoChildren != null) {
        for (var childName in autoChildren) {
            var array = autoChildren[childName];
            for (var i = 0, len = array.length; i < len; ++i) {
                var childID = array[i],
                    child = (childID ? window[childID] : null) || this[childName];

                if (child && !child.destroyed && child.destroy && !child.dontAutoDestroy) {
                   child.destroy();
                }
            }

            // Always clear out this[childName].
            // Probably not really required but if we didn't destroy the child (dontAutoDestroy)
            // we don't want to keep pointing to it
            delete this[childName];
        }
    }

    // if we have an event proxy, or any other widgets are event proxies for this one, clear
    // out the references in both directions.
    if (this.eventProxy != null) this.clearEventProxy();
    if (this._proxiers != null) {
        for (var list = this._proxiers.duplicate(), i = 0; i < list.length; i++) {
            list[i].clearEventProxy();
        }
    }

    if (this.locatorParent && this.locatorParent.locatorChildDestroyed) {
        this.locatorParent.locatorChildDestroyed(this);
    }
    delete this.locatorParent;

    // remove ourselves from the canvas list
    this._canvasList();

    // remove ourselves from the top-level canvas list
    isc.Canvas._removeFromTopLevelCanvasList(this);

    // remove ourselves from the tab-order management system
    this._removeFromAutoTabOrder();

    // notify the EH that we've been destroyed so it can clear up any pointers it has to us
    isc.EH.canvasDestroyed(this);

    // clear our global ID (removes the window.ID pointer to us)
    isc.ClassFactory.dereferenceGlobalID(this);

    // If we have been notified of anything pointing to this object, remove that pointer.

    if (this.pointersToThis != null) {
        for (var i = 0; i < this.pointersToThis.length; i++) {
            var pointer = this.pointersToThis[i];
            if (pointer.object && (pointer.object[pointer.property] == this)) {
                // NOTE: don't use 'delete', as this crashes on the global window object in IE
                var undef;
                pointer.object[pointer.property] = undef;
            }
        }
        // Clear up our pointers in the other direction.
        delete this.pointersToThis;
    }

    // Clean up listeners of the `proportionalResizeModifiers` being pressed.
    this._checkProportionalResizing();

    // delete all properties

    if (this._deletePropsOnDestroy) {
        for (var prop in this) {
            delete this[prop];
        }
    }

    // release the unique IDs we generated for our DOM element(s) so they can be reused by other
    // widgets

    this._releaseDOMIDs();

    this._removeFromRuleScope();
},

//> @method canvas.markForDestroy()
// +link{canvas.destroy(),destroy()} this canvas on a timeout. This method should be used instead of
// calling <code>canvas.destroy()</code> directly unless there's a reason a the canvas needs to be
// destroyed synchronously. By using a timeout, this method ensures the <code>destroy()</code> will
// occur after the current thread of execution completes. This allows you to easily mark canvases
// for destruction while they're handling events, which must complete before the canvas can be
// destroyed.
// @see canvas.destroy()
// @visibility external
//<
markForDestroy : function () {

    if (isc._traceMarkers) arguments.__this = this;

    if (this.destroyed || this.destroying || this.isPendingDestroy()) return;
    this._pendingDestroy = true;

    this._logDestroy(false, false);
    isc.Canvas.scheduleDestroy(this);
},

isPendingDestroy : function () {
    return !this.destroyed && !this.destroying && (this._pendingDestroy == true);
},

_logDestroy : function (synchronous, indirectDestroy) {
    //>DEBUG
    if (this._iscInternal) return;
    // report every destroy for stats, but only log the direct destroys when
    // parents/masters destroy children/peers.
    if (synchronous) this._addStat("destroys");
    if (!indirectDestroy && this.logIsInfoEnabled("destroys")) {
        this.logInfo((synchronous ? "destroy()" : "markForDestroy()") +
                     (this.children && this.children.length > 0 ?
                      " (" + this.getChildCount() + " children) " : "") +
                     (this.logIsDebugEnabled("destroys") ? this.getStackTrace() : ""),
                     "destroys");
    }
    //<DEBUG
},

//> @method canvas.clearHandle()    (A)
//      Clear the canvas handle to free up memory (as much as we can anyway).
//      Note: this can assume that there actually is a handle.
//      @group  handles
//<
clearHandle : function (useRemoveChild) {
    var undef;

    // if we don't have a handle now, we've probably already been cleared...
    if (!this.getHandle()) return;

    // report each individual handle clear for the stat (only actual calls to clear() are
    // logged)
    this._addStat("clears");


    this.getHandle().eventProxy = null;
    this.getClipHandle().eventProxy = null;

    // If we have both a content element and a clip element, the clip element is the outer
    // element, so it's the one to destroy
    var handle = this.getClipHandle();

    // and clear our ref's to the handle so we don't try to access it again
    this._handle = null;
    this._styleHandle = null;
    this._clipDiv = null;

    // use 'Element.clear()' to actually erase the handle from the DOM.




    isc.Element.clear(handle, useRemoveChild || this._clearWithRemoveChild);

    if (isc.Browser._supportsWebkitOverflowScrolling && this._reapplyWebkitOverflowScrollingTouchTimer != null) {
        isc.Timer.clear(this._reapplyWebkitOverflowScrollingTouchTimer);
        this._reapplyWebkitOverflowScrollingTouchTimer = null;
    }


    delete this._setToDisplayNone;
    delete this._visibleDisplayStyle;


    this._$leftCoords = this._$topCoords = null;

    delete this._drewClipDiv;


    handle.onscroll = null;

    //>Animation
    if (this._momentumScrollId != null) {
        this.cancelAnimation(this._momentumScrollId);
        this._momentumScrollId = null;
    }
    //<Animation
},

// Replacing / Placing in the DOM
// --------------------------------------------------------------------------------------------

//> @method canvas.replaceWith()    (A)
//      Clear this canvas handle, and insert another canvas at the same place in the DOM
//      so if relatively positioned, the document will continue to flow around the replacement
//      @group  handles
//      @param  otherCanvas (widget)    Canvas with which to replace this one.
//<
replaceWith : function (otherCanvas) {
    // bail if passed something that isn't an object
    // (we'll accept either an object literal canvas init descriptor, or a canvas)
    if (!isc.isAn.Object(otherCanvas)) return;

    // -- Get all the information from 'this' we need:

    // In DOM browsers, for relatively positioned Canvii, place a marker in the DOM so that we
    // can put the replacing Canvas in exactly the same spot.  In Non-DOM browsers we can't do
    // a proper replace within the document flow instead we'll just clear this widget, and put
    // the replacement in the same parent.

    var marker;
    if (isc.Browser.isDOM) {

        // place a marker element in the DOM where this element was
        var ID = isc.ClassFactory.getNextGlobalID();
        isc.Element.insertAdjacentHTML(this.getClipHandle(), "afterEnd",
                                     "<DIV ID=" + ID + "></DIV>");
        var marker = this.getDocument().getElementById(ID);

        // pass the marker element to the replacing Canvas to indicate the place where it should
        // draw
        otherCanvas.drawContext = { element:marker };
    }

    // the widget replacing us needs to become a child/peer of our parent/master if we have one
    var parentElement = this.parentElement,
        masterElement = this.masterElement,
        //if the original Canvas was in a Layout, preserve it's position.

        inLayout = (isc.isA.Layout(parentElement) && parentElement.hasMember(this)),
        layoutPosition = (inLayout ? parentElement.getMemberNumber(this) : 0);

    // -- Completely remove this canvas
    // Note: We're removing this canvas *before* initializing the other object into a canvas
    // (if it's not already a Canvas) to avoid issues with colliding IDs.
    this.destroy();

    // get rid of the other canvas handle (*if it existed already)
    if (isc.isA.Canvas(otherCanvas)) {
        otherCanvas.clear();
    // If it's just an init block, set autoDraw to false and initialize
    } else {
        otherCanvas.autoDraw = false;

        otherCanvas = isc.ClassFactory.newInstance(otherCanvas);
        if (otherCanvas == null) {
            //>DEBUG
            this.logWarn("canvas.replaceWith(): Unable to create a widget " +
                         "instance from the argument passed in.  Returning.")
            //<DEBUG
            return;
        }
    }

    // draw the replacing Canvas as a Layout member, child, peer, or top-level widget according
    // to the replaced Canvas
    if (inLayout) {
        parentElement.addMember(otherCanvas, layoutPosition)
    } else if (parentElement) {
        parentElement.addChild(otherCanvas)
    } else if (masterElement) {
        masterElement.addPeer(otherCanvas)
    }

    if (!otherCanvas.isDrawn()) otherCanvas.draw();

    if (isc.Browser.isDOM) {
        // Remove the marker so it doesn't clutter up the document
        if (marker.parentNode) {
            marker.parentNode.removeChild(marker)
        } else {
            //>DEBUG
            this.logWarn("unable to clear marker")
            //<DEBUG
        }
    }

    // return the instance that replaced us
    return otherCanvas;
},

//> @method canvas.setDrawContext() [A]
// Set the DOM location where this Canvas should draw.<P>
// If the Canvas has a Canvas parent, it will deparent().<P>
// If the Canvas is already drawn, it will draw in the new location.
//
// @param drawContext (DrawContext) DrawContext object indicating a DOM location.  Pass null
//                                  to clear the draw context and draw at top level.
// @group drawContext
// @visibility drawContext
//<
setDrawContext : function (drawContext) {
    var wasDrawn = this.isDrawn();

    // deparent if we have a parent, since we don't know if the drawContext is inside the
    // existing parent (we could check, but for now, having a drawContext is logically distinct
    // from having a Canvas parent)
    this.deparent();

    if (wasDrawn) this.clear();
    this.drawContext = drawContext;
    if (wasDrawn) this.draw();
},


// HTML for Canvas main tag
// --------------------------------------------------------------------------------------------

// _getDOMID - helper to provide unique IDs for our DOM elements
// These DOM IDs are arbitrary strings provided by ClassFactory.getDOMID() which we write into
// the appropriate DOM sub elements we create.
// dontCache parameter: If passed we don't maintain a map from the partName to the generated ID -
// any cacheing of the generated ID by partName should be handled by the calling code.
_getDOMID : function (partName, dontCache, dontReuse) {
    // Allow callers to handle their own cacheing if desired
    if (dontCache) {
        var ID = isc.ClassFactory.getDOMID(this.getID(), partName);
        if (this.reuseDOMIDs) {
            if (!this._uncachedDOMIDs) this._uncachedDOMIDs = [];
            this._uncachedDOMIDs[this._uncachedDOMIDs.length] = ID;
        }
        return ID;
    }

    if (!this._domIDs) this._domIDs = {};
    if (!this._domIDs[partName])
    this._domIDs[partName] = isc.ClassFactory.getDOMID(this.getID(), partName);

    return this._domIDs[partName];
},
// helper to retrieve the part name based on DOM ID
_getDOMPartName : function (domID) {
    if (!this._domIDs) return null;
    // This is a reverse lookup. If performance becomes a concern we could maintain
    // a reverse map instead...
    for (var ID in this._domIDs) {
        if (this._domIDs[ID] == domID) return ID;
    }
},
// reuseDOMIDs
// On destroy() we call ClassFactory.releaseDOMIDs() so the auto-generated DOM IDs may be reused
// within the page.
reuseDOMIDs:false,
_releaseDOMIDs : function () {
    if (!this.reuseDOMIDs) return;

    if (this._uncachedDOMIDs) {
        for (var i = 0; i < this._uncachedDOMIDs.length; i++) {
            isc.ClassFactory.releaseDOMID(this._uncachedDOMIDs[i]);
        }
    }

    if (this._domIDs) {
        //this.logWarn("to release:"+ this.echo(this._domIDs));
        for (var i in this._domIDs) {
            isc.ClassFactory.releaseDOMID(this._domIDs[i]);
        }
    }
},

//> @method canvas.getCanvasName()  (A)
//          return the name for this object in the DOM
//
//      @return (string)    name of this canvas in the DOM
//
//<
_$canvas:"canvas",
getCanvasName : function () {
    // NOTE: this is called by getHandle(), imgHTML() and a few other spots, it needs to be
    // fast.

    if (!this._canvasName) this._canvasName = this._getDOMID(this._$canvas, true);
    return this._canvasName;
},

_$canvasClipDiv:"canvas_clipDiv",
_getClipDivDOMID : function () {
    return this._getDOMID(this._$canvasClipDiv);
},

getTransformCSS : function () {
    if (this.rotation != null) return ";" + isc.Element.getRotationCSS(this.rotation, this.transformOrigin);
    return null;
},

// If _useNativeTabIndex is true, is the focus handle actually the clipHandle
// overridden for GridRenderers in screenReader mode where we put native focus onto row elements
// within the grid body.
clipHandleIsFocusHandle:true,

_usingNativeDrag : function () {
    return isc.Browser.hasNativeDrag && this.canDrag && this.useNativeDrag;
},


_usingNativeTouchScrolling : function () {
    var handleOverflow = this._getHandleOverflow();
    return this.useNativeTouchScrolling && this._browserSupportsNativeTouchScrolling &&
           (handleOverflow === isc.Canvas.SCROLL || handleOverflow === isc.Canvas.AUTO);
},

//> @method canvas.getTagStart()    (A)
//          return the start tag for this canvas
//      @group  drawing
//
//      @return (string)    start tag for this canvas
//<
_$outlineStyleNone: ";outline-style:none",
_$divIdStart: "<div id='",
_$aIdStart: "<a href='#' id='",
getTagStart : function (dontConcat) {


    //this.logWarn("at draw, coordinates are: " + this.getRect());
    var canvas = isc.Canvas,
        handleOverflow = this._getHandleOverflow();

    

    // if we're set to automatic zIndex, resolve to a number now
    if (this.zIndex == canvas.AUTO) this.zIndex = canvas.getNextZIndex();

    // get the ID of the eventProxy for this object so we can write it into the tag
    var eventProxy = (this.eventProxy ? this.eventProxy.ID : this.ID);

    // for information on the necessity of this double DIV structure see "native size reporting
    // issues" comment
    var useClipDiv = this._shouldWriteClipDiv();
    var sizeArray = this._getInitialHandleSize(useClipDiv),
        width = sizeArray[0],
        height = sizeArray[1],
        left = this.left,
        top = this.top;

    if (this.showCustomScrollbars && this.vscrollOn && this.isRTL()) {
        left += this.getScrollbarSize();
    }

    var pageSpace = this._getPageSpace();
    top += pageSpace;

    // tabIndex, accessKey and focus.
    // ------------------
    // For accessability we need to support keyboard equivalents of everything you can
    // do with a mouse in ISC.
    // - tab and shift-tab are used to switch which ISC Canvas has the focus, such that
    //   it receives keyboard events.
    // - Alt+<accessKey> will 'jump' focus to the ISC canvas with the specified accessKey
    //   [In Firefox 2.0 this has become Alt+Shift+[accesskey] ]
    //
    // Where possible we should do this by leveraging native tabIndex and accessKey
    // support. This will minimize our strange interaction cases with elements that
    // support native tabIndex behavior (such as form items), and allow us to get
    // native, familiar tabIndex type focus behavior for free.
    // It also may be required for support of screen reader software.
    // We also need to support updating the tabIndex/accessKey of the widget on the fly.

    // Native tabIndex / accessKey behavior and considerations:
    // Not all browsers support focusability on every element type - some support focusability
    // only on form elements.  This creates a problem when we need to create keyboard
    // navigability for widgets whose rendering cannot possibly be based on the native <INPUT>
    // elements.
    //
    // ===== IE
    // Any element, including a DIV can be added to the tab-order of elements on a
    // page by setting it's TABINDEX property.  This can also be updated on the fly.
    // When native focus is given to an element, the onfocus handler is called for this
    // element (and when focus is taken away, onblur is fired for the element).
    // No document.onfocus / onblur event is fired when focusing on an HTML element.
    //
    // Setting the tabIndex property for any element in IE to be negative will exclude it
    // from the page's tab order.
    //
    // Setting the ACCESSKEY property on a div will cause focus to 'jump' to that div when
    // alt+accessKey is pressed.  Note that the accessKey can be set to any alpha-numeric
    // value (no symbols or full strings, case-insensitive for letters).
    //
    // Implementation for IE:
    //  -- Add TabIndex to the handle
    //  -- Add onfocus / onblur to keep track of which ISC element has focus
    //  -- Have widget.focus() and widget.blur() to call native element.focus() and
    //     element.blur()
    //
    // ===== Mozilla
    // - Firefox 1.5 and above: identical to IE, except for the following additional
    //   workarounds
    //   Limitations:
    //      AccessKeys - in Moz FF 1.5, an accessKey set on a div is not respected.
    //      We workaround this by writing an empty "<a>" tag between the clip div and the
    //      content div (after the content div), with a specified accessKey and a focus handler
    //      that puts focus into the widget.
    //      See _makeAccessKeyProxy().
    //      Focus on mouse down - In moz a div with a tabIndex will receive focus when clicked.
    //      However we set the tabIndex on the clipDiv, not the content div (this is appropriate
    //      - if we set the tabIndex on the content div, the focus outline appears around the
    //      text rather than around the entire widget). In this case clicking on the content
    //      div fails to put focus onto the clip div. We workaround this by explicitly focusing
    //      in the widget on mousedown in EventHandler.js
    //
    // Previous to FF 1.5, there seems to be no support for TABINDEX on any elements other than
    // "interactive" HTML elements.  This includes form items, buttons and
    // <a> </a> or <area> </area> tags *with an href set*.
    // Note: <area> tags are used within the <map> tag of a client side image-map to
    // denote clickable areas.
    // Therefore we can't use the same approach as in IE or just writing a tabIndex
    // directly onto a widget's handle.
    // Possible approaches:
    //  - We could set an <a> tag around the handle with an onclick / onmouseDown handler
    //    that prevents the "href" from ever being activated.
    //    Has some negative possible side effects,
    //      - window.status gets updated when the <a> gets focus
    //      - SPACE may attempt to navigate the browser to the href specified
    //      - changes the style of text within the handle
    //  - We can draw an interactive tag offscreen for each focusable item, where:
    //      - onfocus / onblur handler for the offscreen tag would update the ISC focus.
    //      - interactive tag's tabIndex and accessKey matches the specified values for the
    //        widget
    //    This is the approach we've taken - we're drawing offscreen 'focusProxy' button
    //    elements, to hold the widget's place in the page's native tab order.
    //
    // Note - to exclude focusable items from the page's tab order in Moz we must make
    // use of the property '-moz-user-focus' - setting this to "ignore" will exclude the
    // item from the page's tab order.  In order to make this more user-friendly,
    // automatically interpret a negative specified tabIndex to mean the developer wants the
    // widget excluded from the tab order, and set this property to 'ignore' on the
    // focusProxy.
    //
    // Implementation, for Moz pre ff 1.5:
    //  -- For each 'focusable' widget, create a button element called a focusProxy.
    //     This button is hidden - it is clipped by a parent div, and absolutely positioned
    //     behind the widget on the page (to ensure that when the element receives native focus
    //     it is scrolled into view.
    //  -- Give the focusProxy the same tabIndex and accessKey as the widget.
    //  -- Write onfocus and onblur handlers for the focusProxy that put the 'virtual ISC
    //     focus' onto the widget
    //  -- Modify the 'setFocus()' method to natively focus on the focusProxy for a widget.
    //     (this in turn fires the onfocus handler that tells the EventHandler which widget
    //     has ISC-focus)
    //  -- Ensure the focusProxy stays 'in synch' with the widget's handle -- this means
    //      o update the visibility of the focusProxy as the visibility of the handle
    //        is changed - this correctly excludes hidden widgets from the page's tab order.
    //      o clear the focusProxy when the widget get's cleared (and write it back out if
    //        the widget is draw()n)
    //      o clear / redraw the focusProxy if the 'setCanFocus()' method updates a widget's
    //        focus-ability at runtime.
    //
    // ===== Chrome
    // In Chrome, we need to leverage the accessKeyProxy subsystem - unfortunately, onfocus()
    // doesn't always fire in Chrome (not at all for some form-item types and in some other
    // specific circumstances) - however, in such circumstances, it *will* still fire
    // onClick().  So, specifically for Chrome, handle onClick() rather than onfocus()in the
    // adjacentHTML we write out for the proxy. *Note*: as at now (8/3/12), certain
    // key-combinations that are implemented internally by Chrome seem not to be useable by SC.
    // For instance, Shift-Alt-B always selects the Bookmarks bar in Chrome (and with no
    // visible indication that it's done so until you use the arrow-keys to move the cursor,
    // giving the appearance that focus has simply disappeared!)
    //
    // =====
    // In Safari native buttons and native div's dont support keyboard access via tabbing.
    // FormItems do, so we use a TextArea as our focusProxy in this browser. Other than this
    // the logic is the same as for Moz pre FF 1.5
    //
    // Suppressing native focus outlines:
    // Native focus outlines show up in IE and Moz 1.5 and above (where we use native tab indices)
    // We want to suppress these for some widgets, such as menus.
    // This is controlled by the showFocusOutline property (defaults to true, set to false to suppress the
    // native focus outline).
    // In IE we use the proprietary 'hideFocus=true' attribute to suppress this
    // In other browsers we use the css attribute 'outline-style:none'

    if (!canvas._onFocus) {
        canvas._onFocus = " onfocus=";
        canvas._onBlur = " onblur=";
        canvas._tabIndex = " tabindex="
        canvas._accessKey = " accessKey=";
    }

    var isMoz = isc.Browser.isMoz;

    // Convert this.opacity to a usable value
    var opacity = this.opacity;
    // CSS opacity uses a decimal between 0 and 1 approach for specifying opacity (correct for
    // both Moz, Safari, and IE9)
    if (!isc.Browser.isIE || isc.Browser.isIE9) {
        if (opacity != null) opacity = opacity / 100;
    }
    if (isc.Browser.isMoz) {

        if (this.smoothFade && (opacity == 1 || opacity == null)) opacity = 0.9999;
    }

    var usingNativeDrag = this._usingNativeDrag(),
        usingNativeTouchScrolling = this._usingNativeTouchScrolling();

    if (useClipDiv) {
        //>DoubleDiv

        var cursor = this.getCurrentCursor(),
            focusString,
            focusOutlineStyle,
            nativeTabIndex = this._useNativeTabIndex;

        var borderHTML = this._getBorderHTML() || "",
            borderRadiusHTML = this._getBorderRadiusHTML() || "";

        if (this.clipHandleIsFocusHandle == false) nativeTabIndex = false;

        if (nativeTabIndex && this._canFocus()) {
            focusString = isc.SB.concat(
                canvas._onFocus, this._getNativeFocusHandlerString(),
                canvas._onBlur, this._getNativeBlurHandlerString(),
                !this.isDisabled() ? canvas._tabIndex + this.getTabIndex() : null,
                // Don't write an accessKey into the handle if we're going to use
                // an accessKeyProxy
                (!this._useAccessKeyProxy() && this.accessKey != null) ?
                    canvas._accessKey + this.accessKey :
                    null
            );

            if (isc.Browser.isMoz) {
                // In Moz, if we are using native tab-indices, the dotted focus
                // outline by default appears 1px outside the clip-div.
                // This would be fine except it is clipped by any parents of this widget and
                // obscured by any other siblings that are adjacent to the widget and have a
                // higher z-index.
                // Moz has a useful css extension -moz-outline-offset which allows us to
                // have the focus outline render a specified distance from the element, including
                // inside, via applying a negative value. This avoids the problem with parents
                // and siblings obscuring the outline.
                // In most cases we use this and it gives us a reasonable solution for a focus
                // outline.
                // However the contents of the content-div  div will obscure the
                // outline if it contains some solid element that extends to the edge of the
                // canvas, such as a  grid-renderer's table, or an image.
                // We could possibly resolve this issue by using the "focus" pseudo css class
                // to apply a custom border in this case instead of relying on the native focus
                // outline.  However this could shift internal content, and besides, we expect
                // this bug will be fixed.
                // For now just provide a property so we can set the offset depending on the
                // widget in question to give as much flexibility as possible.
                // Note: If the widget has a border, or padding, the focus outline shows up
                //  over the border / padding rather than over the content, when the specified
                //  offset is -1px.
                // Note: there is a further Moz bug with widgets showing native scrollbars where,
                // when scrolling, a series of horizontal lines appears over the content due to
                // incorrect redraw of the focus outline.
                focusOutlineStyle = isc.StringBuffer.concat(
                    (this.mozOutlineOffset != null
                        ? ";-moz-outline-offset:" + this.mozOutlineOffset : null),
                    // We also allow customization of the color of the Moz Focus outline.
                    // By default, in FF 1.5 (tested against 1.5.0.3) the color is supposed to invert
                    // whatever it's sitting on top of - however when the background is gray
                    // the focus outline is the same color so isn't visible.
                    // We therefore allow per-widget customization of the color.
                    (this.mozOutlineColor != null
                        ? ";-moz-outline-color:" + this.mozOutlineColor : null),

                    (!this.showFocusOutline
                        ? this._$outlineStyleNone : null)
                );

            // Safari and other modern browsers also support suppressing focus outline via simple "outline" css
            // http://caniuse.com/#feat=outline
            } else if (!this.showFocusOutline) {
                focusOutlineStyle = this._$outlineStyleNone;
            }
        }

        // use two DIVs: an inner one to hold the content, and an outer one for clipping
        var output = isc.StringBuffer.concat(

            // the clipDiv
            this._$divIdStart, this._getClipDivDOMID(),
            "' eventProxy=" , eventProxy,
            (this.ariaRole ? " role='" + this.ariaRole + "'" : ""),
            (this.ariaState && this.getAriaStateAttributes ? this.getAriaStateAttributes() : ""),
            (this.className ? " class='" + this.className + "'" : ""),
            focusString,
            " style='",
                "POSITION:" , this.position,
                ";LEFT:" , left,
                "px;TOP:" , top,
                "px;WIDTH:" , width,
                "px;HEIGHT:" , height,
                "px;Z-INDEX:" , this.zIndex,
                (this.visibility == canvas.INHERIT ? "" : ";VISIBILITY:" + this.visibility),
                (this.backgroundColor == null ?
                    "" : ";BACKGROUND-COLOR:" + this.backgroundColor),
                (this.backgroundImage == null ? "" :
                    ";BACKGROUND-IMAGE:url(" + this.getImgURL(this.backgroundImage) +")" +
                    ";BACKGROUND-REPEAT:"+this.backgroundRepeat +
                    (this.backgroundPosition ?
                        ";BACKGROUND-POSITION:"+this.backgroundPosition : "")),
                (this.textColor == null ? "" : ";COLOR:" + this.textColor),

                // border on outer DIV because it should not scroll
                borderHTML,borderRadiusHTML,

                // padding should scroll and should be included in the drawn content size,
                // so it goes on the contentDiv.
                // If this.padding is set, force the padding for the clipDiv to be zero.
                // Therefore if the style applied to the clipDiv has padding specified we
                // don't draw something with both sets of padding.

                (this._willSuppressOuterDivPadding() ? ";PADDING:0px" : ""),

                // margin must also be on the outer container, since borders are
                this._getMarginHTML(),
                // In Moz we set style.-moz-opacity to a value between zero and one to get opacity
                // In Safari we set style.opacity to a value between zero and one.
                (opacity != null ?
                    (this._useMozOpacity ? ";-moz-opacity:" : ";opacity:") + opacity :
                    ""),
                // use box sizing model where specified size includes border and padding
                (!this.isBorderBox ? null
                                   : ";" + isc.Element._boxSizingCSSName + ":border-box"),
                focusOutlineStyle,
                this.getTransformCSS(),
                // Touch browsers: set -webkit-user-select:none to disable user selection
                // for copy (touch and hold/wait for blue rectangle).
                (isc.Browser.isTouch
                    ? (!this.canSelectText ? ";-webkit-user-select:none" : ";-webkit-user-select:text")
                    : null),

                (isc.Browser.isTouch
                    ? ";-webkit-tap-highlight-color:rgba(0,0,0,0)"
                    : null),


                (usingNativeDrag && isc.Browser.isSafari
                    ? ";-khtml-user-drag:element"
                    : null),

                (isc.Browser._hasElementPointerEvents
                    ? (this.cssPointerEvents != null
                          ? ";pointer-events:" + this.cssPointerEvents
                          // `pointer-events' is inherited. If we have a parent that specifies
                          // cssPointerEvents, make sure to reset the child's `pointer-events'
                          // back to the default.
                          : (this.parentElement != null && this.parentElement.cssPointerEvents != null
                                ? ";pointer-events:auto"
                                : null))
                    : null),

                this.styleText ? ";" + this.styleText : "",

                ";OVERFLOW:",
                handleOverflow,

                (isc.Browser._supportsWebkitOverflowScrolling
                 ? (usingNativeTouchScrolling ? ";-webkit-overflow-scrolling:touch" : ";-webkit-overflow-scrolling:auto")
                 : null),

                ";' ONSCROLL='return " + eventProxy + "._handleCSSScroll()'",

                (usingNativeDrag ? " draggable='true'" : null),

                (pageSpace != 0 ? " data-isc-page-space='" + pageSpace + "'" : null),
                (this.overflowStyle != null ? " data-isc-overflow-style='" + this.overflowStyle + "'" : null),
                ">",

            // the contentDiv
            "<div id='" , this.getCanvasName(),
            "' eventProxy='" , eventProxy,
            (this.textDirection != null ? "' dir='" + this.textDirection : ""),
            "' style='POSITION:relative;",

                (!(this.padding > 0 || (this.topPadding > 0 && this.bottomPadding > 0))
                 ? (isc.Browser.isSafari
                    ? "-webkit-margin-collapse:separate separate;"
                    : (!(isc.Browser.isOpera && isc.Browser.version < 10)
                       ? "display:inline-block;" + isc.Element._boxSizingCSSName + ":border-box;width:100%;vertical-align:top;"
                       : ""))
                 : ""),
                "VISIBILITY:inherit;Z-INDEX:" , this.zIndex,
                (cursor == canvas.AUTO ? "" : ";CURSOR:" + cursor),
                // padding should be included in the drawn content size, so it goes on the
                // contentDiv
                (this.padding != null ? ";PADDING:" + this.padding + "px" : ""),
                // Unexposed per-side padding
                (this.topPadding != null ? ";padding-top:" + this.topPadding + "px" : ""),
                (this.bottomPadding != null ? ";padding-bottom:" + this.bottomPadding + "px" : ""),
                (this.leftPadding != null ? ";padding-left:" + this.leftPadding + "px" : ""),
                (this.rightPadding != null ? ";padding-right:" + this.rightPadding + "px" : ""),
                ";'>"
        );

        //<DoubleDiv
    } else { // Use a single DIV
        //>SingleDiv
        var styleEndSlot = 67;
        if (!canvas._divHTML) {
            canvas._absolutePos = " style='POSITION:absolute;LEFT:";
            canvas._relativePos = " style='POSITION:relative;LEFT:";
            canvas._className = " class='";
            canvas._closeClassName = "'";
            // we write the 'pageSpace' value used (if not 0) into the handle, as a data attribute
            canvas._dataPageSpace = " data-isc-page-space='";
            canvas._visibility = ";VISIBILITY:";
            canvas._$cursor = ";CURSOR:";

            var divHTML = canvas._divHTML = [];
            // [0] _$divIdStart / _$aIdStart
            // [1] ID
            divHTML[2] = "' eventProxy=";
            // [3] eventProxy
            // [4] optional " CLASS=";
            // [5] optional className
            // [6] optional close className
            // [7] optional textDirection
            // [8] " STYLE='POSITION:" relative or absolute + ";LEFT:"
            // [9-14] left
            divHTML[15] = "px;TOP:";
            // [16-21] top
            divHTML[22] = "px;WIDTH:";
            // [23-27] width
            divHTML[28] = "px;HEIGHT:";
            // [29-33] height

            divHTML[34] = "px;Z-INDEX:";
            // [35-41] zIndex

            divHTML[44] = (this.styleText ? ";" + this.styleText : "") + ";OVERFLOW:";
            // [45] overflow
            // [46] visibility
            // [47] visibility
            // [48] background-color
            // [49] background-image
            // [50] Moz box sizing
            // [51] cursor
            // [52] cursor
            // [53] margin
            // [54] padding
            // [55] border
            // [56] opacity
            // [57] flash filter
            // [58] CSS transforms
            // [59] margin-collapse
            // [60] -webkit-user-select
            // [61] -webkit-tap-highlight-color
            // [62] -khtml-user-drag
            // [63] outline-style
            // [64]
            // [65] -webkit-overflow-scrolling
            // [66] pointer-events
            // NOTE: in IE, DIV scroll events can't be captured at the window level.
            divHTML[styleEndSlot] = "' ONSCROLL='return ";
            // [styleEndSlot + 1] eventProxy
            divHTML[styleEndSlot + 2] = "._handleCSSScroll()' ";
            // [gap styleEndSlot + 3]
            // [gap styleEndSlot + 4]
            // [several slots (styleEndSlot + 5)+] focus/blur/tabIndex/accessKey
        }
        var divHTML = canvas._divHTML;


        divHTML[0] = (usingNativeDrag && isc.Browser.isIE && !isc.Browser.isIE10
                      ? this._$aIdStart
                      : this._$divIdStart);
        divHTML[1] = this.getCanvasName();
        divHTML[3] = eventProxy;
        // optional className (note that Button and other table-based Canvii omit className at
        // the DIV level and apply it to the cell)
        if (this.className != null) {
            divHTML[4] = canvas._className;
            divHTML[5] = this.className;
            divHTML[6] = canvas._closeClassName;
        } else {
            divHTML[4] = divHTML[5] = divHTML[6] = null;
        }

        divHTML[7] = (this.textDirection != null ? " dir=" + this.textDirection : null);

        divHTML[8] = (this.position == canvas.RELATIVE ? canvas._relativePos :
                      canvas._absolutePos);

        // 6 slots mostly due to the tendency to use "-10000" as a large offscreen coordinate
        isc._fillNumber(divHTML, left, 9, 6);
        isc._fillNumber(divHTML, top, 16, 6);
        isc._fillNumber(divHTML, width, 23, 5);
        isc._fillNumber(divHTML, height, 29, 5);


        if (this.zIndex != canvas.AUTO) isc._fillNumber(divHTML, this.zIndex, 35, 9);
        else {
            divHTML[35] = this.zIndex;
            divHTML[36] = divHTML[37] = divHTML[38] = divHTML[39] =
                    divHTML[40] = divHTML[41] = divHTML[42] = divHTML[43] = null;
        }

        divHTML[45] = handleOverflow;
        if (this.visibility != canvas.INHERIT) {
            divHTML[46] = canvas._visibility;
            divHTML[47] = this.visibility;
        } else {
            divHTML[46] = divHTML[47] = null;
        }
        divHTML[48] = (this.backgroundColor == null ? null :
                       ";BACKGROUND-COLOR:" + this.backgroundColor);
        divHTML[49] = (this.backgroundImage == null ? null :
                       ";BACKGROUND-IMAGE:url(" + this.getImgURL(this.backgroundImage) +
                       ");BACKGROUND-REPEAT:"+this.backgroundRepeat +
                    (this.backgroundPosition ?
                        ";BACKGROUND-POSITION:"+this.backgroundPosition : ""));
        if (!this.isBorderBox) {
            divHTML[50] = null;
        } else {

            divHTML[50] = ";" + isc.Element._boxSizingCSSName + ":border-box";
        }

        var cursor = this.getCurrentCursor();
        if (cursor == canvas.AUTO) {
            divHTML[51] = divHTML[52] = null;
        } else {
            divHTML[51] = canvas._$cursor;
            divHTML[52] = cursor;
        }
        divHTML[53] = this._getMarginHTML();
        divHTML[54] = (this.padding != null ? ";PADDING:" + this.padding + isc.px : null);
        // Unexposed per-side padding
        if (this.topPadding != null)
            divHTML[54] = (divHTML[54] || "") + ";padding-top:" + this.topPadding + "px";
        if (this.bottomPadding != null)
            divHTML[54] = (divHTML[54] || "") + ";padding-bottom:" + this.bottomPadding + "px";
        if (this.leftPadding != null)
            divHTML[54] = (divHTML[54] || "") + ";padding-left:" + this.leftPadding + "px";
        if (this.rightPadding != null)
            divHTML[54] = (divHTML[54] || "") + ";padding-right:" + this.rightPadding + "px";

        var borderHTML = this._getBorderHTML() || "",
            borderRadiusHTML = this._getBorderRadiusHTML() || "";
        divHTML[55] =  borderHTML + borderRadiusHTML;
        if (isc.Browser.isIE && !isc.Browser.isIE9) {

            if (!isc.Browser.useCSSFilters && isc.Img && isc.isA.Img(this)) {
                divHTML[56] = ";filter:none;";
                divHTML[57] = null;
            } else {
                 if (!isc.Canvas.neverUseFilters || this.useOpacityFilter) {
                     divHTML[56] = (opacity == null ? null :
                           ";filter:progid:DXImageTransform.Microsoft.Alpha(opacity="+opacity+")");
                } else {
                    divHTML[56] = null;
                }
                if (!isc.Canvas.neverUseFilters) {

                    if (this._avoidRedrawFlash) {
                        divHTML[57] = ";filter:progid:DXImageTransform.Microsoft.iris(irisStyle=circle)";
                    } else {
                        divHTML[57] = null;
                    }
                } else {
                    divHTML[57] = null;
                }
            }

        } else {
            if (opacity != null) {
                divHTML[56] = (this._useMozOpacity ? ";-moz-opacity:" : ";opacity:") + opacity;
            } else {
                divHTML[56] = null;
            }
        }
        divHTML[58] = this.getTransformCSS();

        if (isc.Browser.isWebKit) {
            divHTML[59] = ";-webkit-margin-collapse:collapse collapse";
        } else if (isc.Browser._useNewSingleDivSizing) {
            divHTML[59] = ";display:inline-block";
        } else {
            divHTML[59] = null;
        }

        if (isc.Browser.isTouch) {
            divHTML[60] = !this.canSelectText ? ";-webkit-user-select:none" : ";-webkit-user-select:text";
            divHTML[61] = ";-webkit-tap-highlight-color:rgba(0,0,0,0)";
        } else {
            divHTML[60] = null;
            divHTML[61] = null;
        }

        if (usingNativeDrag && isc.Browser.isSafari) {
            divHTML[62] = ";-khtml-user-drag:element";
        } else {
            divHTML[62] = null;
        }

        if (!this.showFocusOutline) {
            divHTML[63] = this._$outlineStyleNone;
        } else {
            divHTML[63] = null;
        }

        if (usingNativeDrag && isc.Browser.isIE && !isc.Browser.isIE10) {

            divHTML[64] = ";display:block;text-decoration:none";
        } else {
            divHTML[64] = null;
        }

        if (isc.Browser._supportsWebkitOverflowScrolling) {

            if (usingNativeTouchScrolling) {
                divHTML[65] = ";-webkit-overflow-scrolling:touch";
            } else {
                divHTML[65] = ";-webkit-overflow-scrolling:auto";
            }
        } else {
            divHTML[65] = null;
        }

        if (isc.Browser._hasElementPointerEvents) {
            var cssPointerEvents,
                parentElement;
            if ((cssPointerEvents = this.cssPointerEvents) != null) {
                divHTML[66] = ";pointer-events:" + cssPointerEvents;

            // `pointer-events' is inherited. If we have a parent that specifies cssPointerEvents,
            // make sure to reset the child's `pointer-events' back to the default.
            } else if ((parentElement = this.parentElement) != null &&
                       (cssPointerEvents = parentElement.cssPointerEvents) != null)
            {
                divHTML[66] = ";pointer-events:auto";

            } else {
                divHTML[66] = null;
            }

        } else {
            divHTML[66] = null;
        }

        divHTML[styleEndSlot + 1] = eventProxy;

        var lastSlot = styleEndSlot + 5;
        if (this._canFocus() && this._useNativeTabIndex && this.clipHandleIsFocusHandle) {
            divHTML[lastSlot    ] = canvas._onFocus;
            divHTML[lastSlot + 1] = this._getNativeFocusHandlerString();
            divHTML[lastSlot + 2] = canvas._onBlur;
            divHTML[lastSlot + 3] = this._getNativeBlurHandlerString();
            if (!this.isDisabled()) {
                divHTML[lastSlot + 4] = canvas._tabIndex;
                isc._fillNumber(divHTML, this.getTabIndex(), lastSlot + 5, 5, true);
                if (this.accessKey != null) {
                    divHTML[lastSlot + 10] = canvas._accessKey;
                    divHTML[lastSlot + 11] = this.accessKey;
                    lastSlot += 12;
                } else lastSlot += 10;

                if (isc.Browser.isIE && !this.showFocusOutline) {
                    if (!canvas._$hideFocus) canvas._$hideFocus = " hideFocus=true";
                    divHTML[lastSlot++] = canvas._$hideFocus;
                }

            } else lastSlot += 4;
        }

        if (usingNativeDrag) {
            divHTML[lastSlot++] = " draggable='true'";
        }

        if ((this.ariaRole || this.ariaState) &&
            isc.Canvas.ariaEnabled() && !isc.Canvas.useLiteAria())
        {
            if (this.ariaRole) {
                divHTML[lastSlot++] = " role='";
                divHTML[lastSlot++] = this.ariaRole;
                divHTML[lastSlot++] = "' ";
            }
            if (this.ariaState && this.getAriaStateAttributes) {
                divHTML[lastSlot++] = this.getAriaStateAttributes();
            }

        }

        if (pageSpace != 0) {
            divHTML[lastSlot++] = canvas._dataPageSpace;
            divHTML[lastSlot++] = pageSpace;
            divHTML[lastSlot++] = this._$singleQuote;
        }

        if (this.overflowStyle != null) {
            divHTML[lastSlot++] = " data-isc-overflow-style='";
            divHTML[lastSlot++] = this.overflowStyle;
            divHTML[lastSlot++] = this._$singleQuote;
        }



        // trim focus-related strings left in the template by the last widget, and end
        // start tag
        divHTML.length = lastSlot;
        divHTML[lastSlot] = this._$rightAngle;

        // code to grab a sample of the HTML written for the first instance of each class
        /*
        var className = this.getClass();
        if (!canvas._sampled) canvas._sampled = {};
        if (!canvas._sampled[className]) {
            this.logWarn("html for first instance of:" + className + ": " + divHTML.join(""));
            canvas._sampled[className] = true;
        }
        */

        if (dontConcat) output = divHTML;
        else output = divHTML.join(isc.emptyString);
        //<SingleDiv
    }

    this._drewClipDiv = useClipDiv;
    return output;
},



_$marginLeft : "MARGIN-LEFT:",
_$marginRight : "MARGIN-RIGHT:",
_$marginTop : "MARGIN-TOP:",
_$marginBottom : "MARGIN-BOTTOM:",
_$margin : "MARGIN:",

_getMarginHTML : function () {

    // optimization: if we have nothing that would introduce automatic per-side margin
    // settings..
    if (!this._edgesAsPeer() && this._attachedPeerMap == null) {
        // don't write out margins CSS if we have no margins setting
        if (this.margin == null) return null;
        // write out only a symmetric margin setting
        return isc.SB.concat(isc.semi, this._$margin, this.margin, isc.px);
    }

    // Support asymmetric margins if necessary.
    var margins = this._calculateMargins(),
        cssText = isc.SB.concat(
             isc.semi, this._$marginLeft, margins.left, isc.px,
             isc.semi, this._$marginRight, margins.right, isc.px,
             isc.semi, this._$marginTop, margins.top, isc.px,
             isc.semi, this._$marginBottom, margins.bottom, isc.px
        );
    //this.logWarn("margins: " + cssText);
    return cssText;
},

_getBorderHTML : function () {
    return this.border ? ";BORDER:" + this.border : null;
},

_getBorderRadiusHTML : function () {
    return this.borderRadius ? ";BORDER-RADIUS:" + this.borderRadius : null;
},

//> @method canvas.getTagEnd()  (A)
//          return the end tag for this canvas
//      @group  drawing
//
//      @return (string)    end tag for this canvas
//<
_singleDIV: "</div>",
_singleDIVNativeDrag: "</a>",
_doubleDIV: "</div></div>",
getTagEnd : function () {

    //>DoubleDiv two closing tags if clipDiv is being used.
    if (this._drewClipDiv) return this._doubleDIV;
    //<DoubleDiv

    //>SingleDiv
    return (this._usingNativeDrag() && isc.Browser.isIE && !isc.Browser.isIE10
            ? this._singleDIVNativeDrag
            : this._singleDIV);
    //<SingleDiv
},

// _getHandleOverflow()
// Internal method to determine the desired overflow setting for the widgets handle.
// Note - this is used for the clipHandle (not the contentHandle) if we're showing a clipHandle.
// Called from both getTagStart() and setOverflow()
_getHandleOverflow : function () {
    // if we're writing an IFrame into our handle, we size it to fit our
    // content. Always suppress any native scrollbars on our handle. If scrolling of the
    // iframe content is required, this is handled by native scrollbars on the iframe
    // handle.

    if (this.containsIFrame()) {
        return this._$hidden;
    }

    var overflow = this.overflow;

    var scrolling = (this.overflow === isc.Canvas.SCROLL || this.overflow === isc.Canvas.AUTO),
        customScrolling = scrolling && this.showCustomScrollbars,
        nativeScrolling = scrolling && !this.showCustomScrollbars;
    // when we use custom scrollbars, we tell the browser that the overflow should be hidden so
    // that the browser doesn't draw scrollbars.  Then we have our scrollbars move the hidden
    // overflow into view via scripting.
    // See getScrollingMechanism(), and comments near showCustomScrollbars definition above.
    if (this.overflow == isc.Canvas.HIDDEN || customScrolling) {
        if (this.alwaysShowScrollbars &&
            this.useNativeTouchScrolling && this._browserSupportsNativeTouchScrolling)
        {
            // when custom scrollbars *and* native touch scrolling are enabled, leave the
            // overflow unchanged


        } else if (this._useMozScrollbarsNone) {
            overflow = this._canScrollHidden ? this._$hidden : "-moz-scrollbars-none";
            this._useMozScrollSize = true;
        } else {
            overflow = this._$hidden;
        }

    } else if (isc.Browser.isOpera && this.overflow == isc.Canvas.VISIBLE) {
        overflow = this._$hidden;
    } else if (isc.Browser.isIE    && this.overflow == isc.Canvas.VISIBLE) {
        if (this.forceHandleOverflowHidden) overflow = this._$hidden;
    } else if (isc.Browser.isMoz) {
        if (nativeScrolling) this._useMozScrollSize = true;

        else if (this._useMozScrollbarsNone) {
            overflow = this._canScrollHidden ? this._$hidden : "-moz-scrollbars-none";
            this._useMozScrollSize = true;
        }
    }

    // if a clipDiv is being used, it will need to be set to overflow:hidden if the canvas is to
    // behave as overflow:clip-h/clip-v, because an overflow:visible DIV won't clip contained
    // content, and we can't use clip regions in NS6.
    if (this._drewClipDiv &&
        (this.overflow == isc.Canvas.CLIP_H || this.overflow == isc.Canvas.CLIP_V))
    {
        overflow = this._$hidden;
    }
    return overflow;
},

// _getInitialHandleSize()
// Internal function to return the specified width / height to write out to the handle initially
// used by getTagStart() and setOverflow()
// NOTE: returns the same Array instance every time.  Retrieve values before calling again.
_fillArray : [],
_getInitialHandleSize : function (useClipDiv) {

    var width = this.getInitialWidth(),
        height = this.getInitialHeight();
    return this._adjustHandleSize(width, height, useClipDiv);
},

// NOTE: these two very advanced functions allow you to specify an initial size for the handle
// which differs from this.width/height.  To be really complete, allowing the handle to have a
// completely different size from the specified size of the Canvas, similar entry points should
// exist for setHandleRect().
getInitialWidth : function () {
    return this.getWidth();
},

getInitialHeight : function () {
    return this.getHeight();
},

// In Mozilla we explicitly specify border-box sizing for canvii.
// In other browsers we have no control over border-box vs content-box sizing, so we
// rely on the default browser behavior for DIVs
isBorderBox:(isc.Browser.isMoz || isc.Browser.isBorderBox),


//> @method canvas._adjustHandleSize()  (I)
//      Internal helper method.
//      Given a desired width and height, return the width and height we must actually write into
//      the handle such that when drawn, the widget, will be the specified size, including all
//      border and padding (effectively fitting the 'content box' sizing model.)
//      Also adjusts for space taken up by custom scrollbars if required.
//      Called from getTagStart() and setHandleRect();
//
//      NOTE: returns the same Array instance every time.  Don't call again without retrieving
//      values first.
//
//      @visibility internal
//      @group  sizing
//
//      @return     (array)     2 element array containing [width,height] to write into the handle
//<
_adjustHandleSize : function (width, height, useClipDiv) {


    var margins = this._calculateMargins();

    if (useClipDiv == null) useClipDiv = this._drewClipDiv;

    // If passed null for width / height just return it
    if (width != null) {
        // when using custom scrollbars, we shrink the handle to leave room for the scrollbar
        if (this.showCustomScrollbars && this.vscrollOn) {
            width -= this.getScrollbarSize();

        }

        // The CSS2 box model specifies that content can be surrounded, from inside to out, by
        // padding, then a border, then margins.
        //     http://www.w3.org/TR/REC-CSS2/box.html
        //
        // The CSS2 spec also says that the width and height specified for an element should be
        // taken as the width and height *without* padding, border or margins (the "content-box"
        // model).  Older browsers implemented width/height as meaning width/height *with*
        // border and padding (the "border-box" model).
        //
        // In CSS3, you will be able to specify what sizing model you want via the "box-sizing:"
        // attribute.  Some browsers already support this.
        //
        // The border-box model is much saner, as the alternative is that in order to get
        // something to be a particular size in order to fit into a layout, you have to subtract
        // off the size of the border and padding up front, which implies you must know the
        // border and padding size despite the fact that such things are supposed to be
        // externalized into style sheets.
        //
        // We take this a step further - the specified size for any widget will be the drawn size
        // including border, padding, AND margins.
        // This is desirable because it allows the developer to handle separating widgets within
        // layouts by applying margins to the widgets.
        // We handle this by subtracting the margins (and in browsers that cannot be told to use
        // the border-box model, padding and border) from a widget, and applying that adjusted
        // size to the handle.
        //
        //

        // In order to get the desired handle size (to write into the DOM):
        // In all browsers subtract margin sizes.
        //
        width -= (margins.left + margins.right);
        //width -= (this.getLeftMargin() + this.getRightMargin());

        if (this.isBorderBox) {
            // border-box (either DIV structure): nothing
        } else if (useClipDiv) {
            // double DIV structure used in browsers with bad size reporting.
            // If padding is explicitly specified, it gets placed on the content div.
            // If padding is specified in the css style definition, it's typically placed
            // on the outer div, so we need to adjust for border and padding.
            // Exception: If the _suppressOuterDivPadding property has been set we
            // explicitly zero out padding on the clip div and apply it to the content
            if (!this._willSuppressOuterDivPadding(false, true)) {
                width -= this.getHBorderPad();
            } else {
                width -= this.getHBorderSize();
            }

        } else {
            // single DIV content-box, eg, IE strict
            width -= this.getHBorderPad();
        }
    }

    if (height != null) {

        if (this.showCustomScrollbars && this.hscrollOn) {
            height -= this.getScrollbarSize();
        }
        height -= (margins.top + margins.bottom);

        if (this.isBorderBox) {
        } else if (useClipDiv) {
            if (!this._willSuppressOuterDivPadding(true, false)) {
                height -= this.getVBorderPad();
            } else {
                height -= this.getVBorderSize();
            }
        } else {
            height -= this.getVBorderPad();
        }
    }

    // If the sizes are negative default them to 1

    if (width != null && width < 1) {
        this.logInfo("Specified width:" + this.getInitialWidth() + " adjusted for border, margin, " +
                     "and scrollbars would cause initial handle size to be less than or equal to " +
                     "zero, which is not supported. Clamping handle width to 1px.", "sizing");
        width =1;
    }
    if (height != null && height < 1) {
        this.logInfo("Specified height:" + this.getInitialHeight() + " adjusted for border, margin, " +
                     "and scrollbars would cause initial handle size to be less than or equal to " +
                     "zero, which is not supported. Clamping handle height to 1px.", "sizing");
        height =1;
    }

    // NOTE: reuse an Array
    var arr = this._fillArray;
    arr[0] = width;
    arr[1] = height;
    return arr;
},

// For double-div widgets, padding should scroll and should be included in the
// drawn content size, so it goes on the contentDiv.
// If this.padding is set, force the padding for the clipDiv to be zero.
// Therefore if the style applied to the clipDiv has padding specified we
// don't draw something with both sets of padding.

_willSuppressOuterDivPadding : function (v, h) {
    return (this.padding != null || this._suppressOuterDivPadding ||
            // vertical param explicitly false - we don't care about
            // top/bottom padding - otherwise check for it.
            (v != false ? (this.topPadding != null || this.bottomPadding != null) : false) ||
            (h != false ? (this.leftPadding != null || this.rightPadding != null) : false) );
},


// _getNativeFocusHandlerString() and _getNativeBlurHandlerString()
// These methods return the native onblur / onfocus handler function strings for use when
// using native focus / blur behavior.  Used by getTagStart / getFocusProxyHTML when writing
// out the onblur / onfocus handler attributes.
_$focusStart : "isc.EH.focusInCanvas(",

_$mozFocusStart : "if(event.target!=this)return;isc.EH.focusInCanvas(",

_$blurStart : "if(window.isc)isc.EH.blurFocusCanvas(",
_$focusEnd : ",true);",
_getNativeFocusHandlerString : function (unquoted) {
    var ID = this.getID();
    var quote = unquoted ? null : this._$singleQuote;
    if (isc.Browser.isMoz)
            return isc.SB.concat(quote, this._$mozFocusStart, ID, this._$focusEnd, quote);
    return isc.SB.concat(quote, this._$focusStart, this.getID(), this._$focusEnd, quote);
},

_getNativeBlurHandlerString : function (unquoted) {
    var quote = unquoted ? null : this._$singleQuote;
    return isc.SB.concat(quote, this._$blurStart, this.getID(), this._$focusEnd, quote);
},

// _getNativeFocusHandlerMethod / _getNativeBlurHandlerMethod
// Returns the native focus / blur handlers as a method constructed from the native focus/blur
// handler strings.
// This can then be assigned directly to the handle's onfocus / onblur attribute after
// the handle has been written out.
_getNativeFocusHandlerMethod : function () {
    if (!this._nativeFocusHandlerMethod) {
        this._nativeFocusHandlerMethod = isc._makeFunction("event", this._getNativeFocusHandlerString(true));
    }
    return this._nativeFocusHandlerMethod;
},
_getNativeBlurHandlerMethod : function () {
    if (!this._nativeBlurHandlerMethod) {
        this._nativeBlurHandlerMethod = isc._makeFunction("event", this._getNativeBlurHandlerString(true));
    }
    return this._nativeBlurHandlerMethod;
},
// Handles: pointers to the Canvas' DOM representation
// --------------------------------------------------------------------------------------------

_getAriaHandleID : function () {
    var isDrawn = this.isDrawn();
    if ((isDrawn && this._drewClipDiv) ||
        (!isDrawn && this._shouldWriteClipDiv()))
    {
        return this._getClipDivDOMID();
    } else {
        return this.getCanvasName();
    }
},

//> @method canvas.getHandle()  (A)
//          get the handle to this layer
//      @group  handles
//
//      @return (handle)    handle to this layer
//<
getHandle : function () {
    if (isc._traceMarkers) arguments.__this = this;


    if (this.destroyed) {
        this.logWarn("Attempt to access destroyed widget in the DOM - " +
            "destroy() called at invalid time (eg: mid-draw) or invalid method " +
            "called on destroy()d widget. Stack Trace:" + this.getStackTrace());

    }

    // don't look for the handle unless we're drawn

    //if (!(this._handleDrawn || this._drawn) || this._clearedByParent) return null;
    if (!(this._handleDrawn || this._drawn)) return null;

    // if the handle is not already defined, find it
    if (this._handle == null) {
        // get the ID we wrote into the DOM for the handle
        var elementId = this.getCanvasName();
        // and get the handle by id
        this._handle = this.ns.Element.get(elementId);

        // if we can't find the handle, since we're supposedly drawn, this is an error
        if (this._handle == null) {
            this.logWarn("Unable to find handle for drawn Canvas, elementId: " + elementId);
        }
    }
    return this._handle;
},

//> @method canvas.getClipHandle() (A)
//
//      @group  handles
//      @return (handle)  clipDiv handle to this layer
//<
getClipHandle : function () {
    // if we're not using a separate clip vs content DIV, the clip handle is just the handle
    if (!this._drewClipDiv) return this.getHandle();

    //>DoubleDiv
    // don't look for the handle unless we're drawn
    //if (!(this._handleDrawn || this._drawn) || this._clearedByParent) return null;
    if (!(this._handleDrawn || this._drawn)) return null;


    // if the handle is not already defined, find it
    if (this._clipDiv == null) {
        // get the document the handle would be in
        var elementId = this._getClipDivDOMID();

        // and get the handle by id
        this._clipDiv = this.ns.Element.get(elementId);

        // if we can't find the handle, since we're supposedly drawn, this is an error
        if (this._clipDiv == null) {
            this.logWarn("Unable to find clipHandle for drawn Canvas, elementId: " + elementId);
        }
    }
    return this._clipDiv;
    //<DoubleDiv
},

//> @method canvas.getOuterElement() [A]
// Returns the outer DOM element of this Canvas. This method is provided for the
// very rare cases where a programmer needs to examine the DOM hierarchy created by
// a drawn SmartClient component.
// <P>
// Direct manipulation of the DOM elements created by SmartClient components
// is not supported. SmartClient components should be rendered or cleared using
// standard methods such as +link{canvas.draw()}, +link{canvas.clear()}. If direct
// integration with existing DOM structures is required, this should be achieved via the
// +link{canvas.htmlElement} attribute, rather than by attempting to move the
// component's outer element via native browser APIs.<br>
// The content of SmartClient components' DOM elements should also not be directly
// manipulated using native browser APIs - standard methods such as
// +link{canvas.setContents()}, +link{canvas.addChild()}, +link{canvas.removeChild()},
// +link{canvas.markForRedraw()} and +link{canvas.redraw()} should be used instead.
// <P>
// In some cases, the element returned may match the element returned by
// +link{canvas.getContentElement()}, but this will not always be the case.
// <P>
// If the widget is undrawn, this method will return <code>null</code>.
//
// @return (DOMElement) The outer DOM element for a drawn Canvas.
// @visibility external
//<
getOuterElement : function () {
    return this.getClipHandle();
},

//> @method canvas.getContentElement() [A]
// Returns the DOM element for this Canvas which contains the +link{canvas.contents}, or
// for +link{canvas.getParentCanvas(),parent components}, the DOM elements for any drawn
// children. This method is provided for the
// very rare cases where a programmer needs to examine the DOM hierarchy created by
// a drawn SmartClient component.
// <P>
// Direct manipulation of the DOM elements created by SmartClient components
// is not supported. SmartClient components should be rendered or cleared using
// standard methods such as +link{canvas.draw()}, +link{canvas.clear()}. If direct
// integration with existing DOM structures is required, this should be achieved via the
// +link{canvas.htmlElement} attribute, rather than by attempting to move the
// component's outer element via native browser APIs.<br>
// The content of SmartClient components' DOM elements should also not be directly
// manipulated using native browser APIs - standard methods such as
// +link{canvas.setContents()}, +link{canvas.addChild()}, +link{canvas.removeChild()},
// +link{canvas.markForRedraw()} and +link{canvas.redraw()} should be used instead.
// <P>
// In some cases, the element returned may match the element returned by
// +link{canvas.getOuterElement()}, but this will not always be the case.
// <P>
// If the widget is undrawn, this method will return <code>null</code>.
//
// @return (DOMElement) The outer DOM element for a drawn Canvas.
// @visibility external
//<
getContentElement : function () {
    return this.getHandle();
},

//> @method canvas.getScrollHandle() (A)
//      If we're scrolling by setting the native scroll position on some DOM element this
//      method gives us a pointer to that element.
//
//      @group  handles
//      @return (handle)  scroll handle of the DOM element
//<

getScrollHandle : function () {
    // default implementation uses this widget's clipHandle.
    return this.getClipHandle();
},

// _getURLHandle()
// Get the handle of the IFrame we used to load content (when using contentsURL and
// contentsType:"page")
_getURLHandle : function () {
    if (!this.containsIFrame()) return null;
    return this.getDocument().getElementById(this._getIFrameID());
},

//>FocusProxy
//> @method canvas._getFocusProxyHandle() (I)
//
//      @group  handles
//      @return (handle) - handle for the 'focusProxy' button.  <code>null</code> if
//                         this._useFocusProxy is false.
//<
_getFocusProxyHandle : function () {
    if (!this._useFocusProxy || !this._hasFocusProxy) return null;

    if (!this._focusProxy) {
        var elementId = this.getCanvasName() + "__focusProxy";
        this._focusProxy = this.getDocument().getElementById(elementId);
    }

    return this._focusProxy;
},

//> @method canvas._getFocusProxyParentHandle() (I)
//
//      @group  handles
//      @return (handle) - handle for the parent div for the 'focusProxy' button.
//                         <code>null</code> if this._useFocusProxy is false.
//<
_getFocusProxyParentHandle : function () {
    if (!this._useFocusProxy) return null;
    if (!this._focusProxy) this._focusProxy = this._getFocusProxyHandle();

    return (this._focusProxy != null ? this._focusProxy.parentNode : null);
},
//<FocusProxy


//> @method canvas.getStyleHandle() (A)
//      Return the style handle for this canvas.
//       This is what we use to set some of the physical properties
//       of canvases, such as the visibility, left, etc.
//
//      @group  handles
//      @return (handle)    style handle to this layer
//<
getStyleHandle : function () {
    if (!this._styleHandle) {

        var clipHandle = this.getClipHandle();
        this._styleHandle = (clipHandle != null ? clipHandle.style : null);
    }
    return this._styleHandle;
},

// --------------------------------------------------------------------------------------------

//> @method canvas.setUpEvents()    (A)
//          set up the handle for this canvas to respond properly to mouse/keyboard events
//      @group  events
//<
// On all browsers, all Canvii write an "eventProxy" attribute into their DOM representation
// (DIV element), which the isc.EventHandler uses to route events to the Canvas which drew the
// DOM elements.
setUpEvents : function () {
    // register to receive drop events, if necessary
    if (this.canAcceptDrop) this.ns.EH.registerDroppableItem(this);
},

// Creating children
// --------------------------------------------------------------------------------------------

// make sure that everything in the children array is a canvas, and has us as its
// parentElement.  if either is not true, call addChild() to add it as a proper child
_instantiateChildren : function (children) {

    // start with a fresh children array,
    //      in case any children add peers (which should appear directly after that child).
    // NOTE: creating a fresh Array here is also key when Canvas.children is set as an
    // inherited property, because each Canvas needs to have a unique children Array
    if (!children) children = this.children;
    if (!children) return;
    this.children = [];

    for (var i = 0, child; i < children.length; i++) {
        child = children[i];

        if (!child) continue;

        // if the child is not a canvas, or doesn't recognize us as its parent
        // call addChild() to create it and add it to our list of children
        if (!isc.isA.Canvas(child) || child.parentElement != this) {
            this.addChild(child);

        // otherwise, it's already been set up correctly (by a previous call to addChild())
        //  so we'll just add it to our children array
        } else {
            this.children.add(child);
        }
    }
},


_$autoChildPrefix:"autoChild:",
_lazyAutoChildCreate : function (name) {
    name = name.substring(this._$autoChildPrefix.length);

    //this.logWarn("lazy creation of autoChild: " + name);

    // try to figure out whether this autoChild should be created by the current widget, or, if
    // this widget is itself an autoChild, by it's creator
    var defaultsName = this._getDefaultsName(name),
        propertiesName = this._getPropertiesName(name);
    var creator = this[defaultsName] || this[propertiesName] ? this :
                    isc.isA.Canvas(this.creator) &&
                            (this.creator[defaultsName] || this.creator[propertiesName])
                            ? this.creator : this;

    if (isc.isA.Canvas(creator[name])) return creator[name];

    // NOTE: when creating autoChildren in this method, we want:
    // - unconditional creation, unlike addAutoChild()
    // - no adding to parent (callers generally have a parent in mind), unlike addAutoChild()
    // - do want to set up this[name], like addAutoChild()
    return (creator[name] = creator.createAutoChild(name));
},

// create or find a Canvas based on the passed string or properties, or return it if it's
// already a Canvas.  Used to allow canvas.children, layout.members, window.items, etc to
// accept various standard ways of specifying Canvii
createCanvas : function (canvas) {
    if (isc.isA.Canvas(canvas)) return canvas;

    if (canvas == null) return;

    if (isc.isA.String(canvas)) {
        // the "autoChild:[childName]" format allows lazy instantiation of autoChildren from eg
        // section.items or tab.pane
        if (isc.startsWith(canvas, this._$autoChildPrefix)) {
            return this._lazyAutoChildCreate(canvas);
        }
        if (isc.startsWith(canvas, this._$spacerChildPrefix)) {
            var spacerLength = canvas.substring(this._$spacerChildPrefix.length);
            var lengthAttribute = "width";
            if (this.orientation == isc.Layout.VERTICAL) lengthAttribute = "height";
            var props = {autoDraw: false};
            props[lengthAttribute] = spacerLength;
            return isc.LayoutSpacer.create(props);
        }

        // otherwise assume the id of a global widget
        return window[canvas];
    }

    var autoChildName = canvas.autoChildName;
    if (autoChildName) {
        // NOTE: we want just creation here, not adding to parent, as addAutoChild would do
        return this[autoChildName] = this.createAutoChild(autoChildName, canvas);
    }

    // new child provided as a properties block - create it
    var cons = canvas._constructor;
    // if constructor isn't provided or doesn't name a class, default to Canvas
    if (cons == null || isc.ClassFactory.getClass(cons) == null) {
        this.logWarn("Unable to create canvas of type '" + cons + "' - no such class in runtime. Will default to Canvas.");
        if (isc.isA.String(cons) && cons.contains(".")) {
            this.logWarn("Did you make the SmartGWT class reflectable? See http://www.smartclient.com/smartgwt/javadoc/com/smartgwt/client/docs/Reflection.html");
        }
        cons = isc.Canvas;
    }
    canvas._constructor = null;

    // prevent autoDraw
    canvas.autoDraw = false;

    return isc.ClassFactory.newInstance(cons, canvas);
},

createCanvii : function (canvii) {
    if (canvii == null) return;
    for (var i = 0; i < canvii.length; i++) {
        canvii[i] = this.createCanvas(canvii[i]);
    }
    return canvii;
},

// setEventProxy() - update the eventProxy for this widget at runtime
setEventProxy : function (newProxy) {
    // clear any back-references from current eventProxy
    var oldProxy = this.eventProxy;
    if (oldProxy == newProxy) return;

    if (oldProxy != null) {
        oldProxy._proxiers.remove(this);
        // Clear the eventProxy pointer from the DOM object

        if (this.isDrawn()) {
            if (this.getHandle() != null) this.getHandle().eventProxy = null;
            if (this.getClipHandle() != this.getHandle()) this.getClipHandle().eventProxy = null;
        }
    }

    // set this.eventProxy to the newProxy passed in (may be null, in which case we clear out
    // the eventProxy).
    this.eventProxy = newProxy;

    if (newProxy != null) {
        if (!isc.isA.Canvas(newProxy)) {
            this.logWarn("setEventProxy() passed invalid eventProxy - clearing this property");
            this.eventProxy = null;
        } else {
            if (newProxy._proxiers == null) newProxy._proxiers = [];
            newProxy._proxiers.add(this);
        }
    }
    // Have to redraw, so eventHandling doesn't get confused about what the eventproxy is
    // Make this an immediate redraw, so *Any* subsequent events go through to the appropriate
    // proxy.
    if (this.isDrawn()) this.redraw("eventProxy updated");
},

// clearEventProxy() - clear this widget's eventProxy at runtime
clearEventProxy : function () {
    this.setEventProxy();
},

// Adding and Removing Children and Peers
// --------------------------------------------------------------------------------------------

//> @method canvas.addChild()   ([])
// Adds newChild as a child of this widget, set up a named object reference (i.e., this[name])
// to the new widget if name argument is provided, and draw the child if this widget has been
// drawn already.
// <P>
// If newChild has a parent it will be removed from it. If it has a master, it will be detached
// from it if the master is a child of a different parent. If newChild has peers, they'll be
// added to this widget as children as well.
//
//  @visibility external
//  @group  containment
//  @param  newChild        (canvas)    new child canvas to add
//  @param  [name]          (string)    name to assign to child (eg: this[name] == child)
//  @param  [autoDraw]      (Boolean)   if false, child will not automatically be drawn (only
//                                          for advanced use)
//  @return (canvas)    the new child, or null if it couldn't be added
//<
addChild : function (newChild, name, autoDraw) {
    if (isc._traceMarkers) arguments.__this = this;
    if (!newChild) return null; // just to be safe

    if (newChild == this) {
        this.logWarn("Attempt to add a child to itself");
        return;
    }

    //this.logInfo("addChild() called on " + newChild + " : parent is drawn() " + this.isDrawn()
    //          + " : child is " + (isA.Canvas(newChild) ? (newChild.isDrawn() ? "drawn " : "undrawn ") + newChild.Class
    //                                                   : "object literal " + Echo.asString(newChild)), "drawing");

    // instantiate the child on the fly if it hasn't been created yet (autodraw is suppressed)
    if (!isc.isAn.Instance(newChild)) newChild = this.createCanvas(newChild);

    if (!isc.isA.Canvas(newChild)) {
        //>DEBUG
        this.logWarn("addChild(): trying to install a non-canvas as a child.  Returning.");
        //<DEBUG
        return null;
    }

    // if newChild already recognizes this canvas as its parent, bail
    if (newChild.parentElement === this) return newChild;

    var wasDrawn = newChild.isDrawn();

    // remove the child from its old parent, if any
    if (newChild.parentElement) newChild.deparent(name);

    // if the child had already been drawn (therefore outside of this canvas), clear it

    if (newChild.isDrawn()) newChild.clear();

    // Remove the child from the top level canvas list - it's no longer a top level canvas
    isc.Canvas._removeFromTopLevelCanvasList(newChild);

    // drop the drawContext to ensure the child does not try to draw in some arbitrary DOM
    // location instead of inside its new parent
    if (newChild.drawContext) newChild.drawContext = null;
    if (newChild.htmlElement) newChild.htmlElement = null;

    // attach the child to its new parentElement (this canvas) and topElement
    newChild.parentElement = this;
    newChild.topElement = (this.topElement || this);
    // update topElement for the child's children, if any
    // (This method will recursively be called on each child / descendant)
    newChild._updateChildrenTopElement();

    if (name) this[name] = newChild;

    var children = this.children;
    if (children == null) children = this.children = [newChild];
    else {

        children.add(newChild);
    }

    // detach the child from its master, if the master's parent is different
    var childsMaster = newChild.masterElement;
    if (childsMaster && childsMaster.parentElement != this) {
        childsMaster.peers.remove(newChild);
        if (childsMaster[name] == newChild) childsMaster[name] = null;
        newChild.masterElement = null;
    }

    // add the child's peers, if any, as children of this parent
    // it's important that this is done *after* newChild is attached to its parent, so the
    // peers don't think they're being moved to a different parent and break their peer/master
    // link
    if (newChild.peers) {
        for (var i = 0; i < newChild.peers.length; i++) this.addChild(newChild.peers[i]);
    }

    // If the page isn't done loading, and we had to clear in order to reparent, warn the
    // developer - chances are they failed to set autoDraw:false
    if (wasDrawn && !this.warnAboutClear && !isc.Page.isLoaded()) {
        this.logWarn("Adding already drawn widget:" + newChild.getID() + " to new parent:" +
                    this.getID() + ". Child has been cleared so it can be drawn inside the new " +
                    "parent. This may be a result of autoDraw being enabled for the child.");
    }

    // Calculate sizes that are expressed as a percentage of parent size, if necessary; this is
    // done after clear so that unnecessary redraws are avoided.  If the parent has not yet
    // drawn, no need, as this happens as part the call to layoutChildren() during draw.
    if (this.isDrawn()) newChild._resolvePercentageSize();

    // Ensure that if any clickmasks are showing our child is at the same level as we are
    // wrt them.

    var EH = this.ns.EH;
    if (EH.clickMaskUp()) {

        var CMIDs = EH.getAllClickMaskIDs();
        for (var i = CMIDs.length -1; i >= 0; i--) {
            var parentMasked = EH.targetIsMasked(this, CMIDs[i]);
            if (!parentMasked) {
                EH.addUnmaskedTarget(newChild, CMIDs[i]);
                // We're iterating down from the top - once a widget is over one mask it's also
                // over any masks below that one. Therefore we don't need to keep iterating
                // down to the bottom adding unmasked targets.
                break;
            } else {
                // If we're masked by our child is not, mask the child.
                var childMasked = EH.targetIsMasked(newChild, CMIDs[i]);
                if (!childMasked) EH.maskTarget(newChild, CMIDs[i]);
            }
        }
    }

    // for very advanced callers, support not drawing the child automatically
    if (autoDraw == false || newChild._dontDrawOnAddChild) {
        // support one-time flag.  Kind of a hack, but there are many codepaths that ultimately
        // call addChild()
        newChild._dontDrawOnAddChild = null;
        return newChild;
    }


    var tabIndexManaged = false,
        autoTabIndex = (newChild._autoTabIndex || !newChild.tabIndex);

    if (isc.isA && isc.isA.Layout &&  autoTabIndex &&
        (newChild._canFocus() || (newChild.children != null && newChild.children.length > 0)))
    {
        var currentChild = newChild;
        while (currentChild.parentElement) {
            if (isc.isA.Layout(currentChild.parentElement) && currentChild.parentElement.isDrawn())
            {
                currentChild.parentElement.updateMemberTabIndex(currentChild);
                if (currentChild.parentElement == this) tabIndexManaged = true;
            }
            currentChild = currentChild.parentElement;
        }
    }

    // if we're not drawn yet, we'll wait to draw the child when we draw.  If we've been drawn,
    // tell the child to draw as well -- unless it has a master, in which case it's a peer of
    // another child, and that other child will draw it.
    if (this.isDrawn() && !newChild.masterElement) {
        //>DEBUG
        if (this.logIsDebugEnabled(this._$drawing)) {
            this.logInfo("child added to already drawn parent: " +
                         (isc.Page.isLoaded() ? "page loaded, will draw immediately" :
                                            "page not loaded, will defer child drawing"),
                         "drawing");
        }
        //<DEBUG

        // if the user has not specified a tabIndex for the child, slot it into the tab order
        // after the previous canFocus:true child for this widget, with an auto-allocated tab
        // index.
        //
        // Note: this widget is drawn, so we can assume that the tab index will have been
        // assigned, and this._autoTabIndex will have been set to true if the tab index was
        // auto-allocated.
        // We can assume the same for any focusable children of this widget.


        if (!tabIndexManaged && autoTabIndex) {

            var lastChild;

            if (this.children.length  > 1) {
                // find the previous child with an auto-allocated tab index
                for (var i = this.children.length -2; i >=0 ; i--) {
                    if (this.children[i]._autoTabIndex) {
                        lastChild = this.children[i];
                        break;
                    }
                }
            }
            // if we didn't find a focusable (and _autoTabIndex) previous child, see if this widget
            // is focusable and has an auto-allocated tab index
            if (lastChild == null && this._autoTabIndex) {
                lastChild = this;
            }

            // slot this child after the last child with an auto-allocated tab index
            if (lastChild != null) newChild._setTabAfter(lastChild);

        }

        // Draw the child, and adjust overflow to account for any changes
        // NOTE: draw() may be delayed until after page load for some older browsers

        newChild.draw();
        this.adjustOverflow("addChild");
    }

    // If we're showing the component mask, mask the new
    // child - duplicate some of _updateChildrenForComponentMask
    if (this.componentMaskShowing && this.componentMask) {
        var maskZIndex = this.componentMask.getZIndex();
        if (newChild.getZIndex() > maskZIndex) {
            newChild.moveBelow(this.componentMask);
        }
        newChild.disableKeyboardEvents(true, true, true);
    }

    return newChild;
},

_updateChildrenTopElement : function () {
    // if a dataPath is specified, values may be managed by a valuesManager applied to
    // an ancestor widget.
    // Re-Run 'setDataPath()' when the ancestor hierarchy changes
    // Note that for non dataBound components this no-ops

    if (this.dataPath) this.setDataPath(this.dataPath);

    var children = this.children;
    if (!children || children.length == 0) return;
    for (var i = 0; i < children.length; i++) {
        var child = children[i];
        child.topElement = this.topElement;
        child._updateChildrenTopElement();
    }
},

//> @method canvas.reparent()
//      Make this canvas have the same parent as some other canvas.
//      Works even if this is a top-level object.
//
//      @return (boolean)   true == reparenting actually occurred.
//      @group  containment
//<
reparent : function (newSibling) {

    // bail if we're trying to reparent to ourselves!
    if (this.getID() == newSibling.getID()) return false;

    // If they have the same ISC AND Native parents already, just bail
    if ((this.parentElement == newSibling.parentElement) &&
        this.getClipHandle() && newSibling.getClipHandle() &&
        (this.getClipHandle().parentNode == newSibling.getClipHandle().parentNode)) {
        return false;
    }

    // Note - to handle relative positioning, etc. properly, we need to ensure that this
    // widget ends up with the same DOM parent as the newSibling - regardless of whether it is
    // an ISC parentElement

    // Ensure this will be drawn next to the newSibling
    this._adjacentHandle = newSibling.getClipHandle();

    if (newSibling.parentElement) {
        // join our sibling's parent (will handle setting up ISC relationships, and drawing)
        newSibling.parentElement.addChild(this);
    } else {
        // Ditch any existing parent
        if (this.parentElement) this.deparent();
        // Or clear() so we can redraw
        else this.clear();

        // and draw anew next to the newSibling
        this.draw();
    }
    return true;
},

// NOTE: child/peer removal:
// - you can call either deparent or removeChild to accomplish child removal (likewise
//   depeer/removePeer)
// - deparented/childRemoved and depeered/peerRemoved are clean notification points that are
//   guaranteed to be called
// - removePeer/removeChild are guaranteed to be called, so can be used as an override point in
//   advanced widgets.  deparent/depeer are *not* guaranteed to be called - with a set of flags we
//   could make this possible without infinite recursion

//> @method canvas.removePeer()
// Remove a peer from this Canvas
// @group containment
// @param peer (Canvas) Peer to be removed from this canvas
// @param [name] (String) If this peer was assigned a name when added via addPeer(), it should
//                        be passed in here to ensure no reference is kept to the peer
// @visibility external
//<
removePeer : function (peer, name) {
    if (peer == null) return;

    var peers = this.peers;
    if (peers == null) {
    //>DEBUG
        this.logWarn("Attempt to remove peer: " + peer + " from Canvas that does not have peers");
    //<DEBUG
        return;
    }
    var index = peers.indexOf(peer);
    if (index < 0) {
    //>DEBUG
        this.logWarn("Attempt to remove peer: " + peer + " from Canvas that is not its master");
    //<DEBUG
        return;
    }

    if (this.parentElement) {
        this.parentElement.removeChild(peer);
    }

    // remove our links to the peer
    peers.removeAt(index);
    if (this[name] == peer) this[name] = null;
    // remove peer's link to us
    peer.masterElement = null;
    // fire notifications
    if (peer.depeered) peer.depeered(this, name);
    if (this.peerRemoved) this.peerRemoved(peer, name);
},

//> @method canvas.depeer()
// Make this Canvas no longer a peer of its master
// @group containment
// @visibility external
//<
// NOTE: name intentionally undocumented; AutoChild approach is better if you want name assignment
depeer : function (name) {
    if (!this.masterElement) return;
    this.masterElement.removePeer(this, name);
},
//> @method canvas.deparent()
// Remove this canvas from its parent if it has one.
// @group containment
// @visibility external
//<
// NOTE: name intentionally undocumented; AutoChild approach is better if you want name assignment
deparent : function (name) {
    // name intentionally undocumented
    if (!this.parentElement) return;
    this.parentElement.removeChild(this, name);
},

//> @method canvas.removeChild()
// Remove a child from this parent.
// @param child (Canvas) Child canvas to remove from this parent.
// @param [name] (string) If the child canvas was assigned a name when added via addChild(), it
//                        should be passed in here to ensure no reference is kept to the child
// @group containment
// @visibility external
//<

removeChild : function (child, name) {
    if (isc._traceMarkers) arguments.__this = this;
    if (child == null) return;

    var children = this.children, index;
    //>DEBUG
    if (!children || (index = children.indexOf(child)) == -1) {
        this.logWarn("Attempt to remove child: " + child + " from Canvas that is not its parent");
        return;
    }
    //<DEBUG

    // remove our links to the child
    children.removeAt(index);
    if (this[name] == child) this[name] = null;
    // remove the child's HTML.  NOTE needs to happen before parentElement/topElement are
    // removed since clear() fires key notifications that cause the parent to adjust to the now
    // undrawn child.
    if (child.isDrawn()) child.clear();
    // remove child's links to us

    delete child.parentElement;
    delete child.topElement;

    // Add the child to the top level list of canvii
    isc.Canvas._addToTopLevelCanvasList(child);

    // deparent any peers of the child, which are also our children
    if (child.peers) child.peers.map("deparent");
    // fire notifications
    if (child.deparented) child.deparented(this, name);
    if (this.childRemoved) this.childRemoved(child, name);

    //>EditMode
    if (this.selectedComponents && this.selectedComponents.remove(child)) this.fireSelectedEditNodesUpdated();
    //<EditMode
},



//> @method canvas.addPeer()    ([])
// Adds newPeer as a peer of this widget (also making it a child of this widget's parent, if
// any), set up a named object reference (i.e., this[name]) to the new widget if name is
// provided, and draw the peer if this widget has been drawn already.<br>
// <P>
// The widget to be added as a peer will be removed from its old master and/or parent, if any,
// and it will be added as a child to the parent of this canvas (if any)
//
// @param newPeer (Canvas) new peer widget to add
// @param [name] (String) name to assign to peer (eg: this[peer] == child)
// @param [autoDraw] (Boolean) if true, peer will not automatically be drawn (only
//                             for advanced use)
// @param [preDraw] (Boolean) if true, when draw is called on the master widget, the peer
//                            will be drawn before the master
// @return (Canvas) the new peer, or null if it couldn't be added
//
// @group containment
// @visibility external
//<
addPeer : function (newPeer, name, autoDraw, preDraw) {
    if (!newPeer) return null;  // just to be safe

    // instantiate the peer on the fly if it hasn't been created yet (autodraw is suppressed)
    if (!isc.isAn.Instance(newPeer)) newPeer = this.createCanvas(newPeer);

    // if this peer is marked for 'predrawing', hang the '_drawBeforeMaster' flag onto the peer, so
    // that when draw is called on the master, this peer gets drawn first.
    // If the master element is already drawn, and this flag is set, we'll call 'redraw' on the
    // master element when this newPeer gets drawn (below).
    if (preDraw == true) newPeer._drawBeforeMaster = true;

    // if newPeer already recognizes this canvas as its master, bail
    if (newPeer.masterElement === this) return null;

    // remove the peer from its old master, if any
    if (newPeer.masterElement) newPeer.depeer(name);

    // attach the peer to its new master (this canvas)
    newPeer.masterElement = this;
    if (name) this[name] = newPeer;

    var peers = this.peers;
    if (peers == null) peers = this.peers = [newPeer];
    else {

        peers.add(newPeer);
    }



    // attach the peer to the same parent as us
    if (this.parentElement) {
        // make the peer a child of our parent (removes peer from its old parent, if any)
        this.parentElement.addChild(newPeer, name);
    } else if (newPeer.parentElement) {
        // or detach the peer from its old parent if it has one
        newPeer.deparent();
    }

    // If we're keeping our opacity in synch with that of our peers, update in now.
    if (newPeer._setOpacityWithMaster && (newPeer.opacity != this.opacity))
        newPeer.setOpacity(this.opacity);

    // If we're showing / hiding with our peers ensure peers visibility is in synch with ours
    if (newPeer._showWithMaster && (newPeer.visibility != this.visibility)) {
        newPeer.setVisibility(this.visibility);
    }

    // If snapTo or snapEdge are set, recalc peer position
    if (newPeer.snapTo || newPeer.snapEdge) newPeer._resolvePercentageSize();

    var EH = this.ns.EH;
    if (EH.clickMaskUp()) {
        var CMIDs = EH.getAllClickMaskIDs();
        for (var i = CMIDs.length -1; i >= 0; i--) {
            var masterMasked = EH.targetIsMasked(this, CMIDs[i]);
            if (!masterMasked) {
                // addUnmaskedTarget will automatically unmask children and peers of the
                // new peer recursively.
                EH.addUnmaskedTarget(newPeer, CMIDs[i]);
                // We're iterating down from the top - once a widget is over one mask it's also
                // over any masks below that one. Therefore we don't need to keep iterating
                // down to the bottom adding unmasked targets.
                break;
            } else {
                // If we're masked but our peer is not, mask the peer
                var peerMasked = EH.targetIsMasked(newPeer, CMIDs[i]);
                if (!peerMasked) EH.maskTarget(newPeer, CMIDs[i]);
            }
        }
    }

    // for very advanced callers, support not drawing the child automatically
    if (autoDraw == false) return newPeer;

    // if we've been drawn and the peer hasn't, tell the peer to draw as well
    if (this.isDrawn() && !newPeer.isDrawn()) {
        newPeer.draw();
        // If the '_drawBeforeMaster' flag has been set on the new peer, force a redraw of the
        // master after the peer is first drawn.
        // We do this because the _drawBeforeMaster flag implies that the master element expects
        // the peer to have been drawn when it itself is drawn, for example, so it can make use
        // of the peer's drawn size in its own getInnerHTML() method.
        // This redraw therefore gives the master a chance to rebuild its HTML after the peer
        // has been drawn.
        if (newPeer._drawBeforeMaster) this.redraw();
    }

    return newPeer;
},

// SnapTo / SnapEdge positioning
// ---------------------------------------------------------------------------------------

//> @method canvas.setSnapTo()  ([])
// Set the snapTo property of this canvas, and handle repositioning.
//
// @group positioning
// @param snapTo (string) new snapTo value
// @visibility external
//<
setSnapTo : function (snapTo) {
    this.snapTo = snapTo;
    this.parentResized();
},

//> @method canvas.getSnapTo()  ([])
// Return the snapTo value of this object
//
// @return (string) snapTo
// @group positioning
// @visibility external
//<
getSnapTo : function () {
    return this.snapTo;
},

//> @method canvas.setSnapEdge()  ([])
// Set the snapEdge property of this canvas, and handle repositioning.
//
// @param snapEdge (string) new snapEdge value
// @group positioning
// @visibility external
//<
setSnapEdge : function (snapEdge) {
    this.snapEdge = snapEdge;
    this.parentResized();
},

//> @method canvas.getSnapEdge()  ([])
// Return the snapEdge value of this object
//
// @return (string)    snapEdge
// @group  positioning
// @visibility external
//<
getSnapEdge : function () {
    return this.snapEdge;
},

//>EditMode
// provide addChild and removeChild as the adder/remover function for the "children" field (not
// mechanically guessable by naming conventions)
getFieldMethod : function (target, type, fieldName, verb) {
    //this.logWarn("getMethod, field: " + fieldName);
    if (fieldName == "children") {
        if (verb == "add") return "addChild";
        if (verb == "remove") return "removeChild";
    }
    return this.Super("getFieldMethod", arguments);
},
//<EditMode

// Canvas hierarchy
// --------------------------------------------------------------------------------------------

getTopLevelCanvas : function () {
    var topLevelCanvas = this;
    while (topLevelCanvas.parentElement != null) {
        topLevelCanvas = topLevelCanvas.parentElement;
    }
    return topLevelCanvas;
},

//> @method canvas.getParentCanvas()
// Returns the parent of this canvas, if any.
// @return (Canvas) the parent canvas, null if none exists.
// @group containment
// @visibility external
//<
getParentCanvas : function() {
    return this.parentElement;
},

//> @method canvas.getMasterCanvas()
// Returns this canvas's "master" (the canvas to which it was added as a peer), if any.
// @return (Canvas) the master canvas, null if none exists.
// @group containment
// @visibility external
//<
getMasterCanvas : function() {
    return this.masterElement;
},

//> @method canvas.getParentElements()
// Returns an array of object references to all ancestors of this widget in the containment
// hierarchy, starting with the direct parent and ending with the top element.
// @return (Array of Canvas) array of parents, closest first; empty array if no parents
// @group containment
// @visibility external
//<
getParentElements : function () {
    var list = [],
        parent = this.parentElement;
    // while there are parents
    while (parent) {
        // add them to the list
        list.add(parent);
        parent = parent.parentElement;
    }
    // return the list
    return list;
},

//> @method canvas.contains()   ([A])
//      Returns true if element is a descendant of this widget (i.e., exists below this widget in
//      the containment hierarchy); and false otherwise.
//  @visibility external
//  @group  containment
//  @param  canvas  (canvas)    the canvas to be tested
//  @param  [testSelf] (Boolean) If passed this method will return true if the canvas
//                               parameter is a pointer to this widget.
//  @return (Boolean)   true if specified element is a descendant of this canvas; false otherwise
//<
contains : function (canvas, testSelf) {
    if (!testSelf && canvas && canvas.getParentCanvas) canvas = canvas.getParentCanvas();
    while (canvas) {
        if (canvas == this) return true;
        if (!canvas || !canvas.getParentCanvas) break;
        canvas = canvas.getParentCanvas();
    }
    return false;
},

// Is this element the parent of the child passed in, AND the child inherits its visibility from
// this parent?
_isVisibilityAncestorOf : function (child) {
    var target = child;

    while (target) {
        if (target == this) return true;
        var inherits = (target.visibility == isc.Canvas.INHERIT);
        if (!inherits) return false;
        target = target.parentElement;
    }
    return false;
},

// get total number of recursively contained children
getChildCount : function () {
    if (this.children == null) return;
    return this.children.map("getChildCount").sum() + this.children.length;
},


// ClickMask
// --------------------------------------------------------------------------------------------

//> @method Canvas.showClickMask()
// Show a clickMask over the entire screen that intercepts mouse clicks and fires some action.
// The mask created will be associated with this canvas - calling this method multiple times
// will not show multiple (stacked) clickMasks if the mask associated with this canvas is
// already up.<br><br>
//
// The clickMask useful for modal dialogs, menus and similar uses, where any click outside of
// some Canvas should either be suppressed (as in a modal dialog) or just cause something (like
// dismissing a menu).
//
// @group   clickMask
//
// @param   clickAction     (callback)  action to fire when the user clicks on the mask
// @param   mode        (ClickMaskMode) whether to automatically hide the clickMask on mouseDown
//                                      and suppress the mouseDown event from reaching
//                                      the target under the mouse
// @param   unmaskedTargets (widget | array of widgets)
//  initially unmasked targets for this clickMask. Note that if this is a
//  <code>"hard"</code> mask, unmasked children of masked parents are not supported
//  so any non-top-level widgets passed in will have their parents unmasked.
//  Children of masked parents can never be masked.
// @return  (string)    clickMask ID
// @see     canvas.hideClickMask()
// @visibility external
//<
showClickMask : function (clickAction, mode, unmaskedTargets) {

    var ID = this.getID();
    if (!this.ns.EH.clickMaskUp(ID)) {
        return this.ns.EH.showClickMask(clickAction, mode, unmaskedTargets, ID);
    }
},

//> @method Canvas.hideClickMask()
// Hides the click mask associated with this canvas.
//      @group  clickMask
//      @param  [ID]    (string) optional ID of specific clickMask to hide. If not passed,
//                      defaults to hiding the click mask associated with this widget only.
//      @visibility external
//      @see canvas.showClickMask()
//<
hideClickMask : function (ID) {
    if (ID == null) ID = this.getID();
    if (this.ns.EH.clickMaskUp(ID)) this.ns.EH.hideClickMask(ID);
},


//> @method Canvas.clickMaskUp()
// Determines whether a clickmask is showing
//@group clickMask
// @param [ID] (string) optional ID of specific clickMask to check. If not passed,
//                      checks for the click mask associated with this widget only.
// @return (Boolean) whether or not a clickmask is showing
// @visibility external
// @see canvas.showClickMask()
//<
clickMaskUp : function (ID) {
    if (ID == null) ID = this.getID();
    return this.ns.EH.clickMaskUp(ID);
},


//> @method Canvas.unmask()
// If a click mask is currently covering this widget, unmask it.
// @group   clickMask
// @param  [mask]    (string) optional ID of specific clickMask for which this widget should
//              be unmasked. If not passed, unmasks target wrt all clickMasks.
// @visibility clickMask
//<
unmask : function (mask) {
    this.ns.EH.addUnmaskedTarget(this, mask);
},

//> @method Canvas.mask()
// Ensure this widget is obscured by a currently visible clickMask.
// @group   clickMask
// @param  [mask]    (string) optional ID of specific clickMask to put this widget behind.
//                            If not passed, masks target wrt all clickMasks.
// @visibility clickMask
//<
mask : function (mask) {
    this.ns.EH.maskTarget(this, mask);
},

//> @method Canvas.isMasked()
// Is this widget currently obscured by a currently visible clickMask.
// @group   clickMask
// @param  [mask]    (string) optional ID of specific clickMask to test. If not passed, will
//                          return true if this canvas is masked by any visible clickMask.
// @visibility clickMask
//<
isMasked : function (mask) {
    return this.ns.EH.targetIsMasked(this, mask);
},

// Helper method - are we covered by a hard (auto-hide:false) clickMask?
_isHardMasked : function () {
    var masks = isc.EH.clickMaskRegistry;
    if (!masks || masks.length == 0) return false;

    for (var i = masks.length-1; i >= 0; i--) {
        var mask = masks[i];
        // If we're unmasked and haven't already hit a hard mask, we're not hard masked
        if (!this.isMasked(mask)) return false;
        // If we hit a hard mask, we are hard masked
        if (isc.EH.isHardMask(mask)) return true;
    }
    // In this case we didn't hit a hard mask, so any masks above us must be soft.
    return false;
},

// Component level masking
// ----------------------------------------------------------------------------------------------
// Support for masking children of this widget only

//> @method canvas.showComponentMask()
// Temporariy block all user interaction with children of this widget, with the exception of those
// passed in in the <code>unmaskedChildren</code> parameter. Children will remain blocked until
// +link{hideComponentMask()} is called.
// <P>
// This method will show the +link{componentMask} canvas to block mouse interaction with
// children, and temporarily remove masked children from the page's tab-order.
// <P>
// This behavior differs from the standard +link{Canvas.showClickMask(),click mask} in that the
// modal mask shown by +link{showClickMask()} will cover the entire screen and typically only
// allow "unmasking" of top level components.
// <P>
// Use +link{hideComponentMask()} to hide the component level mask.
//
// @param [unmaskedChildren] (Array of Canvas) Children passed into this parameter will continue to
//      be interactive while other children are blocked. They will be moved above the componentMask in
//      the page's z-order and remain accessible via keyboard navigation.  Note that this array should
//      contain direct children of this widget only.
// @visibility external
//<
// MaskProperties parameter allows customization of the componentMask at runtime. As implemented, any
// properties passed into this parameter will continue to be applied to the mask when the mask is hidden
// and then re-shown in the future.
// The unexposed Window.modalTarget logic does make use of this parameter - but this appears to be
// totally unused and may be removed in the future.
showComponentMask : function (unmaskedChildren, maskProperties) {


    if (this._showComponentMaskRunning) {
        this.logWarn("Ignoring recursive call to 'showComponentMask'.",
            "componentMask");
        return;
    }
    this._showComponentMaskRunning = true;

    if (unmaskedChildren != null && !isc.isAn.Array(unmaskedChildren)) {
        unmaskedChildren = [unmaskedChildren];
    }
    this.logInfo("showComponentMask running with unmaskedChildren:" + unmaskedChildren,
                "componentMask");

    if (this.componentMaskShowing) {
        if (maskProperties != null && this.componentMask) {
            this.componentMask.setProperties(maskProperties);
        }
        var childrenChanged = false;
        if (unmaskedChildren != null) {
            if (this._unmaskedChildren == null) {
                childrenChanged = true;
            } else {
                if (this._unmaskedChildren.length != unmaskedChildren.length) {
                    childrenChanged = true;
                } else {
                    for (var i = 0; i < unmaskedChildren.length; i++) {
                        if (!this._unmaskedChildren.contains(unmaskedChildren[i])) {
                            childrenChanged = true;
                        }
                    }
                }
            }
        } else if (this._unmaskedChildren == null) {
            childrenChanged = true;
        }
        this.logDebug("showComponentMask running with mask already up." +
            (childrenChanged ? " No change to unmasked children - ignoring"
                            : " Unmasked children changed - hiding and re-showing mask"),
                            "componentMask");

        if (!childrenChanged) return;
        this.hideComponentMask(true);
    }

    this._unmaskedChildren = unmaskedChildren;

    // set the showing flag to true before adding mask as a child. This ensures
    // it will draw
    this.componentMaskShowing = true;

    if (!this.componentMask) {
        this.componentMask = this.addAutoChild(
            "componentMask",
             // mark as disabled - automatically will kill events and not allow bubbling
             isc.addProperties(
                {},
                maskProperties,
                {
                    // Required for Layouts - this is a child, not a member
                    addAsChild:true,
                    disabled:true,
                    autoDraw:false,
                    overflow:"hidden",
                    _generated:true,
                    // size to not take up any space initially
                    width:1, height:1
                 }
             )
        );
    } else {
        if (maskProperties != null) this.componentMask.setProperties(maskProperties);
        this.componentMask.resizeTo(1,1);
    }

    if (this.isDrawn() && !this.componentMask.isDrawn()) {
        this.componentMask.draw();
    }

    this.componentMask.bringToFront();

    this._fixComponentMaskSize();
    this._updateChildrenForComponentMask();

    delete this._showComponentMaskRunning;
},


_updateChildrenForComponentMask : function () {
    var unmaskedChildren = this._unmaskedChildren;

    var currentFocusTarget = isc.EH.getFocusCanvas();

    var children = this.children;
    var maskZIndex = this.componentMask.getZIndex();
    for (var i = 0; i < children.length; i++) {
        if (children[i] == this.componentMask) continue;

        if (unmaskedChildren && unmaskedChildren.contains(this.children[i])) {
            if (this.children[i].getZIndex() < maskZIndex) {
                this.children[i].moveAbove(this.componentMask);
            }
            // If an unmasked child contains the focus target, we know we won't need
            // to blur it.
            if (currentFocusTarget && this.children[i].contains(currentFocusTarget, true)) {
                currentFocusTarget = null;
            }
        } else {
            if (this.children[i].getZIndex() > maskZIndex) {
                this.children[i].moveBelow(this.componentMask);
            }
            // If a masked child contains the focus target, blur it now.
            if (currentFocusTarget && this.children[i].contains(currentFocusTarget, true)) {
                currentFocusTarget.blur();
                currentFocusTarget = null;
            }
        }
    }
    // Recursively remove kids from the page's tab order
    this.disableKeyboardEvents(true, true, true, unmaskedChildren);
},

_fixComponentMaskSize : function () {
    if (!this.componentMask || !this.componentMask.isDrawn()) return;
    this.componentMask.resizeTo(this.getInnerWidth(true), this.getInnerHeight(true));
},

//> @attr canvas.componentMask (AutoChild Canvas : null : R)
// Automatically generated mask canvas displayed when +link{showComponentMask} is called.
// @see canvas.componentMaskDefaults
// @visibility external
//<

//> @attr canvas.componentMaskDefaults (Canvas Properties : {...} : IR)
// Defaults for the +link{canvas.componentMask} autoChild.
// Default properties include +link{backgroundColor} being set to <code>"black"</code> and
// +link{opacity} being set to <code>20</code>.
// @visibility external
//<
componentMaskDefaults:{
    backgroundColor:"black",
    opacity:20
},

//> @method canvas.hideComponentMask()
// Hide the +link{showComponentMask,component level clickMask} for this widget
// @visibility external
//<
// Undocumented parameter indicates we're being called from 'showComponentMask' while
// the mask is currently up.
hideComponentMask : function (fromShowComponentMask) {

    this.logInfo("hideComponentMask()", "componentMask");

    if (!this.componentMaskShowing) {
        this.logDebug("hideComponentMask() called with no mask up. Ignoring", "componentMask");
        return;
    }
    if (this._hideComponentMaskRunning) {
        this.logWarn("recursive call to hideComponentMask() - ignoring", "componentMask");
        return;
    }

    if (!fromShowComponentMask && this._showComponentMaskRunning) {
        this.logWarn("hideComponentMask() called while showComponentMask() is running." +
            "This is unsupported - ignoring",
            "componentMask");
        // could set a flag here to re-call this method when showCM completes
        return;
    }

    this._hideComponentMaskRunning = true;

    this.componentMaskShowing = false;

    if (this.componentMask) {
        this.componentMask.resizeTo(1,1);
        if (this.componentMask.isDrawn()) this.componentMask.clear();
    }

    this.disableKeyboardEvents(false, true, true, this._unmaskedChildren);

    delete this._unmaskedChildren;

    delete this._hideComponentMaskRunning;
},


// Widget Positioning and Sizing Methods
// --------------------------------------------------------------------------------------------
// Note on positioning coordinate systems:
//
//  When describing left / top positions of widgets, there are a few distinct possibilities for
//  the coordinate system you're referring to:
//  1 - Specified widget coordinates
//      - left/top (at init time), getLeft()/getTop(), setLeft()/setTop()
//      For absolutely positioned widgets, this is the distance from the top/left of this
//      widget (measured from outside any border or margin) to the inside of the parent's
//      content.
//      For relatively positioned widgets it is the offset relative to page flow within
//      this widget's parent element.
//  2 - Page level coordinates (getPageLeft() and getPageTop()).
//      This is the absolute offset of the widget from the top / left of the browser window,
//      measured from outside the widget's border and margin.
//      Will match getLeft() / getTop() for absolutely positioned elements at the top level.
//  3 - Canvas level coordinates (getCanvasLeft() / getCanvasTop())
//      This is the absolute offset of the widget from the left / top of its 'parentElement' -
//      the ISC widget defined as it's parent.  Measured from the outside of any border/margin
//      on this widget to the inside of the parent widget's handle - so for
//      absolutely positioned elements will be the same as the specified widget coordinates,
//      and in almost every case will be identical to the result of getOffsetLeft() / top()
//      [As the parent scrolls, this value will not change, like the specified or offset values
//       it is relative to the parent's content rather than floating position on the page].
//  4 - Offset coordinates (getOffsetLeft() and getOffsetTop()).
//      This is the absolute offset of the widget from the left / top of the native DOM
//      offsetParent of the widget (may or may not be a canvas).
//      Value is calculated from the outside of any border / margin of this widget to the
//      inside edge of the offsetParent element.
//      Used internally - should not need to be exposed.


//> @method canvas.setRect()    ([])
// Set all four coordinates, relative to the enclosing context, at once.
// <P>
// Moves the widget so that its top-left corner is at the specified top-left coordinates,
// then resizes it to the specified width and height.
//
//      @visibility external
//      @group  positioning, sizing
//      @param  [left]      (number, Array, Object) new left coordinate<smartclient>, Array of
//                                                  coordinates in parameter order, or Object
//                                                  with left, top, width, height properties.
//                                                  If an Array or Object is passed, the
//                                                  remaining parameters are ignored.</smartclient>
//      @param  [top]       (number)    new top coordinate
//      @param  [width]     (number)    new width
//      @param  [height]    (number)    new height
//      @return (boolean) whether the component's size actually changed
//<
//>Animation
// @param [animating] (boolean) Internal optional parameter passed if we are performing
//  an animated setRect
//<Animation
setRect : function (left, top, width, height, animating) {
    if (isc._traceMarkers) arguments.__this = this;
    if (isc.isAn.Array(left)) {
        top = left[1];
        width = left[2];
        height = left[3];
        left = left[0];
    } else if (left != null && left.top != null) {
        top = left.top;
        width = left.width;
        height = left.height;
        left = left.left;
    }

    //>DEBUG
    if (this.logIsDebugEnabled()) {
        this.logDebug("setRect: " + this.echo({left:left, top:top, width:width, height:height}));
    }
    //<DEBUG





    // first resize its width and height

    var sizeChanged = this.resizeTo(width, height, animating, true);

    if (sizeChanged) this._settingRect = true;
    // now move the canvas

    this.moveTo(left, top, animating, true);
    this._settingRect = null;
    return sizeChanged;
},


//> @method canvas.getRect()
//          return the coordinates of this object as rendered in LTWH order
//      @group  positioning, sizing
//
//      @return (array)     [left, top, width, height]
//<
getRect : function () {
    return [this.getLeft(), this.getTop(), this.getVisibleWidth(), this.getVisibleHeight()];
},

//> @method canvas.getLeft()    ([])
//          Return the left coordinate of this object, relative to its enclosing context, in pixels.
//      @visibility external
//      @group  positioning
//      @return (number)    left coordinate
//<
getLeft : function () {
    var handle = this.getStyleHandle();
    // it hasn't been drawn yet - return this.left
    if (handle == null) return this.left;
    var left = (isc.Browser.isIE ? handle.pixelLeft : parseInt(handle.left));

    

        if (this.vscrollOn && this.showCustomScrollbars && this.isRTL()) {
            return left - this.getScrollbarSize();
        }
        return left;
    

},

//> @method canvas.getOffsetLeft()
//          Return the offsetLeft coordinate of this object,
//          relative to its (ISC) parent, in pixels.
//      @group  positioning
//
//      @return (number)    left coordinate
//<
getOffsetLeft : function () {

    // This function returns the absolute position of widgets relative to their clipHandle's
    // offset parent (may be an ISC widget, but could be another HTML element too).


    // in this case we're always working with the clipHandle
    var handle = this.getClipHandle();


    if (this._isDisplayNone()) handle = null;

    // if we can't get the clip handle, just return the specified left coordinate
    if (handle == null) {
        //>DEBUG NOTE: not logging at WARN priority because it's just too common to manipulate
        // coordinates of an absolutely positioned widget before drawing it.
        if (this.logIsInfoEnabled()) {
            this.logInfo("getOffsetLeft() called before widget is drawn - unable to calculate offset " +
                         "coordinates.  Returning specified coordinates"); //<DEBUG
        }
        return this.left;
    }

    // just return the offsetLeft - this is the absolute position within logical parent element
    // ("offsetParent");
    var offsetLeft = isc.Element.getOffsetLeft(handle);
    if (this.vscrollOn && this.showCustomScrollbars && this.isRTL()) {
        offsetLeft -= this.getScrollbarSize();
    }

    
        return offsetLeft;
    
},

//> @method canvas.setLeft()    ([])
//          Set the left coordinate of this object, relative to its enclosing context, in pixels.
//          NOTE: if you're setting multiple coordinates, use setRect(), moveTo() or resizeTo()
//          instead
//      @visibility external
//      @group  positioning
//      @param  left        (number)    new left coordinate
//<
setLeft : function (left) {
    this.moveTo(left, null);
},

//> @method canvas.getTop() ([])
//          Return the top coordinate of this object, relative to its enclosing context, in pixels.
//      @visibility external
//      @group  positioning
//      @return (number)    top coordinate
//<
getTop : function (excludePageSpace) {
    var handle = this.getStyleHandle();
    if (handle == null) return this.top;

    var top = (isc.Browser.isIE ? handle.pixelTop : parseInt(handle.top, 10));

    if (isc.Browser.isChrome) {

        var numericTop = this._getNumericSize("top");
        if (numericTop != null) top = numericTop;
    }

    if (excludePageSpace) {
        var clipHandle = this.getClipHandle(),
            pageSpace = clipHandle.getAttribute(this._data_page_spaceAttrName);
        if (pageSpace) {
            pageSpace = parseInt(pageSpace, 10);

            top -= pageSpace;
        }
    }

    
        return top;
    
},

//> @method canvas.getOffsetTop()
//          Return the offsetTop coordinate of this object,
//          relative to its (ISC) parent, in pixels.
//      @group  positioning
//
//      @return (number)    top coordinate
//<
getOffsetTop : function () {

    // in this case we're always working with the clipHandle
    var handle = this.getClipHandle();


    if (this._isDisplayNone()) handle = null;

    // if we can't get the clip handle, return the specified top
    if (handle == null) return this.top;

    // just return the offsetTop - this is the absolute position
    var top = isc.Element.getOffsetTop(handle);



    
        return top;
    
},

//> @method canvas.setTop()
// Set the top coordinate of this object, relative to its enclosing context, in pixels.
// <P>
// NOTE: if you're setting multiple coordinates, use setRect() or moveTo() instead
//
//      @visibility external
//      @group  positioning
//      @param  top     (number)    new top coordinate
//<
setTop : function (top) {
    this.moveTo(null, top);
},


_getPageSpace : function () {
    return this.parentElement != null ? 0 : this.leavePageSpace != null ? this.leavePageSpace : isc.Canvas.defaultPageSpace;
},

//> @method canvas.setLeavePageSpace() (A)
// Setter for +link{Canvas.leavePageSpace,leavePageSpace}.
//
// @param newPageSpace (Integer) new value for <code>leavePageSpace</code>.
// @group positioning
// @visibility external
//<
setLeavePageSpace : function (newPageSpace) {
    this.leavePageSpace = newPageSpace;
    this.pageResize();
},


//> @method canvas.getWidth()
// Return the width of this object, in pixels.
//      @visibility external
//      @group  sizing
//      @return (number)    width
//<
getWidth : function () {
    return this.width;
},


//> @method canvas.setWidth()
// Resizes the widget horizontally to the specified width (moves the right side of the
// widget). The width parameter can be expressed as a percentage of viewport size or as
// the number of pixels.
// <P>
// NOTE: if you're setting multiple coordinates, use resizeTo() or setRect() instead
//
// @visibility external
//      @group  sizing
//
//      @param  width       (number)    new width
//<
setWidth : function (width) {
    this.resizeTo(width);
},


//> @method canvas.getHeight()
// Return the height of this object, in pixels.
//      @visibility external
//      @group  sizing
//      @return (number)    height
//<
getHeight : function () {
    return this._height;
},


//> @method canvas.setHeight()
// Resizes the widget vertically to the specified height (moves the bottom side of the
// widget). The height parameter can be expressed as a percentage of viewport size or as
// the number of pixels.
// <P>
// NOTE: if you're setting multiple coordinates, use resizeTo() or setRect() instead
//
// @group sizing
// @param height (number) new height
// @visibility external
//<
setHeight : function (height) {
    this.resizeTo(null, height);
},


//> @method canvas.getMinWidth()
// Get the minimum width available to this Canvas.
// @return (number) width
// @group  sizing
//<
getMinWidth : function () {
    return this.minWidth;
},

//> @method canvas.getMinHeight()
// Get the minimum height available to this Canvas.
// @return (number) height
// @group  sizing
//<
getMinHeight : function () {
    return this.minHeight;
},

//> @method canvas.getMaxWidth()
// Get the maximum width available to this Canvas.
// @return (number) width
// @group  sizing
//<
getMaxWidth : function () {
    return this.maxWidth;
},

//> @method canvas.getMaxHeight()
// Get the maximum height available to this Canvas.
// @return (number) height
// @group  sizing
//<
getMaxHeight : function () {
    return this.maxHeight;
},


//> @method canvas.getDragMinWidth()
// Get the effective minimum width that this Canvas can be resized to by a user.
// @return (number) width
// @see canvas.dragMinWidth
// @group  sizing
//<
getDragMinWidth : function () {
    return Math.max(this.dragMinWidth, this.minWidth);
},

//> @method canvas.getDragMinHeight()
// Get the effective minimum height that this Canvas can be resized to by a user.
// @return (number) height
// @group  sizing
//<
getDragMinHeight : function () {
    return Math.max(this.dragMinHeight, this.minHeight);
},

//> @method canvas.getDragMaxWidth()
// Get the effective maximum width that this Canvas can be resized to by a user.
// @return (number) width
// @group  sizing
//<
getDragMaxWidth : function () {
    return Math.min(this.dragMaxWidth, this.maxWidth);
},

//> @method canvas.getDragMaxHeight()
// Get the effective maximum height that this Canvas can be resized to by a user.
// @return (number) height
// @group  sizing
//<
getDragMaxHeight : function () {
    return Math.min(this.dragMaxHeight, this.maxHeight);
},


//> @method canvas.getRight()
// Return the right coordinate of this object as rendered, relative to its enclosing context,
// in pixels.
//
// @return (number) right coordinate
// @group positioning, sizing
// @visibility external
//<
getRight : function () {
    return this.getLeft() + this.getVisibleWidth();
},


//> @method canvas.setRight()
// Resizes the widget horizontally to position its right side at the specified coordinate.
// <P>
// NOTE: if you're setting multiple coordinates, use setRect(), moveTo() or resizeTo()
// instead
//
// @param   right       (number)    new right coordinate
//
// @group   sizing
// @visibility external
//<
setRight : function (right) {
    if (isc.isA.Number(right)) {
        this.resizeTo(right - this.getLeft(), null);
    } else {
        this.logWarn("setRight() expects an integer value");
    }
},


//> @method canvas.getBottom()
// Return the bottom coordinate of this object as rendered, relative to its enclosing context,
// in pixels.
//
// @return  (number)    bottom coordinate
//
// @group positioning, sizing
// @visibility external
//<
getBottom : function () {
    return this.getTop() + this.getVisibleHeight();
},


//> @method canvas.setBottom()  ([])
// Resizes the widget vertically to position its bottom edge at the specified coordinate.
// <P>
// NOTE: if you're setting multiple coordinates, use setRect(), moveTo() or resizeTo()
// instead
//
// @param bottom        (number)    new bottom coordinate
// @group sizing
// @visibility external
//<
setBottom : function (bottom) {
    if (isc.isA.Number(bottom)) {
        this.resizeTo(null, bottom - this.getTop());
    } else {
        this.logWarn("setBottom() expects an integer value");
    }
},

// Enforcing scroll size and "virtual content"
// Consider the following use cases:
// - A Layout containing a layout-spacer as its last member
// - A parent with a number of children, and the parent wants to create "padding" around
//   those children that behaves like CSS padding.
//   CSS padding as such can't be used because it doesn't affect the positioning of absPos
//   children, and does not wrap around absPos children.
//   The Layout class encounters this use case with the 'layoutMargin' property.
//
// In these cases we have "virtual content" - we know the size we intend the widget's content
// to be, but the browser does not recognize this content and *will not scroll to it*.
//
// We use the enforceScrollSize() / stopEnforcingScrollSize() methods below to workaround this
// issue. When enforceScrollSize() is called, we write an absolutely positioned DIV into the
// widget handle after all other content, giving the handle a truly scrollable area.
// Currently we only make use of these methods in the Layout class if layoutMargin is set
// or the last member is a layoutSpacer.
// We may want to generalize this the Canvas class, for example having a flag that
// automatically calls the 'enforceScrollSize()' on addChild(), childMoved(), childResized
// but we don't have a use-case where this is required at present.

//> @method canvas.enforceScrollSize ()
// Ensure that this widget's scrollable area matches (or exceeds) the dimensions passed in
// @visibility internal
// @param width (number) scroll width
// @param height (number) scroll height
// @see canvas.stopEnforcingScrollSize()
//<

_scrollSizeDivTemplate:["<DIV ID='",
                        null,   // 1: ID
                        "'style='position:absolute;width:1px;height:1px;overflow:hidden;left:",
                        null,   // 3: left
                        "px;top:",
                        null,   // 5: top
                        "px;font-size:0px'>&nbsp;</DIV>"],
_$scrollSizeDiv:"scrollSizeDiv",
//>DEBUG
_$enforceScrollSize:"enforceScrollSize",
//<DEBUG
enforceScrollSize : function (width, height) {
    //>DEBUG
    if(this.logIsDebugEnabled(this._$enforceScrollSize)) {
        this.logDebug("enforcing scroll size:"+ [width, height], "enforceScrollSize");
    }
    //<DEBUG

    if (!this._handleDrawn && !this._drawn) return;

    if (width == null) width = 0;
    if (height == null) height = 0;

    // partial fix/workaround for INFA issue #1857

    if (isNaN(width) || isNaN(height) || (!isc.Page.isRTL() && width < 0) || height < 0) {
        this.logWarn("Invalid width or height in Canvas.enforceScrollSize()"
                    +" on component: " + this.getID() + " with sizes: "
                    + [width, height] + this.getStackTrace());
        return;
    }

    if (this._drewClipDiv && isc.Browser.isMoz) {

        var handle = this.getHandle();
        handle.style.width = width + isc.px;
        handle.style.height = height + isc.px;
    } else if (this._scrollSizeDiv == null) {
        var template = this._scrollSizeDivTemplate;
        var name = this._getDOMID(this._$scrollSizeDiv);
        template[1] = name;
        template[3] = width-1;
        template[5] = height-1;

        var HTML = template.join(isc.emptyString);
        // We clear this pointer on clear()
        // We also handle redraw
        this._scrollSizeDiv =
            isc.Element.insertAdjacentHTML(this.getHandle(), this._$beforeEnd, HTML, true);
        if (this._scrollSizeDiv == null) {
            this._scrollSizeDiv = document.getElementById(name);
        }
    } else if (!this._enforcingScrollSize || this._enforcingScrollSize[0] != width ||
               this._enforcingScrollSize[1] != height)
    {
        this._scrollSizeDiv.style.left = (width-1) + isc.px;
        this._scrollSizeDiv.style.top = (height-1) + isc.px;
    }
    this._enforcingScrollSize = [width,height];
},

_$minus1px:"-1px",
stopEnforcingScrollSize : function () {
    //>DEBUG
    if(this.logIsDebugEnabled(this._$enforceScrollSize)) {
        this.logDebug("stop enforcing scroll size", "enforceScrollSize");
    }
    //<DEBUG

    delete this._enforcingScrollSize;
    if (!this.isDrawn()) return;

    if (this._drewClipDiv && isc.Browser.isMoz) {
        var handle = this.getHandle();
        handle.style.removeProperty("width");
        handle.style.removeProperty("height");
    } else if (this._scrollSizeDiv) {
        this._scrollSizeDiv.style.left = this._$minus1px;
        this._scrollSizeDiv.style.top = this._$minus1px;
    }
},




//> @method canvas.getScrollWidth() ([A])
// Returns the scrollable width of the widget's contents, including children, ignoring
// clipping.
//      @visibility external
//      @group  sizing
//
//      @return (number)    the scrollable width of the widget's contents
//<
getScrollWidth : function (calculateNewValue) {
    if (isc._traceMarkers) arguments.__this = this;


    if (this._deferredOverflow) {
        this._deferredOverflow = null;
        this.adjustOverflow("widthCheckWhileDeferred");

    }

    if (this.containsIFrame()) {
        return this.getInnerWidth();
    }

    // if we have a cached value and we're not looking for a fresh one, dont calculate a
    // new one
    if (!calculateNewValue && this._scrollWidth != null) return this._scrollWidth;

    var width = 0,
        handle = this.getClipHandle();

    if (handle == null) {
        //>DEBUG
        this.logDebug("No size info available from DOM, returning user-specified size");
        //<DEBUG
        return this.getInnerWidth();
    }

    if (this.allowNativeContentPositioning) {
        // allowNativeContentPositioning: special flag for when our handle's HTML may include
        // absolutely positioned HTML child nodes.


        this._retrievingScrollWidth = true;


        if (isc.Browser.isSafari ||
            ( isc.Browser.isMoz &&
              ((handle.scrollWidth || handle.offsetWidth) <= parseInt(handle.style.width)) ) )
        {
            width = isc.Element.getScrollWidth(this.getHandle());
        } else {
            width = isc.Element.getScrollWidth(handle);
        }

        delete this._retrievingScrollWidth;

    } else {
        // simple content - worry only about explicitly specified ISC children, and the
        // reported scrollHeight / width

        var children = this.children,
            hasChildren = children && children.length > 0,
            handleScrollWidth = 0;

        // If we have content, look at the clip handle's reported scroll size.
        if (!hasChildren || this.allowContentAndChildren) {

            if ((isc.Browser.isSafari ||
                 (isc.Browser.isMoz && isc.Browser.version >= 21) ||
                 isc.Browser.isIE) && this._drewClipDiv)
            {

                width = Math.ceil(this.getHandle().scrollWidth);


                if (this.useClipDiv && !this._willSuppressOuterDivPadding(false, true)) {
                    width += isc.Element._getHPadding(this.styleName);
                }


            } else if (isc.Browser.isMoz && this._drewClipDiv) {
                var contentHandle = this.getHandle();
                var clipDivScrollWidth = handle.scrollWidth,
                    contentDivScrollWidth = contentHandle.scrollWidth;
                if (clipDivScrollWidth > contentDivScrollWidth) {
                    width = clipDivScrollWidth;
                } else {
                    var oldDisplay = contentHandle.style.display;
                    contentHandle.style.display = "inline-block";
                    width = contentHandle.scrollWidth;
                    contentHandle.style.display = oldDisplay;
                }
            } else {

                handleScrollWidth = (handle.scrollWidth || handle.offsetWidth);
                // use this scrollWidth if it's available
                if (handleScrollWidth != null && handleScrollWidth != this._$undefined) {
                    width = handleScrollWidth = Math.ceil(handleScrollWidth);


                    if (isc.Browser.isOpera || (isc.Browser.isMoz && isc.Browser.version < 16)) {

                        width -= this.getHBorderSize();
                    }

                    // account for explicit children at negative coords in Moz

                    if (isc.Browser.isMoz && !this.isRTL()) {
                        width -= this._offscreenChildrenWidth();
                    }


                    if (isc.Browser.isMoz &&
                        this.getScrollingMechanism() == isc.Canvas.NESTED_DIV)
                    {
                        var offsetAdjustment = this.getHandle().offsetLeft;
                        if (offsetAdjustment < 0) offsetAdjustment = -offsetAdjustment;
                        width -= offsetAdjustment;
                    }

                }


                if (isc.Browser.isSafari ||
                    (isc.Browser.isMoz && width <= parseInt(handle.style.width)))
                {
                    var contentHandle = this.getHandle(),
                        contentWidth = contentHandle.scrollWidth || contentHandle.offsetWidth;
                    if (contentWidth > width) width = contentWidth;

                    /*
                    var contentHandle = this.getHandle(),
                        contentWidth = contentHandle.scrollWidth || contentHandle.offsetWidth;
                    if (contentWidth < width &&
                        (this.padding != null || (width - contentWidth) > this.getHPadding()))
                    {
                        this.logWarn("using contentWidth of: " + contentWidth +
                                     " instead of scrollWidth of: " + width +
                                     ", hPad: " + this.getHPadding());
                        width = contentWidth;
                    }
                    */
                }

            }

        } // end of check for native handle scrollWidth


        if (hasChildren) {
            var childrenWidth = this._getWidthSpan(this.children);
            width = Math.max(childrenWidth, width);
        }

    }

    // if we're enforcing scroll size, explicitly respect that
    if (this._enforcingScrollSize != null) {
        var enforcedWidth = this._enforcingScrollSize[0];
        width = Math.max(width, enforcedWidth);
    }

    //if (this.containsIFrame()) {
    //    this.logWarn("Normal scrollWidth: " + width +
    //                 ", IFrame scrollWidth of: " + this._getIFrameScrollWidth());
        //return this._scrollWidth = this._getIFrameScrollWidth();
    //}

    // cache the scrollwidth to speed up future calls to this method.
    this._scrollWidth = width;
    return width;
},

// get the distance from the furthest left to the furthest right in a list of widgets

_getWidthSpan : function (children, skipHidden) {
    var mostLeft = 0, mostRight = 0,
        horizontalOverflow = this.overflow == isc.Canvas.VISIBLE ||
                             this.overflow == isc.Canvas.CLIP_H,
        mostRightChild;

    var overflowOnLeft = this.isRTL() && (this.overflow != isc.Canvas.VISIBLE);
    // If overflowing on left "mostRight" is always going to be the specified width
    // - anything past that is clipped.
    if (overflowOnLeft) mostRight = this.getViewportWidth();
    for (var i = 0; i < children.length; i++) {
        var child = children[i];


        //if (!isc.isA.Canvas(child)) continue;
        if (!child.isDrawn() && !child._hasUndrawnSize) continue;
        if (skipHidden && child.visibility == isc.Canvas.HIDDEN) continue;

        var isAbsolute = (child.position != isc.Canvas.RELATIVE),
            childWidth = child.getVisibleWidth(),
            childLeft = (isAbsolute ? child.getLeft() : child.getOffsetLeft());

        // Natively we can't scroll to view right/bottom margins of absolute elements, but we
        // can for relative/inline elements.
        // When calculating the scrollwidth of a scrollable widget, don't include the
        // right-margin of absolute children.
        // Note - we don't make this adjustment if the overflow is visible on the horizontal
        // axis as we do want the widget to expand to accommodate the child's margin on both
        // sides
        if (!horizontalOverflow && isAbsolute) childWidth -= child.getRightMargin();

        // NOTE: DO use negative coordinate to reduce rightward extent..
        if (!overflowOnLeft && (childLeft + childWidth > mostRight)) {
            mostRight = childLeft + childWidth;
            mostRightChild = child;
        }
        if (childLeft < mostLeft) mostLeft = overflowOnLeft ? childLeft : Math.max(0,childLeft);
    }
    //if (isc.isA.Window(this)) this.logWarn("most right child: " + mostRightChild);
    return mostRight - mostLeft;
},


//> @method canvas.getScrollHeight()    ([A])
//          Returns the scrollable height of the widget's contents, including children, ignoring
//          clipping.
//      @visibility external
//      @group  sizing
//
//      @return (number)    height of the element that can scroll
//<
getScrollHeight : function (calculateNewValue) {
    if (isc._traceMarkers) arguments.__this = this;


    if (this._deferredOverflow) {
        this._deferredOverflow = null;
        this.adjustOverflow("heightCheckWhileDeferred");

    }

    if (this.containsIFrame()) {
        return this.getInnerHeight();
    }
    // If we've already cached the value, return it.
    if (!calculateNewValue && this._scrollHeight != null) return this._scrollHeight;
    var height = 0,
        handle = this.getScrollHandle();

    if (handle == null) {
        //>DEBUG
        this.logDebug("No size info available from DOM, returning user-specified size", "sizing");
        //<DEBUG
        return this.getInnerHeight();
    }

    if (this.allowNativeContentPositioning) {

        this._retrievingScrollHeight = true;


        if (isc.Browser.isSafari ||
            (isc.Browser.isMoz &&
            ((handle.scrollHeight || handle.offsetHeight) <= parseInt(handle.style.height))) )
        {
             height = isc.Element.getScrollHeight(this.getHandle());
        } else {
             height = isc.Element.getScrollHeight(handle);
        }

        delete this._retrievingScrollHeight;

    } else {
        // simple content - worry only about explicitly specified ISC children, and the
        // reported scrollHeight / width
        //this.logWarn("handle.scrollHeight: " + this.getHandle().scrollHeight +
        //             ", handle.offsetHeight: " + this.getHandle().offsetHeight +
        //             ", clipHandle.scrollHeight: " + this.getClipHandle().scrollHeight +
        //             ", clipHandle.offsetHeight: " + this.getClipHandle().offsetHeight);

        var hasChildren = (this.children && this.children.length > 0);
        if (!hasChildren || this.allowContentAndChildren) {

            if (this._drewClipDiv) {
                height = Math.ceil(this.getHandle().scrollHeight);

                if (!this._willSuppressOuterDivPadding(true, false)) {
                    height += isc.Element._getVPadding(this.styleName);
                }

            } else {
                var scrollHeight = handle.scrollHeight || handle.offsetHeight;
                // use this scrollHeight if it's available
                if (scrollHeight != null && scrollHeight != this._$undefined) {
                    height = scrollHeight = Math.ceil(scrollHeight);
                    if (isc.Browser.isMoz) height -= this._offscreenChildrenHeight();


                    if (isc.Browser.isOpera || (isc.Browser.isMoz && isc.Browser.version < 16)) {
                        height -= this.getVBorderSize();
                    }


                    if (this._drewClipDiv &&
                        (isc.Browser.isSafari ||
                         (isc.Browser.isMoz && height <= parseInt(handle.style.height))))
                    {
                        var contentHandle = this.getHandle(),
                            contentHandleHeight = contentHandle.scrollHeight ||
                                                        contentHandle.offsetHeight;

                        if (contentHandleHeight > height) height = contentHandleHeight;
                    }
                }

            }
        }


        if (hasChildren) {

            var childrenHeight = this._getHeightSpan(this.children);
            if (childrenHeight > height) {
                height = childrenHeight;
            }
        }
    }

    // as with scrollWidth, if we're enforcing scroll size, explicitly respect that
    if (this._enforcingScrollSize != null) {
        var enforcedHeight = this._enforcingScrollSize[1];
        height = Math.max(height, enforcedHeight);
    }

    //if (this.containsIFrame()) {
    //    this.logWarn("Normal scrollHeight of: " + height +
    //                 ", IFrame scrollHeight of: " + this._getIFrameScrollHeight());
    //    //return this._scrollHeight = this._getIFrameScrollHeight();
    //}

    // cache the value to speed up future returns
    this._scrollHeight = height;
    return height;
},


_offscreenChildrenHeight : function () {
    if (!isc.isAn.Array(this.children)) return 0;
    var furthestNegative = 0;
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i],
            childTop = (child.position == isc.Canvas.ABSOLUTE ?
                        child.getTop() : child.getOffsetTop());


        if (childTop < furthestNegative) furthestNegative = childTop;
    }
    //if (furthestNegative < 0) this.logWarn("offscreenHeight: " + furthestNegative);
    return -furthestNegative;
},
_offscreenChildrenWidth : function () {
    if (!isc.isAn.Array(this.children)) return 0;

    // doesn't happen for width axis with single div structure
    if (!this._drewClipDiv) return 0;

    var furthestNegative = 0;
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i],
            childLeft = (child.position == isc.Canvas.ABSOLUTE ?
                         child.getLeft() : child.getOffsetLeft());
        if (childLeft < furthestNegative) furthestNegative = childLeft;
    }
    //if (furthestNegative < 0) this.logWarn("offscreenWidth : " + furthestNegative);
    return -furthestNegative;
},

// get the distance from the furthest up to the furthest down for a list of widgets

_getHeightSpan : function (children, skipHidden) {
    var mostUp = 0, mostDown = 0,
        verticalOverflow = this.overflow == isc.Canvas.VISIBLE ||
                           this.overflow == isc.Canvas.CLIP_H;

    for (var i = 0; i < children.length; i++) {
        var child = children[i];

        //if (!isc.isA.Canvas(child)) continue;

        // Always skip undrawn children - they should never impact scrollSize of a drawn parent
        // Support a flag to avoid this behavior. This is useful for LayoutSpacers which
        // are never drawn
        if (!child.isDrawn() && !child._hasUndrawnSize) continue;
        // hidden children will effect native scrollHeight so include them unless the
        // explicit skipHidden parameter was passed in (required for layouts)
        if (skipHidden && child.visibility == isc.Canvas.HIDDEN) continue;

        var isAbsolute = child.position != isc.Canvas.RELATIVE,
            childHeight = child.getVisibleHeight(),
            childTop = (isAbsolute ? child.getTop() : child.getOffsetTop());

        // Natively we can't scroll to view right/bottom margins of absolute elements, but we
        // can for relative/inline elements.
        // When calculating the scrollHeight of a scrollable widget, don't include the
        // bottom-margin of absolute children.
        // Note - we don't make this adjustment if the overflow is visible on the vertical
        // axis as we do want the widget to expand to accommodate the child's margin on both
        // sides
        if (!verticalOverflow && isAbsolute) childHeight -= child.getBottomMargin();

        // NOTE: DO use negative coordinate to reduce downward extent..
        if (childHeight + childTop > mostDown) mostDown = childHeight + childTop;
        // .. but don't report negative extents as part of span
        if (childTop < mostUp) mostUp = Math.max(0,childTop);
    }
    //this.logWarn("mostUp: " + mostUp + ", mostDown: " + mostDown);
    return mostDown - mostUp;
},

//> @method canvas.getScrollLeft()  (A)
// Get the number of pixels this Canvas is scrolled from its left edge.
//      @group  positioning, scrolling
//
//      @return (number)    scrollLeft
// @visibility external
//<
getScrollLeft : function () {
    if (!this.isDrawn()) return this.scrollLeft;

    var scrollingMechanism = this.getScrollingMechanism(),
        trueScrollLeft = this.scrollLeft;
    if (scrollingMechanism == isc.Canvas.NATIVE) {
        trueScrollLeft = this.getScrollHandle().scrollLeft;
        if (this.isRTL()) {
            trueScrollLeft = this._adjustScrollLeftForRTL(trueScrollLeft);
        }
    } else if (scrollingMechanism == isc.Canvas.NESTED_DIV && this.isRTL()) {
        trueScrollLeft += this.getScrollRight() - this._scrollRight;
    }

    return trueScrollLeft;
},


//> @method canvas.getScrollTop()   (A)
// Get the number of pixels this Canvas is scrolled from its top edge.
//      @group  positioning, scrolling
//
//      @return (number)    scrollTop
// @visibility external
//<
getScrollTop : function () {
    // if we're using synthetic scrolling, return our number
    if (!this.isDrawn() || this.getScrollingMechanism() != isc.Canvas.NATIVE) {
        return this.scrollTop;
    }
    // otherwise return whatever the browser reports
    return this.getScrollHandle().scrollTop;
},

// XXX setPageLeft/Top don't support percent

//> @method canvas.setPageLeft()
// Set the page-relative left coordinate of this widget.
//
// @param left (number) new left coordinate in pixels
// @group positioning
// @visibility external
//<
setPageLeft : function (left) {
    this.moveBy(left - this.getPageLeft(), 0);
},

//> @method canvas.setPageTop()
// Set the page-relative top coordinate of this widget.
//
// @param top (number) new top coordinate in pixels
// @group positioning
// @visibility external
//<
setPageTop : function (top) {
    this.moveBy(0, top - this.getPageTop());
},

// return the rect of this element's parent, or of the page if this element has no parent

getParentPageRect : function () {
    if (this.parentElement) {
        var parent = this.parentElement,
            rect = parent.getPageRect();

        // don't allow keepInParentRect widgets to go over margins

        var lMargin = parent.getLeftMargin(),
            tMargin = parent.getTopMargin();
        rect[0] += lMargin;
        rect[1] += tMargin;
        rect[2] -= (lMargin + parent.getRightMargin());
        rect[3] -= (tMargin + parent.getBottomMargin());

        // If the parent has borders, also disallow dragging over the borders.
        var borderSize = parent._calculateBorderSize();
        rect[0] += borderSize.left;
        rect[1] += borderSize.top;
        rect[2] -= borderSize.right + borderSize.left;
        rect[3] -= borderSize.bottom + borderSize.top;

        // if the parent has scrollbars
        var scrollBarSize=parent.getScrollbarSize();
        if (parent.vscrollOn) rect[2] -= scrollBarSize;
        if (parent.hscrollOn) rect[3] -= scrollBarSize;

        return this._adjustParentPageRect(rect);
    }
    else return [0, 0, isc.Page.getScrollWidth(), isc.Page.getScrollHeight()];
},

_adjustParentPageRect : function (rect) {
    if (this.peers && this.peers.length > 0) {
        // for widgets that have peers, take the degree to which all peers currently extend
        // past the master's extents, and reduce the parent space by that amount.  This is
        // required for dropShadows.
        // NOTE: This method is inexact if the peer will respond to setPageRect() on its
        // master by sticking out yet further, which seems unlikely mid-drag.
        var peerRect = this.getPeerRect(),
            thisRect = this.getPageRect();
        rect[0] += (thisRect[0] - peerRect[0]);
        rect[1] += (thisRect[1] - peerRect[1]);
        rect[2] -= (peerRect[2] - thisRect[2]);
        rect[3] -= (peerRect[3] - thisRect[3]);
    }
    return rect;
},

_shouldKeepInParentRect : function () {
    return (this.keepInParentRect && this.ns.EH.dragging && this == this.ns.EH.dragMoveTarget);
},

_tempKeepInParentRect: new Array(4),
_getKeepInParentRect : function (moving) {

    var EH = this.ns.EH,
        dragTarget = EH.getDragTarget(EH.getLastEvent()),
        dragParent = dragTarget.parentElement,
        explicitRect = isc.isAn.Array(this.keepInParentRect),
        parentRect;

    if (explicitRect) {    // use provided rect (e.g. for dragOutline)
        parentRect = this.keepInParentRect;
        // offset left/top by parent's page coordinates
        if (dragParent) {
            // we may be passed component-declared values - don't side-effect them
            parentRect = parentRect.duplicate();
            parentRect[0] += dragParent.getPageLeft();
            parentRect[1] += dragParent.getPageTop();
        }
    } else {
        // use parent rect
        if (dragParent) {
            parentRect = dragTarget._adjustParentPageRect(dragTarget.getParentPageRect());
        } else {
            parentRect = this.getParentPageRect();
        }
    }

    var parentLeft = parentRect[0],
        parentTop = parentRect[1],
        parentWidth = parentRect[2],
        parentHeight = parentRect[3],
        parentRight = parentLeft + parentWidth,
        parentBottom = parentTop + parentHeight;
    //this.logWarn("child left/top:"+ [left,top] +
    //             ", parent left/top:"+ [parentLeft,parentTop]);
    //this.logWarn("child r/b: " + [right,bottom] +
    //             ", parent r/b: " + [parentRight,parentBottom]);

    // If the parent already has scrollable content outisde the current viewport in a particular direction,
    // we should allow the child to be dragged out of the viewport in that direction (not applicable to resize)
    //
    // If the widget is keepInParentRect: true but it has no parent, get scrolling info
    // from the Page object
    if (dragParent) {
        var leftScrollExtent = dragParent.getScrollLeft(),
            rightScrollExtent = dragParent.getScrollWidth() -
                                    dragParent.getViewportWidth() - leftScrollExtent,
            topScrollExtent = dragParent.getScrollTop(),
            bottomScrollExtent = dragParent.getScrollHeight() -
                                    dragParent.getViewportHeight() - topScrollExtent;
    } else {
        var leftScrollExtent = isc.Page.getScrollLeft(),
            rightScrollExtent = isc.Page.getScrollWidth() -
                                    isc.Page.getWidth() - leftScrollExtent,
            topScrollExtent = isc.Page.getScrollTop(),
            bottomScrollExtent = isc.Page.getScrollHeight() -
                                    isc.Page.getHeight() - topScrollExtent;
    }

    if (rightScrollExtent < 0) rightScrollExtent = 0;
    if (bottomScrollExtent < 0) bottomScrollExtent = 0;

    var output = this._tempKeepInParentRect,
        outputLeft = parentLeft,
        outputRight = parentRight,
        outputTop = parentTop,
        outputBottom = parentBottom;
    if (moving) {
        outputLeft -= leftScrollExtent;
        outputRight += rightScrollExtent;
        outputTop -= topScrollExtent;
        outputBottom += bottomScrollExtent;
    }
    output[0] = outputLeft;
    output[1] = outputTop;
    output[2] = outputRight - outputLeft;
    output[3] = outputBottom - outputTop;
    return output;
},

setPageRect : function (left, top, width, height, resizeOnly) {

    // if the first argument is an array, normalize it into workable parameters
    // (so that you can say widget.setPageRect(otherWidget.getPageRect()); )
    if (isc.isAn.Array(left)) {
        top = left[1];
        width = left[2];
        height = left[3];
        left = left[0];
    }

    // Optionally constrain size and position to the parent's rect during a dragReposition
    // or dragResize interaction.
    // We assume that:
    //  -- setPageRect is called on a keepInParentRect element either to move ~or~ to resize
    //     the element, not both simultaneously.  This is sufficient for user drags, but
    //     wouldn't work if keepInParentRect was intended to block programmatic resize.
    //  -- if either width or height is specified, this is a resize operation
    //  -- resizing occurs from one edge or corner at a time (revisit this if we support
    //     resizing around the center in the future)
    if (this._shouldKeepInParentRect()) {
        // are we moving or resizing the element?
        var moving = (width == null && height == null);

        // set up all of the element & parent coordinate variables

        if (width == null) width = this.getVisibleWidth();
        if (height == null) height = this.getVisibleHeight();

        var right = left + width,
            bottom = top + height,
            keepInParentRect = this._getKeepInParentRect(moving),
            parentRectLeft = keepInParentRect[0],
            parentRectRight = parentRectLeft + keepInParentRect[2],
            parentRectTop = keepInParentRect[1],
            parentRectBottom = parentRectTop + keepInParentRect[3];

        // test the coordinates and apply constraints

        if (moving) { // moving outside the parent rect?
            if (left < parentRectLeft) {
                left = parentRectLeft;
            } else if (right > parentRectRight) {
                left = parentRectRight - width;
            }
            if (top < parentRectTop) {
                top = parentRectTop;
            } else if (bottom > parentRectBottom) {
                top = parentRectBottom - height;
            }
        } else { // resizing outside the parent rect?
            if (left < parentRectLeft) {
                width = width - (parentRectLeft - left);
                left = parentRectLeft;
            } else if (right > parentRectRight) {
                width = width - (right - parentRectRight);
            }
            if (top < parentRectTop) {
                height = height - (parentRectTop - top);
                top = parentRectTop;
            } else if (bottom > parentRectBottom) {
                height = height - (bottom - parentRectBottom);
            }
        }
    }
    // end keepInParentRect


    this.moveBy(left - this.getPageLeft(), top - this.getPageTop());

    if (resizeOnly) {

        var oldWidth = this.getVisibleWidth(),
            oldHeight = this.getVisibleHeight(),
            desiredDeltaX = oldWidth - width,
            desiredDeltaY = oldHeight - height;

        this.resizeTo(width,height);
        this.redrawIfDirty("setPageRect"); // to get valid new size

        var actualDeltaX = (oldWidth - this.getVisibleWidth()),
            actualDeltaY = (oldHeight - this.getVisibleHeight());

        if (left > this.getPageLeft()) left -= (desiredDeltaX - actualDeltaX);
        if (top > this.getPageTop()) top -= (desiredDeltaY - actualDeltaY);
    } else {
        this.resizeTo(width,height);
    }

},

//> @method canvas.getCanvasOffsets() [A]
// @param [ancestor] (Canvas) Ancestor canvas to check against. If not passed, always checks
// against this canvas' direct parent.
// @return (ElementOffsets)
//<
getCanvasOffsets : function (ancestor) {
    if (ancestor != null) {
        if (!ancestor.contains(this, false)) {
            this.logWarn("getCanvasOffsets passed ancestor:" + ancestor +
                ". This is not an ancestor of this component - ignoring");
            ancestor = this.parentElement;
        }
    } else {
        ancestor = this.parentElement;
    }

    // See "Widget Positioning and Sizing Methods" comment for a discussion of coordinate systems
    // in DOM and ISC

    // If we haven't been drawn yet, return the specified coordinates
    if (!this.isDrawn() ||
        // In Moz, if the widget has been hidden using 'display:none', just return the
        // specified position

        this._isDisplayNone())
    {
        if (!this.isDrawn() && this.position == isc.Canvas.RELATIVE) {
            //>DEBUG technically, an absolutely positioned widget would also have this problem
            // if placed within an element that served as an offsetParent (eg, an absolutely
            // positioned DIV), but that scenario is very unlikely and if we catch it then this
            // warning will fire for the common case of manipulating the coordinates of a
            // top-level absolutely positioned widget before drawing it.
            this.logWarn("getCanvasOffsets(): Called on undrawn relatively-positioned widget '" +
                         this.getID() + "'.  The drawn coordinates can not be reliably " +
                         "calculated until the widget has been drawn - returning estimated position");
            //<DEBUG
        }

        var left = this.left,
            top = this.top,
            pe = this.parentElement;
        while (ancestor != pe) {
            left += pe.left;
            top += pe.top;
            pe = pe.parentElement;
        }

        return {
            left: left,
            top: top
        };
    }

    // fall through to getOffsets()
    var offsets = this.getOffsets(ancestor);

    

    return offsets;
},

//> @method canvas.getPageOffsets() [A]
// Returns the page-relative left and top coordinates of the widget on the page.
// @return (ElementOffsets)
//<
getPageOffsets : function () {
    if (isc._traceMarkers) arguments.__this = this;

    var handle = this.getClipHandle();


    if (handle && this._isDisplayNone()) {
        handle = null;
    }

    if (handle == null) {
        // If we haven't been drawn the coordinates may be wrong for a number of reasons - log
        // a warning
        if (!this.isDrawn() && this.position == isc.Canvas.RELATIVE) {
            //>DEBUG technically, an absolutely positioned widget would also have this problem
            // if placed within an element that served as an offsetParent (eg, an absolutely
            // positioned DIV), but that scenario is very unlikely and if we catch it then this
            // warning will fire for the common case of manipulating the coordinates of a
            // top-level absolutely positioned widget before drawing it.
            this.logWarn("getPageOffsets(): Called on undrawn relatively-position widget '" +
                         this.getID() + "'.  The page level coordinates can not be reliably " +
                         "calculated until the widget has been drawn - returning estimated position");
            //<DEBUG
        }

        var parent = this.parentElement;

        var left, top;
        if (parent) {
            var scrollDelta = 0;
            if (parent.hscrollOn) {
                if (!this.isRTL()) scrollDelta = parent.getScrollLeft();
                else {
                    var maxScroll = parent.getScrollWidth() - parent.getViewportWidth();
                    scrollDelta = -1 * (maxScroll - parent.getScrollLeft());
                }
            }

            var parentPageOffsets = parent.getPageOffsets();

            left = this.getOffsetLeft() + parent.getLeftBorderSize() + parent.getLeftMargin() +
                   parentPageOffsets.left - scrollDelta;

            // parent.getPageTop gives us page coords from outside border/margin of
            // parent - offsetLeft/offsetTop gives us the value to the inside of the parent,
            // so we need to add the parent's border/margin
            top = this.getOffsetTop() + parent.getTopBorderSize() + parent.getTopMargin() +
                  parentPageOffsets.top - parent.getScrollTop();
        } else {
            left = this.getOffsetLeft();
            top = this.getOffsetTop();
        }
        // In RTL we stick scrollbars on our left and shift the handle the right to accomodate
        // them, but getPageRect et all is expected to be the distance to the outside of
        // scrollbars so that's what we'll use
        if (this.isRTL() && this.vscrollOn && this.showCustomScrollbars) left -= this.getScrollbarSize();

        return {
            left: left,
            top: top
        };
    }



    if (this.useClientRectAPI && handle.getBoundingClientRect != null) {
        var bcr = isc.Element.getBoundingClientRect(handle);

        var left = bcr.left;

        left -= this.getLeftMargin();


        var adjustForScroll = !isc.Browser.isIE9;

        if (adjustForScroll) {

            var pageScrollOffset = isc.Page.getScrollLeft(true);
            left += pageScrollOffset;
        }

        if (this.isRTL()) {
            if (this.vscrollOn && this.showCustomScrollbars) {
                left -= this.getScrollbarSize();
            }

            if (isc.Browser.isIE && (isc.Browser.version < 9 || !isc.Browser.isStrict) &&
                (isc.Page.getBodyOverflow() != isc.Canvas.HIDDEN))
            {
                if (isc.EH._pageScrollbarThickness == null) {
                    isc.EH._pageScrollbarThickness = (document.body.offsetWidth -
                                                      document.body.clientWidth);
                }
                left -= isc.EH._pageScrollbarThickness;
            }
        }

        var top = bcr.top;
        // boundingClientRect returns position inside margins, and coords are relative to
        // viewport rather than page
        top -= this.getTopMargin();
        top += isc.Page.getScrollTop();

        return {
            left: left,
            top: top
        };
    }



    // If we are drawn use getOffsets().

    var offsets = this.getOffsets(),
        margins = this._calculateMargins();
    return {
        left: offsets.left - margins.left,
        top: offsets.top - margins.top
    };
},

getCanvasLeft : function (ancestor) {
    return this.getCanvasOffsets(ancestor).left;
},

//> @method canvas.getPageLeft()    ([A])
// Returns the page-relative left coordinate of the widget on the page, in pixels.
//      @visibility external
//      @group  positioning
//      @return (number)    global left coordinate
//<
getPageLeft : function () {
    return this.getPageOffsets().left;
},

useClientRectAPI:false,
useBoxObjectAPI:false,
useBoxObjectAPISelectively:true,


//> @method canvas.getOffsets() (A)
// @param [targetElement] (DOMElement or Canvas)
// @return (ElementOffsets)
//<
getOffsets : function (targetElement) {
    var isRTL = this.isRTL();
    var offsets = this.ns.Element.getOffsets(this, targetElement, isRTL, true);
    if (isRTL && this.vscrollOn && this.showCustomScrollbars) offsets.left -= this.getScrollbarSize();

    

    return offsets;
},

getCanvasTop : function (ancestor) {
    return this.getCanvasOffsets(ancestor).top;
},

//> @method canvas.getPageTop() ([A])
// Returns the page-relative top coordinate of the widget on the page, in pixels
//      @visibility external
//      @group  positioning
//      @return (number)    GLOBAL top coordinate
//<
getPageTop : function () {
    return this.getPageOffsets().top;
},

//> @method canvas.getPageRight()
// Return the page-relative right coordinate of this object, in pixels.
//
//      @group  positioning
//
//      @return (number)    GLOBAL right coordinate
// @visibility external
//<
getPageRight : function (pageOffsets) {
    pageOffsets = pageOffsets || this.getPageOffsets();
    return pageOffsets.left + this.getVisibleWidth();
},


//> @method canvas.getPageBottom()
// Return the page-relative bottom coordinate of this object, in pixels.
//      @group  positioning
//
//      @return (number)    GLOBAL bottom coordinate
// @visibility external
//<
getPageBottom : function (pageOffsets) {
    pageOffsets = pageOffsets || this.getPageOffsets();
    return pageOffsets.top + this.getVisibleHeight();
},


getPageRect : function () {
    var pageOffsets = this.getPageOffsets();
    return [pageOffsets.left, pageOffsets.top,
            this.getVisibleWidth(), this.getVisibleHeight()];
},

// Scrolling Mechanisms
// --------------------------------------------------------------------------------------------

//> @method canvas.usingCSSScrollbars() (A)
// Return whether or not we are configured to show native CSS scrollbars when
// scrollWidth/Height exceeds viewport width/height.
//      @group  scrolling
//
//      @return (boolean)
//<
usingCSSScrollbars : function () {
    return  ! this.showCustomScrollbars &&
        (this.overflow == isc.Canvas.AUTO || this.overflow == isc.Canvas.SCROLL);
},

//> @method canvas.getScrollingMechanism()  (A)
//          Return how we're implementing scrolling - one of 3 possibilities:
//           - "native" = assigning directly to handle.scrollLeft / scrollTop
//           - "clip" = using a clip region to simulate scrolling
//           - "nestedDiv" = moving an inner div within an outer clipDiv
//      @group  scrolling
//
//      @return (enum)  one of "native", "clip", "nestedDiv"
//<
// Note: If we are showing css scrollbars (this.showNativeScrollbars is true, and this.overflow
// is auto or scroll), scrollingMechanism is always native.
// Otherwise it varies by platform (due to limitations in the various platforms)
getScrollingMechanism : function () {


    if (!this._scrollingMechanism) {

        if (!this.showCustomScrollbars &&
            (this.overflow == isc.Canvas.AUTO || this.overflow == isc.Canvas.SCROLL))
        {
            this._scrollingMechanism = isc.Canvas.NATIVE;
        } else {
            // We're either showing custom scrollbars or not showing scrollbars at all for this
            // widget



            if (isc.Browser.isIE && this.isRTL() &&
                (isc.Browser.version <= 7 || (isc.Browser.version == 8 && !isc.Browser.isStrict)))
            {
                this._scrollingMechanism = isc.Canvas.NESTED_DIV;

            // In every other case we can assign directly to handle.scrollLeft / scrollTop
            } else {
                this._scrollingMechanism = isc.Canvas.NATIVE;
            }
        }
    }

    return this._scrollingMechanism;
},


// Border, Padding and Margin
// --------------------------------------------------------------------------------------------
//  Border, Margin and Padding properties can all be specified for widgets at the widget level, or
//  via the css class applied to them (through their className property)
//  We provide methods to get at the thickness of these properties for each widget - whether the
//  property is defined on the widget directly, or through it's css class.



//> @method canvas.setMargin()
// Set the CSS Margin, in pixels, for this component.  Margin provides blank space outside of
// the border.
// <P>
// This property sets the same thickness of margin on every side.  Differing per-side
// margins can be set in a CSS style and applied via +link{styleName}.
// <P>
// Note that the specified size of the widget will be the size <b>including</b> the margin
// thickness on each side.
//
// @param margin (number) new margin in pixels
//
// @visibility external
//<
setMargin : function (margin) {


    this._cachedMargins = null;
    this._fullMargins = null;

    if (margin == null) {
        delete this.margin
    } else {
        var origMargin = margin;
        if (isc.isA.String(margin)) margin = parseInt(margin);
        if (!isc.isA.Number(margin)) {
            this.logWarn("setMargin() passed invalid margin:"+ origMargin + ", ignoring.");
            return;
        }
        this.margin = margin;
    }
    var styleHandle = this.getStyleHandle();
    if (!styleHandle) return;

    this._applyFullMargins();

    // adjustOverflow - since this will change our handle-size

    this.adjustOverflow("setMargin");


    this.innerSizeChanged("Margin thickness changed");

},

// Update the margins applied to a widget after draw.
_applyFullMargins : function () {
    var handle = this.getClipHandle();
    if (!handle) return;

    // optimization: if we have nothing that would introduce automatic per-side margin
    // settings..
    if (!this._edgesAsPeer() && this._attachedPeerMap == null) {
        handle.style.marginTop = "";
        handle.style.marginBottom = "";
        handle.style.marginLeft = "";
        handle.style.marginRight = "";
        if (this.margin == null) handle.style.margin = 0;
        else handle.style.margin = this.margin + isc.px;
        return;
    }

    // Support assymetric margins if necessary.
    var margins = this._calculateMargins();
    handle.style.marginTop = margins.top + isc.px;
    handle.style.marginLeft = margins.left + isc.px;
    handle.style.marginBottom = margins.bottom + isc.px;
    handle.style.marginRight = margins.right + isc.px;
},

//> @method canvas.getMargin()
//          Returns the explicitly specified margin for this widget (set up via this.setMargin())
//      @group  appearance
//      @return (string)    margin property for this widget
//<
getMargin : function () {
    return this.margin;
},


//> @method canvas.getTopMargin()
//          Return the size of the top margin for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no top margin
//<
getTopMargin : function () {
    return this._calculateMargins().top;
},


//> @method canvas.getLeftMargin()
//          Return the size of the left margin for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no left margin
//<
getLeftMargin : function () {
    return this._calculateMargins().left;
},

//> @method canvas.getBottomMargin()
//          Return the size of the bottom margin for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no bottom margin
//<
getBottomMargin : function () {
    return this._calculateMargins().bottom;
},


//> @method canvas.getRightMargin()
//          Return the size of the right margin for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no right margin
//<
getRightMargin : function () {
    return this._calculateMargins().right;
},

//> @method canvas._calculateMargins()
//      Determines the size of the margins for this widget (on each side), by looking at the
//      widget's "Margin" property, it's handle, and it's CSS class.
//      Uses caching for speed
//
//      @group  appearance
//      @return (object)    Object with properties 'left', 'top', 'bottom', 'right', specifying the
//                          width in pixels of the margin on each side of this widget.
//<


_removeDestroyedPeers : function (list, side) {
    var destroyed = [];
    for (var i = 0; i < list.length; i++) {
        if (list[i].destroyed) {
            destroyed[destroyed.length] = {peer:list[i], side:side};
            list[i] = null;
        }
    }
    list.removeEmpty();
    return destroyed;
},
_calculateMargins : function () {

    var attachedPeers = this._attachedPeerMap,
        hasAPs = (attachedPeers != null),
        topPeers,leftPeers,rightPeers,bottomPeers;
    if (hasAPs) {
        topPeers = attachedPeers.top;
        bottomPeers = attachedPeers.bottom;
        leftPeers = attachedPeers.left;
        rightPeers = attachedPeers.right;

        var destroyedPeers = [];
        if (topPeers != null) destroyedPeers.addList(this._removeDestroyedPeers(topPeers, "top"));
        if (bottomPeers != null) destroyedPeers.addList(this._removeDestroyedPeers(bottomPeers, "bottom"));
        if (leftPeers != null) destroyedPeers.addList(this._removeDestroyedPeers(leftPeers, "left"));
        if (rightPeers != null) rightPeers.addList(this._removeDestroyedPeers(rightPeers, "right"));
        if (destroyedPeers.length > 0) {
            for (var i = 0 ; i < destroyedPeers.length; i++) {
                this._unRegisterAttachedPeer(destroyedPeers[i].peer, destroyedPeers[i].side);
            }
        }

        if ((topPeers == null || topPeers.length == 0) &&
            (bottomPeers == null || bottomPeers.length == 0) &&
            (leftPeers == null || leftPeers.length == 0) &&
            (rightPeers == null || rightPeers.length == 0)) hasAPs = false;
    }
    if (!this._edgesAsPeer() && !hasAPs) return this._calculateNormalMargins();


    var fullMargins = this._fullMargins;
    if (fullMargins) return fullMargins;

    var margins = this._getSpecifiedMargins();
    fullMargins = {
        left:margins.left,
        right:margins.right,
        top:margins.top,
        bottom:margins.bottom
    };

    if (hasAPs) {

        if (topPeers) {
            for (var i = 0; i < topPeers.length; i++) {
                var topPeer = topPeers[i];
                fullMargins.top += topPeer.getVisibleHeight();
                if (topPeer._attachedPeerOffset != null) {
                    fullMargins.top -= topPeer._attachedPeerOffset;
                }
            }
        }
        if (bottomPeers) {
            for (var i = 0; i < bottomPeers.length; i++) {
                var bottomPeer = bottomPeers[i];
                fullMargins.bottom += bottomPeer.getVisibleHeight();
                if (bottomPeer._attachedPeerOffset != null) {
                    fullMargins.bottom -= bottomPeer._attachedPeerOffset;
                }
            }
        }
        if (leftPeers) {
            for (var i = 0; i < leftPeers.length; i++) {
                var leftPeer = leftPeers[i];
                fullMargins.left += leftPeer.getVisibleWidth();
                if (leftPeer._attachedPeerOffset != null) {
                    fullMargins.left -= leftPeer._attachedPeerOffset;
                }
            }
        }
        if (rightPeers) {
            for (var i = 0; i < rightPeers.length; i++) {
                var rightPeer = rightPeers[i];
                fullMargins.right += rightPeer.getVisibleWidth();
                if (rightPeer._attachedPeerOffset != null) {
                    fullMargins.right -= rightPeer._attachedPeerOffset;
                }
            }
        }
    }

    //>RoundCorners add to margins to leave room for surrounding EdgedCanvas

    if (this._edgesAsPeer()) {
        var edge = this._createEdges();
        // add to margins to allow room for the edgedCanvas
        fullMargins.left += edge._leftMargin,
        fullMargins.right += edge._rightMargin,
        fullMargins.top += edge._topMargin,
        fullMargins.bottom += edge._bottomMargin
    }
    //<RoundCorners


    return (this._fullMargins = fullMargins);
},

_getSpecifiedMargins : function () {
    var drawn = this._drawn;
    this._drawn = false;
    var margins = this._calculateNormalMargins();
    this._drawn = drawn;
    return margins;
},

_calculateNormalMargins : function () {

    // If we've already calculated it, return the cached version for speed
    // (Cleared out by 'setMargin()')
    if (this._cachedMargins != null) return this._cachedMargins;

    // First check for this.margin / directly applying the margin to the DOM.
    // We'll then check the css class for this widget for any margins we don't find applied directly

    // There are various options for setting the css margin width -
    //  Measure:    float followed by units designator (cm, mm, in, pt, pc, px, OR em, or ex)
    //  Percentage: (fairly self explanatory!)
    //
    // We currently only handle returning widths specified in pixels.
    var margins = {},
        pxString = isc.px;

    // If it's not drawn - Look at this.margin
    if (!this.isDrawn()) {

        // We are assuming here that the margin will be uniform on all sides - something like
        // "1px"
        var marginString = this.margin;

        if (isc.isA.String(marginString)) {
            // We should handle either "2" or "2px" format margin property
            // (This will also handle "2px 2px 2px 2px", but not asymmetric margins applied in this
            //  way)
            if (isc.endsWith(marginString, pxString) || parseInt(marginString) + isc.emptyString == marginString)
                marginString = parseInt(marginString);
        }

        // This will handle the case where a margin was specified as a number directly, or where
        // we've parsed a string
        if (isc.isA.Number(marginString)) {
            margins.top = marginString;
            margins.bottom = marginString;
            margins.left = marginString;
            margins.right = marginString;

            // cache and return it, we're done
            this._cachedMargins = margins;
            return margins;
        }

    // If it is drawn, check the DOM for the margin actually applied to the div
    } else {


        var handleStyle = this.getStyleHandle(),
            marginLeft = handleStyle.marginLeft,
            marginRight = handleStyle.marginRight,
            marginTop = handleStyle.marginTop,
            marginBottom = handleStyle.marginBottom;

        if (isc.isA.String(marginLeft) && isc.endsWith(marginLeft, pxString))
            marginLeft = parseInt(marginLeft);

        if (isc.isA.String(marginRight) && isc.endsWith(marginRight, pxString))
            marginRight = parseInt(marginRight)

        if (isc.isA.String(marginTop) && isc.endsWith(marginTop, pxString))
            marginTop = parseInt(marginTop);

        if (isc.isA.String(marginBottom) && isc.endsWith(marginBottom, pxString))
            marginBottom = parseInt(marginBottom)

        if (isc.isA.Number(marginLeft)) margins.left = marginLeft;
        if (isc.isA.Number(marginRight)) margins.right = marginRight;
        if (isc.isA.Number(marginTop)) margins.top = marginTop;
        if (isc.isA.Number(marginBottom)) margins.bottom = marginBottom;
    }

    // Having looked at the handle (or 'margin' property for undrawn widgets), if we have not
    // determined margin sizes for any side, the widget will display any margin specified on the
    // css class applied to it.
    // Check the styleObject from the className for any margin's we haven't already determined.
    if (this.className) {

        if (!isc.isA.Number(margins.left))
            margins.left = isc.Element._getLeftMargin(this.className);
        if (!isc.isA.Number(margins.right))
            margins.right = isc.Element._getRightMargin(this.className);
        if (!isc.isA.Number(margins.top))
            margins.top = isc.Element._getTopMargin(this.className);
        if (!isc.isA.Number(margins.bottom))
            margins.bottom = isc.Element._getBottomMargin(this.className);
    } else {
        // widget has no margin on any sides we haven't got yet!
        if (!isc.isA.Number(margins.left))
            margins.left = 0;
        if (!isc.isA.Number(margins.right))
            margins.right = 0;
        if (!isc.isA.Number(margins.top))
            margins.top = 0;
        if (!isc.isA.Number(margins.bottom))
            margins.bottom = 0;
    }


    return (this._cachedMargins = margins);
},


//> @method canvas.getTopBorderSize()
//          Return the size of the top border for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no border
//<
getTopBorderSize : function () {
    return this._calculateBorderSize().top;
},

//> @method canvas.getBottomBorderSize()
//          Return the size of the bottom border for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no border
//<
getBottomBorderSize : function () {
    return this._calculateBorderSize().bottom;
},

//> @method canvas.getLeftBorderSize()
//          Return the size of the left border for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no border
//<
getLeftBorderSize : function () {
    return this._calculateBorderSize().left;
},

//> @method canvas.getRightBorderSize()
//          Return the size of the right border for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no border
//<
getRightBorderSize : function () {
    return this._calculateBorderSize().right;
},


//> @method canvas.getHBorderSize()
//          Return the size of the horizontal borders (left and right) for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no border
//<
getHBorderSize : function () {
    return (this.getLeftBorderSize() + this.getRightBorderSize());
},


//> @method canvas.getVBorderSize()
//          Return the total size of the vertical borders (top and bottom) for this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no border
//<
getVBorderSize : function () {
    return this.getTopBorderSize() + this.getBottomBorderSize();
},

//> @method canvas._calculateBorderSize()
//      Determines the size of the border for this widget (on each side), from the 'border' property
//      for the widget, and any specified css class.
//      Stores resulting values in _cachedBorderSize() property.
//
//      @group  appearance
//      @return (object)    Object with properties 'left', 'top', 'bottom', 'right', specifying the
//                          width in pixels of the border on each side of this widget.
//<
_calculateBorderSize : function () {

    // If we've already calculated it, return the cached version for speed
    // (Cleared out by 'setBorder()')
    if (this._cachedBorderSize != null) return this._cachedBorderSize;

    // Determine the borderSize from the DOM.
    var borderSizes = {},
        pxString = isc.px;

    // The Border for a widget can be applied directly to its handle's style attribute - done
    // via the "border" property of the widget, or (if that is not defined), it is picked up
    // from the CSS class for the widget.
    // In this method we will check for an explicitly specified border for the widget, and if none
    // is found, fall through to checking the border on the widget's css class.
    // - Note on the 'border' property.
    //   widget.border is applied directly to the clipHandle's style. It should be of the form
    //   '2px solid black' (so a string of CSS designating a border style).
    //   We don't support the developer applying different borders to different sides, except via
    //   a css class applied to the widget.


    // There are various options for setting the css border width -
    //  String:     medium, thin, thick
    //  Measure:    float followed by units designator (cm, mm, in, pt, pc, px, OR em, or ex)
    //
    // We only support sizes specified in px.


    // Border applied to the handle directly
    //
    // If it's not drawn - Look at border specified via this.border
    if (!this.isDrawn()) {

        // We are assuming here that the border will be uniform on all sides - something like
        // "1px solid black"
        var borderString = this.border;

        // If we can't find a width in pixels, assume width is not defined in this.border
        // We check for this via the presence of the 'px' string. Note that
        // css supports specifying the border style in any order, so we need to use a regexp to
        // find the right part of the string (next to the 'px').

        if (borderString != null && isc.contains(borderString, pxString)) {
            var borderSize = borderString.match(/\s*\d+px/g);

            // All the borders should be the same size - use the first size encountered
            if (isc.isAn.Array(borderSize)) borderSize = parseInt(borderSize[0]);
            else borderSize = parseInt(borderSize);

            if (isc.isA.Number(borderSize)) {
                this._cachedBorderSize = {
                    left:borderSize,
                    right:borderSize,
                    top:borderSize,
                    bottom:borderSize
                }
                return this._cachedBorderSize;
            }
        }

    // If it is drawn, check the DOM for the border actually applied to the div
    } else {

        // examine the style of the drawn HTML element (before looking at the css class)


        var handleStyle = this.getStyleHandle(),
            borderLeft = handleStyle.borderLeftWidth,
            borderRight = handleStyle.borderRightWidth,
            borderTop = handleStyle.borderTopWidth,
            borderBottom = handleStyle.borderBottomWidth;

        if (isc.isA.String(borderLeft) && isc.endsWith(borderLeft, pxString))
            borderLeft = parseInt(borderLeft);

        if (isc.isA.String(borderRight) && isc.endsWith(borderRight, pxString))
            borderRight = parseInt(borderRight)

        if (isc.isA.String(borderTop) && isc.endsWith(borderTop, pxString))
            borderTop = parseInt(borderTop);

        if (isc.isA.String(borderBottom) && isc.endsWith(borderBottom, pxString))
            borderBottom = parseInt(borderBottom)

        if (isc.isA.Number(borderLeft)) borderSizes.left = borderLeft;
        if (isc.isA.Number(borderRight)) borderSizes.right = borderRight;
        if (isc.isA.Number(borderTop)) borderSizes.top = borderTop;
        if (isc.isA.Number(borderBottom)) borderSizes.bottom = borderBottom;

    }

    // Having looked at the handle (or 'border' property for undrawn widgets), if we have not
    // determined sizes for any side, derive the border sizes from the css class applied to the
    // widget.
    var className = this._getBorderClassName();
    if (className) {
        // Determine the borderWidth from the css style class for this element
        if (!isc.isA.Number(borderSizes.left))
            borderSizes.left = isc.Element._getLeftBorderSize(className);
        if (!isc.isA.Number(borderSizes.right))
            borderSizes.right = isc.Element._getRightBorderSize(className);
        if (!isc.isA.Number(borderSizes.top))
            borderSizes.top = isc.Element._getTopBorderSize(className);
        if (!isc.isA.Number(borderSizes.bottom))
            borderSizes.bottom = isc.Element._getBottomBorderSize(className);
    } else {
        // widget has no border on any sides we haven't got yet!
        if (!isc.isA.Number(borderSizes.left))
            borderSizes.left = 0;
        if (!isc.isA.Number(borderSizes.right))
            borderSizes.right = 0;
        if (!isc.isA.Number(borderSizes.top))
            borderSizes.top = 0;
        if (!isc.isA.Number(borderSizes.bottom))
            borderSizes.bottom = 0;
    }


    return (this._cachedBorderSize = borderSizes);
},

// CSS class that actually governs what borders appear on the handle.
// This is overridden in Button.js where we apply the baseStyle + modifier to the
// handle directly.
_getBorderClassName : function () {
    return this.className;
},

// Unexposed method to set explicit per-side padding
// Padding is applied to the content handle. If we drew a clip div, then we need to access the
// content handle's CSSStyleDeclaration. Otherwise, the clip div is the content div, so we can
// use the cached style handle.
setTopPadding : function (padding) {

    this._cachedPadding = null;
    this.topPadding = padding;
    if (isc.isA.Number(padding)) padding += "px";
    if (this.isDrawn()) {

        var styleHandle = this._drewClipDiv ? this.getHandle().style : this.getStyleHandle();
        styleHandle.paddingTop = padding;
    }
},
setLeftPadding : function (padding) {

    this._cachedPadding = null;
    this.leftPadding = padding;
    if (isc.isA.Number(padding)) padding += "px";
    if (this.isDrawn()) {

        var styleHandle = this._drewClipDiv ? this.getHandle().style : this.getStyleHandle();
        styleHandle.paddingLeft = padding;
    }
},
setRightPadding : function (padding) {

    this._cachedPadding = null;
    this.rightPadding = padding;
    if (isc.isA.Number(padding)) padding += "px";
    if (this.isDrawn()) {

        var styleHandle = this._drewClipDiv ? this.getHandle().style : this.getStyleHandle();
        styleHandle.paddingRight = padding;
    }
},
setBottomPadding : function (padding) {

    this._cachedPadding = null;
    this.bottomPadding = padding;
    if (isc.isA.Number(padding)) padding += "px";
    if (this.isDrawn()) {

        var styleHandle = this._drewClipDiv ? this.getHandle().style : this.getStyleHandle();
        styleHandle.paddingBottom = padding;
    }
},

//> @method canvas.setPadding()
// Set the CSS padding of this component, in pixels.  Padding provides space between the border
// and the component's contents.
// <P>
// This property sets the same thickness of padding on every side.  Differing per-side
// padding can be set in a CSS style and applied via +link{styleName}.
// <P>
// @group appearance
// @param newPadding (number) new padding in pixels
// @visibility external
//<
_$0px:"0px",
setPadding : function (padding) {
    this._cachedPadding = null;

    if (padding != null) {
        var origPadding = padding;
        if (isc.isA.String(padding)) padding = parseInt(padding);
        if (!isc.isA.Number(padding)) {
            this.logWarn("setPadding passed unrecognized value:"+ origPadding + " - ignoring");
            return;
        }
    }
    this.padding = padding;

    // No support in non DOM browsers really
    var handle = isc.Browser.isDOM ? this.getHandle() : null;
    if (!handle) {
        return;
    }

    // if padding is null - clear out this.padding
    if (padding == null) {

        // clear out the padding from the handle
        // if we're using clipDivs, also clear out any padding from the clipDiv, since we'll
        // want the css class's padding (if there is any) to be applied.
        handle.style.padding = null;
        if (this._drewClipDiv) this.getClipHandle().style.padding = null;

    } else {
        // update the handle
        // Note - if we're using clip divs, ensure that the clip div's padding is explicitly
        // set to zero so we don't get nested padding from the specified padding property and
        // the className applied to the element
        handle.style.padding = this.padding + isc.px;
        if (this._drewClipDiv) this.getClipHandle().style.padding = this._$0px;
    }

},

//> @method canvas.getPadding()
//          Return the size of the padding around this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no padding
//<
getPadding : function () {
    return this.padding;
},

//> @method canvas.getTopPadding()
//          Return the size of the top padding above this canvas' content.
//          Derives value from explicitly specified 'padding' if present, or from css class.
//      @group  appearance
//      @return (number)    size in pixels, 0 == no padding
//<
getTopPadding : function () {
    return this._calculatePadding().top;
},

//> @method canvas.getBottomPadding()
//          Return the size of the bottom padding (below this canvas' content).
//          Derives value from explicitly specified 'padding' if present, or from css class.
//      @group  appearance
//      @return (number)    size in pixels, 0 == no padding
//<
getBottomPadding : function () {
    return this._calculatePadding().bottom;
},

//> @method canvas.getLeftPadding()
//          Return the size of the left padding for this canvas.
//          Derives value from explicitly specified 'padding' if present, or from css class.
//      @group  appearance
//      @return (number)    size in pixels, 0 == no padding
//<
getLeftPadding : function () {
    return this._calculatePadding().left;
},

//> @method canvas.getRightPadding()
//          Return the size of the right padding for this canvas.
//          Derives value from explicitly specified 'padding' if present, or from css class.
//      @group  appearance
//      @return (number)    size in pixels, 0 == no padding
//<
getRightPadding : function () {
    return this._calculatePadding().right;
},

//> @method canvas.getVPadding()
//          Return the vertical size of the padding around this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no padding
//<
getVPadding : function () {
    return this.getTopPadding() + this.getBottomPadding();
},


//> @method canvas.getHPadding()
//          Return the horizontal size of the padding around this canvas
//      @group  appearance
//      @return (number)    size in pixels, 0 == no padding
//<
getHPadding : function () {
    return this.getLeftPadding() + this.getRightPadding();
},

//> @method canvas._calculatePadding()
//          Determine the size of the padding on each side of this canvas.
//          Derives value from explicitly specified 'padding' if present, or from css class.
//          Stores in this._cachedPadding object.
//      @group  appearance
//<
_calculatePadding : function () {

    // If we've already calculated padding for this widget, return the cached version for speed
    // (cleared out by 'setPadding()')
    if (this._cachedPadding != null) return this._cachedPadding;
    // Determine the padding size from the DOM.

    var padding = {},
        pxString = isc.px;

    // if it's drawn examine the style of the drawn HTML element first
    if (this.isDrawn() && this.getHandle() != null) {
        // Note: if we're writing out two DIVS (as with Moz), the padding will be
        // applied to the inner contentDiv, rather than the outer clipDiv
        // We must use getHandle().style rather than getStyleHandle() therefore as
        // getStyleHandle() will examine the style applied to the clipDiv.

        var handleStyle = this.getHandle().style;

        if (handleStyle.paddingTop != null && !isc.isAn.emptyString(handleStyle.paddingTop) &&
            isc.endsWith(handleStyle.paddingTop, pxString)) {
                padding.top = parseInt(handleStyle.paddingTop);
        }
        if (handleStyle.paddingBottom != null && !isc.isAn.emptyString(handleStyle.paddingBottom) &&
            isc.endsWith(handleStyle.paddingBottom, pxString)) {
                padding.bottom = parseInt(handleStyle.paddingBottom);
        }

        if (handleStyle.paddingLeft != null && !isc.isAn.emptyString(handleStyle.paddingLeft) &&
            isc.endsWith(handleStyle.paddingLeft, pxString)) {
                padding.left = parseInt(handleStyle.paddingLeft);
        }

        if (handleStyle.paddingRight != null && !isc.isAn.emptyString(handleStyle.paddingRight) &&
            isc.endsWith(handleStyle.paddingRight, pxString)) {
                padding.right = parseInt(handleStyle.paddingRight);
        }

        // If the padding is not set here, this will continue to check the CSS class style

    // if the widget is not drawn, but this.padding was specified, that takes precidence over the
    // css class applied to the widget.
    } else {
        if (this.topPadding != null) padding.top = this.topPadding;
        if (this.leftPadding != null) padding.left = this.leftPadding;
        if (this.rightPadding != null) padding.right = this.rightPadding;
        if (this.bottomPadding != null) padding.bottom = this.bottomPadding;
        if (this.padding != null) {
            var paddingAttr = parseInt(this.padding);
            if (padding.left == null) padding.left = paddingAttr;
            if (padding.top == null) padding.top = paddingAttr;
            if (padding.bottom == null) padding.bottom = paddingAttr;
            if (padding.right == null) padding.right = paddingAttr;
        }
    }

    // Having looked at the handle (or 'padding' property for undrawn widgets), if we have not
    // determined sizes for any side, derive the padding sizes from the css class applied to the
    // widget.
    if (this.className) {
        if (!isc.isA.Number(padding.left)) padding.left = isc.Element._getLeftPadding(this.className);
        if (!isc.isA.Number(padding.right)) padding.right = isc.Element._getRightPadding(this.className);
        if (!isc.isA.Number(padding.top)) padding.top = isc.Element._getTopPadding(this.className);
        if (!isc.isA.Number(padding.bottom)) padding.bottom = isc.Element._getBottomPadding(this.className);
    } else {
        // Padding not explicitly set == padding is zero
        if (!isc.isA.Number(padding.left)) padding.left = 0;
        if (!isc.isA.Number(padding.right)) padding.right = 0;
        if (!isc.isA.Number(padding.top)) padding.top = 0;
        if (!isc.isA.Number(padding.bottom)) padding.bottom = 0;
    }


    return (this._cachedPadding = padding);
},


// Containment and Intersection
// --------------------------------------------------------------------------------------------


//> @method canvas.containsPoint()  ([A])
// Return whether or not this object contains the specified global (x,y) coordinates.
// <P>
// Will return false if any parent canvas does not contain the specified point, (EG:
// you're hovering over an element's absolute location, but it is scrolled out of
// view in a parent element)
//
//      @visibility external
//      @group  positioning
//
//      @param  x       (int)   GLOBAL x-coordinate
//      @param  y       (int)   GLOBAL y-coordinate
//      @param  [withinViewport]    (Boolean)   point lies specifically within our viewport
//                                              (drawn area excluding margins and scrollbars if
//                                              present)
//
//      @return (Boolean)   true if this object contains the specified point; false otherwise
//<
containsPoint : function (x, y, withinViewport) {
    if (isc._traceMarkers) arguments.__this = this;
    // always bail if we're not visible
    if (!this.isVisible() || !this.isDrawn()) return false;


    if (withinViewport == null) withinViewport = false;

    // as a quick initial check, see if the point is within the page rect at all

    // Note: don't return true if the specified point is over our margin.
    var myPageLeft = this.getPageLeft() + this.getLeftMargin();
    if (x < myPageLeft) {

        return false;
    }
    var myPageTop = this.getPageTop() + this.getTopMargin();

    if (y < myPageTop) {


        return false;
    }
    var myWidth = withinViewport ? this.getViewportWidth()
                                 : (this.getVisibleWidth() - this.getHMarginSize());
    if (x > myPageLeft + myWidth) {

        return false;
    }
    var myHeight = withinViewport ? this.getViewportHeight()
                                  : (this.getVisibleHeight() - this.getVMarginSize());

    if (y > myPageTop + myHeight) {

        return false;
    }
    var pageLeft = 0, pageTop = 0;

    // Iterate through any parent elements, verifying that the point is contained in their
    // viewports

    // Use 'getCanvasOffsets()' to determine the page level position of each parentElement,
    // by summing these values from the top level element.

    // create an array consisting of this widget and all parents
    var parentChain = this._parentChain = this._parentChain || []; // reuse an array
    parentChain.length = 1;
    parentChain[0] = this;

    var i = 1, currentParent = this;
    while (currentParent.parentElement != null) {
        currentParent = currentParent.parentElement
        parentChain[i] = currentParent;
        i++;
    }

    var viewportWidth, viewportHeight;

    // iterate backwards through the array, from top level parent down to us.
    // If we hit a case where we're not in the viewport, quit.
    for (var j = parentChain.length - 1; j >= 0 ; j--) {

        var widget = parentChain[j];

        var canvasOffsets = widget.getCanvasOffsets();
        pageLeft += canvasOffsets.left;
        pageTop += canvasOffsets.top;

        

        if (widget == this && !withinViewport) {
            // respect the withinViewport flag
            viewportWidth = widget.getVisibleWidth() - widget.getHMarginSize();
            viewportHeight = widget.getVisibleHeight() - widget.getVMarginSize();
        } else {
            viewportWidth = widget.getViewportWidth();
            viewportHeight = widget.getViewportHeight();
        }




        if  ( !((x >= pageLeft) && (x <= pageLeft + viewportWidth) &&
               (y >= pageTop) && (y <= pageTop + viewportHeight))       )
        {

            return false;
        }
    }
    return true;
},

//> @method canvas.visibleAtPoint()  ([A])
// Does this widget contain the specified global (x,y) coordinates, and have no other widgets
// also at the specified position, obscuring this one?  This is commonly used for (for example)
// drag and drop interactions.
//
//      @visibility external
//      @group  positioning
//
//      @param  x       (number)    GLOBAL x-coordinate
//      @param  y       (number)    GLOBAL y-coordinate
//      @param  [withinViewport]    (boolean)   point lies within our viewport rather than
//                                              just our drawn area
//      @param  [ignoreWidgets]  (canvas)    If passed ignore widget(s), do not check whether
//                                          those widgets occludes this one.
//      @param [upToParent] (Canvas) If passed, only check for siblings occluding the
//              component up as far as the specified parent widget.
//
//      @return (boolean)   true if this object contains the specified point; false otherwise
//<

visibleAtPoint : function (x, y, withinViewport, ignoreWidgets, upToParent) {
    if (isc._traceMarkers) arguments.__this = this;




    if (!this.containsPoint(x,y,withinViewport)) {

        return false;
    }

    if (!isc.isAn.Array(ignoreWidgets)) ignoreWidgets = [ignoreWidgets];

    // To determine whether there are any widgets obscuring this widget from the specified
    // point we need to check whether our siblings and the siblings of each of our parents i
    // are positioned over the point and have a higher z-index than this widget.
    var currentWidget = this;

    while (currentWidget != null && currentWidget != upToParent) {
        var siblings = (currentWidget.parentElement != null ?
                        currentWidget.parentElement.children :
                        isc.Canvas._topCanvii);
        for (var i = 0; i < siblings.length; i++) {
            var sibling = siblings[i];
            // avoid checking this widget, any ignoreWidgets, and any widgets tagged
            // with isMouseTransparent:true
            if (sibling == null || sibling == currentWidget ||
                !sibling.isDrawn() || !sibling.isVisible() ||
                ignoreWidgets.contains(sibling) ||
                sibling.isMouseTransparent ||
                (sibling.getZIndex() < currentWidget.getZIndex()))
            {
                continue;
            }

            // can't be occluded by event mask
            if (sibling._maskTarget) continue;

            // You can't be occluded by a sibling's scrollbar/thumb without also being occluded
            // by the master of that scrollbar.
            // You could be occluded by your parent's scrollbar, iff the parent was both H&V
            // scrolling, but drag scrolling should bring you into view immediately, so we
            // ignore this case.
            if (isc.isA.Scrollbar(sibling) || isc.isA.ScrollThumb(sibling)) continue;

            // ignore edges generated by showEdges:true.  Note DropShadow is always
            // mouseTransparent
            if (isc.EdgedCanvas && isc.isA.EdgedCanvas(sibling) &&
                sibling.masterElement &&
                sibling.masterElement._edgedCanvas == sibling) continue;

            // Layouts never allow members to occlude each other, so skip the sibling if both
            // the current parent under consideration and it's sibling are members of a Layout
            if (isc.Layout && isc.isA.Layout(sibling.parentElement) &&
                sibling.parentElement.hasMember(sibling) &&
                sibling.parentElement.hasMember(currentWidget))
            {

                continue;
            }

            // ignore TabBars within TabSets when we are in the paneContainer (one day
            // TabSet will probably become a Layout and this check will be redundant with the
            // above)
            if (isc.TabSet && isc.isA.TabBar(sibling) &&
                isc.isA.TabSet(sibling.parentElement) &&
                sibling.parentElement.paneContainer &&
                sibling.parentElement.paneContainer.contains(this))
            {
                //this.logWarn("eliminated TabBar: " + sibling +
                //             " because we are in the paneContainer of TabSet: " +
                //             sibling.parentElement);
                continue;
            }


            if (sibling.containsPoint(x, y, false)) {

                return false;
            }
        }
        currentWidget = currentWidget.parentElement;
    }


    return true;
},


//> @method canvas.scrollIntoView()
//          Scrolls the widget such that the passed in x / y coordinates (relative to the
//          widget content) are visible in the viewport if they previously were not.
//
//      @group  positioning
//
//      @param  x       (number)    x-coordinate (relative to widget content)
//      @param  y       (number)    y-coordinate (relative to widget content)
//      @param  width   (number)    width of the rect to scroll into view - optional
//      @param  height  (number)    height of the rect to scroll into view - optional
//      @param  [xPosition] (string)    Where the target rectangle should show up in this
//                                      widget's viewport. Valid options are <code>"left"</code>
//                                      <code>"center"</code> or <code>"right"</code>. Defaults
//                                      to <code>"center"</code>.
//      @param  [yPosition] (string)    Where the target rectangle should show up in this
//                                      widget's viewport. Valid options are <code>"top"</code>
//                                      <code>"center"</code> or <code>"bottom"</code>. Defaults
//                                      to <code>"center"</code>.
//      @param  [animated]  (boolean)   If true, scrolling will be performed as an animation
//      @param [callback]   (callback)  Callback to fire when scrollIntoView completes.
//                                      Typically would only be passed in for animated
//                                      scroll, but will be fired after synchronous scroll too.
//                                      Will also be fired if this method does not actually
//                                      cause this widget's scroll position to change.<br>
//                                      Takes no parameters, but will be executed in the scope
//                                      of this widget.
//      @param [source]     (source)    The widget is a source calling scroolIntoView. It is set
//                                      to <code>"this"</code> for the first call the method.
//                                      It is used for recursive calls (scrollIntoView).
//      @param [target]      (canvas)   Ancestor widget in whose viewport the 'source' needs to appear.
//                                      If unset we'll iterate all the way to the top of the page, scrolling
//                                      every ancestors viewport such that the source appears in it.
//                                      If specified we'll only iterate up as far as the target.
//<
_$left:"left", _$top:"top", _$right:"right", _$bottom:"bottom", _$center:"center",
scrollIntoView : function (x,y, width, height, xPosition, yPosition, animated, callback, alwaysCenter, source, target) {
    // If not passed a width / height, just scroll the point into view
    if (width == null) width = 0;
    if (height == null) height = 0;

    if (source == null) {
        // This is the first method call in the call chain
        source = this;
    }

    if (this.isRTL()) {
        // if we're in RTL mode, x will be < 0 if we're overflowing to the left.
        // our scroll coords start at zero however, so map across to the same space.
        x = this._shiftScrollLeftOrigin(x, false);
    }

    var synchronousCallback = true;

    var desiredScrollLeft, desiredScrollTop;

    if (this.overflow != isc.Canvas.VISIBLE &&
        this.overflow != isc.Canvas.IGNORE) {

        if (x != null) {
            var scrollLeft = this.getScrollLeft(),
                viewportWidth = this.getViewportWidth(),
                scrollRight = scrollLeft + viewportWidth,
                rightOff = false,
                leftOff = false;

            if (x + width > scrollRight) {
                rightOff = true;
            }
            if (x < scrollLeft) {
                leftOff = true;
            }

            // if the right edge is off, or the left edge is off, but not both, we need to
            // scroll.
            // (If they're both off, on different sides, then the rect is greater than the
            // viewport and there's nothing we can do)
            if (rightOff != leftOff || alwaysCenter) {
                if (xPosition == this._$left) {
                    desiredScrollLeft = x;
                // Align the right edge with the right edge of the viewport
                } else if (xPosition == this._$right) {
                    desiredScrollLeft = (x + width) - viewportWidth;

                // Centering is the default case
                } else {
                    desiredScrollLeft = (x + parseInt(width/2))
                                        - parseInt(viewportWidth / 2);
                }
            }
        }

        if (y != null) {
            var scrollTop = this.getScrollTop(),
                viewportHeight = this.getViewportHeight(),
                scrollBottom = scrollTop + viewportHeight,
                topOff = false,
                bottomOff = false;

            if (y + height > scrollBottom) bottomOff = true;
            if (y < scrollTop) topOff = true;

            // if the top edge is off, or the bottom edge is off, but not both we need to
            // scroll.
            // (If they're both off, on different sides, then the rect is greater than the
            // viewport and there's nothing we can do)
            if (topOff != bottomOff || alwaysCenter) {
                if (yPosition == this._$top) {
                    desiredScrollTop = y;
                } else if (yPosition == this._$bottom) {
                    desiredScrollTop = (y + height) - viewportHeight;
                } else {
                    desiredScrollTop = (y + parseInt(height/2))
                                         - parseInt(viewportHeight / 2);
                }
            }
        }
        // Note - if we don't have to scroll, avoid calling scrollTo, as this can take a little time
        if (desiredScrollLeft != null || desiredScrollTop != null) {
            //>Animation
            if (animated) {
                this.animateScroll(desiredScrollLeft, desiredScrollTop, callback);
                synchronousCallback = false;
            } else {
            //<Animation

            this.scrollTo(desiredScrollLeft, desiredScrollTop, "scrollIntoView");
            //>Animation
            }
            //<Animation
        }
    }

    // At this point we may be done, or we may have parent elements whos viewports we're not
    // visible through.
    if (this != target && this.parentElement != null) {
        var parentLeft = x, parentTop = y;
        if (parentLeft != null) {
            // If scrolling is not animated we've scrolled to desired scrollLeft / top -
            // otherwise we will end up there, so adjust the x/y to account for this.
            parentLeft -= (desiredScrollLeft != null ? desiredScrollLeft : this.getScrollLeft());
            parentLeft += this.getOffsetLeft();
        }
        if (parentTop != null) {
            parentTop -= (desiredScrollTop != null ? desiredScrollTop : this.getScrollTop());
            parentTop += this.getOffsetTop();
        }

        this.parentElement.scrollIntoView(parentLeft, parentTop, width, height, null, null, null, null, null, source, target);
    }

    if (callback && synchronousCallback) this.fireCallback(callback);
},


//> @method canvas.intersects() ([])
//          Returns true if the rectangles of this widget and the specified widget overlap.
//      @visibility external
//      @group  positioning
//      @param  other       (canvas)    other canvas to test for intersection
//      @return (Boolean)   true if this canvas intersects other; false otherwise
//<
intersects : function (other){

    var otherLeft = other.getPageLeft(),
        otherWidth = other.getVisibleWidth(),
        otherTop = other.getPageTop(),
        otherHeight = other.getVisibleHeight()
    ;
    return this.intersectsRect(otherLeft, otherTop, otherWidth, otherHeight)
},

//> @method canvas.intersectsRect() ([])
//          Returns true if the rectangle of this widget intersects with the rectangle coordinates
//          passed in, and false otherwise.
//      @visibility external
//      @group  positioning
//
//      @param  left        (number, array) left coord of rect (or rect array)
//      @param  top         (number)        top coord of rect
//      @param  width       (number)        width of rect
//      @param  height      (number)        height of rect
//
//      @return (boolean)   true if this canvas intersects the rectangle passed in; false otherwise
//<
intersectsRect : function (left, top, width, height){
    var rect1, rect2 = [];

    if (isc.isAn.Array(left)) rect1 = left;
    else rect1 = [left, top, width, height];

    return isc.Canvas.rectsIntersect(rect1, [this.getPageLeft(), this.getPageTop(),
                                             this.getVisibleWidth(), this.getVisibleHeight()]);
},

//> @method canvas.encloses() ([])
// Returns true if the rectangle of this widget encloses the rectangle of the specified widget.
// @visibility external
// @group  positioning
// @param  other       (canvas)    other canvas to test for enclosure
// @return (Boolean)   true if this canvas encloses other; false otherwise
//<
encloses : function (other){

    var otherLeft = other.getPageLeft(),
        otherWidth = other.getVisibleWidth(),
        otherTop = other.getPageTop(),
        otherHeight = other.getVisibleHeight()
    ;
    return this.enclosesRect(otherLeft, otherTop, otherWidth, otherHeight)
},

//> @method canvas.enclosesRect() ([])
// Returns true if the rectangle of this widget encloses the rectangle coordinates
// passed in, and false otherwise.
// @visibility external
// @group  positioning
//
// @param  left        (number | array of number) left coord of rect (or rect array)
// @param  top         (number)                   top  coord of rect
// @param  width       (number)                   width  of rect
// @param  height      (number)                   height of rect
//
// @return (boolean)   true if this canvas encloses the rectangle passed in; false otherwise
//<
enclosesRect : function (left, top, width, height){
    var rect2 = [];

    if (isc.isAn.Array(left)) rect2 = left;
    else rect2 = [left, top, width, height];

    return isc.Canvas.rectEnclosesRect([this.getPageLeft(), this.getPageTop(),
                                         this.getVisibleWidth(), this.getVisibleHeight()], rect2);
},


_differentEventCharacteristics : function (eventA, eventB) {

    var lastEventTargetElem = (eventA.DOMevent.target && eventA.DOMevent.target.nodeType == 1 ? eventA.DOMevent.target
                                                                                              : eventA.DOMevent.target.parentElement);
    var targetElem = (eventB.DOMevent.target && eventB.DOMevent.target.nodeType == 1 ? eventB.DOMevent.target
                                                                                     : eventB.DOMevent.target.parentElement);
    if (lastEventTargetElem != null &&
        targetElem != null &&
        lastEventTargetElem !== targetElem &&
        (// "differentness" heuristic handles cases where the elements are different
         // because of an intervening redraw().
         lastEventTargetElem.tagName !== targetElem.tagName ||
         lastEventTargetElem.id !== targetElem.id))
    {
        return true;
    }
    return false;
},


// Interior Coordinates
// --------------------------------------------------------------------------------------------

//> @method canvas.containsEvent()
//          Return true if the last event's mouse coordinates are within the bounds of this component.
//      NOTE: Z-ordering is not considered for the purposes of this test.  If the coordinate you're
//      testing is occluded by other component, but the X,Y coordinates are still within the bounds
//      of that component, this method will return true.
//
//      @group  events, positioning
//
//      @return (Boolean)   true if the event occurred within the bounds of this component
// @visibility external
//<
containsEvent : function () {
    return this.containsPoint(this.ns.EH.getX(), this.ns.EH.getY());
},

//> @classMethod canvas.getEventEdge()
// Check if an event is within an "edge" of this canvas.
//
// @param [edgeMask] (Array of EdgeName) Array of legal edges.  Default is all the edges that
//                                       allow resizing (see +link{resizeFrom})
//
// @return (EdgeName) edge where the mouse is positioned, or null if not within a legal edge
//                    (including being in the center)
// @group dragdrop, dragResize
// @see attr:canvas.resizeFrom
// @visibility external
//<
getEventEdge : function (edgeMask, coords) {
    var EH = this.ns.EH;
    if (!edgeMask) edgeMask = (this.resizeFrom || EH.ALL_EDGES);

    if (!isc.isAn.Array(edgeMask)) edgeMask = [edgeMask];

    // get various sizes, etc. to make the logic below cleaner
    // Note: coordinates reported are relative to outside our Margins. Adjust to get the
    // coordinates over the widget's actual handle

    var margins = this._getSpecifiedMargins(),
        leftMargin = margins.left,
        rightMargin = margins.right,
        topMargin = margins.top,
        bottomMargin = margins.bottom;


    var pageOffsets = this.getPageOffsets(),
        left = pageOffsets.left + leftMargin,
        top = pageOffsets.top + topMargin,
        // 2002.2.25 outset rect by 1 to fix problems in IE where exactly on the edge
        // doesn't register properly
        right = (this.getPageRight(pageOffsets) - rightMargin) + 1,
        bottom = (this.getPageBottom(pageOffsets) - bottomMargin) + 1,
        hEdge = "",
        vEdge = "",
        x, y
    ;

    // take position from coords if available
    if (coords) {
        x = coords[0];
        y = coords[1];
    } else {
        x = EH.getX();
        y = EH.getY();
    }

    //this.logWarn("x,y: " + [x,y] + ", rect: " + [left,top,right,bottom]);

    // if the mouse is not within this Canvas at all, bail
    if (y < top || y > bottom || x < left || x > right) return null;

    // figure out what side/corner of the target we're in, if any

    var margin = this.edgeMarginSize;
    if (this.minNonEdgeSize > 0) {
        if (edgeMask.contains("B") || edgeMask.contains("T")) {
            if (edgeMask.contains("B") && edgeMask.contains("T")) {
                if ((bottom - top) < (this.minNonEdgeSize + 2 * margin)) {
                    margin = (bottom - top) / 3;
                }
            } else {
                if ((bottom - top) < (this.minNonEdgeSize + margin)) {
                    margin = (bottom - top) / 2;
                }
            }
        }
        if (edgeMask.contains("L") || edgeMask.contains("R")) {
            if (edgeMask.contains("L") && edgeMask.contains("R")) {
                if ((right - left) < (this.minNonEdgeSize + 2 * margin)) {
                    margin = (right - left) / 3;
                }
            } else {
                if ((right - left) < (this.minNonEdgeSize + margin)) {
                    margin = (right - left) / 2;
                }
            }
        }
    }

    // is it inside the top or bottom edge ?  (Bottom takes precedence over top)
    if      (y >= (bottom - margin) && y <= bottom)             vEdge = "B";
    else if (y >= top               && y <= (top + margin + 1)) vEdge = "T";

    // is it inside the left or right edge ?  (Right takes precedence over left)
    if      (x >= (right - margin)  && x <= right)               hEdge = "R";
    else if (x >= left              && x <= (left + margin + 1)) hEdge = "L";

    // if we're in some edge
    if (hEdge != "" || vEdge != "") {
        var resizeCorner = vEdge + hEdge;
        // figure out if we're in a valid corner, which takes precedence over an edge
        if (edgeMask.contains(resizeCorner)) return resizeCorner;
        // not in a valid corner, check for valid edge (horizontal takes precedence)
        else if (hEdge != "" && edgeMask.contains(hEdge)) return hEdge;
        else if (vEdge != "" && edgeMask.contains(vEdge)) return vEdge;
    }

    // no legal corner or edge found -- forget it!
    return null;
},


//> @method canvas.getOffsetX()
//  Return the X-coordinate of the last event relative to the left edge of the content of this
//  Canvas.<br><br>
//
//  NOTE: To get a coordinate relative to the <b>viewport</b> of this Canvas, subtract
//  this.getScrollLeft()
//
//  @group  events, positioning
//  @return (number)
//  @visibility external
//<
getOffsetX : function (event) {
    var value = this.ns.EH.getX(event)
        - (this.getPageLeft() + this.getLeftBorderSize())
        + this.getScrollLeft()
        // textDirection: if the canvas is drawn RTL and the vertical scrollbar is visible, it
        // will be on the left of the content, and we don't want to count it as part of the
        // canvas, so subtract the scrollbarSize from the offsetX
        - (this.vscrollOn && this.isRTL() ? this.getScrollbarSize() : 0);

    return value;
},


//> @method canvas.getOffsetY()
//  Return the Y-coordinate of the last event, relative to the top edge of the content of this
//  Canvas.<br><br>
//
//  NOTE: To get a coordinate relative to the <b>viewport</b> of this Canvas, subtract
//  this.getScrollTop()
//
//  @group  events, positioning
//  @return (number)
//  @visibility external
//<
getOffsetY : function (event) {
    return this.ns.EH.getY(event)
                + this.getScrollTop()
                - (this.getPageTop() + this.getTopBorderSize());
},


// Visible Area
// --------------------------------------------------------------------------------------------




//> @method canvas.setClip()    (A)
// Set the clip region of this handle
//
// NOTE: you can pass an array in TRBL order as the first parameter instead
//
//      @group  sizing
//
//      @param  top         (number)    new top clip coordinate
//      @param  right       (number)    new right clip coordinate
//      @param  bottom      (number)    new bottom clip coordinate
//      @param  left        (number)    new left clip coordinate
//<
setClip : function (top, right, bottom, left) {

    // store the values in the 'clip' slot
    if (isc.isAn.Array(top))
        this._clip = top;
    else
        this._clip = [top, right, bottom, left];

    // if the layer has been drawn, set its clip!
    var clipHandle = this.getClipHandle();
    if (clipHandle != null) {

        var clip = this._clip;



        

        // actually set the clip
        clipHandle.style.clip = "rect("+ clip.join("px ")+"px)";
    }
},

//> @method canvas.getScrollbarSize()   (A)
//  Returns the thickness of this widget's scrollbars.<br>
//  For canvases showing custom scrollbars this is determined from <code>this.scrollbarSize</code>
//
//  @group  scrolling
//  @return (number) thickness of the scrollbars, in pixels
//  @visibility external
//  @see    scrollbarSize
//<
getScrollbarSize : function () {
    if (this.showCustomScrollbars) return this.getCustomScrollbarSize();
    return isc.Element.getNativeScrollbarSize();
},

//> @method canvas.getViewportWidth()   (A)
//  Returns the width of the viewport onto the scrollable content.
//
//  @group  sizing
//
//  @return (number) width of the viewport, in pixels
//  @visibility external
//<
getViewportWidth : function() {
    return this.getVisibleWidth() -
                (this.vscrollOn ? this.getScrollbarSize() : 0) -
                this.getHMarginBorder();
},

//> @method canvas.getViewportHeight()  (A)
//  Returns the height of the viewport onto the scrollable content.
//
//  @group  sizing
//
//  @return (number) height of the viewport, in pixels
//  @visibility external
//<
getViewportHeight : function() {
    return this.getVisibleHeight() -
                    (this.hscrollOn ? this.getScrollbarSize() : 0) -
                    this.getVMarginBorder();
},

//> @method canvas.getOuterViewportWidth()  (A)
// Returns the outer width of the viewport - the width including any borders (but excluding
// any vertical scrollbar)
//  @group  sizing
//
//  @return (number) width of the viewport, in pixels
//<
getOuterViewportWidth : function () {

    return this.getVisibleWidth() - (this.vscrollOn ? this.getScrollbarSize() : 0) -
           this.getHMarginSize();
},

//> @method canvas.getOuterViewportHeight() (A)
// Returns the outer height of the viewport - the width including any borders (but excluding
// any horizontal scrollbar)
//
//  @group  sizing
//
//  @return (number) height of the viewport, in pixels
//<
getOuterViewportHeight : function () {
    return this.getVisibleHeight() - (this.hscrollOn ? this.getScrollbarSize() : 0) -
           this.getVMarginSize();
},



//> @method canvas.getInnerHeight() (A)
// Returns the amount of space available for (an) absolutely positioned child widget(s) or
// absolutely positioned HTML content, without introducing clipping, scrolling or overflow.
// <P>
// This is the space within the viewport of the widget (including padding, but excluding
// margins, borders or scrollbars) rendered at its specified size.
//
//  @group  sizing
//
//  @return (number) inner height of the widget in pixels
//  @see Canvas.getInnerWidth()
//  @see Canvas.getInnerContentHeight()
//  @see Canvas.getInnerContentWidth()
//  @visibility external
//<
getInnerHeight : function(visibleHeight) {
    return (visibleHeight ? this.getVisibleHeight() : this.getHeight())
           - ((this.hscrollOn || this.overflow == isc.Canvas.SCROLL) ? this.getScrollbarSize()
                                                                     : 0)
           - this.getVMarginBorder();
},

//> @method canvas.getInnerWidth()  (A)
// Returns the amount of space available for absolutely positioned child widget(s) or
// absolutely positioned HTML content, without introducing clipping, scrolling or overflow.
// <P>
// This is the space within the viewport of the widget (including padding, but excluding
// margins, borders or scrollbars) rendered at its specified size.
//
//  @return (number) inner width of the widget in pixels
//  @group  sizing
//  @see Canvas.getInnerHeight()
//  @see Canvas.getInnerContentHeight()
//  @see Canvas.getInnerContentWidth()
//  @visibility external
//<
getInnerWidth : function (visibleWidth) {
    var width = visibleWidth ? this.getVisibleWidth() : this.getWidth();
    if (this.vscrollOn || this.overflow == isc.Canvas.SCROLL || this.alwaysShowVScrollbar)
        width -= this.getScrollbarSize();
    return width - this.getHMarginBorder();
},

//> @method canvas.getInnerContentHeight()  (A)
// Returns the amount of space available for interior content (or relatively positioned child
// widget(s)) without introducing clipping, scrolling or overflow.<br>
// This is the space within the viewport of the widget (not including padding, and excluding
// margins, borders or scrollbars) rendered at its specified size.
//
//  @group  sizing
//
//  @return (number) inner height of the widget in pixels
//  @see Canvas.getInnerContentWidth()
//  @see Canvas.getInnerHeight()
//  @see Canvas.getInnerWidth()
//  @visibility external
//<
getInnerContentHeight : function (visibleHeight) {
    // Interior content space is the size of the handle (specified size less margins), minus
    // border and padding -- the total available space for a relatively positioned HTML element
    // without introducing overflow
    return Math.max(1, (visibleHeight ? this.getVisibleHeight() : this.getHeight())
           - (this.hscrollOn || this.overflow == isc.Canvas.SCROLL ?
                    this.getScrollbarSize() : 0)
           - this.getVMarginBorderPad());

},


//> @method canvas.getInnerContentWidth()   (A)
//  Returns the amount of space available for interior content (or relatively positioned child
//  widget(s)) without introducing clipping, scrolling or overflow.<br>
//  This is the space within the viewport of the widget (not including padding, and excluding
//  margins, borders or scrollbars) rendered at its specified size.
//
//  @group  sizing
//
//  @return (number) inner height of the widget in pixels
//  @see Canvas.getInnerContentHeight()
//  @see Canvas.getInnerHeight()
//  @see Canvas.getInnerWidth()
//  @visibility external
//<
getInnerContentWidth : function (visibleWidth) {

    var width = visibleWidth ? this.getVisibleWidth() : this.getWidth();
    if (this.vscrollOn || this.overflow == isc.Canvas.SCROLL || this.alwaysShowVScrollbar)
        width -= this.getScrollbarSize();
    return Math.max(1, width - this.getHMarginBorderPad());

},



// Per-axis accessors for border, margin, padding size
// ---------------------------------------------------------------------------------------

//> @method canvas.getVBorderPad()  (A)
//  Returns the total size of vertical (top and bottom) border and padding for this widget.
//
//  @group  sizing
//
//  @return (number) vertical border and padding for this widget
//<
getVBorderPad : function () {
    return this.getVBorderSize() + this.getVPadding();
},

//> @method canvas.getHBorderPad()  (A)
//  Returns the total size of horizontal (left and right) border and padding for this widget.
//
//  @group  sizing
//
//  @return (number) horizontal border and padding for this widget
//<
getHBorderPad : function () {
    return this.getHBorderSize() + this.getHPadding();
},

getHMarginSize : function () {
    return this.getLeftMargin() + this.getRightMargin();
},

getVMarginSize : function () {
    return this.getTopMargin() + this.getBottomMargin();
},


getVMarginBorder : function () {
    var margins = this._calculateMargins(),
        borders = this._calculateBorderSize();
    return margins.top + margins.bottom +
            borders.top + borders.bottom;
    //return this.getVMarginSize() + this.getVBorderSize();
},
getHMarginBorder : function () {
    var margins = this._calculateMargins(),
        borders = this._calculateBorderSize();
    return margins.left + margins.right +
            borders.left + borders.right;
    //return this.getHMarginSize() + this.getHBorderSize();
},

getVMarginBorderPad : function () {
    return this.getVMarginSize() + this.getVBorderPad();
},

getHMarginBorderPad : function () {
    return this.getHMarginSize() + this.getHBorderPad();
},

// Visible Dimensions
// ---------------------------------------------------------------------------------------

//>!BackCompat 2004.1.1 outdated synonyms of getVisibleHeight/Width
getClipWidth : function () { return this.getVisibleWidth(); },
getClipHeight : function () { return this.getVisibleHeight(); },
//<!BackCompat

//> @method canvas.getVisibleWidth()    (A)
//      Return the visible width of the Canvas.
//
//      @group  sizing
//
//      @return (number) visible width in pixels
//  @visibility external
//<
// Note this width includes any margin for the item - essentially it's the space required to
// render the widget

getVisibleWidth : function (recalc) {
    if ((this._drawn || this._handleDrawn) &&
        (this.overflow == isc.Canvas.VISIBLE || this.overflow == isc.Canvas.CLIP_V)) {
        // if the overflow is visible, the visible width may be greater than the
        // specified width
        return Math.max(this.width, this.minWidth,
                        (this.getScrollWidth(recalc) + this.getHMarginBorder()));
    } else {
        // overflow is Hidden, Auto, Scroll, CLIP_H or Ignore.
        // Return the specified width
        //>Animation
        // If we're doing an animated hide/show verify adjust for rendered scrollbar size if
        // necessary
        var animationInfo = this.isAnimating(this._$show) ? this.$showAnimationInfo :
                            this.isAnimating(this._$hide) ? this.$hideAnimationInfo : null;
        if (animationInfo != null && !animationInfo._vertical && this.vscrollOn) {
            var sbDelta = 0;
            if (this.vscrollbar.visibility == isc.Canvas.HIDDEN) {
                sbDelta = this.getScrollbarSize();
            } else {

                sbDelta = this.getScrollbarSize() - this.getScrollbarSize();
            }
            return Math.max(this.getWidth() - sbDelta,1);
        }
        //<Animation
        return this.getWidth();
    }
},

//> @method canvas.getVisibleHeight()   (A)
//      Return the visible height of the Canvas.
//
//      @group  sizing
//
//      @return (number) visible height in pixels
//  @visibility external
//<
getVisibleHeight : function (recalc) {
    if ((this._drawn || this._handleDrawn) &&
        (this.overflow == isc.Canvas.VISIBLE || this.overflow == isc.Canvas.CLIP_H))
    {
        // if the overflow is visible, the visible height may be greater than the
        // specified height
        return Math.max(this.getHeight(), this.getMinHeight(),
                        (this.getScrollHeight(recalc) + this.getVMarginBorder()));

    } else {
        //>Animation
        // During animateShow() / animateHide(), with wipe/slide effect, we resize and hide the
        // scrollbar on the leading edge of the resize.
        // setHeight() assumes the scrollbar is fully visible, so at this point the specified height
        // could exceed the rendered height by the size of the scrollbar.
        // Explicitly catch this case and return the smaller size.
        // This ensures that when animateHide() / animateShow()ing members of a layout the reflow
        // respects tha actual space taken up by the member during the animation rather than being
        // off by up to one scrollbarSize

        if (this.isAnimating()) {
            var animationInfo = this.isAnimating(this._$show) ? this.$showAnimationInfo :
                                this.isAnimating(this._$hide) ? this.$hideAnimationInfo : null;
            if (animationInfo != null && animationInfo._vertical && this.hscrollOn) {
                var sbDelta = 0;
                if (this.hscrollbar && this.hscrollbar.visibility == isc.Canvas.HIDDEN) {
                    sbDelta = this.getScrollbarSize();
                } else {
                    sbDelta = this.getScrollbarSize() - this.getScrollbarSize();
                }
                return Math.max(this.getHeight() - sbDelta,1);
            }
        }
        //<Animation
        // overflow is Hidden, Auto, Scroll, CLIP_V, or Ignore.
        // Return the specified height
        return this.getHeight();
    }
},

getPeerRect : function () {
    var rect = this.getPageRect();

    if (this.peers == null) return rect;
    for (var i = 0; i < this.peers.length; i++) {
        var peer = this.peers[i];
        // NOTE: only ignore a peer that is explicitly not visible while we are visible
        if (!peer.isDrawn() || (this.isVisible() && !peer.isVisible())) continue;

        // Special case: If we are hidden, and we have hidden scrollbars, they may or may not
        // show with us.
        // Furthermore, when we adjustOverflow(), if scrollbars are no longer required we hide
        // them, but don't bother resizing them (if thats required), so they can effect the
        // size reported by this method when they shouldn't
        // Use vscrollOn / hscrollOn to avoid taking them into account if they're not currently
        // meant to be showing.
        if ((!this.vscrollOn && peer == this.vscrollbar) ||
            (!this.hscrollOn && peer == this.hscrollbar)) continue;

        var peerRect = peer.getPageRect();

        if (peerRect[0] < rect[0]) rect[0] = peerRect[0];
        if (peerRect[1] < rect[1]) rect[1] = peerRect[1];
        // NOTE: a peer may extend to the right/bottom while being smaller than it's master
        var peerRight = peerRect[0] + peerRect[2];
        if (peerRight > rect[0] + rect[2]) rect[2] = peerRight - rect[0];
        var peerBottom = peerRect[1] + peerRect[3];
        if (peerBottom > rect[1] + rect[3]) rect[3] = peerBottom - rect[1];
    }
    return rect;
},

// Moving
// --------------------------------------------------------------------------------------------


//> @method canvas.moveBy() ([])
//          Moves the widget deltaX pixels to the right and deltaY pixels down. Pass negative
//          numbers to move up and/or to the left.
//      @visibility external
//      @group  positioning
//      @param  deltaX      (int)   amount to move horizontally (may be negative)
//      @param  deltaY      (int)   amount to move vertically (may be negative)
//      @return (Boolean)   whether the component actually moved
//      @example    move
//<
//>Animation
// @param [animating] (boolean) Internal parameter passed if this move is being called as part
//  of an animation
//<Animation

moveBy : function (deltaX, deltaY, animating, resizeHandle) {
    //>Animation
    // If an external moveBy is called during an animated setRect, finish the animated setRect
    // before starting the explicit move.
    // Note: it's a setRect if resizeHandle is true, and a straight move otherwise
    var setRectAnimating = animating && resizeHandle;
    if (!setRectAnimating && this.rectAnimation) this.finishAnimation("rect");
    else if (!animating && this.moveAnimation) this.finishAnimation("move");
    //<Animation

    if (isc._traceMarkers) arguments.__this = this;

    // adjust our internal values by values passed in
    if (isc.isA.Number(deltaX))
        this.left += deltaX;
    else
        deltaX = 0;

    if (isc.isA.Number(deltaY))
        this.top += deltaY;
    else
        deltaY = 0;


    var moved = (deltaX != 0 || deltaY != 0);
    if (!moved && !resizeHandle) return false;

    // store the deltas locally - used by _completeMoveBy()
    this._moveDeltaX = deltaX;
    this._moveDeltaY = deltaY;


    var left = this.left,
        top = this.top,
        width = (resizeHandle && this._resizeDeltaX ? this.width : null),
        height = (resizeHandle && this._resizeDeltaY ? this._height : null);

    if (this.isDrawn()) {
        var clipHandle = this.getClipHandle(),
            oldPageSpace = clipHandle.getAttribute(this._data_page_spaceAttrName);
        if (oldPageSpace) {
            oldPageSpace = parseInt(oldPageSpace, 10);

        } else {
            oldPageSpace = 0;
        }

        var pageSpace = this._getPageSpace(),
            d = pageSpace - oldPageSpace;

        // If now using a different pageSpace, then we need to clear cached offset coordinates
        // because any cached top page offsets from "none" (for either this widget or a descendant)
        // will be off by `d'.
        if (d != 0) {
            this._$leftCoords = this._$topCoords = null;
            this._childrenCoordsChanged();
        }

        top += d;
    }

    this._setHandleRect(left, top, width, height);

    // update the 'data-isc-page-space' attribute
    if (this.isDrawn()) {
        var pageSpace = this._getPageSpace(),
            clipHandle = this.getClipHandle();
        if (pageSpace != 0) clipHandle.setAttribute(this._data_page_spaceAttrName, String(pageSpace));
        else clipHandle.removeAttribute(this._data_page_spaceAttrName);
    }

    if (resizeHandle) this._completeResizeBy();
    this._completeMoveBy();

    return moved;
},


_completeMoveBy : function () {

    var deltaX = (this._moveDeltaX || 0),
        deltaY = (this._moveDeltaY || 0),
        undef;

    this._moveDeltaX = undef;
    this._moveDeltaY = undef;

    // Just bail if this method was called with no move required.

    if (!deltaX && !deltaY) return;

    // fire up/down chain parent and child / master and peer notifications
    this._fireParentMoved(this, deltaX, deltaY);
    this._fireMasterMoved(deltaX, deltaY);
    if (this.parentElement) this.parentElement.childMoved(this, deltaX, deltaY);
    if (this.masterElement) this.masterElement.peerMoved(this, deltaX, deltaY);

    //>FocusProxy If we have a focusProxy written into the DOM, move it so it continues to
    // float over this widget.
    if (this._useFocusProxy && this._hasFocusProxy) {
        var fpp = this._getFocusProxyParentHandle();
        if (fpp != null) {
            var newLeft = parseInt(fpp.style.left) + deltaX,
                newTop = parseInt(fpp.style.top) + deltaY;
            fpp.style.left = newLeft + "px";
            fpp.style.top = newTop + "px";
        }
    } //<FocusProxy



    // call the observable moved method


    this._$leftCoords = this._$topCoords = null;
    this.handleMoved(deltaX, deltaY);
},

handleMoved : function (deltaX, deltaY) {
    // when a top level element is moved or resized it can introduce page level scrollbars, changing
    // the browser window size overall.
    // We don't get a resized event notification from the browser on this, so explicitly run the
    // _pageResize() method

    if (!this._pageResizing && this.isDrawn()
        && this.parentElement == null && !isc.Page.pollPageSize)
    {
        isc.EH.fireOnPause("checkForBodyOverflowChange",
                            {target:isc.Canvas, methodName:"checkForPageResize"},
                            100);
    }
    this.moved(deltaX, deltaY);
},

// canvas.moved()
//  Observable method called whenever a Canvas is explicitly moved.
//  Documented under registerStringMethods
moved : function (deltaX, deltaY) {

//!DONTOBFUSCATE  (we want observers to be able to pick up the passed values)
},


// canvas.parentMoved()
//  Observable method called whenever a Canvas's ancestor is explicitly moved.
//  Documented under registerStringMethods
parentMoved : function (parent, deltaX, deltaY) {
},

// If our parent has moved, inform any children we have that an ancestor has moved.
// This notifies the children that they will have been repositioned in terms of page
// coordinates.
handleParentMoved : function (parent, deltaX, deltaY) {


    this._$leftCoords = this._$topCoords = null;
    this.parentMoved(parent, deltaX, deltaY);

    // fireParentMoved is what notifies our children (recursively) that we moved.
    this._fireParentMoved(parent, deltaX, deltaY);
},

// fire 'handleParentMoved' on children. This will recursively call back into this method to
// notify all descendents.
_fireParentMoved : function (parent, deltaX, deltaY) {
    var children = this.children;
    if (children != null) {
        for (var i = 0; i < children.length; i++) {
            // NOTE: this fires before during init, before children have necessarily been
            // auto-created
            if (isc.isA.Canvas(children[i])) {
                children[i].handleParentMoved(parent, deltaX, deltaY);
            }
        }
    }
},


// parent receiving notification that a child has moved
_$childMoved : "childMoved",
childMoved : function (child, deltaX, deltaY) {
    //>EditMode
    if (this.editingOn && this.editContext) {
        this.editContext.saveCoordinates(child);

        if (this.editProxy && this.editProxy.canSelectChildren && !this._movingSelection) {
            // if this component is part of a selection, move the rest of the selected
            // components by the same amount
            var selection = this.editContext.getSelectedComponents();
            if (selection.length > 0 && selection.contains(child)) {
                this._movingSelection = true;
                for (var i = 0; i < selection.length; i++) {
                    if (selection[i] != child) {
                        selection[i].moveBy(deltaX, deltaY);
                    }
                }
                this._movingSelection = false;
            }
        }
    }
    //<EditMode

    // containedPeer means this child is a peer of some other element that intends to keep the
    // child completely within it's bounding box, hence, it should not trigger adjustOverflow.
    // Examples include the ScrollThumb and the label for StretchImgButtons
    if (child && child.masterElement != null && child.containedPeer == true) return;

    // if a child moves, the size of our content may have changed, so adjustOverflow.  For
    // example, we may need to grow/shrink to fit (overflow:visible), or show or hide scrollbars
    // (overflow:auto).

    if (this.allowContentAndChildren && this.overflow == isc.Canvas.VISIBLE)
        this._resetHandleOnAdjustOverflow = true;

    this._markForAdjustOverflow(this._$childMoved);
},

_fireMasterMoved : function (deltaX, deltaY) {
    var peers = this.peers;
    if (peers == null) return;
    for (var i = 0; i < peers.length; i++) {
        if (peers[i]) peers[i].masterMoved(deltaX, deltaY);
    }
},
masterMoved : function (deltaX, deltaY) {
    if (this._moveWithMaster) this.moveBy(deltaX, deltaY);
    // NOTE: not a recursive notification
},

// master receiving notification that a peer has moved
peerMoved : function (child, deltaX, deltaY) { },

//> @method canvas.dragRepositioned()    (A)
// Observable function fired once at the end of a successful drag-reposition operation.
// Useful for firing some action in response to reposition without firing repeatedly on every
// dragMove while the user is drag-resizing the target.
//<
dragRepositioned : function () {},

// Percent / "*" coordinate handling
// --------------------------------------------------------------------------------------------
// Special coordinate specifications like percents and "*" must get resolved into pixel values
// before the widget is drawn.
// We handle this by resolving these coordinates to pixel values on widget init(), (or on
// setWidth() / setHeight()), and storing the pixel value as this.width (available via
// this.getWidth()).
// The original string value is stored in a second variable and updated when it's meaning
// changes (eg a percent's resolved value changing on parent/page resize).
//   - percents are resolved as percents of the parent size, or of the page size if we're at top
//     level
//   - "*" values are just destroyed, since they only matter in Layouts, and are the same as the
//     absence of a value

// get the delta between the coordinate of name 'name', new value 'coord', current value 'current
// value'.  Handles resolving percent coordinates to pixel values and discarding and logging bad
// values
_$height : "height",
_$width : "width",
_$left : "left",
_$top : "top",
_$_height: "_height",
_$percent: "%",
_$star : "*",
_percentNames : {
    height : "_percent_height",
    width : "_percent_width",
    left : "_percent_left",
    top : "_percent_top"
},
_minNames:{
    height:"minHeight",
    width:"minWidth"
},
_maxNames:{
    height:"maxHeight",
    width:"maxWidth"
},
getDelta : function (name, newValue, currentValue) {
    if (newValue == null) return null;


    var propertyName = name,
        percentName = this._percentNames[name];
    if (name == this._$height) propertyName = this._$_height;

    // If we were passed a fractional number, round it and warn.
    // Note we don't need to do this with percent values, which already get rounded
    // or numbers-as-strings (like "5") where we simply parseInt when converting.
    if (isc.isA.Number(newValue)) {
        var rounded = Math.round(newValue);
        if (rounded != newValue) {
            this.logWarn(name + " specified as fractional coordinate:"+ newValue +
                        ". Rounded to:" + rounded);
            newValue = rounded;
        }
    } else if (isc.isA.String(newValue) && isc.endsWith(newValue, this._$percent)) {

        // remember the percent version of this coordinate
        this[percentName] = newValue;


        // if this is a top-level widget with a percent coordinate, update whenever there is a
        // page resize event.  NOTE: this is FIRE_ONCE so we don't receive multiple resize
        // events; we reregister each time.
        if (this.masterElement == null && this.parentElement == null && this._resizeID == null) {
            this._resizeID = isc.Page.setEvent(this._$resize, this, isc.Page.FIRE_ONCE);
        }

        if (this._canvas_initializing) {
            // at init time only, ensure we report a non-zero delta as we resolve our
            // percentage size to a pixel size.  We are effectively going from an
            // unknown to a known size, so we want to trigger all logic associated
            // with size change.  Subsequently, a percent size widget reports normal deltas.
            currentValue = this[propertyName] = 0;

            if (this.percentBox == "custom") this[propertyName] = 1;
        }

        // "custom" percentBox - assume the parent will apply some custom logic to size / position
        // this child so suppress the standard handling
        if (this.percentBox == "custom") return 0;

        // get the relevant full size
        // this is the page width/height if this canvas has no parents, or
        // the parent element's inner width/height, otherwise
        var parent, fullSize, insideParent,
            horizontal = (name == this._$left || name == this._$width);
        // viewport vs outer size determined by percentBox setting
        if (this.percentSource || (this.snapTo && this.masterElement)) {
            parent = this.percentSource || this.masterElement;
            insideParent = (this.percentBox == this._$viewport),
            fullSize = horizontal ? (insideParent ? parent.getViewportWidth()
                                                  : parent.getVisibleWidth())
                                  : (insideParent ? parent.getViewportHeight()
                                                  : parent.getVisibleHeight());
        } else {
            parent = this.parentElement;
            fullSize = (horizontal ? (parent ? parent.getInnerWidth() : isc.Page.getWidth())
                                   : (parent ? parent.getInnerHeight() : isc.Page.getHeight() - this._getPageSpace())
                       );
        }




        // In IE and Chrome we can hit a case where page size is initially reported as
        // zero px. In this case we want to re-calculate top-level widget
        // percentage sizes after page load completes (When page size *is* available)



        //>IE
        if (isc.Browser.isIE && !isc.Page.isLoaded() &&
            ((isc.Page.getWidth() == 0) || (isc.Page.getHeight() == 0)))
        {
            isc.Page.setEvent(
                "load",
                "if(window[" + this.ID + "])" + this.ID + ".pageResize()", isc.Page.FIRE_ONCE
            );
            // set a flag to indicate this special case so we avoid attempting to draw() before
            // we've resized correctly
            this._pendingPageResizeForZeroSize = true;
        } //<IE


        if (isc.Browser.isChrome && (!isc.Page.isLoaded() || isc.EH._handlingEvent == "load") &&
            (isc.Page.getWidth() == 0 || isc.Page.getHeight() == 0))
        {
            if (isc.Page.isLoaded()) {
                isc.Page.setEvent("idle",
                    "if(window." + this.ID + ")" + this.ID + ".pageResize()",
                    isc.Page.FIRE_ONCE);
            } else {
                isc.Page.setEvent("load",
                    "if(window." + this.ID + ")" + this.ID + ".delayCall('pageResize',[],100)",
                    isc.Page.FIRE_ONCE);
            }
            this._pendingPageResizeForZeroSize = true;
        }
        // compute the coord as a percent of that

        newValue = Math.round((parseInt(newValue, 10) / 100) * fullSize);

        // support minWidth / minHeight for percent sizes.
        var min = this[this._minNames[name]];
        if (min != null && newValue < min) {
            newValue = min;
        }
        var max = this[this._maxNames[name]];
        if (max != null && newValue > max) {
            newValue = max;
        }

        //if (name == "height") {
        //    this.logWarn("resolved percent height ["+ this[percentName]+ "] to: " + newValue +
        //                 ", parent height: " + fullSize + ", currentValue: " + currentValue);
        //}
        return newValue - currentValue;
    }

    // handle coordinates specified as strings.  Even though we document this as incorrect, it's
    // really easy to forget if you work in XML.
    var origNewValue = newValue;
    if (!isc.isA.Number(newValue)) {
        newValue = parseInt(newValue);
        // if we parsed the newValue and got a valid number, and this is init time
        // (currentValue is a string, which can never happen after init), change the saved
        // value to the numeric version.
        if (isc.isA.Number(newValue) && isc.isA.String(currentValue)) {
            this[propertyName] = currentValue = newValue;
        }
    }

    // clear any previously defined percent size -- this is either a valid numeric size, or an
    // invalid value, in which case we'll revert to default size.
    this[percentName] = null;

    // complain about bad coordinates.
    if (!isc.isA.Number(newValue) ||
        (newValue < 0 && (name == this._$width || name == this._$height)))
    {
        var layoutSetSize = false;

        // HACK: avoid complaining about "*", which is valid within a Layout, and which can be
        // treated as the absence of a value.
        if (origNewValue != "*") {
            //>DEBUG
            this.logWarn("ignoring bad or negative " + name + ": " + origNewValue +
                         (this.logIsDebugEnabled("sizing") ? this.getStackTrace()
                          : " [enable 'sizing' log for stack trace]")); //<DEBUG
        } else {
            // HACK: setting width/height to "*" after init:
            // - this should mean the same thing "*" does before init, and the Layout normally
            //   picks up the "*" size via _userWidth/Height, since getWidth()/Height() always
            //   return pixels
            // - there is no clear delta value we can report - even if we reverted to default
            //   size there may be no change - so the usual childResized() notification that
            //   causes automatic reflow won't occur.  So we do it manually.
            //this.logWarn("clearing user prop: " + name);
            name == this._$width ? this._userWidth = "*" : this._userHeight = "*";
            var parent = this.parentElement;
            if (isc.isA.Layout(parent) && parent.hasMember(this)) {
                parent.reflow(this.getID() + " set " + name + " to '*'");
                layoutSetSize = true;
            }
        }

        // if the value we were initialized with is bad, remove it, hence reverting to
        // defaults.

        if (!layoutSetSize && (currentValue == this[name] || currentValue == this[propertyName]))
        {
            currentValue = this.restoreDefaultSize(name == this._$height);
        }
        // Fire adjustOverflow to actually resize the handle to the default size, if necessary
        this.adjustOverflow();

        return null;
    }

    //this.logWarn("getDelta: newValue: " + newValue + ", currentValue: " + currentValue);

    return newValue - currentValue;
},

restoreDefaultSize : function (isHeight) {

    var propertyName = isHeight ? this._$height : this._$width,
        instanceDefault = this.getClass().getInstanceProperty(propertyName);

    // use defaultHeight/Width if set
    if (!isc.isA.Number(instanceDefault)) {
        if (isHeight) instanceDefault = this.defaultHeight;
        else instanceDefault = this.defaultWidth;
    }

    var currentValue = this[propertyName] = (isc.isA.Number(instanceDefault) ?
                                             instanceDefault : 0);

    if (isHeight) this._height = currentValue;

    return currentValue;
},

// if we have any percent coordinates, recompute their values
pageResize : function () {
    this._pageResizing = true;
    //this.logWarn("pageResize: resizing to: " + [this._percentWidth, this._percentHeight] + " of " +
    //             [Page.getWidth(), Page.getHeight()] + this.getStackTrace());
    this._resizeID = null;
    // clear out the flag set up for handling the 'showModalDialog' case in IE
    this._pendingPageResizeForZeroSize = null;
    this._resolvePercentageSize();
    delete this._pageResizing;
},

//> @method canvas.moveTo() ([])
// Moves the widget so that its top-left corner is at the specified coordinates.
// <P>
// This method will also accept a single parameter as an object array with left and top given
// as properties.
//
//      @visibility external
//      @group  positioning
//      @param  [left]      (number or Object) x-coordinate to move to in LOCAL coordinates
//                                             or Object with left and top properties.
//      @param  [top]       (number)    y-coordinate to move to in LOCAL coordinates
//      @return (boolean)   whether the component actually moved
//      @example    move
//<
//>Animation
// @param [animating] (boolean) optional internal parameter passed if this moveTo is being
//   called as part of an animation.
//<Animation

moveTo : function (left, top, animating, resizeHandle) {
    if (!resizeHandle && left == null && top == null) return false;
    if (isc._traceMarkers) arguments.__this = this;

    if (left != null && left.top != null) {
        top = left.top;
        left = left.left;
    }

    var deltaX = this.getDelta(this._$left, left, this.getLeft()),
        deltaY = this.getDelta(this._$top, top, this.getTop(true));

    //if (deltaX != 0 || deltaY != 0) {
    //    this.logWarn("moveTo: " + [x,y] + " calling moveBy: " + [deltaX, deltaY] +
    //                 ", top: " + this.getTop() + ", scrollTop: " + this.scrollTop +
    //                 ", left: " + this.getLeft() + ", scrollLeft: " + this.scrollLeft +
    //                 ", using CSS scrolling: " + this.usingCSSScrollbars());
    //}

    // ... and call the moveBy function to do it for us
    return this.moveBy(deltaX, deltaY, animating, resizeHandle);
},


//> @method canvas.moveToEvent()
//          move to the last event location (such as when we're being dragged around)
//      @group  positioning, events
//      @param  [offsetX]       (number)    x-coordinate offset (typically used for drag and drop)
//      @param  [offsetY]       (number)    y-coordinate offset (typically used for drag and drop)
//<
moveToEvent : function (offsetX, offsetY) {

    // get the global coordinates of the event, maintaining the drag offset
    var event = this.ns.EH.getLastEvent(),
        x = event.x,
        y = event.y
    ;

    if (isc.isA.Number(offsetX)) x -= offsetX;
    if (isc.isA.Number(offsetY)) y -= offsetY;
    // Snap-to-grid

    var EH = this.ns.EH;
    var snapChild = EH.getDragTarget(event);
    var snapParent;
    if (EH.getDragTarget().canDrop) {
        snapParent = EH.getDropTarget(event);
        if (snapParent) {

            if ( ! snapChild.snapOnDrop || ! snapParent.shouldSnapOnDrop(snapChild) ) {
                snapParent = null;  // Effectively switches off snap-to-grid
            }
        } else {
            snapParent = EH.getDragTarget(event).parentElement;
        }
    } else {
        snapParent = EH.getDragTarget(event).parentElement;
    }

    var snapToChild = snapChild.snapToGrid,
        alignToChild = snapChild.snapToAlign,
        snapToParent = (snapParent ? snapParent.childrenSnapToGrid : null),
        alignToParent = (snapParent ? snapParent.childrenSnapAlign : null)
    ;

    //>EditMode
    if (snapChild.editingOn && snapChild.editProxy) snapToChild = snapChild.editProxy.snapToGrid || snapToChild;
    if (snapParent && snapParent.editingOn && snapParent.editProxy) {
        snapToParent = snapParent.editProxy.willAcceptDrop() && (snapParent.editProxy.childrenSnapToGrid || snapToParent);
    }

    if (snapChild.editingOn && snapChild.editProxy) alignToChild = snapChild.editProxy.snapToAlign || alignToChild;
    if (snapParent && snapParent.editingOn && snapParent.editProxy) {
        snapParent.editProxy.willAcceptDrop() && (alignToParent = snapParent.editProxy.childrenSnapAlign || alignToParent);
    }


    if (snapParent && snapParent.editingOn && isc.isA.Canvas(snapParent) &&
            snapToChild != true && snapToParent != true &&
            snapParent.editProxy &&
            (!snapParent.editProxy.canAdd(snapChild.getClassName()) || !snapParent.editProxy.willAcceptDrop()) &&
            snapParent.parentElement)
    {
        if (snapParent.parentElement.containsPoint(event.x, event.y) && snapParent.parentElement.childrenSnapToGrid) {
            snapParent = snapParent.parentElement;
            snapToParent = snapParent.childrenSnapToGrid;
            if (snapParent && snapParent.editingOn && snapParent.editProxy) snapToParent = snapParent.editProxy.childrenSnapToGrid || snapToParent;
        }
    }
    //<EditMode

    var checkAlignment = snapToChild || alignToChild || snapToParent || alignToParent;

    // Parentless canvases cannot participate in snap-to-grid
    if (isc.isA.Canvas(snapParent) && checkAlignment) {

        // Support suppressing the drag offset.
        // This is used in GridRenderer where we want the drag child to snap to whatever
        // cell the mouse is regardless of original drag offset
        if (snapParent.noSnapDragOffset(this)) {
            x = event.x,
            y = event.y
        }
        // allow snapOffsets to be individually disabled by axis.
        // useful in calendar.timelineView drag and drop
        if (snapParent.suppressHSnapOffset == true) x = event.x;
        if (snapParent.suppressVSnapOffset == true) y = event.y;

        if (snapParent.snapAxis == isc.Canvas.HORIZONTAL ||
            snapParent.snapAxis == isc.Canvas.BOTH)
        {
            var snapParentContentOffset =
                (snapParent.getPageLeft() + snapParent.getLeftBorderSize() +
                  snapParent.getLeftMargin() - snapParent.getScrollLeft());

            x -= snapParentContentOffset;

            var snapCoordinate = x,
                snapLineDefault = snapParent.getHSnapPosition(x);

            if ((snapToParent || snapToChild) && !event.shiftKey) {
                snapCoordinate = snapLineDefault + snapParent.getHSnapOrigin(snapChild);
            }

            // if we find that we can snap to an eligible component before we reach the
            // default snap line, show the line and override the snap coordinate
            if (alignToParent || alignToChild) {

                var snapLineMarker = snapParent._getHSnapAlignMarker(snapChild, x);
                if (snapLineMarker) {
                    if (snapLineMarker.snapCoordinate.isBetween(x, snapLineDefault, true)) {

                        snapLineMarker.show();
                        snapCoordinate = snapLineMarker.snapCoordinate + snapParent.getHSnapOrigin(snapChild);

                    } else {
                        snapLineMarker.hide();
                    }
                }
            }

            x = snapCoordinate + snapParentContentOffset;
        }

        if (snapParent.snapAxis == isc.Canvas.VERTICAL ||
            snapParent.snapAxis == isc.Canvas.BOTH)
        {
            var snapParentContentOffset =
                 (snapParent.getPageTop() + snapParent.getTopBorderSize() +
                  snapParent.getTopMargin() - snapParent.getScrollTop());

            y -= snapParentContentOffset;

            var snapCoordinate = y,
                snapLineDefault = snapParent.getVSnapPosition(y);

            if ((snapToParent || snapToChild) && !event.shiftKey) {
                snapCoordinate = snapLineDefault + snapParent.getVSnapOrigin(snapChild);
            }

            if (alignToParent || alignToChild) {

                var snapLineMarker = snapParent._getVSnapAlignMarker(snapChild, y);
                if (snapLineMarker) {
                    if (snapLineMarker.snapCoordinate.isBetween(y, snapLineDefault, true)) {

                        snapLineMarker.show();
                        snapCoordinate = snapLineMarker.snapCoordinate + snapParent.getVSnapOrigin(snapChild);

                    } else {
                        snapLineMarker.hide();
                    }
                }
            }

            y = snapCoordinate + snapParentContentOffset;
        }
    }

    // x/y is where we want to move to in global coordinates, so use setPageRect
    // (Don't pass in width and height - will just move to page coordinates)
    this.setPageRect(  x, y );
},

//> @method canvas.getVSnapOrigin()
// Get an offset to be used when calculating snap positioning. Returns 0 by default.
//
// @param [snapChild] (Canvas) the child that is being snapped
// @return (int) The offset to use when snapping
//
// @group positioning
// @see canvas.getVSnapPosition
// @visibility external
//<
getVSnapOrigin : function (snapChild) {
    return this.VSnapOrigin ? this.VSnapOrigin : 0;
},

//> @method canvas.getHSnapOrigin()
// Get an offset to be used when calculating snap positioning. Returns 0 by default.
//
// @param [snapChild] (Canvas) the child that is being snapped
// @return (int) The offset to use when snapping
//
// @group positioning
// @see canvas.getHSnapPosition
// @visibility external
//<
getHSnapOrigin : function (snapChild) {
    return this.HSnapOrigin ? this.HSnapOrigin : 0;
},

//> @method canvas.placeNextTo()
//  Move this canvas so that it is directly next to another canvas, unless that would cause
//  this canvas to extend beyond the browser window in some direction, in which case this
//  canvas should be placed such that it doesn't extend beyond the browser viewport.
//      @group  positioning, events
//      @param  otherWidget (Canvas)    Canvas to move next to
//      @param  [side]  (string)    Which side of the other canvas should we put. Options are
//                                  "top", "bottom", "left", "right". (Defaults to "bottom")
//      @param  [canOcclude]    (boolean)
//          This property controls whether this canvas can be positioned on top of the other
//          widget if there isn't room to put it next to the other widget without going off
//          screen.<br>
//          If 'canOcclude' is true, simply shift this widget over the other widget, so that
//          it ends up onscreen.  If 'canOcclude' is false, avoid extending offscreen
//          by positioning this widget on the other side of the other widget.
//      @param  [otherAxisAlign]    (string)    Can be one of "left", "right", "outside-left",
//                                          "outside-right", "top", "bottom", "outside-top",
//                                          "outside-bottom". (Defaults to "left" if side is
//                                          "top" or "bottom", "top" if side is "left" or
//                                          "right").<br>
//                                          This property determines how this widget will be
//                                          aligned with the other widget on the other axis.
//<
placeNextTo : function (otherWidget, side, canOcclude, otherAxisAlign) {
    // Pick up defaults for side, canOcclude, otherAxisAlign from _placeRect
    var adjacentRect = otherWidget.getPeerRect(),
        thisRect = this.getPeerRect(),
        pos = isc.Canvas._placeRect(
                thisRect[2], thisRect[3],
                adjacentRect, side, canOcclude, otherAxisAlign
              )
    ;

    this.setPageRect(pos[0], pos[1]);
},

//> @method canvas.showNextTo()
// Show this widget next to another widget on the page, positioned such that it will
// not extend beyond the browser viewport.
// <P>
// Note that this method simply sets the coordinates of the widget and displays it (using
// a +link{canvas.animateShow()} by default). It will
// not change the +link{canvas.parentElement} of either component.
// <P>
// An example use case might be showing a menu next to a menu-button.
//
// @param otherWidget (Canvas) Canvas to show next to
// @param [side] (string) Which side of the other canvas should we put. Options are
//                                  "top", "bottom", "left", "right". (Defaults to "right")
// @param [canOcclude] (boolean)
//  This argument controls whether this canvas can be positioned on top of the other
//  widget if there isn't room to put it next to the other widget extending out of the
//  browser viewport<br>
//  If 'canOcclude' is true, simply shift this widget over the other widget, so that
//  it ends up onscreen.  If 'canOcclude' is false, avoid extending offscreen
//  by positioning this widget on the other side of the other widget.
// @param [skipAnimation] (boolean) If <code>false</code> do not use an animation to
//  show the component.
//
// @visibility external
//<
showNextTo : function (otherWidget, side, canOcclude, skipAnimation) {
    if (side == null) side = "right";
    if (canOcclude == null) canOcclude = false;
    this.placeNextTo(otherWidget, side, canOcclude);
    if (skipAnimation) {
        // For top level widgets, "show()" also draws
        // Not so for widgets embedded in an already drawn parent - explicitly
        // call draw() as well as show so we pop up on the page in either case.
        if (!this.parentElement || this.parentElement.isDrawn()) {
            this.draw();
        }
        if (!this.isVisible()) this.show();

    } else {
        this.animateShow("fade");
    }
},

//> @method canvas.placeNear()
// Move this canvas to the specified point, or as close to the specified point as possible
// without this widget extending beyond the edge of the browser viewport on any side.
// @param [left] (number) Left coordinate (defaults to mouse position)
// @param [top] (number) Top coordinate (defaults to mouse position)
// @group positioning, events
// @visibility external
//<
placeNear : function (left, top) {
    if (isc.isAn.Array(left)) {
        top = left[1]; left = left[0];
    } else if (isc.isAn.Object(left)) {
        top = left.top; left = left.left;
    }

    // If we're currently hidden, the shadow will be sized small and offscreen
    // force it to fit to master before measuring the peer-rect so we dont shove it offscreen
    // and generate unnecessary scrollbars
    if (this.showShadow && this._shadow) this.updateShadow();
    var thisRect = this.getPeerRect(),
        pos = isc.Canvas._placeRect(
                    thisRect[2], thisRect[3], {left:left, top:top}
              );
    this.setPageRect(pos[0], pos[1]);
},



// Resizing
// --------------------------------------------------------------------------------------------

//> @method canvas.resizeBy()   ([])
//          Resizes the widget, adding deltaX to its width and deltaY to its height (moves the right
//          and/or bottom sides of the widget).
//      @group  sizing
//      @param  [deltaX]    (number)    amount to resize horizontally (may be negative)
//      @param  [deltaY]    (number)    amount to resize vertically (may be negative)
//      @return (Boolean)   whether the component actually changed size
//      @visibility external
//      @example    resize
//<
// @param [animating] (boolean) Internal optional parameter indicating that this resize is
//  occurring as part of an animation
// @param [suppressHandleUpdate] (boolean) If passed avoid actually updating the handle
resizeBy : function (deltaX, deltaY, animating, suppressHandleUpdate, reason) {
    if (isc._traceMarkers) arguments.__this = this;

    //>Animation
    // If an external resizeBy is called during an animated setRect, finish the animated setRect
    // before starting the explicit resize.
    // Note: setRect will pass the suppressHandleUpdate param
    var setRectAnimating = animating && suppressHandleUpdate;
    if (!setRectAnimating && this.rectAnimation) this.finishAnimation("rect");
    if (!animating) {
        // If we're doing a setRect animation, kill any running resizeAnimation
        if (setRectAnimating && this.resizeAnimation) this.finishAnimation("resize");
        // animated show / hide also do a resize.
        if (this.hideAnimation) this.finishAnimation("hide");
        if (this.showAnimation) this.finishAnimation("show");
    }
    //<Animation



    var oldWidth = this.getWidth(), oldHeight = this.getHeight();
    // adjust width and height by the values passed in

    if (isc.isA.Number(deltaX)) {
        this.width += deltaX;
        // set a marker for Layouts (not yet used)
        if (!this._canvas_initializing) this._widthSetAfterInit = true;
    } else {
        deltaX = 0;
    }

    if (isc.isA.Number(deltaY)) {

        this.height = this._height = oldHeight + deltaY;
        // set a marker for Layouts (not yet used)
        if (!this._canvas_initializing) this._heightSetAfterInit = true;
    } else {
        deltaY = 0;
    }

    // no-op.  This is very important as generally most Canvii redraw if they are resized, and
    // layout code is very likely to blindly call resizeTo() in no-op situations.
    // NOTE: it's possible to fool a Canvas into not resizing when it needs to resize, by
    // setting the width/height properties directly without calling setters, then calling a
    // move/resize function with the current values, which causes the Canvas to believe there
    // has been no change in size.  This just means that you really have to call the setter
    // functions, as it's critical to be able to no-op here!
    if (deltaX == 0 && deltaY == 0) return false;

    // Store the delta's locally - used by _completeResizeBy
    // - will be cleared out when we actually resize the handle.
    this._resizeDeltaX = deltaX;
    this._resizeDeltaY = deltaY;

    // Also store whether we're animating or not - required by completeResizeBy
    this._resizeAnimating = animating;

    if (this.isDrawn() && this.logIsInfoEnabled(this._$resize)) {
        this.logInfo("resize of drawn component: " +
                     "new width/height: " + [this.width, this._height] +
                     ", old width/height: " + [oldWidth, oldHeight] +
                     ", delta width/height: " + [deltaX, deltaY] +
                     (this.logIsDebugEnabled(this._$resize) ?
                      this.getStackTrace() : ""), this._$resize);
    }

    // we don't fire resized() if suppressHandleUpdate is true - this will be called from from
    // moveBy()
    // This ensures that when resized() is fired the handle has actually been resized.

    if (!suppressHandleUpdate) {

        // if we have a clip region set, it will have been clobbered by _setHandleRect.
        // restore it:
        // Note: since we're resizing from the top left (bottom / right will 'move'), adjust
        // those coords of the clip by the amount we've resized.
        var clip = this._clip;
        if (isc.isAn.Array(clip)) {
            clip[1] += deltaX;
            clip[2] += deltaY;
        }

        var drawnState = this.getDrawnState();
        if (drawnState == isc.Canvas.COMPLETE) {
            // actually resize the handle by calling _setHandleRect
            this._setHandleRect(this.left, this.top, this.width, this._height);

            if (isc.isAn.Array(clip)) this.setClip(clip);

        // If we've already got our tag start but haven't finished drawing, when we write it out
        // the handle will be the wrong size.
        // Set a flag so that when we *are* done drawing we resize our handle before adjusting
        // overflow
        } else if (drawnState != isc.Canvas.UNDRAWN) {
            this._resizeHandleOnDrawComplete = true;
        }
        this._completeResizeBy(reason);
    }

    // return true indicating that a resize actually occurred (as opposed to a no-op of staying
    // the same size)
    return true;
},

_$resized: "resized",
_completeResizeBy : function (reason) {
    var deltaX = (this._resizeDeltaX || 0),
        deltaY = (this._resizeDeltaY || 0),
        animating = this._resizeAnimating,
        undef;

    this._resizeDeltaX = undef;
    this._resizeDeltaY = undef;
    this._resizeAnimating = undef;

    // Bail if the delta is zero or null

    if (!deltaX && !deltaY) return;

    var redrawOnResize;
    if (this.isDrawn()) {
        // check if we're supposed to redraw on resize

        redrawOnResize = this.shouldRedrawOnResize(deltaX, deltaY, animating);
        // if we're supposed to redraw when resized, mark for a redraw
        if (redrawOnResize) {
            //if (this.isDrawn()) {
            //    this.logWarn("redrawing due to resize: " +
            //                 "old width/height: " + [oldWidth, oldHeight] +
            //                 ", delta width/height: " + [deltaX, deltaY]);
            //}
            this.markForRedraw(this._$resize);
        }
    }

    // run layout code to resize children, if any.  Note this needs to happen before we
    // adjustOverflow.
    if (!animating) this.layoutChildren(this._$resized, deltaX, deltaY)

    if ((isc.Browser.isMoz || isc.Browser.isSafari) && this.containsIFrame()) this._sizeIFrame();


    this._handleResized(deltaX, deltaY);

    // if we're not going to redraw, which would adjust overflow automatically, we need to adjust
    // now.
    if (!redrawOnResize) this.adjustOverflow(this._$resize);

    //>FocusProxy
    // If we're showing a focus proxy, resize it to match our new (specified) size, so that
    // when the user tabs into the focus proxy, the whole widget gets scrolled into view.

    if (!animating && this._useFocusProxy && this._hasFocusProxy) {
        var fp = this._getFocusProxyHandle();
        if (fp != null) {
            fp.style.width = this.getWidth() + isc.px;
            fp.style.height = this.getHeight() + isc.px;
        }
    }
    //<FocusProxy

    // tell our peers to resize as well
    this.resizePeersBy(deltaX, deltaY);
    // call the observable resized method
    this._resized(deltaX, deltaY, reason);
},

shouldRedrawOnResize : function (deltaX, deltaY) {
    var redrawOnResize = this.redrawOnResize;
    if (redrawOnResize == null) {


        // this Canvas doesn't need to redraw if..
        redrawOnResize = !(
            // it's a parent with no content
            (this.children != null && this.children.length > 0 &&
             !this.allowContentAndChildren) ||
            // contents are static: getInnerHTML has not been overridden, this.contents has not
            // been set to a function
            (this.getInnerHTML == isc.Canvas._instancePrototype.getInnerHTML &&
             !isc.isA.Function(this.contents)));
    }
    return redrawOnResize;
},

//> @method canvas.dragResizing()
// Returns true if this widget is currently being drag-resized.
//<
dragResizing : function () {
    var EH = isc.EH;
    return (EH.dragging && EH.dragOperation == EH.DRAG_RESIZE && EH.dragTarget==this);
},


// _resized() - calls public, observable resized() method.
_resized : function (deltaX, deltaY, reason) {
    if (isc._traceMarkers) arguments.__this = this;
//!DONTOBFUSCATE  (we want observers to be able to pick up the passed values)

    // rerun snapTo positioning for cases where size affects positioning (eg snapTo:"R")
    if (this.snapTo) this._resolvePercentageSize(true);

    // fire up/down chain parent/child master/peer notifications
    if (this.parentElement) this.parentElement.childResized(this, deltaX, deltaY, reason);
    if (this.masterElement) this.masterElement.peerResized(this, deltaX, deltaY, reason);

    var peers = this.peers;
    if (peers) {
        for (var i = 0; i < peers.length; i++) {
            if (isc.isA.Canvas(peers[i])) peers[i].masterResized(deltaX, deltaY, reason);
        }
    }



    //>CornerClips
    // Also checking for this._cornerClips because Canvas.init() calls resizeTo() before corner
    // clips are created.
    if (this.clipCorners && this._cornerClips) {
        var clips = this._cornerClips;
        if (clips.TR) clips.TR.moveBy(deltaX, null);
        if (clips.BL) clips.BL.moveBy(null, deltaY);
        if (clips.BR) clips.BR.moveBy(deltaX, deltaY);
    }
    //<CornerClips

    //>DragScrolling
    // Kill any cached drag-scrolling thresholds resolved from percentages to pixel values -
    // these will have to be recalculated as percentage of the new viewport size. Done lazily
    // on drag scrolling in handleDropMove()

    if (this._hDragScrollThreshold != null) delete this._hDragScrollThreshold;
    if (this._vDragScrollThreshold != null) delete this._vDragScrollThreshold;
    //<DragScrolling

    this.resized(deltaX, deltaY, reason);


    // when a top level element is moved or resized it can introduce page level scrollbars, changing
    // the browser window size overall.
    // We don't get a resized event notification from the browser on this, so explicitly run the
    // _pageResize() method
    // Note that childResized() may cause a parent to resize as part of adjustOverflow but in that
    // case '_resized()' is still fired on the parent so no need for an additional check in
    // the childResized() method.
    if (!this._pageResizing && this.isDrawn() && this.parentElement == null
        && !isc.Page.pollPageSize)
    {
        isc.EH.fireOnPause("checkForBodyOverflowChange",
                            {target:isc.Canvas, methodName:"checkForPageResize"},
                            100);
    }
},

_handleResized : function () {},

//> @method   canvas.resized()
//  Observable method called whenever a Canvas changes size. Note that if this canvas is
// +link{canvas.overflow,overflow:"visible"}, and is waiting for a queued redraw (see
// +link{canvas.isDirty()}), the value for +link{canvas.getVisibleWidth()} and
// +link{canvas.getVisibleHeight()} will be unreliable until <code>redraw()</code> fires.
// @visibility external
//<

resized : function (deltaX, deltaY) {},

// Fired when the viewport size changes but not the overall widget size
// Used to resize children and peers with snapTo:true and percent sizing
// Also resizes widgets for which this is the percentSource - handled by observation
innerSizeChanged : function (reason) {


    this._childrenCoordsChanged();

    this.layoutChildren(reason);
    var peers = this.peers;
    if (peers) {
        for (var i = 0; i < peers.length; i++) {
            if (!peers[i].percentSource && peers[i].snapTo &&
                peers[i].percentBox == this._$viewport
               )
           {
               peers[i]._resolvePercentageSize();
           }
        }
    }
},

//> @method canvas.setPercentSource() [A]
// Setter method for the +link{canvas.percentSource,percentSource} attribute.
// @parameter [sourceWidget] (Canvas) New percent source (if omitted existing
//                                      percentSource will just be cleared).
// @visibility external
// @group sizing
//<
setPercentSource : function (sourceWidget, initTime) {

    if (isc.isA.String(sourceWidget)) sourceWidget = window[sourceWidget];
    if (!initTime && this.percentSource == sourceWidget) return;

    if (this.percentSource && this.isObserving(this.percentSource, "innerSizeChanged")) {
        this.ignore(this.percentSource, "innerSizeChanged");
        this.ignore(this.percentSource, "resized");
    }

    if (!isc.isA.Canvas(sourceWidget)) {
        this.percentSource = null;
        return;
    }
    this.percentSource = sourceWidget;
    this.observe(sourceWidget, "innerSizeChanged", "observer.percentSourceInnerSizeChanged()");
    this.observe(sourceWidget, "resized", "observer._resolvePercentageSize()");
},

percentSourceInnerSizeChanged : function () {
    if (this.percentBox == this._$viewport) this._resolvePercentageSize();
},

// If an overflow:VISIBLE child resets its handle for adjust overflow
// (IE shrinks to specified size, then resizes to drawn size), it may impact our scroll
// position natively as the scrollWidth/scrollHeight may change.
// Remember the scroll position before this occurs, and then reset to it after adjustOverflow
// finishes resizing the child handle to its final size.

childResettingHandleForAdjustOverflow : function () {
    if (this.oveflow == isc.Canvas.VISIBLE) {
        if (this.parentElement) this.parentElement.childResettingHandleForAdjustOverflow();
    } else {
        this._scrollLeftBeforeChildReset = this.getScrollLeft();
        this._scrollTopBeforeChildReset = this.getScrollTop();
    }
},
childResetHandleForAdjustOverflowComplete : function () {
    if (this.overflow != isc.Canvas.VISIBLE) {
        this.scrollTo(this._scrollLeftBeforeChildReset, this._scrollTopBeforeChildReset);
        this._scrollLeftBeforeChildReset = this._scrollTopBeforeChildReset = null;
    }
},

_$childResized : "childResized",
childResized : function (child, deltaX, deltaY, reason) {

    // Always ignore the componentMask, whose size is driven entirely by us
    if (child == this.componentMask) return;

    //>EditMode
    if (this.editingOn && this.editContext) {
        this.editContext.saveCoordinates(child);
    }
    //<EditMode

    // if a child changes size, the size of our content has changed, so adjustOverflow.  For
    // example, we may need to grow/shrink to fit (overflow:visible), or show or hide scrollbars
    // (overflow:auto).


    if (this.allowContentAndChildren && this.overflow == isc.Canvas.VISIBLE)
        this._resetHandleOnAdjustOverflow = true;
    this._markForAdjustOverflow(this._$childResized);
    //this.logWarn("child resize: " + this.getStackTrace());
},

peerResized : function (peer, deltaX, deltaY, reason) { },

masterResized : function (deltaX, deltaY, reason) {
    this._resolvePercentageSize();
},

//> @method canvas.dragResized()    (A)
// Observable function fired once at the end of a successful drag-resize operation.
// Useful for firing some action in response to resize without firing repeatedly on every
// dragMove while the user is drag-resizing the target.
//<
dragResized : function () {},


//> @method canvas.resizePeersBy()  (A)
//          resize any peers by the amounts specified, if we have any
//      @group  sizing
//      @param  deltaX      (number)    amount to resize horizontally (may be negative)
//      @param  deltaY      (number)    amount to resize vertically (may be negative)
//<
resizePeersBy : function (deltaX, deltaY) {

    var peers = this.peers;
    if (peers) {
        for (var i = 0; i < peers.length; i++) {
            // Avoid resizing the peer in the case where we haven't yet assigned its
            // "masterElement" link - this can happen if we were initialized with peers - in this
            // case we don't want to resize them until we've had time to set up (for example) the
            // snapToEdge stuff.
            if (peers[i] && peers[i].masterElement == this && peers[i]._resizeWithMaster) {
                peers[i].resizeBy(deltaX, deltaY);
            }
        }
    }
},


//> @method canvas.layoutChildren() ([A])
//
// <code>layoutChildren()</code> is where a Canvas should implement a sizing policy for it's
// Canvas children.  Since <code>layoutChildren</code> calls parentResized() on its children,
// +link{Canvas.parentResized} is a good place for a child to implement a layout policy that
// can be used within any parent.
// <P>
// Recommended practice for a Canvas that manages Canvas children is to create those children
// without any initial coordinate or size settings and do all sizing when layoutChildren() is
// called.
// <P>
// layoutChildren() is always called at least once before children are drawn, and is called
// automatically whenever the viewport size changes (which includes both resizing and
// introduction/removal of scrolling).  layoutChildren() can also be manually invoked in any
// other component-specific situation which changes the layout.
// <P>
// NOTE: layoutChildren() may be called before draw() if a widget is resized before draw(), so
// be sure to avoid errors such as assuming that any children you automatically create have
// already been created.
// <P>
// NOTE: auto-sizing: layoutChildren() is also called once during the initial draw(), before
// children are drawn, with a "reason" of "initial draw".  During this invocation of
// layoutChildren() it is legal to directly draw children (call child.draw()), which is
// otherwise never allowed.  This allows a Canvas to implement an auto-sizing layout policy by
// drawing some children before deciding on the sizes of remaining children, which is far more
// efficient than drawing all children and resizing some of them after they are drawn.
// @param reason (string) reason why layoutChildren() is being called, passed when framework
//                        code invokes layoutChildren()
//
//  @visibility external
//  @group  sizing
//<
layoutChildren : function (reason, deltaX, deltaY) {
    if (this.children) this._resolveChildPercentSizes();
},

// tell any percent-size children to update size
_resolveChildPercentSizes : function () {
    var children = this.children;
    if (children != null && children.length > 0) {
        for (var i = 0; i < children.length; i++) {
            if (isc.isA.Canvas(children[i])) children[i].parentResized();
        }
    }
},

_equalsCurrentSize : function (width, height) {
    return (width  == null || this.getDelta(this._$width,  width,  this.getWidth ()) == 0) &&
           (height == null || this.getDelta(this._$height, height, this.getHeight()) == 0);
},

//> @method canvas.resizeTo()   ([])
//          Resizes the widget to the specified width and height (moves the right and/ or bottom
//          sides of the widget). The width and height parameters can be expressed as a percentage
//          of viewport size or as the number of pixels.
//      @group  sizing
//      @param  [width]     (number)    new width for canvas.
//      @param  [height]    (number)    new height for canvas
//      @return (Boolean) whether the size actually changed
//      @visibility external
//      @example    resize
//<
// @param [animating] (boolean) optional internal param passed if this is a resize occurring as
// part of an animation
// @param [suppressHandleUpdate] (boolean) If passed avoid actually updating the handle
resizeTo : function (width, height, animating, suppressHandleUpdate, reason) {
    if (isc._traceMarkers) arguments.__this = this;

    if (width == null && height == null) return false;

    var deltaX = this.getDelta(this._$width, width, this.getWidth()),
        deltaY = this.getDelta(this._$height, height, this.getHeight());
    // now call resizeBy to do the work for us
    return this.resizeBy(deltaX, deltaY, animating, suppressHandleUpdate, reason);
},

//> @method canvas.resizeToEvent()
//      Resize according to an event, such as when resizing in a drag.
//      Uses isc.EventHandler.lastEvent for the event coordinates.
//
//      @group  sizing, events
//      @param  resizeEdge      (string)    Edge or corner to resize (eg: "T" or "BR", etc).
//<
resizeToEvent : function (resizeEdge) {
    var EH = this.ns.EH,
        event = EH.getLastEvent(),
        x = event.x,
        y = event.y,
        left0 = this.getPageLeft(),
        left = left0,
        top0 = this.getPageTop(),
        top = top0,
        right0 = this.getPageRight(),
        right = right0,
        bottom0 = this.getPageBottom(),
        bottom = bottom0,
        visibleWidth0 = this.getVisibleWidth(),
        visibleHeight0 = this.getVisibleHeight();

    // Snap-to-grid - adjust x/y to grid as required, before validity checks

    var snapChild = EH.getDragTarget(event);

    var snapParent = snapChild.parentElement || snapChild._parentElement;

    // Parentless canvases cannot participate in snap-to-grid
    if (snapParent) {

        var snapToChild = snapChild.snapResizeToGrid == true
            || (snapChild.snapResizeToGrid == null && snapChild.snapToGrid == true);

        var alignToChild = snapChild.resizeSnapAlign
            || (snapChild.resizeSnapAlign == null && snapToChild);

        var snapToParent = snapChild.snapResizeToGrid == null
            && (snapParent.childrenSnapResizeToGrid == true
                || (snapParent.childrenSnapResizeToGrid == null
                    && snapParent.childrenSnapToGrid == true)
            )
        ;

        var alignToParent = snapParent.childrenResizeSnapAlign
            || (snapParent.childrenResizeSnapAlign == null && snapToParent);

        //>EditMode
        if (snapChild.editingOn && snapChild.editProxy) snapToChild = snapChild.editProxy.snapToGrid || snapToChild;
        if (snapParent && snapParent.editingOn && snapParent.editProxy) snapToParent = snapParent.editProxy.childrenSnapToGrid || snapToParent;

        if (snapChild.editingOn && snapChild.editProxy) alignToChild = snapChild.editProxy.snapToAlign || alignToChild;
        if (snapParent && snapParent.editingOn && snapParent.editProxy) alignToParent = snapParent.editProxy.childrenSnapAlign || alignToParent;
        //<EditMode

        var checkAlignment = snapToChild || alignToChild || snapToParent || alignToParent;

        if (checkAlignment) {

            if (snapParent.snapAxis == isc.Canvas.HORIZONTAL ||
                snapParent.snapAxis == isc.Canvas.BOTH)
            {
                var snapParentContentOffset =
                    (snapParent.getPageLeft() + snapParent.getLeftBorderSize() +
                      snapParent.getLeftMargin() - snapParent.getScrollLeft());

                x -= snapParentContentOffset;

                var snapCoordinate = x,
                    snapLineDefault = snapParent.getHSnapPosition(x);

                if ((snapToParent || snapToChild) && !event.shiftKey) {
                    snapCoordinate = snapLineDefault + snapParent.getHSnapOrigin(snapChild);
                }

                // if we find that we can snap to an eligible component before we reach the
                // default snap line, show the line and override the snap coordinate
                if (alignToParent || alignToChild) {

                    var snapLineMarker = snapParent._getHSnapAlignMarker(snapChild, x, resizeEdge);
                    if (snapLineMarker) {
                        if (snapLineMarker.snapCoordinate.isBetween(x, snapLineDefault, true)) {

                            snapLineMarker.show();
                            snapCoordinate = snapLineMarker.snapCoordinate + snapParent.getHSnapOrigin(snapChild);

                        } else {
                            snapLineMarker.hide();
                        }
                    }
                }

                x = snapCoordinate + snapParentContentOffset;
            }

            if (snapParent.snapAxis == isc.Canvas.VERTICAL ||
                snapParent.snapAxis == isc.Canvas.BOTH)
            {
                var snapParentContentOffset =
                     (snapParent.getPageTop() + snapParent.getTopBorderSize() +
                      snapParent.getTopMargin() - snapParent.getScrollTop());

                y -= snapParentContentOffset;

                var snapCoordinate = y,
                    snapLineDefault = snapParent.getVSnapPosition(y);

                if ((snapToParent || snapToChild) && !event.shiftKey) {
                    snapCoordinate = snapLineDefault + snapParent.getVSnapOrigin(snapChild);
                }

                if (alignToParent || alignToChild) {

                    var snapLineMarker = snapParent._getVSnapAlignMarker(snapChild, y);
                    if (snapLineMarker) {
                        if (snapLineMarker.snapCoordinate.isBetween(y, snapLineDefault, true)) {

                            snapLineMarker.show();
                            snapCoordinate = snapLineMarker.snapCoordinate + snapParent.getVSnapOrigin(snapChild);

                        } else {
                            snapLineMarker.hide();
                        }
                    }
                }

                y = snapCoordinate + snapParentContentOffset;
            }
        }
    }

    //>DEBUG
    if (this.logIsDebugEnabled("dragResize")) {
        this.logDebug("resizeToEvent: coords: " +
                      isc.Log.echo({x:x, y:y, left:left, top:top, right:right, bottom:bottom}),
                      "dragResize");
    } //<DEBUG

    resizeEdge = resizeEdge || EH.resizeEdge || "BR";

    // for each side participating in the resize, figure out how much it should change,
    // refusing to resize beyond the min/max height and width.

    // top or bottom
    var isOnTop = resizeEdge.contains("T"),
        isOnBottom = !isOnTop && resizeEdge.contains("B");
    if (isOnTop) {
        var height = Math.min(this.maxHeight, Math.max(bottom - y, this.minHeight));
        top = bottom - height;
    } else if (isOnBottom) {
        var height = Math.min(this.maxHeight, Math.max(y - top, this.minHeight));
        bottom = top + height;
    }

    // left or right
    var isOnLeft = resizeEdge.contains("L"),
        isOnRight = !isOnLeft && resizeEdge.contains("R");
    if (isOnLeft) {
        var width = Math.min(this.maxWidth, Math.max(right - x, this.minWidth));
        left = right - width;
    } else if (isOnRight) {
        var width = Math.min(this.maxWidth, Math.max(x - left, this.minWidth));
        right = left + width;
    }

    var newWidth = right - left,
        newHeight = bottom - top;

    // Implement proportional resizing if it is currently enabled.
    var useProportionalResizing = false,
        origWidth = 0, origHeight = 0,
        left1 = 0, top1 = 0, right1 = 0, bottom1 = 0;

    var dragTarget = EH.dragTarget;
    if (dragTarget._useProportionalResizing &&
        // Dragging must be free in two directions for this to make sense.
        (isOnLeft || isOnRight) && (isOnTop || isOnBottom))
    {
        var rect = EH.dragTargetStartRect,
            origWidth = rect[2],
            origHeight = rect[3];

        // This is not well defined if the starting width or height is zero.
        if (origWidth != 0 && origHeight != 0) {
            useProportionalResizing = true;
            left1 = left;
            top1 = top;
            right1 = right;
            bottom1 = bottom;


            if (dragTarget._shouldKeepInParentRect()) {
                var keepInParentRect = dragTarget._getKeepInParentRect(false),
                    parentRectLeft = keepInParentRect[0],
                    parentRectRight = parentRectLeft + keepInParentRect[2],
                    parentRectTop = keepInParentRect[1],
                    parentRectBottom = parentRectTop + keepInParentRect[3];

                if (left < parentRectLeft) {
                    left = parentRectLeft;
                } else if (right > parentRectRight) {
                    right = parentRectRight;
                }
                newWidth = right - left;
                if (top < parentRectTop) {
                    top = parentRectTop;
                } else if (bottom > parentRectBottom) {
                    bottom = parentRectBottom;
                }
                newHeight = bottom - top;
            }

            var minWidth  = dragTarget.getDragMinWidth(),
                minHeight = dragTarget.getDragMinHeight(),
                sx = (newWidth / origWidth),
                sy = (newHeight / origHeight);
            if (sx < sy) {
                var dy = Math.round(newHeight - sx * origHeight);
                if (newHeight - dy < minHeight) {
                    if (dy > 0 && newWidth == Math.round(minHeight * origWidth / origHeight)) {
                        dy = newHeight - minHeight;
                    } else {
                        // Proportional resizing is impossible considering the current
                        // `keepInParentRect` and `minHeight`.
                        return;
                    }
                }
                if (isOnBottom) {
                    bottom -= dy;
                } else {
                    top += dy;
                }
                newHeight = bottom - top;
            } else if (sy < sx) {
                var dx = Math.round(newWidth - sy * origWidth);
                if (newWidth - dx < minWidth) {
                    if (dx > 0 && newHeight == Math.round(minWidth * origHeight / origWidth)) {
                        dx = newWidth - minWidth;
                    } else {
                        // Proportional resizing is impossible considering the current
                        // `keepInParentRect` and `minWidth`.
                        return;
                    }
                }
                if (isOnRight) {
                    right -= dx;
                } else {
                    left += dx;
                }
                newWidth = right - left;
            }
        }
    }

    var resizeOnly = (isOnTop || isOnLeft || useProportionalResizing);
    this.setPageRect(left, top, newWidth, newHeight, resizeOnly);


    if (useProportionalResizing &&

        dragTarget.getDragAppearance(isc.EH.DRAG_RESIZE) != isc.EH.OUTLINE)
    {

        var hasEdges = (this._edgedCanvas != null && !this._edgedCanvas.destroyed);
        if (hasEdges) {
            this._edgedCanvas.fitToMaster();
        }

        var pageLeft = this.getPageLeft(),
            pageTop = this.getPageTop(),
            visibleWidth = this.getVisibleWidth(),
            visibleHeight = this.getVisibleHeight();
        if (left != pageLeft ||
            top != pageTop ||
            newWidth != visibleWidth ||
            newHeight != visibleHeight)
        {
            var minWidth  = Math.max(this.dragMinWidth,  this.minWidth,  visibleWidth),
                minHeight = Math.max(this.dragMinHeight, this.minHeight, visibleHeight);

            left = left1;
            top = top1;
            right = right1;
            bottom = bottom1;
            newWidth = right1 - left1;
            newHeight = bottom1 - top1;

            if (newWidth < minWidth || newHeight < minHeight) {
                this.setPageRect(left0, top0, visibleWidth0, visibleHeight0, resizeOnly);
                if (hasEdges) {
                    this._edgedCanvas.fitToMaster();
                }
                return;
            }

            var sx = (newWidth / origWidth),
                sy = (newHeight / origHeight);
            if (sx < sy) {
                var dy = Math.round(newHeight - sx * origHeight);
                if (newHeight - dy < minHeight) {
                    if (dy > 0 && newWidth == Math.round(minHeight * origWidth / origHeight)) {
                        dy = newHeight - minHeight;
                    } else {
                        // Proportional resizing is impossible considering the current
                        // `keepInParentRect` and `minHeight`.
                        this.setPageRect(left0, top0, right0 - left0, bottom0 - top0, resizeOnly);
                        if (hasEdges) {
                            this._edgedCanvas.fitToMaster();
                        }
                        return;
                    }
                }
                if (isOnBottom) {
                    bottom -= dy;
                } else {
                    top += dy;
                }
                newHeight = bottom - top;
            } else if (sy < sx) {
                var dx = Math.round(newWidth - sy * origWidth);
                if (newWidth - dx < minWidth) {
                    if (dx > 0 && newHeight == Math.round(minWidth * origHeight / origWidth)) {
                        dx = newWidth - minWidth;
                    } else {
                        // Proportional resizing is impossible considering the current
                        // `keepInParentRect` and `minWidth`.
                        this.setPageRect(left0, top0, visibleWidth0, visibleHeight0, resizeOnly);
                        if (hasEdges) {
                            this._edgedCanvas.fitToMaster();
                        }
                        return;
                    }
                }
                if (isOnRight) {
                    right -= dx;
                } else {
                    left += dx;
                }
                newWidth = right - left;
            }

            // Try resizing again.
            this.setPageRect(left, top, newWidth, newHeight, resizeOnly);
        }
    }

    // set EH.dragResizeWidth and EH.dragResizeHeight
    //  so other routines can know how big the resizing thing will be
    EH.dragResizeWidth = newWidth;
    EH.dragResizeHeight = newHeight;

    // HACK: if we're resizing the dragTracker, redraw immediately, this looks MUCH cleaner
    if (this == this.ns.EH.dragTracker) this.redrawIfDirty();
},

_proportionalResizing: "none",
_checkProportionalResizing : function () {
    var oldMode = this._proportionalResizing,
        newMode = this._getProportionalResizing();

    if (oldMode == newMode) {
        return;
    }
    if (oldMode == "none") {
        if (newMode == "always") {
            this._enableProportionalResizing(this);
        } else { // newMode is "modifier" or "modifierOff"
            var modifierOff = (newMode == "modifierOff"),
                downAction = this._enableProportionalResizing,
                upAction = this._disableProportionalResizing;
            if (modifierOff) {
                // The actions are swapped in "modifierOff" mode.
                downAction = this._disableProportionalResizing;
                upAction = this._enableProportionalResizing;
            }

            // In "modifier" mode, enable proportional resizing if the
            // `proportionalResizeModifiers` are currently being pressed.  In "modifierOff"
            // mode, enable proportional resizing if the modifier keys are not being pressed.
            var modifiersDown = isc.Page._modifierKeysDown(this.proportionalResizeModifiers);
            if (modifiersDown != modifierOff) {
                this._enableProportionalResizing(this);
            }

            isc.Page._registerModifierKeys(
                this.proportionalResizeModifiers, isc.Page._OR, downAction, upAction, this);
        }
    } else {
        this._disableProportionalResizing(this);
        if (oldMode != "always") { // oldMode is "modifier" or "modifierOff"
            isc.Page._unregisterModifierKeys(
                this.proportionalResizeModifiers, isc.Page._OR, this);
        }
    }

    // Save the new `proportionalResizing` mode.
    this._proportionalResizing = newMode;
},


_enableProportionalResizing : function (me) {
    if (!me._useProportionalResizing) {
        me._useProportionalResizing = true;
        if (me.dragResizing()) {
            // Call resizeToEvent() again to trigger proportional resizing.
            isc.EH.dragMoveTarget.resizeToEvent(isc.EH.resizeEdge);
        }
    }
},
_disableProportionalResizing : function (me) {
    if (me._useProportionalResizing) {
        me._useProportionalResizing = false;
        if (me.dragResizing()) {
            // Call resizeToEvent() again to trigger regular resizing.
            isc.EH.dragMoveTarget.resizeToEvent(isc.EH.resizeEdge);
        }
    }
},

// Generic interaction for resizing some target widget as we are moved
// ---------------------------------------------------------------------------------------

resizeTarget : function (target, vertical, realTime, offset, ignore, coord, targetAfter) {
    // ignore: number of pixels between targetCoord and coord to ignore for the purposes of
    // this calculation (used for skipping intervening collapsed headers in SectionStack)
    ignore = ignore || 0;
    // offset: drag offset
    offset = offset || 0;

    if (coord == null) coord = vertical ? isc.EH.getY() : isc.EH.getX();
    coord += offset;

    // don't allow to drag the target past the edge of the parent
    // Essentially what we're doing here is keeping the drag-widget (EG splitBar) inside
    // the parent rect
    if (this.parentElement) {
        var parentRect = this.getParentPageRect(),
            maxCoord = vertical ? (parentRect[1] + parentRect[3])
                                : (parentRect[0] + parentRect[2]);
        maxCoord -= vertical ? this.getVisibleHeight() : this.getVisibleWidth();
        if (coord > maxCoord) coord = maxCoord;
    }

    targetAfter = targetAfter != null ? targetAfter : !vertical && this.isRTL();

    var min = vertical ? target.getDragMinHeight() : target.getDragMinWidth(),
        max = vertical ? target.getDragMaxHeight() : target.getDragMaxWidth();

    var targetCoord;
    if (targetAfter) {
        targetCoord = (vertical ? target.getPageBottom() : target.getPageRight())
            // adjust by the resizeBar's thickness since newSize is determined by
            // the right coordinate of the target as compared to the right coordinate of the
            // resizeBar
            - (vertical ? this.getVisibleHeight() : this.getVisibleWidth());
    } else {
        targetCoord = vertical ? target.getPageTop() : target.getPageLeft();
    }


    // determine size implied by the resizeBar's current position
    var newSize = !targetAfter ?
                            // target before us: target is to our left (or top),
                            // newSize is our coord - target's left
                            coord - targetCoord - ignore :
                            // target after us: target is to our right (or bottom),
                            // newSize is target's right - our coord
                            targetCoord - coord - ignore;


    // clamp size to max min
    if (newSize < min) {
        newSize = min;
    } else if (newSize > max) {
        newSize = max;
    }
    // save off targetSize for finishTargetResize()
    this._targetSize = newSize;

    // calculate where the resizeBar should be
    coord = targetCoord + ignore + (targetAfter ? - newSize : newSize);

    if (realTime) {
        // resize the target
        vertical ? target.setHeight(this._targetSize) : target.setWidth(this._targetSize);
    } else {
        // just move this widget
        vertical ? this.setPageTop(coord) : this.setPageLeft(coord);
    }
},

finishTargetResize : function (target, vertical, realTime) {
    if (realTime) return;
    vertical ? target.setHeight(this._targetSize) : target.setWidth(this._targetSize);
},

// ---------------------------------------------------------------------------------------

//> @method canvas.parentResized()
// Fires when the interior size of the parent changes, including parent resize and
// scrollbar introduction or removal.
// <p>
// This method allows a child to implement a layout policy that can be used within any
// parent, such as a Resizer component that always snaps to the parent's
// bottom-right corner.  The default implementation of this method applies a child's
// percent sizes, if any, or implements layout based on the +link{Canvas.snapTo} property
// @group sizing
// @visibility external
//<
parentResized : function () {
    if (isc._traceMarkers) arguments.__this = this;
    this._resolvePercentageSize();
},

// Called on an individual child to tell it to resolve its own percent sizes and/or snapTo
// coordinates.
_resolvePercentageSize : function (positionOnly) {
    // percentBox:"custom" -- assume the percentage sizing / positioning will be explicitly
    // managed by some custom logic
    if (this.snapTo != null && this.percentBox != "custom") {
        // if the child has percent size, need to resize first so that centering logic is correct
        if ((this._percent_width || this._percent_height) && !positionOnly) {
            this.resizeTo(this._percent_width, this._percent_height);
        }
        var target, targetOrigin, insideCoords;
        target = (this.masterElement ? this.masterElement : this.parentElement);
        if (!target) return; // use this info later to implement snapTo page

        isc.Canvas.snapToEdge(target, this.snapTo, this, this.snapEdge);

    }
    // if snapTo was invalid or really is null
    if (this.snapTo == null && !positionOnly) {
        if (this._percent_left || this._percent_top ||
            this._percent_width || this._percent_height)
        {
            this.setRect(this._percent_left, this._percent_top,
                         this._percent_width, this._percent_height);
        }
    }
},

prepareForDragging : function () {
    var EH = this.ns.EH;

    // this would indicate that a child has set itself as the dragTarget, and then
    // prepareForDragging bubbled to this Canvas.  By default, we leave this alone.
    if (EH.dragTarget) return;

    // NOTE: interesting case:
    // - a parent that wants to be drag resizable may have children which are flush with the
    //   parent's edges.  If those children are themselves resizable they will have set
    //   themselves as the dragTarget.  The parent may want to override this.

    var isDraggable = false,
        dragOperation = this.dragOperation;

    //>Touch
    if (isc.Browser.isTouch && this.touchDragOperation != null &&
        EH._handledTouch === EH._touchEventStatus.TOUCH_STARTED)
    {
        // touch-specific drag operation overrides for touch interfaces
        dragOperation = this.touchDragOperation;
    }
    //<Touch

    // use explicit drag operation setting
    if (dragOperation) {
        isDraggable = true;
        EH.dragOperation = dragOperation;

    // if the target can be resized by dragging,
    } else if (this.canDragResize) {
        // see if the cursor is over an edge where this Canvas can be resized
        EH.resizeEdge = this.getEventEdge();

        if (EH.resizeEdge) {
            // built-in drag resizing:
            // - EventHandler will automatically show a resize animation according to
            //   this.dragAppearance, and will permanently resize this Canvas on mouseUp
            // - this Canvas will receive dragResizeStart/Move/Stop events, which bubble to
            //   parents
            isDraggable = true;
            EH.dragOperation = EH.DRAG_RESIZE;
            // if drag appearance is 'tracker', don't resize the tracker to fit the
            // drag operation, just move it as we would with a dragReposition
            var dragResizeAppearance = this.getDragAppearance(EH.DRAG_RESIZE);
            EH.dragMoveAction = (dragResizeAppearance == "tracker") ? EH._moveDragMoveTarget
                                : EH._resizeDragMoveTarget;
        }
    }
    if (!isDraggable) { // not a drag resize..
        if (this.canDragReposition) {
            // built-in drag repositioning
            // - EventHandler will automatically show a move animation according to
            //   this.dragAppearance, and will permanently reposition this Canvas on mouseUp
            // - this Canvas will receive dragRepositionStart/Move/Stop events, which bubble to
            //   parents
            isDraggable = true;
            EH.dragOperation = EH.DRAG_REPOSITION;
            EH.dragMoveAction = EH._moveDragMoveTarget;

        //>Touch In touch interfaces, default scrollable regions to drag scrolling if no
        // specific drag flags have been set.  This means that eg a ListGrid will scroll by
        // default, and will need to show drag handles on records or a similar UI to
        // offer normal drag modes.
        } else if (EH._handledTouch === EH._touchEventStatus.TOUCH_STARTED &&
            (this.hscrollOn || this.vscrollOn) && !this.dragOperation &&
            this.useTouchScrolling != false && !this._usingNativeTouchScrolling())
        {
            // built-in drag scrolling
            // - target will receive dragScrollStart et al, which are implemented on Canvas
            isDraggable = true;
            EH.dragOperation = EH.DRAG_SCROLL;

            // no need to set dragAppearance - we'll handle that in EH
        //<Touch

        } else if (this.canDrag) {
            // generic drag interaction:
            // - EventHandler will show a move animation according to this.dragAppearance
            // - this Canvas will receive dragStart/Move/Stop events, which bubble to parents
            isDraggable = true;
            EH.dragOperation = EH.DRAG;

        // allow drag-scroll with text selection
        // If some other canDrag property is set check that first - that will take
        // precedence over drag-text-selection behavior
        } else if (EH._handledTouch !== EH._touchEventStatus.TOUCH_STARTED && this.canSelectText) {
            isDraggable = true;
            EH.dragOperation = EH.DRAG_SELECT;
            this.dragAppearance = "none";
        }

    }

    // This canvas can designate another Canvas as the object that should be dragged (via the
    // dragTarget property).  This is to support situations where some external widget (such as
    // resize nubs) drives drag and drop behavior for another Canvas.
    // NOTE: dragRelated properties (EH.dragOperation etc) are derived from properties
    // (canDragReposition, etc) on the mouse event target. The delegated dragTarget may not have
    // these drag-related properties set, but will recieve the actual dragRepositionStart etc events.
    // [Example use-case - Window is marked as canDragReposition:true which prevents it being dragged
    // directly - but the label is canDragReposition:true, with dragTarget set causing dragging on
    // the label to issue dragReposition events on the Window]
    if (isDraggable) {
        var dragTarget = this;

        if (EH.dragOperation != EH.DRAG_SELECT && this.dragTarget != null) {
            // if it's a canvas, use it
            if (isc.isA.Canvas(this.dragTarget)) {
                dragTarget = this.dragTarget;
            // if it's the constant 'top' and the target has a topElement, use that
            } else if (this.dragTarget == "top" && this.topElement) {
                dragTarget = this.topElement;
            // if it's the constant 'parent' and the target has a parentElement, use that
            } else if (this.dragTarget == "parent" && this.parentElement)   {
                dragTarget = this.parentElement;
            } else if (this.dragTarget == "creator" && this.creator) {
                dragTarget = this.creator;
            } else if (isc.isA.String(this.dragTarget) &&
                        isc.isA.Canvas(window[this.dragTarget]))
            {
                dragTarget = window[this.dragTarget];
            //>DEBUG
            // otherwise we don't know what to do with it...
            } else {
                this.logWarn('prepareForDragging():  target.dragTarget not understood : ' +
                             this.dragTarget);
            //<DEBUG
            }
        }
        EH.dragTarget = dragTarget;
    }
    // not draggable (all 3 flags false: canDrag, canDragResize, canDragReposition, and
    // not selecting text), so don't
    // set a dragTarget.  NOTE: allow this event to bubble, so parents can override our drag
    // settings.
},

//> @method  Canvas.setDragTracker()
// If +link{canvas.dragAppearance} is set to <code>"tracker"</code>, this method will be called
// (if defined), when the user starts to drag this widget. It is an opportunity to update the
// drag tracker to display something relative to this canvas.  Typical implementation will
// be to call +link{EventHandler.setDragTracker()}, passing in the desired custom tracker HTML
// as a string
// @return  (boolean) Return false to suppress bubbling, and prevent <code>setDragTracker()</code>
//                      from being called on this widget's ancestors.
// @group dragdrop
// @visibility external
// @example dragTracker
//<

// Drag Scrolling
// ---------------------------------------------------------------------------------------
// While the mouse is actually down, the region being scrolled moves 1 to 1 with the movement
// of the mouse.  When the mouse is lifted, "momentum" is calculated and an animation is
// kicked off to continue scrolling.
dragScrollStart : function () {
    // allow a settable target for scrolling, since in eg ListGrid, the ListGrid gets the
    // events but the body is what scrolls
    var dragScrollTarget = this.dragScrollTarget || this;

    // start coordinate of mouse
    this._touchStartX = isc.EH.getX();
    this._touchStartY = isc.EH.getY();
    // start scroll position
    this._scrollStartLeft = dragScrollTarget.scrollLeft || 0;
    this._scrollStartTop = dragScrollTarget.scrollTop || 0;

    // init variables we'll use to detect speed
    this._scrollPriorX = this._scrollLastX = isc.EH.getX();
    this._scrollPriorY = this._scrollLastY = isc.EH.getY();
    this._scrollPriorTS = this._scrollLastTS = isc.timestamp();
},

dragScrollMove : function () {
    var dragScrollTarget = this.dragScrollTarget || this;

    // note: we're "grabbing" the content.  Moving the mouse downward scrolls up.
    var leftDelta = this._touchStartX - isc.EH.getX(),
        topDelta = this._touchStartY - isc.EH.getY();

    //isc.logWarn("scrollStart: " + [this.scrollStartLeft, this.scrollStartTop] +
    //            ", scroll delta: " + [leftDelta, topDelta]);

    // note scrollTo automatically clamps to max
    dragScrollTarget.scrollTo(this._scrollStartLeft + leftDelta,
                              this._scrollStartTop + topDelta,
                              "dragScrollMove");
    if (window.event) window.event.preventDefault();


    this._scrollPriorX = this._scrollLastX;
    this._scrollPriorY = this._scrollLastY;
    this._scrollPriorTS = this._scrollLastTS;
    this._scrollLastX = isc.EH.getX();
    this._scrollLastY = isc.EH.getY();
    this._scrollLastTS = isc.timestamp();

    return false;
},

momentumScrolling: true,
// time to stop scrolling in milliseconds.

momentumScrollTime: 1500,

//> @attr canvas.momentumScrollMinSpeed (double : 200 : IRWA)
// The minimum speed in pixels per second that must be reached for momentum scrolling to kick in.
// This setting only applies to touch-enabled devices.
// @visibility external
//<
momentumScrollMinSpeed: 200,

// meaning in this case: slows slowly, then quickly comes to a stop
momentumScrollAcceleration: "smoothStart",

dragScrollStop : function () {
    if (!this.momentumScrolling) return;


    var elapsed = (this._scrollLastTS - this._scrollPriorTS);

    // we went directly from scrollStart to scrollStop with no scrollMove.  No momentum.
    if (elapsed == 0) return;

    // no move events in the last 100ms, implying motion stopped.  No momentum
    if (isc.timestamp() - this._scrollLastTS > 100) return;

    // speeds in pixels / ms
    var speedX = (this._scrollLastX - this._scrollPriorX) / elapsed,
        speedY = (this._scrollLastY - this._scrollPriorY) / elapsed,
        target = this,
        dragScrollTarget = this.dragScrollTarget || this;

    if (!(isc.isA.DrawPane && isc.isA.DrawPane(dragScrollTarget))) {
        if (!dragScrollTarget.hscrollOn) speedX = 0;
        if (!dragScrollTarget.vscrollOn) speedY = 0;
    }

    if (this.logIsDebugEnabled("dragScroll")) {
        this.logDebug("dragScroll: x/y: " + [this._scrollLastX, this._scrollLastY] +
                     ", last: " + [this._scrollPriorX, this._scrollPriorY] +
                     ", elapsed: " + elapsed + ", speed: " + [speedX, speedY], "dragScroll");
    }

    // if there is insufficient speed in a direction in which scrolling is allowed, exit
    // Convert this.momentumScrollMinSpeed (in [px/sec]) to [px/ms] by dividing by 1000.
    var momentumScrollMinSpeed = this.momentumScrollMinSpeed / 1000;
    if (Math.abs(speedX) < momentumScrollMinSpeed &&
        Math.abs(speedY) < momentumScrollMinSpeed)
    {
        return;
    }

    // record the animation id since a new mouseDown should instantly stop scrolling
    var animationId = this._momentumScrollId = this.registerAnimation(function (ratio) {
        var now = isc.timestamp(),
            elapsed = now - target._scrollLastTS;
        target._scrollLastTS = now;

        var frameSpeedX = speedX * (1 - ratio),
            frameSpeedY = speedY * (1 - ratio);

        var distanceX = Math.round(frameSpeedX * elapsed),
            distanceY = Math.round(frameSpeedY * elapsed);

        if (this.logIsDebugEnabled("dragScroll")) {
            this.logDebug("animating: elapsed: " + elapsed +
                          ", frame speed: " + [frameSpeedX, frameSpeedY] +
                          ", distance: " + [distanceX, distanceY], "dragScroll");
        }

        if (distanceX == 0 && distanceY == 0) target.cancelAnimation(animationId);

        var oldScrollLeft = dragScrollTarget.getScrollLeft(),
            oldScrollTop = dragScrollTarget.getScrollTop();

        dragScrollTarget.scrollTo(dragScrollTarget.getScrollLeft() - distanceX,
                                  dragScrollTarget.getScrollTop() - distanceY,
                                  "dragScrollStop");

        // cancel if we're out of scrollable content
        if (oldScrollLeft == dragScrollTarget.getScrollLeft() &&
            oldScrollTop == dragScrollTarget.getScrollTop())
        {
            target.cancelAnimation(animationId);
            target._momentumScrollId = null;
        }


    },
    this.momentumScrollTime,
    this.momentumScrollAcceleration);

},

// Drop Indicator
// ---------------------------------------------------------------------------------------

// We want to support having a user be shown a "no drop" cursor for a couple of use-cases
// 1) General "no drop" indicator for every target that isn't a valid drop target
//    When a user is dragging a droppable object show the no drop cursor for every widget
//    which is not a valid drop target.
//    Enabled via isc.EH.showNoDropIndicator:true -- default is false
//    Implemented in Canvas.getCurrentCursor()
//
// *Note: We don't currently provide a canvas.showNoDropIndicator flag to override
//  this global setting for particular widgets.
//  There isn't any obvious use case where this is very valuable:
//  - if you want to have global no-drop indicators disabled but show a no-drop indicator
//    for a specific widget you can use dropMove / setCurrentCursor
//  - if you want to have global no-drop indicators it seems unlikely that you would want
//    to disable this for a specific widget which was non-droppable.
//    The one use case similar to this I can think of is that a dev might use have logic
//    within dropOver / dropMove which actually changes the return value of willAcceptDrop
//    but in this case, if the dev called 'setCursor()' within that method the result of
//    getCurrentCursor would change and the correct [drop allowed] cursor would still be
//    displayed.
//  Also implementing showNoDropIndicator optimally isn't as simple as you might think:
//    It's not entirely clear whether we should check the property on the mouse event
//    target ['this' in the scope of getCurrentCursor()], or on the drop target
//    [if there is one], which may be different due to either children or a drag-tracker
//    under the mouse... or loop through the parent-element chain of the widget under the
//    mouse [which isn't the drag tracker, so the potential drop candidate], etc.
//
//
// 2) More fine grained approach where we show the no-drop indicator only for some specific
//    widgets which may accept some drops but not others. For example TreeGrids use this
//    to make it obvious that self-drop within a child folder isn't supported.
//    Enabled by overriding dropMove on the target and showing the user the no drop cursor
//    there.


// shouldShowNoDropIndicator() - called from each mouseMove when the user is dragging
// over this widget and EH.showNoDropIndicator is true.
// Return true if we want the no-drop indicator to show for this widget

shouldShowNoDropIndicator : function () {
    return !this.canAcceptDrop || !this.willAcceptDrop()
},

//> @method Canvas.setNoDropIndicator()
// Display a "not-allowed" cursor when the user drags over this canvas.
// If +link{Canvas.shouldSetNoDropTracker} is <code>true</code> will also replace the current
// drag tracker (if visible) with the +link{Canvas.noDropTracker} image.
// @see Canvas.clearNoDropIndicator()
// @see Canvas.shouldSetNoDropTracker
//<

setNoDropIndicator : function () {

    this._noDropIndicatorSet = true;

    // The actual 'not allowed cursor' will be picked up by getCurrentCursor()
    // This way we don't have to remember the previous cursor and reset to it on
    // clearNoDropIndicator()
    this._updateCursor();

    // If we should show the no-drop tracker image, and the drag-tracker is showing, do this
    // now.

    if (this.shouldSetNoDropTracker && isc.EH.dragTracker && isc.EH.dragTracker.isVisible()) {
        // Remember the current dragTracker content so we can clear if need be

        if (!this._activeDragTracker) this._activeDragTracker = isc.EH.dragTracker.getContents();
        isc.EH.setDragTracker(this.imgHTML(this.noDropTracker));
    }
},

//>@method Canvas.clearNoDropIndicator()
// Stop displaying the "not-allowed" cursor (and special no-drop tracker if appropriate)
// while the user drags over this canvas.
// @see Canvas.setNoDropIndicator()
//<
clearNoDropIndicator : function () {

    if (!this._noDropIndicatorSet) return;
    delete this._noDropIndicatorSet;
    this._updateCursor();

    if (this.shouldSetNoDropTracker && isc.EH.dragTracker) {
        isc.EH.setDragTracker(this._activeDragTracker);
        delete this._activeDragTracker;
    }
},

//> @attr canvas.shouldSetNoDropTracker (boolean : varies by browser : [IRWA])
// When +link{Canvas.setNoDropIndicator()} is called, should we replace the current drag-tracker
// with the +link{canvas.noDropTracker} image?<br>
// By default this property is set to true in Opera only as Safari, Moz and IE all support a native
// <code>"not-allowed"</code> cursor.
// @see canvas.setNoDropIndicator()
//<
// Unsupported last tested on Opera version 9.27
shouldSetNoDropTracker : isc.Browser.isOpera,

//> @attr   Canvas.noDropTracker    (SCImgURL : "[SKIN]/shared/no_drop.png" : [IRWA])
// Image to display as the 'no-drop' drag tracker when +link{shouldSetNoDropTracker} is true
// @see canvas.shouldSetNoDropTracker
//<
noDropTracker:"[SKIN]/shared/no_drop.png",


//>DragScrolling
// When a user is dragging a dragTarget widget over a scrollable widget which will accept drop
// we automatically scroll the canAcceptDrop widget when the mousepointer is close to the
// edge of the viewport.
// Can be disabled by setting 'canDragScroll' to false.

//> @method canvas.shouldDragScroll() [A]
// If this widget is showing scrollbars, and a user drags close to the edge of the viewport,
// should we scroll the viewport in the appropriate direction?
// Returns this.canDragScroll if there are scrollbars, else false.
// @group events
// @group dragdrop
// @visibility external
//<
shouldDragScroll : function () {
    return this.canDragScroll && (this.hscrollOn || this.vscrollOn);
},

// Determine whether the last event occurred in either the top or bottom scroll thresholds
// Returns -1 if the event occurred in the top scroll threshold, so we should scroll up, and
// +1 if the event occurred in the bottom threshold, so we should scroll down (or zero if not
// over either threshold).
_getVDragScrollDirection : function (offsetY) {

    // resolve the max/min scroll increments (typically specified as percentages)
    // to numeric values
    var vDragThreshold = this.getVDragScrollThreshold();

    if (offsetY < vDragThreshold) return -1;
    if (offsetY > (this.getViewportHeight() - vDragThreshold)) return 1;
    return 0;
},

// Determine whether the last event occurred in either the left or right scroll thresholds
_getHDragScrollDirection : function (offsetX) {
    var hDragThreshold = this.getHDragScrollThreshold();

    if (offsetX < hDragThreshold) return -1;
    if (offsetX > (this.getViewportWidth() - hDragThreshold)) return 1;
    return 0;
},

// Determine whether the last event occurred over any drag scroll threshold
_overDragThreshold : function (direction) {
    var offsetY = (this.getOffsetY() - this.getScrollTop()),
        offsetX = (this.getOffsetX() - this.getScrollLeft());

    if (direction != null) {
        if (direction == isc.Canvas.VERTICAL)
            return this._getVDragScrollDirection(offsetY) != 0;
        else
            return this._getHDragScrollDirection(offsetX) != 0;
    }

    return (this._getVDragScrollDirection(offsetY) != 0 ||
            this._getHDragScrollDirection(offsetX) != 0);
},

getDragScrollThreshold : function () {
    if (this.dragScrollThreshold != null) {
        return this.dragScrollThreshold;
    } else {
        // On touch browsers, use a higher dragScrollThreshold of 30% (from 10%) by default.
        // This makes auto-scrolling during a drag much easier to invoke.
        return (isc.Browser.isTouch ? "30%" : "10%");
    }
},

// getHDragScrollThreshold() / getVDragScrollThreshold() - method to determine the size of the
// dragScrollThreshold on either axis.
// By default will return this.dragScrollThreshold, resolved from a percentage size if
// necessary.
getHDragScrollThreshold : function () {
    // We cache the values to avoid recalculating from percentage size on every mouseMove.
    // These cached values are dropped on widget resize.
    if (this._hDragScrollThreshold != null) return this._hDragScrollThreshold;
    var tH = this.getDragScrollThreshold();
    if (isc.isA.Number(tH)) this._hDragScrollThreshold = tH;
    else {
        // assume it's a percentage
        tH = parseInt(tH);
        if (!isNaN(tH)) {
            this._hDragScrollThreshold = parseInt(tH * this.getViewportWidth() / 100);
            return this._hDragScrollThreshold;
        } else {
            //>DEBUG
            isc.Log.logWarn("Unable to resolve specified drag scroll threshold '" +
                            this.getDragScrollThreshold() + "' to a valid size. Should be specified as" +
                            " an absolute pixel value, or a percentage of widget viewport.");
            //<DEBUG
            return 0;
        }
    }
},
getVDragScrollThreshold : function () {
    if (this._vDragScrollThreshold != null) return this._vDragScrollThreshold;
    var tH = this.getDragScrollThreshold();
    if (isc.isA.Number(tH)) this._vDragScrollThreshold = tH;
    else {
        // assume it's a percentage
        tH = parseInt(tH);
        if (!isNaN(tH)) {
            this._vDragScrollThreshold = parseInt(tH * this.getViewportHeight() / 100);
            return this._vDragScrollThreshold;
        } else {
            //>DEBUG
            isc.Log.logWarn("Unable to resolve specified drag scroll threshold '" +
                            this.getDragScrollThreshold() + "' to a valid size. Should be specified as" +
                            " an absolute pixel value, or a percentage of widget viewport.");
            //<DEBUG
            return 0;
        }
    }
},

// setupDragScroll
// - If the user is drag-hovering close to the ends of the widget, setup a timer event to start
//   scrolling in the appropriate direction.
_setupDragScroll : function (direction, isDragSelect) {

    // If we're already waiting to scroll no-op
    if (this._dragScrollTimer != null) return;

    var offsetY = (this.getOffsetY() - this.getScrollTop()),
        offsetX = (this.getOffsetX() - this.getScrollLeft()),
        horizontal = this._getHDragScrollDirection(offsetX),
        vertical = this._getVDragScrollDirection(offsetY);

    this._dragScrollTimer =
        isc.Timer.setTimeout({target:this, methodName:"_performDragScroll",
                              args:[horizontal,vertical,true, direction,isDragSelect]},
                              this.dragScrollDelay
                            );
},

// performDragScroll
// Actually scroll the widget in the appropriate direction in response to the user
// drag-hovering close to the edge of the viewport.
// This method is always fired in response to a timer event, set up from either:
// - _setupDragScroll() called by event handler code when the user is dragging over the edge
//   of this widget. In this case we're passed an intended direction of scroll, and the
//   boolean 'firstScroll' parameter. We use these params to avoid the possibility of the
//   user hovering on one side of the widget long enough to start the drag-scroll timer, then
//   moving to a different side, and having scrolling beging before the user has drag-hovered
//   for the requisite length of time on that other side.
// or:
// - _performDragScroll() will setup a timer to call itself, in order to continuously scroll
//  as long as the user hovers over a scroll threshold on the widget.
//
// isDragSelect parameter - passed if a widget is canSelectText:true and the user is
// dragging the mouse outside the drag target widget.
// In this case we want to scroll as long as the mouse is down, and *outside* the widget
_performDragScroll : function (horizontal, vertical, firstScroll, direction, isDragSelect) {
    this._dragScrollTimer = null;

    var hScrollIncrement = 0, vScrollIncrement = 0;
    var containsEvent = this.containsEvent();

    if (this.ns.EH.dragging && (isDragSelect || containsEvent)) {

        var offsetX = this.getOffsetX() - this.getScrollLeft(),
            offsetY = this.getOffsetY() - this.getScrollTop(),
            viewportWidth = this.getViewportWidth(),
            viewportHeight = this.getViewportHeight();

        // the scroll increments may have been set up as percentage values.
        // If so resolve these to pixel values, and cache them for the next _performDragScroll()
        // call.
        // Note that if the user has moved the mouse outside the scroll area when this method fires
        // we'll clear these cached values, so they should never become out of date due to the
        // widget's scrollWidth, etc. changing.
        if (!isc.isA.Number(this.maxDragScrollIncrement)) {
            // resolve percentages
            var maxInc = parseInt(this.maxDragScrollIncrement);
            if (!isc.isA.Number(maxInc))
                this.logWarn("Unable to resolve this.maxDragScrollIncrement '" +
                             this.maxDragScrollIncrement + "' to a valid value. This should be an " +
                             "absolute pixel value or a percentage to scroll by.");

            // cache for repeated scroll events
            this._maxHInc = parseInt(maxInc / 100 * this.getScrollWidth());
            this._maxVInc = parseInt(maxInc / 100 * this.getScrollHeight());
        } else {
            this._maxHInc = this._maxVInc = this.maxDragScrollIncrement;
        }

        if (!isc.isA.Number(this.minDragScrollIncrement)) {
            // resolve percentages
            var minInc = parseInt(this.minDragScrollIncrement);
            if (!isc.isA.Number(minInc))
                this.logWarn("Unable to resolve this.minDragScrollIncrement '" +
                             this.minDragScrollIncrement + "' to a valid value. This should be an " +
                             "absolute pixel value or a percentage to scroll by.");

            // cache for repeated scroll events
            this._minHInc = parseInt(minInc / 100 * (this.getScrollWidth()-viewportWidth));
            this._minVInc = parseInt(minInc / 100 * (this.getScrollHeight()-viewportHeight));
        } else {
            this._minHInc = this._minVInc = this.minDragScrollIncrement;
        }

        // Direction param - certain widgets only cause drag-scrolling either vertically
        // or horizontally. Derived by EH from canvas.dragScrollDirection, and passed into
        // this method as the direction param.
        // If we are passed a 'direction' parameter, only allow drag-scrolling in the
        // direction specified.
        var hDSDir = (direction == isc.Canvas.VERTICAL ? 0 : this._getHDragScrollDirection(offsetX)),
            vDSDir = (direction == isc.Canvas.HORIZONTAL ? 0 : this._getVDragScrollDirection(offsetY));

        // This event is fired on a timer.
        // We want to avoid scrolling in the case where a user passes over the scroll threshold
        // on one axis (which kicks off the timer), and is positioned over a different scroll
        // threshold when the timer executes, as we want to scroll only if the user has
        // consciously hovered over a scroll threshold.
        // Once we've kicked off the first scroll, we don't need to be strict about this -
        // if the user moves their mouse to a different scroll area while scrolling is in
        // progress we can assume it's a conscious attempt to scroll in another direction.
        if (firstScroll) {
            // if the direction has changed, set to zero - this will prevent scrolling from
            // occurring
            if (horizontal != 0 && horizontal != hDSDir)
                horizontal = 0;
            if (vertical != 0 && vertical != vDSDir)
                vertical = 0;
        } else {
            horizontal = hDSDir;
            vertical = vDSDir;
        }

        // When drag selecting text the correct behavior is a little tricky.
        // If a user is selecting a line of text which happens to be near the edge of
        // the viewport we don't want a scroll to occur on a parent and shoot the target
        // out of view.
        // Therefore we only drag scroll a parent as far as necessary to completely
        // reveal the drag-target
        if (isDragSelect) {
            var dragTarget = isc.EH.dragTarget;
            if (this != dragTarget) {
                if (horizontal != 0) {
                    var offsetLeft = dragTarget.getCanvasLeft(this);
                    if (horizontal < 0) {
                        if (offsetLeft >= 0) {
                            horizontal = 0;
                        }
                    } else {
                        if (offsetLeft + dragTarget.getVisibleWidth()
                            <= this.getViewportWidth())
                        {
                            horizontal = 0;
                        }
                    }
                }
                if (vertical != 0) {
                    var offsetTop = dragTarget.getCanvasTop(this);
                    if (vertical < 0) {
                        if (offsetTop >= 0) {
                            vertical = 0;
                        }
                    } else {
                        if (offsetTop + dragTarget.getVisibleHeight()
                            <= this.getViewportHeight())
                        {
                            vertical = 0;
                        }
                    }
                }
            }
        }
        if (containsEvent) {
            hScrollIncrement = this.getScrollIncrement(horizontal,
                                                            offsetX,
                                                            viewportWidth,
                                                            this.getHDragScrollThreshold(),
                                                            this._maxHInc,
                                                            this._minHInc);
            vScrollIncrement = this.getScrollIncrement(vertical,
                                                            offsetY,
                                                            viewportHeight,
                                                            this.getVDragScrollThreshold(),
                                                            this._maxVInc,
                                                            this._minVInc);
        } else {
            hScrollIncrement = horizontal * this._maxHInc;
            vScrollIncrement = vertical * this._maxVInc;
        }

        // Don't bother scrolling / setting up repeating scrolls if we're already at the end
        if ((hScrollIncrement > 0 && (this.getScrollLeft() >= this.getScrollRight())) ||
            (hScrollIncrement < 0 && (this.getScrollLeft() <= 0))) hScrollIncrement = 0;
        if ((vScrollIncrement > 0 && (this.getScrollTop() >= this.getScrollBottom())) ||
            (vScrollIncrement < 0 && (this.getScrollTop() <= 0))) vScrollIncrement = 0;
    }

    if (hScrollIncrement != 0 || vScrollIncrement != 0) {
        this.scrollBy(hScrollIncrement, vScrollIncrement);
        // continue to scroll.  We do this on a timeout, rather than re-calling this method
        // directly to allow normal event processing to continue.
        this._dragScrollTimer = isc.Timer.setTimeout(
                                    {target:this,
                                     methodName:"_performDragScroll",
                                     args:[null,null,null,direction,isDragSelect]}, 50
                                );

    // The mouse has moved out of the scrollable area since we last started the timer, or
    // we've reached the edge of the widget.
    } else {
        // clear out the cached scroll increments - we'll lazily recalculate when drag
        // scrolling begins again.
        delete this._maxHInc;
        delete this._minHInc;
        delete this._maxVInc;
        delete this._minVInc;
    }
},

// Internal method to determine how much to scroll by when drag-scrolling this widget, based
// on mouse position [abstracted out to work vertically or horizontally]
// For drag scrolling to occur, the mouse must be positioned <= 1 * this.dragScrollThreshold
// from the edge of the viewport.
// The closer the mouse is to the edge of the viewport, the faster the widget will scroll
// - this is controlled by the 'maxDragScrollIncrement' / 'minDragScrollIncrement' properties
//   when the user is hovering right over the edge of the window, the window will scroll by the
//   maximum value, when hovering exactly 1* the threshold from the edge, it will scroll by the
//   minimum value.
// Return zero if the widget should not scroll.
getScrollIncrement : function (direction, eventOffset, viewportSize, threshold, maxInc, minInc) {
    if (direction == null || direction == 0) return 0;

    // Resolve the offset to the distance from the start of the scroll threshold
    if (direction > 0) {
        eventOffset = eventOffset - (viewportSize - threshold);
    } else if (direction < 0) {
        eventOffset = threshold - eventOffset;
    }

    // Don't scroll if we're outside the threshold area (or outside the widget)
    if (eventOffset < 0 || eventOffset > threshold) return 0;

    // Determine the amount to scroll based on the max/min scroll increments, and how close
    // we are to the edge of the widget.
    var increment = direction *
            (
                (eventOffset / threshold) *  (maxInc - minInc)
                + minInc
            );
    return parseInt(increment);
},
//<DragScrolling

// Overflow handling
// --------------------------------------------------------------------------------------------
// Managing what happens when contents overflow the Canvas' specified size: expanding, clipping,
// scrolling, etc


hasInherentHeight : function () {
    if (this.inherentHeight != null) return this.inherentHeight;
    return (this.children == null &&
            (this.overflow == isc.Canvas.VISIBLE || this.overflow == isc.Canvas.CLIP_H));
},

hasInherentWidth : function () {
    if (this.inherentWidth != null) return this.inherentWidth;
    return (this.children == null &&
            (this.overflow == isc.Canvas.VISIBLE || this.overflow == isc.Canvas.CLIP_V));
},

canOverflowWidth : function (overflow) {
    if (overflow == null) overflow = this.overflow;
    return overflow == isc.Canvas.VISIBLE || overflow == isc.Canvas.CLIP_H;
},

canOverflowHeight : function (overflow) {
    if (overflow == null) overflow = this.overflow;
    return overflow == isc.Canvas.VISIBLE || overflow == isc.Canvas.CLIP_V;
},

_shouldWriteClipDiv : function () {
    return (this.useClipDiv ||
            (!isc.Browser._useNewSingleDivSizing ||

             (this.overflow == isc.Canvas.VISIBLE && (!isc.Browser.isOpera || isc.Browser.minorVersion >= 11.1)))) ||
           this.getScrollingMechanism() == isc.Canvas.NESTED_DIV;
},

//> @method canvas.getOverflow()
//      Return the overflow of a Canvas.
//      @group  positioning, sizing
//
//<
getOverflow : function () {
    return this.overflow;
},


//> @method canvas.setOverflow()    ([A])
// Update the +link{Canvas.overflow, overflow} of a Canvas after it has been created.
//      @group  positioning, sizing
//      @param  newOverflow (Overflow)      New overflow value.
//
// @group sizing
// @visibility external
//<
setOverflow : function (newOverflow) {

    //>Animation
    // Finish any hide/show animations that are running
    // Required since we force overflow to hidden during animation, then reset to original
    // overflow when animation completes.
    if (this._animatingHide != null && !this._hidingAsAnimation)
        this.finishAnimation(this._animatingHide);
    if (this._animatingShow != null && !this._showingAsAnimation)
        this.finishAnimation(this._animatingShow);
    //<Animation

    if (this.overflow == newOverflow) return; // no-op

    var oldOverflow = this.overflow,
        oldNeedHideUsingDisplayNone = this._needHideUsingDisplayNone();
    this.overflow = newOverflow;
    var needHideUsingDisplayNone = this._needHideUsingDisplayNone();

    if (!oldNeedHideUsingDisplayNone && needHideUsingDisplayNone) {
        this._incrementHideUsingDisplayNoneCounter();

        var parent = this.parentElement;
        while (parent != null) {
            parent._incrementHideUsingDisplayNoneCounter();
            parent = parent.parentElement;
        }
    } else if (oldNeedHideUsingDisplayNone && !needHideUsingDisplayNone) {
        this._decrementHideUsingDisplayNoneCounter();

        var parent = this.parentElement;
        while (parent != null) {
            parent._decrementHideUsingDisplayNoneCounter();
            parent = parent.parentElement;
        }
    }

    // If we're drawn, we need to update the elements width, height, overflow, and
    // clip so that they reflect the new overflow state.  Essentially, we make the setting
    // match the initial values as set in getTagStart() and then call 'adjustOverflow' to do
    // standard adjustments.

    if (!this.isDrawn()) return;

    var scrollingStateChanged = false;

    // If we WERE showing custom scrollbars, and the overflow is no longer scroll or auto,
    // clear them out
    if (newOverflow != isc.Canvas.SCROLL && newOverflow != isc.Canvas.AUTO &&
         (this.hscrollOn || this.vscrollOn))
    {
        if (this.hscrollOn || this.vscrollOn) scrollingStateChanged = true;
        // clear flags (note flag may be set with no scrollbar having been created)
        this.hscrollOn = this.vscrollOn = false;
        // hide custom scrollbars if they exist
        // (Note: we could destroy the scrollbars here, but it's not necessary - this is
        // quicker, and this way the scrollbars may be re-used if the overflow is changed
        // back to auto / scroll.  If the widget is clear()'d / destroy()'d, the scrollbars
        // will get cleaned up.)
        if (this.hscrollbar != null) this.hscrollbar.hide();
        if (this.vscrollbar != null) this.vscrollbar.hide();
    }


    if (isc.Browser.isIE &&
        (newOverflow == isc.Canvas.CLIP_H || newOverflow == isc.Canvas.CLIP_V))
    {
        this.markForRedraw();
        return;
    }

    var handle;

    // Check if we need to switch DOM structures from doubleDiv to singleDiv or vice versa.
    var drewClipDiv = this._drewClipDiv,
        writeClipDiv = this._shouldWriteClipDiv();
    if (isc.Browser._useNewSingleDivSizing && drewClipDiv != writeClipDiv) {
        handle = this.getHandle();
        var clipHandle = this.getClipHandle(),
            origParent = clipHandle.parentNode,
            origNextSibling = clipHandle.nextSibling,
            docFragment,
            child;


        if (isc.Browser._supportsCreateContextualFragment) {
            // Parse `this.getTagStart() + this.getTagEnd()' as a `DocumentFragment' and move
            // the child elements of the current handle into the document fragment.
            var range = handle.ownerDocument.createRange();
            range.selectNode(handle);
            docFragment = range.createContextualFragment(this.getTagStart() + this.getTagEnd());

            // Detach the current handle (and clip handle if applicable) from the document
            // so that moving the children of the current handle into `docFragment' will be more efficient.

            this._drewClipDiv = drewClipDiv;
            this.clearHandle(true);

            var newHandle = docFragment.firstChild;
            if (writeClipDiv) newHandle = newHandle.firstChild;

            while ((child = handle.firstChild) != null) {
                newHandle.appendChild(child);
            }

            // Attach the new handles and original handle's children (atomic operation).
            origParent.insertBefore(docFragment, origNextSibling);

            this._handle = newHandle;
        } else {
            // Use only DOM Level 1 methods for browsers that do not support Range.createContextualFragment().

            // Save the children of the handle to a `DocumentFragment'. First detach the current handle
            // (and clip handle if applicable) from the document so that this is more efficient.

            this._drewClipDiv = drewClipDiv;
            this.clearHandle(true);

            docFragment = handle.ownerDocument.createDocumentFragment();
            while ((child = handle.firstChild) != null) {
                docFragment.appendChild(child);
            }

            // Re-create the handle elements.
            var drawContext;
            if (origNextSibling == null) {
                drawContext = {
                    element: origParent,
                    position: "beforeEnd"
                };
            } else {
                drawContext = { element: origNextSibling };
            }
            this._insertHTML(false, drawContext);

            // Attach the original handle's children (atomic operation).
            this.getHandle().appendChild(docFragment);

            // A side effect of Canvas._insertHTML() is that it resets the _drawn flag. Set back
            // to true.
            this._drawn = true;
        }
        this._drewClipDiv = writeClipDiv;

        this._updateHandleDisplay();
        this._descendentHTMLRefreshed();
    }
    handle = this.getStyleHandle();

    // set the overflow property on the handle
    var handleOverflow = this._getHandleOverflow();
    handle.overflow = handleOverflow;

    if (isc.Browser._supportsWebkitOverflowScrolling) {
        handle.WebkitOverflowScrolling = this._usingNativeTouchScrolling() ? "touch" : "auto";
    }

    // Set the initial width / height of the handle
    var sizeArray = this._getInitialHandleSize();
    handle.width = sizeArray[0] + this._$px;
    handle.height = sizeArray[1] + this._$px;

    

    // If we're not using clip-scrolling, we want to clear out any clip that's already been
    // set on the widget's handle.
    // (_adjustOverflow() will apply a clip to the handle in some cases, but will not remove
    // an existing clip)

    {
        if (handle.clip != null && handle.clip != "" &&
            handle.clip != "rect(auto auto auto auto)")
        {
            handle.clip = (isc.Browser.isIE ? "rect(auto)" : "");
        }
        this._clip = null;
    }

    // The handle will now have it's overflow, size and clip set to the values they would
    // have at the end of getTagStart().
    // Call adjustOverflow to handle resizing to accommodate contents, setting additional
    // clips, showing scrollbars, etc.
    this.adjustOverflow("setOverflow");


    if (oldOverflow == isc.Canvas.VISIBLE && newOverflow != isc.Canvas.VISIBLE) {
        var dX = Math.max(this.getScrollWidth() - this.getInnerWidth(), 0),
            dY = Math.max(this.getScrollHeight() - this.getInnerHeight(), 0);
        // Note the handle in this case is shrinking by the difference between scroll size
        // and available space, so pass in -dX/-dY
        if (dX > 0 || dY > 0) this._resized(-dX, -dY, "overflow changed");

    } else if (oldOverflow != isc.Canvas.VISIBLE && newOverflow == isc.Canvas.VISIBLE) {
        var dX = Math.max(this.getScrollWidth() - this.getInnerWidth(), 0),
            dY = Math.max(this.getScrollHeight() - this.getInnerHeight(), 0);
        if (dX > 0 || dY > 0) this._resized(dX, dY, "overflow changed");
    } else if (scrollingStateChanged) {
        this.innerSizeChanged("scrolling state changed");
    }

    // Note: since the dynamic _canFocus() method defaults to depending on this.overflow
    // being hidden, we should call the _updateCanFocus() method here to update the native
    // handle focus and tab-index behavior.
    // NOTE: avoid doing this in common cases where it's not needed, since it can cause some
    // components to redraw (eg Buttons and Labels, when animating)
    if ((newOverflow == isc.Canvas.HIDDEN || newOverflow == isc.Canvas.VISIBLE) &&
        (oldOverflow == isc.Canvas.HIDDEN || oldOverflow == isc.Canvas.VISIBLE)) {
    } else {
        this._updateCanFocus();
    }
},

// setOverflow may change the handle from a single to double div structure or vice versa.
// When this happens we have to temporarily remove all HTML and then slot it back in
// Have a notification be fired on descendants when this occurs.
_descendentHTMLRefreshed : function () {
    var children = this.children;
    for (var i = 0, len = (children == null ? 0 : children.length); i < len; ++i) {
        children[i]._domRefreshedByParent();
    }
},


_domRefreshedByParent : function () {

    this._transitionsRemoved();
    // make this method recursive
    var children = this.children;
    for (var i = 0, len = (children == null ? 0 : children.length); i < len; ++i) {
        children[i]._domRefreshedByParent();
    }


},


_transitionsRemoved : (isc.Browser._supportsCSSTransitions ?
    function () {
        if (this.transitionsRemoved != null) this.transitionsRemoved();

        var children = this.children;
        for (var i = 0, len = (children == null ? 0 : children.length); i < len; ++i) {
            children[i]._transitionsRemoved();
        }
    }
:
    isc.Class.NO_OP
),

// set a timer to call adjustOverflow (unless one is already set).  This is to avoid redundant
// timers being set when parents set a timer to adjustOverflow on child move and resize, which
// can happen in large batches (particularly with layouts).  It might even be worthwhile to
// centralize delayed adjustOverflow() calls for all widgets into a single queue, similar to
// the redraw queue.
_markForAdjustOverflow : function (reason) {
    if (!this.isDrawn() || this.isDirty() || this.destroying || this._clearing) return;

    if (!this._overflowQueued) {
        //>DEBUG
        if (this.logIsDebugEnabled())
            this.logDebug("delaying adjustOverflow: " + (reason ? reason : this.getStackTrace()));
        //<DEBUG
        var theCanvas = this;
        this._overflowTimer =
            isc.Timer.setTimeout(function () {
                if (!theCanvas.destroyed) theCanvas.adjustOverflow(reason, true)
            }, 0);
    }
    this._overflowQueued = true;
},

//> @method canvas.adjustForContent() [A]
// This method tells a component to adjust for size changes made to content by external code.
// <P>
// This is for very advanced use in which the contents of a Canvas are being directly updated by
// Ajax techniques, which is required for integration with some third-party libraries.
// Calling this method is required because browsers do not provide consistent events by which
// SmartClient can be notified of external content changes.
// <P>
// Only contents supplied to a widget via +link{canvas.contents} or via an override of
// +link{canvas.getInnerHTML()} should be manipulated directly.  Contents automatically
// generated by SmartClient components (such as the basic structure of a Button) should never be
// manipulated: these structures are considered internal, differ by platform, and will change
// without notice.
// @param immediate (boolean)
//  By default the adjustment will occur on a small delay for performance reasons.
//  Pass in this parameter to force immediate adjustment.
// @group sizing
// @visibility external
//<
adjustForContent : function (immediate) {
    var reason = "adjustForContent() called";
    if (immediate) this.adjustOverflow(reason);
    else this._markForAdjustOverflow(reason);
},


_browserDoneDrawing : function () {
    var handle = this.getHandle();


    if (isc.Browser.isOpera) {
        var handle = this.getHandle();
        return !(handle.scrollHeight == 0 && handle.scrollWidth == 0);
    }

    if (!isc.Browser.isIE) {

        //
        // clipHandle can be null in canvas.start/end mode if we're doc.write()ing
        var clipHandle = this.getClipHandle();
        if (clipHandle == null) return false;

        var scrollHeight = clipHandle.scrollHeight;
        if (scrollHeight == null || scrollHeight == 0) scrollHeight = this.getClipHandle().offsetHeight;

        return scrollHeight != 0;
    }

    // IE-only (including MacIE)


    var browserDoneDrawing;
    if (isc.Browser.isWin) {


        return handle != null && handle.scrollHeight != this._$undefined &&
                    handle.scrollHeight != 0;
    }
},

// Flag to suppress adjustOverflow from running while we're waiting on a redraw
adjustOverflowWhileDirty:true,

//> @method canvas.adjustOverflow() (A)
// Adjust the size, clipping and/or scrolling of a canvas to account for its drawn size and
// the overflow setting.
//
//      @group  sizing
//
//      @return (boolean)   true == we're done adjusting the overflow
//                          false == couldn't adjust for some reason, had to defer and call again.
//<
// NOTE: children must adjust for overflow before parents, because some parents take children's
// sizes into account when sizing themselves.
adjustOverflow : function (reason, delayed, fromRedraw) {
    if (isc._traceMarkers) arguments.__this = this;

    if (delayed && !this._overflowQueued) {
        // only one timer can be outstanding at once, but this case still happens if
        // adjustOverflow is called by other code during the timer delay (eg redraw)
        //this.logWarn("aborting unnecessary delayed adjust");
        return;
    }
    this._overflowQueued = false;


    // if not drawn yet or we're not handling overflow for this object,
    //  just return true since we don't need to do anything
    if (!this.isDrawn() || this.overflow == isc.Canvas.IGNORE) return true;

    // Flag can be set to avoid all adjustOverflows while waiting on a redraw
    // Note: if we're being redrawn in response to the redraw of a dirty parent, their
    // __dirty flag will not yet have been cleared (so this.isDirty() will return true).
    // We catch that case with the explicit 3rd param

    if (!this.adjustOverflowWhileDirty && !fromRedraw && this.isDirty() &&
        (this.overflow != isc.Canvas.VISIBLE))
    {
        return;
    }


    if (!isc.Page.isLoaded() &&
        (isc.Browser.isSafari || isc.Page.delayAdjustOverflowUntilLoad ||
         (isc.Browser.isMoz && isc.Browser.geckoVersion < 20040616)))
    {
        // defer the 'adjustOverflow' until the page has loaded.
        isc.Page.setEvent("load", this, isc.Page.FIRE_ONCE, "_adjustOverflowForPageLoad");


        if (isc.Browser.isMoz) return;
    }

    // If we've set the internal flag to suppress adjustOverflow just return
    if (this._suppressAdjustOverflow) return;

    // adjust now if size is available
    if (this._browserDoneDrawing()) return this._adjustOverflow(reason);

    if (this.logIsDebugEnabled("overflow")) {
        this.logDebug("browser not done drawing, deferring overflow.", "overflow");
        if (this._drewClipDiv) {
            this.logDebug("clipHandle sizes: " + this.echoElementSize(this.getClipHandle()),
                          "overflow");
        }
        this.logDebug("handle sizes: " + this.echoElementSize(this.getHandle()),
                      "overflow");
    }

    // if size can't be determined, set a relatively immediate timer to check again.
    // If it still can't be determined, keep checking at a less frequent interval.
    if (!this._delayedAdjustOverflow) {
        this._markForAdjustOverflow();
        this._delayedAdjustOverflow = true;     // this flag cleared out in _adjustOverflow
    } else {
        //>DEBUG
        this.logDebug("still waiting for size to become available", "overflow"); //<DEBUG
        this._queueForDelayedAdjustOverflow();
    }
    // return false that we didn't finish the adjustment yet
    return false;
},


_adjustOverflowForPageLoad : function () {
    if (!this.destroyed && this.isDrawn()) this.adjustOverflow("pageLoad");
},

_queueForDelayedAdjustOverflow : function() {
    isc.Canvas._queueForDelayedAdjustOverflow(this.getID());
},


// (internal) routine to implement the Canvas.overflow property, by clipping, scrolling or
// automatically expanding based on the size of content and children
_adjustOverflow : function (reason) {
    if (this._inAdjustOverflow) {

        return
    }
    this._inAdjustOverflow = true;

    // If we're showing the componentMask, resize so it doesn't take any space. We'll reset to fill the
    // handle when adjustOverflow is complete.
    if (this.componentMask != null && this.componentMask.isDrawn()) {
        this.componentMask.resizeTo(1,1);
    }

    this.__adjustOverflow(reason);

    // If we're showing a per-component clickMask, ensure it covers all our content.
    if (this.componentMask != null && this.componentMask.isDrawn()) {
        this._fixComponentMaskSize();
    }

    this._inAdjustOverflow = false;
},

_supportedOverflows:{hidden:true, visible:true, scroll:true, auto:true, "clip-v":true, "clip-h":true, ignore:true},
_$sizing : "sizing",
_$overflow : "overflow",
__adjustOverflow : function (reason) {

    if (!this._supportedOverflows[this.overflow]) {
        this.logWarn("This widget has overflow specified as " + this.echo(this.overflow) +
                     ".  This overflow setting is not supported - defaulting to overflow:\"visible\".");
        this.overflow = isc.Canvas.VISIBLE;
    }

    // Note: scrollHeight / scrollWidth and cacheing:
    // in getScrollHeight() / getScrollWidth(), we iterate through all our DOM children to
    // calculate a reliable scrollHeight / width.
    // This is quite expensive, so we cache the value after calculating it.
    //
    // This method (_adjustOverflow) is called by all the methods that could end up effecting
    // the scrollHeight / width of a widget (setContents, resize, addChildren...)
    // Therefore in this case we want ensure we calculate new scrollHeight / scrollWidth values.
    //
    // getScrollHeight() / getScrollWidth() takes a parameter 'calculateNewValue' which, if true,
    // will force the value to be recalculated rather than returning the cached value.
    // We must ensure that at the end of this method that getScrollHeight() and
    // getScrollWidth() will report accurate values.
    //
    // Start by invalidating any existing cached scrollHeight / scrollWidth values for this
    // widget.
    if (this._scrollWidth != null) delete this._scrollWidth;
    if (this._scrollHeight != null) delete this._scrollHeight;

    // if we allow content to overflow, this method may change our drawn size.
    // We need to detect this case and fire 'resized'.
    // old scroll size was remembered last time this method was run (if overflow == "visible")
    // - hang onto this value locally for comparison with the current drawn size.

    var oldScrollWidth = this._currentContentWidth,
        oldScrollHeight = this._currentContentHeight;

    delete this._currentContentWidth;
    delete this._currentContentHeight;

    // hang onto a flag indicating whether we're overflowed
    var wasOverflowed = this._isOverflowed;
    this._isOverflowed = false;

    // make a local reference to the global Canvas object (faster)
    var canvas = isc.Canvas;

    // clear out the _delayedAdjustOverflow flag used by the delayedAdjustOverflow queueing code
    this._delayedAdjustOverflow = null;

    //>DEBUG
    if (this.getHandle() == null) this.logWarn("adjustOverflow: handle null");
    if (this.getClipHandle() == null) this.logWarn("adjustOverflow: clipHandle null");

    if (this.alwaysShowVScrollbar) {
        // this is acceptable since overflow may be modified at runtime
        if (this.overflow != isc.Canvas.AUTO || this.overflow != isc.Canvas.SCROLL) {
            this.logInfo("alwaysShowVScrollbar specified as true, but overflow set to \""+
                         this.overflow + "\". Property will be ignored.");
        } else if (this.showCustomScrollbars == false) {
            this.logWarn("alwaysShowVScrollbar property not supported when showing native scrollbars");
        }
    }

    if (this.logIsInfoEnabled(this._$sizing)) {
        this.logInfo("Specified size: " + this.getWidth() + "x" + this.getHeight() +
                     ", drawn scroll size: " +
                            this.getScrollWidth(true) + "x" + this.getScrollHeight(true) +
                     ", border: " + this.getVBorderSize() + "x" + this.getHBorderSize() +
                     ", margin: " + this.getVMarginSize() + "x" + this.getHMarginSize() +
                     (oldScrollWidth == null ? "" :
                      ", old size: " + oldScrollWidth + "x" + oldScrollHeight) +
                     ", reason: " + reason,
                     "sizing");
    }

    if (this.logIsDebugEnabled(this._$sizing)) {
        if (this._drewClipDiv) {
            this.logDebug("clipHandle sizes: " + this.echoElementSize(this.getClipHandle()),
                          "sizing");
        }
        this.logDebug("handle sizes: " + this.echoElementSize(this.getHandle()),
                      "sizing");
    }
    //<DEBUG


    if (this.overflow == canvas.IGNORE) {

    } else if (this.overflow == canvas.VISIBLE) {

        // If we drew larger than the specified size, expand to that size.
        // Shrink if we were previously drawn larger than specified size, but never shrink
        // below specified size.


        var resetHandleOnAdjustOverflow = false;
        if (this._resetHandleOnAdjustOverflow) {
            if (this.getWidth() < this.getVisibleWidth() ||
                this.getHeight() < this.getVisibleHeight())
            {
                resetHandleOnAdjustOverflow = true;
                if (this.parentElement != null) {
                    this.parentElement.childResettingHandleForAdjustOverflow();

                    this._setHandleRect(null, null, this.width, this._height);
                }
            }
            delete this._resetHandleOnAdjustOverflow;
        }

        var scrollWidth = this.getScrollWidth(true),
            scrollHeight = this.getScrollHeight(true);


        if (this._useMozScrollbarsNone) {
            var handle = this.getScrollHandle();
            if (handle.scrollTop != 0 || handle.scrollLeft != 0) {
                handle.scrollTop = handle.scrollLeft = 0;

            }
        }

        // If the widget's content or children take up more space than the specified size, the
        // drawn size may exceed the specified size.



        var innerWidth = this.getInnerWidth(), innerHeight = this.getInnerHeight();

        // figure out whether we're overflowed, and store it
        var overflowed = this._isOverflowed = (scrollWidth > innerWidth ||
                                               scrollHeight > innerHeight);
        if (!wasOverflowed && oldScrollWidth > this.getWidth()) {
            wasOverflowed = true;
        }


        if (overflowed && !wasOverflowed && this._acceptedAdaptOffer) {
            var layout = this.parentElement;
            if (layout && layout._canAdaptSize(this)) {
                this.logWarn("size-adaptable member of layout " + layout.getID() +
                             " accepted an offer of " + this._acceptedAdaptOffer + " pixels " +
                             "but has just overflowed; check adaptWidthBy()/adaptHeightBy() " +
                             "implementation", this._$adaptMembers);
            }
        }

        // if we're not overflowed, and we weren't overflowed before, we don't need to resize
        // the handle.
        if (!overflowed && !wasOverflowed)
        {
            this._currentContentWidth = scrollWidth;
            this._currentContentHeight = scrollHeight;
            //this.logWarn("adjustOverflow done, no overflow, size: " +
            //             [scrollWidth, scrollHeight]);
            return;
        }

        // Resize to the larger of this.size and the reported scroll size [+ border and margin]
        // in each dimension.
        var hMarginBorder = this.getHMarginBorder(), vMarginBorder = this.getVMarginBorder();

        //this.logWarn("assigning width/height: " + [
        //                    Math.max((scrollWidth + hMarginBorder), this.getWidth()),
        //                    Math.max((scrollHeight + vMarginBorder), this.getHeight()) ] +
        //" margin/border is: " + [hMarginBorder,vMarginBorder]);
        var newWidth  = Math.max(scrollWidth  + hMarginBorder,
                                 this.getWidth(),  this.getMinWidth()),
            newHeight = Math.max(scrollHeight + vMarginBorder,
                                 this.getHeight(), this.getMinHeight());




        if (isc.Menu && isc.isA.Menu(this.parentElement) && isc.isA.GridBody(this) &&
            (newWidth > this.getWidth() || newHeight > this.getHeight())) {
            this._resetHandleOnAdjustOverflow = true;
        }

        this._setHandleRect(this.left, this.top, newWidth, newHeight);


        if (this.isRTL()) this.handleMoved();


        var hasChildren = this.children && this.children.length > 0;
        if (!hasChildren || this.allowContentAndChildren) {
            var newScrollHeight = this.getScrollHeight(true),
                newScrollWidth = this.getScrollWidth(true);

            if (newScrollHeight != scrollHeight || newScrollWidth != scrollWidth) {


                scrollWidth = newScrollWidth;
                scrollHeight = newScrollHeight;

                this._setHandleRect(this.left, this.top,
                                    Math.max((scrollWidth + hMarginBorder),
                                             this.getWidth(),  this.getMinWidth()),
                                    Math.max((scrollHeight + vMarginBorder),
                                             this.getHeight(), this.getMinHeight()));

                if (this.isRTL()) this.handleMoved();
            }
        }
        if (resetHandleOnAdjustOverflow && this.parentElement != null) {
            this.parentElement.childResetHandleForAdjustOverflowComplete();
        }



        if (this.snapTo != null && overflowed &&
            (reason == this._$parentDrawn || reason == this._$draw))
        {
            this._resolvePercentageSize(true);
        }

        // Remember the current scrollWidth / scrollHeight so we can tell if future
        // adjustOverflows change the drawn size.
        this._currentContentWidth = scrollWidth;
        this._currentContentHeight = scrollHeight;

        // if the scrollWidth or scrollHeight changed, for an overflow:visible widget this
        // indicates the visible height/width have changed, so fire resized().  Note that this
        // notification may fire for overflow being introduced, going away, or just changing.

        if ((oldScrollWidth != null && oldScrollWidth != scrollWidth) ||
            (oldScrollHeight != null && oldScrollHeight != scrollHeight))
        {
            // don't report overflow going away during a resize, it's redundant with the
            // resized() notification fired during resizeBy()

            if (!overflowed && reason == this._$resize) return;
            this._resized(scrollWidth - oldScrollWidth, scrollHeight - oldScrollHeight,
                         this._$overflow);
        }

    } else if (this.overflow == canvas.HIDDEN) {

        // set the width and height of the layer explicitly
        this._setHandleRect(this.left, this.top, this.getWidth(), this.getHeight());


        if (this.isRTL()) {
            var scrollingMechanism = this.getScrollingMechanism();
            if (scrollingMechanism == isc.Canvas.NATIVE) {
                this.scrollLeft = this.getScrollLeft();
            } else if (scrollingMechanism == isc.Canvas.NESTED_DIV) {
                this.scrollLeft = this.getScrollLeft();
            }
        }
        // If this adjustOverflow was fired because of a resize, our contents may no longer
        // overflow by the same amount, meaning we may be 'scrolled off the end'
        // call clampToContent() to fix this
        // Note: May not be required for all browsers - but some, including Moz, do allow
        // specifying a scroll height such that you're scrolled past all content in the handle
        this._clampToContent();


    } else if (this.overflow == canvas.CLIP_H) {
        // adjust the clip to the specified values horizontally, no matter how large it
        // rendered

        var scrollHeight = this.getScrollHeight(),
            vMarginBorder = this.getVMarginBorder(),
            drawnHeight = Math.max(scrollHeight + vMarginBorder,
                                   this.getHeight(), this.getMinHeight());

        this._currentContentHeight = drawnHeight;

        this.setClip(0,
                     this.getWidth(),
                     drawnHeight,
                     0);


        // set the width and height of the layer explicitly
        // (Setting the clip will not have changed the scrollHeight, so we don't need to pass
        // the calculateNewValues parameter in to force a new calculation).
        this._setHandleRect(this.left,
                            this.top,
                            this.getWidth(),
                            drawnHeight);
    } else if (this.overflow == canvas.CLIP_V) {

        var scrollWidth = this.getScrollWidth(),
            hMarginBorder = this.getHMarginBorder();

        // handle scrollWidth not being reported as less than specified width
        if ((isc.Browser.isIE || isc.Browser.isMoz || isc.Browser.isOpera) &&
            (scrollWidth > this.getInnerWidth()) &&
            (this._currentContentWidth == scrollWidth)) {
            // Resize to specified size, then check scrollWidth again, and resize a second time
            // if necessary.
            this._setHandleRect(this.left, this.top,
                                Math.max(this.getWidth(), this.getMinWidth()),
                                this.getHeight());

            // Recalculate the scrollWidth, and do a second resize, if it's greater
            // than the specified width now
            // (Pass in the 'calculateNewValues' parameter so it doesn't just return the
            // cached value).
            scrollWidth = this.getScrollWidth(true)

            if (scrollWidth > this.getInnerWidth()) {
                this._setHandleRect(this.left, this.top,
                                    scrollWidth + hMarginBorder,
                                    this.getHeight());
            }

        // Other browsers / double resize not required...
        // The reported scrollWidth should be accurate - just resize to fit content
        } else {

            // set the width and height of the layer explicitly
            this._setHandleRect(this.left, this.top,
                                Math.max(scrollWidth + hMarginBorder,
                                         this.getWidth(), this.getMinWidth()),
                                this.getHeight());
        }

        var drawnWidth = Math.max(scrollWidth + hMarginBorder,
                                  this.getWidth(), this.getMinWidth());

        // adjust the clip to the specified values vertically, no matter how large it rendered
        this.setClip(0,
                     drawnWidth,
                     this.getHeight(),
                     0);

        // Remember the current scrollWidth
        this._currentContentWidth = drawnWidth;

    } else { // canvas.SCROLL, canvas.AUTO

        var scrollingMechanism = this.getScrollingMechanism();
        if ((isc.Browser.isIE && this.showCustomScrollbars && scrollingMechanism == isc.Canvas.NATIVE) ||
            scrollingMechanism == isc.Canvas.NESTED_DIV)
        {
            var scrollLeft = this.scrollLeft,
                scrollTop = this.scrollTop,
                trueScrollLeft = this.getScrollLeft(),
                trueScrollTop = this.getScrollTop();

            if (trueScrollLeft != scrollLeft || trueScrollTop != scrollTop) {
                this.scrollTo(trueScrollLeft, trueScrollTop, this._$nativeScroll);
            }
        }

        // old state of the scrollbars
        var vscrollWasOn = this.vscrollOn,
            hscrollWasOn = this.hscrollOn,
            wasFocusable = this._canFocus();

        // Permanently on v-scrollbar:
        var vScrollAlwaysOn = (this.alwaysShowVScrollbar && this.showCustomScrollbars);

        if (this.overflow == isc.Canvas.SCROLL) {
            // always show both scrollbars
            this.hscrollOn = this.vscrollOn = true;
        } else {    // Overflow is isc.Canvas.AUTO - determine whether scrollbars are required

            // scrollHeight / scrollWidth cache invalidated at the top of the method -no need for
            // 'calculateNewValues' parameter.

            var scrollHeight = this.getScrollHeight(),  height = this.getHeight(),
                scrollWidth = this.getScrollWidth(),    width = this.getWidth(),
                scrollbarSize = this.getScrollbarSize(),     scrollStateAtLayout;


            // If we're showing native scrollbars compare clientHeight / width with
            // scroll height / width to determine whether we're showing scrollbars

            var vMarginBorder = this.getVMarginBorder(),
                hMarginBorder = this.getHMarginBorder();

            var clipHandle = this.getClipHandle();
            if (!this.showCustomScrollbars && clipHandle.clientHeight != null) {

                this.vscrollOn = (scrollHeight > clipHandle.clientHeight);
                this.hscrollOn = (scrollWidth > clipHandle.clientWidth);

            // Otherwise, we'll determine whether we need to show scrollbars in 2 steps:
            // If the content size exceeds the specified size, we definitely need
            // scrollbars.
            } else {
                this.vscrollOn = vScrollAlwaysOn || (scrollHeight > height - vMarginBorder);
                this.hscrollOn = (scrollWidth > width - hMarginBorder);
            }

            if ((this.vscrollOn && !vscrollWasOn) ||
                (this.hscrollOn && !hscrollWasOn))
            {

                if (isc.Browser._supportsWebkitOverflowScrolling && this._usingNativeTouchScrolling() &&
                    reason === "resize")
                {
                    this.getStyleHandle().WebkitOverflowScrolling = "auto";
                    if (this._reapplyWebkitOverflowScrollingTouchTimer != null) {
                        isc.Timer.clear(this._reapplyWebkitOverflowScrollingTouchTimer);
                    }
                    this._reapplyWebkitOverflowScrollingTouchTimer = this.delayCall("_reapplyWebkitOverflowScrollingTouch");
                }


                if (!this.hscrollOn || !this.vscrollOn) {


                    if (this.showCustomScrollbars) {

                        this._setHandleRect(this.left, this.top, this.getWidth(), this.getHeight());
                    }

                    // Call innerSizeChanged() to give the widget an opportunity to resize children to
                    // match the new viewport.  Optimization: remember that we did this so we don't run
                    // it redundantly if the scrolling state stays the same.
                    scrollStateAtLayout = (this.vscrollOn ? "V" : "") + (this.hscrollOn ? "H" : "");
                    this.innerSizeChanged("introducing scrolling: " + scrollStateAtLayout);

                    // now that the content has been reflown, get the new dimensions (pass in the
                    // 'calculateNewValue' parameter - the value will have changed since the last
                    // calculation)
                    var newScrollWidth = this.getScrollWidth(true),
                        newScrollHeight = this.getScrollHeight(true);
                    //>DEBUG
                    if (this.logIsDebugEnabled("scrolling")) {
                        this.logDebug("Rechecking scrollWidth/Height on introduction of scroll:" +
                                      " old: " + [scrollWidth, scrollHeight] +
                                      ", new: " + [newScrollWidth, newScrollHeight],
                                      "scrolling");
                    } //<DEBUG
                    scrollWidth = newScrollWidth;
                    scrollHeight = newScrollHeight;
                }
            }

            if (this.showCustomScrollbars) {
                if (this.vscrollOn && !this.hscrollOn) {
                    this.hscrollOn = (scrollWidth > width - hMarginBorder - scrollbarSize);
                } else if (this.hscrollOn) {
                    this.vscrollOn = vScrollAlwaysOn || (scrollHeight > height - vMarginBorder - scrollbarSize);
                }
            }
        }

        //>DEBUG Report scroll state
        if (this.logIsInfoEnabled("scrolling")) {
            this.logInfo("Drawn size: " + this.getScrollWidth(true) + " by " + this.getScrollHeight(true) +
                         ", specified: " + this.getWidth() + " by " + this.getHeight() +
                         ", scrollbar state: " + (this.hscrollOn ? "h" : "") +
                         (this.vscrollOn ? "v" : ""), "scrolling");
        } //<DEBUG


        if (this.showCustomScrollbars &&
            (this.hscrollOn != hscrollWasOn || this.vscrollOn != vscrollWasOn))
        {


            this._setHandleRect(this.left, this.top, this.getWidth(), this.getHeight());
            // Invalidate the cached scrollheight / width again..
            if (this._scrollWidth != null) delete this._scrollWidth;
            if (this._scrollHeight != null) delete this._scrollHeight;
        }

        var oldState = ((vscrollWasOn ? "V" : "") + (hscrollWasOn ? "H" : "")),
            newState = ((this.vscrollOn ? "V" : "") + (this.hscrollOn ? "H" : ""));
        if (oldState != newState) {
            var stateChange = oldState + " -> " + newState;
            //>DEBUG
            this.logInfo("Scrollbar state: " + stateChange, "scrolling"); //<DEBUG

            // call layout children since the viewport size changed
            // Optimization: if we ran innerSizeChanged() just above because a scrollbar was
            // newly introduced, and we're still in the same scrolling situation, no need to
            // run it again.
            if (scrollStateAtLayout == null || newState != scrollStateAtLayout)
            {
                this.innerSizeChanged("scrolling state changed: " + stateChange);
            }
        }

        if (this.isRTL()) {

            if (this.hscrollOn && !hscrollWasOn) {
                var actualScroll = this.getScrollLeft();
                //this.logWarn("on RTL hscroll introduction, picked up scroll of: " + actualScroll +
                //             ", was: " + this.scrollLeft);
                this.scrollLeft = actualScroll;
            }

            // In RTL mode, when the vertical scrollbar is shown or hidden, any cached left
            // offset coordinates are invalidated.
            if (!!this.vscrollOn != !!vscrollWasOn) {
                this._$leftCoords = null;
            }
        }

        // if we're using native CSS scrollbars, we're done.  We just needed to figure out if
        // the browser was showing scrollbars.


        // if using custom scrollbars, show/hide scrollbars
        if (this.showCustomScrollbars) {
            // hide scrollbars if necessary here instead of later on, as calling scrollTo (see
            // below) will cause the other scrollbar to be redrawn if it isn't hidden yet.
            if (!this.hscrollOn && hscrollWasOn) this.hscrollbar.hide();
            if (!this.vscrollOn && vscrollWasOn) this.vscrollbar.hide();

            if (this.hscrollOn) {
                // if we need to scroll horizontally
                this._setHorizontalScrollbar();
            } else {
                // make sure we're not scrolled, scrollbar should already be hidden above.
                if (hscrollWasOn) this.scrollTo(0, null, "ending hscroll");
            }

            if (this.vscrollOn) {
                this._setVerticalScrollbar();
            } else {
                // make sure we're not scrolled, scrollbar should already be hidden above.
                if (vscrollWasOn) this.scrollTo(null, 0, "ending vscroll");
            }

            // Ensure we're not scrolled past our content

            this._clampToContent();
        }

        // default focusability is based on whether a widget scrolls, so if we have introduced
        // or removed scrolling, focusability *may* have changed.

        if ((this._useNativeTabIndex || this._useFocusProxy) &&
            wasFocusable != this._canFocus())
        {
            this._updateCanFocus();
        }

    }

    this._scrollRight = this.getScrollRight();

    return true;
},

// called during adjustOverflow.
// if our scrollHeight / scrollWidth has changed such that we're scrolled off the
// end, snap back to the end
_clampToContent : function () {
    // not scrolled, doesn't apply
    if (this.scrollLeft == 0 && this.scrollTop == 0) return;

    var maxScrollTop = Math.max(0, this.getScrollBottom()),
        maxScrollLeft = Math.max(0, this.getScrollRight()),
        newScrollLeft = this.getScrollLeft(),
        newScrollTop = this.getScrollTop(),
        clampToContent = false
    ;
    if (newScrollLeft > maxScrollLeft) {
        clampToContent = true;
        newScrollLeft = maxScrollLeft;
    }
    if (newScrollTop > maxScrollTop) {
        clampToContent = true;
        newScrollTop = maxScrollTop;
    }
    if (clampToContent) {
        this.scrollTo(newScrollLeft, newScrollTop, "clampToContent");
    }

},

// Verify that the (native) scroll position of the widget matches the recorded
// 'scrollLeft / scrollTop' properties.
// If the positions do not match, will scroll to the specified scroll position.

checkNativeScroll : function () {
    if (!this.isDrawn() || this.getScrollingMechanism() != isc.Canvas.NATIVE) return;

    var handle = this.getScrollHandle(),
        trueScrollLeft = handle.scrollLeft,
        trueScrollTop = handle.scrollTop;
    if (this.isRTL()) {
        trueScrollLeft = this._adjustScrollLeftForRTL(trueScrollLeft);
    }

    if (trueScrollLeft != this.scrollLeft || trueScrollTop != this.scrollTop) {
        //this.logWarn("noticed handle scrolled to: " +
        //             [trueScrollLeft, trueScrollTop]);

        this.scrollTo(this.scrollLeft, this.scrollTop, "removing native scroll");

    }
},

//> @method canvas._setHorizontalScrollbar()    (A)
//          Creates a horizontal custom scrollbar on a widget
//          returns true for success, false for failure
//      @group  scrolling
//
//<
_setHorizontalScrollbar : function () {

    // if the horizontal scrollbar hasn't been created, do so
    var scrollbar = this.hscrollbar;
    if (!scrollbar) {
        scrollbar = this.hscrollbar = isc.ClassFactory.newInstance(this.scrollbarConstructor,
        {
            ID:this.getID()+"_hscroll",
            autoDraw:false,
            _generated:true,
            zIndex:this.getZIndex() +1,
            showThumbTriggerArea:isc.Browser.isTouch,
            vertical:false,
            scrollTarget:this,
            visibility:this.visibility,
            _redrawWithMaster:false,
            _resizeWithMaster:false,
            _redrawWithParent:false,
            _selfManaged:false
        });
    }


    if (!isc.Page.isLoaded()) {
        var theCanvas = this;
        isc.Page.setEvent("load", function () {
            if (!theCanvas.destroyed) theCanvas._setHorizontalScrollbar()
        });
        return;
    }

    // the need for scrolling may go away while we are waiting to draw
    if (!this.hscrollOn) return;

    scrollbar.setRect(this.getOffsetLeft() + this.getLeftMargin() +
                        (this.vscrollOn && this.isRTL() ? this.getCustomScrollbarSize() : 0),
                      this.getOffsetTop() + this.getHeight() -
                              (this.getBottomMargin() + this.getCustomScrollbarSize()),
                      this.getOuterViewportWidth(),
                      this.getCustomScrollbarSize());

    if (!scrollbar.masterElement) {
        // if we haven't added it as a peer yet, add it (which will draw it)
        this.addPeer(scrollbar);
    } else {
        // otherwise show it
        if (this.visibility != isc.Canvas.HIDDEN) scrollbar.show();
    }
},


// when we're creating a custom scrollbar - this method returns a size for the sb.
// Usually governed by this.scrollbarSize - however if we're using the special "NativeScrollbar"
// class we need to ask that to give us the size the scrollbar will render at -- we can't
// control this.
getCustomScrollbarSize : function () {
    var scrollbarClass = this.scrollbarConstructor;
    if (isc.isA.String(scrollbarClass)) scrollbarClass = isc[scrollbarClass];

    if (isc.NativeScrollbar != null &&
        scrollbarClass == isc.NativeScrollbar) return isc.NativeScrollbar.getScrollbarSize();
    return this.scrollbarSize;
},

//> @method canvas._makeVerticalScrollbar() (A)
//          Creates a vertical custom scrollbar on a widget
//          returns true for success, false for failure
//      @group  scrolling
//<
_setVerticalScrollbar : function () {
    var scrollbar = this.vscrollbar
    if (!scrollbar) {
        // if the vertical scrollbar hasn't been created, do so
        scrollbar = this.vscrollbar = isc.ClassFactory.newInstance(this.scrollbarConstructor,
        {
            ID:this.getID()+"_vscroll",
            autoDraw:false,
            _generated:true,
            zIndex:this.getZIndex() +1,
            showThumbTriggerArea:isc.Browser.isTouch,
            vertical:true,
            scrollTarget:this,
            visibility:this.visibility,
            _redrawWithMaster:false,
            _resizeWithMaster:false,
            _redrawWithParent:false,
            _selfManaged:false
        });
    }

    // see _makeHorizontalScrollbar
    if (!isc.Page.isLoaded()) {
        var theCanvas = this;
        isc.Page.setEvent("load", function () {
            if (!theCanvas.destroyed) theCanvas._setVerticalScrollbar()
        });
        return;
    }

    if (!this.vscrollOn) return;

    // make sure we're showing the corner if we should be doing so
    // this will mark as dirty if necessary
    scrollbar.setShowCorner(this.hscrollOn && this.vscrollOn);

    scrollbar.setRect(
        this.getOffsetLeft() +
            (this.isRTL() ? this.getLeftMargin() :
                            this.getWidth() - (this.getRightMargin() + this.getScrollbarSize())),
        this.getOffsetTop() + this.getTopMargin(),
        this.getScrollbarSize(),
        this.getHeight() - this.getVMarginSize()
    );

    if (!scrollbar.masterElement) {
        // if we haven't added it as a peer yet, add it (which will draw it)
        this.addPeer(scrollbar);
    } else {
        // otherwise show it
        if (this.visibility != isc.Canvas.HIDDEN) scrollbar.show();
    }
},

// Scrollbar API
// -----------------------------------------------------------------------------------------
// Principally used by custom scrollbars

// scroll by slightly less than one viewport (less than in order to keep context)
scrollByPage : function (vertical, direction, reason) {
    var distance = (vertical ? this.getViewportHeight() : this.getViewportWidth()) -
             this.scrollDelta;
    this._scrollByAmount(vertical, direction * distance,
                         reason || "scrollByPage");
},

// scroll by one (arbitrary) increment
scrollByDelta : function (vertical, direction, reason) {
    this._scrollByAmount(vertical, direction * this.scrollDelta,
                         reason || "scrollByDelta");
},

_scrollByAmount : function (vertical, amount, reason) {
    if (vertical) {
        this.scrollTo(null, this.getScrollTop() + amount, reason);
    } else {
        this.scrollTo(this.getScrollLeft() + amount, null, reason);
    }
},

canScroll : function (vertical) {
    var scrollSize = vertical ? this.getScrollHeight() : this.getScrollWidth(),
        viewportSize = vertical ? this.getViewportHeight() : this.getViewportWidth();
    return (scrollSize > viewportSize);
},

// get the amount scrolled as a proportion of the maximum scroll amount, as a number between 0
// and 1
getScrollRatio : function (vertical) {
    var scrollSize = vertical ? this.getScrollHeight() : this.getScrollWidth(),
        viewportSize = vertical ? this.getViewportHeight() : this.getViewportWidth(),
        scrollPosition = vertical ? this.getScrollTop() : this.getScrollLeft(),
        // the furthest viewport position is when the viewport is showing the end of the
        // scrollable area
        maxScrollPosition = scrollSize - viewportSize;

    //this.logWarn("scrollSize: " + scrollSize +
    //             ", scrollPosition: " + scrollPosition);

    if (maxScrollPosition == 0) return 0;
    return scrollPosition / maxScrollPosition;
},

// scroll to some ratio of the maximum scroll amount
scrollToRatio : function (vertical, ratio, reason) {
    var maxScroll = Math.max(0, (vertical ? this.getScrollBottom() : this.getScrollRight())),
        newCoord = Math.round(maxScroll * ratio),
        reason = reason || "scrollToRatio";
    if (vertical) {
        this.scrollTo(null, newCoord, reason);
    } else {
        this.scrollTo(newCoord, null, reason);
    }
},

// get the ratio of the viewport size vs total content (used for thumb sizing)
getViewportRatio : function (vertical) {
    if (vertical) {
        return this.getViewportHeight() / this.getScrollHeight();
    } else {
        return this.getViewportWidth() / this.getScrollWidth();
    }
},

// Scrolling
// --------------------------------------------------------------------------------------------

//> @method canvas.getScrollBottom()
// Returns the scrollTop required to scroll vertically to the end of this widget's content.
// @return (int) scroll bottom coordinate
// @group scrolling
// @visibility external
//<
getScrollBottom : function () {
    if (this.overflow == isc.Canvas.VISIBLE) return 0;
    return this.getScrollHeight() - this.getViewportHeight();
},

//> @method canvas.getScrollRight()
// Returns the scrollLeft required to scroll horizontally to the end of this widget's content.
// @return (int) scroll bottom coordinate
// @group scrolling
// @visibility external
//<
getScrollRight : function () {
    if (this.overflow == isc.Canvas.VISIBLE) return 0;
    return this.getScrollWidth() - this.getViewportWidth();
},


//> @method canvas.scrollToTop()
// Vertically scrolls the content of the widget to 0
//
// @group scrolling
// @visibility external
//<
scrollToTop : function () {
    this.scrollTo(null, 0, "scrollToTop");
},
//> @method canvas.scrollToBottom()
// Vertically scrolls the content of the widget to the end of its content
//
// @group scrolling
// @visibility external
//<
scrollToBottom : function () {
    this.scrollTo(null, this.getScrollBottom(), "scrollToBottom")
},

//> @method canvas.scrollToLeft()
// Horizontally scrolls the content of the widget to 0
//
// @group scrolling
// @visibility external
//<
scrollToLeft : function () {
    this.scrollTo(0, null, "scrollToLeft");
},
//> @method canvas.scrollToRight()
// Horizontally scrolls the content of the widget to the end of its content
//
// @group scrolling
// @visibility external
//<
scrollToRight : function () {
    this.scrollTo(this.getScrollRight(), null, "scrollToRight");
},

//> @method canvas.scrollBy()
// Scroll this widget by some pixel increment in either (or both) direction(s).
//
// @param dX (number) Number of pixels to scroll horizontally
// @param dY (number) Number of pixels to scroll vertically
// @group scrolling
// @visibility external
//<
scrollBy : function (dX, dY, reason) {
    var left, top;
    if (dX != null) left = this.getScrollLeft() + dX;
    if (dY != null) top = this.getScrollTop() + dY;

    return this.scrollTo(left, top, reason || "scrollBy");
},

//> @method canvas.scrollByPercent()   ([])
//  Scroll this widget by some percentage of scroll size in either (or both) direction(s).
//
//      @visibility external
//      @param  dX  (number | string)    Percentage to scroll horizontally. Will accept either
//                                      a numeric percent value, or a string like "10%".
//      @param  dY  (number | string)    Percentage to scroll horizontally. Will accept either
//                                      a numeric percent value, or a string like "10%".
//      @group  scrolling
//<
scrollByPercent : function (dX, dY) {
    if (isc.isA.String(dX)) dX = parseInt(dX);
    if (isc.isA.String(dY)) dY = parseInt(dY);

    // Resolve bad coordinates or null values to zero
    if (!isc.isA.Number(dX)) dX  = 0;
    else
        // Note - "100%" scrolled is scrolled to the the scrollHeight - viewport height, as we're
        // moving the top / left edge of the viewport.
        dX = parseInt( dX / 100 * Math.max(0, (this.getScrollWidth()-this.getViewportWidth()) ) );
    if (!isc.isA.Number(dY)) dY  = 0;
    else
        dY = parseInt( dY / 100 * Math.max(0, (this.getScrollHeight()-this.getViewportHeight()) ) );

    this.scrollBy(dX, dY);
},

//> @method canvas.scrollTo()   ([])
// Scrolls the content of the widget so that the origin (top-left corner) of the content
// is left pixels to the left and top pixels above the widget's top-left corner (but still
// clipped by the widget's dimensions).
// <p>
// This is guaranteed to be called whenever this Canvas is scrolled, whether scrolling is
// initiated programmatically, by custom scrollbars, or a by a native scrollbar.
//
//      @visibility external
//      @group  scrolling
//      @param  [left]  (Integer)    the left coordinate
//      @param  [top]   (Integer)    the top coordinate
//<
//>Animation additional 'animating' parameter passed if this is part of an animated scroll
//<Animation
scrollTo : function (left, top, reason, animating) {
//!DONTOBFUSCATE this function is legal to observe and grab parameters
   if (isc._traceMarkers) arguments.__this = this;
    //>Animation
    if (!animating) {
        if (this.scrollAnimation) this.finishAnimation("scroll");
        // We slide in and out of view by adjusting scroll positions - if we're in the middle
        // of such an animation, just suppress future scrolls.

        if (this.hideAnimation && this.$hideAnimationInfo.slideOut)
            this.$hideAnimationInfo.slideOut = false;
        if (this.showAnimation && this.$showAnimationInfo.slideIn)
            this.$showAnimationInfo.slideIn = false;
    }
    //<Animation

    //>DEBUG
    if (this.logIsDebugEnabled("scrolling")) {
        this.logDebug("scrollTo(" + left + ", " + top +
                      "), reason: " + reason, "scrolling");
    } //<DEBUG

    if (left == null) {
        left = this.getScrollLeft();
    }

    if (top == null) {
        top = this.getScrollTop();
    }

    // if scrolling is actually occuring
    var actuallyMoved = false;
    if ((left != null && left != this.scrollLeft) || (top != null && top != this.scrollTop)) {
        actuallyMoved = true;
        // save off the last scroll coordinates, to allow detecting scrolling direction
        this.lastScrollLeft = this.scrollLeft;
        this.lastScrollTop = this.scrollTop;
        //this.logWarn("left, top: " + [left, top] +
        //             ", scrollLeft/Top: " + [this.scrollLeft, this.scrollTop]);
        this.lastScrollDirection = (left != null && left != this.scrollLeft &&
                                    top != null && top != this.scrollTop ? "both" :
                                    top != null && top != this.scrollTop ? "vertical" :
                                    "horizontal");
    }

    // if we're responding to a native scroll event, the viewport has already been scrolled by
    // the browser - we're just being notified, and we only call this method for the sake of
    // observers, and to update custom scrollbar thumbs. In this case, or if we haven't yet
    // been drawn, just store the passed in values.
    if (reason == "nativeScroll" || !this.isDrawn()) {
        this.scrollLeft = left;
        this.scrollTop = top;
    } else {
        // Don't scroll past the ends of the widget - this way the callers don't have to worry
        // about passing in good parameters.

        var maxScrollLeft = this.getScrollRight();
        this.scrollLeft = Math.max(0, Math.min(maxScrollLeft, left));
        var maxScrollTop = this.getScrollBottom();
        this.scrollTop = Math.max(0, Math.min(maxScrollTop, top));



        // Actually scroll the widget.
        this._scrollHandle(this.scrollLeft, this.scrollTop);
    }

    // update thumb position and size.  NOTE: because scrollbar construction is delayed under
    // some circumstances, we might not have a scrollbar yet even if scroll is on.
    if (this.showCustomScrollbars) {
        if (this.hscrollOn && this.hscrollbar) this.hscrollbar.setThumb();
        if (this.vscrollOn && this.vscrollbar) this.vscrollbar.setThumb();
    }

    // fire notification of scroll change
    if (actuallyMoved) this._scrolled(this.lastScrollLeft - this.scrollLeft,
                                      this.lastScrollTop  - this.scrollTop);
},


// canvas.scrolled()
//  Observable method called whenever a Canvas is explicitly moved.
//  Documented under registerStringMethods
scrolled : function (deltaX, deltaY) {},

_scrolled : function (deltaX, deltaY) {
    // If the mouse is over us and we scrolled (for example due to mouse wheel scroll / drag scroll)
    // fire a synthetic mousemove event on the event target
    // This means we can react to the fact that the mouse's position over our content has changed
    // (EG: update styling on list grid rows as the user scrolls with the mouse-wheel)


    if (!isc.EH._handlingMouseMove && !isc.Browser.nativeMouseMoveOnCanvasScroll) {
        this._fireSyntheticMouseMove();
    }

    // fix dotted focus outline leaving artifacts over the handle in IE
    if (this.hasFocus && isc.Browser.isIE9) {
        this._fixIEFocusScrollArtifacts();
    }
    this._fireParentScrolled(this, deltaX, deltaY);

    if (this.scrolled) this.scrolled(deltaX, deltaY);

    if (this._iosScrollFixInProgress) {
        this._iosScrollFixInProgress = false;
    }
},

// In IE9 and above, a scroll on an element showing the native focus outline leaves
// odd scrolling artifacts on the scrolled widget (as if the scroll outline shifted with
// the handle and was never cleared).
// We've had multiple reports on the forums and it's easy to reproduce.
// Touching the handle clears these lines (and is quicker than a redraw).

_redrawToFixIEFocusScrollArtifacts:false,
_fixIEFocusScrollArtifacts : function () {

    if (this._redrawToFixIEFocusScrollArtifacts) {
        // use fireOnPause to minimize redraws (Even though this means the lines sit there for
        // a few ms)
        this.fireOnPause("redrawToFixIEFocusScrollArtifacts",
            {target:this, methodName:"markForRedraw", args:["fixIEScrollArtifacts"]},
            100);
    } else {
        var style = this.getStyleHandle();
        // trivial touch is sufficient to clear the odd focus-outline scroll artifacts
        if (style) style.backgroundColor = style.backgroundColor;
    }
},

// Helper method - if the mouse is over a widget and it scrolls, fire a synthetic
// mouseMove event to reflect the fact that the mouse-position has changed relative to
// the content of the widget
_fireSyntheticMouseMove : function () {

    // We only want to fire a mouse move if we are the current mouse target or a parent
    // of it.
    // This avoids cases where the mouse isn't over us, or some non child is occluding us
    // like an external drag-target.

    // Determine the target for the mouse move event based on event.target or
    // event.lastMoveTarget for non-mouse events.
    var lastEvent = isc.EH.lastEvent,
        isMouseEvent = isc.EH.isMouseEvent(lastEvent.eventType),
        currentlyOver =  isMouseEvent ? lastEvent.target : isc.EH.lastMoveTarget;

    if (currentlyOver != null) {
        if (!this.contains(currentlyOver, true)) currentlyOver = null;

        // If this was a mouse event, assume the reported target on the event is accurate
        //
        // Otherwise we're relying on the captured lastMoveTarget which was updated
        // last time mouseMove fired.
        // This may be out of date due to a scroll shifting the target out from under
        // the mouse -- will only happen if the lastMoveTarget is a child of the
        // widget that was scrolled (us).
        // In this case, check visibleAtPoint() to ensure the mouse is still over the
        // target. Pass this component in as the "upToParent" to make the method more
        // efficient. This asserts that the mouse is over our viewport somewhere - a
        // reasonable assumption since it was at the last mouseMove, and our scroll may
        // shift our childrens' page coords but won't change ours.


        else if (!isMouseEvent && currentlyOver != this) {
            var offsetX = this.getOffsetX(),
                offsetY = this.getOffsetY();

            if (!currentlyOver.visibleAtPoint(isc.EH.getX(), isc.EH.getY(),
                false, null, this))
            {
                currentlyOver = null;
            }
        }


        if (currentlyOver != null) {
            this._firingSyntheticMouseMove = true;
            isc.EH._handleMouseMove(null, isc.EH.lastEvent);
            delete this._firingSyntheticMouseMove;
        }
    }
},
// canvas.parentMoved()
//  Observable method called whenever a Canvas's ancestor is explicitly moved.
//  Documented under registerStringMethods
parentScrolled : function (parent, deltaX, deltaY) {},

// If our parent has scrolled, inform any children we have that an ancestor has scrolled.
// This notifies the children that they will have been repositioned in terms of page
// coordinates.
handleParentScrolled : function (parent, deltaX, deltaY) {


    if (isc.Element.cacheOffsetCoords) this._$leftCoords = this._$topCoords = null;
    this.parentScrolled(parent, deltaX, deltaY);

    // fireParentScrolled is what notifies our children (recursively) that we scrolled.
    this._fireParentScrolled(parent, deltaX, deltaY);
},

// fire 'handleParentScrolled' on children. This will recursively call back into this
// method to notify all descendents.
_fireParentScrolled : function (parent, deltaX, deltaY) {
    var children = this.children;
    if (children != null) {
        for (var i = 0; i < children.length; i++) {
            // NOTE: this fires before during init, before children have necessarily been
            // auto-created
            if (isc.isA.Canvas(children[i])) {
                children[i].handleParentScrolled(parent, deltaX, deltaY);
            }
        }
    }
},


_childrenCoordsChanged : function () {
    if (!isc.Element.cacheOffsetCoords) return;

    var children = this.children;
    if (children != null) {
        for (var i = 0, len = children.length; i < len; ++i) {
            var child = children[i];
            // clear offsetCoords cache
            child._$leftCoords = child._$topCoords = null;
            child._childrenCoordsChanged();
        }
    }
},


_reapplyWebkitOverflowScrollingTouchTimer: null,
_reapplyWebkitOverflowScrollingTouch : function () {

    this._reapplyWebkitOverflowScrollingTouchTimer = null;

    if (!this.isDrawn() || !this._usingNativeTouchScrolling() ||
        (!this.isVisible() && (this.hideUsingDisplayNone || this._hideUsingDisplayNoneCounter > 0)) ||
        (isc.Browser.iOSVersion >= 7 && this._offsetCoordsCacheDisabled))
    {
        return;
    }

    var styleHandle = this.getStyleHandle();
    styleHandle.WebkitOverflowScrolling = "touch";
},

_offsetCoordsCacheDisabled: false,

_disableOffsetCoordsCaching : function () {
    if (!isc.Element.cacheOffsetCoords || !this.isDrawn() || this._offsetCoordsCacheDisabled) return;

    if (isc.Browser.iOSVersion >= 7 &&
        isc.Browser._supportsWebkitOverflowScrolling && this._usingNativeTouchScrolling())
    {
        if (this._reapplyWebkitOverflowScrollingTouchTimer != null) {
            isc.Timer.clear(this._reapplyWebkitOverflowScrollingTouchTimer);
            this._reapplyWebkitOverflowScrollingTouchTimer = null;
        }
        var styleHandle = this.getStyleHandle();
        styleHandle.WebkitOverflowScrolling = "auto";
    }

    this._$leftCoords = this._$topCoords = null;
    this._offsetCoordsCacheDisabled = true;
    this._origCacheOffsetCoords = this.cacheOffsetCoords;
    this.cacheOffsetCoords = false;

    var children = this.children;
    if (children != null) {
        for (var i = 0, len = children.length; i < len; ++i) {
            children[i]._disableOffsetCoordsCaching();
        }
    }
},

_enableOffsetCoordsCaching : function () {
    if (!isc.Element.cacheOffsetCoords || !this.isDrawn() || !this._offsetCoordsCacheDisabled) return;

    if (isc.Browser.iOSVersion >= 7 &&
        isc.Browser._supportsWebkitOverflowScrolling && this._usingNativeTouchScrolling())
    {
        if (this._reapplyWebkitOverflowScrollingTouchTimer != null) {
            isc.Timer.clear(this._reapplyWebkitOverflowScrollingTouchTimer);
        }
        this._reapplyWebkitOverflowScrollingTouchTimer = this.delayCall("_reapplyWebkitOverflowScrollingTouch");
    }

    this._offsetCoordsCacheDisabled = false;
    this.cacheOffsetCoords = this._origCacheOffsetCoords;
    delete this._origCacheOffsetCoords;

    var children = this.children;
    if (children != null) {
        for (var i = 0, len = children.length; i < len; ++i) {
            children[i]._enableOffsetCoordsCaching();
        }
    }
},

//> @method canvas.scrollToPercent()   ([])
//  Scroll this widget to some position specified as a percentage of scroll size in either
// (or both) direction(s).
//
//      @visibility external
//      @param  left (number | string)    Left Percentage position to scroll to
//                                        Will accept either a numeric percent value, or a
//                                        string like "10%".
//      @param  top (number | string)    Top Percentage position to scroll to
//                                       Will accept either a numeric percent value, or a
//                                       string like "10%".
//      @group  scrolling
//<
scrollToPercent : function (left, top, reason) {
    if (isc.isA.String(left)) left = parseInt(left);
    if (isc.isA.String(top)) top = parseInt(top);


    //
    // Note - "100%" scrolled is scrolled to the the scrollHeight - viewport height, as we're
    // moving the top / left edge of the viewport.
    if (left != null) {
        if (!isc.isA.Number(left)) left = 0; // Resolve bad coordinates
        left = parseInt(left / 100 * Math.max(0, (this.getScrollWidth() -
                                                  this.getViewportWidth())));
    }
    if (top  != null) {
        if (!isc.isA.Number(top))  top  = 0; // Resolve bad coordinates
        top = parseInt(top / 100 * Math.max(0, (this.getScrollHeight() -
                                                this.getViewportHeight())));
    }

    this.scrollTo(left, top, reason || "scrollToPercent");
},


_adjustScrollLeftForRTL : function (left, isSCCoords) {
    // Moz / Old IE -- scrolled hard left reported as negative values - we want to remap to
    // a zero-origin based system
    var adjustForNegativeOrigin =
            isc.Browser.isMoz || (isc.Browser.isIE && isc.Browser.minorVersion < 5.5),
        // IE9 with HTML5 doctype inverts the origin, so zero is hard right and the scrollLeft
        // reported value increases as the user scrolls leftwards.
        // Ditto with IE8 [tested with both HTML5 doctype and HTML4.01 strict doctype]
        // Backcompat mode (no doctype specified) does not inverse the origin.
        adjustForInverseOrigin = (isc.Browser.isIE8 || isc.Browser.isIE9)
                                 && isc.Browser.isStrict;

    if (!adjustForNegativeOrigin && !adjustForInverseOrigin) return left;

    var scrollWidth = this.getScrollWidth(),
        viewportWidth = this.getViewportWidth();
    return isc.Canvas._adjustScrollLeftForRTL(left, scrollWidth, viewportWidth, isSCCoords,
        adjustForNegativeOrigin, adjustForInverseOrigin);
},


_shiftScrollLeftOrigin : function (left, zeroToNegativeOrigin) {
    var scrollWidth = this.getScrollWidth(),
        viewportWidth = this.getViewportWidth();
    return isc.Canvas._adjustScrollLeftForRTL(left, scrollWidth, viewportWidth,
                        zeroToNegativeOrigin, true);
},

//> @method canvas._scrollHandle()   (IA)
// Internal method to scroll the widget's viewport to the left / top coordinates passed in.
// Called by canvas.scrollTo();
//
//      @visibility internal
//      @group  scrolling
//      @param  left    (number)    the left coordinate
//      @param  top (number)    the top coordinate
//      @see    scrollTo()
//<
_scrollHandle : function (left, top) {

    var scrollMechanism = this.getScrollingMechanism();

    // for browsers that support setting scrollLeft/scrollTop to scroll.
    if (scrollMechanism == isc.Canvas.NATIVE) {

        if (this.isRTL()) {
            left = this._adjustScrollLeftForRTL(left, true);
        }

        var handle = this.getScrollHandle();
        if (handle) {
            // set a flag to tell '_handleCSSScroll' to No-Op while the scroll is in progress
            this._scrollingHandleDirectly = true;

            handle.scrollLeft = left;
            handle.scrollTop = top;




            var newScrollLeft = handle.scrollLeft,
                newScrollTop = handle.scrollTop;
            if (this.isRTL()) {
                newScrollLeft = this._adjustScrollLeftForRTL(newScrollLeft);
            }

            if (newScrollLeft != this.scrollLeft || newScrollTop != this.scrollTop) {

                //this.logWarn("handle clamping scrollLeft/Top at: " +
                //             [newScrollLeft, newScrollTop] +
                //             " tried to assign: " + [this.scrollLeft, this.scrollTop]);
                this.scrollLeft = newScrollLeft;
                this.scrollTop = newScrollTop;
            }


            delete this._scrollingHandleDirectly;

        }

    // scrolling mechanisms for browsers in which assigning to handle.scrollLeft/scrollTop
    // doesn't work.
    } else if (scrollMechanism == isc.Canvas.NESTED_DIV) {
        // move the contentDiv around within the clipDiv to create scrolling

        // Note that the contentDiv's parent is the clipDiv, and the contentDiv is always drawn
        // at (0,0) within the clipDiv, so we don't worry about left and top with respect to a
        // parent, since that applies only to the clipDiv and it's parent.

        // get the contentDiv
        var handle = this.getHandle();
        if (handle == null) {
            //>DEBUG this happens to ListGrid headers in NS6 when the LV scrolls it on
            // LV.draw().
            this.logWarn(this.getCallTrace(arguments) + " in NS6 with null handle");
            //<DEBUG
            return;
        }
        // Grab the style attribute for the handle
        handle = handle.style;

        if (this.isRTL()) {
            left = this._shiftScrollLeftOrigin(-left);
            top = -top;
        } else {
            left = -left;
            top = -top;
        }

        //this.logWarn("handle is at: " + [handle.left, handle.top] +
        //             ", moving to: " + [-this.scrollLeft, -this.scrollTop]);
        // move it within the clipDiv to create scrolling
        handle.left = left + this._$px;
        handle.top = top + this._$px;
    
    }

},


// Handle a native scroll event

_$nativeScroll: "nativeScroll",
_handleCSSScroll : function (waited, fromFocus) {
    if (isc._traceMarkers) arguments.__this = this;

    // The contents of the Canvas have already been scrolled by the browser, and we're just
    // being notified of it.


    if (this._scrollingHandleDirectly) return;

    // Avoid attempting to handle a delayed scroll if the widget in question has been cleared
    if (!this.isDrawn()) return;

    var scrollMechanism = this.getScrollingMechanism();
    if (scrollMechanism != isc.Canvas.NATIVE) {
        this.logWarn("unsupported native scroll occurred on this widget - resetting");
        var handle = this.getScrollHandle();
        if (scrollMechanism == isc.Canvas.NESTED_DIV) {
            this._scrollHandle(this.isRTL() ? this.getScrollRight() : 0, 0);
        } else {
            this._scrollHandle(this.scrollLeft, this.scrollTop);
        }
        return;
    }

    //>Moz

    if (isc.Browser.isMoz && !waited && (fromFocus ||  isc.Browser.geckoVersion < 20030312)) {
        if (!this._scrollTimeout)
            this._scrollTimeout = this.delayCall("_handleCSSScroll", [true], 10);
        return;
    }
    this._scrollTimeout = null;
    //<Moz

    var trueScrollLeft = this.getScrollLeft(),
        trueScrollTop = this.getScrollTop();

    // if our notion of the scroll position matches the DOM's - just return
    if (trueScrollLeft == this.scrollLeft && trueScrollTop == this.scrollTop) return;

    // Even though the native element has already scrolled, we call scrollTo to update
    // this.scrollLeft/Top, and to cause any scrollTo overrides or observations to fire


    isc.EH._setThread("SCR");
    this.scrollTo(trueScrollLeft, trueScrollTop, this._$nativeScroll);
    isc.EH._clearThread();
},


mouseWheel : function () {
    // If the horizontal and/or vertical custom scrollbar is/are showing, then update the scroll
    // position based on the wheelDeltaX/wheelDeltaY.
    if ((this.overflow == isc.Canvas.AUTO || this.overflow == isc.Canvas.SCROLL) &&
        this.showCustomScrollbars && (this.vscrollOn || this.hscrollOn))
    {
        var wheelDeltaY = this.ns.EH.lastEvent.wheelDeltaY,
            wheelDeltaX = this.ns.EH.lastEvent.wheelDeltaX;
        // For each increment the user scrolled the mouse wheel, we want to move about 50px
        // This seems to approximately match native scrolling speed.
        var scrollTop =
                this.scrollTop + Math.round(wheelDeltaY * isc.Canvas.scrollWheelDelta);
        var scrollLeft =
                this.scrollLeft + Math.round(wheelDeltaX * isc.Canvas.scrollWheelDelta);

        // Note that scrollTo already catches scrolling past beginning or end
        this.scrollTo(scrollLeft, scrollTop, "mouseWheel");

        // return false to cancel further / native processing
        return false;
    }

    // Not a scrollable region, return true
    return true;
},

// Helpers to determine if this was a 'fast' scrolling mechanism - track scroll / drag scroll
isDragScrolling : function () {
    if (this.vscrollOn && this.vscrollbar && this.vscrollbar.isDragScrolling()) return true;
    if (this.hscrollOn && this.hscrollbar && this.hscrollbar.isDragScrolling()) return true;
    return false;
},

isRepeatTrackScrolling : function () {
    if (this.vscrollOn && this.vscrollbar && this.vscrollbar.isRepeatTrackScrolling()) return true;
    if (this.hscrollOn && this.hscrollbar && this.hscrollbar.isRepeatTrackScrolling()) return true;
    return false;
},

isMouseWheelScrolling : function () {
    return isc.EH.lastEvent.eventType == isc.EH.MOUSE_WHEEL;
},

// Default Keyboard Handling
// --------------------------------------------------------------------------------------------
// Canvases have built-in scrolling and focus change behavior for keyboard events

//> @method canvas.handleKeyPress()     (A)
//  Canvas level handler function for the (possibly bubbled) keyPress event, fired by the event
//  handling system when the user presses a key on a focus'd widget.
//  Fires any user-defined 'keyPress' handler string method.
//  Scrolls the widget on arrow keypresses
//      @group  events
//
//      @param  event   (ISC Event object)
//      @param  eventInfo   (object)
//<

handleKeyPress : function (event, eventInfo) {
    var keyPressReturn;

    // If a keypress string method handler is defined, call it before firing standard scrolling
    // logic
    if (this.convertToMethod("keyPress")) {
        keyPressReturn = this.keyPress(event, eventInfo);
    }


    if (keyPressReturn != false && this.shouldCancelKey != null  &&
        this.shouldCancelKey(event, eventInfo))
    {
        keyPressReturn = false;
    }

    if (keyPressReturn == false) return false;

    // widgetHandleKeyPress() is a method that individual components can override in order to
    // add widget-specific keyPress-handling that takes precedence over normal Canvas
    // keyPress handling, but does not interfere with custom keyPress handlers or require
    // user code to invoke Super()
    if (this.widgetHandleKeyPress) {
        keyPressReturn = this.widgetHandleKeyPress(event, eventInfo);
        if (keyPressReturn == false) return false;
    }

    var keyName = event.keyName;

    if (this._useFocusProxy &&
        ((isc.Browser.isMoz && this.canSelectText) || isc.Browser.isSafari)
        && keyName == "Tab")
    {
        this.setFocus(true);
    }


    // if using custom scrollbars, scroll if standard scrolling keys are hit

    if ((this.overflow == isc.Canvas.AUTO || this.overflow == isc.Canvas.SCROLL) &&
         this.showCustomScrollbars)
    {
        keyPressReturn = this.handleKeyboardScroll(keyName);
    }
    return keyPressReturn;
},

handleKeyboardScroll : function (keyName, reason) {

        if (isc.EH.ctrlKeyDown() || isc.EH.altKeyDown()) return;

        var leftDelta = 0, topDelta = 0;

        // pageUp/Down: scroll one viewport
        if (keyName == "Page_Up") topDelta -= this.getViewportHeight();
        else if (keyName == "Page_Down") topDelta += this.getViewportHeight();
        // arrows: scroll a small amount
        else if (keyName == "Arrow_Up") topDelta -= 10; // Maybe make this a var?
        else if (keyName == "Arrow_Down") topDelta += 10;
        else if (keyName == "Arrow_Left") leftDelta -= 10;
        else if (keyName == "Arrow_Right") leftDelta += 10;

        reason = reason || "cancel native keyPress scrolling";
        if (leftDelta != 0 || topDelta != 0) {
            // NOTE: scrollTo automatically clamps
            this.scrollTo(this.scrollLeft + leftDelta, this.scrollTop + topDelta, reason);

            // return false so the event doesn't get propagated
            return false;
        }

        // Home / End - go to the top or bottom
        if (keyName == "Home") {
            this.scrollTo(null, 0, reason);
            return false;
        } else if (keyName == "End") {
            this.scrollTo(null, (this.getScrollHeight() - this.getViewportHeight()), reason);
            return false;
        }
},


//> @method canvas.pageScrollUp()
// This method is the programmatic equivalent of the user pressing the "Page Up" key while
// this widget has the focus.  It scrolls the widget's content upwards by the viewport
// height, if the content can be scrolled that far upwards
// @visibility external
//<
pageScrollUp : function () {
    this.handleKeyboardScroll("Page_Up", "canvas.pageScrollUp()");
},

//> @method canvas.pageScrollDown()
// This method is the programmatic equivalent of the user pressing the "Page Down" key while
// this widget has the focus.  It scrolls the widget's content downwards by the viewport
// height, if the content can be scrolled that far downwards
// @visibility external
//<
pageScrollDown : function () {
    this.handleKeyboardScroll("Page_Down", "canvas.pageScrollDown()");
},


handleKeyDown : function (event,eventInfo) {
    // If a keyDown string method handler is defined, call it before firing standard scrolling
    // logic
    var keyDownReturn
    if (this.convertToMethod("keyDown")) {
        keyDownReturn = this.keyDown(event, eventInfo);
    }
    return keyDownReturn;
},

// --------------------------------------------------------------------------------------------

//> @method canvas._setHandleRect() (A)
//          (internal) routine to set the rectangle of the canvas handle to its
//          .left, .top, .width, .height
//      @group  positioning, sizing
//
//      @param  left    (number)
//      @param  top     (number)
//      @param  width   (number)
//      @param  height  (number)
//<


_setHandleRect : function (left, top, width, height) {
    // Bail if we're not actually drawn (have no handle to position)
    var styleHandle = this.getStyleHandle();
    if (styleHandle == null) return;

    // Bail if element is already hidden and shrinkElementOnHide is true. We want the actual handle
    // to still remain at 1x1 size until element is visible again.
    if(this.shrinkElementOnHide && !this.isVisible()) {
        return;
    }




    

    // In RTL mode, we need to shift the handle to the right of the v-scrollbar if appropriate
    if (this.showCustomScrollbars && this.vscrollOn && left != null && this.isRTL()) {
        left += this.getScrollbarSize();
        //this.logWarn("adjusting left coordinate for RTL:" + left + this.getStackTrace());
    }

    // Call the '_adjustHandleSize' helper method to determine the width/height
    // values we will actually apply to the handle to get the desired size.
    // This corrects for the space required by custom scrollbars, and for border, padding, etc.
    if (width != null || height != null) {
        var adjustedSize = this._adjustHandleSize(width, height);

        width = adjustedSize[0];
        height = adjustedSize[1];
    }
    //this.logWarn("assigning size of: " + [width, height]);

    this._assignRectToHandle(left,top,width,height, styleHandle);
},
// This method takes the adjusted size calculated in _setHandleRect and applies it to
// the widget handle.
// Overridden in Button.js to also resize the inner-table if necessary
_data_page_spaceAttrName: "data-isc-page-space",
_assignRectToHandle : function (left,top,width,height,styleHandle) {
    if (this.containsIFrame()) {
        var iframeElem = this._getURLHandle();

        iframeElem.setAttribute("width", this.getInnerContentWidth());
        iframeElem.setAttribute("height", this.getInnerContentHeight());
    }

    if (left != null && isc.isA.Number(left)) this._assignSize(styleHandle, isc.Canvas.LEFT, left);
    if (top != null && isc.isA.Number(top)) {
        var clipHandle = this.getClipHandle(),
            pageSpace = clipHandle.getAttribute(this._data_page_spaceAttrName);
        if (pageSpace) {
            pageSpace = parseInt(pageSpace, 10);

            top += pageSpace;
        }
        this._assignSize(styleHandle, isc.Canvas.TOP, top);
    }
    if (width != null && isc.isA.Number(width)) this._assignSize(styleHandle, this._$width,
                                                                 Math.max(width,1));
    if (height != null && isc.isA.Number(height)) this._assignSize(styleHandle, this._$height,
                                                                   Math.max(height,1));
    //  this.logWarn("setHandleRect: style handle now reports: " +
    //              this.echo({left:styleHandle.left, top:styleHandle.top,
    //                         width:styleHandle.width, height:styleHandle.height}));
},

_$px : "px",
_assignSize : function (styleHandle, prop, size) {
    if (isc.Browser.isIE || isc.Browser.isOpera) {

        if ((prop == this._$width || prop == this._$height)) size = Math.max(1, size);
        if (!isc.Browser.isStrict) {

            styleHandle[prop] = size;
        } else {
            styleHandle[prop] = size + this._$px;
        }
    } else {
        if (styleHandle == null) {

            //this.logWarn(" size: " + size + ", styleHandle is: " + styleHandle);
            return;
        }
        var propVal = size + this._$px;
        styleHandle[prop] = propVal;

        if (isc.Browser.isChrome && size > 999999) {

            this._setNumericSize(prop, size);
        }

        if (styleHandle.setAttribute != null) {

            styleHandle.setAttribute(prop, propVal);
        }
    }
},

_setNumericSize : function (prop, size) {

    if (!this._numericSize) this._numericSize = {};
    this._numericSize[prop] = size;
},
_getNumericSize : function (prop) {
    if (!this._numericSize) this._numericSize = {};
    return this._numericSize[prop];
},

_sizeBackMask : function () {
    var backMask = this._backMask;
    if (!backMask) return;
    if (this.showEdges) {
        // keep the backmask from "squaring out" edges that use transparency
        var edge = this._edgedCanvas,
            // If maskEdgeCenterOnly is set, mask only the area of the center segment of the
            // edges.  Any content that overlaps the edges will still burn through.  This
            // allows a translucent Window header and other uses cases, with the drawback that
            // those areas won't be masked.
            center = this.maskEdgeCenterOnly,
            left = center ? edge._leftEdge : edge._leftMargin,
            right = center ? edge._rightEdge : edge._rightMargin,
            top = center ? edge._topEdge : edge._topMargin,
            bottom = center ? edge._bottomEdge : edge._bottomMargin,
            width = this.getVisibleWidth() - (left + right),
            height = this.getVisibleHeight() - (top + bottom);
        // NOTE: this can happen when the edgedCanvas is a background and the widget sizes
        // so that only edges are visible, eg rounded minimized window
        if (width <= 0 || height <= 0) backMask.hide();
        else {
            if (this.isVisible()) backMask.show();
            //this.logWarn("sizing backmask to: " + [width, height] + this.getStackTrace());
            backMask.setRect(this.getLeft() + left,
                             this.getTop() + top,
                             width,
                             height);
        }
    } else {
        backMask.setRect(this.getRect());
    }
},

// Text Direction
// --------------------------------------------------------------------------------------------
// Bi-directional text (BIDI) support for languages that read right to left (RTL)



//> @method canvas.getTextDirection()
//      Get the text direction of this canvas.
//      This property is determined according to the containment hierarchy
//       (like disabled) and is ultimately set by the page property if
//       not defined by any widget.
//
// @group RTL
// @group appearance
// @return (TextDirection) direction -- Canvas.LTR or Canvas.RTL
// @visibility internal
//<

getTextDirection : function () {
    if (this._textDirection) return this._textDirection;

    // start off by looking in this object
    var target = this;

    // while the target exists
    while (target) {
        // if the is not enabled, return false
        if (target.textDirection != null) {
            return (this._textDirection = target.textDirection);
        }
        // otherwise look up the parent chain
        target = target.parentElement;
        // and if an eventProxy is defined, use that instead of the parentElement
        if (target && target.eventProxy) target = target.eventProxy;
    }
    // if no widget specified a textDirection, use the Page.textDirection
    return (this._textDirection = isc.Page.getTextDirection());
},

//> @method canvas.isRTL()
// Return whether the text direction is right to left
// @return (boolean) whether text direction is RTL
//<
isRTL : function () {
    return (this.getTextDirection() == isc.Canvas.RTL);
},

//> @method canvas.getRTLSign()
// Get either one or negative one if the text direction is LTR or RTL respectively.
// <P>
// Useful for writing LTR/RTL component layout algorithms.
//
// @return (Number) 1 for LTR, -1 for RTL
//<
getRTLSign : function () {
    return this.isRTL() ? -1 : 1;
},

// Visibility
// ------------------------------------------------------------------------------------------------
// Whether this Canvas is currently visible

//> @method canvas.setVisibility()  (A)
//          set the visibility of this object
//      @group  visibility
//
//      @param  newVisibility   (string)    CSS visibility to set to (Canvas.HIDDEN,
//                                          Canvas.VISIBLE, etc)
//                              (boolean)   false == hide, anything else == show
//<
setVisibility : function (newVisibility) {
    //>Animation
    // Finish any hide/show animations that are running

    if (this._animatingHide != null && !this._hidingAsAnimation)
        this.finishAnimation(this._animatingHide);
    if (this._animatingShow != null && !this._showingAsAnimation)
        this.finishAnimation(this._animatingShow);
    // if we have any opacity change animation(s) running, finish them before changing our
    // visibility
    if (this.fadeAnimation) this.finishAnimation("fade");
    //<Animation

    // if newVisibility is a boolean, normalize to a CSS value
    if (!isc.isA.String(newVisibility)) {
        newVisibility = (newVisibility != false ? isc.Canvas.INHERIT : isc.Canvas.HIDDEN);
    }

    // no-op if no change in visibility
    if (this.visibility == newVisibility) return;

    // check if we're currently visible (NOTE: must call isVisible to check parents)
    var wasVisible = this.isVisible();

    // set the visible state of the object
    this.visibility = newVisibility;

    var isVisible = this.isVisible();

    // if we're drawn
    if (this.isDrawn()) {

        if (!wasVisible && isVisible) {

            // If we're showing a widget that is awaiting redraw, or has a child awaiting redraw,
            // redraw before showing to avoid a flash after show().
            if (this.isDirty()) {
                this.redraw("show() while dirty");

            } else if (this.children && this.children.length > 0) {

                // check for dirty children and redraw them.  Use the redraw queue to determine
                // whether we have any dirty children - quicker than iterating down through all
                // our children recursively.

                // Make a copy of the Queue, as redrawing widgets inside it will change it's
                // length, etc.
                var origRedrawQueue = isc.Canvas._redrawQueue.duplicate();

                // Note - we redraw any children directly rather than just redrawing the
                // parent, because it's more efficient -- while the parent is likely to have
                // no significant content, redrawing it could force a redraw of a number of
                // siblings
                for (var i = 0; i < origRedrawQueue.length; i++) {
                    var widget = origRedrawQueue[i];
                    // If we're the parent of a dirty child, redraw it.
                    // the isDirty() check verifies that we haven't cleaned it up by redrawing
                    // a parent in a prev iteration of this loop.
                    // Note - it's ok to leave the widget in the redraw queue, as
                    // clearRedrawQueue() will skip any widgets that are no longer dirty
                    if (widget && widget.isDirty() && this._isVisibilityAncestorOf(widget)) {
                        widget.redraw("show() on parent while dirty");
                    }
                }
            }

        }

        this._setHandleVisibility(newVisibility);


        if (isc.Canvas.ariaEnabled() && (this.ariaState == null || this.ariaState.hidden != true)) {
            this.setAriaState("hidden", !isVisible);
        }

        // Update handle.display if using hideUsingDisplayNone

        this._updateHandleDisplay();
    }

    // if we have peers, show or hide them as well
    if (this.peers) {
        for (var i = 0; i < this.peers.length; i++) {
            var peer = this.peers[i];
            // special case the scrollbars: they should generally hide and show with the
            // master, but sometimes we hide a scrollbar because we no longer need to scroll on
            // that axis, and we don't want it to get show()n when we show().
            if (isVisible &&
                ((peer == this.hscrollbar && !this.hscrollOn) ||
                 (peer == this.vscrollbar && !this.vscrollOn))) continue;
            // don't show the shadow if we're set to no longer have one (eg temporary drag
            // shadow)
            if (isVisible && peer == this._shadow && !this.showShadow) continue;
            if (peer._showWithMaster) peer.setVisibility(newVisibility);
        }
    }

    // notify children that visibility changed
    if (this.children) this.children.map("parentVisibilityChanged", newVisibility, this);

    if (this.parentElement) this.parentElement.childVisibilityChanged(this, newVisibility);

    //>FocusProxy
    // If we have a 'focusProxy' make sure it has the appropriate visibility
    if (this._useFocusProxy) this._updateFocusProxyVisibility();
    //<FocusProxy

    this._visibilityChanged();
},

// Fires the visibilityChanged notification if appropriate
// documented in registerStringMethods
// These steps always need to run when the visibility of this widget changes, even when the
// visibility is inherited from an ancestor and that ancestor's visibility changes.
_visibilityChanged : function () {
    if (!this.isDrawn()) return;
    // Set a flag tracking this.isVisible() so we only fire when
    // the actual visibility to the user changes.
    // This flag is always re-initialized on draw()
    var visible = this.isVisible();
    if (visible != this._currentlyVisible) {
        //>Animation
        if (!visible && this._momentumScrollId != null) {
            this.cancelAnimation(this._momentumScrollId);
            this._momentumScrollId = null;
        }
        //<Animation
        this._currentlyVisible = visible;
        if (this.visibilityChanged != null) {
            this.visibilityChanged(this.isVisible());
        }
    }
},

// tell our children some parent's visibility changed
parentVisibilityChanged : function (newVisibility, parent) {
    if (this.children) this.children.map("parentVisibilityChanged", newVisibility, parent);


    this._updateHandleDisplay();

    // If we have a 'focusProxy', make sure it has the appropriate visibility
    if (this._useFocusProxy) this._updateFocusProxyVisibility();

    // this._visibilityChanged() verifies that this.isVisible() actually changed
    // minor optimization: this can only happen if the parent was a visibility ancestor of this widget
    if (parent._isVisibilityAncestorOf(this)) this._visibilityChanged();
},

// notification that a child's visibility changed
childVisibilityChanged : function (child, newVisibility) {
    // NOTE: if a child uses display:none or some other custom way of hiding itself, this
    // *might* reduce content size.
    this._markForAdjustOverflow("childVisChange");
},

_incrementHideUsingDisplayNoneCounter : function () {

    var oldValue = this._hideUsingDisplayNoneCounter++;
    // If the old counter value was 0, we may need to switch on the effect of hideUsingDisplayNone.
    if (oldValue == 0) {
        this._updateHandleDisplay();
    }
},

_decrementHideUsingDisplayNoneCounter : function () {

    var oldValue = this._hideUsingDisplayNoneCounter--;
    // If the oldValue is 1, then the counter value is now 0.
    if (oldValue == 1) {
        // If hideUsingDisplayNone is set, then we still want to hide using CSS display:none.
        if (this.hideUsingDisplayNone) {
            this._updateHandleDisplay();

        // Otherwise, if we previously hid the handle via CSS display:none, then we need to
        // drop display:none and set the handle's visibility.
        } else if (this._setToDisplayNone) {

            var styleHandle = this.getStyleHandle();
            styleHandle.display = (this._visibleDisplayStyle != null ? this._visibleDisplayStyle
                                                                     : isc.emptyString);

            delete this._setToDisplayNone;
            delete this._visibleDisplayStyle;

            styleHandle.visibility = this.visibility;
        }
    }
},

// notifications that a child/peer was cleared
childCleared : function (child) { if (!this.destroying) this._markForAdjustOverflow("childClear"); },
peerCleared : function (peer) { },

childDrawn : function (child) {
    if (this.isDrawn()) this._markForAdjustOverflow("childDraw")
},
peerDrawn : function (peer) {},

//>FocusProxy
// If this widget has a 'focusProxy' - ensure it is shown and hidden with the widget

_updateFocusProxyVisibility : function () {
    if (!this._useFocusProxy || !this._hasFocusProxy) return;

    var isVisible = this.isVisible(),
        proxy = this._getFocusProxyHandle();
    if (proxy) {
        if (isVisible && proxy.style.visibility == isc.Canvas.HIDDEN)
            proxy.style.visibility = isc.Canvas.VISIBLE
        if (!isVisible && proxy.style.visibility != isc.Canvas.HIDDEN)
            proxy.style.visibility = isc.Canvas.HIDDEN
    }
},
//<FocusProxy


_needHideUsingDisplayNone : function () {
    if (isc.Browser.isTouch) {
        return this._usingNativeTouchScrolling();


    } else if (isc.Browser.isMac && isc.Element.getNativeScrollbarSize() == 0) {
        if (isc.Browser.isChrome && isc.HTMLFlow &&
            isc.isAn.HTMLFlow(this) && this.contentsType === "page")
        {
            return true;
        }
    }
    return false;
},

//> @method canvas._setHandleVisibility()   (A)
//          (internal) routine to set the visibility of the underlying DOM element.  Call
//                     setVisibility instead.
//      @group  visibility
//
//      @param  newVisibility   (string)    CSS visibility constant
//<
_setHandleVisibility : function (newVisibility) {
    var handle = this.getStyleHandle();
    if (handle != null) handle.visibility = newVisibility;

},

_$none:"none",
_updateHandleDisplay : function () {
    var hideUsingDisplayNone = this.hideUsingDisplayNone || this._hideUsingDisplayNoneCounter > 0;
    if (!hideUsingDisplayNone || !this.isDrawn()) return;

    var styleHandle = this.getStyleHandle(),
        isVisible = this.isVisible();

    if (!isVisible && !this._setToDisplayNone) {
        if (isc.Browser.iOSVersion >= 7 &&
            isc.Browser._supportsWebkitOverflowScrolling && this._usingNativeTouchScrolling())
        {
            if (this._reapplyWebkitOverflowScrollingTouchTimer != null) {
                isc.Timer.clear(this._reapplyWebkitOverflowScrollingTouchTimer);
                this._reapplyWebkitOverflowScrollingTouchTimer = null;
            }
            styleHandle.WebkitOverflowScrolling = "auto";
        }

        // save off the current state of the display property so we can restore it when the
        // component becomes visible again
        this._visibleDisplayStyle = styleHandle.display;
        this._setToDisplayNone = true;
        styleHandle.display = this._$none;


        this._$leftCoords = this._$topCoords = null;

    } else if (isVisible && this._setToDisplayNone) {
        if (isc.Browser.iOSVersion >= 7 &&
            isc.Browser._supportsWebkitOverflowScrolling && this._usingNativeTouchScrolling())
        {
            if (this._reapplyWebkitOverflowScrollingTouchTimer != null) {
                isc.Timer.clear(this._reapplyWebkitOverflowScrollingTouchTimer);
            }
            this._reapplyWebkitOverflowScrollingTouchTimer = this.delayCall("_reapplyWebkitOverflowScrollingTouch");
        }

        // if the display property had a value other than the empty string when it was in
        // visible state (picked up when we hide) we use that
        styleHandle.display = (this._visibleDisplayStyle != null ? this._visibleDisplayStyle
                                                                 : isc.emptyString);
        delete this._setToDisplayNone;
        delete this._visibleDisplayStyle;
    }
},

// Helper method: should we draw() on a call to show()?
// Returns true for top level widgets that are not peers
// (in which cases parent/master is responsible for drawing at the right time).
// Also, don't draw if we are drawn, or already in the middle of drawing
// (This can happen if a child tries to show it's parent while the parent is drawing it).
_drawOnShow : function () {
    return (this.getDrawnState() == isc.Canvas.UNDRAWN) &&
           !this.parentElement && !this.masterElement;
},

//> @method canvas.show()   ([])
// Sets this widget's visibility to "inherit", so that it becomes visible if all of its parents
// are visible or it has no parents.
// <P>
// If the widget has not yet been drawn (and doesn't have a parent or master), this method
// calls the draw method as well.
//
//      @visibility external
//      @group  visibility
//      @example    showAndHide
//<
show : function () {
    if (isc._traceMarkers) arguments.__this = this;

    var showWithFocus = this.hasFocus;

    // if we haven't yet been drawn, go ahead and do so for top level widgets
    if (this._drawOnShow()) {
        // note: passing the parameter to draw will prevent draw calling show() again when it is
        // done drawing.
        this.draw(true);
    }

    this.setVisibility(isc.Canvas.INHERIT);

    // Set size back to original width and height if we had been shrunk. Also restore the overflow.
    if(this.shrinkElementOnHide) {
        this._setHandleRect(this.getLeft(), this.getTop(), this.getWidth(), this.getHeight());
        this.getStyleHandle().overflow = this.overflow;
    }

    if (showWithFocus && this.hasFocus) {
        //>DEBUG if we were marked as having focus before being drawn, and still are, focus
        // explicitly
        this.logInfo("Show: Hidden / Undrawn widget marked as having focus - calling focus()",
                     "events"); //<DEBUG

        this.hasFocus = false;
        this.focus();
    }

    if (this.parentElement != null && this.autoShowParent) {
        this.parentElement.show();
    }
},

//> @method canvas.showRecursively()   ([])
// Recursively show the canvas and all it's parents so the canvas will be visible.
// <P>
// If the widget has not yet been drawn, this method calls the draw method as well.
//
//      @visibility external
//      @group  visibility
//<
showRecursively : function () {
    var parent = this.parentElement;
    if (this._containerID == null && parent == null) {
        this.show();
    } else {
        this.setVisibility(isc.Canvas.INHERIT);
        if (this._containerID != null) {
            parent = window[this._containerID];
        }
        parent.showRecursively();
        if (isc.TabSet != null && isc.isA.TabSet(parent)) {
            parent.selectTab(parent.tabForPane(this));
        } else if (isc.SectionStack != null && isc.isA.SectionStack(parent)) {
            parent.expandSection(parent.sectionForItem(this));
        }
    }
},

//> @method canvas.getPanelContainer()   ([])
// Returns this Canvas's "panel container".  A panel container is a widget that manages a
// collection of panels, like a +link{class:TabSet} or +link{class:SectionStack}.  If this
// Canvas is not a child of such a panel container, this method returns null.
//
// @visibility external
// @return (Canvas)   the Canvas's panel container, or null if the Canvas is not a chlld of
//                    a panel container
//<
getPanelContainer : function () {
    return this._containerID ? window[this._containerID] : null;
},

//> @method canvas.revealChild()   ([])
// For "panel container" widgets like +link{class:TabSet} or +link{class:SectionStack}, this
// method reveals the child Canvas passed in by whatever means is applicable for the particular
// type of container.  For example, when called on a TabSet, it selects the tab containing the
// passed-in child.
// <p>
// For other types of Canvas, this method simply shows the passed-in child if it is not
// currently visible.
// <p>
// If the passed-in widget is not a child of this Canvas, this method has no effect
//
// @visibility external
// @param child (ID | Canvas)   the child Canvas to reveal, or its global ID
//<
revealChild : function (child) {
    if (isc.isA.String(child)) child = window[child];
    if (child) {
        if (this.children && this.children.contains(child) && !child.isVisible()) {
            child.show();
        }
    }
},


_$relative:"relative",
_relativePageResized : function () {
    if (!this.isDrawn() || this.parentElement || this.position != this._$relative) return;

    // Fire completeMoveBy() - this will handle all our notifications such as
    // masterMoved() on our peers.
    var oldLeft = this._preResizePageLeft,
        oldTop = this._preResizePageTop,
        pageLeft = this.getPageLeft(),
        pageTop = this.getPageTop();

    this._moveDeltaX = (pageLeft - oldLeft);
    this._moveDeltaY = (pageTop- oldTop);
    this._completeMoveBy();

    // re-register for the next resized event
    this._preResizePageLeft = pageLeft;
    this._preResizePageTop = pageTop;
    isc.Page.setEvent(
        "resize",
        this,
        isc.Page.FIRE_ONCE,
        "_relativePageResized"
    );


},


//> @method canvas.hide()   ([])
//          Sets the widget's CSS visibility attribute to "hidden".
//      @visibility external
//      @group  visibility
//      @example    showAndHide
//<
hide : function () {
    this._updateFocusForHide();

    // Hide by settings size to 0x0 and overflow: hidden
    if(this.shrinkElementOnHide) {
        this.getStyleHandle().overflow = isc.Canvas.HIDDEN;
        this._setHandleRect(this.left, this.top, 0, 0);
    }

    this.setVisibility(isc.Canvas.HIDDEN);
},

//> @method canvas.isVisible()  ([])
// Returns true if the widget is visible, taking all parents into account, so that a widget
// which is not hidden might still report itself as not visible if it is within a hidden
// parent.
// <P>
// NOTE: Undrawn widgets will report themselves as visible if they would be visible if drawn.
//
//      @visibility external
//      @group  visibility
//
//      @return (boolean)   true if the widget is visible, false otherwise
//<
isVisible : function () {
    // start off by looking in this object
    var target = this;

    // while the target exists
    while (target) {
        // if the is not visible, return false
        if (target.visibility == isc.Canvas.HIDDEN) return false;

        // if the is explicitly set as visible, return true
        if (target.visibility == isc.Canvas.VISIBLE) return true;

        // otherwise "inherit", so look up the parent chain
        target = target.parentElement;
    }
    // if everyone is inheriting visiblility (up to the page itself), return true
    return true;
},

// _isDisplayNone()
// Internal method - returns true if this canvas or any of its ancestors is currently rendered
// with display:"none"
_isDisplayNone : function () {
    var target = this;
    do {
        if (target.visibility == isc.Canvas.HIDDEN &&
            (target.hideUsingDisplayNone || target._hideUsingDisplayNoneCounter > 0))
        {
            return true;
        }
        target = target.parentElement;
    } while (target != null);
    return false;
},


// Enable/Disable
// -----------------------------------------------------------------------------------------------
//> @groupDef enable
// Disabled components do not respond to mouse or keyboard events, and change appearance to
// indicate they are disabled.
// @title Enabling and Disabling
// @visibility external
//<

//> @method canvas.setEnabled()     (A)
// set the enabled state of this object.
//
// @group enable
// @param  newState (boolean) pass false to disable or anything else to enable
// @visibility external
// @deprecated As of Smartclient version 5.5, deprecated in favor of +link{canvas.setDisabled()}
//<
_$disabled:"disabled",
setEnabled : function (newState) {
    this.logWarn("call to deprecated method 'setEnabled()' - use 'setDisabled()' instead."

    );
    var disabled = ((newState == null || isc.isA.Boolean(newState)) ? !newState
                    : (newState == this._$disabled));

    this.setDisabled(disabled);
},

//> @method canvas.setDisabled()    (A)
// set the disabled state of this object
// @group enable
// @param disabled (boolean) new disabled state of this object - pass <code>true</code> to disable the widget
// @visibility external
//<
setDisabled : function (newState, dontNoOp) {

    // We can no-op if we're already explicitly set to the appropriate state.
    if (newState == null) newState = false;
    if (!isc.isA.Boolean(newState)) newState = (newState == this._$disabled);
    if (this.disabled == newState) return;


    // Notify peers that the master element has been disabled
    // Will disable the peers too where appropriate
    if (this.peers) this.peers.map("masterDisabled", newState);

    // disabled state is inherited in a similar way to hidden visibility - if any of this widgets
    // ancestors are disabled, it's considered disabled, even if the "disabled" property has
    // been set to true.
    // Use isDisabled() to check whether this state change needs to have any effect on the
    // widget's handle and its children.
    var wasDisabled = this.isDisabled()
    // set the disabled state of the object
    this.disabled = newState;
    var isDisabled = this.isDisabled();

    if (wasDisabled != isDisabled || dontNoOp) {

        // update our HTML to reflect a change of state.
        this.setHandleDisabled(isDisabled);

        // If we have any children, they will also be affected by the state change.
        if (this.children) this.children.map("parentDisabled", isDisabled);
    }
},

// Notification function called when a widget's masterElement gets disabled
masterDisabled : function (disabled) {
    // Simply update our disabled state to match our masters, since we don't actually inherit
    // enabled /disabled state from our master like children do.
    this.setDisabled(disabled);
},

// notification function fired when a widget's parent or ancestor gets disabled or enabled

parentDisabled : function (disabled) {
    // If we're explicitly disabled the parent's enabling/disabling will not effect us - we
    // will remain disabled
    if (this.disabled) return;

    // If the parent redrew on being disabled we don't need to update our HTML
    if (!this.parentElement.redrawOnDisable) this.setHandleDisabled(disabled);

    // Tell our descendants about the change
    if (this.children) this.children.map("parentDisabled", disabled);
},


// Helper to actually update our HTML for becoming disabled / enabled
setHandleDisabled : function (disabled) {
    if (!this.isDrawn()) return;

    if (this.redrawOnDisable) this.markForRedraw("setDisabled");
    else this._updateCursor();

    if (this._canFocus()) this.disableKeyboardEvents(disabled);
},

// disableKeyboardEvents will clear the tabIndex / accessKey from a widget's handle.
// (Same method used to re-enable keyboard events, with the first parameter set to false)
disableKeyboardEvents : function (disabled, recursive, checkExistingState, exemptChildren) {

    // 'checkExistingState' allows calling code to ensure that if a widget is non focusable or
    // already disabled we don't mess with the existing keyboard event handling state.
    // This is used by the component-masking code.
    // We do still need to recursively look at children
    if (!checkExistingState || this._canFocus()) {

        if (disabled) {
            // these methods will No-Op if this._useNativeTabIndex is false, or if the widget
            // is not drawn.
            this._setHandleTabIndex(-1);
            if (this.accessKey != null) this._setHandleAccessKey(null);
        } else {
            // restore them when we're enabling them!
            this._setHandleTabIndex(this.getTabIndex());
            if (this.accessKey != null) this._setHandleAccessKey(this.accessKey);
        }

        // On disable, do a blur
        // Do this even if we're redrawing since that's done asynchronously
        if (disabled && this.hasFocus) this.blur();
    }
    // Set a flag so we can detect we've removed this from the tab-order when doing
    // synthetic tabbing
    this._keyboardEventsDisabled = disabled;

    if (recursive && this.children) {
        for (var i = 0; i < this.children.length; i++) {
            // always skip the actual component-mask
            if (this.componentMask == this.children[i]) continue;

            if (exemptChildren && exemptChildren.contains(this.children[i])) {
                continue;
            }

            if (checkExistingState && this.children[i].isDisabled()) continue;

            this.children[i].disableKeyboardEvents(disabled, true, checkExistingState);
        }
    }
},

//> @method canvas.enable() ([])
// Enables this widget and any children / peers of this widget.
//  @visibility external
//  @group enable
//<
enable : function () {

    // if the object is not already enabled
    if (this.disabled) this.setDisabled(false);
},


//> @method canvas.disable()    ([])
// Disables this widget and any children and peers of this widget.
//  @visibility external
//  @group enable
//<
disable : function () {
    if (!this.disabled) this.setDisabled(true);
},


//> @method canvas.isDisabled()  ([])
// Is this canvas disabled? Note that the disabled state is inherited - this method will return
// true if this widget, or any of its ancestors are marked disabled.
//  @visibility external
//  @group enable
//  @return (Boolean)   true if the widget or any widget above it in the containment hierarchy
//                      are disabled.
//<
isDisabled : function () {
    // Check this widget and each ancestor of it for the 'disabled' property
    var target = this;
    while (target) {
        if (target.disabled) return true;

        target = target.parentElement;
        // and if an eventProxy is defined, use that instead of this object
        if (target && target.eventProxy) target = target.eventProxy;
    }
    // if no-one is disabled, return false
    return false;
},

//> @method canvas.isEnabled()  ([])
// Returns true if the widget and all widgets above it in the containment hierarchy are enabled.
// Returns false otherwise.
// @visibility external
// @group enable
// @return    (boolean)   true if the widget and all widgets above it in the containment hierarchy
//                      are enabled; false otherwise
// @deprecated As of SmartClient version 5.5 deprecated in favor of +link{canvas.isDisabled()}.
//<
isEnabled : function () {
    this.logWarn("Call to deprecated 'isEnabled()' method - should use isDisabled() instead");
    return !this.isDisabled();
},

// Focus
// --------------------------------------------------------------------------------------------
//> @groupDef focus
// Focus is the ability to become the target of keyboard input events.
// <P>
// A widget normally receives focus by being clicked on or tabbed to.
//
// @title Focus
// @visibility external
//<

// Internal method to determine whether this widget should accept keyboard focus.
_canFocus : function () {
    // respect explicit setting
    if (this.canFocus != null) return this.canFocus;

    // If this.canFocus is not set, allow focus only on scrollable canvii with visible
    // scrollbars
    if ((this.overflow == isc.Canvas.SCROLL) ||
        ((this.overflow == isc.Canvas.AUTO) && (this.vscrollOn || this.hscrollOn)) ) {
            return true;
    }

    return false;
},

//> @method canvas.setCanFocus()    (A)
// Change whether a widget can accept keyboard focus.
// @param canFocus (boolean) whether the widget should now accept focus
// @see canFocus
// @visibility external
//<
setCanFocus : function (canFocus) {
    this.canFocus = canFocus;
    this._updateCanFocus();
},



//> @method canvas.isFocused()
// Returns true if this Canvas has the keyboard focus.  Note that focus is assigned
// asynchronously in Internet Explorer, so in that browser only, this method can correctly
// return false when, intuitively, you would expect it to return true:<pre>
//     someCanvas.focus();
//     if (someCanvas.isFocused()) {
//         // In most browsers we would get here, but not in Internet Explorer!
//     }</pre>
// @return (Boolean) whether this Canvas has the keyboard focus
// @see containsFocus
// @visibility external
//<
isFocused : function () {
    return this.hasFocus;
},

// Internal method to update the widget's handle to allow / disallow keyboard focus, based on
// the result of this._canFocus()
// Will No-Op if we're not using native tab-index / focus behavior, either by writing handlers
// onto the widget handle, or using the focusProxy approach.
_updateCanFocus : function () {
    var canFocus = this._canFocus();
    this._updateHandleForFocus(canFocus);
    this.canFocusChanged();
    // If a widget is made non-focusable and it currently has the focus, then blur() to give
    // up focus.
    if (!canFocus && this.hasFocus) this.blur();
},

_updateHandleForFocus : function (canFocus) {
    // If we're using native tab index (tabIndex and accessKey properties written into the widget
    // handle), we need to clear them out / update them.
    // This means updating the the handle's tabIndex / onfocus/onblur handler and accessKey.
    //
    // If we're using a focusProxy DOM element, we need to update (or create / destroy) it.
    //
    // If we're not leveraging any native browser tabIndex behavior, but a widget is being
    // removed from the tab-order, we need to clear up it's references in the auto-assigned tab
    // index system.
    var handle;

    //>FocusProxy if we're using a focusProxy, make sure it's present or absent as necessary
    if (this._useFocusProxy) {
        if (canFocus) {
            handle = this._getFocusProxyHandle();

            // if the focusProxy doesn't exist, call the makeFocusProxy method to create it.
            // Notes:
            // - the handle will be created in the correct state, so we return
            // - creation is delayed in some browsers
            if (!handle) return this.makeFocusProxy();
        } else {
            // we shouldn't be focusable, so destroy our focusProxy if we have one, and remove
            // ourselves from the tab order
            this._clearFocusProxy();

            return;
        }

        // we're focusable and we already have a focusProxy.
        // In Safari - when tabIndex is -1 we don't write a focusProxy into the DOM.
        // If tabIndex is -1 and we already have a focus proxy, clear it here

        if (isc.Browser.isSafari && this.getTabIndex() == -1) {
            this._clearFocusProxy();
            return;
        }
    }
    //<FocusProxy


    if (this._useAccessKeyProxy()) {
        if (canFocus && this.accessKey) {
            this._makeAccessKeyProxy();
        } else if (this._accessKeyProxy) {
            this._clearAccessKeyProxy();
        }
    }

    // If we're writing focus properties directly onto the widget handle, get a pointer to that
    // for manipulation below.
    if (this._useNativeTabIndex) handle = this.getFocusHandle();

    if (canFocus) {
        // Note: this.getTabIndex() will set this._autoTabIndex as appropriate.
        // _setTabIndex() will fall through to _setHandleTabIndex() and apply the tabIndex to
        // the handle if appropriate.
        //

        this._setTabIndex(this.getTabIndex(), this._autoTabIndex);

        // if we can accept focus, setup handlers and put us in the tab order
        if (handle != null) {

            var focusHandler = this._getNativeFocusHandlerMethod(),
                blurHandler = this._getNativeBlurHandlerMethod();
            handle.onfocus = focusHandler;
            handle.onblur = blurHandler;
            if (this.accessKey) this._setHandleAccessKey(this.accessKey);
        }


    } else {
        // if we can't accept focus, clear handlers and remove us from the tab order
        if (handle != null) {

            handle.removeAttribute("onfocus");
            handle.onfocus = null;
            handle.removeAttribute("onblur");
            handle.onblur = null;

            // Remove from the tab order

            this._setHandleTabIndex(-1);

            if (handle.accessKey != null) this._setHandleAccessKey(null);
        }

    }
},

// notification fired when the canFocus status of this widget has updated
canFocusChanged : function () {
    var parent = this.parentElement;
    while (parent) {
        parent.childCanFocusChanged(this);
        parent = parent.parentElement;
    }
},
// Notification fired when the canFocus status of some child of this widget changes
// Fired by 'canFocusChanged'.  No Op by default.

childCanFocusChanged : function (child) {
},

// update whether or not we should show the focusOutline
// handleOnly param will update the handle to show / hide the focus outline but leave
// this.showFocusOutline unmodified
_$none:"none",
setShowFocusOutline : function (showFocusOutline, handleOnly) {
    if (!handleOnly && this.showFocusOutline == showFocusOutline) return;
    if (!handleOnly) this.showFocusOutline = showFocusOutline;
    var handle = this.getClipHandle();
    if (handle != null) {
        // only IE supports the 'hidefocus' attribute
        // http://help.dottoro.com/lhgdtcso.php
        // http://msdn.microsoft.com/en-us/library/ms533783.aspx
        if (isc.Browser.isIE) {
            handle.hideFocus = !showFocusOutline;
        } else {
            handle.style.outlineStyle = (showFocusOutline ? isc.emptyString : this._$none);
        }
    }
},

////////
// obtain or lose the focus in this object
//
//  if this object wants to get the focus when it's clicked, set:
//      obj.canFocus = true
//
//  to have an object redraw when its focus changes, set:
//      obj.redrawOnFocus = true
////////

//_readyToSetFocus: can we update the focus state of this widget?
_readyToSetFocus : function (focus) {


    return (this.isDrawn() && this.visibleInDOM() && (!focus || !this.isDisabled()));
},

visibleInDOM : function () {
    if (!this.isVisible()) return false;

    // relative positioned widgets can be hidden without us ever being notified of the hide,
    // if the ancestors in the DOM have been hidden
    // If the topParent is pos:"relative", iterate up from the topParent to the page body and verify
    // all elements are visible

    var topWidget = this.getTopLevelCanvas();

    if (topWidget.position == isc.Canvas.ABSOLUTE) return true;

    var docBody = this.getDocumentBody();
    var handle = topWidget.getClipHandle().parentNode;
    while (handle && handle != docBody) {
        var style = handle.style;
        if (style && style.visibility == this._$hidden) return false;
        if (style && style.display == this._$none) return false;
        handle = handle.parentNode;
    }
    return true;
},

// get the handle this widget uses for focus, if there is one
getFocusHandle : function () {
    if (this._useNativeTabIndex) {
        return this.getClipHandle();
    //>FocusProxy
    } else if (this._useFocusProxy && this._hasFocusProxy) {
        return this._getFocusProxyHandle();
    //<FocusProxy
    }
    return null;
},

//> @method canvas.setFocus()   (A)
// set the focused state of this object
//      @group  focus
//
//  @param  newState            (boolean) pass false to blur or anything else to focus
//<
setFocus : function (newState, reason) {
    if (!this._readyToSetFocus(newState)) return;
    var focusHandle = this.getFocusHandle(newState);



    // call the EventHandler method to update the current focus canvas
    if (newState && this._canFocus()) {

        // If the widget is currently masked we should avoid calling handle.focus(), and instead
        // notify the EH directly so it can update it's 'maskedFocusCanvas'
        // Because of IE's fun asynchronous focus handler behavior we'll have to also catch the
        // case where focus has previously been called on another widget, but the focus handler
        // hasn't been fired yet and avoid it clobbering this maskedFocusCanvas setting when
        // onfocus does fire.

        if (focusHandle != null && this.getDocument().activeElement !== focusHandle) {
            /*
            if (isc.EH._unconfirmedFocus == this) {
                // aborting here has not yet been observed to matter
                this.logDebug("ignoring focus attempt on widget with unconfirmed focus()");
                return;
            }
            */

            if (isc.Browser.isIE && document.activeElement == focusHandle) {
                this.logInfo("setFocus() not calling element.focus() as element already has " +
                    "native focus", "nativeFocus");
            } else {
                //>DEBUG
                this.logInfo("about to call native focus()" +
                             (this.logIsDebugEnabled("traceFocus") ? this.getStackTrace() : ""),
                             "nativeFocus");
                //<DEBUG

                isc.EH._unconfirmedFocus = this;
                focusHandle.focus();
                isc.EH._lastFocusTarget = this;
            }
        } else {
            this.ns.EH.focusInCanvas(this);
        }

    } else if (this.hasFocus) {
        if (focusHandle) {
            /*
            if (isc.EH._unconfirmedBlur == this) {
                // aborting here has not yet been observed to matter
                this.logWarn("ignoring blur attempt on widget with unconfirmed blur()");
                return;
            }
            */
            //>DEBUG
            this.logInfo("about to call native blur()" +
                         (this.logIsDebugEnabled("traceBlur") ? this.getStackTrace() : ""),
                         "nativeFocus");
            //<DEBUG

            isc.EH._unconfirmedBlur = this;
            focusHandle.blur();
        } else {
            this.ns.EH.blurFocusCanvas(this);
        }
    }


},


_restoreFocus : function () {
    // abort if focus has moved (onFocus() fired somewhere else)
    var focusCanvas = isc.EH._focusCanvas;
    if (focusCanvas != null && focusCanvas != this) {
        this.logDebug("not restoring focus; focus moved to: " + focusCanvas,
                      "nativeFocus");
        return;
    }
    // abort if we've called native focus() to move focus elsewhere, but onFocus() hasn't fired
    // yet
    var pendingFocus = isc.EH._unconfirmedFocus;
    if (pendingFocus != null && pendingFocus != this) {
        this.logDebug("not restoring focus; focus about to move to:" + pendingFocus,
                      "nativeFocus");
        return;
    }
    this.logDebug("restoring focus from zIndex change", "nativeFocus");
    this._setFocusWithoutHandler(true);
},

// special handling of focus is required when a click mask is hidden
_restoreFocusForClickMaskHide : function () {
    this.focus();
},

//> @method canvas.focus()
// If this canvas can accept focus, give it keyboard focus. After this method, the canvas
// will appear focused and will receive keyboard events.
// @group   focus
// @visibility external
//<
focus : function (reason) {

    if (isc._traceMarkers) arguments.__this = this;

    this.setFocus(true, reason);
},


//> @method canvas.blur()
// If this canvas has keyboard focus, blur it. After this method, the canvas
// will no longer appear focused and will stop receiving keyboard events.
// @group   focus
// @visibility external
//<
blur : function (reason) {
    if (isc._traceMarkers) arguments.__this = this;
    this.setFocus(false, reason);
},

// focusAtEnd(): Helper method for synthetic tabIndex stuff - puts focus at the 'beginning' or
// 'end' of this widget.
// No effect unless this widget has some concept of focusable sub elements, for which it
// manages the tab order directly.
// Has meaningful implementation in DynamicForm / Toolbar by default
focusAtEnd : function (start) {
    return this.focus();
},

//> @method canvas._setFocusWithoutHandler()
//          Internal method to update whether this widget has focus or not, without triggering the
//          focusChanged handler
//      @group  focus
//      @visibility internal
//<
_setFocusWithoutHandler : function (state, reason) {
    this._suppressFocusChanged = true;
    this.setFocus(state, reason);


},


//> @method canvas._focusChanged() (I)
// Fired when this canvas is focused or blurred.  May cause redraw if redrawOnFocus is true.
//      @group  focus
//<

_focusChanged : function (hasFocus) {
    if (hasFocus == null) hasFocus = (this.ns.EH._focusCanvas == this);
    this.logDebug("_focusChanged(): hasFocus = " + hasFocus, "nativeFocus");
    this.hasFocus = hasFocus;

    if (this._suppressFocusChanged) {
        delete this._suppressFocusChanged;
        return false;
    }

    // have a flag so the focusChanged so we know if we're firing in response to a focus/blur

    this._focusChanging = true;

    // if defined, call the focusChanged handler (stringMethod)
    if (this.focusChanged != null) {
        this.focusChanged(hasFocus);
    }

    // Notify our ancestors that focus changed on one of the children
    if (this.parentElement) {
        this.parentElement._childFocusChanged(this, hasFocus);
    }

    // if we're marked to redraw when focused, redraw!
    if (this.redrawOnFocus) this.markForRedraw("setFocus");
    this._focusChanging = false;
},

// Notification fired when focus changes on some descendent of this widget

_childFocusChanged : function (target, hasFocus) {
    if (this.parentElement) {
        this.parentElement._childFocusChanged(target, hasFocus);
    }
},

// if we have a focusOnHide target specified, focus in it, otherwise just blur
// Note: We're hiding ourselves and all our children here, so if we're hiding the current
// focus canvas we need to respect it's focusOnHide (if set)
_updateFocusForHide : function () {

    var fc = this.ns.EH.getFocusCanvas();

    if (this._isVisibilityAncestorOf(fc)) {

        if (isc.isA.Canvas(fc.focusOnHide) && fc.focusOnHide.isDrawn() &&
            fc.focusOnHide.isVisible()) {
                fc.focusOnHide.focus();
        }
        else {
            fc.blur();
            // In IE blur() is asynchronous - the blur handler won't fire until after the
            // end of the calling thread.
            // If the handle has disappeard from the DOM, it won't fire at all, which can leave
            // EH focusCanvas pointing to a hidden (or even destroyed) widget.
            // Explicitly call EH.blurFocusCanvas() now if we still have focus at this point
            // to avoid this. When the native blur handler fires EH._blurFocusCanvas will no-op
            // if appropriate.
            if (fc.hasFocus) isc.EH.blurFocusCanvas(fc);
        }
    }
},

//> @method canvas.containsFocus()
// Returns true if the keyboard focus is in this Canvas or any child of this Canvas.
// @return (Boolean) whether this Canvas contains the keyboard focus
// @group focus
// @visibility external
//<
containsFocus : function  () {
    var fc = this.ns.EH.getFocusCanvas();
    return this.contains(fc, true);
},




// Access Key
// --------------------------------------------------------------------------------------------
// Global keyboard shortcuts for switching focus to this Canvas

//> @method canvas.setAccessKey()   (A)
// Set the accessKey for this canvas.
// <P>
// The accessKey can be set to any alphanumeric character (symbols not supported)
// Having set an accessKey, the canvas will be given focus when the user hits
// Alt+[accessKey], or in Mozilla Firefox 2.0 and above, Shift+Alt+[accessKey].
//
//      @group  focus
//
//      @param accessKey
//              Character to use as an accessKey for this widget.  Case Insensitive.
// @visibility external
//<

setAccessKey : function (accessKey) {
    this.accessKey = accessKey;

    // Only set the accessKey on the handle if the widget is really focus-able
    if (this._canFocus() && !this.isDisabled()) {
        this._setHandleAccessKey(this.accessKey)
    }
},

// Internal method to actually set the accessKey on the widget handle (or focusProxy if
// appropriate).  No-op's if the handle is not drawn or if _useNativeTabIndex and
// _useFocusProxy are both false
_setHandleAccessKey : function (accessKey) {

    // accessKeyProxy stuff for Moz
    if (this._useAccessKeyProxy()) {
        if (accessKey == null) this._clearAccessKeyProxy();
        else {
            if (this._accessKeyProxy) this._accessKeyProxy.accessKey = accessKey;
            else this._makeAccessKeyProxy();
        }
        return;
    }

    if (this._useNativeTabIndex) {
        var handle = this.getHandle();
        if (handle != null) handle.accessKey = accessKey;
    }

    if (this._useFocusProxy && this._hasFocusProxy) {
        var handle = this._getFocusProxyHandle();

        if (handle != null) {

            if (isc.Browser.isMoz) {
                //>FocusProxy
                this._clearFocusProxy();
                this.makeFocusProxy();
                //<FocusProxy
            } else {
                handle.accessKey = accessKey;
            }
        }
    }

},

// Return the accessKey for the widget.
getAccessKey : function () {
    return this.accessKey;
},


// Tab Index
// --------------------------------------------------------------------------------------------
// Managing this Canvas position in the global tabbing order

// Return the Tab index for the widget.
// If not set, defaults to isc.Canvas.currentTabIndex, which increments from 1000 as more widgets
// are added to the tab order.
getTabIndex : function () {
    if (this.tabIndex == null) {
        this._autoAllocateTabIndex();
    }

    return this.tabIndex;
},

// Most widgets take up 1 tab index.
getTabIndexSpan : function () {
    return 1;
},

//> @method canvas.setTabIndex()    (A)
//  Assign an explicit tabIndex to this widget.
// @param tabIndex (number) New tabIndex for this widget. Must be less than
//                          +link{Canvas.TAB_INDEX_FLOOR} to avoid interfering with auto-assigned
//                          tab indices on the page.
// @group focus
// @see canvas.tabIndex
// @visibility external
//<
// See comments by _autoAllocateTabIndex() for ISC tab order tracking implementation details.
setTabIndex : function (index) {
    var floor = isc.Canvas.TAB_INDEX_FLOOR;
    // explicitly specified tabIndices must be below a certain floor so that they don't collide
    // with ISC auto-allocated tab indices.
    if (index >= floor) {
        var minIndex = floor - 1;
        this.logWarn("setTabIndex(): Passed index of " + index +
                     ". This method does not support setting a tab index greater than "
                     + minIndex +
                     ".  Setting tab index for this widget to " + minIndex +
                     this.getStackTrace());
        index = minIndex;
    }
    // Update the _previousTabWidget and _nextTabWidget flags
    this._removeFromAutoTabOrder();
    this._setTabIndex(index, false);
},

_setTabIndex : function (index, autoAllocated) {
    //!DONTCOMBINE

    // Note - this method doesn't manage _previousTabWidget and _nextTabWidget - those
    // properties should be updated by the calling methods.

    this._autoTabIndex = autoAllocated;

    this.tabIndex = index;
    if (this._canFocus() && !this.isDisabled()) {
        this._setHandleTabIndex(index);
    }
},

// _setHandleTabIndex
// Updates the tabIndex of a widget's handle -- will not effect the widgets 'tabIndex' property
// No-ops if it can't get to the widget's handle, or if _useNativeTabIndex is not true
_setHandleTabIndex : function (index) {
    if (this._useNativeTabIndex && this.isDrawn()) {
        var handle = this.getFocusHandle();
        handle.tabIndex = index;

        if (isc.Browser.isIE) isc.Canvas._forceNativeTabOrderUpdate();
    }

    //>FocusProxy
    if (this._useFocusProxy) {

        // We may not have a focus proxy yet - this could happen if we're calling this method
        // before delayed creation of a focus proxy, or in Safari going from tabIndex -1 to
        // a positive t.i.
        if (!this._hasFocusProxy) return this.makeFocusProxy();

        var handle = this._getFocusProxyHandle();
        // before manipulating the handle take focus from it
        // If necessary we'll restore focus after changing the tabIndex


        var hasFocus = (this.hasFocus && !this._focusChanging);
        if (hasFocus && handle) {
            this.logDebug("_setHandleTabIndex() about to call native blur() on the focus proxy handle", "nativeFocus");
            handle.blur();
        }

        // In safari, it is impossible to make a native focus proxy and exclude it from the
        // page's tab order, so we just clear it to remove the widget from the tab order of the
        // page.
        if (isc.Browser.isSafari && index < 0) return this._clearFocusProxy();


        if (handle != null) {
            handle.tabIndex = index;

            if (isc.Browser.isMoz) {
                handle.style.MozUserFocus = (index < 0 ? "ignore" : "normal");
            }

            if (hasFocus) {
                this.logDebug("_setHandleTabIndex() about to call native focus() on the focus proxy handle", "nativeFocus");
                handle.focus();
            }
        }
    }
    //<FocusProxy
},


// If no tabIndex is specified for the widget (and it is focus-able), automatically
// assign one.
// In IE, tabIndex can validly be any integer from -32767 to 32767
// Negative values are ommitted from the tab order.
//
// We manage auto-assigning tab indexes for widgets in the following way:
// A widget is auto-assigned a tabIndex at draw time.  We start the ISC tab index count at 1000,
// and increment this value by 50 for each new widget.
// Each widget can be assumed to take up a 'span' of tab index slots - by default one slot, but
// for a dynamic form one slot per focusable item. The method 'getTabIndexSpan()' should return
// this value.

//
// If a developer wants to explicitly specify tab-index for some widgets, they can set the
// values to anything below 1000 to avoid interfering with the auto-assigned tab indexes.
// If the widget is a dynamic form, the developer should be aware that the form items will take
// up slots in the page's tab order, so they may have to leave gaps between DynamicForm widgets.
// We may want to make 'getTabIndexSpan()' external for this reason.
//
// For widgets with auto-assigned tab indexes, we allow the widgets to keep track of where they
// are in the tab order by setting pointers to the next and previous widget in the tab order
// (_nextTabWidget and _previousTabWidget).
// We also support runtime reordering of auto-assigned tabindex widgets via the internal
// _setTabBefore() and _setTabAfter() methods. This is used to ensure that Layout members
// appear in the appropriate order on the page





_autoAllocateTabIndex : function () {
    var Canvas = isc.Canvas;
    if (Canvas._currentTabIndex == null) {
        Canvas._currentTabIndex = Canvas.TAB_INDEX_FLOOR;
    }

    var currentTabWidget = isc.EH._lastTabWidget;
    if (currentTabWidget) Canvas._currentTabIndex += currentTabWidget.getTabIndexSpan();

    // Always leave a significant gap between widgets when first setting them up - makes
    // it easier to slot other widgets in between them in the page's tab order.
    Canvas._currentTabIndex += Canvas.TAB_INDEX_GAP

    // If we hit the native browser tabindex ceiling warn about it

    if (Canvas._currentTabIndex > isc.Canvas.TAB_INDEX_CEILING &&
        !isc.Canvas._tabIndexCeilingWarned)
    {
        isc.Canvas.logWarn("Auto allocation of tab-indices has reached native browser ceiling " +
                           "- tab-order cannot be guaranteed for widgets on this page.");
        isc.Canvas._tabIndexCeilingWarned = true;
    }
    this._setTabIndex(Canvas._currentTabIndex, true);

    // update the flags to point to the previous widget in the auto-allocated tab order
    if (currentTabWidget) {
        currentTabWidget._setNextTabWidget(this);
        this._previousTabWidget = currentTabWidget;
    } else {
        isc.EH._firstTabWidget = this;
    }
    isc.EH._lastTabWidget = this;
},

// limitation: if you try to move before or after a widget with an explicitly
// specified tab index we can't manage the order properly.
// Also updates any auto-assigned children's tab indexes to keep them in order within the page
// level tab order.
// If this method is called on a non-focusable widget, it will only update any focusable
// children.

_setTabBefore : function (otherWidget) {
    // No need to take action if attempting to move before this, or if we're already before the
    // other widget
    if (this == otherWidget || this._getNextTabWidget() == otherWidget) return;

    // note: getTabIndex() will set the _autoTabIndex flag if no tab index was explicitly
    // specified
    var newTabIndex = otherWidget.getTabIndex();
    if (!otherWidget._autoTabIndex) {
        //>DEBUG
        this.logWarn("_setTabBefore() attempting to set tab index adjacent to widget "
                    + otherWidget + " with explicitly specified tabIndex [" + otherWidget.tabIndex
                    + "]. This method can only manipulate widgets with auto-assigned tab indexes.");
        //<DEBUG
        return;
    }

    var previousWidget = otherWidget._previousTabWidget;



    // Remove this widget from it's current position in the tab order -
    // If we have a previous / next widget in the tab order, update it's flag pointing back to us
    // to point to the appropriate widget after / before us in the tab order
    var prev = this._getPreviousTabWidget(),
        next = this._getNextTabWidget();
    if (isc.EH._lastTabWidget == this) isc.EH._lastTabWidget = prev;
    if (isc.EH._firstTabWidget == this) isc.EH._firstTabWidget = next;
    if (prev != null)
        prev._setNextTabWidget(next);
    if (next != null)
        next._setPreviousTabWidget(prev);

    this._setPreviousTabWidget(null);
    this._setNextTabWidget(null);

    this._slotTabBetween(otherWidget._getPreviousTabWidget(), otherWidget);

    // If we have children, ensure they show up after us in the tab order.

    this._slotChildrenIntoTabOrder();
},

_setTabAfter : function (otherWidget) {

    // No need to take action if attempting to move before this, or if we're already before the
    // other widget
    if (this == otherWidget || this._previousTabWidget == otherWidget) return;


    // note: getTabIndex() will set the _autoTabIndex flag if no tab index was explicitly specified
    otherWidget.getTabIndex();

    if (!otherWidget._autoTabIndex) {
        // Slot our children into the tab order after whatever is "previous", even though
        // we ourselves aren't legit to slot into tab order (explicit tab index etc)
        this._slotChildrenIntoTabOrder(otherWidget);

        //>DEBUG
        this.logWarn("_setTabAfter() attempting to set tab index adjacent to widget "
                    + otherWidget + " with explicitly specified tabIndex [" + otherWidget.tabIndex
                    + "]. This method can only manipulate widgets with auto-assigned tab indexes.");
        //<DEBUG
        return;
    }

    var previousWidget = otherWidget,
        oldPrev = this._getPreviousTabWidget(),
        oldNext = this._getNextTabWidget();

    if (isc.EH._lastTabWidget == this) isc.EH._lastTabWidget = oldPrev;
    if (isc.EH._firstTabWidget == this) isc.EH._firstTabWidget = oldNext;

    // If we have a previous / next widget in the tab order, update it's flag pointing back to us
    // to point to the appropriate widget after / before us in the tab order
    if (oldPrev != null)
        oldPrev._setNextTabWidget(oldNext);
    if (oldNext != null)
        oldNext._setPreviousTabWidget(oldPrev);

    // (and clear these flags on us!)
    this._setPreviousTabWidget(null);
    this._setNextTabWidget(null);

    // Now just slot in between the other widget and the one that follows it
    this._slotTabBetween(otherWidget, otherWidget._getNextTabWidget());

    // If we have children, ensure they show up after us in the tab order.
    this._slotChildrenIntoTabOrder();
},

// Insert this widget into the auto-assigned tab order between 2 other widgets
_slotTabBetween : function (previous, next) {

    // This will automatically set up EH._lastTabWidget
    if (next == null) return this._autoAllocateTabIndex();

    // We can't easily slot in front of the first widget in the tab-order - in this case we
    // need to slot into the first widgets slot and shift the first widget forward to avoid
    // assigning a tabIndex < the isc-managed tabIndex floor.
    if (previous == null) {
        var nextNext = next._getNextTabWidget();
        next._removeFromAutoTabOrder();
        this._setNextTabWidget(nextNext);
        this._setPreviousTabWidget(null);
        this._setTabIndex(next.tabIndex, true);
        isc.EH._firstTabWidget = this;

        next._slotTabBetween(this, nextNext);
        return;
    }

    // At this point we have 2 valid tabindex-adjacent widgets to slot between

    // update the _nextTabWidget / _previousTabWidget flags
    this._setNextTabWidget(next);
    next._setPreviousTabWidget(this);
    this._setPreviousTabWidget(previous);
    previous._setNextTabWidget(this);

    var previousTabIndex = previous.tabIndex + previous.getTabIndexSpan(),
        nextTabIndex = next.tabIndex,
        // split the difference between the previous widgets tabIndex (plus its required slots)
        // and the next tabIndex.
        newTabIndex = previousTabIndex + Math.floor((nextTabIndex - previousTabIndex)/2),
        span = this.getTabIndexSpan();
    // if our required tabIndexSpan overlaps the next tabIndex, we need to shift the next widget
    // forwards

    if ((newTabIndex + span) > nextTabIndex) {
        next._shiftTabIndexForward((newTabIndex + span) - nextTabIndex);
        // This calculation is now guaranteed to give us enough space
        //this.logWarn("Our span:" + span +": not enough tabIndex gap between:"
        //                + previous + ", " + previous.tabIndex
        //                + " and next:"+ next + ":" + nextTabIndex +
        //                  " - resolved by shifting next to:"+ next.tabIndex);

    }
    if (this.logIsDebugEnabled("tabIndex")) {
        this.logDebug("Putting " + this.getID() + " in tab order between: "+ previous.getID() +
                     ":"+ previous.tabIndex + ", and :"+ next.getID() + ":" + next.tabIndex +
                     ". Resulting tabIndex:"+ newTabIndex, "tabIndex");
    }

    this._setTabIndex(newTabIndex, true);
},


// Shunt our tabIndex forward by the number of slots passed in.
// If we don't have room without colliding with the tabIndex of this._nextTabWidget,
// shift that widget forward as well (recursively)
_shiftTabIndexForward : function (minimumRequired) {



    var next = this._getNextTabWidget();
    if (next == null) {
        this._setTabIndex(this.tabIndex + minimumRequired + isc.Canvas.TAB_INDEX_GAP, true);
        return;
    }

    // Shunt ourselves right up against the guy after us by default.
    // If that doesn't give us enough room we'll have to shift him forward too.
    var nextTI = next.getTabIndex(),
        newTI = nextTI - this.getTabIndexSpan();
    if (this.tabIndex + minimumRequired < newTI) this._setTabIndex(newTI, true);
    else {
        // Shift the next widget forward by the space we need to shift forwards by less the
        // space we actually can shift forwards by
        next._shiftTabIndexForward(minimumRequired - (newTI - this.tabIndex));
        // And now when we shunt up against it we know there will be enough space.
        this._setTabIndex(next.tabIndex - this.getTabIndexSpan(), true);
    }
},


_getNextTabWidget : function (backwards) {
    if (!backwards) return this._nextTabWidget;
    else return this._previousTabWidget;
},

_getPreviousTabWidget : function () {
    return this._getNextTabWidget(true);
},

_setNextTabWidget : function (widget, backwards) {

    if (!backwards) this._nextTabWidget = widget;
    else this._previousTabWidget = widget;
},

_setPreviousTabWidget : function (widget) {
    return this._setNextTabWidget(widget, true);
},

//> @method canvas.focusInNextTabElement()
// Shifts focus to the next focusable element after this one.  This is the programmatic
// equivalent of the user pressing the Tab key.  A "focusable element" is a +link{class:Canvas}
// or +link{class:FormItem} that is +link{canvas.canFocus,focusable}, and is not
// +link{formItem.disabled,disabled} or +link{canvas.showClickMask,masked}.  Note that the
// movement of focus to a <code>FormItem</code> is managed by the containing
// +link{class:DynamicForm}; calling this method on a <code>DynamicForm</code> will move the
// focus to the next focusable <code>FormItem</code> in the form if there is one, and onto the
// next focusable <code>Canvas</code> if not.
// <p>
// <b>NOTE: </b>This method only considers SmartClient elements.  Native elements that you
// create directly - for example, with +link{HTMLFlow.setContents()} or by creating a custom
// widget with +link{Canvas.getInnerHTML()} that has focusable elements that are not child
// Canvases - will not be noticed by this method.
//
// @group focus
// @see canvas.tabIndex
// @see canvas.focusInPreviousTabElement
// @visibility external
//<
focusInNextTabElement : function() {
    if (this._focusInNextTabElement) {
        this._focusInNextTabElement(true, this._getTopHardMask());
    }
},


//> @method canvas.focusInPreviousTabElement()
// Shifts focus to the previous focusable element before this one.  This is the programmatic
// equivalent of the user pressing Shift-Tab.  A "focusable element" is a +link{class:Canvas}
// or +link{class:FormItem} that is +link{canvas.canFocus,focusable}, and is not
// +link{formItem.disabled,disabled} or +link{canvas.showClickMask,masked}.  Note that the
// movement of focus to a <code>FormItem</code> is managed by the containing
// +link{class:DynamicForm}; calling this method on a <code>DynamicForm</code> will move the
// focus to the previous focusable <code>FormItem</code> in the form if there is one, and onto
// the previous focusable <code>Canvas</code> if not.
// <p>
// <p>
// <b>NOTE: </b>This method only considers SmartClient elements.  Native elements that you
// create directly - for example, with +link{HTMLFlow.setContents()} or by creating a custom
// widget with +link{Canvas.getInnerHTML()} that has focusable elements that are not child
// Canvases - will not be noticed by this method.
//
// @group focus
// @see canvas.tabIndex
// @see canvas.focusInNextTabElement
// @visibility external
//<
focusInPreviousTabElement : function() {
    if (this._focusInNextTabElement) {
        this._focusInNextTabElement(false, this._getTopHardMask());
    }
},

_getTopHardMask : function () {
    return isc.EH.getTopHardMask();
},

// Allow 'alwaysManageFocusNavigation' on a widget to always intercept Tab keypresses
// and go into the 'focusInNextTabElement' flow even if we have no clickMask up.
//alwaysManageFocusNavigation:false,


useExplicitFocusNavigation : function () {
    if (this.alwaysManageFocusNavigation) return true;
    // For CanvasItem, check the containing DynamicForm [may not be the
    // parentElement of the CanvasItem canvas due to the 'containerWidget' pattern]
    if (isc.CanvasItem && isc.isA.CanvasItem(this.canvasItem)) {
        var form = this.canvasItem.form;

        return form.useExplicitFocusNavigationForCanvasItem(this.canvasItem);
    } else {
        if (!this.parentElement) return false;
        return this.parentElement.useExplicitFocusNavigation();
    }
},

_focusInNextTabElement : function (forward, mask) {

    if (isc.CanvasItem && this.isDrawn() && this.isVisible()) {
        var canvasItemParent = null, canvas = this;
        do {
            if (canvas.canvasItem != null) {
                canvasItemParent = canvas.canvasItem;
            } else {
                canvas = canvas.getParentCanvas();
            }
        } while (canvas && (canvasItemParent == null))

        if (canvasItemParent && canvasItemParent.form) {

            this.logInfo("_focusInNextTabElement() called on a descendent of a CanvasItem " +
                canvasItemParent + ". Delegating focus manipulation to parent form " +
                canvasItemParent.form, "syntheticTabIndex");
            return canvasItemParent.form._focusInNextTabElement(forward, mask, null, canvasItemParent);
        }

    }

    // If the current target has a tabIndex of -1, look up the parent hierarchy to see if we
    // have an ancestor with a tabIndex, and delegate to that ancestor if we do
    var target = this;
    while (target.tabIndex == -1 && target.parentElement != null) {
        target = target.parentElement;
    }

    if (target != this) {
        if (target.tabIndex != -1) {
            this.logDebug("_focusInNextTabElement() was called for a " +
                "Canvas with a tabIndex of -1 (" + this.ID + "). Delegating focus " +
                "manipulation to the nearest ancestor with a tabIndex (" +
                target.ID + ")");
        } else {
            this.logDebug("_focusInNextTabElement() was called for a " +
                "Canvas with a tabIndex of -1 (" + this.ID + "), but we failed to " +
                "find an ancestor with a real tabIndex, so we could not delegate. " +
                "Proceeding with the original target, which is going to mean we " +
                "cycle back to the start of the tab order");
            target = this;
        }
    }

    if (target != this) {
        return target._focusInNextTabElement(forward, mask);
    }

    var nextWidget = this;
    do {
        nextWidget = (forward ? nextWidget._getNextTabWidget() :
                                nextWidget._getPreviousTabWidget());

    } while(nextWidget &&
            (isc.EH.targetIsMasked(nextWidget, mask) ||
             nextWidget._keyboardEventsDisabled ||
             nextWidget.isDisabled() ||
             !nextWidget.isDrawn() || !nextWidget.isVisible()  || !nextWidget._canFocus()) &&
            // don't shove focus into a CanvasItem's canvas -- here. This would be handled via
            // the DynamicForm override to focusInItem() on the appropraite item (which would
            // stick focus into the embedded Canvas if appropriate).
            (!isc.CanvasItem || nextWidget.canvasItem == null || nextWidget.canvasItem.form == null))

    if (nextWidget) {
        //>DEBUG
        this.logInfo("focusInNextTabElement() shifting focus to:"+ nextWidget, "syntheticTabIndex");
        //<DEBUG


        nextWidget.focusAtEnd(forward)
    } else if (forward) {
        //>DEBUG
        this.logInfo("focusInNextTabElement() shifting focus to first widget", "syntheticTabIndex");
        //<DEBUG
        if (isc.EH._firstTabWidget == null ||
            // If we're the first widget in the synthetic tab order and we're non focusable
            // telling EH to drop focus into the first guy will cause EH to call this
            // method again, leading to a potential infinite loop.
            (isc.EH._firstTabWidget == this &&
             (this.isDisabled() || !this.isDrawn() ||
             !this.isVisible()  || !this._canFocus() || this.isMasked(mask))))
         {
             return;
         }
        isc.EH._focusInFirstWidget(mask);
    } else {
        //>DEBUG
        this.logInfo("focusInNextTabElement() shifting focus to last widget", "syntheticTabIndex");
        //<DEBUG
        if (isc.EH._lastTabWidget == null ||
            (isc.EH._lastTabWidget == this &&
             (this.isDisabled() || !this.isDrawn() ||
             !this.isVisible()  || !this._canFocus() || this.isMasked(mask))))
        {
            return;
        }
        isc.EH._focusInLastWidget(mask);
    }
},

// Helper - if we've got an autoAllocated tabIndex, ensure our children show up after this
// widget in the page's tab order.

_slotChildrenIntoTabOrder : function (previous) {
    previous = previous || this;

    var children = isc.isA.Layout(this) ? this.members : this.children;
    if (!children || children.length == 0) return;


    var afterChild = previous._getNextTabWidget();
    for (var i = children.length -1; i >= 0; i--) {
        // support sparse arrays
        if (children[i] == null) continue;

        if (children[i].tabIndex == null || children[i]._autoTabIndex)
        {
            // Catch the case where we are the last auto-allocated tab widget
            if (afterChild == null) children[i]._setTabAfter(previous);
            else children[i]._setTabBefore(afterChild);
            afterChild = children[i];
        } else {

            children[i]._slotChildrenIntoTabOrder(previous);
            // Note: we've just slotted some children between the "previous" and "afterChild"
            // widgets. Since we're iterating through the child array backwards we need the
            // next pass through this loop to slot earlier children before anything we
            // slotted in, so recalculate afterChild
            afterChild = previous._getNextTabWidget();

        }
    }
},

// Helper to get the last descendant of a widget with auto-assigned tab index so
// setTabAfter() can reliably put the widget after the prev-widget's descendants.
// Currently only used in Layouts.

_getLastAutoIndexDescendant : function (lookAtAssignedPosition) {

    var children = this.children;

    if (isc.Layout && isc.isA.Layout(this)) children = this.members;
    if (children != null) {
        for (var i = children.length -1; i >= 0; i--) {
            // skip nulls in case we're called pre-draw on a Layout
            if (children[i] == null ||
                (children[i].tabIndex != null && !children[i]._autoTabIndex) ||
                // if "lookAtAssignedTabPosition" is passed, skip any widgets
                // where _autoTabIndex is currently false, even if tabIndex
                // is unset.

                (!lookAtAssignedPosition && !children[i]._autoTabIndex)
               )
            {
                continue;
            }

            var descendant = children[i]._getLastAutoIndexDescendant(lookAtAssignedPosition);
            if (descendant != null) return descendant;
        }
    }

    // If we're still going, we didn't find any descendants with auto-assigned TI.
    // return ourselves if appropriate
    if (!lookAtAssignedPosition && this.tabIndex == null || this._autoTabIndex)
        return this;

    return null;
},


// Helper function to update the pointers to the next and previous widget in the page's tab order
// when we stop managing a widget's tab position.
// This can happen if the widget's tab position is specified explicitly via 'setTabIndex()', or if
// the widget becomes un-focusable.
// This function doesn't remove the widget from the tab order of the page - it doesn't set the
// native tab index to -1 or null.
// It just
_removeFromAutoTabOrder : function () {
    // if we're not managing the tab index, nothing to do
    if (!this._autoTabIndex || !this.tabIndex) return;

    var prevWidget = this._getPreviousTabWidget(),
        nextWidget = this._getNextTabWidget();

    // if this method has been run before, we can just return
    if (prevWidget == null && nextWidget == null && isc.EH._lastTabWidget != this &&
        isc.EH._firstTabWidget != this) return;


    if (prevWidget) {
        prevWidget._setNextTabWidget(nextWidget);
    } else {
        isc.EH._firstTabWidget = nextWidget;
    }

    if (nextWidget) {
        nextWidget._setPreviousTabWidget(prevWidget);
    } else {

        isc.EH._lastTabWidget = prevWidget;
    }

    this._setPreviousTabWidget(null);
    this._setNextTabWidget(null);
},

// zIndex (stacking order)
// --------------------------------------------------------------------------------------------
// See also class method Canvas.getNextZIndex();

//> @method canvas.getZIndex()  (A)
//  Get the z-Index of this canvas.<br><br>
//
//      @group  zIndex
//
//      @param resolveToNumber(boolean)
//              If passed <code>true</code>, for undrawn widgets, resolve "auto" to the next available zIndex.
//
//      @return (number)
// @visibility external
//<
getZIndex : function (resolveToNumber) {


    if (!this.isDrawn() || isc.Browser.isSafari) {
        // if passed the 'resolveToNumber' parameter, update the zIndex to be a valid number.
        if (resolveToNumber && this.zIndex == isc.Canvas.AUTO) {
            this.setZIndex(isc.Canvas.getNextZIndex());
        }
        return this.zIndex;
    }

    return parseInt(this.getStyleHandle().zIndex);
},

//> @method canvas.setZIndex()  (A)
//          set the z-Index of the canvas.
//      @group  zIndex
//      @param  newIndex        (number)    new zIndex to set to
//<

setZIndex : function (newIndex) {
    var oldZIndex = this.zIndex;
    if (oldZIndex == newIndex) return;

    var hasNativeFocusInIE = false;

    // NOTE: In IE there is a native bug whereby if the handle of a canvas has native
    // focus, and we attempt to set the z-index, the widget will not have its z-index updated.
    // Fix this by natively blurring the canvas, and re-focussing at the end of the message
    // (without firing any focus/blur handlers)
    if (isc.Browser.isIE && this.hasFocus && this._useNativeTabIndex)
    {
        hasNativeFocusInIE = true;
        this.logDebug("blurring due to zIndex change", "nativeFocus");
        this._setFocusWithoutHandler(false);
    }

    // adjust zIndices of the backmask and other special peers.  Note - we do this first if
    // we're moving the widget back in the Z-order, and last if we're moving the widget forward
    // in the z-order, so the peers never pop in front

    if (newIndex < oldZIndex) this._adjustSpecialPeers(newIndex);

    this.zIndex = newIndex;
    if (this.isDrawn()) {

        // if using two DIVs, set zIndex for both DIVs that we draw
        if (this._drewClipDiv) this.getHandle().style.zIndex = newIndex

        this.getStyleHandle().zIndex = newIndex;
    }

    if (newIndex > oldZIndex) this._adjustSpecialPeers(newIndex);

    // Keep custom scrollbars above us.
    if (this.hscrollbar) this.hscrollbar.moveAbove(this);
    if (this.vscrollbar) this.vscrollbar.moveAbove(this);

    //>CornerClips keep corner clips above us
    if (this.clipCorners) {
        var clips = this._cornerClips;
        if (clips.TL) clips.TL.moveAbove(this);
        if (clips.TR) clips.TR.moveAbove(this);
        if (clips.BL) clips.BL.moveAbove(this);
        if (clips.BR) clips.BR.moveAbove(this);
    }
    //<CornerClips

    if (hasNativeFocusInIE) {
        // refocus on a timeout if we've blurred.

        this.delayCall("_restoreFocus", [], 0);
    }

    this.zIndexChanged(oldZIndex, newIndex);
},

_adjustSpecialPeers : function (newIndex) {
    if (this._edgesAsPeer()) this._edgedCanvas.setZIndex(newIndex-1);
    if (this._backMask) this._backMask.setZIndex(newIndex-2);
    if (this._shadow) this._shadow.setZIndex(newIndex-3);
    if (this.modalMask) this.modalMask.setZIndex(newIndex-4);
},

// zIndexChanged - notification fired if our zIndex has changed.
// calls 'parentZIndexChanged()' on any descendants by default.
zIndexChanged : function (oldZIndex, newZIndex) {
    if (!this.parentElement &&
        isc.Hover.lastHoverCanvas == this && isc.Hover.hoverCanvas.isVisible() &&
        isc.Hover.hoverCanvas.getZIndex() < newZIndex)
    {
        isc.Hover.hoverCanvas.bringToFront();
    }

    if (this.children) this.children.map("parentZIndexChanged");
},

// parentZIndexChanged - notification fired when an ancestor's zIndex has changed.
// recursively calls this same method on any descendants so the whole descendant-chain is
// notified of the ZIndex change.
parentZIndexChanged : function () {
    if (isc.Hover.lastHoverCanvas == this && isc.Hover.hoverCanvas.isVisible()) {
        var topElement = this.getTopLevelCanvas();
        if (isc.Hover.hoverCanvas.getZIndex() < topElement.getZIndex())
        {
            isc.Hover.hoverCanvas.bringToFront();
        }
    }
    if (this.children) this.children.map("parentZIndexChanged");
},


//> @method canvas.bringToFront()   ([])
// Puts this widget at the top of the stacking order, so it appears in front of all other
// widgets in the same parent.
//      @visibility external
//      @group  zIndex
//      @example    layer
//<

bringToFront : function (skipSoftUnmask) {
    if (isc._traceMarkers) arguments.__this = this;

    isc.Canvas._BIG_Z_INDEX += 18;
    this.setZIndex(isc.Canvas._BIG_Z_INDEX);

    // if we're showing a groupLabel, bring that above this canvas
    if (this.groupLabel) this.groupLabel.moveAbove(this);

    // If we're in a parent showing a component-level click mask, have bringToFront move it
    // above the mask and unmask it.

    var parent = this.getParentCanvas();
    if (parent && parent.componentMaskShowing && parent.componentMask != this) {
        if (parent._unmaskedChildren == null) {
            parent._unmaskedChildren = [this];
        } else if (!parent._unmaskedChildren.contains(this)) {
            parent._unmaskedChildren.add(this);
        }
        // re-enable keyboard events
        this.disableKeyboardEvents(false, true, true);
    }


    if (skipSoftUnmask && !this._isHardMasked()) return;

    isc._unmaskOnBringToFront = true;
    this.unmask();
    isc._unmaskOnBringToFront = false;
},


//> @method canvas.sendToBack() ([])
// Puts this widget at the bottom of the stacking order, so it appears behind all other
// widgets in the same parent.
//      @visibility external
//      @group  zIndex
//      @example    layer
//<

sendToBack : function () {
    // if we're showing a groupLabel, push it back as well
    if (this.groupLabel) this.groupLabel.sendToBack();

    isc.Canvas._SMALL_Z_INDEX -= 18;
    this.setZIndex(isc.Canvas._SMALL_Z_INDEX);
},


//> @method canvas.moveAbove()  ([])
// Puts this widget just above the specified widget in the stacking order, so it appears in
// front of the specified widget if both widgets have the same parent.
//      @visibility external
//      @group  zIndex
//      @param  canvas      (Canvas or subclass)    canvas to move above
//      @example    layer
//<
moveAbove : function (canvas) {
    // if the other Canvas has "auto" because it hasn't drawn yet, assign it a zIndex now
    // Note - this method will always set the zIndex so that this widget is adjacent to the
    // other widget (may lower the zIndex of this widget if it is already well above the other
    // widget).
    // Therefore we can't no-op if this widget is already above the other widget without a
    // functional change.
    var z = canvas.getZIndex(true);
    if (canvas.groupLabel) z = Math.max(z,canvas.groupLabel.getZIndex(true));
    this.setZIndex(z + 6);
},


//> @method canvas.moveBelow()
// Puts this widget just below the specified widget in the stacking order, so it appears
// behind the specified widget if both widgets have the same parent.
//      @visibility external
//      @group  zIndex
//      @param  canvas      (Canvas or subclass)    canvas to move below
//      @example    layer
//<
moveBelow : function (canvas) {
    // Note - this method will always set the zIndex so that this widget is adjascent to the
    // other widget (may raise the zIndex of this widget if it is already well below the other
    // widget).
    // Therefore we can't no-op if this widget is already below the other widget without a
    // functional change.
    // if the other Canvas has "auto" because it hasn't drawn yet, assign it a zIndex now
    var z = canvas.getZIndex(true);
    this.setZIndex(z - 6);
},


// Setting / Getting HTML Content
// --------------------------------------------------------------------------------------------

//> @method canvas.getContents()
//      Returns the contents of a Canvas. The contents are an HTML string.
// @return (HTML) contents of this Canvas
// @visibility external
//<
getContents : function () {
    var contents = (isc.isA.Function(this.contents) ? this.contents() : this.contents);
    return this.dynamicContents ?
            contents.evalDynamicString(this, this.dynamicContentsVars) :
            contents;
},


//> @method canvas.setContents()
// Changes the contents of a widget to newContents, an HTML string.
// <P>
// When +link{canvas.dynamicContents,dynamicContents} is set, <code>setContents()</code> can
// also be called with no arguments to cause contents to be re-evaluated.
//
//  @param  [newContents]   (string)    an HTML string to be set as the contents of this widget
//  @visibility external
//  @example setContents
//<
setContents : function (newContents) {
    if (newContents != null) this.contents = newContents;
    this.markForRedraw("setContents");
},

// Loading HTML Content
// ---------------------------------------------------------------------------------------

containsIFrame : function () {
    return this.contentsURL != null && this.contentsType == "page";
},



//> @method canvas.getContentsURL()    ()
//      Returns the contentsURL of a widget.
//<
getContentsURL : function () {
    return this.contentsURL;
},

//> @method canvas.setContentsURL()
//  Change the contentsURL of the Canvas
//
//      @param  newURL  (string)
//<
setContentsURL : function (url, params) {
    // store new URL
    this.contentsURL = url;

    // support special prefixes, eg [APPFILES]
    url = isc.Page.getURL(url);
    // support params (NOTE: doc'd under HTMLFlow)
    var allParams = isc.addProperties({}, this.contentsURLParams, params),
    url = isc.rpc.addParamsToURL(url, allParams);

    if (!this.isDrawn()) return;

    if (this.containsIFrame()) {
        // Modify the src property on the IFRAME to move to the new URL.
        var urlHandle = this._getURLHandle();

        if (!urlHandle || !url) this.markForRedraw("setContentsURL");
        else urlHandle.src = url;
    }
},

// Miscellaneous styling setters
// --------------------------------------------------------------------------------------------

//> @method canvas.setBackgroundColor()
// Sets the background color of this component to <code>newColor</code>.
// @param newColor (CSSColor) new background color, or <code>null</code> to remove the current
// background color.
// @group appearance
// @visibility external
//<
setBackgroundColor : function (newColor) {
    this.backgroundColor = newColor;
    var styleHandle = this.getStyleHandle();
    if (styleHandle != null) {

        styleHandle.backgroundColor = (newColor == null ? "" : newColor);
    }
},


setTextColor : function (newColor) {
    this.textColor = newColor;
    var styleHandle = this.getStyleHandle();
    if (styleHandle) {
        return styleHandle.color = newColor;
    }
},

//> @method canvas.setBackgroundImage()
//          Sets the background to an image file given by newImage. This URL should be given as a
//          string relative to the image directory for the page (./images by default).
//      @group  appearance
//      @param  newImage    (string)    new URL (local to Page image directory) for background image
//      @visibility external
//<
setBackgroundImage : function (newImage) {
    this.backgroundImage = newImage;
    var styleHandle = this.getStyleHandle();
    if (styleHandle) {
        if (newImage == null) {
            styleHandle.backgroundImage = "";
        } else {
            styleHandle.backgroundImage = 'url(' + this.getImgURL(this.backgroundImage) + ')';
        }
    }
},


//> @method canvas.setBorder()
// Set the CSS border of this component, as a CSS string including border-width,
// border-style, and/or color (eg "2px solid blue").
// <P>
// This property applies the same border to all four sides of this component.  Different
// per-side borders can be set in a CSS style and applied via +link{styleName}.
//
// @group appearance
// @param newBorder (string) new border to set to (eg: "2px solid black")
// @visibility external
//<
setBorder : function (newBorder) {
    this._cachedBorderSize = null;

    if (newBorder != null && !isc.isA.String(newBorder)) {
        newBorder = this._convertBorderToString(newBorder);
    }

    if (newBorder == null) newBorder = isc.emptyString;

    // Avoid a mysterious JS error in IE6 if someone passes in a string like
    // "2px solid gold;" rather than "2px solid gold"
    if (isc.endsWith(newBorder, isc.semi)) newBorder = newBorder.slice(0,newBorder.length-1);

    this.border = newBorder;

    var styleHandle = this.getStyleHandle();
    // if we're undrawn, no need to continue
    if (!styleHandle) return;
    if (styleHandle.border != newBorder) {
        styleHandle.border = newBorder;
    }

    this.adjustOverflow("setBorder");

    this.innerSizeChanged("Border thickness changed");
},

// convert a non-string border into something usable, or drop it
_convertBorderToString : function (border) {
    var specifiedBorder = border;
    if (isc.isA.Number(border)) {
        border += "px solid";
    } else {
        border = null;
         //>DEBUG
         this.logWarn("this.border defined as " + specifiedBorder +
                    ". This property should have a string value - dropping this attribute.");
         //<DEBUG
    }

    return border;
},

// convert a non-string border radius into something usable, or drop it
_convertBorderRadiusToString : function (borderRadius) {
    return (isc.isA.Number(borderRadius) ? borderRadius + "px" : null);
},

//> @method canvas.getBorder()
// Get the border for this canvas
//      @group  appearance
//      @return (string)    css border string (eg: "2px solid black")
//<
getBorder : function () {
    return this.border;
},

//> @method canvas.setOpacity() ([])
// Sets the opacity for the widget to the newOpacity value. This newOpacity
// value must be within the range of 0 (transparent) to 100 (opaque).
// Null means don't specify opacity directly.
// Note that heavy use of opacity may have a performance impact on some older
// browsers.
// <P>
// In older versions of Internet Explorer (Pre IE9 / HTML5), opacity is achieved
// through proprietary filters. If
// +link{canvas.neverUseFilters,filters have been disabled} within this application
// developers must set +link{canvas.useOpacityFilter} to true for specific components
// on which opacity support is required.
// <P>
// Also note that opacity is incompatible
// with +link{canvas.useBackMask,backMasks}.
//      @group  cues
//      @param  newOpacity  (number)    new opacity level
//      @visibility external
//      @example translucency
//<
//>Animation
// @param [animating] (boolean) passed if this setOpacity is part of an animated set opacity
//<Animation
setOpacity : function (newOpacity, animating, forceFilter) {
    //this.logWarn("setOpacity: " + newOpacity + ", animating: " + animating +
    //             this.getStackTrace());

    //>Animation
    if (!animating && this.fadeAnimation) this.finishAnimation("fade");
    //<Animation
    var oldOpacity = this.opacity;
    this.opacity = newOpacity;

    // ensure we null out the opacity setting when we go back to 100 (opaque), except for Moz
    // (see below).
    // In IE at least, this avoids issues where filters interact with each other unexpectedly,
    // specifically an Alpha filter on some parent will cause burn through issues with Gradient
    // or AlphaImageLoader filters that appear within table cells nested somewhere underneath
    if (this.opacity == 100 && !forceFilter && !(this.smoothFade && isc.Browser.isMoz)) this.opacity = null;

    if (this.isDrawn()) {
        if (isc.Browser.isMoz) {

            var opacity = (this.opacity != null) ? this.opacity / 100 : "";

            if (this.smoothFade && (opacity == 1 || this.opacity == null)) opacity = 0.9999;
            if (this._useMozOpacity) this.getStyleHandle().MozOpacity = opacity;
            else this.getStyleHandle().opacity = opacity;

        } else if (isc.Browser.isIE && !isc.Browser.isIE9) {

            if (!isc.Canvas.neverUseFilters || this.useOpacityFilter) {
                // Using proprietary Microsoft filters to achieve opacity
                this.getStyleHandle().filter = (this.opacity == null ? "" :
                        "progid:DXImageTransform.Microsoft.Alpha(opacity="+this.opacity+")");
            }



        // Safari, Opera, other: CSS3 opacity
        } else {
            var opacity = (this.opacity != null) ? this.opacity / 100 : "";
            this.getStyleHandle().opacity = opacity;
        }
    }

    this._setPeersOpacity(newOpacity, animating, forceFilter || newOpacity != null);

    if (isc.Browser.isIE && this.fixIEOpacity && this.children) {

        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (child.opacity == null && (forceFilter || newOpacity != null)) {
                //this.logWarn("setting child: " + child + " to 100");
                child.setOpacity(100, animating, true);
            } else if (child.opacity == 100) {
                //this.logWarn("setting child: " + child + " to null");
                child.setOpacity(null);
            }
        }
    }

    this.opacityChanged(newOpacity, animating);
},

//> @method canvas.opacityChanged() ([])
//  Observable method called whenever a Canvas changes opacity.
// @param   newOpacity  (number)    new opacity level
//<
//>Animation
// @param [animating] (boolean) passed if this setOpacity is part of an animated set opacity
//<Animation
opacityChanged : function (newOpacity, animating) {},

// When opacity changes, update peers with new opacity
_setPeersOpacity : function (newOpacity, animating, forceFilter) {
    if (!this.peers) return;
    for (var i = 0; i < this.peers.length; i++) {

        if (this.peers[i]._setOpacityWithMaster) {
            if (this.useOpacityFilter != null) {
                this.peers[i].useOpacityFilter = this.useOpacityFilter;
            }
            this.peers[i].setOpacity(newOpacity, animating, forceFilter);
        } else if (this.peers[i] == this.edgedCanvas && this.edgeOpacity) {
            if (this.useOpacityFilter != null) {
                this.peers[i].useOpacityFilter = this.useOpacityFilter;
            }
            // If edgeOpacity is set, convert it to a percentage of the parents opacity
            var compOpacity = Math.round(this.opacity * (this.edgeOpacity * .01));
            this.peers[i].setOpacity(compOpacity, animating, forceFilter);
        }
    }
},



//> @method canvas.setPrompt()
// Set the prompt for this <code>Canvas</code>. If +link{Canvas.showHover,this.showHover} is
// <code>true</code> this will be displayed in a hover.
//
// @param prompt (HTMLString) the new prompt.
// @group cues
//<
setPrompt : function (prompt) {
    this.prompt = prompt;
    this.updateHover();
},

// Cursor handling
// --------------------------------------------------------------------------------------------

//> @method canvas.setCursor()  ([])
//          Sets the cursor for this widget to cursor. See the cursor property
//          for possible values.
//      @visibility external
//      @group  cues
//      @param  newCursor   (Cursor)    new cursor
//<
setCursor : function (newCursor) {
    if (newCursor && newCursor != this.cursor) {
        this.cursor = newCursor;
        // Call updateCursor to show the new cursor if appropriate
        this._updateCursor();
    }
},

//> @method canvas._applyCursor()     (I)
//      @group  cues
//          Internal method - actually updates the HTML to show a new cursor
//      @param  newCursor   (Cursor)    new cursor
//<
_applyCursor : function (newCursor) {
    if (this._styleCursor == newCursor) return;
    if (this.isDrawn()) {

        if (
            (isc.Browser.isMoz || (isc.Browser.isStrict && isc.Browser.isSafari))
            && newCursor == "hand") newCursor = isc.Canvas.HAND;

        this._styleCursor = newCursor;

        this.getStyleHandle().cursor = newCursor;
        // In double-div browsers, set the cursor of the content div.

        if (this._drewClipDiv) this.getHandle().style.cursor = newCursor;

        // If we are having events proxied to us, update the proxiers' cursors too, since
        // the proxiers' should be treated essentially like an extension of this widget's handle
        if (this._proxiers) {
            for (var i = 0; i < this._proxiers.length; i++) {
                this._proxiers[i]._applyCursor(newCursor);
            }
        }

        if (this.ns.EH._mouseMask && (this == this.ns.EH.getTarget())) {
            this.ns.EH._mouseMask.setCursor(newCursor);
        }

        // In Opera 10.10 and earlier, if the mouse is over this widget, the cursor change won't
        // be picked up unless we force a refresh of the HTML (or the user mouses off, then back
        // on the widget).

        if (isc.Browser.isOpera && isc.Browser.minorVersion < 10.5 && this === isc.EH.lastEvent.target) {
            this.markForRedraw();
        }
    }
},

_updateCursor : function() {
    var currentCursor = this.getCurrentCursor();

    // apply the appropriate cursor to the Canvas

    this._applyCursor(currentCursor);
},


getCurrentCursor : function () {
    // If we don't have a special cursor, we need to show the original cursor.
    var currentCursor = this.cursor;

    // If setNoDropIndicator has been called, show the "no-drop" cursor when the user
    // drags over this widget.
    // Takes presidence over other custom cursors (EG even if disabled we should show this
    // no-drop indicator when the user drags over us).

    if (isc.EH.dragging && this._noDropIndicatorSet && (isc.EH.dragMoveTarget != this)) {
        currentCursor = this.noDropCursor;

    // If showNoDropIndicator has been set at the EH level, have everything where
    // willAcceptDrop returns false show the 'no drop' cursor.

    } else if (isc.EH.showNoDropIndicator && isc.EH.dragDropInProgress() &&
                (!isc.EH.dropTarget || isc.EH.dropTarget.shouldShowNoDropIndicator()))
    {
        currentCursor = this.noDropCursor;

    // If we're disabled, let the disabled cursor show
    } else if (this.isDisabled()) currentCursor = this.disabledCursor;

    // Drag indicators
    else {
        // Edge drag resizing
        var edgeCursor;
        if (this.canDragResize && this.edgeCursorMap) {
            // if this Canvas is resizable and there's an edgeCursorMap
            // determine whether we're on the edge, and show the appropriate cursor
            var edge = this.getEventEdge();
            if (edge && this.edgeCursorMap[edge]) {
                currentCursor = this.edgeCursorMap[edge];
                edgeCursor = true;
            }
            //this.logWarn("over edge: " + edge + " with cursor: " + currentCursor);
        }
        // drag repositioning
        if (!edgeCursor && this.canDragReposition && this.dragRepositionCursor) {
            currentCursor = this.dragRepositionCursor;
        }
    }

    return currentCursor;
},


// Hover handling

//> @method canvas.getHoverTarget() (A)
// This method is fired when a user moves over this widget, and returns a pointer to the widget
// that should receive a hover event if the user remains positioned over this canvas.
// Default implementation will return the first ancestor of this widget (or this widget itself)
// for which <code>canHover</code> is true.  If it encounters a parent for which canHover is
// explicitly set to false, the default implementation returns null.
//  @group hovers
//  @visibility internal
//  @param event (event) Current mouse event.
//  @return (Canvas) Hover target for the current event (or null)
//<
getHoverTarget : function (event, eventInfo) {
    var target = this;
    while (target) {
        var canHover = target.getCanHover();
        if (canHover == null) {
            // If the target has a prompt specified this implies the developer wants hover
            // behavior to show the prompt on that target.
            if (target.prompt != null) return target;
            target = target.parentElement;
        } else if (canHover) {
            return target;
        } else {
            return null;
        }
    }
    return null;
},

//> @method canvas.startHover() (A)
// Handler fired when the mouse goes over a valid hover target, or some other canvas which
// identifies this as the hover target.  Starts the hover timer to fire public hover handling
// methods on the hoverTarget.
//  @group hovers
//  @visibility internal
//  @param event (event) Current mouse event.
//<
startHover : function (event) {
    isc.Hover.setAction(this, this._handleHover, null, this.hoverDelay);
},

//> @method canvas.stopHover() (A)
// Handler fired when the mouse leaves a hover target.
// Clears the hover timer to fire public hover handling methods on the target.
//  @group hovers
//  @visibility internal
//  @param event (event) Current mouse event.
//<

stopHover : function (event) {
    isc.Hover.clear();
},

// Internal method fired when the hover timer returns - will fire exposed hover handler methods.
_handleHover : function () {
    //!DONTCOMBINE
    var EH = isc.EH,
        lastMoveTarget = EH.lastMoveTarget;
    // Catch the case wher the user has moved out of this canvas

    var event = EH.lastEvent;
    if (!lastMoveTarget || lastMoveTarget.getHoverTarget(event) != this) return;

    return this.handleHover();
},

// getCanHover() - should this canvas fire hover events?
getCanHover : function () {
    return this.canHover;
},

//> @attr canvas.showHoverComponents (Boolean : false : IRWA)
// When set to true, shows a widget hovering at the mouse point instead of the builtin
// hover label.  Override +link{canvas.getHoverComponent, getHoverComponent} to provide the
// Canvas to show as the hoverComponent.
// @group hoverComponents
// @visibility external
//<

//> @method canvas.getHoverComponent()
// When +link{showHoverComponents} is true, this method is called to get the component to show
// as a hover for this Canvas.  There is no default implementation of this method, so you need
// to override it with an implementation that returns a Canvas that suits your needs.
// <P>
// By default, components returned by <code>getHoverComponent()</code> will not be
// automatically destroyed when the hover is hidden.  To enforce this, set
// +link{canvas.hoverAutoDestroy} to true on the returned component.
//
// @return (Canvas | Canvas Properties) the component to show as a hover
// @group hoverComponents
// @visibility external
//<
getHoverComponent : function () {
},

//> @method canvas.handleHover() (A)
// Handler fired on a delay when the user hovers the mouse over this hover-target.
// Default implementation will fire <code>this.hover()</code> (if defined), and handle
// showing the hover canvas if <code>this.showHover</code> is true.
//  @group hovers
//  @visibility external
//  @see canvas.canHover
//  @see canvas.showHover
//  @see canvas.hover()
//<
handleHover : function () {
    if (this.hover && this.hover() == false) return;
    if (this.showHover) {
        var component = this.showHoverComponents && this.getHoverComponent ? this.getHoverComponent() : null;
        if (component != null && isc.isA.Canvas(component)) {
            //isc.logWarn("canvas: "+this.getID()+" - showing hoverCanvas: "+this.hoverCanvas.getID());
            // getHoverComponent() returned a Canvas - we'll show that now instead of the
            // hoverHTML in a Label but using the same positioning/sizing logic
            var hoverProperties = this._getHoverProperties();
            isc.Hover.show(component, hoverProperties, null, this);
        } else {
            var HTML = this.getHoverHTML();
            if (HTML != null && !isc.isAn.emptyString(HTML)) {
                var hoverProperties = this._getHoverProperties();
                isc.Hover.show(HTML, hoverProperties, null, this);
            }
        }
    }
},



//> @method canvas.updateHover() (A)
// If this canvas is currently showing a hover (see +link{canvas.handleHover}), this method
// can be called to update the contents of the hover. Has no effect if the hover canvas is not
// showing for this widget.
//  @param [hoverHTML] (string) Option to specify new HTML for the hover. If not passed, the result
//   of +link{canvas.getHoverHTML(),this.getHoverHTML()} will be used instead. Note that if the
//   hover HTML is empty the hover will be hidden.
//  @group hovers
//  @visibility external
//<
updateHover : function (hoverHTML) {
    if (isc.Hover.lastHoverCanvas != this || !isc.Hover.hoverCanvas.isVisible()) return;
    if (hoverHTML == null) hoverHTML = this.getHoverHTML();
    isc.Hover.show(hoverHTML,  this._getHoverProperties(), null, this);
},

_hoverHidden : function () {
    // if we have a local reference to the hoverCanvas, it's a canvas we've returned from
    // getHoverComponent, rather than the built-in label from isc.Hover.  If it's been flagged
    // for auto-destruction on hide, do that now...
    if (this.hoverCanvas && this.hoverCanvas.hoverAutoDestroy != false) {
        //isc.logWarn("canvas: "+this.getID()+" - auto-destroying hoverCanvas: "+this.hoverCanvas.getID());
        this.hoverCanvas.markForDestroy();
        this.hoverCanvas = null;
        delete this.hoverCanvas;
    }

    this.hoverHidden();
},

//> @method canvas.hoverHidden() (A)
// If +link{canvas.showHover,showHover} is true for this canvas, this notification method will be
// fired whenever the hover shown in response to +link{canvas.handleHover(),handleHover()} is
// hidden. This method may be observed or overridden.
// @group hovers
// @visibility external
//<
hoverHidden : function () {},

// Helper method to assemble the properties to apply to the hover canvas into an object to pass
// to Hover.show()
_getHoverProperties : function () {
    var target = isc.EH.getTarget(),
        parent = target ? isc.isA.CanvasItem(target) ? target : target.canvasItem : null,
        result
    ;

    if (parent) {
        result = {
            width: (parent.hoverWidth != null ? parent.hoverWidth : this.hoverWidth),
            height: (parent.hoverHeight != null ? parent.hoverHeight : this.hoverHeight),
            align: (parent.hoverAlign != null ? parent.hoverAlign : this.hoverAlign),
            valign: (parent.hoverVAlign != null ? parent.hoverVAlign : this.hoverVAlign),
            baseStyle: (parent.hoverStyle != null ? parent.hoverStyle : this.hoverStyle),
            opacity: (parent.hoverOpacity != null ? parent.hoverOpacity : this.hoverOpacity),
            moveWithMouse: (parent.hoverMoveWithMouse != null ?
                        parent.hoverMoveWithMouse : this.hoverMoveWithMouse),
            wrap: (parent.hoverWrap != null ? parent.hoverWrap : this.hoverWrap)
        };
        return result;
    }


    return {    width:this.hoverWidth, height:this.hoverHeight, align:this.hoverAlign,
                valign:this.hoverVAlign, baseStyle:this.hoverStyle, opacity:this.hoverOpacity,
                moveWithMouse:this.hoverMoveWithMouse, wrap:this.hoverWrap
           };
},

//> @method canvas.hover()
// If <code>canHover</code> is true for this widget, the <code>hover</code> string method will
// be fired when the user hovers over this canvas. If this method returns false, it will
// suppress the default behavior of showing a hover canvas if <code>this.showHover</code>
// is true.
//  @return (boolean) false to cancel the hover event.
//  @group hovers
//  @see canvas.canHover
//  @visibility external
//<


//> @method canvas.getHoverHTML()
// If <code>this.showHover</code> is true, when the user holds the mouse over this Canvas for
// long enough to trigger a hover event, a hover canvas is shown by default. This method returns
// the contents of that hover canvas. Default implementation returns <code>this.prompt</code> -
// override for custom hover HTML. Note that returning <code>null</code> or an empty string will
// suppress the hover canvas altogether.
//  @group hovers
//  @see canvas.showHover
//  @return (HTMLString) the string to show in the hover
//  @visibility external
//<
getHoverHTML : function () {
    return this.prompt;
},

// CSS Style methods
// ------------------------------------------------------------------------------------------------------

//> @method canvas.setClassName()   ([A])
// Sets the CSS class for this widget
//      @visibility external
//      @group  appearance
//      @param  newClass        (string)    new CSS class name (must be defined previously)
//  @deprecated As of SmartClient version 5.5, use +link{canvas.setStyleName()} instead.
//<
_$styleName:"styleName",
setClassName : function (newClass) {
    // we expect this to happen a lot as we haven't converted all internal usage of .className
    // Log a warning at the info level only
    if (this.logIsInfoEnabled(this._$styleName)) {
        this.logInfo("call to deprecated setClassName() property - use setStyleName() instead");
    }
    return this.setStyleName(newClass);
},

//> @method canvas.setStyleName()
// Sets the CSS class for this widget
// @group appearance
// @param newStyle (CSSStyleName) new CSS style name
// @visibility external
// @example styles
//<
setStyleName : function (newStyle) {
    this._cachedBorderSize = null;
    this._cachedPadding = null;


    this._childrenCoordsChanged();

    this.styleName = newStyle;
    // Also update the depreacted className property
    this.className = newStyle;

    var clipHandle = this.getClipHandle();
    if (clipHandle != null) clipHandle.className = (newStyle == null ? isc.emptyString : newStyle);


    if (this.overflow != isc.Canvas.HIDDEN) {


        if (this.overflow == isc.Canvas.VISIBLE) this._resetHandleOnAdjustOverflow = true;
        this.adjustOverflow("setStyleName");
     }
},

//> @method canvas.getStateName()   (A)
//          get the CSS class for a particular canvas (not what it is, what it should be)
//          OVERRIDE to implement some other scheme
//      @group  appearance
//
//      @return (CSSStyleName)  name of the style to set the canvas to
//<
getStateName : function () {
    var handleClassName = this.getClipHandle() ? this.getClipHandle().className : null;

    return (handleClassName != null ? handleClassName : this.styleName);
},


// Context Menu Handling
// ------------------------------------------------------------------------------------------------

// Internal contextMenu event handler to fire partwise events if appropriate.
handleShowContextMenu : function (event) {
    if (event.target == this && this.useEventParts) {
        var partInfo = this.getEventPart(event);
        // Fire showCM for appropriate part
        if (partInfo.part) {
            if (this._firePartEvent(partInfo.part,
                                    "showContextMenu",
                                    partInfo.element,partInfo.ID,event) == false) return false;
        }
    }
    if (this.showContextMenu) return this.showContextMenu(event);

},

//> @method canvas.showContextMenu()    (A)
// Executed when the right mouse button is clicked.  The default implementation of
// this method auto-creates a +link{class:Menu} from the +link{attr:canvas.contextMenu} property on
// this component and then calls +link{method:menu.showContextMenu} on it to show it.
// <p>
// If you want to show a standard context menu, you can simply define your Menu and set it as the
// contextMenu property on your component - you do not need to override this method.
// <p>
// If you want to do some other processing before showing a menu or do something else entirely, then
// you should override this method.  Note that the return value from this method controls whether or
// not the native browser context menu is shown.
//
// @return (boolean)    false == don't show native context menu, true == show native context menu
// @group widgetEvents
// @see attr:contextMenu
// @see method:menu.showContextMenu
// @see method:canvas.hideContextMenu
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @platformNotes
// On the Mac platform, context menu functionality may be triggered by <code>Command+click</code><br>
// On the Opera browser, context menu functionality may be triggered by <code>Shift+Ctrl+click</code>
//<
showContextMenu : function () {
    var menu = this.contextMenu;
    if (menu) {
        menu.target = this;
        if (!isc.isA.Canvas(menu)) {
            menu.autoDraw = false;
            this.contextMenu = menu = this.getMenuConstructor().create(menu);
        }
        menu.showContextMenu();
    }
    return (menu == null);
},

getMenuConstructor : function () {
    var menuClass = isc.ClassFactory.getClass(this.menuConstructor);
    if (!menuClass) {
        isc.logWarn("Class not found for menuConstructor:" + this.menuConstructor +
            ". Defaulting to isc.Menu class");
        menuClass = isc.ClassFactory.getClass("Menu");
    }
    return menuClass;
},

//> @method canvas.hideContextMenu()    (A)
//
// The default implementation of this method hides the contextMenu currently being shown for this
// component (which occurs when the mouse button that toggles the context menu is released).
// Override if you want some other behavior.
//
// @see showContextMenu()
// @see menu.hideContextMenu()
// @group   widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<
hideContextMenu : function (){
    if (this.contextMenu) this.contextMenu.hideContextMenu();
},

// Mouse Events
// ------------------------------------------------------------------------------------------------------

//> @method canvas.mouseOver() (A)
//
// Executed when mouse enters this widget.  No default implementation.
//
// @return (Boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<


//> @method canvas.mouseDown() (A)
// Executed when the left mouse button is pressed on this widget.  No default implementation.
//
// @platformNotes If the end user system has only one mouse button, then it is considered the "left"
//                mouse button (and this method would execute when it is pressed on this widget).
//
// @return (Boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<

// _allowNativeTextSelection.
// By default returns this.canSelectText

_allowNativeTextSelection : function (event) {
    return this.canSelectText;
},

//> @method canvas.rightMouseDown() (A)
// Executed when the right mouse button is pressed on this widget.  No default implementation.
//
// @platformNotes Some end user systems only have one mouse button.
//
// @return (boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<


//> @method canvas.mouseStillDown() (A)
//
// Executed repeatedly (every +link{attr:canvas.mouseStillDownDelay} by default) when the system is idle -
// i.e. not busy running other scripts - and the left mouse button is held down after having been
// pressed in the object. This event is not native to JavaScript, but is provided by the ISC system.
// <p>
// Note: The event handling system waits +link{attr:canvas.mouseStillDownInitialDelay} before
// calling mouseStillDown for the first time on the widget.  Subsequently the method is called every
// +link{attr:canvas.mouseStillDownDelay}.  Both attributes are configurable per widget instance.
// <p>
// This method is called only when the left mouse is held down.
//
// @platformNotes Some end user systems only have one mouse button.
//
// @return (boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see mouseStillDownInitialDelay
// @see mouseStillDownDelay
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @example customMouseEvents
//<


//> @method canvas.mouseMove() (A)
//
// Executed when the mouse moves within this widget.  No default implementation.
//
// @return (Boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @example customMouseEvents
//<


//> @method canvas.mouseOut() (A)
//
// Executed when the mouse leaves this widget.  No default implementation.
//
// @return (Boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @visibility external
// @example customMouseEvents
//<



//> @method canvas.mouseUp() (A)
//
// Executed when the left mouse is released on this widget.  No default implementation.
//
// @return (Boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @example customMouseEvents
//<


//> @method canvas.click() (A)
//
// Executed when the left mouse is clicked (pressed and then released) on this widget.  No default
// implementation.
//
// @return (Boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<


//> @method canvas.doubleClick() (A)
//
// Executed when the left mouse button is clicked twice in rapid succession (within
// +link{attr:Canvas.doubleClickDelay} by default) in this object.
//
// @return (boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @see doubleClickDelay
// @group widgetEvents
// @visibility external
//<

//> @method canvas.mouseWheel() (A)
//
// Executed when the mouse wheel is actuated.
//
// @platformNotes Not all end user systems have mouse wheels.
//
// @return (boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see EventHandler.getWheelDelta()
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @example customMouseEvents
//<

// Partwise mouse event handling
// ------------------------------------------------------------------------------------------------------
// In some cases we want to be able to respond to events over HTML elements written into our handle
// (For example the 'drawRect()' / 'rectMouseMove()' et al system).
// We handle this by writing an attribute 'eventPart' onto the elements in question and treating
// events occurring over these elements specially (firing custom handlers depending on the
// part name).
// This is all disabled by default - enable by flipping the 'useEventParts' attribute

// Implement handleMouseMove to fire part-wise events if we're configured to do so and the
// user is over a 'part' type element
handleMouseMove : function (event, eventInfo) {
    if (event.target == this && this.useEventParts) {
        var partInfo = this.getEventPart(event),
            lastOverPart = this._lastOverPart;

        // If we moved out of a part, fire a [part]Out handler
        if (lastOverPart &&  lastOverPart.part &&
            (lastOverPart.part != partInfo.part || lastOverPart.ID != partInfo.ID))
        {
            this._firePartEvent(lastOverPart.part, isc.EH.MOUSE_OUT,
                                lastOverPart.element, lastOverPart.ID, event);
        }

        // Fire over or move handler on the new part
        if (partInfo.part) {

            var newPart = !lastOverPart || (lastOverPart.ID != partInfo.ID),
                eventType = (newPart ? isc.EH.MOUSE_OVER : isc.EH.MOUSE_MOVE)
            ;

            this._firePartEvent(partInfo.part, eventType, partInfo.element,partInfo.ID,event);

            // If this is a new part, we want to start the part-wise hover timer

            if (newPart) {
                isc.Hover.setAction(this, this._handleRectHover, [partInfo.element, partInfo.ID], this.hoverDelay);
            }

        }

        this._lastOverPart = partInfo;
    }

    if (this.mouseMove) return this.mouseMove(event, eventInfo);
},

// Handle a hover on a rect written out by the drawRect() system
_handleRectHover : function (element, ID) {
    //!DONTCOMBINE
    if (this._lastOverPart) this._firePartEvent(this._lastOverPart.part, "hover", element, ID);
},

// Implement handleMouseOut to trip the part-wise mouseOut handler if we're firing
// partwise events, and the user is moving off an event part.
handleMouseOut : function (event, eventInfo) {
    if (event.target == this && this.useEventParts) {
        var lastOverPart = this._lastOverPart;
        if (lastOverPart && lastOverPart.part) {
            this._firePartEvent(lastOverPart.part, isc.EH.MOUSE_OUT,
                                lastOverPart.element, lastOverPart.ID, event);
        }
    }
    if (this.mouseOut) return this.mouseOut(event, eventInfo);
},

// Implement handle mouseDown, mouseUp, click and doubleClick to fire partwise events if
// appropriate
handleMouseDown : function (event, eventInfo) {
    // cancel any momentum scrolling from drag scrolling
    var animationId = this._momentumScrollId;
    if (animationId != null) {
        this.cancelAnimation(animationId);
        this._momentumScrollId = null;
    }

    if (event.target == this && this.useEventParts) this.firePartEvent(event, isc.EH.MOUSE_DOWN);
    if (this.mouseDown) return this.mouseDown(event, eventInfo);
},

handleRightMouseDown : function (event, eventInfo) {
    if (event.target == this && this.useEventParts) {
        this.firePartEvent(event, isc.EH.RIGHT_MOUSE_DOWN);
    }
    if (this.rightMouseDown) return this.rightMouseDown(event, eventInfo);
},

handleMouseUp : function (event, eventInfo) {
    if (event.target == this && this.useEventParts) this.firePartEvent(event, isc.EH.MOUSE_UP);
    if (this.mouseUp) return this.mouseUp(event, eventInfo);
},

handleClick : function (event, eventInfo) {
    if (event.target == this && this.useEventParts) this.firePartEvent(event, isc.EH.CLICK);
    if (this.click) return this.click(event, eventInfo);
},

handleDoubleClick : function (event, eventInfo) {
    if (event.target == this && this.useEventParts) this.firePartEvent(event, isc.EH.DOUBLE_CLICK);
    if (this.doubleClick) return this.doubleClick(event, eventInfo);
},

handleTouchStart : function (event, eventInfo) {
    if ((isc.Browser.isIPhone || isc.Browser.isIPad) &&
        event.target === this &&
        this.isDrawn() &&
        this._usingNativeTouchScrolling())
    {


        this._iosScrollFixInProgress = true;

        var elem = this.getClipHandle();
        var scrollTop = elem.scrollTop;
        if (scrollTop <= 0) elem.scrollTop = 1;
        else if (scrollTop + elem.clientHeight >= elem.scrollHeight) {
            elem.scrollTop = elem.scrollHeight - elem.clientHeight - 1;
        }


        this._preventNativeScrolling = elem.scrollHeight <= elem.clientHeight;

    }
},

handleTouchMove : function (event, eventInfo) {
    if ((isc.Browser.isIPhone || isc.Browser.isIPad) &&
        event.target === this &&
        this.isDrawn() &&
        this._usingNativeTouchScrolling() &&
        this._preventNativeScrolling)
    {
        return false;
    }
},

// "longTouch" event - fired by touch browsers when the user holds their finger over a
// widget.
// By default this is wired into the context click event system
handleLongTouch : function (event, eventInfo) {
    return this.handleShowContextMenu(event, eventInfo);
},

_$eventPart:"eventpart",
//> @method canvas.getEventPart()
// If this canvas is using partwise events, given an event determine which part it occurred over
// @visibility eventParts
//<
getEventPart : function (event) {
    if (!event) event = isc.EH.lastEvent;
    var part = event.eventPart,
        partID = event.eventPartID;

    if (partID == isc.emptyString) {
        partID = null;

    // part elements' IDs are expected to be of the form <widgetID>_partType_partID
    } else if (partID != null) {
        partID = partID.substring(this.getID().length + part.length + 2);
    }
    var partInfo = {part:part, ID:partID, element:event.nativeTarget};
    return partInfo;
},


getElementPart : function (element) {
    var part, partID;
    if (this.isDrawn() && element != null) {
        var handle = this.getHandle();

        if (isc.isA.Canvas(element)) element = element.getHandle();
        while (element != handle && element != null) {
            if (element.getAttribute) {
                part = element.getAttribute(this._$eventPart);
            }
            if (part == null || part == isc.emptyString) {
                element = element.parentNode;
            } else {
                break;
            }
        }

        if (part && part != isc.emptyString) {
            var elementID = element.id;
            if (elementID && elementID != isc.emptyString) {
                partID = elementID.substring(this.getID().length + part.length + 2);
            }
        }
    }

    return {part:part, ID:partID, element:element};
},

// For the AutoTest APIs, we need to be able to get back at the eventPart handle from the part
// name.

getPartElement : function (partObj) {
    // check for standardized element ID first
    var part = partObj.part,
        partID = partObj.partID,
        elementID = this.getID() + "_" + part;
    if (partID) elementID += partID;
    var element = isc.Element.get(elementID);
    if (element) return element;

    // If we didn't find it do an iteration through our descendent nodes
    return isc.Element.findAttribute(this.getHandle(), this._$eventPart, part);
},

// Given a generic event on this widget, determine whether it occurred over a specific 'part'
// If so, fire the appropriate part event.
firePartEvent : function (event, eventType) {
    if (!this.useEventParts || !event) return;
    var partInfo = this.getEventPart(event);
    if (!partInfo.part) return;

    if (!eventType) eventType = event.eventType;

    return this._firePartEvent(partInfo.part, eventType, partInfo.element, partInfo.ID, event);
},

// _firePartEvent() - helper to fire <partName>MouseOver() et al.
_firePartEvent : function (partName, eventType, element,ID,event) {
    var handlerName = this.getPartEventHandler(partName, eventType);

    if (this[handlerName]) {
        return this[handlerName](element,ID,event);
    }
},

//> @method canvas.getPartEventHandler()
// Given a part name and an event type, this method returns the name of the part-wise event
// handler to fire (such as "rectMouseOut")
// @visibility eventParts
//<
getPartEventHandler : function (partName, event) {

    if (!isc.Canvas._partHandlers[partName]) isc.Canvas._partHandlers[partName] = {};
    if (!isc.Canvas._partHandlers[partName][event]) {

        // We will fire [partName]MouseOver, [partName]Click, etc.
        var suffix = event.substring(0,1).toUpperCase() + event.substring(1);
        isc.Canvas._partHandlers[partName][event] = partName + suffix;
    }

   return isc.Canvas._partHandlers[partName][event];
},


// Drag and Drop
// ------------------------------------------------------------------------------------------------------

//> @method canvas.dragRepositionStart() (A)
//
// Executed when dragging first starts. No default implementation.  Create this handler to set
// things up for the drag reposition.
//
// @return (boolean) false to cancel the drag reposition action
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<


//> @method canvas.dragRepositionMove() (A)
//
// Executed every time the mouse moves while drag-repositioning. If this method
// does not return false, the +link{attr:canvas.dragTarget} (or outline if
// +link{attr:canvas.dragAppearance} is set to "outline") will automatically be moved as appropriate
// whenever the mouse moves.
//
// @return (boolean) false to suppress auto-move of the +link{attr:canvas.dragTarget} or outline.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<


//> @method canvas.dragRepositionStop() (A)
//
// Executed when the mouse button is released at the end of the drag. Your
// widget can use this opportunity to fire custom code based upon where the
// mouse button was released, etc.
// <p>
// Returning true from this handler will cause the +link{attr:canvas.dragTarget} (or outline if
// +link{attr:canvas.dragAppearance} is set to "outline") to be left in its current
// location. Returning false from this handler will cause it to snap back to its
// original location.
//
// @return (boolean) false to snap the +link{attr:canvas.dragTarget} (or outline) back to its
//                   original location or true to leave it at the current cursor position.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<

//> @method canvas.dragResizeStart() (A)
//
// Executed when resize dragging first starts. No default implementation.
// Create this handler to set things up for the drag resize.
//
// @return (boolean) false to cancel the drag reposition action
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<


//> @method canvas.dragResizeMove() (A)
//
// Executed every time the mouse moves while drag-resizing. If this method
// does not return false, the +link{attr:canvas.dragTarget} (or outline if
// +link{attr:canvas.dragAppearance} is set to "outline") will automatically be moved as appropriate
// whenever the mouse moves.
//
// @return (boolean) false to suppress auto-resize of the +link{attr:canvas.dragTarget} or outline.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<


//> @method canvas.dragResizeStop() (A)
//
// Executed when the mouse button is released at the end of the drag resize. Your
// widget can use this opportunity to fire custom code based upon where the
// mouse button was released, etc.
// <p>
// Returning true from this handler will cause the +link{attr:canvas.dragTarget} (or outline if
// +link{attr:canvas.dragAppearance} is set to "outline") to be left at its current size. Returning
// false from this handler will cause it to snap back to its original location size
//
// @return (boolean) false to snap the +link{attr:canvas.dragTarget} (or outline) back to its
//                   original size or true to leave it at the current cursor position.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<


//> @method canvas.dragStart() (A)
// Executed when dragging first starts. Your widget can use this opportunity to set
// things up for the drag, such as setting the drag tracker. Returning false from this
// event handler will cancel the drag action entirely.
// <p>
// A drag action is considered to be begin when the mouse has moved
// +link{attr:canvas.dragStartDistance} with the left mouse down.
//
// @return (boolean) false to cancel drag action.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @example dragPan
//<


//> @method canvas.dragMove() (A)
// Executed every time the mouse moves while dragging this canvas.
//
// @return (boolean) false to cancel drag interaction.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @example dragPan
//<


//> @method canvas.dragStop() (A)
// Executed when the mouse button is released at the end of the drag. Your widget can
// use this opportunity to fire code based on the last location of the drag or reset any
// visual state that was sent.
//
// @return (boolean) false to cancel drag interaction.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
//<


//> @method canvas.dropOver() (A)
//
// Executed when the compatible dragged object is first moved over this drop target. Your
// implementation can use this to show a custom visual indication that the object can be
// dropped here.
//
// @return (boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @example customDrag
//<

//> @method canvas.dropMove() (A)
//
// Executed whenever the compatible dragged object is moved over this drop target. You
// can use this to show a custom visual indication of where the drop would occur within the
// widget, or to show the +link{canvas.noDropCursor,no-drop cursor} to indicate that
// this is not a valid drop target, typically if +link{willAcceptDrop()} returns false.
// <P>
// For details on showing a 'no drop' cursor when the user drags over all invalid drop
// targets, see +link{EventHandler.showNoDropIndicator}.
//
// @return (boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @example customDrag
//<


//> @method canvas.dropOut() (A)
//
// Executed when the dragged object is moved out of the rectangle of this drop target. If you
// have set a visual indication in dropOver or dropMove, you should reset it to its normal
// state in dropOut.
//
// @return (boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @visibility external
// @example customDrag
//<



//> @method canvas.drop() (A)
//
// Executed when the mouse button is released over a compatible drop target at the end of
// a drag sequence. Your widget should implement whatever it wants to do when receiving a
// drop here. For example, in a file moving interface, a drop might mean that you should
// move or copy the dragged file into the folder it was dropped on, or dropping something in
// a trash can might mean to clear it from the screen.
//
// @return (boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
//
// @group widgetEvents
// @see method:canvas.getOffsetX
// @see method:canvas.getOffsetY
// @see EventHandler.getDragTarget()
//
// @visibility external
// @example dragCreate
//<


// Keyboard handling
// ------------------------------------------------------------------------------------------------------


//> @method canvas.keyDown() (A)
//
// Executed when a key is pressed on a focusable widget (+link{attr:canvas.canFocus}: true).
// <P>
// Use +link{EventHandler.getKey()} to find out the +link{type:KeyName,keyName} of the key that
// was pressed, and use +link{EventHandler.shiftKeyDown()} and related functions to determine
// whether modifier keys were down.
//
// @return (boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see canFocus
// @visibility external
//<


//> @method canvas.keyUp() (A)
//
// Executed when a key is released on a focusable widget (+link{attr:canvas.canFocus}: true).
// <P>
// Use +link{EventHandler.getKey()} to find out the +link{type:KeyName,keyName} of the key that
// was pressed, and use +link{EventHandler.shiftKeyDown()} and related functions to determine
// whether modifier keys were down.
//
// @return (Boolean) false to prevent this event from bubbling to this widget's parent, true or
// undefined to bubble.
// @group widgetEvents
// @see canFocus
// @visibility external
//<


//> @method canvas.keyPress() (A)
//
// Executed when a key is pressed and released on a focusable widget (+link{attr:canvas.canFocus}:
// true).
// <P>
// Use +link{EventHandler.getKey()} to find out the +link{type:KeyName,keyName} of the key that
// was pressed, and use +link{EventHandler.shiftKeyDown()} and related functions to determine
// whether modifier keys were down.
//
// @return (boolean) false to suppress native behavior in response to the keyPress, and prevent
//                   this event from bubbling to this widget's parent, or true or undefined to bubble.
// @group widgetEvents
// @see canFocus
// @visibility external
// @example keyboardEvents
//<



//> @method canvas.getDragType()    (A)
// Return the type of stuff that was dragged from this object
//
//      @return (DragTypes)
// @group dragdrop
//<
getDragType : function () {
    return this.dragType;
},


//> @method canvas.willAcceptDrop() [A]
//
// Returns true if the widget object being dragged can be dropped on this widget, and
// false otherwise.  The default implementation of this method simply compares the
// +link{Canvas.dragType,dragType} of the <code>dragTarget</code> (the component being dragged from)
// with the list of +link{Canvas.dropTypes,dropTypes} on this Canvas.  If the +link{Canvas.dropTypes,dropTypes}
// list contains the +link{Canvas.dragType,dragType} value, then this method returns true.  Otherwise it
// returns false.
// <p>No matter what you return, +link{Canvas.dropOver,dropOver()} and +link{Canvas.dropMove,dropMove()}
// will still be called, and their return values will determine whether those events are bubbled
// to parent elements.
// <p>However, what you return from <code>willAcceptDrop()</code> does determine whether
// +link{Canvas.drop,drop()} will be called.
// <ul>
// <li>If you return true, then <code>drop()</code> will be called, and its return value
// will determine whether the event is bubbled to parent elements
// <li>If you return false, then <code>drop()</code> will not be called, and the event
// will not be bubbled.
// <li>If you return null, then <code>drop()</code> will not be called, but the event
// will be bubbled to parent elements (giving them a chance to handle the drop).
// </ul>
// So, you should return false to definitively deny a drop, and return null if it could
// make sense to allow a parent element, such as a +link{Layout}, to handle the drop.
//
// @return  (boolean)   true if the widget object being dragged can be dropped on this widget,
//                      false if it cannot (and <code>drop()</code> should not bubble),
//                      null to permit <code>drop()</code> to bubble to parent elements
//
// @see Canvas.dragType
// @see Canvas.dropTypes
// @see Canvas.dragTarget
// @see Canvas.drop
//
// @group dragdrop
// @visibility external
//<
willAcceptDrop : function () {

    // if nothing is currently being dragged, return false
    var EH = this.ns.EH;
    if ((EH.nativeDragging &&
         (EH.lastEvent == null ||
          EH.lastEvent.DOMevent == null ||
          EH.lastEvent.DOMevent.dataTransfer == null)) ||
        EH.dragTarget == null)
    {
        return false;
    }

    // if the dropTypes of this object is not set,
    //  assume we can take anything...
    if (this.dropTypes == isc.Canvas.ANYTHING || this.dropTypes == null ||
        isc.is.emptyString(this.dropTypes))
    {
        return true;
    }

    // get the type of stuff that's being dragged
    var type = EH.dragTarget == null ? null : EH.dragTarget.getDragType();
    if (type == null && EH.nativeDragging) {
        var event = EH.lastEvent;
        type = isc.EH._getDragType(event.DOMevent.dataTransfer);
    }
    // if the object being dragged has no dragType, assume we can't take it
    if (type == null || isc.is.emptyString(type)) return false;

    // otherwise go based on the type of the drag types
    if (isc.isA.String(type)) {
        // if it's a string, return true if our dropTypes contains the type
        return this.dropTypes.contains(type);
    } else if (isc.isAn.Array(type)) {
        // if it's an array, return true if our dropTypes contains all sub-types
        for (var i = 0, OK = true, length = type.length; i < length  && OK; i++) {
            OK = OK && (this.dropTypes.contains(type));
        }
        return OK;
    }

    // otherwise assume we can't take it

    return false;
},


_showDragMask : function () {
    if (this.useDragMask && this.dragMaskType == "hide") {
        var styleHandle = this.getStyleHandle();
        this.display_bak = styleHandle.display;
        styleHandle.display = "none";
    } else if (this.useDragMask && this.dragMaskType == "hidePlugin" && this.usePlaceholderDragMask) {
        var handle = this.getPluginHandle();
        if (handle) {
            handle.style.visibility = "hidden";
            if (!this._dragPlaceholder) this._dragPlaceholder = this.createDragPlaceholder();
            if (this._dragPlaceholder) {
                // make the placeholder into a drag mask, so we can accept events on it on behalf
                // of the plugin
                isc.addProperties(this._dragPlaceholder, {
                    _maskTarget: this,
                    getTarget : function () { return this._maskTarget; }
                });
                this._dragPlaceholder.setRect(this.getPageRect());
                this._dragPlaceholder.show();
            }
        }
    } else if (this._eventMask) {
        // show() the eventMask canvas if it's hidden
        // Note: check _eventMask.visibility rather than eventMask.isVisible() because of the
        // case where a parent is hidden
        if (this._eventMask.visibility == isc.Canvas.HIDDEN) this._eventMask.show();
    }
},

getPluginHandle : function () {
    return document.getElementById(this.getPluginID());
},

getPluginID : function () {
    return ;
},

createDragPlaceholder : function () {
    return isc.Label.create({
        align: "center",
        contents: this.dragPlaceholderMessage,
        styleName: this.dragPlaceholderStyle
    });
},

_hideDragMask : function () {
    if (this.useDragMask && this.dragMaskType == "hide") {
        this.getStyleHandle().display = this.display_bak;
        delete this.display_bak;
    } else if (this.useDragMask && this.dragMaskType == "hidePlugin" && this.usePlaceholderDragMask) {
        var handle = this.getPluginHandle();
        if (handle) {
            handle.style.visibility = "inherit";
            if (this._dragPlaceholder) this._dragPlaceholder.hide();
        }
    } else if (this._eventMask) {
        // Note: check _eventMask.visibility rather than eventMask.isVisible() because of the
        // case where a parent is hidden
        if (this._eventMask.visibility != isc.Canvas.HIDDEN) this._eventMask.hide();
    }
},

// handleDrop() -- if 'onDrop' exists fire this before the standard drop behavior

handleDrop : function (event,eventInfo) {
    if (this.onDrop != null && (this.onDrop() == false)) return false;
    return this.drop(event,eventInfo);
},



// Drag/drop snap-to-grid functionality

//> @method canvas.getHSnapPosition()   (A)

// Override this method to provide a custom snap-to grid.  Note that you do not need to do
// this if your grid is regular (ie, grid points are every x pixels); regular grids should be
// defined using +link{canvas.snapHGap} and +link{canvas.snapVGap}.
// You should only override this method if you want to provide support for a grid of
// irregularly-placed points
//
// @param coordinate (int) x-coordinate of the drag event relative to the inside of this widget
// @param [direction] (string) "before" or "after" denoting whether the returned coordinate should
//   match the left or right edge of the current square. If unset +link{canvas.snapHDirection} will
//   be used by default
// @return (int) The horizontal coordinate to snap to
// @group dragdrop
// @visibility external
//<
getHSnapPosition : function (coordinate, direction) {
    if (! direction) {
        direction = this.snapHDirection;
    }
    if (direction != isc.Canvas.BEFORE &&
        direction != isc.Canvas.AFTER  &&
        direction != isc.Canvas.NEAREST) {
        // log an error and return the supplied coord
        return coordinate;
    }

    var before = Math.floor(coordinate / this.snapHGap) * this.snapHGap;
    var after  = before + this.snapHGap;
    var halfway = before + this.snapHGap / 2;

    if (direction == isc.Canvas.BEFORE) {
        return before;
    } else if (direction == isc.Canvas.AFTER) {
        return after;
    } else {
        // If we're exactly inbetween, go left
        if (coordinate <= halfway) return before;
        else return after;
    }

},

//> @method canvas.getVSnapPosition()   (A)
// Override this method to provide a custom snap-to grid.  Note that you do not need to do
// this if your grid is regular (ie, grid points are every x pixels) - regular grids should be
// defined using +link{canvas.snapHGap} and +link{canvas.snapVGap}.
// You should only override this method if you want to provide support for a grid of
// irregularly-placed points
//
// @param coordinate (int) y-coordinate of the drag event relative to the inside of this widget
// @param [direction] (string) "before" or "after" denoting whether the returned coordinate should
//   match the top or bottom edge of the current square. If unset +link{canvas.snapHDirection} will
//   be used by default
// @visibility external
//  @group dragdrop
//  @return (int) The vertical coordinate to snap to
//<
getVSnapPosition : function (coordinate, direction) {
    if (! direction) {
        direction = this.snapVDirection;
    }
    if (direction != isc.Canvas.BEFORE &&
        direction != isc.Canvas.AFTER  &&
        direction != isc.Canvas.NEAREST) {
        // log an error and return the supplied coord
        return coordinate;
    }

    var before = Math.floor(coordinate/ this.snapVGap) * this.snapVGap;

    var after  = before + this.snapVGap;
    var halfway = before + this.snapVGap / 2;

    if (direction == isc.Canvas.BEFORE) {
        return before;
    } else if (direction == isc.Canvas.AFTER) {
        return after;
    } else {
        // If we're exactly inbetween, go up
        if (coordinate <= halfway) return before;
        else return after;
    }
},

//> @method canvas.shouldSnapOnDrop()   (A)
// Override this method to give programmatic control over whether or not the parameter
// <code>dragTarget</code> should snap to this object's grid when dropped.  Note that this only applies
// if snap-to-grid is enabled on either <code>dragTarget</code> or this object.  See
// +link{canvas.snapToGrid} and +link{canvas.childrenSnapToGrid}.
// <P>
// The default implementation simply returns true.
//
// @visibility external
// @group dragdrop
// @param dragTarget (isc.Canvas) The object about to be dropped
// @return (boolean) true if <code>dragTarget</code> should snap to this object's grid; otherwise false
//<
shouldSnapOnDrop : function (dragTarget) {
    return true;
},

// internal helper to suppress drag offsets when dragging child in snapToGrid mode
noSnapDragOffset : function (dragTarget) {
    return false;
},

// SnapTo Grid
// ---------------------------------------------------------------------------------------


snapGridPaneConstructor: "Canvas",
snapGridPaneDefaults: {
    width: "100%",
    height: "100%"
},

snapGridCrossLength: 3,
snapGridLineDefaults: {
    lineWidth: 1
},



//> @attr canvas.showSnapGrid  (Boolean : null : [IRW])
// Whether to show a snap grid for this Canvas. Note that the grid is only shown
// when either +link{childrenSnapToGrid,childrenSnapToGrid} or +link{childrenSnapResizeToGrid,childrenSnapResizeToGrid}
// is <code>true</code>.
// <p>
// Grid is based on +link{snapHGap,snapHGap} and +link{snapVGap,snapVGap} properties.
//
// @setter setShowSnapGrid()
// @visibility external
//<

//> @method canvas.setShowSnapGrid()
// Set the showSnapGrid property.
// @param  show   (boolean)
// @visibility external
//<
setShowSnapGrid : function (show) {
    if (this.showSnapGrid == show) return;

    this.showSnapGrid = show;
    if (show) {
        this._showSnapGrid();
    } else {
        if (this.snapGridPane) this.snapGridPane.hide();
    }
},

_showSnapGrid : function () {
    if (!this.childrenSnapToGrid && !this.childrenSnapResizeToGrid) return;
    if (this.snapVGap < 8 || this.snapHGap < 8) {
        this.logWarn("Attempt to showSnapGrid ignored - snapVGap or snapHGap < 8");
        return;
    }

    if (!this.snapGridPane) {
        // Create a tile of a single cross which will be applied as
        // a repeated background on the snapGridPane
        var tilePane = isc.DrawPane.create({
            autoDraw: false,
            height: this.snapVGap,
            width: this.snapHGap,
            // Draw off screen
            top: -1000,
            left: -1000
        });

        // Make sure crossLength is even
        var crossLength = Math.floor(this.snapGridCrossLength / 2) * 2,
            halfCrossLength = crossLength / 2,
            x = halfCrossLength,
            y = halfCrossLength
        ;

        // Draw actual cross into tile
        var hLineProperties = isc.addProperties({}, this.snapGridLineDefaults, {
            drawPane: tilePane,
            startPoint:  [x - halfCrossLength, y],
            endPoint:    [x + halfCrossLength, y]
        });
        isc.DrawLine.create(hLineProperties);

        var vLineProperties = isc.addProperties({}, this.snapGridLineDefaults, {
            drawPane: tilePane,
            startPoint:  [x, y - halfCrossLength],
            endPoint:    [x, y + halfCrossLength]
        });
        isc.DrawLine.create(vLineProperties);

        // Draw the canvas now and obtain an internal URL for the bitmap image
        tilePane.draw();
        tilePane.refreshNow();
        var url = tilePane.getDataURL();
        tilePane.markForDestroy();

        // Create the snapGridPane showing the bitmap image as a repeated background image
        this.snapGridPane = this.createAutoChild("snapGridPane", {
            isSnapAlignCandidate: false,
            backgroundImage: url,
            backgroundRepeat: "repeat",
            backgroundPosition: (this.snapHGap - halfCrossLength) + "px " + (this.snapVGap - halfCrossLength) + "px"
        });

        // Add grid pane to canvas and make sure it is behind everything else
        this.addChild(this.snapGridPane);
        this.snapGridPane.sendToBack();
    }
    this.snapGridPane.show();
},

// SnapTo Component
// -----------------


//> @attr canvas.childrenSnapAlign (Boolean : null : IRW)
// If enabled while +link{childrenSnapToGrid} is enabled, children dragged within this Canvas
// will also snap to positions where their edges or center lines would be aligned with the
// edges or centers of other components, and lines will be shown to point out the possible
// alignment (with appearance controlled by +link{snapAlignCenterLineStyle} and
// +link{snapAlignEdgeLineStyle} respectively.
// <p>
// By default, edge- or center-snapping is enabled for all components, but the set of eligible
// components can be explicitly set via +link{canvas.snapAlignCandidates}.
// <p>
// See also +link{childrenSnapCenterAlign} and +link{childrenSnapEdgeAlign} for enabling or
// disabling center alignment or edge alignment individually.
//
// @visibility external
//<
setChildrenSnapAlign : function(childrenSnapAlign) {
    this.childrenSnapAlign = childrenSnapAlign;
    if (this.childrenSnapAlign) this._initSnapAlign();
},

//> @attr canvas.childrenResizeSnapAlign (Boolean : null : IRW)
// Flag to disable snapping to alignment when children of this Canvas are resized
//
// @visibility external
//<
setChildrenResizeSnapAlign : function(childrenResizeSnapAlign) {
    this.childrenResizeSnapAlign = childrenResizeSnapAlign;
},

//> @attr canvas.childrenSnapCenterAlign (Boolean : null : IRW)
// See +link{childrenSnapAlign}.  This setting enables or disables snapping on center
// alignment only.
//
// @visibility external
//<
setChildrenSnapCenterAlign : function(childrenSnapCenterAlign) {
    this.childrenSnapCenterAlign = childrenSnapCenterAlign;
},

//> @attr canvas.childrenSnapEdgeAlign (Boolean : null : IRW)
// See +link{childrenSnapAlign}.  This setting enables or disables snapping on edge
// alignment only.
//
// @visibility external
//<
setChildrenSnapEdgeAlign : function(childrenSnapEdgeAlign) {
    this.childrenSnapEdgeAlign = childrenSnapEdgeAlign;
},

//> @attr canvas.snapToAlign (Boolean : null : IRW)
// Flag to disable snapping to alignment when this Canvas is dragged when
// +link{canvas.childrenSnapAlign} is enabled on this Canvas' parent.
// <p>
// To control snapping to align for the children dragged <i>within</i> this Canvas, see
// +link{childrenSnapAlign} instead.
//
// @visibility external
//<
setSnapToAlign : function(snapToAlign) {
    this.snapToAlign = snapToAlign;
},

//> @attr canvas.snapResizeToAlign (Boolean : null : IRW)
// Flag to disable snapping to alignment when this Canvas is resized.
// <p>
// To control snapping to align for the children resized <i>within</i> this Canvas, see
// +link{canvas.childrenResizeSnapAlign,childrenResizeSnapAlign} instead.
//
// @visibility external
//<
setResizeSnapAlign : function(resizeSnapAlign) {
    this.resizeSnapAlign = resizeSnapAlign;
},

//> @attr canvas.snapToCenterAlign (Boolean : null : IRW)
// Flag to disable snapping to center alignment when this Canvas is dragged when
// +link{canvas.childrenSnapAlign} is enabled on this Canvas' parent.
//
// @visibility external
//<
setSnapToCenterAlign : function(snapToCenterAlign) {
    this.snapToCenterAlign = snapToCenterAlign;
},

//> @attr canvas.snapToEdgeAlign (Boolean : null : IRW)
// Flag to disable snapping to edge alignment when this Canvas is dragged when
// +link{canvas.childrenSnapAlign} is enabled on this Canvas' parent.
//
// @visibility external
//<
setSnapToEdgeAlign : function(snapToEdgeAlign) {
    this.snapToEdgeAlign = snapToEdgeAlign;
},

//> @attr canvas.isSnapAlignCandidate (Boolean : null : IRW)
// Flag to disable snapping to alignment against this Canvas when <i>other</i> Canvases
// dragged into the same parent when +link{canvas.childrenSnapAlign} is enabled on this
// Canvas' parent.
//
// @visibility external
//<
setIsSnapAlignCandidate : function(isSnapAlignCandidate) {
    this.isSnapAlignCandidate = isSnapAlignCandidate;
},

//> @attr canvas.snapAlignCandidates (Array of Canvas : null : IRW)
// When +link{childrenSnapAlign} is enabled, list of candidates to check for alignment.
// <p>
// If a list of <code>snapAlignCandidates</code> is never provided, the default is to use all
// children that are not explicitly excluded via +link{isSnapAlignCandidate}, including
// automatically adding newly added children as candidates, and ignoring children that have
// been removed.  Use +link{addSnapAlignCandidate} and +link{removeSnapAlignCandidate} to add
// and remove special candidates while retaining all children as default candidates.
// <p>
// Possible candidates which are not drawn or are hidden are automatically ignored.
//
// @visibility external
//<
setSnapAlignCandidates : function(snapAlignCandidates) {
    this.snapAlignCandidates = snapAlignCandidates;
},

hSnapPositions: [],
vSnapPositions: [],

//> @method canvas.addSnapAlignCandidate()
// Add a candidate to +link{snapAlignCandidates}.  Duplicates are automatically avoided.
//
// @param newCandidate (Canvas)
//
// @visibility external
//<
addSnapAlignCandidate : function(newCandidate) {

    var canvasId = newCandidate.ID;

    if (this.hSnapPositions.find("canvasId", canvasId)) {
        isc.logWarn("Ignoring duplicate snapAlignCandidate having ID '" + canvasId
            + "'.  Call removeSnapAlignCandidate first to overwrite this entry explicitly."
        );
        return;
    }

    if (newCandidate.masterElement || newCandidate.eventMask || newCandidate._isHoopSelector
        || newCandidate.isMouseTransparent) {
        this.logDebug("Ignoring snapAlignCandidate " + canvasId
            + " because it indicates that it is for internal use only.");

        return;
    }

    if (newCandidate.isSnapAlignCandidate === false) {
        isc.logWarn("Ignoring snapAlignCandidate " + canvasId
            + " because it has its isSnapAlignCandidate property set to false.");

        return;
    }

    this.logDebug("Adding snapAlignCandidate with canvasId '" + canvasId + "'.", "dragDrop");

    var that = this;


    var showHorizontal = function() {

        //top segment
        if (this.canvas.getPageTop().isBetween(that.getPageTop(), that.getPageBottom())) {
            this.line1.setHeight(this.canvas.getPageTop() - that.getPageTop());
            this.line1.moveTo(this.getLocalLocator(), 0);
        } else {
            this.line1.setHeight(that.getHeight());
            this.line1.moveTo(this.getLocalLocator(), 0);
        }

        //bottom segment
        if (this.canvas.getPageBottom().isBetween(that.getPageTop(), that.getPageBottom())) {
            this.line2.setHeight(that.getPageBottom() - this.canvas.getPageBottom());
            this.line2.moveTo(this.getLocalLocator(), this.canvas.getPageBottom() - that.getPageTop());
        } else {
            this.line2.setHeight(that.getHeight());
            this.line2.moveTo(this.getLocalLocator(), 0);
        }

        this.line1.bringToFront();
        this.line2.bringToFront();

        this.line1.show();
        this.line2.show();
    };

    var showVertical = function() {

        //left segment
        if (this.canvas.getPageLeft().isBetween(that.getPageLeft(), that.getPageRight())) {
            this.line1.setWidth(this.canvas.getPageLeft() - that.getPageLeft());
            this.line1.moveTo(0, this.getLocalLocator());
        } else {
            this.line1.setWidth(that.getWidth());
            this.line1.moveTo(0, this.getLocalLocator());
        }

        //right segment
        if (this.canvas.getPageRight().isBetween(that.getPageLeft(), that.getPageRight())) {
            this.line2.setWidth(that.getPageRight() - this.canvas.getPageRight());
            this.line2.moveTo(this.canvas.getPageRight() - that.getPageLeft(), this.getLocalLocator());
        } else {
            this.line2.setWidth(that.getWidth());
            this.line2.moveTo(0, this.getLocalLocator());
        }

        this.line1.bringToFront();
        this.line2.bringToFront();

        this.line1.show();
        this.line2.show();
    };

    var hide = function() {
        this.line1.hide();
        this.line2.hide();
    };

    // add a marker representing each alignment point, and include a function that allows
    // resolution to the coordinates of the canvas with the grid (the 'that' closure)
    var left = isc.SnapAlignmentMarker.create({
        orientation: "horizontal",
        position: "left",
        line1: this.hSnapLineEdge1,
        line2: this.hSnapLineEdge2,
        show: showHorizontal,
        hide: hide,
        getLocalLocator : function() {
            var global = this.canvas.getPageLeft();
            return global - that.getPageLeft();
        }
    });
    var right = isc.SnapAlignmentMarker.create({
        orientation: "horizontal",
        position: "right",
        line1: this.hSnapLineEdge1,
        line2: this.hSnapLineEdge2,
        show: showHorizontal,
        hide: hide,
        getLocalLocator : function() {
            var global = this.canvas.getPageRight();
            return global - that.getPageLeft();
        }
    });
    var hCenter = isc.SnapAlignmentMarker.create({
        orientation: "horizontal",
        position: "center",
        line1: this.hSnapLineCenter1,
        line2: this.hSnapLineCenter2,
        show: showHorizontal,
        hide: hide,
        getLocalLocator : function() {
            var l = left.getLocalLocator();
            var r = right.getLocalLocator();
            return (Math.floor(r - l) / 2) + l;
        }
    });

    var top = isc.SnapAlignmentMarker.create({
        orientation: "vertical",
        position: "top",
        line1: this.vSnapLineEdge1,
        line2: this.vSnapLineEdge2,
        show: showVertical,
        hide: hide,
        getLocalLocator : function() {
            var global = this.canvas.getPageTop();
            return global - that.getPageTop();
        }
    });
    var bottom = isc.SnapAlignmentMarker.create({
        orientation: "vertical",
        position: "bottom",
        line1: this.vSnapLineEdge1,
        line2: this.vSnapLineEdge2,
        show: showVertical,
        hide: hide,
        getLocalLocator : function() {
            var global = this.canvas.getPageBottom();
            return global - that.getPageTop();
        }
    });
    var vCenter = isc.SnapAlignmentMarker.create({
        orientation: "vertical",
        position: "center",
        line1: this.vSnapLineCenter1,
        line2: this.vSnapLineCenter2,
        show: showVertical,
        hide: hide,
        getLocalLocator : function() {
            var t = top.getLocalLocator();
            var b = bottom.getLocalLocator();
            return (Math.floor(b - t) / 2) + t;
        }
    });

    this._addSnapAlignMarker(this.hSnapPositions, newCandidate, left);
    this._addSnapAlignMarker(this.hSnapPositions, newCandidate, right);
    this._addSnapAlignMarker(this.hSnapPositions, newCandidate, hCenter);

    this._addSnapAlignMarker(this.vSnapPositions, newCandidate, top);
    this._addSnapAlignMarker(this.vSnapPositions, newCandidate, bottom);
    this._addSnapAlignMarker(this.vSnapPositions, newCandidate, vCenter);

},


_addSnapAlignMarker : function(list, canvas, marker) {

    var that = this;

    // to be used when some snapAlignCandidate changes location (as in moved or resized ops)
    var reposition = function() {

        this.locator = this.getLocalLocator();

        if (this.orientation === "horizontal") {
            that.hSnapPositions.sortByProperty("locator", true);
        } else {
            that.vSnapPositions.sortByProperty("locator", true);
        }
    };

    var destroyed = function(canvas) {
        that.removeSnapAlignCandidate(canvas);
    };

    marker.reposition = reposition;
    marker.destroyed = destroyed;

    marker.canvas = canvas;
    marker.canvasId = canvas.ID;
    marker.locator = marker.getLocalLocator();


    marker.observe(canvas, "draw", "observer.reposition()");

    marker.observe(canvas, "moved", "observer.reposition()");
    marker.observe(canvas, "resized", "observer.reposition()");
    marker.observe(canvas, "destroy", "observer.destroyed(this)");

    if (this.editingOn && this.editProxy) {

        marker.observe(this.editProxy, "drop", "observer.hide()");
        marker.observe(this.editProxy, "dragResizeStop", "observer.hide()");
        marker.observe(this.editProxy, "dragRepositionStop", "observer.hide()");

    } else {
        marker.observe(canvas, "dragResizeStop", "observer.hide()");
        marker.observe(canvas, "dragRepositionStop", "observer.hide()");
    }

    // use a binary search strategy to find the appropriate insertion index
    var high = list.length,
        low = -1,
        index;

    while (high - low > 1) {
        index = (high + low) >>> 1;
        if (list[index].getLocalLocator() >= marker.getLocalLocator()) {
            high = index;
        } else {
            low = index;
        }
    }

    list.addAt(marker, high);

    return index;
},

//> @method canvas.removeSnapAlignCandidate()
// Remove a candidate from +link{snapAlignCandidates}.  If the passed widget was not actually
// a candidate, nothing happens and no warning is logged.
//
// @param candidate (Canvas)
//
// @visibility external
//<
removeSnapAlignCandidate : function(candidate) {

    var horizontals = this.hSnapPositions.findAll("canvasId", candidate.ID);

    if (horizontals == null || horizontals.isEmpty()) {
        return;
    }
    this.logDebug("Removing snapAlignCandidate with ID '" + candidate.ID + "'");

    var ignore = function(marker) {
        marker.ignore(candidate, "draw");
        marker.ignore(candidate, "moved");
        marker.ignore(candidate, "resized");
        marker.ignore(candidate, "destroy");

        marker.ignore(candidate, "dragResizeStop");
        marker.ignore(candidate, "dragRepositionStop");

        if (this.editProxy) {
            marker.ignore(this.editProxy, "drop");
            marker.ignore(this.editProxy, "dragResizeStop");
            marker.ignore(this.editProxy, "dragRepositionStop");
        }
    }

    for (var i = 0; i < horizontals.length; i++) {
        var entry = horizontals[i];

        ignore(entry);

        this.hSnapPositions.remove(entry);
    }

    var verticals = this.vSnapPositions.findAll("canvasId", candidate.ID);
    if (verticals == null || verticals.isEmpty()) {
        return;
    }
    for (var i = 0; i < verticals.length; i++) {
        var entry = verticals[i];

        ignore(entry);

        this.vSnapPositions.remove(entry);
    }
},


_getSnapMarkersBetweenPoints : function(array, p1, p2, includeEdges, includeCenters) {

    var min = Math.min(p1, p2),
        max = Math.max(p1, p2);

    var boundaries = [];
    var high, low, index;

    // get the highest number having a value less than p1 - we'll know to get the next
    // element later, and we do this so that we can be sure to get the 1st instance of a
    // duplicated number
    high = array.length; low = -1;
    while (high - low > 1) {

        index = (low + high) >>> 1;
        if (array[index].getLocalLocator() < min) {
            low = index;
        } else {
            high = index;
        }
    }
    boundaries[0] = low;

    // get the lowest number having a value greater than p1 - array.slice (getRange) will
    // only take those elements up to the given index, so no need to adjust as in the case
    // of  the lower index
    high = array.length; low = -1;
    while (high - low > 1)
    {
        index = (low + high) >>> 1;
        if (array[index].getLocalLocator() > max)
            high = index;
        else
            low = index;
    }
    boundaries[1] = high;

    var unfiltered = array.getRange(boundaries[0]+1, boundaries[1]);

    var filter = {
        _constructor: "AdvancedCriteria",
        operator: "and",
        criteria:[
          { fieldName: "canvas._currentlyVisible", value: true }
        ]
    };

    var edgeCriteria = [];
    if (includeEdges) {
        edgeCriteria.addList([
            { fieldName: "position", value: "left" },
            { fieldName: "position", value: "right"},
            { fieldName: "position", value: "top" },
            { fieldName: "position", value: "bottom"}
        ]);
    }
    if (includeCenters) {
        edgeCriteria.add(
            { fieldName: "position", value: "center" }
        );
    }
    filter.criteria.add({
        _constructor: "AdvancedCriteria",
        operator: "or",
        criteria: edgeCriteria
    });


    var filtered = unfiltered.findAll(filter);
    return filtered && !filtered.isEmpty() ? filtered : null;
},


_snapMarkerComparator: function(a, b) {

    if (a.distanceToSnap != b.distanceToSnap) {
        return a.distanceToSnap < b.distanceToSnap ? -1 : 1;
    }
    var score = function(string) {
        if (string === "centercenter") {
            return 3;
        } else if (string === "leftleft" || string === "toptop") {
            return 2;
        } else if (string === "rightright" || string === "bottombottom") {
            return 1;
        }
        return 0;
    };
    var first = score(a.dragPosition + a.snapPosition);
    var second = score(b.dragPosition + b.snapPosition);

    if (first  > second) return -1;
    if (second > first ) return 1;

    return 0;
},


_getHSnapAlignMarker : function(dragTarget, dragCoordinate, resizeEdge) {

    dragTarget = dragTarget._maskTarget || dragTarget;

    var snapToEdgeEnabled = this.childrenSnapEdgeAlign != false
        && dragTarget.snapToEdgeAlign != false
        && ! this.childrenSnapCenterAlign;

    var snapToCenterEnabled = this.childrenSnapCenterAlign != false
        && dragTarget.snapToCenterAlign != false
        && ! this.childrenSnapEdgeAlign;


    var width = resizeEdge ? 0 : dragTarget.getVisibleWidth(),
        half = resizeEdge ? 0 : Math.floor(width/2);

    var leftDragPoint = dragCoordinate,
        leftGridLine1 = this.getHSnapPosition(leftDragPoint, isc.Canvas.BEFORE),
        leftGridLine2 = this.getHSnapPosition(leftDragPoint, isc.Canvas.AFTER );

    var rightDragPoint = dragCoordinate + width,
        rightGridLine1 = this.getHSnapPosition(rightDragPoint, isc.Canvas.BEFORE),
        rightGridLine2 = this.getHSnapPosition(rightDragPoint, isc.Canvas.AFTER );

    var centerDragPoint = dragCoordinate + half,
        centerGridLine1 = this.getHSnapPosition(centerDragPoint, isc.Canvas.BEFORE),
        centerGridLine2 = this.getHSnapPosition(centerDragPoint, isc.Canvas.AFTER );

    // any marker that falls between the grid lines on either side of the calculated drag
    // coordinate (and passes the filter imposed by _getSnapMarkersBetweenPoints)
    // ends up here
    var nearby = {
        data: [],
        add : function(marker, dragCoordinate, dragPosition, snapCoordinateOffset) {
            if (dragTarget.ID === marker.canvasId) {
                return;
            }
            this.data.add({
                show           :  function(){ marker.show() },
                hide           :  function(){ marker.hide() },
                dragPosition   :  dragPosition,
                dragCoordinate :  dragCoordinate,
                snapPosition   :  marker.position,
                snapCoordinate :  marker.getLocalLocator() - snapCoordinateOffset,
                distanceToSnap :  Math.abs(marker.getLocalLocator() - dragCoordinate)
            });
        },
        addList : function(list, dragCoordinate, dragPosition, snapCoordinateOffset) {
            for (var i=0; i<list.length; i++) {
                this.add(list[i], dragCoordinate, dragPosition, snapCoordinateOffset);
            }
        }
    };

    if (snapToEdgeEnabled) {

        var inLeftCorridor = this._getSnapMarkersBetweenPoints(
            this.hSnapPositions,
            leftGridLine1, leftGridLine2,
            snapToEdgeEnabled, snapToCenterEnabled
        );
        var inRightCorridor = this._getSnapMarkersBetweenPoints(
            this.hSnapPositions,
            rightGridLine1, rightGridLine2,
            snapToEdgeEnabled, snapToCenterEnabled
        );

        if (inLeftCorridor) {
            nearby.addList(inLeftCorridor, leftDragPoint, "left", 0);
        }
        if (inRightCorridor) {
            nearby.addList(inRightCorridor, rightDragPoint, "right", width);
        }
    }
    if (snapToCenterEnabled) {
        var inCenterCorridor = this._getSnapMarkersBetweenPoints(
            this.hSnapPositions,
            centerGridLine1, centerGridLine2,
            snapToEdgeEnabled, snapToCenterEnabled
        );

        if (inCenterCorridor) {
             nearby.addList(inCenterCorridor, centerDragPoint, "center", half);
        }
    }

    // And now we can just sort it by the calculated distance from the calculated dragPoint
    return nearby.data.sort(this._snapMarkerComparator)[0];
},


_getVSnapAlignMarker : function(dragTarget, dragCoordinate, resizeEdge) {

    dragTarget = dragTarget._maskTarget || dragTarget;

    var snapToEdgeEnabled = this.childrenSnapEdgeAlign != false
        && dragTarget.snapToEdgeAlign != false
        && ! this.childrenSnapCenterAlign;

    var snapToCenterEnabled = this.childrenSnapCenterAlign != false
        && dragTarget.snapToCenterAlign != false
        && ! this.childrenSnapEdgeAlign;


    var height = resizeEdge ? 0 : dragTarget.getVisibleHeight(),
        half = resizeEdge ? 0 : Math.floor(height/2);

    var topDragPoint = dragCoordinate,
        topGridLine1 = this.getVSnapPosition(topDragPoint, isc.Canvas.BEFORE),
        topGridLine2 = this.getVSnapPosition(topDragPoint, isc.Canvas.AFTER );

    var bottomDragPoint = dragCoordinate + height,
        bottomGridLine1 = this.getVSnapPosition(bottomDragPoint, isc.Canvas.BEFORE),
        bottomGridLine2 = this.getVSnapPosition(bottomDragPoint, isc.Canvas.AFTER );

    var centerDragPoint = dragCoordinate + half,
        centerGridLine1 = this.getVSnapPosition(centerDragPoint, isc.Canvas.BEFORE),
        centerGridLine2 = this.getVSnapPosition(centerDragPoint, isc.Canvas.AFTER );

    // any marker that falls between the grid lines on either side of the calculated drag
    // coordinate (and passes the filter imposed by _getSnapMarkersBetweenPoints)
    // ends up here
    var nearby = {
        data: [],
        add : function(marker, dragCoordinate, dragPosition, snapCoordinateOffset) {
            if (dragTarget.ID === marker.canvasId) {
                return;
            }
            this.data.add({
                show           :  function(){ marker.show() },
                hide           :  function(){ marker.hide() },
                dragPosition   :  dragPosition,
                dragCoordinate :  dragCoordinate,
                snapPosition   :  marker.position,
                snapCoordinate :  marker.getLocalLocator() - snapCoordinateOffset,
                distanceToSnap :  Math.abs(marker.getLocalLocator() - dragCoordinate)
            });
        },
        addList : function(list, dragCoordinate, dragPosition, snapCoordinateOffset) {
            for (var i=0; i<list.length; i++) {
                this.add(list[i], dragCoordinate, dragPosition, snapCoordinateOffset);
            }
        }
    };

    if (snapToEdgeEnabled) {

        var inTopCorridor = this._getSnapMarkersBetweenPoints(
            this.vSnapPositions,
            topGridLine1, topGridLine2,
            snapToEdgeEnabled, snapToCenterEnabled
        );
        var inBottomCorridor = this._getSnapMarkersBetweenPoints(
            this.vSnapPositions,
            bottomGridLine1, bottomGridLine2,
            snapToEdgeEnabled, snapToCenterEnabled
        );

        if (inTopCorridor) {
            nearby.addList(inTopCorridor, topDragPoint, "top", 0);
        }

        if (inBottomCorridor) {
            nearby.addList(inBottomCorridor, bottomDragPoint, "bottom", height);
        }
    }

    if (snapToCenterEnabled) {

        var inCenterCorridor = this._getSnapMarkersBetweenPoints(
            this.vSnapPositions,
            centerGridLine1, centerGridLine2,
            snapToEdgeEnabled, snapToCenterEnabled
        );

        if (inCenterCorridor) {
            nearby.addList(inCenterCorridor, centerDragPoint, "center", half);
        }
    }

    // And now we can just sort it by the calculated distance from the calculated dragPoint
    return nearby.data.sort(this._snapMarkerComparator)[0];
},

//> @attr canvas.snapAlignCenterLineStyle (String : "1px solid blue" : IR)
// CSS border declaration used for the line shown to indicate snapping to a center line when
// +link{canvas.childrenSnapAlign} is set.
//
// @visibility external
//<
snapAlignCenterLineStyle: "1px solid blue",

//> @attr canvas.snapAlignEdgeLineStyle (String : "1px solid #555555" : IR)
// CSS border declaration used for the line shown to indicate snapping to a edge line when
// +link{canvas.childrenSnapAlign} is set.
//
// @visibility external
//<
snapAlignEdgeLineStyle: "1px solid #555555",

snapLineDefaults : {
    isSnapAlignCandidate: false,
    visibility: "hidden",
    width: 1,
    height: 1
},

_initSnapAlign : function() {
    if (this._calledInitSnapAlign) return;
    this._calledInitSnapAlign = true;



    var edgeStyle = this.snapAlignEdgeLineStyle || null;
    var centerStyle = this.snapAlignCenterLineStyle || null;

    this.hSnapLineEdge1 = this.createAutoChild("snapLine", {
        styleText: edgeStyle ? "border-left: " + edgeStyle : null,
        show: function() {
            this.creator.hSnapLineCenter1.hide();
            this.creator.hSnapLineCenter2.hide();
            this.Super("show", arguments);
        }
    });
    this.hSnapLineEdge2 = this.createAutoChild("snapLine", {
        styleText: edgeStyle ? "border-left: " + edgeStyle : null,
        show: function() {
            this.creator.hSnapLineCenter1.hide();
            this.creator.hSnapLineCenter2.hide();
            this.Super("show", arguments);
        }
    });
    this.hSnapLineCenter1 = this.createAutoChild("snapLine", {
        styleText: centerStyle ? "border-left: " + centerStyle : null,
        show: function() {
            this.creator.hSnapLineEdge1.hide();
            this.creator.hSnapLineEdge2.hide();
            this.Super("show", arguments);
        }
    });
    this.hSnapLineCenter2 = this.createAutoChild("snapLine", {
        styleText: centerStyle ? "border-left: " + centerStyle : null,
        show: function() {
            this.creator.hSnapLineEdge1.hide();
            this.creator.hSnapLineEdge2.hide();
            this.Super("show", arguments);
        }
    });
    this.vSnapLineEdge1 = this.createAutoChild("snapLine", {
        styleText: edgeStyle ? "border-top: " + edgeStyle : null,
        show: function() {
            this.creator.vSnapLineCenter1.hide();
            this.creator.vSnapLineCenter2.hide();
            this.Super("show", arguments);
        }
    });
    this.vSnapLineEdge2 = this.createAutoChild("snapLine", {
        styleText: edgeStyle ? "border-top: " + edgeStyle : null,
        show: function() {
            this.creator.vSnapLineCenter1.hide();
            this.creator.vSnapLineCenter2.hide();
            this.Super("show", arguments);
        }
    });
    this.vSnapLineCenter1 = this.createAutoChild("snapLine", {
        styleText: centerStyle ? "border-top: " + centerStyle : null,
        show: function() {
            this.creator.vSnapLineEdge1.hide();
            this.creator.vSnapLineEdge2.hide();
            this.Super("show", arguments);
        }
    });
    this.vSnapLineCenter2 = this.createAutoChild("snapLine", {
        styleText: centerStyle ? "border-top: " + centerStyle : null,
        show: function() {
            this.creator.vSnapLineEdge1.hide();
            this.creator.vSnapLineEdge2.hide();
            this.Super("show", arguments);
        }
    });

    this.addChild(this.hSnapLineEdge1);
    this.addChild(this.hSnapLineEdge2);

    this.addChild(this.hSnapLineCenter1);
    this.addChild(this.hSnapLineCenter2);

    this.addChild(this.vSnapLineEdge1);
    this.addChild(this.vSnapLineEdge2);

    this.addChild(this.vSnapLineCenter1);
    this.addChild(this.vSnapLineCenter2);

    if (! this.snapAlignCandidates) {
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            this.addSnapAlignCandidate(child);
        };
    } else {
        for (var i = 0; i < this.snapAlignCandidates.length; i++) {
            this.addSnapAlignCandidate(this.snapAlignCandidates[i]);
        };
    }

    this.observe(this, "addChild", "observed.addSnapAlignCandidate(returnVal)");

},

// Images
// ------------------------------------------------------------------------------------------------------

//> @method canvas.setAppImgDir()
// Set the image directory for this individual widget.
// @group images
// @param   [URL]   (URL)   URL (relative to Page.appImgDir) for where images for this widget live
//<
setAppImgDir : function (URL) {
    if (URL) this.appImgDir = URL;
},

//> @method canvas.getAppImgDir()
// Return the image directory for this individual widget, prepended with the Page image directory.
// @group images
// @return  (URL)   Image directory (including Page image directory) for this widget.
//<
getAppImgDir : function () {
    return isc.Page.getImgURL("", this.appImgDir);
},

//> @method canvas.setSkinImgDir()
// Set the widget image directory for this individual widget.
// @group images
// @param   [URL]   (URL)   URL (relative to Page.appImgDir) for where images for this widget live
//<
setSkinImgDir : function (URL) {
    if (URL) this.skinImgDir = URL;
},

//> @method canvas.getSkinImgDir()
// Return the widget image directory for this individual widget, prepended with the Page image
// directory.
//
// @group images
// @return  (URL)   Widget image directory (including Page widget image directory) for this widget.
//<
getSkinImgDir : function () {
    return isc.Page.getSkinImgDir(this.skinImgDir);
},


//> @method Canvas.getImgURL() (A)
// Return the full URL for an image to be drawn in this canvas.
// <P>
// If the passed URL begins with the special prefix "[SKIN]", it will have the
// widget.skinImgDir and Page.skinImgDir prepended.  Otherwise the image is assumed to be
// application-specific, and will have the widget.appImgDir and Page.appImgDir automatically
// prepended.
// <P>
// Note that if passed an absolute path (starting with "/" or "http://" for example), no extra
// image directory information will be prepended to the generated URL.//
//
// @param URL      (string) URL local to skin or application image directory
// @param [imgDir] (string) optional image directory to override the default for this Canvas
// @group images
// @return (string) URL to use
// @visibility external
//<
getImgURL : function (src, imgDir) {
    return isc.Canvas.getImgURL(src, imgDir, this);
},


//> @object ImgProperties
//
// A set of properties that can be used to create an image.
//
// @treeLocation Client Reference/Foundation/Canvas
// @visibility external
//<

//> @attr imgProperties.src (URL : null : IRW)
//
// Specifies the URL of the image local to the skin or application directory.
//
// @visibility external
//<

//> @attr imgProperties.width (number : null : IRW)
//
// Specifies the width of the image.
//
// @visibility external
//<

//> @attr imgProperties.height (number : null : IRW)
//
// Specifies the height of the image.
//
// @visibility external
//<

//> @attr imgProperties.name (string : null : IRW)
//
// Specifies the name of the image. This is an identifier unique to the canvas, and subsequent
// calls to <code>+link{method:canvas.getImage()}</code> and
// <code>+link{method:canvas.setImage()}</code>
// with this name will act on the image object created using this ImgProperties object.
//
// @visibility external
//<

//> @attr imgProperties.extraStuff (string : null : IRW)
//
// Specifies the additional attributes to write in the tag.
//
// @visibility external
//<

//> @attr imgProperties.imgDir (URL : null : IRW)
//
// Specifies the image-specific image directory to override the default.
//
// @visibility external
//<

//> @method canvas.imgHTML() (A)
// Generates the HTML for an image unique to this Canvas.
// <P>
// The full URL for the image will be formed according to the rules documented for
// <code>+link{method:canvas.getImgURL()}</code>.
// <P>
// The created image will have an identifier unique to this Canvas, and subsequent calls to
// <code>+link{method:canvas.getImage()}</code> and
// <code>+link{method:canvas.setImage()}</code>
// with the name passed to this function will act on the image object produced by the HTML
// returned from this call.
//
// @param src           (SCImgURL)  URL local to the skin or application directory.<br>
//      NOTE: instead of passing several parameters, you can pass an object as the 'src'
//      parameter with properties for all the various function parameters with, eg:<br>
//      canvas.imgHTML( {src:"foo", width:10, height:10} );
//
// @param [width]       (number)    width of the image
// @param [height]      (number)    height of the image
// @param [name]        (string)    name for the image
// @param [extraStuff]  (string)    additional attributes to write in the tag
// @param [imgDir]      (string)    image-specific image directory to override the default
//                                  for this Canvas
// @return  (string)                HTML to draw the image.
//
// @group images
// @visibility external
//<
// @param [generateSpan] (boolean)  whether to generate the HTML for a &lt;span&gt; element instead
//                                  of an &lt;img&gt; element.
imgHTML : function (src, width, height, name, extraStuff, imgDir, activeAreaHTML, generateSpan) {
    return isc.Canvas.imgHTML(src, width, height, name, extraStuff, imgDir, activeAreaHTML, this, false, generateSpan);
},

// returns an imgHTML template that contains an open slot for a unique name attribute
// for the image.  Used in inner loops.
_getImgHTMLTemplate : function (src, width, height, name, extraStuff, imgDir, activeAreaHTML, generateSpan) {
    return isc.Canvas.imgHTML(src, width, height, name, extraStuff, imgDir, activeAreaHTML, this, true, generateSpan);
},

//> @method canvas.getImage() (A)
// Retrieve a native image element by name.
// <P>
// The image element must have been created from HTML generated by calling
// +link{Canvas.imgHTML()} on this particular Canvas.
//
// @param   identifier (string) name of the image to get, as originally passed to
//                              <code>imgHTML()</code>
// @return  (DOMElement)    DOM image element if found, else null
// @group images
// @visibility external
//<
getImage : function (identifier, checkSpans) {
    // if identifier is a string, prepend the canvas name
    if (isc.isA.String(identifier)) identifier = this.getCanvasName() + identifier;

    // if we've been drawn and there is a document object to query
    var handle = this.getHandle();
    if (handle) {
        var doc = handle.document || document;
        if (isc.Page.isXHTML() || checkSpans) {

            return doc.getElementById(identifier);
        } else {
            // just ask for the image

            return doc.images[identifier];
        }
    }

    // not found -- return null;
    return null;
},


//> @method canvas.setImage() (A)
// Set the URL of an image element by name.
// <p>
// The image element must have been created from HTML generated by calling
// <code>canvas.imgHTML()</code> on this particular Canvas.
//
// @param identifier (string)   name of the image to change, as originally passed to
//                              <code>imgHTML</code>
// @param URL        (SCImgURL) URL for the image
// @param [imgDir]   (string)   optional image directory, overrides the default for this Canvas
// @group images
// @visibility external
//<
setImage : function (identifier, src, imgDir, checkSpans) {
    // get the image
    var image = this.getImage(identifier, checkSpans);

    if (image == null) {
        //>DEBUG
        this.logWarn("setImage: image '" + identifier + "' couldn't be found");
        //<DEBUG
        return;
    }

    isc.Canvas._setImageURL(image, src, imgDir, this);
},

//> @method canvas.linkHTML() (A)
// Generates the HTML for a standard link (anchor) element.
//
// @param href  (string)    URL for the link to point to
// @param [text] (HTMLString) HTML to display in the link element (defaults to the href)
// @param [target] (string)   Target window for the link (defaults to opening in a new, unnamed window)
// @param [ID] (string)     optional ID for the link element to be written out
// @param [tabIndex] (Integer) optional tabIndex for the link
// @param [accessKey] (string) optional accessKey for the link
// @return (HTMLString) HTML for the link
// @visibility external
//<
// Additional 'extrastuff' param
linkHTML : function (href, text, target, ID, tabIndex, accessKey, extraStuff) {
    return isc.Canvas.linkHTML(href,text,target, ID, tabIndex, accessKey, extraStuff);
},

// ----------------------------------------------------------------------------------------

//> @method canvas.inWhichPosition()    (A)
//          given a list of numerical coordinates and a single coordinate,
//          return which item the coordinate falls in
//
//      @group  utils
//
//      @param  list            (array of numbers)  these are sizes (widths, heights, etc) of each
//                               item, such as that returned by Canvas.applyStretchResizePolicy()
//      @param  coord           (number)    coordinate, such as an x or y coordinate from an Event
//      @param  [direction]     (Page.LTR or Page.RTL)  direction
//                                  -- if LTR we scan from left to right, if RTL we scan from right
//                                     to left unspecified == LTR
//      @return (number)
//              -1 = before beginning of list
//              -2 = after end of list
//               #  = in that position
//<
inWhichPosition : function (list, coord, textDirection) {
    //this.logWarn("inWhichPosition: coord: " + coord + "\nlist: " + list);

    // if we're before the first item, return -1
    if (!list || coord < 0) return -1;

    // iterate through the list of sizes, returning the one containing the coord
    if (textDirection == isc.Page.RTL) {
        // direction right to left: coord is still an offset from left, but assume list of
        // lengths is laid out right to left
        var totalSize = list.sum();
        for (var c = 0, numCols = list.length; c < numCols; c++) {
            if (coord >= totalSize-list[c]) return c;
            totalSize -= list[c];
        }
    } else {
        for (var c = 0, numCols = list.length; c < numCols; c++) {
            if (coord <= list[c]) {
                return c;
            }
            coord -= list[c];
        }
    }
    // not found -- return -2
    return -2;
},

// Log window: update stats
// --------------------------------------------------------------------------------------------

// add or remove from canvasList
_$count : "count",
_canvasList : function (add) {
    var list = isc.Canvas._canvasList;
    if (add) list.add(this);
    else list.remove(this);
    //>DEBUG
    if (this._iscInternal) {
        isc.Canvas._iscInternalCount += (add ? 1 : -1);
    } else {
        isc.Log.updateStats(this._$count);
    } //<DEBUG
},

//>DEBUG increment some stat we're drawing an update the log window
_addStat : function (stat) {
    if (!this._iscInternal) {
        isc.Canvas._stats[stat]++;
        isc.Log.updateStats(stat);
    }
}, //<DEBUG


// Attached Peers
// ----------------------------------------------------------------------------------------


_attachedPeers : function (side) {
    var attachedPeers = this._attachedPeerMap;
    if (!attachedPeers) return null;
    if (side) return attachedPeers[side];
},

_registerAttachedPeer : function (peer, side, offset, observeResize) {
    if (peer == null || side == null) return;
    if (!this._attachedPeerMap) this._attachedPeerMap = {};
    if (!this._attachedPeerMap[side]) this._attachedPeerMap[side] = [];
    this._attachedPeerMap[side].add(peer);

    if (offset != null) peer._attachedPeerOffset = offset
    // observeResize param -- most "attachedPeers" are statically sized, like edges, so avoid this
    // unless explicitly requested, but if the peer could change size we'll need to refresh our
    // margins (and hence resize our handle) to accomodate it when it does.
    if (observeResize) {
        this.observe(peer, "resized", "observer._attachedPeerResized(observed)");
    }
    // Note: on destroy, we destroy all peers so no need to clean up this list.
    // We also have a sanity check for the peer being destroyed when calculating margins.

    delete this._cachedMargins;
    delete this._fullMargins;
},

_unRegisterAttachedPeer : function (peer, side, offset) {
    if (peer == null || side == null) return;
    if (!this._attachedPeerMap ||!this._attachedPeerMap[side]) return;
    this._attachedPeerMap[side].remove(peer);
    if (this.isObserving(peer, "resized")) {
        this.ignore(peer, "resized");
    }
    delete peer._attachedPeerOffset;
    delete this._cachedMargins;
    delete this._fullMargins;
},

_attachedPeerResized : function (peer) {
    // This will clear the cached margins which were calculated based on attached peer sizes
    // and refresh on the style-handle
    this.refreshMargin();
},

refreshMargin : function () {
    this.setMargin(this.margin);
},

// -----------------------------------------------------------------------------------------





//>CornerClips
// make corner cap elements for subtractive rounded corners
_makeCornerClips : function () {
    this._cornerClips = {};
    for (var i = 0; i < this.clippedCorners.length; i++) {
        this._makeCornerClip(this.clippedCorners[i])
    }
},

// make a single corner cap element
// could convert position param to a cap properties obj for more flexibility here
// (if we do, note that helper methods currently assume position is a string)
// should check for valid positions here
_makeCornerClip : function (position) {
    var clips = this._cornerClips,
        capLeft = this.left,
        capTop = this.top,
        capWidth = this.cornerClipWidth || this.cornerClipSize,
        capHeight = this.cornerClipHeight || this.cornerClipSize;

    // calculate position for this corner
    if (position == "TR" || position == "BR") {
        capLeft = capLeft + this.getWidth() - capWidth;
    }
    if (position == "BL" || position == "BR") {
        capTop = capTop + this.getHeight() - capHeight;
    }

    // we can only do no-image corner masks in IE5.5+
    if (this.noCornerClipImages && !(isc.Browser.isIE && isc.Browser.minorVersion >= 5.5)) {
        this.noCornerClipImages = false;
    }

    var newCap = clips[position] = isc.ClassFactory.newInstance({
        _constructor:(this.noCornerClipImages ? "Canvas" : "Img"),
        left:capLeft,
        top:capTop,
        width:capWidth,
        height:capHeight,
        eventProxy:this,
        //border:"1px solid blue",
        src:(this.noCornerClipImages ? null : this._getCornerImage(position)),

        contents:(this.noCornerClipImages ?
            this._getCornerHTML(capWidth, capHeight, position) : null)

    }, this._cornerProperties);

    this.addPeer(newCap);
    newCap.moveAbove(this);
},

_finishCornerClips : function () {
    if (!this.noCornerClipImages) return;
    for (var edge in this._cornerClips) {
        var cap = this._cornerClips[edge],
            div = cap.getHandle().firstChild,
            style = div.style;
        //this.logWarn("edge: " + edge + ", cap div: " + this.echo(div));

        // kick in irising transition
        div.filters[0].apply();
        // transition to hidden version (to create transparent space)
        style.visibility = "hidden";
        // move transition to 71% completion (where circle touches edge)
        div.filters[0].percent=71;
    }
},

// generate image filename
// jumping directly to Img.urlForState() here; is there a better approach?
// currently using position and color only; could enhance with size if scaling is unacceptable
_getCornerImage : function (position) {
    return isc.Img.urlForState(
        this.cornerClipImage,
        null, // selected is unused
        null, // as is focused
        this.cornerClipColor, // embed hex color code in the file name
        position);
},

_getCornerHTML : function (capWidth, capHeight, edge) {

    var output = isc.SB.create();



    // containing DIV: 4x the area of the final cap, since we want to show only 1/4 of frozen
    // transition per cap
    output.append(
        "<DIV STYLE='width:", 2*capWidth,
                 "px;height:", 2*capHeight,
                 "px;filter:progid:DXImageTransform.Microsoft.iris(irisStyle=circle,motion=out);"
                 //,"border:1px solid red;"
    );
    // move left/top so that only relevant corner shows
    if (edge.contains("R")) output.append("margin-left:", -capWidth, "px;");
    if (edge.contains("B")) output.append("margin-top:", -capHeight, "px;");

    // NOTE: needs overflow:hidden or it will expand to one line-height
    output.append("'><DIV STYLE='overflow:hidden;width:", capWidth, "px;height:", capHeight,
                  "px;background-color:", this.cornerClipColor, ";");
                  //"px;background-color:orange;");

    // move right/bottom to place in relevant corner of 4x area container
    if (edge.contains("R")) output.append("margin-left:", capWidth, "px;");
    if (edge.contains("B")) output.append("margin-top:", capHeight, "px;");
    output.append("'></DIV></DIV>");

    //this.logWarn(this.getCallTrace() + ", html: " + output.toString());

    return output.release(false);


},




//<CornerClips

//>RoundCorners




_edgesAsPeer : function () {
    return this.showEdges && !this.edgesAsChild;
},

_createEdges : function () {
    if (!this.showEdges || isc.isA.EdgedCanvas(this) || this._edgedCanvas != null) {
        return this._edgedCanvas;
    }
    var edgedCanvas = this._edgedCanvas = this._createEdgedCanvas();

    if (this.edgesAsChild) {
        edgedCanvas.resizeTo("100%", "100%");
        edgedCanvas.sendToBack();
        this.addChild(edgedCanvas);
    } else {
        this.addPeer(edgedCanvas);
    }
    return edgedCanvas;
},

//> @attr canvas.showEdges (Boolean : false : IR)
// Whether an +link{class:EdgedCanvas} should be used to show image-based edges around this
// component.
//
// @group imageEdges
// @visibility roundCorners
// @example edges
//<

//> @attr canvas.edgeSize (number : 10 : IR)
// @include edgedCanvas.edgeSize
// @example edges
//<

//> @attr canvas.edgeOffset (number : null : IR)
// @include edgedCanvas.edgeOffset
// @example corners
//<

//> @attr canvas.edgeImage (SCImgURL : "[SKIN]edge.gif" : IR)
// @include edgedCanvas.edgeImage
// @example edges
//<

//> @attr canvas.customEdges (Array of String : null : IR)
// @include edgedCanvas.customEdges
//<

//> @attr canvas.edgeBackgroundColor (Color: null : IR)
// Background color for the EdgedCanvas created to decorate this component.  This can be used
// to provide an underlying "tint" color for translucent edge media
//
// @group imageEdges
// @visibility roundCorners
//<

//> @attr canvas.edgeOpacity (int : null : IR)
// Opacity of the edges.  Defaults to matching this.opacity.
// if +link{Canvas.setOpacity()} is called on a Canvas where edgeOpacity is set,
// edgeOpacity will be considered a percentage of the parent's opacity (so 50% opaque parent plus
// edgeOpacity 50 means 25% opaque edges)
// @setter setEdgeOpacity()
//
// @group imageEdges
// @visibility external
// @example edges
//<

//> @attr canvas.edgeShowCenter (Boolean : false : IR)
// @include edgedCanvas.showCenter
// @example corners
//<

//> @attr canvas.edgeCenterBackgroundColor (Color: null : IR)
// @include edgedCanvas.centerBackgroundColor
//<

//> @method canvas.setEdgeOpacity()
// Set the +link{edgeOpacity} and mark the canvas for redraw
// @param   newOpacity  (number)    new edge-opacity level
// @visibility external
// @example edges
//<
setEdgeOpacity : function (newOpacity) {
    var realOpacity = this.edgeOpacity = newOpacity;
    if (this.opacity > 0 && this.opacity < 100) {
        realOpacity = this.opacity * (this.edgeOpacity / 100);
    }
    this._edgedCanvas.setOpacity(realOpacity);
},


_edgePassThroughs : [
    "edgeImage", "edgeColor", "customEdges", "shownEdges",
    "edgeSize", "edgeTop", "edgeBottom", "edgeLeft", "edgeRight",
    "edgeOffset", "edgeOffsetTop", "edgeOffsetBottom", "edgeOffsetLeft", "edgeOffsetRight",
    "canDragResize", "canDragReposition"
],
_createEdgedCanvas : function () {
    // pass through edge-related properties
    var propNames = this._edgePassThroughs,
        edgedCanvas = isc.EdgedCanvas.createRaw();
    edgedCanvas.autoDraw = false;
    edgedCanvas._generated = true;
    edgedCanvas.containedPeer = true;
    edgedCanvas.dragTarget = this;

    edgedCanvas.visibility = this.visibility;
    edgedCanvas.opacity = this.opacity;
    edgedCanvas.useOpacityFilter = this.useOpacityFilter;
    if (this.edgeOpacity != null) {
        edgedCanvas.opacity = this.edgeOpacity;
        edgedCanvas._setOpacityWithMaster = false;
    }
    edgedCanvas.smoothFade = this.smoothFade;


    if (this.edgeOverflow != null) edgedCanvas.overflow = this.edgeOverflow;

    // edged canvases behavior like super-borders, so have the thing they're
    // attached to handle events occurring on the edge (as it would with standard CSS borders)
    edgedCanvas.eventProxy = this;

    for (var i = 0; i < propNames.length; i++) {
        var name = propNames[i];
        if (this[name] != null) edgedCanvas[name] = this[name];
    }
    if (this.edgeBackgroundColor) edgedCanvas.backgroundColor = this.edgeBackgroundColor;
    if (this.edgeCenterBackgroundColor) {
        edgedCanvas.centerBackgroundColor = this.edgeCenterBackgroundColor;
    }
    if (this.edgeShowCenter != null) edgedCanvas.showCenter = this.edgeShowCenter;
    if (!this.edgesAsChild) edgedCanvas.zIndex = this.getZIndex(true)-1;

    edgedCanvas.completeCreation();
    return edgedCanvas;
},


// NOTEs on shadow placement and softness
// "thrower" means the element that throws the shadow.
//
// Possible properties for configuring shadows:
//
// - offset
//   How far the shadow is offset from the thrower
//   Physically:
//   - with a fixed light source, offset increases with thrower height
//   - a more angular light source causes larger offsets for all throwers, and a more distant
//     light source causes less offset
//   - technically, viewer angle would also change offset, but we assume the viewer is centered
//
// - softness
//   How much blurring there is along the shadows edges, and how much larger the shadow is than
//   the element that throws it.
//   Physically:
//   - with a fixed light source, softness increases with thrower height
//   - a light source closer to the page causes larger, softer shadows for all throwers
//
// - angle
//   Direction shadow is offset.  This is almost always 45 degrees down/right, and we don't
//   support altering this
//
// - depth
//   A combination of softness and offset.
//   Physically, given a single light source and thrower height, both softness and
//   offset are known.  For a given depth, we implement an arbitrary default relationship
//   between depth and softness (implying a particular light source distance) and between depth
//   and offset (implying a particular light source distance and angle)
//
// Sample softness/offset relations known to look nice:
//
// softness    offset    shadow pixels visible left/above   shadow pixels visible right/below
// 1           1         0                                  2
// 2           1         1                                  3
// 3           2         1                                  5
// 6           2         4                                  8

//> @attr canvas.showShadow     (Boolean : false : [IRW])
// Whether to show a drop shadow for this Canvas.
// <P>
// Developers should be aware that the drop shadow
// is drawn outside the specified width and height of the widget meaning a widget with shadows
// takes up a little more space than it otherwise would. A full screen canvas with showShadow set
// to true as this would be likely to cause browser scrollbars to appear - developers can handle
// this by either setting this property to false on full-screen widgets, or by setting
// overflow to "hidden" on the &lt;body&gt; element  browser-level scrolling is never intended to occur.
//
// @setter setShowShadow()
// @group shadow
// @example shadows
// @visibility external
//<

//> @attr canvas.shadowDepth    (number : 4 : [IR])
// Depth of the shadow, or the virtual height above the page of the widget throwing the shadow.
// <P>
// This is a single parameter that can be used to control both <code>shadowSoftness</code> and
// <code>shadowOffset</code>.
//
// @visibility external
// @group shadow
//<
shadowDepth: 4,

//> @attr canvas.shadowOffset   (number : null : IRWA)
// Offset of the shadow.  Defaults to half of <code>shadowDepth</code> if unset.
// <P>
// Because of the blurred edges, a shadow is larger than the originating component by
// 2xsoftness.  An <code>shadowOffset</code> of 0 means that the shadow will extend around the
// originating component equally in all directions.
//
// @visibility external
// @group shadow
// @example shadows
//<

//> @attr canvas.shadowSoftness (number : null : IRWA)
// Softness, or degree of blurring, of the shadow.
// <P>
// A shadow with <code>softness:x</code> is 2x pixels larger in each direction than the element
// throwing the shadow, and the media for each edge should be x pixels wide/tall.
// <P>
// Defaults to <code>shadowDepth</code> if unset.
//
// @visibility external
// @group shadow
// @example shadows
//<

//> @attr canvas.shadowImage   (SCImgURL : "[SKIN]ds.png" : [IRA])
// Base name of the series of images for the sides, corners, and center of the shadow.
// <P>
// The actual image names fetched for the dropShadow combine the segment name and the
// <code>shadowDepth</code> setting.  For example, given "ds.png" as the base name, a depth of
// 4, and the top-left segment of the shadow, we'd use "ds4_TL.png".
// <P>
// The names for segments are the same as those given for controlling resizable edges; see
// +link{attr:canvas.resizeFrom}.  The center segment has the name "center".  The center segment is
// the only segment that doesn't include the depth in the URL, so the final image name for the
// center given a baseName of "ds.png" would be just "ds_center.png".
//
// @visibility external
// @group shadow
//<

//> @method canvas.setShowShadow()
// Method to update +link{canvas.showShadow}.
// @param showShadow (boolean) true if the shadow should be visible false if not
// @visibility external
// @group shadow
//<
setShowShadow : function (showShadow) {
    this.showShadow = showShadow;
    if (showShadow) {
        if (!this._shadow) this._createShadow();
        else if (this.isDrawn()) this._shadow.show();
    } else {
        if (this._shadow) this._shadow.hide();
    }
},

_createShadow : function () {
    var shadow = this._shadow = this.createAutoChild("shadow",
                                                     {visibility:this.visibility,
                                                      zIndex:this.getZIndex(true)-3},
                                                     isc.DropShadow);
    this.updateShadow(true);

    this.addPeer(shadow);
    shadow.moveBelow(this);
},

// whether to allow drag resizing from the shadow.  Generally useful as the shadow, if present,
// occludes other elements and is hence a dead zone in terms of interactivity without this
// behavior.

dragResizeFromShadow:true,

updateShadow : function (initTime) {
    if (!initTime) this.setShowShadow(this.showShadow);
    var shadow = this._shadow;
    if (!shadow) return;

    shadow.offset = this.shadowOffset;
    shadow.offsetX = this.shadowOffsetX;
    shadow.offsetY = this.shadowOffsetY;
    shadow.softness = this.shadowSoftness;

    if (this.shadowImage) shadow.setEdgeImage(this.shadowImage);

    // NOTE: setDepth recalculates offsets and softness, even if depth change is a no-op
    shadow.setDepth(this.shadowDepth);

    if (this.dragResizeFromShadow && this.canDragResize) {
        // NOTE: master's setting for canDragResize is dynamically checked via overrides on the
        // DropShadow class
        shadow.canDragResize = this.canDragResize;
        shadow.resizeFrom = this.resizeFrom;
        shadow.dragTarget = this;
    }
},
//<RoundCorners

_$shadow:"shadow",
_$snapHGap:"snapHGap",
_$snapVGap:"snapVGap",
_$childrenSnapToGrid:"childrenSnapToGrid",
_$childrenSnapResizeToGrid:"childrenSnapResizeToGrid",
propertyChanged : function (propName, value) {
    if (isc.contains(propName, this._$shadow) && this.updateShadow) this.updateShadow();
    if ((propName == this._$snapHGap || propName == this._$snapVGap) && this.snapGridPane) {
        var showing = this.showSnapGrid;
        this.setShowSnapGrid(false);
        this.snapGridPane = null;
        if (showing) this.setShowSnapGrid(true);
    }
    if (propName == this._$childrenSnapToGrid || propName == this._$childrenSnapResizeToGrid) {
        if ((this.childrenSnapToGrid || this.childrenSnapResizeToGrid) && this.showSnapGrid) this._showSnapGrid();
        else if (this.snapGridPane) this.snapGridPane.hide();
    }
},


// Group Frame APIs
// ---------------------------------------------------------------------------------------

//> @attr canvas.isGroup (boolean : false : IR)
// Should a grouping frame be shown around this canvas.
// @see canvas.groupBorderCSS
// @see canvas.groupLabelStyleName
// @see canvas.groupLabelBackgroundColor
// @visibility external
//<
// isGroup - should we show a grouping frame around this canvas?

isGroup:false,

setIsGroup : function (isGroup) {
    if (isGroup == this.isGroup) return;
    // horrible hack: we use registerAttachedPeer to account for the space taken up
    // by the label with margins - for whatever reason this doesn't update on a drawn widget
    // without a clear/draw(), so explicitly clear / draw if necessary
    var mustClear = this.shouldShowGroupLabel() && this.isDrawn();
    if (mustClear) this.clear();
    if (isGroup) {
        this._standardBorder = this.border;
        this.setBorder(this.groupBorderCSS);
        if (this.shouldShowGroupLabel()) this._showGroupLabel();
    } else {
        this.setBorder(this._standardBorder || "");
        if (this.shouldShowGroupLabel()) this._hideGroupLabel();
    }
    this.isGroup = isGroup;
    if (mustClear) this.draw();
},


//> @attr canvas.groupBorderCSS (String : "2px solid black" : IR)
// Sets the style for the grouping frame around the canvas. Only necessary when +link{canvas.isGroup}
// is set to true.
// @group appearance
// @visibility external
//<
groupBorderCSS:"2px solid black",

groupLabelPadding:10,

showGroupLabel:true,
shouldShowGroupLabel : function () {
    return this.showGroupLabel;
},

//> @attr canvas.groupLabelStyleName (CSSStyleName : "groupLabel" : IR)
// Sets the style for the grouping label. Only necessary when +link{canvas.isGroup}
// is set to true.
// <p>
// Note that +link{groupLabelBackgroundColor} overrides any background-color of this style.
// @group appearance
// @visibility external
//<
groupLabelStyleName:"groupLabel",

//> @attr canvas.groupLabelBackgroundColor (CSSColor : null : IRW)
// If set, the background color of the grouping label. Only applicable when +link{isGroup}
// is set to true.
// <p>
// This corresponds to the CSS background-color property on the grouping label. You can set this
// property to an RGB value (e.g. #22AAFF) or a named color (e.g. red) from a list of browser supported
// color names.
// <smartgwt><p>
// The getter for this attribute, {@link #getGroupLabelBackgroundColor()}, returns the color
// that will actually be used; i.e. if groupLabelBackgroundColor is left unset or is set to
// null, then getGroupLabelBackgroundColor() returns the color string that will be used.
// </smartgwt>
// @setter setGroupLabelBackgroundColor()
// @group appearance
// @visibility external
//<
//groupLabelBackgroundColor: null,

// creates the groupLabel canvas (and sets default properties)
makeGroupLabel : function () {

    if (!this.groupLabel) {
        var dynamicDefaults = {
            autoDraw:false,
            backgroundColor:this.getGroupLabelBackgroundColor(),
            eventProxy:this,
            styleName:this.groupLabelStyleName
        }
        if (this.groupTitle != null) dynamicDefaults.contents = this.groupTitle;
        this.groupLabel = this.createAutoChild("groupLabel", dynamicDefaults);

    } else {
        if (this.groupTitle != null) this.groupLabel.setContents(this.groupTitle);
        this.groupLabel.setBackgroundColor(this.getGroupLabelBackgroundColor());
    }
},

// default groupLabel background color to match us, or be white if we're transparent.
// We need to return a color here to mask the grouping frame.
getGroupLabelBackgroundColor : function () {
    if (this.groupLabelBackgroundColor) return this.groupLabelBackgroundColor;
    if (this.backgroundColor) return this.backgroundColor;
    // should check this.styleName.backgroundColor too...
    return "white";
},

//> @method canvas.setGroupLabelBackgroundColor()
// Setter for +link{groupLabelBackgroundColor}.
// @param groupLabelBackgroundColor (CSSColor) the new grouping label background color.
// @visibility external
//<
setGroupLabelBackgroundColor : function (groupLabelBackgroundColor) {
    this.groupLabelBackgroundColor = groupLabelBackgroundColor;
    if (this.groupLabel) this.groupLabel.setBackgroundColor(this.getGroupLabelBackgroundColor());
},

_showGroupLabel : function () {
    this.makeGroupLabel();

    var label = this.groupLabel;
    // draw the groupLabel offscreen so we can pick up vertical sizing
    var labelHeight;
    if (label.overflow == isc.Canvas.VISIBLE) {
        // Ensure it's top level before trying to draw it offscreen
        if (label.parentElement != null) label.deparent();
        label.setTop(-1000);
        label.draw();
        labelHeight = label.getVisibleHeight();

    } else {
        labelHeight = label.getVisibleHeight();
    }
    // the groupLabel will be an attached peer - this handles updating the top margin
    var offset = Math.round(labelHeight / 2);
    this._registerAttachedPeer(label, isc.Canvas.TOP, offset);

    // very crude- explicitly set topPadding to ensure there's enough space

    var padding = labelHeight - offset;
    if (this.padding) padding += this.padding;
    this.setTopPadding(padding);

    this._moveGroupLabelIntoPlace();

    if (label.masterElement != this) this.addPeer(label);
    if (this.isDrawn()) {
        if (!label.isDrawn()) label.draw();
    }
    // xxx hack: run calculate margins to ensure the visible height of the label is remembered
    // as top margin (it will likely be cleared before being added to layouts etc)
    this.getTopMargin();
    label.moveAbove(this);
    // if we had to draw the label offscreen, and we're not yet drawn, clear now.
    if (label.isDrawn() && !this.isDrawn()) label.clear();
},
_hideGroupLabel : function () {
    if (!this.groupLabel) return;
    var label = this.groupLabel;
    this._unRegisterAttachedPeer(label, isc.Canvas.TOP);
    this.setTopPadding(null);
    label.clear();
    // xxx this depeer is required to ensure it doesn't draw with us next time we get drawn!
    label.depeer();
},
_moveGroupLabelIntoPlace : function () {
    var label = this.groupLabel;

    // can update this to support center / right alignment fairly easily
    var left,
        top = this.getTop();
    if (this.isRTL()) {
        left = this.getRight() - this.groupLabelPadding - label.getVisibleWidth();
    } else {
        left = this.getLeft() + this.groupLabelPadding;
    }
    label.moveTo(left, top);
},

//groupLabelConstructor:"Label"
groupLabelDefaults:{
    // default to a Label
    _constructor:"Label",
    // which fits its content
    overflow:"visible",
    height:1, width:1,
    _resizeWithMaster:false,
    wrap:false,
    // center in both directions
    vAlign:"center", align:"center",

    redraw : function () {
        var ret = this.Super("redraw", arguments);
        this.creator._moveGroupLabelIntoPlace();
        return ret;
    },
    handleParentMoved : function () {
        this.Super("handleParentMoved", arguments);
        this.creator._moveGroupLabelIntoPlace();
    }
},

//> @attr canvas.groupTitle (HTMLString : null : IRW)
// The title/label for the grouping. Only applicable when +link{Canvas.isGroup,isGroup} is set to true.
// @setter setGroupTitle()
// @group appearance
// @visibility external
//<

//> @method canvas.setGroupTitle()
// Setter for +link{Canvas.groupTitle}.
// @param newTitle (HTMLString) The new title for the grouping.
// @group appearance
// @visibility external
//<
setGroupTitle : function (newTitle) {
    this.groupTitle = newTitle;
    if (this.groupLabel) {
        this.groupLabel.setContents(this.groupTitle);
    } else {
        this._showGroupLabel();
    }
},


// Trigger Area
// ---------------------------------------------------------------------------------------


//> @attr canvas.showTriggerArea (boolean : false : IRA)
// Whether to show a +link{Canvas.triggerArea,triggerArea} over this canvas.
//<
showTriggerArea: false,

//> @attr canvas.triggerArea (AutoChild Canvas : see below : RA)
// When +link{Canvas.showTriggerArea,showTriggerArea} is set to <code>true</code>, a special
// peer of this canvas is created and overlaid on top which forwards all events that it receives
// to this canvas. The <code>triggerArea</code> peer is slightly larger than this canvas by
// +link{Canvas.triggerAreaTop,triggerAreaTop} at the top, +link{Canvas.triggerAreaRight,triggerAreaRight}
// on the right, +link{Canvas.triggerAreaBottom,triggerAreaBottom} at the bottom, and
// +link{Canvas.triggerAreaLeft,triggerAreaLeft} on the left.
// <p>
// <code>triggerArea</code>s can be useful in creating applications that are specifically adapted
// for +link{Browser.isTouch,touch} displays because they are a simple way to increase the hit
// area of small UI elements on screen.
//<
triggerAreaDefaults: {
    // there is no need to redraw the triggerArea
    redrawOnResize: false,
    _redrawWithParent: false,
    _redrawWithMaster: false,

    _resizeWithMaster: false,
    overflow: "hidden",
    canFocus: false,

    _fitToMaster : function () {
        var master = this.masterElement,
            rect = master._getTriggerAreaRect();
        this.setRect(rect);
    },
    masterResized : function () {
        this._fitToMaster();
    }
},

//> @attr canvas.triggerAreaTop (int : 5 : IRWA)
// The number of pixels that the +link{Canvas.triggerArea,triggerArea} extends over the top
// edge of this canvas. Must be non-negative.
//<
triggerAreaTop: 5,

setTriggerAreaTop : function (newTriggerAreaTop) {

    if (this.triggerAreaTop == newTriggerAreaTop) return;
    this.triggerAreaTop = newTriggerAreaTop;
    if (this.triggerArea != null) this.triggerArea._fitToMaster();
},

//> @attr canvas.triggerAreaRight (int : 5 : IRWA)
// The number of pixels that the +link{Canvas.triggerArea,triggerArea} extends over the right
// edge of this canvas. Must be non-negative.
//<
triggerAreaRight: 5,

setTriggerAreaRight : function (newTriggerAreaRight) {

    if (this.triggerAreaRight == newTriggerAreaRight) return;
    this.triggerAreaRight = newTriggerAreaRight;
    if (this.triggerArea != null) this.triggerArea._fitToMaster();
},

//> @attr canvas.triggerAreaBottom (int : 5 : IRWA)
// The number of pixels that the +link{Canvas.triggerArea,triggerArea} extends over the bottom
// edge of this canvas. Must be non-negative.
//<
triggerAreaBottom: 5,

setTriggerAreaBottom : function (newTriggerAreaBottom) {

    if (this.triggerAreaBottom == newTriggerAreaBottom) return;
    this.triggerAreaBottom = newTriggerAreaBottom;
    if (this.triggerArea != null) this.triggerArea._fitToMaster();
},

//> @attr canvas.triggerAreaLeft (int : 5 : IRWA)
// The number of pixels that the +link{Canvas.triggerArea,triggerArea} extends over the left
// edge of this canvas. Must be non-negative.
//<
triggerAreaLeft: 5,

setTriggerAreaLeft : function (newTriggerAreaLeft) {

    if (this.triggerAreaLeft == newTriggerAreaLeft) return;
    this.triggerAreaLeft = newTriggerAreaLeft;
    if (this.triggerArea != null) this.triggerArea._fitToMaster();
},

_getTriggerAreaRect : function () {
    var triggerAreaTop = this.triggerAreaTop,
        triggerAreaRight = this.triggerAreaRight,
        triggerAreaBottom = this.triggerAreaBottom,
        triggerAreaLeft = this.triggerAreaLeft;
    return {
        left: this.getLeft() - triggerAreaLeft,
        top: this.getTop() - triggerAreaTop,
        width: this.getVisibleWidth() + triggerAreaRight + triggerAreaLeft,
        height: this.getVisibleHeight() + triggerAreaTop + triggerAreaBottom
    };
},
_createTriggerArea : function () {

    var rect = this._getTriggerAreaRect();
    var triggerArea = this.triggerArea = this.createAutoChild("triggerArea", {
        eventProxy: this,
        left: rect.left,
        top: rect.top,
        width: rect.width,
        height: rect.height


    }, isc.Browser.isAndroid && isc.Browser.isChrome ? isc.Img : isc.Canvas);
    this.addPeer(triggerArea);
    return triggerArea;
},

//ruleScope
//---------------------------------------------------------------------------------------

//> @groupDef ruleCriteria
// If a property says it supports "rule criteria" it means that the criteria will be evaluated in
// the context of the current +link{canvas.ruleScope}, so can set +link{criterion.fieldName} to a
// path that references state in the current rule context.
// <p>
// Because this type of criteria are allowed to reference UI state (such as whether any
// records are selected in an adjacent grid) they are not generally used to filter DataSource
// records, since such criteria would not be able to be evaluated on the server.
// <p>
// All RuleCriteria are also +link{group:dynamicCriteria,Dynamic Criteria} unless otherwise noted.
//
// @title Form Rules
// @visibility external
//<

//> @attr canvas.ruleScope (String : null : IR)
// +link{Canvas.ID} of the component that gathers the context for evaluation of criteria-based
// rules specified by properties such as +link{formItem.visibleWhen}.
// <p>
// If not specified, this component will search through it's +link{canvas.parentCanvas} chain until it
// either reaches the top or reaches a parent marked +link{canvas.isRuleScope}.  Determination of the
// <code>ruleScope</code> happens when the component is first drawn.
// <p>
// The component designated as the <code>ruleScope</code> manages a nested data structure called
// the "rule context" which contains information from all +link{DataBoundComponent}s that are
// registered with the <code>ruleScope</code>.  By specifying +link{criterion.fieldName} as a
// +link{type:DataPath}, AdvancedCriteria defined in properties such as
// +link{formItem.visibleWhen} can access any part of the rule context.
// <p>
// By default, the rule context contains data as follows:
// <ul>
// <li> any <code>DataBoundComponent</code> that has a DataSource contributes the values of the
//   selected record or record being edited under the ID of the DataSource. For any collision
//   an editable display (such as a form or editable grid) wins over a static display (such as
//   a non-editable grid with a selection.)
// <li> any ListGrid or other component that manages a selection and has been assigned an explicit
//   +link{Canvas.ID} will contribute the values of the selected record under
//   <code>&lt;componentId&gt;.selectedRecord</code>, and also contributes 3 flags for checking
//   for selection: <code>anySelected</code>, <code>multiSelected</code>,
//   <code>numSelected</code>.
// <li> any DynamicForm or other component that edits values and has been assigned an explicit
//   +link{Canvas.ID} contributes its current values under
//   <code>&lt;componentId&gt;.values</code>, and contributes a flag <code>hasChanges</code>.
// <li> any DynamicForm or ListGrid that has been assigned an explicit +link{Canvas.ID}
//   contributes a value <code>&lt;componentId&gt;.focusField</code>. When present the value
//   indicates the component has focus along with the name of the field that has focus. Its absense
//   indicates the component does not have focus at all.
// <li> any ListGrid that has been assigned an explicit +link{Canvas.ID} contributes a flag
//   <code>isGrouped</code> under <code>&lt;componentId&gt;</code>.
// </ul>
// For example, given a screen where:
// <ul>
// <li> a ListGrid with ID "itemGrid" and DynamicForm with ID "itemForm" are both bound to the
//   <code>supplyItem</code> sample DataSource
// <li> the ListGrid has a single selection, and the record selected in the ListGrid is being
//   edited in the form, and has been changed
// </ul>
// The default rule context available from +link{getRuleContext()}, expressed as JSON, would be:
// <pre>
// {
//  supplyItem : {
//     itemID : "654321",
//     itemName : "Sewing Machine",
//     price : 5.50, // note: user change
//     <i>..other properties..</i>
//  },
//  itemForm.values : {
//     itemID : "654321",
//     itemName : "Sewing Machine",
//     price : 5.50, // note: user change
//     <i>..other properties..</i>
//  },
//  itemForm.focusField : "itemName",
//  itemForm.hasChanges : true,
//  itemGrid.selectedRecord : {
//     itemID : "654321",
//     itemName : "Sewing Machine",
//     price : 3.50, // note: old price
//     <i>..other properties..</i>
//  },
//  itemGrid.anySelected : true,
//  itemGrid.multiSelected : false,
//  itemGrid.numSelected : 1,
//  itemGrid.isGrouped : false
// }
// </pre>
// @visibility external
//<







//> @attr canvas.isRuleScope (Boolean : null : IR)
// Marks this Canvas as the +link{canvas.ruleScope} that will be discovered by any contained
// +link{DataBoundComponent}s which do not specify an explicit <code>ruleScope</code>.
// @visibility external
//<

//> @method canvas.getRuleContext()
// Get the current value of the rule context collected by the +link{canvas.ruleScope} of this component
// (which may be this component itself or whatever component is managing the
// <code>ruleScope</code> for this component).
// <p>
// If the <code>databoundOnly</code> parameter is passed as true, only data from components that
// actually have a +link{DataSource} is included.
// <p>
// Use +link{canvas.ruleContextChanged()} to get a notification of changes to the rule context.
//
// @param [databoundOnly] (boolean) whether to include only data from components that have a
//                                  +link{DataSource}
// @return (Object) the ruleContext object, or null if canvas is not part of a ruleScope
// @visibility external
//<
getRuleContext : function (databoundOnly) {
    var component = this.getRuleScopeComponent();
    if (!component) return null;

    if (!component._ruleContext) component._ruleContext = {};

    var ruleContext = component._ruleContext;
    if (databoundOnly) {
        var filteredContext = {},
            dbcList = component._ruleScopeDBCs
        ;
        for (var i = 0; i < dbcList.length; i++) {
            var dbc = dbcList[i];
            if (ruleContext[dbc.ID] != null) {
                filteredContext[dbc.ID] = ruleContext[dbc.ID];
            }
            if (dbc.dataSource && ruleContext[dbc.dataSource] != null) {
                filteredContext[dbc.dataSource] = ruleContext[dbc.dataSource];
            }
        }
        ruleContext = filteredContext;
    }

    return ruleContext;
},

getRuleScopeDataBoundComponents : function () {
    var component = this.getRuleScopeComponent();
    if (!component) return [];

    return component._ruleScopeDBCs || [];
},

//> @method canvas.ruleContextChanged()
// Notification that the rule context gathered by the +link{canvas.ruleScope} has changed.
// <p>
// This notification fires only on the component designated as the +link{ruleScope}; components
// that are merely contributing data to the rule context do not fire
// <code>ruleContextChanged</code>.
// @param data (Object) the new rule context
// @visibility external
//<
ruleContextChanged : function (newContext) { },

//> @method canvas.provideRuleContext()
// Provide data to the +link{canvas.ruleScope} component, to be made available in the rule context at the
// specified <code>path</code>.
// <p>
// <code>path</code> must be one or more valid identifiers with either dot (.) or slash (/) used
// as a separator.
// <p>
// <code>data</code> can be any value, including both atomic values like a Boolean or String, or a
// nested data structure.  Pass <code>data</code> as <code>null</code> to remove data from the
// context at the specified <code>path</code>
// <p>
// <code>dbc</code> is the DataBoundComponent to be identified as the owner of the rule context
// contribution. This component is used to handle any conflicts between multiple components
// contributing to the same base path (i.e. first segment of path). For any collision an editable
// display (such as a form or editable grid) wins over a static display (such as a non-editable
// grid with a selection). Hidden components have lowest priority even if editable. For two
// editable components the first becomes the owner.
//
// @param path (String) path where data should be made available
// @param data (any) data to contribute to rule context
// @param [dbc] (DataBoundComponent) dataBoundComponent contributing to ruleContext
// @visibility external
//<

provideRuleContext : function (path, data, dbc, suppressChangeEvent) {
    // If ruleScope hasn't been determined, ruleContext cannot yet be populated
    if (!this.ruleScope && !this.isRuleScope) return;

    if (!path) {
        this.logWarn("provideRuleContext: no ruleContext path specific - ignored", "ruleContext");
        return;
    }

    var component = this.getRuleScopeComponent();
    if (!component) return;

    var dbcID = (dbc ? dbc.getID() : null);

    this.logDebug("provideRuleContext [" + [this.getRuleScope(),dbcID,(suppressChangeEvent ? "PARTIAL" : "COMPLETE")] + "]: " + path + " = " + this.echo(data), "ruleContext");
    if (!component._ruleContext) component._ruleContext = {};
    if (!component._ruleContextOwners) component._ruleContextOwners = {};

    var ruleContext = component._ruleContext,
        owners = component._ruleContextOwners,
        basePath = path.replace("/", ".").split(".")[0]
    ;

    // Assign path ownership
    var owner = owners[basePath];
    if (dbc) {
        if (owner != dbcID) {
            // Path is not owned by caller
            if (owner == null) {
                // No owner yet - assign to the caller
                owner = owners[basePath] = dbcID;
            } else {
                // Determine if caller has priority over current owner
                if (isc.Canvas.getRuleContextPreferredOwnerID(window[owner], dbc) == dbcID) {
                    this.logDebug("provideRuleContext: " + dbcID + " taking ownership of " + basePath + " from " + owner, "ruleContext");
                    owner = owners[basePath] = dbcID;
                } else {
                    this.logDebug("provideRuleContext: " + dbcID + " NOT taking ownership of " + basePath + " from " + owner, "ruleContext");
                }
            }
        }
    }

    // Only update/clear data if this component is the path owner
    if (owner == dbcID) {
        if (data != null) {
            isc.Canvas._saveFieldValue(path, null, data, component._ruleContext);
        } else {
            isc.Canvas._clearFieldValue(path, component._ruleContext);
            if (dbcID && path == basePath && owners[basePath] == dbcID) {
                // Implied release of ownership by clearing basePath
                delete owners[basePath];
            }
        }
    } else {
        this.logDebug("provideRuleContext: " + path + " update ignored - not owner [dbc=" + dbcID + ",owner="+ owners[basePath] + "]", "ruleContext");
    }

    // Set ruleContext on the rulesEngine. Note that the object reference is
    // shared with the local ruleContext so any future changes are reflected
    // in both locations.
    if (component.rulesEngine && !component.rulesEngine.ruleContext) {
        component.rulesEngine.ruleContext = component.getRuleContext();
    }

    // Fire change event
    if (!suppressChangeEvent && component.ruleContextChanged) {
        this.fireRuleContextChanged(component);
    }
},

_getFromRuleContext : function (path) {
    return isc.Canvas._getFieldValue(path, null, this.getRuleContext());
},

fireRuleContextChanged : function (component) {
    // If ruleScope hasn't been determined, nothing to trigger
    if (!this.ruleScope && !this.isRuleScope) return;

    if (!component) component = this.getRuleScopeComponent();
    if (!component) return;

    if (component.rulesEngine) component.rulesEngine.processContextChanged();
    component.ruleContextChanged(component._ruleContext);
},

getRulesEngine : function () {
    if (this.rulesEngine) return this.rulesEngine;

    var component = this.getRuleScopeComponent();
    if (!component) return null;

    if (!component.rulesEngine) {
        component.rulesEngine = isc.RulesEngine.create({
            baseComponent: component,
            members: [ component ]
        });
    }

    return component.rulesEngine;
},

getRuleScopeComponent : function () {
    // If ruleScope hasn't been determined, component cannot be returned
    if (!this.ruleScope && !this.isRuleScope) return null;

    var ruleScope = this.getRuleScope();
    if (!ruleScope) return null;

    var component = window[ruleScope];
    return (!component || component.destroyed ? null : component);
},

getRuleScope : function () {
    if (this.ruleScope) {
        // If Canvas was provided as ruleScope, always return ID
        return (isc.isA.Canvas(this.ruleScope) ? this.ruleScope.getID() : this.ruleScope);
    }
    if (this.isRuleScope) return this.getID();

    var ruleScope = null,
        parentCanvas = this.getParentCanvas()
    ;
    if (parentCanvas) {
        if (this.editNode && this.editContext && !parentCanvas.editNode) {

          return this.getID();
        }
        ruleScope = parentCanvas.getRuleScope();
    } else {
        ruleScope = this.getID();
    }

    return ruleScope;
},


_getObjectLocatorForWhenRules : function (component) {
    var testRoot = isc.AutoTest.testRoot;

    isc.AutoTest.testRoot = null;
    var locator = isc.AutoTest.getObjectLocator(component);
    isc.AutoTest.testRoot = testRoot;
    return locator;
},

_createCanvasWhenRules : function () {
    if (this._createdCanvasWhenRules) return;

    var component = this.getRuleScopeComponent();
    if (!component) return null;

    var rules = [];
    if (this.visibleWhen || this.enableWhen) {
        var locator = this._getObjectLocatorForWhenRules(this);

        if (this.visibleWhen) {
            rules.add(this._createWhenRule(locator, "visibility", this.visibleWhen));
        }
        if (this.enableWhen) {
            rules.add(this._createWhenRule(locator, "enable", this.enableWhen));
        }
    }
    if (rules.length > 0) {
        var rulesEngine = component.getRulesEngine();
        // The rulesEngine may not be accessible yet because the ruleScope
        // is not yet derived.
        if (!rulesEngine) {
            // Note that _createdCanvasWhenRules is not set
            return;
        }
        rulesEngine.addMember(this);
        for (var i = 0; i < rules.length; i++) {
            rulesEngine.addRule(rules[i]);
        }
    }
    this._createdCanvasWhenRules = true;
},

_removeCanvasWhenRules : function () {
    var component = this.getRuleScopeComponent();
    if (component) {
        if (component.rulesEngine && (this.visibleWhen || this.enableWhen)) {
            var locator = this._getObjectLocatorForWhenRules(this);

            if (this.visibleWhen) this._removeWhenRule(locator, "visibility");
            if (this.enableWhen) this._removeWhenRule(locator, "enable");
        }
    }
    delete this._createdCanvasWhenRules;
},

_getRuleName : function (locator, type, fieldName) {
    if (fieldName && !locator) {
        var dsName = (isc.isA.String(this.dataSource) ? this.dataSource : this.dataSource.getID());
        return dsName + "_" + fieldName + "_" + type;
    }
    return (fieldName ? this.ID + "_" + fieldName + "_" + type : this.ID + "_" + type);
},

_createWhenRule : function (locator, type, criteria, fieldName) {
    if (!isc.DS.isAdvancedCriteria(criteria)) {
        if (criteria.operator && criteria.criteria) {
            // Advanced format but missing constructor
            criteria = isc.clone(criteria);
            criteria._constructor = "AdvancedCriteria";
        } else if (criteria.fieldName && criteria.operator) {
            // Shorthand format
            criteria = {
                    _constructor: "AdvancedCriteria",
                    operator: "and",
                    criteria: isc.clone(criteria)
            };
        } else {
            criteria = isc.DS.convertCriteria(criteria, "exact");
        }
    } else {
        criteria = isc.clone(criteria);
    }
    this._globalizeWhenAdvancedCriteria(criteria);

    var ruleName = this._getRuleName(locator, type, fieldName),
        target = (locator != null ? { locator : locator } : { fieldName: this.dataSource + "." + fieldName })
    ;

    return isc.addProperties({
        name: this._getRuleName(locator, type, fieldName),
        triggerEvent: "contextChanged",
        type: type,
        applyWhen: criteria
    }, target);
},

_removeWhenRule : function (locator, type, fieldName) {
    var name = this._getRuleName(locator, type, fieldName),
        rulesEngine = this.getRulesEngine()
    ;
    if (rulesEngine) rulesEngine.removeRule(name);
},

_removeFromRuleScope : function () {
    if (!this.ruleScope) return;

    var component = this.getRuleScopeComponent();
    if (!component) return null;

    if (component._ruleScopeDBCs) {
        component._ruleScopeDBCs.remove(this);
    }
    if (component._ruleContextOwners) {
        var ID = this.ID,
            owners = component._ruleContextOwners
        ;
        for (var key in owners) {
            if (owners[key] == ID) delete owners[key];
        }
    }
}

});



isc.Canvas.addClassMethods({



// for canvas start/end in useCaptureSpan mode.
//
// Note: we need to strip ALL script tags - i.e. not just the Javascript ones so that
// e.g. VBScript doesn't re-execute. That's why we don't reuse code from HTMLFlow here.
//
// Note: these will incorrectly strip matching text in e.g. strings and textareas - but that
// should be a somewhat unlikely occurrence.
//
// Furthermore, we can provide these as semi-public override points for easy patching if anyone
// runs into a problem.
stripScriptTags : function (html) {
    // \r required for Firefox 1.0 (and probably earlier moz) - otherwise doesn't match EOL
    return html.replace(/<script([^>]*)?>(.|\n|\r)*?<\/script>/ig, isc.emptyString);
},
stripLinkTags : function (html) {
    return html.replace(/<link([^>]*)?>/ig, isc.emptyString);
},


// DOM emulation
// --------------------------------------------------------------------------------------------

//> @classMethod Canvas.getById()
// Retrieve a Canvas by it's global +link{canvas.ID,ID}.
// @param ID (String) global ID of the Canvas
// @return (Canvas) the Canvas, or null if not found
// @visibility external
//<
getById : function (sId) {
    var canvas = window[sId] || null;
    return canvas ? (isc.isA.Canvas(canvas) ? canvas : null) : null;
},

// get the next zIndex for the next item to be drawn. see setZIndex() for notes
getNextZIndex : function () {
    return (isc.Canvas._nextZIndex += 18);
},

// getFocusProxyString()
// This will return HTML for a natively-focusable element with no visual representation to be
// written into the DOM.

getFocusProxyString : function (tagBaseName, absolute, offsetLeft, offsetTop, width, height, isVisible,
                                canFocus, tabIndex, accessKey, eventsHandledNatively,
                                focusHandler, blurHandler,
                                keyDownHandler, keyPressHandler, keyUpHandler)
{
    if (this._focusProxyTemplate == null) {
        this._onfocus = "' ONFOCUS=";
        this._closeQuoteSpace = "' ";
        this._onblur = " ONBLUR=";
        this._focusProxyTemplate = [
            "<div",                                                     // 0
            " id='",                                                     // 1
                null,                                                   // 2 - tagBaseName
            "__focusProxyParent'" +
            " style='overflow:hidden;width:0px;height:0px;position:",   // 3
                ,                                                       // 4 - position (absolute/inline)
                ";left:",                                               // 5
                    null,                                               // 6 - offsetLeft
                "px;top:",                                              // 7
                    null,                                               // 8 - offsetTop
                "px;'>",                                                // 9


            (isc.Browser.isSafari ?
                "<textarea" :
                (isc.Browser.isMoz && isc.Browser.geckoVersion >= 20051111 ?
                    "<div" :

                    "<button onclick='event.cancelBubble=true;return false;'"
                )
            ),                                                          // 10

                " id='",                                                 // 11
                    null,                                               // 12 - tagBaseName
                "__focusProxy'",                                         // 13

                // Note: if we are not visible, draw the focusProxy as not being visible either
                // - this prevents it from being focus-able, until we get shown
                " style='VISIBILITY:",                                  // 14
                    null,                                               // 15 - visible / hidden

                // the proxy button is drawn inside it's 0x0 parent div (with overflow hidden)
                // Note - if you make parentDiv bigger than 0x0, and position the focus proxy
                // such that it's initially not visible, when it receives focus, the parent
                // div scrolls, making it visible (at least in Moz)
                // The 0x0 div is supported in both Moz and Safari, so use this to ensure it's
                // not visible
                "left:1px;top:1px;" +


                "width:",                                               // 16
                    (isc.Browser.isSafari ? "1" : null),                // 17 - width
                "px;height:",                                           // 18
                    (isc.Browser.isSafari ? "1" : null),                // 19 - height
                "px;",                                                  // 20
                    null,                                               // 21 - -moz-user-focus (Moz Only)
                this._onfocus,                                           // 22
                    null,                                               // 23 - focusHandler
                this._onblur,                                             // 24
                    null,                                               // 25 - blurHandler
                null, null, null,                                       // 26-28 - onKeyDown/up/press
                " tabindex='",                                           // 29
                    null,                                               // 30 - TabIndex
                    null,                                               // 31 - "ACCESSKEY=x"

                // Hang this attribute on the tag so we can recognize it's not a native form
                // item in EH.eventHandledNatively
                "' focusProxy='true' handleNativeEvents='",                 // 32
                    null,                                               // 33 - true / false
                "'>",
//                tagBaseName," focus proxy" +
                (isc.Browser.isSafari ? "</textarea>" :
                    (isc.Browser.isMoz && isc.Browser.geckoVersion >= 20051111 ? "</div>"
                                                                               : "</button>")
                ),
                "</div>"
        ]
    }

    var template = this._focusProxyTemplate;

    template[2] = tagBaseName;
    template[4] = (absolute ? "absolute" : "inline");
    template[6] = offsetLeft;
    template[8] = offsetTop;
    template[12] = tagBaseName;
    template[15] = (isVisible ? "visible;" : "hidden;");
    template[17] = width;
    template[19] = height;
    if (isc.Browser.isMoz) {
        if (!canFocus || tabIndex == -1) template[21] = "-moz-user-focus:ignore;";
        else template[21] = "-moz-user-focus:normal;"
    }
    if (focusHandler && focusHandler != isc.emptyString) {
        template[22] = this._onfocus;
        template[23] = focusHandler;
    } else {
        template[22] = this._closeQuoteSpace; // close the style=' attribute
        template[23]= null
    }
    if (blurHandler && blurHandler != isc.emptyString) {
        template[24] = this._onblur;
        template[25] = blurHandler
    } else {
        template[24] = null;
        template[25] = null;
    }

    // Only write key handlers in if they were passed in

    template[26] = (keyDownHandler != null ? " onkeydown=" + keyDownHandler : null);
    template[27] = (keyPressHandler != null ? " onkeypress=" + keyPressHandler : null);
    template[28] = (keyUpHandler != null ? " onkeyup=" + keyUpHandler : null);

    template[30] = (canFocus ? tabIndex : -1);
    template[31] = (canFocus && accessKey ? "' accesskey='" + accessKey : null);

    template[33] = (eventsHandledNatively ? true : false);

    return template.join(isc._emptyString);

},

// TabIndex auto-allocation
// Helper to look at our complete allocated tab chain.
showAllocatedTabChain : function () {
    var firstTabWidget = isc.EH._firstTabWidget,
        lastTabWidget = isc.EH._lastTabWidget;
    var info = "First tab widget:" + firstTabWidget +  ", and last:" + lastTabWidget +
         "\nFull chain:";
    var currentWidget = firstTabWidget;
    do {
        info += "\n\t" + currentWidget.getID() + " - " + currentWidget.getTabIndex() + " -->";
        currentWidget = currentWidget._nextTabWidget;
    } while (currentWidget != null && currentWidget != lastTabWidget)

    this.logWarn(info);
},



// CSS Caching
// ---------------------------------------------------------------------------------------

// wipe out any cached CSS information.  This is needed for
// - Safari 2.0 and earlier where we get bad info before page load
// - automated tests that load stylesheets
// - possible future advanced usage like on the fly skin change
clearCSSCaches : function () {

    // tell the Element class to clear all generic CSS caches
    isc.Element._clearCSSCaches();

    // wipe out cached style information on Canvases
    var list = isc.Canvas._canvasList;
    for (var i = 0; i < list.length; i++) {
        var canvas = list[i];
        if (canvas == null || canvas.destroyed) continue;
        canvas._fullMargins = canvas._cachedMargins =
            canvas._cachedBorderSize = canvas._cachedPadding = null;
    }
},

// Dynamic skin size modification
// ---------------------------------------------------------------------------------------

// get the rule declaration from the Nth stylesheet in the page
getStyleRules : function (sheet) {
    if (sheet == null) return;

    var rules;
    try {
        rules = sheet.rules;
        if (rules == null) rules = sheet.cssRules;
    } catch (e) {
        // happens if stylesheet is loaded from a foreign host
        this.logDebug("skipped stylesheet '" + sheet + "' due to exception accessing rules");
    }
    return rules;
},

modifyProperty : function (clazz, delta, propertyName) {
    if (propertyName == null) propertyName = "height";
    if (isc.isA.String(clazz)) clazz = isc.ClassFactory.getClass(clazz);
    if (clazz == null) return; // don't complain; probably just indicates module isn't loaded
    clazz.setInstanceProperty(propertyName, clazz.getInstanceProperty(propertyName) + delta);
},

modifyDefaultsProperty : function (clazz, defaultsName, propertyName, delta) {
    if (propertyName == null) propertyName = "height";
    if (isc.isA.String(clazz)) clazz = isc.ClassFactory.getClass(clazz);
    if (clazz == null) return; // don't complain; probably just indicates module isn't loaded

    var defaults = clazz.getInstanceProperty(defaultsName);
    if (defaults == null) {
        this.logWarn("no such defaults '" + defaultsName + "' in class '" + clazz + "'");
        return;
    }

    var existingValue = defaults[propertyName];

    // don't try to modify null properties.  The most likely case of this is that the defaults
    // in a particular skin don't set the property, relying on class defaults
    if (!isc.isA.Number(existingValue)) return;

    var newDefaults = {};
    newDefaults[propertyName] = existingValue + delta;
    clazz.changeDefaults(defaultsName, newDefaults);
},

//> @classMethod Canvas.resizeFonts()
// Modify the size of fonts for some or all stylesheets defined in the page.
// <p>
// This method can be used to dynamically increase or decrease font size for all of the fonts
// in your application, or just fonts defined in your chosen SmartClient skin (the latter can
// be achieved by passing <code>styleSheets</code> as "skin_styles.css" - the default name for
// the CSS file used in each SmartClient skin).
// <p>
// <code>resizeFonts()</code> must be called after the skin has been loaded, and before any
// components have been created.  Calling <code>resizeFonts()</code> at a later time is not
// supported (you will notice that font sizes still increase, however, this approach is not
// supported).
// <p>
// Some browsers will disallow access or modification of styleSheets if they are loaded from a
// domain that is different from the loading page.  In this case <code>resizeFonts()</code>
// cannot be used.
// <p>
// This method has a small performance penalty which depends on the browser, number of
// stylesheets being modified, and age of your machine.  With modern browsers on modern
// machines resizing just skin fonts, the impact is basically negligible (&lt;5ms).
//
// @param sizeChange (int) size to change fonts by.  Can be negative to shrink fonts
// @param [styleSheets] (String) optional regular expression pattern for matching stylesheets
//
// @visibility external
//<
// "styleSheets" can actually be passed in a few more ways than we document:
//  - a native StyleSheet object or Array of StyleSheets, already retrieved from the DOM
//  - an already-created Regexp object to match against document.styleSheets[i].href
resizeFonts : function (sizeChange, styleSheets) {

    if (styleSheets == null) {
        styleSheets = document.styleSheets;
    } else if (isc.isA.String(styleSheets) || isc.isA.RegularExpression(styleSheets)) {
        var urlPattern = isc.isA.String(styleSheets) ? new RegExp(styleSheets) : styleSheets,
            styleSheets = [];
        for (var i = 0; i < document.styleSheets.length; i++) {
            var sheet = document.styleSheets[i],
                href = sheet.href + ""; // just in case it's not a real String
            if (href && href.match(urlPattern)) styleSheets.add(sheet);
        }
    } else if (!isc.isAn.Array(styleSheets)) {
        styleSheets = [styleSheets];
    }

    // for every loaded stylesheet..
    for (var i = 0; i < styleSheets.length; i++) {
        var rules = this.getStyleRules(styleSheets[i]);
        if (rules == null) continue;

        // first collect all sizes in an array
        var sizes = [];
        for (var j = 0; j < rules.length; j++) {
            var style = rules[j].style;
            if (style == null) continue;

            var fontSize = style.fontSize;
            if (fontSize != null && fontSize.indexOf("px") > 0) {
                sizes.push(parseInt(fontSize));
            }
        }
        // then overwrite with new size
        // doing this as two loops avoids double-applying increase to any styles
        // that appear more than once in the rules array (happens in IE)
        for (var j = 0; j < rules.length; j++) {
            var style = rules[j].style;
            if (style == null) continue;

            var fontSize = style.fontSize;
            if (fontSize != null && fontSize.indexOf("px") > 0) {
                style.fontSize = (sizes.shift() + sizeChange) + "px";
            }
        }
    }

    // for Drawing and FacetChart, font sizes are not in CSS
    this.modifyProperty(isc.DrawLabel, "fontSize", sizeChange);
    this.modifyDefaultsProperty(isc.DrawItem, "titleLabelDefaults", "fontSize", sizeChange);
    var chartLabelProps = [
        "titleProperties", "valueAxisLabelProperties", "dataAxisLabelProperties",
        "gradationLabelProperties", "dataLabelProperties",
        "legendLabelProperties", "hoverLabelProperties",
        "pointSizeLegendLabelProperties","pointSizeLegendTitleLabelProperties",
        "colorScaleLegendLabelProperties","colorScaleLegendTitleLabelProperties"
        ];

    for (var i = 0; i < chartLabelProps.length; i++) {
        this.modifyDefaultsProperty(isc.FacetChart, chartLabelProps[i], "fontSize", sizeChange);
    }

    isc.Canvas._currentFontIncrease = sizeChange;

    this.clearCSSCaches();
},

//> @classMethod Canvas.resizeControls()
// Change the basic size of UI components in the current skin by "delta" pixels.  Must be
// called after the skin has been loaded, but before any components are created.
// <p>
// The size of a text input control implies the size of most other controls:
// <ul>
// <li> all other FormItems (eg selects) need to be the same size or mixed controls will look
//      odd.  This includes Buttons
// <li> anything that potentially contains a FormItem needs to be as tall or slightly taller:
//      this includes grid row (inline editing), +link{window.headerControls,Window headers},
//      TabBar and SectionHeaders
// </ul>
// <p>
// Because of this necessary uniformity, just specifying a single pixel value is enough for the
// framework to resize all core controls, with several caveats:
// <ul>
// <li> skins that make extensive use of images (eg TreeFrog) will stretch those images, which
//      may result in ugly artifacts in some combinations of operating system and browser, for
//      which no workaround is possible.  For this reason, <code>resizeControls()</code> is
//      only officially supported for Enterprise, EnterpriseBlue and Graphite skins, and only in
//      +link{group:skinning,CSS3 Mode}
// <li> even in Enterprise-series skins, +link{treeGrid.showConnectors,tree connector lines}
//      vertically stretch, becoming obviously blurry and misshapen with an increase of 4-5px.
//      To avoid this, replace the tree connector media (see +link{treeGrid.connectorImage}).
// <li> +link{FormItemIcon}s are not resized by default, because stretched icons generally look
//      worse than non-scaled icons that are a bit smaller than the input field
// <li> images that use +link{group:skinning,spriting} will not be stretched because the sizes
//      for these controls are embedded in CSS.  In most cases, this is desirable; for example,
//      the downward chevron shape used for SelectItem controls doesn't stretch, and looks
//      better that way.
// </ul>
//
// @param delta (int) number of pixels to increase or decrease from current size
//
// @visibility external
//<
resizeControls : function (delta) {
    var heightClasses = [
        isc.Button,
        isc.IButton,
        isc.MenuButton,

        isc.FormItem,
        isc.TextItem,
        isc.SelectItem,
        isc.DateItem,
        isc.ComboBoxItem,
        isc.SpinnerItem,
        isc.ButtonItem,
        isc.SectionItem
    ];

    for (var i = 0; i < heightClasses.length; i++) {
        this.modifyProperty(heightClasses[i], delta);
    }

    this.modifyProperty(isc.ListGrid, delta, "cellHeight");
    this.modifyProperty(isc.ListGrid, delta, "headerHeight");
    this.modifyProperty(isc.ListGrid, delta, "filterEditorHeight");
    this.modifyProperty(isc.DetailViewer, delta, "rowHeight");
    this.modifyProperty(isc.Menu, delta, "cellHeight");
    this.modifyProperty(isc.PickListMenu, delta, "normalCellHeight");
    // defined on isc.PickList interface, but ends up copied to implementing classes
    this.modifyProperty(isc.SelectItem, delta, "pickListCellHeight");
    this.modifyProperty(isc.ComboBoxItem, delta, "pickListCellHeight");

    this.modifyProperty(isc.Calendar, delta, "rowHeight");
    this.modifyProperty(isc.Calendar, delta, "eventHeaderHeight");

    this.modifyProperty(isc.TabSet, delta, "tabBarThickness");
    this.modifyProperty(isc.TabBar, delta, "breadth"); // note: doesn't seem necessary given tabBarThickness

    this.modifyProperty(isc.SectionStack, delta, "headerHeight");

    this.modifyDefaultsProperty(isc.PickTreeItem, "buttonDefaults", "height", delta);
    this.modifyDefaultsProperty(isc.Window, "headerDefaults", "height", delta);

    isc.Canvas._currentSizeIncrease = delta;
},


// for any font-family declaration matching facePattern, replace with newFace.
// Really just for trying out new options, not intended to be exposed
changeFontFace : function (facePattern, newFace) {
    if (isc.isA.String(facePattern)) facePattern = new RegExp(facePattern);

    // for every loaded stylesheet..
    for (var i = 0; i < document.styleSheets.length; i++) {
        var rules = this.getStyleRules(document.styleSheets[i]);
        if (rules == null) continue;

        for (var j = 0; j < rules.length; j++) {
            var style = rules[j].style;
            if (style == null) continue;

            var fontFamily = style.fontFamily;
            if (fontFamily != null && fontFamily.match(facePattern)) {
                style.fontFamily = newFace;
            }
        }
    }
},

// Image locations and skinning
// --------------------------------------------------------------------------------------------

//>!BackCompat 2005.2.23
// Removing these setters and getters, as switching images to a different directory on the
// fly is a pointless feature, and getters don't seem necessary.

//> @classMethod Canvas.setAppImgDir()
// Set the default app-specific image directory for all canvases of this type.
// <p>
// Note: this will not cause any instances to redraw, but having them
// redraw will show the new images.
//
// @param URL       (string)    New URL for the app-specific images.
// @group images
//<
setAppImgDir : function (URL) {
    this.getPrototype().appImgDir = URL;
},

//> @classMethod Canvas.getAppImgDir()
// Return the image directory for this class of widgets, prepended with the Page image
// directory.
//
// @group images
// @return (URL)    Image directory (including Page image directory) for this widget.
//<
getAppImgDir : function () {
    return isc.Page.getImgURL(isc.emptyString, this.getPrototype().appImgDir);
},


//> @classMethod Canvas.setSkinImgDir()
// Set the default widget image directory for all canvases of this type.
// <p>
// Note: this will not cause any instances to redraw, but having them
// redraw will show the new images.
//
// @param URL       (string)    New URL for the app-specific images.
// @group images
//<
setSkinImgDir : function (URL) {
    this.getPrototype().skinImgDir = URL;
},

//> @classMethod    Canvas.getSkinImgDir()
// Return the image directory for this class of widgets, prepended with the Page image
// directory.
//
// @group images
// @return (URL)    Image directory (including Page image directory) for this widget.
//<
getSkinImgDir : function () {
    return isc.Page.getSkinImgDir(this.getPrototype().skinImgDir);
},

//<!BackCompat

// --------------------------------------------------------------------------------------------

// see JSDoc for instance method canvas.getImgURL()
_skinPrefix: "[SKIN]",
_$allowRelativeSrc: "{allowRelativeSrc}",
getImgURL : function (src, imgDir, instance) {
    // if no src specified, return empty string
    if (src == null || isc.isAn.emptyString(src)) return isc._emptyString;

    // get skin / app dir settings from the passed-in instance or use this class' instance
    // prototype to get instance defaults.
    instance = instance || this.getPrototype();

    // handle src being specified as an object, of the form:  {src:"URL", imgDir:"URL"}
    if (src.imgDir != null && imgDir == null) imgDir = src.imgDir;
    if (src.src != null) src = src.src;


    var assumeRelativeSrc;
    if (imgDir == this._$allowRelativeSrc) {
        if (isc.Page._isRelativeURL(src)) assumeRelativeSrc = true;
        imgDir = null;
    }

    // default the imgDir as appropriate
    if (imgDir == null) {
        imgDir = (isc.startsWith(src, this._skinPrefix) ? instance.skinImgDir : instance.appImgDir);
    }
    var URL = isc.Page.getImgURL(src, imgDir, assumeRelativeSrc);

    //>DEBUG
    //this.logDebug("getImgURL("+src+","+imgDir+") returned " + URL);
    //<DEBUG
    return URL;
},

//> @classMethod Canvas.setShowCustomScrollbars()
// Whether to use the browser's native scrollbars or SmartClient-based scrollbars by default
// for all canvases.
// <P>
// This method changes the default value of +link{canvas.showCustomScrollbars}.
// @param showCustomScrollbars (boolean) whether to show custom (SmartClient-based) scrollbars
//   rather than css-scrollbars by default.
// @visibility external
//<
// This is just an equivalent to calling isc.Canvas.addProperties({showCustomScrollbars:true});
// Useful to have as a static setter for SGWT.
setShowCustomScrollbars : function (showCS) {
    isc.Canvas.addProperties({showCustomScrollbars:showCS});

},

// Printing
// --------------------------------------------------------

// for printHTML
printOmitControls : [
"Button","StretchImgButton","ImgButton","MenuButton",
"Toolbar","ToolStrip","ButtonItem","ToolbarItem"
],
printIncludeControls : [
"Label"
],

//> @classMethod Canvas.getPrintHTML()
// Returns print-formatted HTML for the specified list of components.
//
// @param components (Array of Canvas) Components to get the print HTML for. Strings of raw HTML may
//  also be included in this array, and will be integrated into the final HTML at the appropriate
//  point.
// @param printProperties (PrintProperties) properties affecting print output
// @param [callback] (callback) Callback to fire when the method completes. The generated print HTML
//  will be passed in as the first parameter <code>HTML</code>.
// @param [separator] (HTML) Optional HTML separator to render between each component's printable HTML
// @return (HTMLString) print HTML for the components passed in. This will be <code>null</code> if
//  a callback parameter was passed into this method, or if the print HTML was generated asynchronously by
//  the component[s].
// @visibility external
//<
// callback is also passed the callback as a second parameter to allow the developer to pass
// state around.
// HTML / index params are used internally - this method calls itself to handle asynchronous HTML
// generation.
getPrintHTML : function (components, printProperties, callback, separator, HTML, index) {

    if (!isc.isAn.Array(components)) components = [components];

    if (HTML == null) HTML = [];
    if (index == null) index = 0;

    var async,

        // If we pass a callback to component-level getPrintHTML() that method
        // will always return null.
        // If we were passed a callback, this is acceptable - we will just return
        // null from this method and app-code can rely on the callback firing to
        // work with the component print HTML
        // If we were not passed a callback, the only way this method is useful is
        // if it actually returns HTML - only passible if we *don't* pass a callback
        // to each component. Of course component getPrintHTML() may truly be asynchronous
        // in which case this method will never return HTML.
        componentCallback = callback == null ? null :
                            {target:this, methodName:"gotComponentPrintHTML",
                             components:components, printProperties:printProperties,
                             callback:callback, HTML:HTML, index:index, separator:separator};


    for (; index < components.length; index++) {
        // if we fire the component level callback - start on the component after it in the list!
        if (componentCallback) componentCallback.index+=1;
        var component = components[index];

        // allow raw HTML strings
        var compHTML;
        if (isc.isA.String(component)) compHTML = component;
        else compHTML = component.getPrintHTML(printProperties, componentCallback);

        if (compHTML != null) {
            HTML.add(compHTML);
        } else {
            async = true;
            break;
        }
    }

    // If no HTML was returned for some component - if we had a callback we'll run again
    // thanks to gotComponentPrintHML()
    if (async) {
        if (!callback) {
            this.logWarn("getPrintHTML(): HTML generated asynchronously, but no callback passed in");
        }
        return null;
    }

    // We'll only get here if
    // - either this is being fired from gotComponentPrintHTML() callback [and we've gone
    //   through all the widgets]
    if (callback) {
        this.fireCallback(callback, "HTML,callback", [HTML.join(separator || isc.emptyString),
                                                      callback]);
        // Return value actually doesn't matter here - we're running from a nested callback
        return null;

    // - or no callback was passed in and HTML was generated synchronously for all components
    } else {
        return HTML.join(separator || isc.emptyString);
    }
},


gotComponentPrintHTML : function (HTML, callback) {
    // If this method is called synchronously, no-op - the HTML will be returned by the
    // component.getPrintHTML() method and so we pick it up directly in the for... loop
    // in this.getPrintHTML()
    if (this._getPrintHTMLRunning) return;

    callback.HTML.add(HTML);
    this.getPrintHTML(callback.components, callback.printProperties, callback.callback,
                      callback.separator, callback.HTML, callback.index);
},


// HTML for Images (and other basic structures)
// --------------------------------------------------------------------------------------------

//> @classMethod Canvas.imgHTML()
//          Return the HTML for an image.
//
//      @group  images
//      @param  src             (SCImgURL)
//      NOTE: instead of passing several parameters, you can pass an object as the 'src'
//      parameter with properties for all the various function parameters with, eg:<br>
//      canvas.imgHTML( {src:"foo", width:10, height:10} );
//      @param  [width]         (number)
//      @param  [height]        (number)
//      @param  [name]          (string)
//      @param  [extraStuff]    (string)
//      @param  [imgDir]        (string)
//
//      @return (string)    configured IMG tag
//<

getImgHTML : function (src, width, height, name, extraStuff, imgDir, activeAreaHTML,
                       instance, returnTemplate, generateSpan) {
    return this.imgHTML(src, width, height, name, extraStuff, imgDir, activeAreaHTML,
                        instance, returnTemplate, generateSpan);
},

_getImgHTMLTemplate : function (src, width, height, name, extraStuff, imgDir, activeAreaHTML, generateSpan) {
    return isc.Canvas.imgHTML(src, width, height, name,
                              extraStuff, imgDir, activeAreaHTML, null, true, generateSpan);
},

// - if "instance" is passed, we into account the instance settings for imgDir and make the IMG
//   ID unique to the instance.
// - if "returnTemplate" is passed, we return an HTML template Array, with a slot open to give
//   a unique ID to the image.  This is a very advanced internal API for generating many images
//   with the same SRC, size and other attributes but with different unique IDs.
_imgMapId : 0,
_$apos:"&apos;",
_imgAlignToVerticalAlignMap: {
    "TEXTTOP": "text-top",
    "texttop": "text-top",
    "absmiddle": "middle"
},

_nullSrcPlaceholder: new String,
imgHTML : function (src, width, height, name, extraStuff, imgDir, activeAreaHTML,
                    instance, returnTemplate, generateSpan) {

    var align,
        extraCSSText;
    // if an object is passed in for SRC, assume that it's a properties object
    //  and normalize it into the arguments of the function
    if (isc.isAn.Object(src)) {
        if (src.width != null)          width = src.width;
        if (src.height != null)         height = src.height;
        if (src.name != null)           name = src.name;
        if (src.extraStuff != null)     extraStuff = src.extraStuff;
        if (src.imgDir != null)         imgDir = src.imgDir;
        if (src.align != null)          align = src.align;
        if (src.activeAreaHTML != null)    activeAreaHTML = src.activeAreaHTML;
        if (src.generateSpan != null)   generateSpan = src.generateSpan;
        if (src.extraCSSText != null)   extraCSSText = src.extraCSSText;
        src = src.src;
    }

    if (src === this._nullSrcPlaceholder) {
        src = null;
    } else if (src == null || isc.isAn.emptyString(src)) {
        return (returnTemplate ? [isc._emptyString] : isc._emptyString);
    }

    // once ever setup
    var template = this._imgTemplate;
    if (!template) {
        this._imgSrc = "<img src='";
        this._widthEquals = "' width='";
        this._heightEquals = "' height='";
        this._alignEquals = "' align='";
        this._styleEquals = "' style='";
        this._idEquals = "' id='";
        this._nameEquals = "' name='";
        this._closeQuote = "' ";
        // NOTE: Opera converts TEXTTOP to "bottom" when retrieved from the DOM, and align is
        // way off.  "middle" seems close to what "TEXTTOP" used to mean
        // Further note: Later versions of Opera (observed in 12.01) do not treat "middle"
        // like TEXTTOP - "top" gives a better result (and also works in older Opera versions)
        this._textTop = isc.Browser.isOpera ? "top" : "TEXTTOP";
        this._endString = " border='0' suppress='TRUE'" +

                          " draggable='true'/>";
        this._imgTemplate = template = [this._imgSrc];



        this._alphaFilterStart =
           "' style='filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"";
        this._alphaFilterEnd = "\",sizingMethod=\"scale\");";



        this._spanSimpleStart = "<span style='display:inline-block";
        this._spanSimpleStartFixARIA = "<span role='presentation'" + (isc.Browser.isIE ? " unselectable='on'" : "") + " style='display:inline-block";
        this._spanStart = "<span style='display:inline-block;background-size:100% 100%;background-image:url(\"";
        this._spanStartFixPNG = "<span style='display:inline-block;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"";
        this._spanStartFixARIA = "<span role='presentation'" + (isc.Browser.isIE ? " unselectable='on'" : "") + " style='display:inline-block;background-size:100% 100%;background-image:url(\"";
        this._spanStartFixARIAFixPNG = "<span role='presentation'" + (isc.Browser.isIE ? " unselectable='on'" : "") + " style='display:inline-block;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"";
        this._widthColon = ";width:";
        this._endURLWidthColon = "\");width:";
        this._endURL = "\")";
        this._endFixPNGWidthColon = "\",sizingMethod=\"scale\");width:";
        this._endFixPNG = "\",sizingMethod=\"scale\")";
        this._pxHeightColon = "px;height:";
        this._heightColon = ";height:";
        this._pxVerticalAlignColon = "px;vertical-align:";
        this._verticalAlignColon = ";vertical-align:";

        this._endSpanString = " ></span>";
    }
    // default align to texttop (this._textTop defined above)
    if (align == null) align = this._textTop;

    if (instance != null && instance.isPrinting) generateSpan = false;


    if (!this._blankURL) this._blankURL = this.getImgURL("[SKIN]/blank.gif");

    //>DEBUG
    if (isc.Browser.isSafari && (width > 32000 || height > 32000)) {
        this.logWarn("Attempting to draw an image of size " + width + " x " + height +
                    ".  Images larger than 32000 pixels in either direction are not reliably " +
                    " rendered in this browser.");
    } //<DEBUG

    // if we're being asked to return a template, allocate a fresh one that the caller can hang
    // onto
    if (returnTemplate) template = [this._imgSrc];

    // fill out the template.  NOTE: if the numbering changes here, all callers to
    // _getImgHTMLTemplate() need to be updated.
    // [0] "<img src='"
    // [1] URL
    // [2] [unused]
    // [3-5] IE filtering
    // [6] "' width="
    // [7] width
    // [8] "' height="
    // [9] height
    // [10] "' align="
    // [11] align
    // [12] "' style='"
    // [13] extraCSSText
    // [14] "' name="
    // [15] canvas ID
    // [16] name
    // [17] "' usemap='" + mapName
    // [18] "' "
    // [19] extraStuff
    // [20] endString
    // [21] (optional) "<map name='.....></map>"
    // in XHTML mode

    var URL,
        fixPNG;
    if (src == null && generateSpan) {
        URL = null;
        fixPNG = false;
    } else {
        if (src == null) src = this._blankURL;

        URL = this.getImgURL(src, imgDir, instance);
        if (isc.Page.isXHTML()) {
            URL = isc.makeXMLSafeAttribute(URL);
        } else {
            URL = URL.replace(this._$singleQuote, this._$apos);
        }

        fixPNG = this._fixPNG(instance) && this._isPNG(src);
        if (fixPNG) {

            if (width == null) width = 16;
            if (height == null) height = 16;
        }
    }

    var fixARIA = (isc.screenReader &&
                   (extraStuff == null ||
                    (!isc.contains(extraStuff, "alt=") && !isc.contains(extraStuff, "aria-label"))));

    if (generateSpan) {
        if (src == null) {
            template[0] = fixARIA ? this._spanSimpleStartFixARIA : this._spanSimpleStart;
            template[1] = null;
            if (width) {
                template[6] = this._widthColon;
                template[7] = width;
            }
        } else {

            if (fixARIA) {
                template[0] = fixPNG ? this._spanStartFixARIAFixPNG : this._spanStartFixARIA;
            } else {
                template[0] = fixPNG ? this._spanStartFixPNG : this._spanStart;
            }
            template[1] = URL;
            if (width) {
                template[6] = fixPNG ? this._endFixPNGWidthColon : this._endURLWidthColon;
                template[7] = width;
            } else {
                template[6] = fixPNG ? this._endFixPNG : this._endURL;
            }
        }
        if (height) {
            template[8] = width ? this._pxHeightColon : this._heightColon;
            template[9] = height;
        }
        template[10] = (isc.isA.Number(height) && height ? this._pxVerticalAlignColon : this._verticalAlignColon);

        if (this._imgAlignToVerticalAlignMap.hasOwnProperty(align)) {
            align = this._imgAlignToVerticalAlignMap[align];
        }
        template[11] = align;

        if (extraCSSText != null) {
            template[12] = isc.semi;
            template[13] = extraCSSText;
        }

        template[20] = this._endSpanString;
    } else {

        if (fixARIA) {

            template[0] = "<img role='presentation' src='";
        } else {
            template[0] = this._imgSrc;
        }
        if (!fixPNG) {
            template[1] = URL;
        } else {

            template[1] = this._blankURL;
            template[3] = this._alphaFilterStart;
            template[4] = URL;
            template[5] = this._alphaFilterEnd;
        }

        if (width) {
            template[6] = this._widthEquals;
            template[7] = width;
        }
        if (height) {
            template[8] = this._heightEquals;
            template[9] = height;
        }

        template[10] = this._alignEquals;
        template[11] = align;

        if (extraCSSText != null) {
            template[12] = this._styleEquals;
            template[13] = extraCSSText;
        }

        template[20] = this._endString;
    }

    if (name) {
        template[14] = isc.Page.isXHTML() || generateSpan ? this._idEquals : this._nameEquals;
        // make the name unique to the target instance if passed one
        if (instance) template[15] = instance.getCanvasName();
        template[16] = name;
    }
    // img map support
    var mapName;
    if (activeAreaHTML) {
        mapName = "ISC_IMGMAP_" + this._imgMapId++;
        template[17] = "' usemap='#" + mapName;
    }
    template[18] = this._closeQuote;

    if (extraStuff) {

        template[19] = extraStuff;
    }

    if (activeAreaHTML) {
        template[21] = "<map name='" + mapName + "'>" + activeAreaHTML + "</map>";
    }

    if (returnTemplate) return template;

    // otherwise return the HTML and truncate the template
    var output = template.join(isc._emptyString);
    template.length = 3;
    return output;
},


// Value Icon HTML generation
// Generates the <img ...> tag HTML used by ListGrids and DynamicForm items for their 'valueIcons'

_$IDEquals:"ID='",
_$singleQuote:"'",
_$absmiddle:"absmiddle",
_$valueIconExtraStuffTemplate: [
    ,                                                   // [0] ID=', or null
    ,                                                   // [1] ID, or null
    ,                                                   // [2] ', or null
    " eventpart='valueicon' ",                          // [3]
    null                                                // [4] extraExtraStuff
],
_$marginLeftColon: "margin-left:",
_$pxMarginRightColon: "px;margin-right:",
_valueIconObj: {},
_getValueIconHTML : function (src, prefix, width, height, leftPad, rightPad, ID, instance, extraExtraStuff, extraCSSText) {

    // Apply ID and custom styling to the image through the 'extraStuff' parameter
    var extraStuffTemplate = this._$valueIconExtraStuffTemplate;
    if (ID != null) {
        extraStuffTemplate[0] = this._$IDEquals;
        extraStuffTemplate[1] = ID;
        extraStuffTemplate[2] = this._$singleQuote;
    } else {
        extraStuffTemplate[0] = extraStuffTemplate[1] = extraStuffTemplate[2] = null;
    }

    extraStuffTemplate[4] = extraExtraStuff;

    var iconObj = this._valueIconObj;
    iconObj.src = src === this._nullSrcPlaceholder ? this._nullSrcPlaceholder : isc.Canvas.getImgURL(src, prefix, instance);
    iconObj.width = width
    iconObj.height = height
    // We want the valueIcon to be center-aligned with adjacent text
    // (either the form item's textBox text, or a listGrid cell's text)
    // We do this by setting align='absMiddle', and vertical-align = middle

    if (height != null && height < 16 &&
        (isc.Browser.isMoz || isc.Browser.isSafari ||
         (isc.Browser.isIE && (isc.Browser.isIE9 || isc.Browser.version >= 10))))
    {
        iconObj.align = null;
    } else {
        iconObj.align = this._$absmiddle; // prevent default "text-top"
    }
    iconObj.imgDir = prefix;
    iconObj.extraStuff = extraStuffTemplate.join(isc.emptyString);
    iconObj.extraCSSText = this._$marginLeftColon + (leftPad || 0) +
                           this._$pxMarginRightColon + (rightPad || 0) + isc.px;
    if (extraCSSText != null) iconObj.extraCSSText += ";" + extraCSSText;
    // The width and height passed to _getValueIconHTML() frequently differs from the image's
    // intrinsic width and height. Before writing out a `span' instead of an `img', make sure
    // that the `background-size:100% 100%' that we would write out will have an effect in this
    // browser.
    iconObj.generateSpan = ((instance == null || !instance.isPrinting) &&
                            this._generateSpanForBlankImgHTML &&
                            isc.Browser._supportsBackgroundSize);

    return isc.Canvas.imgHTML(iconObj);
},

// NOTE: Whether to apply IE5.5+ PNG alpha transparency workaround.
// IE7 natively supports PNG transparency, however if you also set opacity via the
// Microsoft.Alpha filter, PNG transparency breaks.
// This is visible with fade animations, and with transparent hovers with dropShadows (since
// the shadows, which are peers, get the master's transparency),
// This is obliquely mentioned in the blog where PNG transparency support was first announced:
// - http://blogs.msdn.com/ie/archive/2005/04/26/412263.aspx
// Getting rid of filters greatly reduces browserDoneDrawing() time, so it might be a
// worthwhile optimization to special case certain PNG-heavy widgets, like so:
//  - in _fixPNG(), allow an instance flag that avoids using filter hacks for PNG transparency so
//    long as opacity is not set
//  - set this flag for DropShadow only
//  - in setOpacity() override on DropShadow, redraw() to cause filters to be used
//  - NOTE: in order to generalize this to all Canvii or even all EdgedCanvas, would need
//    parent->child opacityChange notifications since setOpacity can be called on a parent.
//
// - Update: 6/15/2007 IE 7.0.5730.11
// IE7 has blurriness at PNG edge on a PNG *without* filters if a filter is used elsewhere on
// the page.  An example is here:
//   http://www.atalasoft.com/cs/blogs/davidcilley/archive/2007/03/14/ie7-dximagetransform-and-png-transparency-problem.aspx
// For single pixel tiled PNGs, which SmartClient uses extensively for the center segment of
// buttons and for the "rails" on rounded corners, this blur translates to what looks like
// a fade effect on the stretched image.
// Note that this effect is avoided for a PNG that has no alpha channel at all, which is a
// distinct file format from a PNG with an alpha channel with 100% opacity.  In many cases the
// alpha channel could be removed, but not for, eg, tintable SectionHeaders.
//
// This basically means it's impossible to avoid using the AlphaImageLoader workaround for PNGs
// unless we *both* do not use any IE filters within the framework *and* insist that all
// developers who use SmartClient also do not use IE filters
//
// IE 8 (version 8.0.6001.18702) tested  6 Aug 09:
// The issue with other filters causing stretch pngs to "fade" has been resolved.
// However the underlying issue where if you also set opacity via the
// Microsoft.Alpha filter, PNG transparency breaks still occurs.
// Note that we can't just apply this workaround where opacity is specified on a widget since we'd
// also have to check up the parentElement chain to the topmost widget to be sure none of them had
// a specified transparancy != 100.
// Note: still no support for setting handle.style.opacity directly in IE8
//
// Note that we now disable filters by default as part of skinning (by setting
// neverUseFilters), which causes us to avoid this workaround in most cases.
//
// IE9 (running in IE9 mode / HTML5 doctype) renders this workaround obsolete in all cases
// as far as we know.
_fixPNG : function (instance) {
    // if we're explicitly not using the png fix, return false immediately.
    if (this.usePNGFix == false) return false;
    var fix = isc.Browser.isIE && isc.Browser.minorVersion >= 5.5 &&
              !isc.Browser.isIE9 &&
//                (isc.Browser.version < 7 || this.opacity == null) &&
                isc.Browser.isWin &&
                (!isc.Canvas.neverUseFilters && this.neverUsePNGWorkaround != true);
    // if we have an instance with _fixPNG returning false, respect it
    if (fix && instance && instance._fixPNG && !instance._fixPNG()) {
        fix = false;
    }
    return fix;
},

_$pngSuffixes:{
png:true, PNG:true, Png:true

},
_isPNG : function (src) {
    return (src && this._$pngSuffixes[src.substring(src.lastIndexOf(isc.dot) + 1)]);
},

_setImageURL : function (element, src, imgDir, instance) {
    // apply the new URL
    var style = element.style,
        isSpan = element.tagName === "SPAN",
        URL,
        fixPNG;
    if (src === this._nullSrcPlaceholder && isSpan) {
        URL = null;
        fixPNG = false;
    } else {
        if (src === this._nullSrcPlaceholder) src = this._blankURL;
        URL = this.getImgURL(src, imgDir, instance);
        fixPNG = this._fixPNG(instance) && this._isPNG(src);
    }
    if (fixPNG) {
        style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"" + URL + "\",sizingMethod=\"scale\")";
        if (!isSpan) element.src = this._blankURL;
    } else {
        if (isSpan) {
            if (src === this._nullSrcPlaceholder || !src) {
                style.backgroundSize = isc._emptyString;
                style.backgroundImage = isc._emptyString;
            } else {
                style.backgroundImage = "url(\"" + URL + "\")";
            }
        } else {
            style.filter = isc._emptyString;
            element.src = URL;
        }
    }
},

//> @classMethod Canvas.linkHTML()
// Returns the HTML for a standard link (anchor) element.
// @param href (string) target url for the link.
// @param [text] (HTMLString) HTML to display in the link element - if null, use the href
// @param [target] (string) target window for the link - defaults to "_blank"
// @param [ID] (string) optional ID for the link element
// @param [tabIndex] (number) optional tabIndex for the link
// @param [accessKey] (string) optional accessKey for the link
// @return (HTMLString) HTML for the link
// @visibility internal
//<
// @param extraStuff - allows you to add freeform attributes into the tag)

_$linkHTMLTemplate:[
    "<a",       // 0
    ,           // 1: (ID ? " ID='" + ID + "'" : ""),
    " href='",  // 2
    ,           // 3: href
    "' target='", // 4
    ,           // 5: target
    "'",        // 6
    ,           // 7: tabIndex = tabIndex or null
    ,           // 8: accessKey = accessKey or null
    ,           // 9: extraStuff
    ">",        // 10
    ,           // 11 text of the link
    "</a>"
],
linkHTML : function (href, text, target, ID, tabIndex, accessKey, extraStuff) {

    if (text == null) {
        text = (!href ? isc.nbsp : String(href).asHTML());
    }

    var template = this._$linkHTMLTemplate;

    if (ID != null) template[1] = " ID='" + ID + "'";
    else template[1] = null;

    template[3] = String.asAttValue(href);
    template[5] = (target ? String.asAttValue(target) : "_blank");

   if (tabIndex != null) template[7] = " tabIndex=" + tabIndex;
   else template[7] = null;

   if (accessKey != null) template[8] = " accessKey='" + accessKey + "'";
   else template[8] = null;

   if (extraStuff) template[9] = " " + extraStuff;

   template[11] = text;
   return template.join(isc.emptyString);
},




//> @classMethod    Canvas.blankImgHTML()
//          Return the HTML for a blank image, such as would be used for a spacer.
//      @group  utils
//
//      @param  [width]         (number)
//      @param  [height]        (number)
//
//      @return (string)    configured IMG tag
//<

_blankImgURL : isc.Browser.isMobileSafari ? "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
                                          : "[SKINIMG]/blank.gif",
_$zero:"0",

_generateSpanForBlankImgHTML: !isc.Browser.isIE || isc.Browser.version >= 9,
blankImgHTML : function (width, height) {

    // In some cases, `height' is not a number (e.g. "auto").
    if (!isc.isA.Number(height)) {
        return isc.Canvas.imgHTML(this._blankImgURL, width, height, null, null, null, null,
                                  null, false, this._generateSpanForBlankImgHTML);
    }

    var template = this._blankTemplate;
    if (!template) {


        template = this._blankTemplate =
            this._getImgHTMLTemplate(this._blankImgURL, 1, 1, null, null, null, null,
                                     this._generateSpanForBlankImgHTML);
    }
    template[7] = width || this._$zero;
    template[9] = height || this._$zero;
    return template.join(isc._emptyString);
},

//> @classMethod    Canvas.spacerHTML()
//      Return the HTML for a blank spacer at a particular width and height.
//      Does this without using images so it should be really fast.
//
//      @group  utils
//
//      @param  [width]         (number)
//      @param  [height]        (number)
//
//      @return (string)    HTML for the spacer
//<
spacerHTML : function (width, height, contents) {
    // shortcut: if the size is 0x0, return an empty string
    if (width == 0 && height == 0) return isc._emptyString;


    if (isc.Browser.isMoz ||
        isc.Browser.isSafari ||
        isc.Browser.isOpera ||
        isc.Browser.isStrict ||
        (isc.Browser.isIE && (isc.Browser.version >= 10 ||
                              (height < 3 && (isc.Browser.minorVersion == 5.5 || isc.Browser.isMac)))))
    {

        var threshold;
        if (isc.Browser.isSafari) {
            threshold = 32000;
        } else if (isc.Browser.isFirefox && isc.Browser.geckoVersion >= 20090219) {
            threshold = 17895580;
        } else if (isc.Browser.isIE && isc.Browser.isStrict) {
            threshold = 16000;
        }

        if (threshold != null && (width > threshold || height > threshold)) {
            var output = isc.SB.create(),
                max = threshold,
                // note - numRows / cols will be one less than is required
                numRows = Math.floor(height / max),
                numCols = Math.floor(width / max);

            output.append("<TABLE role='presentation' CELLPADDING=0 CELLSPACING=0 BORDER=0 MARGIN=0>");
            for (var i = 0; i <= numRows; i++) {
                output.append("<TR>");
                for (var j = 0; j <= numCols; j++) {

                    output.append("<TD>");
                    // write cells down leading diagonal, or along first row / col if we've
                    // already writen out all the cells we need on the other axis
                    var writeSpacer =
                        ((i == j) || (i > numCols && j == 0) || (j > numRows && i == 0));

                    if (writeSpacer) {
                        var cellSpacerHeight = (i < numRows ? max : height - (i*max)),
                            cellSpacerWidth = (j < numCols ? max : width - (j*max));

                        output.append(this.blankImgHTML(cellSpacerWidth, cellSpacerHeight));
                    }
                    output.append("</TD>");
                }
                output.append("</TR>");
            }
            output.append("</TABLE>");
            return output.release(false);
        }
        return this.blankImgHTML(width,height);
    }

    // in IE8 non-strict mode a limit has been hit whereby spans exceeding ~140,000px in height
    // start misreporting their heights.
    // Simply stacking them one after another using <br> tags to break them up resolves this
    // (tested up to 14,000,000px)
    var vThreshold = 1300000;
    if (height > vThreshold) {
        var spacerStrings = [];
        var cumulativeHeight = 0;
        while (cumulativeHeight < height) {

            var lastRow, blockHeight;
            if (cumulativeHeight + 1400 >= height) {
                lastRow = true;
                blockHeight = height-cumulativeHeight;
            } else {
                blockHeight = 1400;
                lastRow = false;
            }
            spacerStrings[spacerStrings.length] = this.spacerHTML(width,blockHeight);
            spacerStrings[spacerStrings.length] = "<br>";

            cumulativeHeight += blockHeight;

        }
        return spacerStrings.join(isc._emptyString);
    }


    // return HTML that the browser recognizes as taking up space.
    var spacerHTML = this._spacerHTMLTemplate;
    if (spacerHTML == null) {
        spacerHTML = this._spacerHTMLTemplate = [
            "<SPAN STYLE='WIDTH:",
            null, // width
            "px;HEIGHT:",
            null, // height
            null, // height units
            ";overflow:hidden'>",
            null, // contents
            "</SPAN>"
        ];
    }
    spacerHTML[1] = width;
    spacerHTML[3] = height;
    spacerHTML[4] = isc.isA.Number(height) ? isc.px : null;
    spacerHTML[6] = contents ? contents : isc.nbsp;
    return spacerHTML.join(isc._emptyString);
},

//> @classMethod canvas.hiliteCharacter()   (A)
//          Given a string and a character, hilite the first occurrence of the character in the
//          string (if it occurs), preferring uppercase to lowercase.
//
//      @group  utils
//
//      @param  string      (string)    String to return with hilited character
//      @param  character   (character) Character to hilite
//      @param  [hilitePrefix] (string) Prefix to apply to hilighted character - defaults to
//                                      "&lt;span style='text-decoration:underline;'&gt;"
//      @param  [hiliteSuffix]  (string)    Suffix to apply to hilited character - defaults to
//                                          "&lt;/span&gt;"
//
//      @return (string)    The string passed in, with the first occurrence of the hilite
//                          character enclosed by the 'hilitePrefix' and 'hiliteSuffix'
// @visibility external
//<
// This is used by form items, and stretchImgButtons to hilite their accessKey
hiliteCharacter : function (string, character, hilitePrefix, hiliteSuffix) {

    if (!isc.isA.String(string) || !isc.isA.String(character) || character.length != 1)
        return string;

    // Bail if they're attempting to hilight a space character - it will look weird!

    if (character == " ") return string;

    // Default the hilite prefix and suffix if necesary (note - we don't support being passed
    // just one of these arguments)
    if (hilitePrefix == null || hiliteSuffix == null) {
        hilitePrefix = "<span style='text-decoration:underline;'>";
        hiliteSuffix = "</span>"
    }

    var index = string.indexOf(character.toUpperCase());
    if (index == -1) index = string.indexOf(character.toLowerCase());

    if (index != -1) {
        var start = string.slice(0, index),
            hiliteString = string.slice(index, index+1),
            end = string.slice(index+1);

        hiliteString = hilitePrefix+hiliteString+hiliteSuffix;
        string = start.concat(hiliteString, end);
    }

    return string;
},

// Redraw Queue
// --------------------------------------------------------------------------------------------

//> @classMethod    Canvas.scheduleRedraw() (A)
//          Add a canvas that needs to be redrawn to the redrawQueue so it will be redrawn
//          automatically.  Called by Canvas.markForRedraw()
//      @group  draw
//
//      @param  canvas      (Canvas)        Canvas to be redrawn
//<
_$clearRedrawQueue:"clearRedrawQueue",
scheduleRedraw : function (canvas) {
    //this.logWarn("Scheduled redraw of: " + canvas + this.getStackTrace());

    // add the canvas to the list of canvases to be redrawn
    if (canvas && canvas.priorityRedraw) {
        this._redrawQueue.addAt(canvas, 0);
    } else {
        this._redrawQueue.add(canvas);
    }
    // and start the timer to redraw the objects in the queue
    if (!this._redrawTimer) {
        this._redrawTimer =
            isc.Timer.setTimeout({target:isc.Canvas, methodName:this._$clearRedrawQueue}, this._redrawQueueDelay);
    }
},

//> @classMethod    Canvas.clearRedrawQueue()   (A)
//      Redraw all the canvases that are currently waiting on a redraw
//      @group  draw
//<
clearRedrawQueue : function () {
    // don't show a new thread if we're being called from a timer
    var inThread = (isc.EH._thread != null && isc.EH._thread.contains("TMR"));
    if (!inThread) isc.EH._setThread("RDQ");

    //>DEBUG
    var start = isc.timeStamp();
    //<DEBUG

    // set the timer to null so that a new timer can be started if further redraws are scheduled.
    // We don't have to clearTimeout because the timeout already fired.
    this._redrawTimer = null;

    // get the list of items to be redrawn
    var list = this._redrawQueue;
    // create a new list for additional redraws (some of which may be triggered by the redraws
    // we do now!)
    this._redrawQueue = [];

    //>DEBUG
    if (this.logIsDebugEnabled()) {
        var redrawList = "";
        for (var i = 0; i < list.length; i++) {
            redrawList += list[i];
            if (i != list.length - 1) redrawList += ", ";
        }
        this.logDebug("clearRedrawQueue: " + redrawList, "drawing");
    }
    //<DEBUG

    // priorityRedraw: these items need to repaint as soon as possible, so postpone any other
    // redraws, to allow the browser to repaint the screen.
    var item, priorityList;
    for (var i = 0; i < list.length; i++) {
        item = list[i];
        if (item && item.priorityRedraw) {
            item.priorityRedraw = false; // clear the flag (it applies for one redraw only)
            if (priorityList == null) priorityList = [];
            priorityList.add(item);
            list[i] = null;
        }
    }
    if (priorityList != null) {
        //>DEBUG
        this.logInfo("Priority redraw: postponing non-priority items", "drawing");
        //<DEBUG
        this._redrawQueue = list;
        this.scheduleRedraw(list[0]); // HACK kick off the timer
        list = priorityList;
    }

    // now redraw each item in the list
    var redraws = 0, item;
    for (var i = 0; i < list.length; i++) {
        item = list[i];
        // ignore items that were destroyed right after being marked for redraw
        if (item == null || item.destroyed) continue;
        // avoid redrawing if an item has already been redrawn
        if (item && item.isDirty()) {
            // redraw the item
            item.redraw(false);
            redraws++;
        }
    }
    //>DEBUG
    if (this.logIsDebugEnabled("redraws")) {
        this.logDebug("clearRedrawQueue: " + redraws + " redraws (" + list.length + " items), " +
                      (isc.timeStamp() - start) + "ms"
                      //+ " queue was: " + list
                      , "redraws");
    }
    //<DEBUG
    if (!inThread) isc.EH._clearThread();
},




// Delayed adjustOverflows
// --------------------------------------------------------------------------------------------
// Add a canvas to the queue to have overflow adjusted after a delay, and set timer running (if
// necessary)
// See comments in 'adjustOverflow()' for description of why this function is used.
_queueForDelayedAdjustOverflow : function (canvasID) {
    if (!isc.Canvas._delayedAdjustOverflowQueue) isc.Canvas._delayedAdjustOverflowQueue = [];
    isc.Canvas._delayedAdjustOverflowQueue.add(canvasID);

    if (!isc.Canvas._delayedAdjustTimer) {
        isc.Canvas._delayedAdjustTimer =
            isc.Timer.setTimeout({target:isc.Canvas, methodName:"_clearDelayedAdjustOverflowQueue"},
                                 isc.Canvas._delayedAdjustOverflowQueueDelay)
    }

},

// Adjust overflows of all the canvii in the 'delayedAdjustOverflowQueue'
_clearDelayedAdjustOverflowQueue : function () {
    var array = isc.Canvas._delayedAdjustOverflowQueue;

    // clear the queue and the timer pointer
    isc.Canvas._delayedAdjustOverflowQueue = [];
    isc.Canvas._delayedAdjustTimer = null;

    if (!array || array.length == 0) return;

    for (var i = 0; i < array.length; i++) {
        // call adjustOverflow on each widget in the queue.
        // Note - if the Canvas still can't successfully adjustOverflow(), that method will
        // re-queue the widget for delayed adjustOverflow().
        var canvas = window[array[i]];
        if (isc.isA.Canvas(canvas)) canvas.adjustOverflow("delayed");
    }

},

// Check for browser size change
checkForPageResize : function () {
    // Pass the "polling" argument into _pageResize. This indicates the method wasn't called by
    // an actual browser resize event and will cause it to no-op if appropriate.
    isc.EH._pageResize(true);
},


// Move a canvas offscreen (used by Layout for pre-drawing to determine overflowed sizes)
moveOffscreen : function (member) {
    if (member.isDrawn()) return;

    var moveOffscreen = (!(!isc.Browser.isWin && isc.Browser.isMoz &&
                           member.showCustomScrollbars == false &&
                           (member.overflow == isc.Canvas.AUTO)));

    if (moveOffscreen) member.moveTo(null, -9999);
},

// --------------------------------------------------------------------------------------------


//> @classMethod    Canvas.scheduleDestroy()    (A)
//          Add a canvas that needs to be destroyed to the destroyQueue so it will be destroyed
//          automatically.  Called by Canvas.markForDestroy()
//      @group  draw
//
//      @param  canvas      (Canvas)        Canvas to be destroyed
//<
_destroyQueue:[],
_destroyQueueDelay:0,
_$clearDestroyQueue:"clearDestroyQueue",
scheduleDestroy : function (canvas) {

    if (!canvas || canvas.destroyed || canvas.destroying || !canvas.destroy) return;

    this._destroyQueue.add(canvas);

    // and start the timer to destroy the objects in the queue
    if (!this._destroyTimer) {
        this._destroyTimer =
            isc.Timer.setTimeout({target:isc.Canvas, methodName:this._$clearDestroyQueue}, this._destroyQueueDelay);
    }
},

//> @classMethod    Canvas.clearDestroyQueue()  (A)
//      Destroy all the canvases that are currently waiting on a destroy()
//      @group  draw
//<
clearDestroyQueue : function () {
    isc.EH._setThread("DSQ");

    //>DEBUG
    var start = isc.timeStamp();
    //<DEBUG

    // set the timer to null so that a new timer can be started if further destroys are scheduled.
    // We don't have to clearTimeout because the timeout already fired.
    this._destroyTimer = null;

    // get the list of items to be destroyed
    var list = this._destroyQueue;

    // create a new list for additional destroys
    this._destroyQueue = [];

    //>DEBUG
    if (this.logIsDebugEnabled("destroys")) {
        var destroyList = "";
        for (var i = 0; i < list.length; i++) {
            destroyList += list[i];
            if (i != list.length - 1) destroyList += ", ";
        }
        this.logDebug("clearDestroyQueue: " + destroyList, "destroys");
    }
    //<DEBUG

    // destroy each item in the list
    var destroys = 0, item;
    for (var i = 0; i < list.length; i++) {
        item = list[i];
        // ignore items that are already destroyed
        if (item == null || item.destroyed || item.destroying) continue;
        item.destroy(false);
        destroys++;
    }
    //>DEBUG
    if (this.logIsDebugEnabled("destroys")) {
        // this statistic may be misleading since we may include children or peers of items already
        // in the list, in which case they'll be destroyed, but the count won't be incremented
        this.logDebug("clearDestroyQueue: " + destroys + " direct destroy() calls (" + list.length + " items), " +
                      (isc.timeStamp() - start) + "ms"
                      //+ " queue was: " + list
                      , "destroys");
    }
    //<DEBUG
    isc.EH._clearThread();
},



// helper method used to outset or inset a canvas by a certain number of pixels.
outsetRect : function (rect, outset) {
    if (!outset) return rect;

    // rect can be like the output of Canvas.getRect()
    if (isc.isAn.Array(rect)) {
        rect[0] -= outset;
        rect[1] -= outset;
        rect[2] += 2*outset;
        rect[3] += 2*outset;
        return rect;
    }
    // or rect can be a properties block
    rect.left -= outset;
    rect.top -= outset;
    rect.width += 2*outset;
    rect.height += 2*outset;
    return rect;
},

// helper: returns true if rect1 and rect2 intersect, false othewise
rectsIntersect : function (rect1, rect2) {
    var left1 = rect1[0],
        top1 = rect1[1],
        width1 = rect1[2],
        height1 = rect1[3],

        left2 = rect2[0],
        top2 = rect2[1],
        width2 = rect2[2],
        height2 = rect2[3],

        horizontal = ((left1 > left2 + width2 - 1) || (left1 + width1 - 1 < left2)),
        vertical = ((top1 > top2 + height2 - 1) || (top1 + height1 - 1 < top2))
    ;

    return !horizontal && !vertical;
},

//helper: returns true if rect1 encloses rect2, false othewise
rectEnclosesRect : function (rect1, rect2) {
    var left1 = rect1[0],
        top1 = rect1[1],
        width1 = rect1[2],
        height1 = rect1[3],

        left2 = rect2[0],
        top2 = rect2[1],
        width2 = rect2[2],
        height2 = rect2[3],

        horizontal = ((left1 <= left2) && (left1 + width1 >= left2 + width2)),
        vertical = ((top1 <= top2) && (top1 + height1 >= top2 + height2))
    ;

    return horizontal && vertical;
},


_forceNativeTabOrderUpdate : function () {
    if (!this.__tabIndexRefreshDiv) {
        this.ns.Element.createAbsoluteElement(
            "<DIV ID='_isc_tabIndexRefreshDiv'" +
            " style='position:absolute;left:0px;top:-100px'>&nbsp;</DIV>");
        this.__tabIndexRefreshDiv = document.all["_isc_tabIndexRefreshDiv"];
    } else {
        this.__tabIndexRefreshDiv.innerHTML = "&nbsp;"
    }
},

// maintain a list of top level canvii - this simplifies iterating through all the canvii
// in the same parent as a widget (commonly required for zIndices)
_topCanvii : [],
_addToTopLevelCanvasList : function (canvas) {
    if (!isc.isA.Canvas(canvas) || canvas._topCanviiIndex != null) return;

    this._topCanvii.add(canvas);
    canvas._topCanviiIndex = this._topCanvii.length - 1;
},

_removeFromTopLevelCanvasList : function (canvas) {
    if (!isc.isA.Canvas(canvas) || canvas._topCanviiIndex == null) return;

    this._topCanvii[canvas._topCanviiIndex] = null;
    canvas._topCanviiIndex = null;
},

// Checks whether a given canvas is above all other top-level canvases that are drawn and visible.

_isInFront : function (canvas) {
    while (canvas.parentElement != null) canvas = canvas.parentElement;

    var canvasZIndex = canvas.getZIndex(true),
        topCanvii = this._topCanvii;
    for (var i = 0, len = topCanvii.length; i < len; ++i) {
        var otherCanvas = topCanvii[i];
        if (otherCanvas != null &&
            otherCanvas.isDrawn() &&
            otherCanvas.isVisible() &&
            otherCanvas.getZIndex(true) > canvasZIndex)
        {
            return false;
        }
    }
    return true;
},



// -----------------
// RTL adjustments


_adjustScrollLeftForRTL : function (left, scrollWidth, viewportWidth,
    zeroToNegativeOrigin, adjustForNegativeOrigin, adjustForInverseOrigin)
{
    if (adjustForNegativeOrigin) {
        var offset = scrollWidth - viewportWidth;
        // offset is a positive value since the scrollWidth exceeds viewport with
        // (for scrollLeft to have any meaning!).
        // To go from zero based coords to negative origin coords we need to reduce
        // by the offset.
        // To go from negative origin coords to zero based coords we need to
        // increase by the offset.
        if (zeroToNegativeOrigin) left -= offset;
        else left += offset

    } else if (adjustForInverseOrigin) {
        var maxScroll = scrollWidth - viewportWidth;

        if (maxScroll > 0 && maxScroll >= left) {
            left = maxScroll - left;
        }
    }
    return left;
},


// ClickMask
// --------------------------------------------------------------------------------------------

// NOTE: BackCompat only.  Canvas instance methods should be used instead (because they provide
// more context), or for very advanced callers, the EventHandler APIs should be used directly.
showClickMask : function (clickAction, mode, unmaskedTargets) {
    return this.ns.EH.showClickMask(clickAction, mode, unmaskedTargets);
},
hideClickMask : function (ID) { this.ns.EH.hideClickMask(ID); },

// ----------------------------------------------------------------------------------------

// _placeRect() - place one rectangle adjacent to another, on a specified side, without going
// offscreen.  Takes:
// - size of rectangle to place
// - coordinates / size for rectangle to place near
// - a side
// Returns X/Y coords
// Other params:
// [canOcclude]    (boolean)
//          This property controls whether this canvas can be positioned on top of the other
//          widget if there isn't room to put it next to the other widget without going off
//          screen.<br>
//          If 'canOcclude' is true, simply shift this widget over the other widget, so that
//          it ends up onscreen.  If 'canOcclude' is false, avoid extending offscreen
///         by positioning this widget on the other side of the other widget.
// [otherAxisAlign]    (string)
//   Can be one of "left", "right", "outside-left", "outside-right", "top", "bottom",
//   "outside-top", "outside-bottom". (Defaults to "left" if side is "top" or "bottom",
//   "top" if side is "left" or "right").
//   This property determines how this widget will be aligned with the other widget on the
//   other axis.
// If there isn't enough room to avoid the widget going offscreen on one axis or the other,
// allow it to push offscreen on the bottom / left side, since we can always scroll in that
// direction.
_placeRect : function (width, height, adjacentRect, side, canOcclude, otherAxisAlign) {
    // Default any optional params / normalize into expected structures
    if (isc.isAn.Array(adjacentRect)) {
        adjacentRect = {left:adjacentRect[0], top:adjacentRect[1],
             width:adjacentRect[2], height:adjacentRect[3]};

    // if passed no target rect, use the mouse position
    } else if (adjacentRect == null) {
        adjacentRect = {
            left:this.ns.EH.getX(), top:this.ns.EH.getY()
        }
    }

    // [if target rect has no width/height assume to be a point]
    if (adjacentRect.width == null) adjacentRect.width = 0;
    if (adjacentRect.height == null) adjacentRect.height = 0;

    // default side to "bottom"
    if (side == null) side = "bottom";

    // default canOcclude to true
    if (canOcclude == null) canOcclude = true;

    // we are placing the widget on a particular side; otherAxisAlign specifies where along
    // that side we want the widget to appear.  For example for a widget placed on the top or
    // bottom side, options in left-right order are "outside-left", "left" (aka "inside-left"),
    // "right" (aka "inside-right"), "outside-right".  Analogous choices for vertical placement
    // when placing on right/left side.
    // If unset, (or set to a value on the wrong axis), default to "left" when side is bottom/
    // top, and "top" when side is left/right
    var vertical = (side == "bottom" || side == "top");
    if (vertical) {
        // only 4 options on each axis - setting to "top" / "bottom" has no meaning if placing
        // above/below
        if (otherAxisAlign == "inside-right") otherAxisAlign = "right";
        if (otherAxisAlign != "right" &&
            otherAxisAlign != "outside-right" &&
            otherAxisAlign != "outside-left") otherAxisAlign = "left";
    } else {
        if (otherAxisAlign == "inside-bottom") otherAxisAlign = "bottom";
        if (otherAxisAlign != "bottom" &&
            otherAxisAlign != "outside-bottom" &&
            otherAxisAlign != "outside-top") otherAxisAlign = "top";
    }

    var left = adjacentRect.left;
    if (vertical) {
        // if otherAxisAlign is "left", we want to put it at the left edge (no change to left)
        // Adjust for other options:
        if (otherAxisAlign == "right") left += (adjacentRect.width - width);
        else if (otherAxisAlign == "outside-right") left += adjacentRect.width;
        else if (otherAxisAlign == "outside-left") left -= width;
    } else {
        if (side == "left") left -= width;
        else left += adjacentRect.width
    }

    var top = adjacentRect.top;
    if (vertical) {
        if (side == "top") top -= height;
        else top += adjacentRect.height;
    } else {
        if (otherAxisAlign == "bottom") top += (adjacentRect.height - height);
        else if (otherAxisAlign == "outside-bottom") top += adjacentRect.height;
        else if (otherAxisAlign == "outside-top") top -= height;

    }

    // left / top now represent the desired position.  Adjust this to avoid the placed rect
    // from sticking offscreen if necessary.
    // Note: If canOcclude is true, this is simple, we will just move it back as far as
    // necessary to avoid being clipped by the browser viewport.
    // If canOcclude is false, we must "jump" across the adjacentRect to avoid covering it,
    // so we will try placing it on the opposite side, instead.
    var pageWidth = isc.Page.getWidth(),
        pageHeight = isc.Page.getHeight(),
        // param will give us negative origin coords if we're in RTL mode
        pageScrollLeft = isc.Page.getScrollLeft(true),
        pageScrollTop = isc.Page.getScrollTop()
    ;

    // calculate how much we're jutting out beyond the browser viewport in each dimension
    var leftExcess = pageScrollLeft - left,
        rightExcess = left + width - (pageWidth + pageScrollLeft),
        topExcess = pageScrollTop - top,
        bottomExcess = top + height - (pageHeight + pageScrollTop);
    ;

    // Shortcut: if the rectangle will be completely onscreen, just return it:
    if (leftExcess <=0 && rightExcess <=0 && topExcess <=0 && bottomExcess <=0) {
        return [left, top];
    }

    // for each direction we extend out of the viewport:
    // - if we are allowing occlusion, just move top and left until not sticking out of the
    //   viewport
    // - otherwise, try moving to the other side of the adjacent rect, and use that position if
    //   it prevents sticking out of the viewport.  If moving to the other side still has us
    //   sticking out of the viewport, always prefer sticking out to the right/bottom, since
    //   the user can scroll in that direction.

    // -- HORIZONTAL ADJUSTMENTS:
    // jutting out to the left
    if (leftExcess > 0) {
        // If we're on the left side, and canOcclude is false, we want to jump to the right
        // side of the adjacentRect
        if (side == "left" && !canOcclude) {
            // Edge cases [no pun intended]:
            // - the adjacentRect is completely offscreen to the left
            //   * In this case, we will move past the right edge to ensure our rect is
            //     onscreen [move to pageScrollLeft]
            // - positioning at the right edge of adjacentRect will push our new rect offscreen
            //   to the right
            //   * This is ok - preferable to be offscreen on the right since the user can
            //     always scroll to reach it
            // - right edge of adjacentRect is offscreen on the right
            //   * not clear what's the best behavior here - for now we'll position at the
            //     right edge of adjacentRect, even though that is offscreen, as we know we
            //     can scroll it into view.
            if (adjacentRect.left + adjacentRect.width < pageScrollLeft) {
                left = pageScrollLeft;
            } else {
                left = adjacentRect.left + adjacentRect.width;
            }
        } else {
            // Just slide into view on the page
            left = pageScrollLeft;
        }

    // jutting out to the right
    } else if (rightExcess > 0) {

        // if we're on the right edge, and can't occlude, jump over the adjacentRect and
        // put on the left edge (unless this would push it out of the viewport to the left)
        if (side == "right" && !canOcclude) {
            if ((adjacentRect.left - width) >= pageScrollLeft) {
                // if the adjacent rect is completely offscreen to the right, slide into view
                // on the right edge of the screen
                if (adjacentRect.left > (pageScrollLeft + pageWidth))
                    left = (pageScrollLeft + pageWidth) - width;
                else left = adjacentRect.left - width;
            }
            // If putting on the left edge would push the element out of the viewport on the
            // left, just leave on the right edge.
        } else {
            // If the object is wider than the page, just plonk it on the left edge of the
            // page (will continue to jut out to the right)
            // Otherwise align the right edge with the right edge of the page
            if (pageWidth < width) {
                left = pageScrollLeft;
            } else {
                left = pageScrollLeft + pageWidth - width;
            }
        }
    }

    // -- VERTICAL ADJUSTMENTS:
    // [see comments on horizontal adjustments - identical logic]
    // Clipped by top of viewport
    if (topExcess > 0) {
        if (side == "top" && !canOcclude) {
            if (adjacentRect.top + adjacentRect.height < pageScrollTop) {
                top = pageScrollTop;
            } else {
                top = adjacentRect.top + adjacentRect.height;
            }
        } else {
            // Just slide into view on the page
            top = pageScrollTop;
        }

    // clipped by bottom of viewport
    } else if (bottomExcess > 0) {

        if (side == "bottom" && !canOcclude) {
            if ((adjacentRect.top - height) >= pageScrollTop) {

                if (adjacentRect.top > (pageScrollTop + pageHeight))
                    top = (pageScrollTop + pageHeight) - height;
                else top = adjacentRect.top - height;
            }
            // If putting on the top edge would push the element out of the viewport on the
            // top, just leave on the bottom edge.
        } else {

            if (pageHeight < height) {
                top = pageScrollTop;
            } else {
                top = pageScrollTop + pageHeight - height;
            }
        }
    }
    return [left, top];

},





// clean up on unload
_handleUnload : function () {
    //>IE
    if (isc.Browser.isIE) this._clearDOMHandles(); //<IE

    var logViewer = isc.Log.logViewer;
    if (logViewer && logViewer.logWindowLoaded()) {
        logViewer._logWindow.openerUnloading();

        logViewer._logWindow = null;
    }
}

//>IE

,
_clearDOMHandles : function () {

    // get the list of global ID objects
    var list = this._canvasList;
    // now for each item that has a _handle, clear the pointers in both directions
    for (var i = 0; i < list.length; i++) {
        var canvas = list[i];
        // if the canvas exists...
        if (canvas) {
            // ...and has a handle, remove the references to and from the DOM
            if (canvas._handle) {
                // kill the reference from the DOM to JS
                canvas._handle.eventProxy = null;
                // kill the reference from JS to the DOM
                canvas._handle = null;
            }
        }
    }
    return true;
}
//<IE
,





//> @classMethod snapToEdge()
// consolidate logic for snapTo code. Aligns snapRect to targetRect base on parameters
// snapTo and snapEdge.
// @param targetRect - canvas to snap to, or array of coords [left, top, width, height]
// @param snapTo - edge against which to snap
// @param snapRect - canvas being snapped
// @param snapEdge - edge of snapRect to align with snapTo
//<

snapToEdge : function (targetRect, snapTo, snapRect, snapEdge, arbitraryCanvas) {

    var finalCoord = isc.Canvas._getSnapPosition(targetRect, snapTo, snapRect, snapEdge, arbitraryCanvas);

    // finally, move this to result coords
    snapRect.moveTo(finalCoord[0], finalCoord[1]);
    // let master know not to resize this peer
    snapRect._resizeWithMaster = false;
},

// give a rect (coord + size) return the coordinates in that rect that correspond to the edge.
_getSnapPoint : function (edge, coord, size, getInverse) {
    var cWidth = size[0],
        cHeight = size[1];

    // get the amount to add or subtract to top and left for each snap point
    var delta;
    if (edge == "TL") delta = [0, 0];
    else if (edge == "T") delta = [0, cWidth / 2];
    else if (edge == "TR") delta = [0, cWidth];
    else if (edge == "R") delta = [cHeight / 2, cWidth];
    else if (edge == "BR") delta = [cHeight, cWidth];
    else if (edge == "B") delta = [cHeight, cWidth / 2];
    else if (edge == "BL") delta = [cHeight, 0];
    else if (edge == "L") delta = [cHeight / 2, 0];
    else if (edge == "C") delta = [cHeight / 2, cWidth / 2];
    else delta = [0, 0];

    delta[0] = Math.floor(delta[0]);
    delta[1] = Math.floor(delta[1]);

    // apply the appropriate transform to the parameter coordinates
    if (getInverse) return [coord[0] - delta[0], coord[1] - delta[1]];
    else return [coord[0] + delta[0], coord[1] + delta[1]];
},


//  utility function to get the top level view
_getTopLevelWidget : function(globals) {
    if (!globals) return null;

    var globalKeys = isc.isAn.Array(globals) ? globals : isc.getKeys(globals);

    // find the last top-level Canvas in the globals and return it
    //
    // Note: globalEvalWithCapture return globalIDs in the order they were created.
    // Typically the top-level container is declared last since it incorporates other
    // Canvii declared before it, so we count down from the last created Canvas here.
    for (var ri = globalKeys.length; ri > 0; --ri) {
        var global = globalKeys[ri - 1];
        var obj = window[global]; // globals are IDs, dereference

        if (obj && isc.isA.Canvas(obj) && !obj.destroyed && obj._screenEligible &&
            obj.parentElement == null  &&  obj.masterElement == null)
        {
            return obj;
        }
    }
    return null;
},

// ------------------------
// ScreenReader method stubs


ariaEnabled : function () {
    return false;
},

useLiteAria : function () {
    return false;
},

//>@classMethod Canvas.getSnapPosition()
//  Return the position for <code>snapper</code> to be placed in order to "snap to" an edge or
//  corner of <code>target</code>, in the same sense as +link{canvas.snapTo}.
//  <p>
//  Default for <code>snapEdge</code> is the <b>opposite</b> edge or corner from
//  <code>snapTo</code>.  For example, <code>snapTo</code> of "T" (top) means <code>snapEdge</code>
//  will default to "B" (bottom), so the returned coordinates would place <code>snapper</code>
//  centered along the top edge of <code>target</code>.  A <code>snapTo</code> of "TL" (top left)
//  means <code>snapEdge</code> will default to "BR" (bottom right), so the returned coordinates
//  would place the bottom right of <code>snapper</code> at the top left corner of
//  <code>target</code>.
//  <p>
//  <code>target</code> can be passed as either a Canvas or 4-element Array giving the top, left,
//  width and height of the target.
//  <smartclient><code>snapper</code> can be passed as either a Canvas or a
//  two-element Array of the width and height of the rectangle to be placed.</smartclient>
//
//  @param target (Canvas | Array of Integer) canvas to snap to
//  @param snapTo (String) edge against which to snap
//  @param snapper (Canvas | Array of Integer) canvas being snapped
//  @param [snapEdge] (String) optional edge to snapTo. Default is the <b>opposite</b> edge or corner from
//  <code>snapTo</code>
//  @return (Point) the position for <code>snapper</code> to be placed in order to "snap to" an edge or
//  corner of <code>target</code>
//  @visibility external
//<

getSnapPosition : function (target, snapTo, snapper, snapEdge) {
    if (!snapEdge) {
        if (snapTo == "TL") snapEdge = "BR";
        else if (snapTo == "T") snapEdge = "B";
        else if (snapTo == "TR") snapEdge = "BL";
        else if (snapTo == "R") snapEdge = "L";
        else if (snapTo == "BR") snapEdge = "TL";
        else if (snapTo == "B") snapEdge = "T";
        else if (snapTo == "BL") snapEdge = "TR";
        else if (snapTo == "L") snapEdge = "R";
    }

    return isc.Canvas._getSnapPosition(target, snapTo, snapper, snapEdge);
},

// Auxiliary method used by snapToEdge and by getSnapPosition
// The "arbitraryCanvas" param allows you to snap a canvas to the edge of
// some other canvas, without having to be a peer of that canvas. It is used internally,
// by snapToEdge
_getSnapPosition : function (target, snapTo, snapper, snapEdge, arbitraryCanvas) {
    // any combo of snapTo and snapEdge can be resolved by two fairly simple coordinate
    // transforms. SnapPoints are the 8 possible values for snapTo and snapEdge.
    // To get the final (top,left) of the canvas in question:
    //    1. find the coordinates of the snapPoint on this.parent/master given in this.snapTo
    //    2. map to the origin of this, starting from the snapPoint on this given in
    //      this.snapEdge.Use the coordinates from 1 as the location of this.snapEdge.
    //    3. move this to the resulting coordinates.

    // If we're snapping to an edge within our parent, use internal sizing
    // determine origin for first transform (inside borders, sb's etc).
    // Param target can also be an array [left, top, width, height]
    var targetDims, insideCoords, targetOrigin;
    if (isc.isAn.Array(target)) {
        insideCoords = false;
        targetOrigin = [target[1], target[0]];
        targetDims = [target[2], target[3]];
    } else if (snapper.masterElement) {
        insideCoords = (snapper.percentBox == snapper._$viewport),
        targetDims = [insideCoords ? target.getViewportWidth() :
                                      target.getVisibleWidth(),
                       insideCoords ? target.getViewportHeight() :
                                      target.getVisibleHeight() ];
        targetOrigin = [target.getTop() + (insideCoords ?
                                           (target.getTopBorderSize() + target.getTopMargin()) :
                                          0),
                        target.getLeft() + (insideCoords ?
                                       (target.getLeftBorderSize() + target.getLeftMargin()) :
                                       0)
                        ];
    } else if (isc.isA.Canvas(arbitraryCanvas)) {
        insideCoords = (snapper.percentBox == snapper._$viewport),
        targetDims = [insideCoords ? arbitraryCanvas.getViewportWidth() :
                                      arbitraryCanvas.getVisibleWidth(),
                       insideCoords ? arbitraryCanvas.getViewportHeight() :
                                      arbitraryCanvas.getVisibleHeight() ];
        targetOrigin = [arbitraryCanvas.getPageTop() + (insideCoords ?
                            (arbitraryCanvas.getTopBorderSize() + arbitraryCanvas.getTopMargin()) :
                            0),
                        arbitraryCanvas.getPageLeft() + (insideCoords ?
                            (arbitraryCanvas.getLeftBorderSize() + arbitraryCanvas.getLeftMargin()) :
                            0)
                        ];
    } else {
        insideCoords = true;
        targetDims = [target.getViewportWidth(), target.getViewportHeight()];
        targetOrigin = [0, 0];
    }

    // get the coordinate on the target that we are snapping to
    var firstCoord = isc.Canvas._getSnapPoint(snapTo, targetOrigin, targetDims, false);
    // then modify this coordinate by our size, according to which of our edges should snap
    // to the target point
    var finalCoord = isc.Canvas._getSnapPoint((snapEdge || snapTo), firstCoord,
                                        [snapper.getVisibleWidth(),snapper.getVisibleHeight()], true);
    // note that _getSnapPoint() returns [top,left], not [left,top]
    if (snapper.snapOffsetLeft != null) finalCoord[1] += snapper.snapOffsetLeft;
    if (snapper.snapOffsetTop != null) finalCoord[0] += snapper.snapOffsetTop;

    // Return a Point. As Left, top
    return [finalCoord[1], finalCoord[0]];
}

}); // END isc.Canvas.addClassMethods()


//  'registerStringMethods()' - add all the instance properties that can be defined as strings
//  to evaluate (or as methods) to a central registry, together with their arguments as comma
//  separated strings.
//
isc.Canvas.registerStringMethods({
    // NOTE: event handlers are all legal to register as string methods.  We do this below.

    // Other legal stringMethods
    resized:"deltaX,deltaY", // note these args are intentionally not doc'd, but framework
                             // code in GR.addEmbeddedComponent() currently relies on them
    showIf:"canvas",
    childRemoved:"child,name",
    peerRemoved:"peer,name",
    deparented:"oldParent,name",
    depeered:"oldMaster,name",

    //> @method canvas.parentMoved()
    // Notification method fire when an ancestor of this component's position changes.
    // @param parent (canvas) the ancestor that moved
    // @param deltaX (int) horizontal difference between current and previous position
    // @param deltaY (int) vertical difference between current and previous position
    // @see canvas.moved()
    // @visibility external
    //<
    parentMoved:"parent,deltaX,deltaY",


    //> @method canvas.moved()
    // Notification method fired when this component is explicitly moved.
    // Note that a component's position on the screen may also changed due to an ancestor being
    // moved. The +link{parentMoved()} method provides a notification entry point to catch
    // that case as well.
    //
    // @param deltaX (int) horizontal difference between current and previous position
    // @param deltaY (int) vertical difference between current and previous position
    // @visibility external
    //<
    moved:"deltaX,deltaY",

    //> @method     canvas.focusChanged()
    // Notification function fired when this widget receives or loses keyboard focus.
    // @param   hasFocus (boolean) If true this widget now has keyboard focus
    // @group focus
    // @visibility external
    //<
    focusChanged:"hasFocus",

    //> @method canvas.scrolled()
    // Notification that this component has just scrolled.  Use with
    // +link{class.observe,observation}.
    // <P>
    // Fires for both CSS and +link{Scrollbar,"synthetic" scrollbars}.
    //
    // @group scrolling
    // @visibility external
    //<
    scrolled: "deltaX,deltaY",

    //> @method canvas.parentScrolled()
    // Notification that an ancestor of this component has just scrolled.  Use with
    // +link{class.observe,observation}.
    // <P>
    // Fires for both CSS and +link{Scrollbar,"synthetic" scrollbars}.
    //
    // @group scrolling
    //<
    parentScrolled: "parent,deltaX,deltaY",

    // The hover event is generated by the Canvas class, so not present in EH.eventTypes.
    hover:"",

    //> @method Canvas.onDrop()
    // Notification method fired when the user drops another canvas onto this one. Returning
    // <code>false</code> from this method will prevent any default drop behavior from occurring
    // @return (boolean) return false to cancel default drop handling
    // @visibility sgwt
    //<
    onDrop:"",

    //> @method canvas.visibilityChanged()
    // Notification  fired when this canvas becomes visible or hidden to the user.
    // Note - this method is fired when the +link{isVisible()} state of this
    // component changes. It may be fired in response an explicit call to +link{show()}
    // or +link{hide()} or +link{setVisibility()}, or in response to a parent component
    // being shown or hidden when this widgets +link{canvas.visibility} is set to "inherit".
    // <P>
    // Note that a call to +link{show()} or +link{hide()} will not <b>always</b> fire this
    // notification. If this widget has a hidden parent, show or hide would change this
    // components +link{canvas.visibility} property, and may update the CSS visibility attribute
    // of the drawn handle in the DOM, but would not actually hide or reveal the component to
    // the user and as such the notification would not fire.
    // <P>
    // Note also that this notification will only be fired for components which have been
    // +link{canvas.draw(),drawn}.
    // @param isVisible (boolean) whether the canvas is visible to the user
    // @visibility external
    //<
    visibilityChanged:"isVisible"


});

isc.Canvas._canvasInit = function () {
    var EH = isc.EH,
        noopHandlers = {};
    for (var eventName in EH.eventTypes) {
        // Register all events as string methods using the EventHandler's authoritative list
        this.registerStringMethods(EH.eventTypes[eventName], EH._eventHandlerArgString);

        // Make sure every event handler on all Canvas's has a NO-OP function as its default value,
        // so you don't get a JS error if you explicitly call (canvas.click()).
        var functionName = EH.eventTypes[eventName];
        if (this.getInstanceProperty(functionName) == null) {
            noopHandlers[functionName] = isc.Class.NO_OP;
        }
    }
    this.addMethods(noopHandlers);
}
isc.Canvas._canvasInit();



// SnapAlignmentMarker
// ---------------------------------------------------------------------------------------
isc.defineClass("SnapAlignmentMarker");

// Backmask
// ---------------------------------------------------------------------------------------
isc.defineClass("BackMask", "Canvas").addMethods({
    autoDraw:false,
    _isBackMask:true,
    _generated:true,

    useClipDiv: false,

    hideUsingDisplayNone: isc.Browser.isMoz || (isc.Browser.isIPhone && isc.Browser.iOSVersion >= 7)
            || isc.Browser.isChrome,
    overflow:isc.Canvas.HIDDEN,
    contents:
     "<iframe width='100%' height='100%' border='0' frameborder='0' src=\"" +
        isc.Page.getBlankFrameURL() +

      "\" marginwidth='0' marginheight='0' scrolling='no' tabIndex='-1' tabStop='false'></iframe>",
    // custom sizing policy, to avoid the backmask "squaring-out" rounded corners.  Note
    // _sizeBackMask() currently both sizes and places BackMask, which prevent us using the
    // move-by-deltas approach of _moveWithMaster:true
    _moveWithMaster:false,
    masterMoved : function () { this.masterElement._sizeBackMask() },
    _resizeWithMaster:false,
    masterResized : function () { this.masterElement._sizeBackMask(); },

    draw : function (a,b,c) {
        // special suppressed flag - set by BrowserPlugin to suppress the backMask
        if (this.suppressed) return this;
        if (!this.readyToDraw()) return this;
        this.invokeSuper(isc.BackMask, this._$draw, a,b,c);
        if (this.masterElement.overflow == isc.Canvas.VISIBLE) this.masterElement._sizeBackMask();
        return this;
    },
    show : function () {
        // special suppressed flag - set by BrowserPlugin to suppress the backMask
        if (!this.suppressed) this.invokeSuper(isc.BackMask, "show");
    },

    _redrawWithMaster:false,
    _redrawWithParent:false,

    //disable snapping to alignment against this Canvas
    isSnapAlignCandidate: false
});

// ScreenSpan
// ---------------------------------------------------------------------------------------
isc.defineClass("ScreenSpan", "Canvas").addMethods({
    _generated:true,




    _spacerWidth:3200, _spacerHeight:2400,
    getInnerHTML:function () {
        if (!this._cachedContent) {
            // In IE7, the spacerHTML doesn't block clicks on "a href" links, but the img does.
            //
            // NOTE: if you update this code, also check and update EventHandler.makeEventMask();
            this._cachedContent = isc.Browser.isIE && isc.Browser.version > 6 ?
                isc.Canvas.imgHTML(this.src, this._spacerWidth,this._spacerHeight)
                : isc.Canvas.spacerHTML(this._spacerWidth,this._spacerHeight);
        }
        return this._cachedContent;
    },
    src:isc.Canvas._blankImgURL,
    redrawOnResize:false,
    overflow:"hidden",


    hide : function (waited,b,c,d) {
        isc.ScreenSpan.removeFromSpanRegistry(this);

        this.resizeTo(1,1);
        this.moveTo(null,-this.getHeight());
        return this.invokeSuper(isc.ScreenSpan, "hide", waited,b,c,d);
    },

    show : function (a,b,c,d) {
        // This sets up the page resized observation so we continue to match the
        // screen size.
        isc.ScreenSpan.addToSpanRegistry(this);
        this.fitToScreen();

        return this.invokeSuper(isc.ScreenSpan, "show", a,b,c,d);
    },

    // DEBUG: set a translucent tint to see the screenSpan while debugging
    //backgroundColor:"blue",
    //opacity:30,

    fitToScreen : function () {

        var pageWidth = Math.max(isc.Page.getWidth(null, true), isc.Page.getScrollWidth()),
            pageHeight = Math.max(isc.Page.getHeight(null, true), isc.Page.getScrollHeight());



        this.resizeTo(pageWidth, pageHeight);
        // Ensure our actual content exceeds the scrollable area of the page so we don't
        // see a gap if the user scrolls down a long way!
        if (pageWidth > this._spacerWidth || pageHeight > this._spacerHeight) {
            this._spacerWidth = Math.max(pageWidth, this._spacerWidth);
            this._spacerHeight = Math.max(pageHeight, this._spacerHeight);
            delete this._cachedContent;
            this.markForRedraw("Resizing spacer HTML to fit large page content.");
        }

        this.moveTo(0,0);
    }
});

// Handle multiple screen spans showing at the same time.
// We have to handle these centrally as screen-spans need to fit the overflowed size of the
// page, so we'll have to shrink them all to a smaller size before we can calculate
// what this desired size is
isc.ScreenSpan.addClassMethods({
    spanRegistry:{},
    addToSpanRegistry : function (span) {
        this.spanRegistry[span.getID()] = true;
        if (this.pageResizedEvent == null) {
            this.pageResizedEvent = isc.Page.setEvent("resize", this, isc.Page.FIRE_ONCE,
                                        "pageResized");
        }
    },
    removeFromSpanRegistry : function (span) {
        delete this.spanRegistry[span.getID()];

        var clearResizedEvent = true;
        for (var i in this.spanRegistry) {
            if (this.spanRegistry[i]) {
                clearResizedEvent = false;
                break;
            }
        }
        if (this.pageResizedEvent != null && clearResizedEvent) {
            isc.Page.clearEvent("resize", this.pageResizedEvent);
            delete this.pageResizedEvent;
        }
    },
    pageResized : function () {
        var spans = [];
        for (var spanID in this.spanRegistry) {
            if (this.spanRegistry[spanID]) {
                var span = window[spanID];

                if (span && span.isVisible()) {
                    spans.add(span);

                    // resize to the browser viewport to avoid impacting the page
                    // scrollWidth/scrollHeight
                    span.resizeTo(isc.Page.getWidth(null, true), isc.Page.getHeight(null, true));
                }
            }
        }
        // fitToScreen will calculate page size, move to zero/zero and resize to cover the page.
        spans.map("fitToScreen");
        // ensure it resizes if the page is resized again.
        this.pageResizedEvent = isc.Page.setEvent(
            "resize",
            this,
            isc.Page.FIRE_ONCE,
            "pageResized"
        );

    }
});

// various methods to deal with forms - these are available as class and instance methods on
// Canvas
isc._formMethods = {
//> @method canvas.getForm()
//          get a form in this layer by name or number
//          returns null if form can't be found
//
//          NOTE: you're MUCH better off naming forms, since IE and Nav
//              set the form context very differently!
//      @group  form
//
//      @param  formID      (number or string)  name or index number of the form to get
//
//      @return (object)    DOM form object if found, else null
//<
getForm : function (formID) {
    if (formID && typeof formID == "object") return formID;

    var theForm;
    if (formID != null && isc.Browser.isDOM) {
        // try looking up the form by ID attribute
        theForm = document.getElementById(formID);
    }
    if (theForm != null) return theForm;

    // try looking up the form via document.forms

    // default the formID parameter to the first form
    if (formID == null) formID = 0;

    // look for forms in the global document
    if (theForm == null) return document.forms[formID];
    return theForm;
},


//> @method canvas.getFormElementValue()
//          get a form element's value
//      does the right thing for text fields, checkboxes, radio button and selects
//      @group  form
//
//      @param  formID      (number or string)  name or index number of the form to get
//      @param  elementID   (number or string)  name or index number of the form element to get
//      @return             (any)       value of the element or null if form or element can't be found
//<
getFormElementValue : function (formID, elementID) {
    // get the form element -- if not found, bail
    var element = this.getFormElement(formID, elementID);
    if (!element) return;

    // now set the value according to the element type
    switch (element.type) {
      case "radio":
        return (element.checked ? element.value : null)

      case "checkbox":
        return element.checked;

      case "select-one":
        if (!element.options || element.options.length == 0) return null;

        // get the option that's selected
        var option = element.options[element.selectedIndex];
        // if it has a value, return the value, otherwise return the name
        return option.value;//(option.value == null ? option.value : option.text);

      case "select-multiple":
        var output = [];
        for (var i = 0, len = element.options.length; i < len; i++) {
            var option = element.options[i];
            if (option.selected)
                output.add(option.value);
        }
        return output;

      case "button":
      case "reset":
      case "submit":
        return null;

      default:
        // for text field, passwords, textAreas, etc. just return the value
        return element.value;
    }
},

//> @method canvas.getFormValues()
// Returns an object literal with formElement names to formElement values
// returns null if form can't be found
//
//      @group  form
//
//      @param  formID      (number or string)  name or index number of the form to get
//
//      @return (object)    key/value pairs
//<
getFormValues : function (formID) {
    var theForm = this.getForm(formID);
    if (!theForm) return null;

    var formData = {};
    if(!theForm.elements) {
        this.logWarn("Form '"+formID+"' contains no elements - returning empty map for data.");
        return {};
    }
    for (var i = 0; i < theForm.elements.length; i++) {
        var formElement = theForm.elements[i];
        if (formElement.name != null) {
            var elementValue = this.getFormElementValue(theForm, theForm.elements[i]);
            if (elementValue != null) formData[formElement.name] = elementValue;
        }
    }
    return formData;
},



//> @method canvas.getFormElement()
//          get a form element by form name and element name
//      @group  form
//
//      @param  formID      (number or string or form)  name or index number of the form to get
//              returns null if form can't be found
//      @param  elementID       (number or string or form element)  name or index number of the form element to get
//      @return (object)    form element object if found, else null
//<
getFormElement : function (formID, elementID) {
    // if they passed an element, just return it
    if (typeof elementID == "object") return elementID;
    // get the handle to the form
    var form = this.getForm(formID);
    // if the form was found, return the element if it can be found
    if (form) return form.elements[elementID];
    // otherwise return null
    return null;
}

};

isc.Canvas.addClassMethods(isc._formMethods);
isc.Canvas.addMethods(isc._formMethods);

//> @classMethod isc.setAutoDraw()
// Set the global default setting for +link{Canvas.autoDraw}.
// <p>
// After calling <code>isc.setAutoDraw()</code>, any newly created Canvas which is not given an
// explicit setting for +link{canvas.autoDraw,autoDraw} will follow the new default setting.
// <P>
// autoDraw:false is the recommended default setting for most applications since it ensures
// that extra draws will not occur when developers inadvertently omit the autoDraw:false
// setting on child components.
//
// @param [enable] whether autoDraw should be enabled or disabled.  Defaults to true.
// @see attr:Canvas.autoDraw
// @group autoDraw
// @visibility external
//<
isc.setAutoDraw = function (enable) {
    if (enable == null) enable = true;
    isc.Canvas.addProperties({
        autoDraw:enable
    });
};



isc.allowDuplicateStyles = true;

//  END package Canvas
//
////////////////////




//> @groupDef noFrames
// Loading the SmartClient framework into multiple frames or iframes within the same browser is
// not a supported configuration, or more accurately, not a <i>supportable</i> configuration,
// for the following reasons:
// <ul>
// <li> each additional frame multiplies the memory footprint and reduces speed
// <li> having multiple frames prevents drag and drop between components in different frames
// <li> modality handling (eg modal dialogs) doesn't automatically take into account multiple
// frames (consider tabbing order, nested modality and other issues, you'll see it's not
// realistic to provide automatic cross-frame modality handling)
// <li> inter-frame communication triggers several browser bugs: memory leaks, performance
// issues, intermittent crashes in some browsers, inconsistencies in basic JavaScript operators
// such as "typeof", and problems with form focus handling in IE, among many other bugs
// </ul>
// None of these problems are specific to SmartClient.  They happen with Ajax frameworks in
// general as well as other RIA technologies.  This is why no successful Ajax application has
// ever used the approach of double-loading a component framework into multiple frames.
// <P>
// The recommended +link{smartArchitecture,SmartClient Architecture} involves loading as many
// SmartClient-based application views as possible in the first page load, then showing and
// hiding different views as the user navigates through the application.
// <P>
// If, for whatever reason, you cannot follow the SmartClient Architecture and must load new
// SmartClient-based views by contacting the server each time, use the +link{ViewLoader} class
// to load new views, never frames.
// <P>
// Note that the use of IFrames is appropriate in certain circumstances, including loading
// certain types of content within an +link{HTMLFlow,contentsType,HTMLFlow}.  The only
// prohibited usage is loading the SmartClient framework into multiple frames within the same
// browser.
//
// @title Don't Misuse Frames
// @visibility external
//<

//> @type SCImgURL
// Properties that refer to images by URL, such as +link{Img.src} and +link{Button.icon}, are
// specially interpreted in SmartClient to allow for simpler and more uniform image URLs,
// and to allow applications to be restructured more easily.
// <P>
// <b>the application image directory</b>
// <P>
// When specifying URLs to image files via SmartClient component properties such as
// +link{StretchImg.src}, any relative path is assumed to be relative to the "application image
// directory" (<code>appImgDir</code>).  The application image directory can be set via
// +link{Page.setAppImgDir()}, and defaults to "images/", representing the typical practice of
// placing images in a subdirectory relative to the URL at which the application is accessed.
// <P>
// For applications that may be launched from multiple URLs, the <code>appImgDir</code> can be
// set to the correct relative path to the image directory by calling
// +link{Page.setAppImgDir()} before any SmartClient components are created.  This enables
// applications or components of an application to be launched from multiple locations, or to
// be relocated, without changing any image URLs supplied to SmartClient components.
// <P>
// <b>the "[SKIN]" URL prefix</b>
// <P>
// The special prefix "[SKIN]" can be used to refer to images within the skin folder
// whenever image URLs are supplied to SmartClient components.
// <P>
// The value of "[SKIN]" is the combination of:
// <ul>
// <li> the "skin directory", established in <code>load_skin.js</code> via +link{Page.setSkinDir()},
// plus..
// <li> the setting for +link{canvas.skinImgDir,skinImgDir} on the component where you set an
// image URL property
// </ul>
// <code>skinImgDir</code> defaults to "images/", so creating an +link{Img} component with
// +link{Img.src} set to "[SKIN]myButton/button.gif" will expand to <code>Page.getSkinDir() +
// "/images/myButton/button.gif"</code>.
// <P>
// Some components that use a large number of images use <code>skinImgDir</code> to group them
// together and make it possible to relocate all the media for the component with a single setting.
// For example, the +link{TreeGrid} class sets <code>skinImgDir</code> to "images/TreeGrid/".
// This allows +link{treeGrid.folderIcon} to be set to just "[SKIN]folder.gif" but refer to
// <code>Page.getSkinDir() + "/images/TreeGrid/folder.gif"</code>.
// <P>
// A custom subclass of TreeGrid can set <code>skinImgDir</code> to a different path, such as
// "/images/MyTreeGrid", to source all media from a different location.
// <P>
// TIPS:
// <ul>
// <li> subcomponents may not share the parent component's setting for skinImgDir.  For
// example, the +link{window.minimizeButton} has the default setting for "skinImgDir"
// ("images/"), so the +link{img.src,src} property used with this component is set to
// "[SKIN]/Window/minimize.png" (in the "SmartClient" sample skin).
// <li> for a particular image, the skinImgDir setting on the component may not be
// convenient.  The prefix "[SKINIMG]" can be used to refer to <code>Page.getSkinDir() +
// "/images"</code> regardless of the setting for <code>skinImgDir</code>
// </ul>
// <B>Stateful image URLs</B>
// <P>
// Many image URLs in SmartClient are "stateful", meaning that the actual URL used to fetch an
// image will vary according to the component's state (eg, "Disabled"), generally, by adding a
// suffix to the image URL.  See the +link{group:skinning,Skinning Overview} for more
// information on statefulness and the +link{Img.src} documentation for information on how
// stateful image URLs are formed.
//
// @visibility external
//<

//> @groupDef skinning
//
// Skinning (aka "theming" or "branding") is the process of modifying SmartClient's default
// look and feel to match the desired look and feel for your application.  SmartClient supports
// an extremely powerful and simple skinning system that allows designers with a basic grasp of
// CSS and JSON to skin any SmartClient component.
// <P>
// <h4>Basics</h4>
// <P>
// <ul>
// <li> SmartClient components create their visual appearance by dynamically generating HTML,
// within the browser, using JavaScript.
//
// <li> the HTML generated by SmartClient components contains CSS style names and URLs to
// images
//
// <li> SmartClient components can be skinned by replacing the CSS styles and images that
// the components use by default, or by setting properties on components to configure
// them to use new CSS styles and new image URLs.
//
// <li> You can change the appearance of an individual SmartClient component by
// <smartclient>
// passing properties to +link{class.create,create()}, or you can skin all
// components of the same class at once, by using +link{classMethod:class.addProperties,addProperties()}
// and +link{class.changeDefaults,changeDefaults()} to change the defaults for the class.
// </smartclient>
// <smartgwt>
// calling setter methods such as +link{canvas.styleName,setStyleName()} or
// +link{canvas.backgroundColor,setBackgroundColor()}, or you can skin all
// components of the same class at once, by using Canvas.setDefaultProperties()
// to change the defaults for the class.
// </smartgwt>
//
//
// <li> CSS is used to control details of appearance such as fonts, borders and background
//      colors and gradients, but component properties are used to control layout and
//      positioning of components.  See +link{type:CSSStyleName} for more details about correct
//      usage.
// <li> A "skin" consists of:
// <ul>
// <li> a single CSS stylesheet containing all CSS styles used by SmartClient components
// (<code>skin_styles.css</code>)
// <li> a single JavaScript file that sets component defaults (<code>load_skin.js</code>)
// <li> a directory tree of images organized by component
// </ul>
//
// <li>
// The example skins that come with SmartClient are
// <smartclient>in <code>smartclientSDK/isomorphic/skins</code>.</smartclient>
// <smartgwt>inside smartgwt.jar and smartgwt-skins.jar as GWT modules.</smartgwt>
// The standard directory layout for a skin is:
// <pre>
//        skin_styles.css
//        load_skin.js
//        images/
//            ListGrid/
//                sort_ascending.gif
//                ...
//            Tab/
//            ... other directories containing
//                component or shared media ...
// </pre>
// <li>
// <smartclient>
// A skin is loaded via a &lt;SCRIPT SRC=&gt; tag that loads load_skin.js, or, if using
// the SmartClient server, by specifying the "skin" property of the +link{group:loadISCTag}.
// </smartclient>
// <smartgwt>
// A skin is implicitly loaded when you add an &lt;inherits&gt; tag in your .gwt.xml file to
// include SmartGWT components (name="com.smartgwt(ee).SmartGWT(Pro|Power|EE)").  To switch skins,
// add the "NoTheme" suffix to the "name" attribute of this &lt;inherits&gt; tag, then add
// &lt;inherits name="com.smartclient.theme.enterpriseblue.<i>SkinName</i>"/&gt;.  These
// tags cause a &lt;SCRIPT SRC=&gt; tag to be injected into your bootstrap .html page, which loads
// load_skin.js for the appropriate skin.
// </smartgwt>
// load_skin.js loads the stylesheet and sets the CSS styleNames and media URLs that
// SmartClient components will use.
// </ul>
// <P>
// <h4>CSS3 mode</h4>
// <P>
// Three of SmartClient's most commonly used skins - Enterprise, EnterpriseBlue and Graphite - now
// have a "CSS3 mode" in which almost all images required by the skin are replaced with CSS3
// settings that appear nearly identical to the image-based appearance.  This results in a
// performance boost through both a simplified DOM and far few images being loaded.
// <P>
// By default CSS3 mode is automatically used in modern browsers such as Firefox, Chrome, Safari,
// IE 9 in standards mode, and IE 10+.  Internet Explorer version 8 and earlier does not have sufficient
// CSS support to create a close match to the existing image-based skin, so CSS3 mode is not
// enabled by default. If CSS3 mode is manually enabled for IE when not automatically enabled,
// this will result in a degraded appearance that is similar across IE6, 7, and 8: rounded elements
// such as tabs will become square, and backgrounds will have lower quality if not disappear.
// <P>
// To override the default decision on whether to use CSS3 support, set the JavaScript global
// variable <code>isc_css3Mode</code> before any of the SmartClient libraries are loaded.  For
// example:
// <pre>
//   &lt;script&gt;isc_css3Mode = "on";&lt;/script&gt;
// </pre>
// <P>
// Possible settings are:
// <P>
// <ul>
//   <li>"supported" :<br><i>(default setting)</i> CSS3 mode will be used for browsers that fully
//       support it (including rounded edges and full gradient support)</li>
//   <li>"off" :<br>CSS3 mode will never be used</li>
//   <li>"on" :<br>CSS3 mode will be used for all browsers</li>
// </ul>
// <P>
// For more control than the above settings provide, you can create a custom skin based on one
// of the above 3 skins and modify load_skin.js - whether CSS3 mode is used is controlled by a
// JavaScript variable <code>useCSS3</code> defined in this file.
// <P>
// <b>NOTE</b>: we are working on improving IE9 support using the limited CSS3 features
// provided by this browser, but at the moment, the well-published workarounds for IE9's CSS3
// bugs create other bugs of their own that are, as yet, unresolved.
// <P>
// <h4>Spriting</h4>
// <p>
// In addition to having a CSS3 mode, the Enterprise, EnterpriseBlue, and Graphite skins also
// support spriting of user interface images. This typically results in reduced load times and
// eliminates noticeable delays in changes of component appearance while the browser downloads
// a required image. Because of these benefits, spriting is enabled by default in all browsers
// except for Internet&nbsp;Explorer 6.
// <p>
// When spriting is enabled, SmartClient uses images which have several of the smaller images
// combined into one. For example, the up and down arrow images of a +link{SpinnerItem} in
// the normal, "Focused", and "Disabled" states are combined into one image. The file size of
// the combined image is 65% smaller than the sum of the file sizes of the 6 constituent images,
// and the browser does not have to make 6 separate HTTP requests.
// <p>
// If certain component metrics (such as the height of a component or padding) are changed,
// then the Enterprise, EnterpriseBlue, and Graphite skins' image sprites might not work in the
// customized skin. In this case, spriting can be disabled by setting the JavaScript global
// variable <code>isc_spriting</code> to "off" before any of the SmartClient libraries are loaded.
// For example:
// <pre>
//   &lt;script&gt;isc_spriting = "off";&lt;/script&gt;
// </pre>
// Possible settings are:
// <P>
// <ul>
//   <li>"supported" :<br><i>(default setting)</i> Spriting will be used in browsers that fully
//       support it</li>
//   <li>"off" :<br>Spriting will not be used</li>
// </ul>
// <h4>Modifying Skins</h4>
// <P>
// To modify a skin, first create a copy of one of the skins that comes with the SmartClient
// SDK, then modify the copy.  Full instructions are provided in Chapter 9 of the
// <smartclient>
// +docTreeLink{QuickStartGuide,QuickStart Guide}.
// </smartclient>
// <smartgwt>
// +externalLink{http://docs.smartclient.com,QuickStart Guide}.
// </smartgwt>
// <P>
// <h4>Locating Skinning Properties</h4>
// <P>
// <b>Starting from the name of the component</b>
// <P>
// <smartclient>
// Given a SmartClient component that you want to skin, use the search feature of the SmartClient
// Reference to locate it, and open the "Instance APIs" tab:
// </smartclient>
// <smartgwt>
// Given a Smart GWT component that you want to skin, open its JavaDoc:
// </smartgwt>
// <ul>
// <li> for properties that set CSS styles, look for properties whose name includes "style", eg
// +link{button.baseStyle}
// <li> for properties that control URLs to media, look for properties whose name includes
// "src", "image" or "icon", such as +link{Img.src}
// <li> for subcomponents that also support skinning, look for properties that are documented
// as being +link{group:autoChildUsage,"AutoChildren"} and check the reference for the type of
// the AutoChild for settable properties.  For example, +link{window.minimizeButton} is an
// ImgButton and therefore supports +link{imgButton.src}.
// </ul>
// <smartclient>
// <b>TIP</b>: the Instance APIs tab allows you to search within just the current class, limit
// the display to just properties or methods, and sort by type.
// </smartclient>
// <P>
// <b>Starting from a running example</b>
// <P>
// <smartclient>
// Open the Developer Console and use the Watch Tab to locate the component or subcomponent you
// want to skin, then locate it in the documentation, as above.
// <P>
// If you don't find the component in the documentation, it may be a custom component specific
// to your organization.  To find the base SmartClient component for a component named
// "MyComponent", use the following code to find out the name of the superclass:
// <pre>
//     isc.<i>MyComponent</i>.getSuperClass().getClassName()
// </pre>
// Repeat this until you arrive at a SmartClient built-in class.  You can execute this code in
// the "Eval JS" area of the Results pane of the Developer Console.
// </smartclient>
// <P>
// Specific browsers offer alternate approaches to quickly discover the images or style names
// being used for a part of a SmartClient component's appearance:
// <ul>
// <li> the Firefox browser offers a dialog via Tools-&gt;"Page Info" that gives a manifest of
// media used in the page.
// <li> the +externalLink{http://www.getfirebug.com/,Firebug} extension for Firefox has an
// "Inspect" feature that allows you to see the HTML, CSS and media in use for a given area of
// the screen
// <li> right clicking (option-click on a Mac) on an image and choosing "Properties" shows a
// dialog that provides the image URL in most browsers.  Tips:
// <ul>
// <li> if a SmartClient component is showing text over an image, right-click at the very edge of
// the underlying image to get image properties rather than information about the text label
// <li> on some browsers, in order to see the full image URL, you may need to drag select the
// partial URL of the image shown in the properties dialog
// </ul>
// </ul>
// <P>
// <h4>Image URLs in SmartClient</h4>
// <P>
// Properties that refer to images by URL, such as +link{Img.src} and +link{Button.icon}, are
// specially interpreted in SmartClient to allow for simpler and more uniform image URLs,
// and to allow applications to be restructured more easily.
// <P>
// Unlike the URL used with an HTML &lt;IMG&gt; element, the image URL passed to a SmartClient
// component is not assumed to be relative to the current page.  See +link{type:SCImgURL} for a
// full explanation of the default application image directory, and the meaning of the "[SKIN]"
// prefix.
// <P>
// <h4>Specifying Image URLs</h4>
// <P>
// Default image URLs for SmartClient components are specified in <code>load_skin.js</code> via
// JavaScript, using calls to +link{classMethod:Class.addProperties()} and
// +link{class.changeDefaults()}.  For example, the <code>load_skin.js</code> file
// from the "Enterprise" skin includes the following code to establish the media used by
// +link{window.minimizeButton}:
// <pre>
//    isc.Window.changeDefaults("minimizeButtonDefaults", {
//         src:"[SKIN]/Window/minimize.png"
//    });
// </pre>
// <P>
// <smartgwt><b>NOTE:</b> These are JavaScript APIs and hence do not appear in SmartGWT
// JavaDoc - you may want to refer to the &#83;martClient Reference available at
// +externalLink{http://www.smartclient.com/product/documentation.jsp,Isomorphic.com} for these specific
// APIs.</smartgwt>
//
// <h4>Specifying Image Sizes</h4>
// <P>
// Many SmartClient components must know some image sizes in advance, in order to allow those
// components to autosize to data or content.
// <P>
// For example, the +link{ImgTab}s used in +link{TabSet}s are capable of automatically sizing
// to a variable length +link{tab.title}.  To make this possible, SmartClient must know the
// sizes of the images used as "endcaps" on each tab in advance.
// <P>
// Like image URLs, image sizes are specified in <code>load_skin.js</code>.  The following code
// sample establishes the default size of the "endcaps" for tabs, by setting a default value
// for +link{ImgTab.capSize}:
// <pre>
//     isc.ImgTab.addProperties({
//         capSize:4
//     })
// </pre>
// <P>
// <h4>Statefulness and Suffixes</h4>
// <P>
// Some components or areas within components, including buttons and the cells within a grid, are
// "stateful", meaning that they can be in one of a set of states each of which has a distinct
// visual appearance.
// <P>
// Stateful components switch the CSS styles or image URLs they are using as they transition
// from state to state, appending state information as suffixes on the style names or URL.
// See +link{img.src} and +link{button.baseStyle} for details and examples.
// <P>
// SmartClient has built-in logic to manage a series of state transitions, such as:
// <ul>
// <li> "rollover": showing a different appearance when the mouse is over a component
// <li> "button down": showing a different appearance when the mouse is pressed over a
// component
// <li> "disabled": showing a different appearance when a component cannot be interacted with
// <li> "selected": showing one of a set of components in a different state to indicate
// selection
// </ul>
// Flags on some components, such as +link{ImgButton.showRollOver}, allow you to control whether the
// component will switch CSS style or image URL when the component transitions into a given state.
// <P>
// <h4>StretchImg: 3-segment stretchable images</h4>
// <P>
// A +link{StretchImg} is SmartClient component that renders out a compound image composed of 3
// image files: two fixed-size endcaps images and a stretchable center segment.  Like stateful
// components, the names of each image segment is appended to the image URL as a suffix.  See
// +link{stretchImg.src} for details.
// <P>
// <h4>EdgedCanvas</h4>
// <P>
// Similar to a StretchImg, an +link{EdgedCanvas} provides an image-based decorative edge
// around and/or behind another component, with up to 9 segments (a 3x3 grid).  Decorative
// edges can be added to any component by setting +link{canvas.showEdges,showEdges:true}.
// EdgedCanvas is also used to construct dropshadows, which can be enabled on any component via
// +link{canvas.showShadow,showShadow:true}.
// <P>
// <smartclient>
// <!-- note: omitted from SmartGWT discussion since you just use ordinary Java subclassing -->
// <h4>Multiple looks for the same component type</h4>
// <P>
// In some cases you need to create two variations in appearance for a component with the same
// behavior.  For example, you may want to create a specialized Window, called "PaletteWindow",
// that behaves like a normal Window but has a very compact look & feel.  To create a
// separately skinnable component for PaletteWindow, use +link{classMethod:isc.defineClass()}.  For
// example:
// <pre>
//    isc.defineClass("PaletteWindow", "Window");
//    isc.PaletteWindow.addProperties({
//        showFooter:false,
//        ...
//    })
// </pre>
// </smartclient>
// <smartgwt>
// <p>
// <h4>Advanced: setScClassName()</h4>
// <p>
// In rare situations, such as trying to share a skin between a &#83;martClient and Smart GWT
// application, you may have a &#83;martClient class that has been defined to hold certain skin
// settings where there is no corresponding Smart GWT class.  For example, you might have a
// &#83;martClient subclass of ListGrid called "LedgerGrid" that changes cell styles to appear
// more like a ledger.
// <p>
// In this case, you can generally use the Smart GWT class that is the nearest superclass of
// the &#83;martClient class (ListGrid in this case), then use a call to
// setScClassName("LedgerGrid") to cause the &#83;martClient class to be used as the underlying
// &#83;martClient class used by the GWT ListGrid instance.
// <P>
// <h4>Where to put skin-related JavaScript</h4>
// <P>
// If you're creating a custom skin, you can place JavaScript snippets such as those shown above in your
// custom skin's load_skin.js file.  If you prefer not to create a custom skin for small customizations,
// you can execute JavaScript via a +externalLink{http://www.google.com/search?q=gwt+jsni,JSNI} method in
// your Java code.  With this latter approach, be sure to change "isc." to "$wnd.isc." wherever it
// appears, and to call the JSNI method before creating any SmartGWT components.
// </smartgwt>
// <p>
// <h4>Limitations</h4>
// <P>
// In most cases, using newer CSS features such as CSS3 prefix attribute selectors or CSS3
// pseudo-classes in a skin will just work, provided the browser supports those CSS features.
// However, in some cases, SmartClient needs to be able to extract style information from
// CSS style declarations. For this reason, only single class name selectors are officially
// supported (e.g. <code>.myButton, .myButtonDown</code>) and @-rules are not supported.
//
// @treeLocation Concepts
// @visibility external
// @title Skinning / Theming
//<





//> @object PrintProperties
// Settings for generating printable HTML for components.
//
// @treeLocation Client Reference/System
// @group printing
// @visibility external
//<

//> @attr printProperties.omitControls (Array of String : null : IR)
// An array of Strings indicating the classNames of controls that should be omitted from
// printing.  By default, <code>omitControls</code> includes all button-based controls, menus
// and similar interactive controls that are typically useless in printed output.
// <P>
// All subclasses of the specified classes are also omitted.
// <P>
// See also +link{includeControls}.
//
// @group printing
// @visibility external
//<

//> @attr printProperties.includeControls (Array of String : null : IR)
// An array of Strings indicating the classNames of controls that should be specifically
// included when printing, even if a superclass is listed in +link{omitControls}.
//
// @group printing
// @visibility external
//<

//> @attr printProperties.printForExport (Boolean : null : IR)
// If true, generates HTML for export.
// <P>
// Some components, specifically +link{DrawPane} and +link{FacetChart} on IE8 and earlier, need to generate
// different HTML for export versus in-browser print preview. When using +link{RPCManager.exportContent()}
// the printForExport property is set to true automatically. If not using RPCManager.exportContent(),
// but the generated HTML will be sent for export, the <code>PrintProperties</code> passed to
// +link{Canvas.getPrintHTML()} must have printForExport:true.
//
// @group printing
// @visibility external
//<

//> @class PrintCanvas
// PrintCanvas is a subclass of canvas which renders printable content HTML and
// provides APIs for printing this content as a separate document.
// @treeLocation Client Reference/System
// @visibility external
// @group printing
//<
isc.defineClass("PrintCanvas", "Canvas").addProperties({

redrawOnResize: false,
overflow: "hidden",

initWidget : function () {
    this.Super("initWidget", arguments);
},


useExplicitHeight:isc.Browser.isSafari ||
                (isc.Browser.isFirefox && isc.Browser.isStrict && isc.Browser.geckoVersion >= 20100101),

resized : function () {
    if (this.useExplicitHeight) {
        var handle = this.getIFrameHandle();
        if (handle) {
            handle.style.width = this.getInnerWidth();
            handle.style.height = this.getInnerHeight();
        }
    }
},

getInnerHTML : function () {

    delete this.iframeLoaded;

    var width = "100%", height = "100%";
    if (this.useExplicitHeight) {
        width = this.getInnerWidth();
        height = this.getInnerHeight();
    }
    return "<iframe height='" + height + "' width='" + width + "' scrolling='auto' id='"
        + this.getIFrameID()+"'"+" frameborder='0'" +" src=\"" +this.getPrintFrameURL(this.title)+"\"></iframe>";
},

getIFrameID : function () {
    return this.getID()+"_frame";
},

//> @attr printCanvas.printFrameURL (String : "[HELPERS]printFrame.html" : IRA)
// Location of the special printFrame html file provided as part of the SmartClient libraries.
// This file must be present at the specified location for the printCanvas printing APIs.
// @visibility external
//<
printFrameURL:"[HELPERS]printFrame.html",

//> @attr printCanvas.externalStylesheet (String : null : IRWA)
// Setting this property will cause the specified stylesheet to be loaded in this print
// canvas's frame.
// The stylesheet should be specified as a URL to load.
// @visibility external
//<
// no default setting

getPrintFrameURL : function (title) {
    return  isc.Page.getURL(this.printFrameURL + "?id="+this.getID() +
                            "&title=" + (title || ""));
},

getIFrameHandle : function () {
    return document.getElementById(this.getIFrameID());
},

getIFrameWindow : function () {
    return this.getIFrameHandle().contentWindow;
},

iframeLoad : function () {
    this.iframeLoaded = true;

    // If we're RTL update the print IFRAME to be RTL as well.

    if (this.isRTL()) {
        this.logInfo("Print preview - applying 'rtl' direction to print frame.", "printing");
        var body = this.getIFrameWindow().document.body;
        if (body == null) {
            this.logWarn("Print preview - unable to get 'body' tag for print frame. " +
                         "Right-to-left text direction cannot be guaranteed in this print preview.",
                         "printing");

        } else {
            body.style.direction = "rtl";
        }
    }


    if (isc.Browser.isIE) {
        var body = this.getIFrameWindow().document.body;
        if (body) body.style.overflow = "auto";
    }


    if (this._pendingHTMLContext != null) {
        var context = this._pendingHTMLContext;
        this._pendingHTMLContext = null;
        this.setHTML(context.HTML, context.callback);
    }
},

//> @method Callbacks.PrintCanvasCallback
// Callback executed when a Canvas is being printed.
//
//@param printCanvas (PrintCanvas) The canvas being printed.
//
//@visibility external
//<

//> @method printCanvas.setHTML()
// Update the HTML content displayed in this print canvas. If the printCanvas is not yet
// drawn the HTML will be displayed when the canvas is drawn.
//
// @param HTML (String) HTML to show in this print canvas
// @param callback (PrintCanvasCallback) callback function to fire when the HTML is displayed. The
//  callback will be passed a pointer to this print canvas as the first parameter with the
//  name <code>printPreview</code>. If this canvas is not drawn when this method is called,
//  the callback will not be fired until the canvas is drawn and the HTML rendered out into
//  the page.
// @visibility external
//<
setHTML : function (HTML, callback) {
    if (!this.isDrawn() || !this.iframeLoaded) {
        this._pendingHTMLContext = {
            HTML:HTML,
            callback:callback
        };
        return;
    }

    if (this.externalStylesheet) {
        var stylesheetHTML = '<link rel="stylesheet" type="text/css" href="' +
                    isc.Page.getURL(this.externalStylesheet) + '" />\n';
        HTML = stylesheetHTML + HTML;
    }

    var frame = this.getIFrameWindow();
    frame.assignHTML(HTML);
    if (isc.Browser.isIE && isc.Browser.hasVML && HTML.contains("class=rvml")) {
        frame.document.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
    }
    this.fireCallback(callback, ["printPreview","callback"], [this, callback]);
},

//> @method printCanvas.setTitle()
// Specify the title for the printCanvas. This is the title that will appear on the printed
// document
// @param title (String) Title to show
// @visibility internal
//<

setTitle : function (title) {
    this.title = title;
    // if the iframe hasn't been loaded we can bail - when we load it we'll include the
    // title in the HTML passed in.
    if (!this.isDrawn() && !this.iframeLoaded) return;

    // In IE window.title is essentially read-only - we really need to rewrite the entire HTML of
    // the frame to update it
    if (this.isDrawn()) this.redraw();
},

// Note there's no call to 'draw()' in here so if called before draw this would have no
// effect
printHTML : function (HTML, title ,debugOnly) {
    var self = this;
    this.setTitle(title);
    this.setHTML(HTML,

                    function () {
                    self.print();
                });
},


//> @method printCanvas.print()
// Show the native print dialog and allow the user to print the current HTML for
// this printCanvas. Note that the PrintCanvas must be drawn to be printed.
// @visibility external
//<
print : function () {
    if (!this.isDrawn()) {
        this.logWarn("print(): Attempt to print an undrawn PrintCanvas. Ignoring.");
        return;
    }

    if (!this.iframeLoaded) {
        this.delayCall("print", [], 100);
        return;
    }

    // doPrint() is a function defined in the printFrame.html helper page.
    this.getIFrameWindow().doPrint();


},

// Handler to fire when printing is complete - only fires in IE
printComplete : function () {
  //this.logWarn("print complete!~");
}

});

isc.Canvas.addClassMethods({
    //> @classMethod Canvas.printComponents()
    // Generate printable HTML for the designated components and trigger the native print
    // dialog, without never showing the printable HTML to the user.
    //
    // @param components (Array of Canvas) components to get the print HTML for. May also include
    //        raw HTML strings which will be folded into the generated print output
    // @param [printProperties] (PrintProperties) object for customizing the print HTML output
    //
    // @group printing
    // @visibility external
    //<
    printComponents : function (components, printProperties, title, debugOnly) {
        isc.Canvas.getPrintHTML(
            components, printProperties,
            {target:this, methodName:"_printComponentHTML", title:title, debugOnly:debugOnly}
        );
    },
    _printComponentHTML : function (printHTML, callback) {
        var title = callback.title,
            debugOnly  = callback.debugOnly;

        if (!this._printCanvas) this._printCanvas = isc.PrintCanvas.create({
            // sizing to 100/100 should cause the layout to match as closely as possible...
            width:"100%", height:"100%", autoDraw:false
            ,backgroundColor:"white"
        });
        this._printCanvas.moveTo(null, -isc.Page.getHeight());
        if (!this._printCanvas.isDrawn()) this._printCanvas.draw();
        this._printCanvas.printHTML(printHTML, title, debugOnly);
    },

    //> @classMethod Canvas.getPrintPreview()
    // Creates a printCanvas containing the full printHTML for a series of components, passing
    // it as an argument to the callback (if supplied) when it fires. Note that the generated
    // preview canvas will be drawn automatically by this method. Developers may also
    // explicitly create a PrintCanvas instance and populate it with HTML derived from the
    // +link{Canvas.getPrintHTML()} for finer grained control over when the print canvas is
    // drawn.
    // @param components (array of Canvas) components to get the print HTML for. May also include
    //    raw HTML strings which will be folded into the generated print output
    // @param [printProperties] (PrintProperties) PrintProperties object for customizing the print HTML output
    // @param [previewProperties] (Canvas Properties) properties to apply to the generated printPreview Canvas.
    // @param [callback] (Callback) callback to fire when the print preview canvas has been populated
    //    with the printable HTML. The generated canvas will be passed to the callback as a single
    //    <code>printPreview</code> parameter.
    // @param [separator] (String) optional string of HTML to render between each component
    // @group printing
    // @visibility external
    //<

    getPrintPreview : function (components, printProperties, previewProperties, callback, separator) {
        // always auto-draw - this is required so the thing gets populated with print HTML
        // and actually gets shown.
        if (previewProperties == null) previewProperties = {};
        previewProperties.autoDraw = true;

        // 2 steps here - both are asynchronous:
        // - generate print html from components
        // - apply HTML to the print canvas (asynchronous if iframe wasn't yet loaded)
        isc.Canvas.getPrintHTML(components, printProperties,
                                {target:this, methodName:"_createPrintPreview",
                                    origCallback:callback, previewProperties:previewProperties},
                                    separator);

    },
    _createPrintPreview : function (HTML, callback) {
        var PC = isc.PrintCanvas.create(callback.previewProperties);
        PC.setHTML(HTML, {target:this, methodName:"_printPreviewGenerated",
                                        origCallback:callback.origCallback});
    },
    _printPreviewGenerated : function (printPreview, callback) {
        if (callback.origCallback) {
            this.fireCallback(callback.origCallback, ["printPreview"], [printPreview]);
        }
    },

    //> @classMethod Canvas.showPrintPreview()
    // Generate and show a +link{class:PrintWindow} containing a +link{class:PrintCanvas}
    // showing a printable view of the components passed in.
    //
    // @param components (Array of Canvas) components to get the print HTML for. May also include
    //  raw HTML strings which will be folded into the generated print output
    // @param [printProperties] (PrintProperties) PrintProperties object for customizing the
    //    print HTML output
    // @param [printWindowProperties] (PrintWindow Properties) Properties to apply to the
    //    generated print window.
    // @param [callback] (Callback) callback to fire when the print preview canvas has
    //    been populated with the printable HTML. This callback takes 2 parameters:
    //    <code>printPreview</code> - a pointer to the generated print canvas shown in the
    //    body of the print window.
    //    <code>printWindow</code> - a pointer to the generated print window and
    // @param [separator] (String) Optional HTML separator to render between each component's printable
    //                      HTML
    //
    // @group printing
    // @visibility external
    //<
    showPrintPreview : function (components, printProperties, previewProperties, callback,
                                  separator)
    {
        if (!isc.PrintWindow) {
            isc.definePrintWindow();
        }
        if (!isc.PrintWindow) return;

        // Make the PrintWindow an autoChild
        if (previewProperties == null) previewProperties = {};
        previewProperties.autoDraw = false;
        if (previewProperties.width == null) previewProperties.width = "100%";
        if (previewProperties.height == null) previewProperties.height = "100%";
        if (previewProperties.left == null) previewProperties.left = 0;
        if (previewProperties.top == null) previewProperties.top = 0;

        if (!this._previewWindow) {
            this._previewWindow = isc.PrintWindow.create(previewProperties);
        } else {
            this._previewWindow.setProperties(previewProperties);
        }
        this._previewWindow.showPrintPreview(components, printProperties, callback, separator);
    }

});

// separate the definition of the PrintWindow class into a separate function.
// We fire this at the end of Window.js, after the Window class has been defined (but before page
// load so we know the class is available when load_skin.js gets loaded).
isc.definePrintWindow = function () {

if (!isc.Window) {
    isc.logWarn("Attempting to create PrintWindow class with no defined Window class. " +
                "Ensure the required 'Containers' module is laoded");
    return;
}

//> @class PrintWindow
// Subclass of +link{class:Window} used for displaying a printable view. Includes a "Print" button
// header control to trigger printing of content.
//
// @treeLocation Client Reference/System
// @group printing
// @visibility external
//<
isc.defineClass("PrintWindow", "Window");
isc.PrintWindow.addProperties({
    isModal: true,
    headerControls: ["headerIcon", "headerLabel", "printButton", "closeButton"],
    printButtonDefaults: {
        _constructor: "IButton",
        height: 20,
        click: "this.creator.printClicked()"
    },

    showMinimizeButton: false,
    showShadow:false,

    //> @attr printWindow.title (string : "Print Preview" : IRW)
    // Title for the print window
    // @visibility external
    //<
    title: "Print Preview",

    //> @attr printWindow.printButtonTitle (string : "Print" : IRW)
    // Title for the print button
    // @visibility external
    //<
    printButtonTitle: "Print",

    //> @method printWindow.setPrintButtonTitle ()
    // Setter for title for the print button
    // @param printButtonTitle (String) new title for the print button
    // @visibility external
    //<
    setPrintButtonTitle : function (printButtonTitle) {
        this.printButtonTitle = printButtonTitle;
        if (this.printButton != null) this.printButton.setTitle(printButtonTitle);
    },

    //> @attr printWindow.externalStylesheet (String : null : IRWA)
    // Setting this property will cause the specified stylesheet to be loaded in this
    // window's printable HTML frame.
    // <P>
    // The stylesheet should be specified as a URL to load.
    // @visibility external
    //<

    initWidget : function () {

        if (isc.Browser.isAndroid) {
            var headerControls = this.headerControls;
            if (headerControls != null) {
                headerControls = this.headerControls = headerControls.duplicate();
                headerControls.remove("printButton");
            }
        }
        this.Super("initWidget", arguments);
    },

    printButton_autoMaker : function (dynamicProperties) {
        dynamicProperties = isc.addProperties({}, dynamicProperties, {
            title: this.printButtonTitle
        });
        return this.createAutoChild("printButton", dynamicProperties);
    },

    showPrintPreview : function (components, printProperties, callback, separator) {
        if (!isc.isAn.Array(components)) components = [components];
        isc.Canvas.getPrintHTML(components, printProperties,
                                {target:this, methodName:"_applyPreviewHTML",
                                    origCallback:callback}, separator);
    },
    _applyPreviewHTML : function (HTML, callback) {
        if (!this.previewPane) {
            this.previewPane = this.createPreviewPane();
            this.previewPane.addProperties({title:this.title});
            this.addItem(this.previewPane);
        } else {
            this.previewPane.setTitle(this.title);
        }

        this.previewPane.externalStylesheet = this.externalStylesheet;

        // we have to draw the preview pane to set it's HTML
        this.setVisibility("hidden");
        if (!this.isDrawn()) this.draw();
        this.previewPane.setHTML(HTML, {target:this, methodName:"_printPreviewGenerated",
                                         origCallback:callback.origCallback});
    },
    _printPreviewGenerated : function (printPreview, callback) {
        if (!this.isVisible()) this.show();
        this.bringToFront();
        if (callback.origCallback) {
            this.fireCallback(callback.origCallback,
                ["printPreview", "printWindow"], [printPreview, this]);
        }
    },

    printClicked : function () {
        var pc = this.getPrintCanvas();
        if (!pc) return;
        pc.print();
    },

    createPreviewPane : function (callback) {
        var previewPane = isc.PrintCanvas.create({
            width: "100%",
            height: "100%"
        });
        return previewPane;
    },

    getPrintCanvas : function () {
        return this.previewPane;
    },
    // clear on closeClick

    closeClick : function () {
        this.Super("closeClick", arguments);
        this.clear();
    }
});

}



// DrawRegion
// This is a special-case subsystem exposed only to Wily

isc.Canvas.addMethods({

// --------------------------------------------------------------------------------------------
// drawRect() - write out arbitrary rectangles into this widgets handle.

//> @method drawRegion.drawRect()
// Instruct this Canvas to write out a positioned rectangle within this canvas that can
// respond to events. This method will not actually write the rectangle into our handle
// - the rectangle will instead be written out when this widget's handle is drawn / redrawn.
// Recommended usage is to call 'drawRect()' from an override of 'getInnerHTML()'
// @param left (integer) absolute left position of rectangle within this canvas
// @param top (integer) absolute top position of rectangle within this canvas
// @param width (integer) width of the rectangle in pixels
// @param height (integer) height of the rectangel in pixels
// @param [ID] (string) Optional ID for this rectangle - will be passed as a param to event
//                      handlers triggered by events over the rectangle. Defaults to the
//                      index of the rect within the rects written out during this draw.
// @param [contents] (HTML) contents to write into the rect
// @param [className] (css className) CSS Class to apply to the rect
// @param [cssText] (string) A css text fragment to be applied to the rectangle's style
//
// @group rects
// @visibility rects
//<

drawRect : function (left,top,width,height,ID,contents,className,cssText) {


    if (!this._appendHTML) this._appendHTML = [];
    this._appendHTML.add(
        isc.DrawRegion.getRectHTML(this, left,top,width,height,contents,className,cssText,ID)
    );

},

// Helper method to destroy the cached info on drawn rectangles when it is obsoleted by
// a new redraw.
_clearRectInfo : function () {
    delete this._rectCount;
    delete this._appendHTML;
}


}); // end addMethods

isc.Canvas.addClassMethods({

//> @classMethod DrawRegion.getRectHTML()
// Returns the HTML used to write out a rect via the 'drawRect()' method
// @visibility internal
//<
getRectHTML : function (creator, left, top, width, height, contents, className, cssText, ID) {
    if (left== null) left = 0;
    if (top == null) top = 0;
    if (width == null) width = 1;
    if (height== null) height = 1;



    if (!contents || contents == isc.emptyString) contents = isc.nbsp;
    if (!this._rectTemplate) {
        this._rectTemplate = [
            "<DIV class='",  // 0
            ,                // 1: className
            "' style='",     // 2
            ,                // 3: css text

            ";position:absolute;overflow:hidden;left:", // 4
            ,,,,,,           // 5-10: left (6 slots)
            "px;top:",       // 11
            ,,,,,,           // 12-17: top
            "px;width:",     // 18
            ,,,,,            //19-23: width
            "px;height:",    //24
            ,,,,,            // 25-29: height
            "px;' ID='",     // 30
            ,                // 31: this.getID()
            "_rect_",        // 32
            ,,,,,            // 33-37: itemID
            "' eventpart='rect'>",  // 38
            ,                // 39: content
            "</DIV>"
        ];
    }

    if (!creator._rectCount) creator._rectCount = 0;

    var template = this._rectTemplate;

    template[1] = className;
    template[3] = cssText;

    isc._fillNumber(template, left, 5, 6);
    isc._fillNumber(template, top, 12, 6);
    isc._fillNumber(template, width, 19, 5);
    isc._fillNumber(template, height, 25, 5);

    template[31] = creator.getID();
    if (!ID) ID = creator._rectCount++;
    if (isc.isA.Number(ID) && ID < 100000)
        isc._fillNumber(template, ID, 33, 5);
    else
        template[33] = ID;
    template[39] = contents;
    return template.join(isc.emptyString);
}


});

// "rect" partwise event stringMethods
isc.Canvas.registerStringMethods({

    //>@method drawRegion.rectMouseOver()
    // Fired when the user rolls over a rectangle drawn into this canvas via 'drawRect()'
    // @param element (DOM element) pointer to the element the user rolled over (the rectangle's HTML)
    // @param ID (string)   ID of the rectangle rolled over
    // @param event (event) event object that triggered the rectMouseOver
    // @visibility rects
    // @group rects
    //<
    rectMouseOver:"element,ID,event",

    //>@method drawRegion.rectMouseOut()
    // Fired when the user rolls off a rectangle drawn into this canvas via 'drawRect()'
    // @param element (DOM element) pointer to the element the user rolled off (the rectangle's HTML)
    // @param ID (string)   ID of the rectangle rolled off
    // @param event (event) event object that triggered the rectMouseOut
    // @visibility rects
    // @group rects
    //<
    rectMouseOut:"element,ID,event",

    //>@method drawRegion.rectMouseMove()
    // Fired when the user moves the mouse within a rectangle drawn into this canvas via 'drawRect()'
    // @param element (DOM element) pointer to the element the user rolled over (the rectangle's HTML)
    // @param ID (string)   ID of the rectangle rolled over
    // @param event (event) event object that triggered the rectMouseMove
    // @visibility rects
    // @group rects
    //<
    rectMouseMove:"element,ID,event",

    //>@method drawRegion.rectMouseDown()
    // Fired when the depresses the left mouse button within a rectangle drawn into this canvas
    // via 'drawRect()'
    // @param element (DOM element) pointer to the element the user clicked (the rectangle's HTML)
    // @param ID (string)   ID of the rectangle clicked
    // @param event (event) event object that triggered the rectMouseDown
    // @visibility rects
    // @group rects
    //<
    rectMouseDown:"element,ID,event",

    //>@method drawRegion.rectMouseUp()
    // Fired when the user releases the left mouse button within a rectangle drawn into this
    // canvas via 'drawRect()'
    // @param element (DOM element) pointer to the element the user clicked (the rectangle's HTML)
    // @param ID (string)   ID of the rectangle clicked
    // @param event (event) event object that triggered the rectMouseUp
    // @visibility rects
    // @group rects
    //<
    rectMouseUp:"element,ID,event",

    //>@method drawRegion.rectClick()
    // Fired when the user clicks within a rectangle drawn into this canvas via 'drawRect()'
    // @param element (DOM element) pointer to the element the user clicked (the rectangle's HTML)
    // @param ID (string)   ID of the rectangle clicked
    // @param event (event) event object that triggered the rectClick
    // @visibility rects
    // @group rects
    //<
    rectClick:"element,ID,event",

    //>@method drawRegion.rectDoubleClick()
    // Fired when the user double clicks within a rectangle drawn into this canvas via 'drawRect()'
    // @param element (DOM element) pointer to the element the user clicked (the rectangle's HTML)
    // @param ID (string)   ID of the rectangle clicked
    // @param event (event) event object that triggered the rectDoubleClick
    // @visibility rects
    // @group rects
    //<
    rectDoubleClick:"element,ID,event",

    //>@method drawRegion.rectContextMenu()
    // Fired when the user right clicks within a rectangle drawn into this canvas via 'drawRect()'
    // @param element (DOM element) pointer to the element the user clicked (the rectangle's HTML)
    // @param ID (string)   ID of the rectangle clicked
    // @param event (event) event object that triggered the rectDoubleClick
    // @visibility rects
    // @group rects
    //<
    rectShowContextMenu:"element,ID,event",


    //>@method drawRegion.rectHover()
    // Fired when the user hovers within a rectangle drawn into this canvas via 'drawRect()'
    // @param element (DOM element) pointer to the element the user clicked (the rectangle's HTML)
    // @param ID (string)   ID of the rectangle clicked
    // @visibility rects
    // @group rects
    //<
    rectHover:"element,ID"
});


// Define the drawRegion class for use with the 'drawRect()' subsystem.
// Implemented as a very simple subclass of canvas, just enables partwise event handling.
//> @class DrawRegion
// Subclass of Canvas providing interfaces for writing out arbitrarily positioned rects which
// will fire events as the user interacts with them.
// @visibility rects
//<
isc.ClassFactory.defineClass("DrawRegion", "Canvas");
isc.DrawRegion.addProperties({
    useEventParts:true
})






isc.ClassFactory.defineInterface("DataBoundComponent");

//> @interface DataBoundComponent
// A DataBoundComponent is a widget that can configure itself for viewing or editing objects which
// share a certain schema by "binding" to the schema for that object (called a "DataSource").
// <P>
// A schema (or DataSource) describes an object as consisting of a set of properties (or
// "fields").
// <P>
// DataBoundComponents have a +link{dataBoundComponent.dataSource,common set of APIs} for
// dealing with binding to DataSources,
// +link{dataBoundComponent.fields,overriding or augmenting} the schema information
// provided by a DataSource, and manipulating objects or sets of object from the DataSource.
// <P>
// The following visual components currently support databinding:<pre>
//   +link{class:DynamicForm}
//   +link{class:DetailViewer}
//   +link{class:ListGrid}
//   +link{class:TreeGrid}
//   +link{class:TileGrid}
//   +link{class:ColumnTree}
//   +link{class:CubeGrid}
// </pre>
// The following non-visual components also support databinding:<pre>
//   +link{class:ValuesManager}
//   +link{class:ResultSet}
//   +link{class:ResultTree}
// </pre>
//
// @treeLocation Client Reference/Data Binding
// @visibility external
//<
// Currently the DataBinding APIs are present on all Canvii.
// Documented as a separate, intervening class, to separate functionality (DataBoundComponent)

isc.Canvas.addClassProperties({
    //> @type DragDataAction
    // What do we do with data that's been dropped into another list?
    // @value "none" Don't do anything, resulting in the same data being in both lists.
    // @value isc.Canvas.COPY Copy the data leaving the original in our list.
    COPY:"copy",
    // @value isc.Canvas.MOVE Remove the data from this list so it can be moved into the other list.
    MOVE:"move",
    // @group dragdrop
    // @visibility external
    //<
    // Backcompat only: docs removed in 5.5 release in favor of "copy"
    CLONE:"clone",


    validateFieldNames: false,


    _dbcTypeDetails : {
        "DynamicForm":  { titleSuffix: "Form",        criteriaBasePathSuffix: "values"        , metaFields: ["focusField","hasChanges"] },
        "ListGrid":     { titleSuffix: "Grid",        criteriaBasePathSuffix: "selectedRecord", metaFields: ["focusField","isGrouped","anySelected","multiSelected","numSelected"] },
        "TreeGrid":     { titleSuffix: "Tree",        criteriaBasePathSuffix: "selectedRecord", metaFields: ["focusField","anySelected","multiSelected","numSelected"] },
        "TileGrid":     { titleSuffix: "Tile Grid",   criteriaBasePathSuffix: "selectedRecord" },
        "CubeGrid":     { titleSuffix: "Cube",        criteriaBasePathSuffix: "selectedRecord" },
        "ColumnTree":   { titleSuffix: "Column Tree", criteriaBasePathSuffix: "selectedRecord" },
        "DetailViewer": { titleSuffix: "Details",     criteriaBasePathSuffix: "values"         }
    },

    _dbcTypeMetaFieldTypes : {
        "focusField":   "text",
        "hasChanges":   "boolean",
        "isGrouped":    "boolean",
        "anySelected":  "boolean",
        "multiSelected":"boolean",
        "numSelected":  "integer"
    },

    _ruleScopeMetaFieldNamePrefix: "_meta_",

    maxNumInvalidFieldNameWarnings: 1,
    _numInvalidFieldNameWarningsShown: 0
});

isc.Canvas.addClassMethods({

_validateFieldNames : function (fields, caller) {
    var isForm = isc.isAn.Instance(caller) && caller.getClass().isA(isc.DynamicForm),
        i, field, message;
    for (i = 0; i < fields.length; i++) {
        field = fields[i];

        // Every field must have a name that is a valid JavaScript identifier (except that
        // if the fields are from a DynamicForm (and hence the fields are FormItems) then a
        // field does not need to have a name if its shouldSaveValue property is set to false).
        var valid = ((isForm && field.shouldSaveValue === false && field.name == null) || String.isValidID(field.name));

        if (!valid && isc.Canvas._numInvalidFieldNameWarningsShown++ < isc.Canvas.maxNumInvalidFieldNameWarnings) {
            message = "'" + field.name + "' is not a valid JavaScript identifier. DataSource and " +
                      "DataBoundComponent field names are required to be valid JavaScript identifiers, " +
                      "the syntax for which is specified by ECMA-262 Section 7.6. " +
                      "Note: The String.isValidID(string) function can be used to test whether a string " +
                      "is a valid identifier.";
            if (caller != null) {
                var callerID = isc.isAn.Instance(caller)
                        // For instances, rely on our standard toString() to indicate
                        // caller class and ID.
                        ? "" + caller
                        : isc.Log.echoLeaf(caller);
                message += " This field applied to " + caller + ".";
            }
            if (isc.Canvas._numInvalidFieldNameWarningsShown == isc.Canvas.maxNumInvalidFieldNameWarnings) {
                message += " This will be the last warning.";
            }
            isc.logWarn(message);
        }
    }
},

_makeRuleScopeMetaFieldName : function (fieldName) {
    if (fieldName == null) return null;
    if (!fieldName.contains(".")) return isc.Canvas._ruleScopeMetaFieldNamePrefix + fieldName;
    var lastDot = fieldName.lastIndexOf(".") + 1,
        leader = fieldName.substring(0,lastDot),
        trailer = fieldName.substring(lastDot)
    ;
    return leader +
        (!trailer.startsWith(isc.Canvas._ruleScopeMetaFieldNamePrefix) ? isc.Canvas._ruleScopeMetaFieldNamePrefix : "") +
        trailer;
},

// Returns the preferred owner from two components for contributing to ruleContext.
// For any collision, an editable display (such as a form or editable grid) wins over a
// static display (such as a non-editable grid with a selection). Hidden components have
// lowest priority even if editable. For two editable components the first becomes
// the owner.
getRuleContextPreferredOwnerID : function (owner, dbc) {
    // Prefer visible component
    if (owner.isVisible && !owner.isVisible() && dbc.isVisible && dbc.isVisible()) {
        return dbc.getID();
    }

    // Prefer editable component
    // This is harder than it seems because there are multiple ways to
    // disable editing on a component and no single way to check it.
    var isEditable = function (component) {
        if (component.isDisabled()) return false;
        if (isc.isA.DynamicForm(component)) {
            // A form is editable unless canEdit:false
            return (component.canEdit != false);
        } else if (isc.isA.ListGrid(component)) {
            // A grid is editable if canEdit:true
            return component.canEdit;
        }
        return false;
    };
    if (!isEditable(owner) && isEditable(dbc)) {
        return dbc.getID();
    }
    // New dbc is not preferred from an editibility standpoint.
    // Prefer a DynamicForm over other components.
    if (!isc.isA.DynamicForm(owner) && isc.isA.DynamicForm(dbc)) {
        return dbc.getID();
    }

    return owner.getID();
},

// Get source for ruleContext contribution from component.
// "values" for a DynamicForm, "selectedRecord" from grid, etc.
getRuleScopeSourceFromComponent : function (component) {
    for (var className in isc.Canvas._dbcTypeDetails) {
        if (component.isA(className)) {
            return isc.Canvas._dbcTypeDetails[className].criteriaBasePathSuffix;
        }
    }
    return null;
},

getFieldImageDimensions : function (field, record) {
    var width, height;

    // if any of field.imageWidth/Height/Size are set as strings, assume they are property
    // names on the record
    var imageWidthProperty, imageHeightProperty, imageSizeProperty;
    if (isc.isA.String(field.imageWidth)) {
        imageWidthProperty = field.imageWidth;
    } else {
        width = field.imageWidth;
    }
    if (isc.isA.String(field.imageHeight)) {
        imageHeightProperty = field.imageHeight;
    } else {
        height = field.imageHeight;
    }
    if (isc.isA.String(field.imageSize)) {
        imageSizeProperty = field.imageSize;
    } else {
        width = width || field.imageSize;
        height = height || field.imageSize;
    }

    if (record != null) {
        width = width || record[imageWidthProperty] || record[imageSizeProperty];
        height = height || record[imageHeightProperty] || record[imageSizeProperty];
    }

    return { width: width, height: height };
},

// Generic values management for mapping fieldNames or dataPaths to values within a values object.
// Implemented at the DBC level as static methods as this is used across dataBoundComponents,
// and also by ValuesManager.  NOTE: refactored the three methods _get, _save and _clear so
// that they all work via the common method _performActionOnValue.  This isn't a perfect
// factoring, but it avoids triplication of the code required to navigate a dataPath to
// locate the value to operate on (refactored at the same time that navigation code was made
// rather more complicated, to cope with lists-within-lists)
// Params:
// action - one of 'get', 'clear', 'save', or 'hasValue'
// fieldName - field name or dataPath pointing to the entry
// field - field object - may be null. If present used to extract type info for custom
//         simple type data manipulation
// values - values object we're acting upon
// component - component containing this values object. Used to customize some behavior
//             with valuesManagers as documented inline
// useFirstEntryImplicitly - boolean flag indicating if we're getting an object and it's
//             embedded in an array but either:
//             - we're expecting a single object, or
//             - we're expecting to find a a valid selection in a bound selectionComponent,
//               and there isn't one
//             then we should just use the first entry.  Note, this is accomplished by calling
//             the static method isc.Canvas.deriveImplicitArrayEntry, the default impl of which
//             simply returns 0.  It is possible to achieve more sophisticated list entry
//             derivation by overriding this method.
// value - new value (if action is "set")
// skipExtraCheck - flag to avoid an endless loop

_performActionOnValue : function(action, fieldName, field,
                                values, component,
                                 useFirstEntryImplicitly, value, skipExtraCheck,
                                 record, reason)
{
    if (!values || fieldName == null || isc.isAn.emptyString(fieldName)) return;

    //this.logWarn("_performActionOnValue with fieldName: " + isc.echoFull(fieldName));

    var originalValues = values;

    var separator = this._$slash;
    var isDataPath = fieldName.contains(separator);

    if (!isDataPath) {
        separator = this._$dot;
        isDataPath = fieldName.contains(separator);
    }
    if (isDataPath) {
        fieldName = fieldName.trim(separator);
        var segments = fieldName.split(separator),
            nestedVals = [],
            undef;


        // NOTE: The skipExtraCheck flag is to ensure that we don't go into an endless
        // recursion loop in the case where the dataPath and the supplied value just don't
        // match
        if (segments[0] && values[segments[0]] === undef &&
            (action == "get" || action == "hasValue") && !skipExtraCheck)
        {
            if (component && isc.ValuesManager && isc.isA.ValuesManager(component.valuesManager))
            {
                return this._performActionOnValue(action, fieldName, field,
                                                  component.valuesManager.getValues(),
                                                  component,
                                                  useFirstEntryImplicitly, value, true,
                                                  record || values, reason);
            }
        }
        if (isc.isAn.emptyString(segments.last())) segments.length -= 1;
        for (var i = 0; i < segments.length; i++) {
            if (isc.isAn.emptyString(segments[i])) continue;
            // handle the case where we don't have a nested value for this path
            if (values == null) {
                nestedVals.length = 0;
                break;
            }
            nestedVals.add(values);
            // If we've reached the end of the path, act upon the result.
            if (i == segments.length-1) {
                if (action == "get") {
                    if (field != null && field.type != null) {
                        var simpleType = isc.SimpleType.getType(field.type);
                        if (simpleType && simpleType.getAtomicValue &&
                                values[segments[i]] !== undef)
                        {
                            return simpleType.getAtomicValue(values[segments[i]], reason);
                        }
                    }
                    return values[segments[i]];
                } else if (action == "clear") {
                    delete values[segments[i]];
                } else if (action == "save") {
                    if (field != null && field.type != null) {
                        var simpleType = isc.SimpleType.getType(field.type);
                        if (simpleType && simpleType.updateAtomicValue) {
                            var updateResult = simpleType.updateAtomicValue(value, values[segments[i]], reason);
                            if (updateResult != null) return updateResult;
                        }
                    }

                    values[segments[i]] = value;
                } else if (action == "hasValue") {
                    return segments[i] in values;
                }

            // Otherwise reach into the next nested object, then continue in the for-loop
            } else {
                var newValues = values[segments[i]];

                // If the value is undefined, we have been asked to get or set a dataPath
                // that doesn't exist.  For get or clear, just return null.  For save, we need
                // to build up the missing dataPath as we go.
                if (newValues == undef) {
                    if (action == "get") {
                        return undef;
                    } else if (action == "clear") {
                        return;
                    } else if (action == "save") {
                        newValues = values[segments[i]] = {};
                    } else if (action == "hasValue") {
                        return false;
                    }
                }
                values = newValues;

                // If the value is an array, we are about to traverse a multiple: true part of
                // the object hierarchy, so we need to decide which of the multiple items to
                // follow
                if (isc.isAn.Array(values)) {
                    var index = null;
                    // If the next element in the dataPath is an index, use that
                    var nextIsIndex = (parseInt(segments[i+1]) == segments[i+1]);
                    if (nextIsIndex) {
                        index = parseInt(segments[i+1]);
                        segments.removeAt(i+1);
                    // Otherwise, try to derive a selected record from the chain of
                    // selectionComponents
                    } else if (component && component.selectionComponent) {
                        var path = separator,
                            selComponent = component,
                            foundNullSelection;
                        for (var j = 0; j <= i; j++) {
                            path += segments[j] + separator;
                        }
                        path = path.trim(separator);
                        selComponent = component.selectionComponent;
                        while (selComponent) {
                            var componentPath = selComponent.dataPath;
                            if (componentPath) componentPath = componentPath.trim(separator);
                            if (path == componentPath) {
                                var sel = selComponent.getSelectedRecord();
                                if (sel) {

                                    for (var k = 0; k < values.length; k++) {
                                        if (sel == values[k]) {
                                            index = k;
                                            break;
                                        }
                                    }
                                    if (index == null) {
                                        // ASSERT: This should never happen
                                        isc.logWarn("At dataPath " + fieldName + ", there was " +
                                            "a selectionComponent with a valid selected record " +
                                            "but we could not find that record in the VM's " +
                                            "data.  Falling back to row derivation behavior");
                                    }
                                } else {
                                    // If we get here, we have found a valid path through the
                                    // data model, based on a selectionComponent, but
                                    // currently there is nothing selected in that component.
                                    // In this case, we want downstream components to reflect
                                    // that by containing nothing; it's only if we couldn't
                                    // find a valid path through the data model that we fall
                                    // back to using the first record
                                    foundNullSelection = true;
                                }
                                break;
                            }
                            selComponent = selComponent.selectionComponent;
                        }

                        if (index == null) {
                            if (!foundNullSelection && useFirstEntryImplicitly) {
                                index = isc.Canvas.deriveImplicitArrayEntry(action, fieldName,
                                            field, values, component, segments, i, record);
                            } else {
                                return;
                            }
                        }
                    } else {
                        // Nothing else for it...
                        if (useFirstEntryImplicitly) {
                            index = 0;
                        } else {
                            return;
                        }
                    }
                    values = values[index];
                }
            }
        }
        // In clear mode, if we have a nested values object like this:
        //  {foo:{ moo: {zoo:"a"} } }
        // in addition to deleting the zoo attribute from the moo object we may as well clear up
        // the empty object stored under foo.moo
        if (action == "clear") {
            for (var i = nestedVals.length-1; i > 0; i--) {
                if (isc.isAn.emptyObject(nestedVals[i])) {
                    delete nestedVals[i-1][segments[i-1]];
                }
            }
        }
    } else {
        if (action == "get") {
            if (field != null && field.type != null) {
                var simpleType = isc.SimpleType.getType(field.type);
                if (simpleType && simpleType.getAtomicValue  &&
                     values[fieldName] !== undef)
                {
                    return simpleType.getAtomicValue(values[fieldName], reason);
                }
            }
            return values[fieldName];
        } else if (action == "clear") {
            delete values[fieldName];
        } else if (action == "save") {
            if (field != null && field.type != null) {
                var simpleType = isc.SimpleType.getType(field.type);
                if (simpleType && simpleType.updateAtomicValue) {
                    var updateResult = simpleType.updateAtomicValue(value, values[fieldName], reason);
                    if (updateResult != null) return updateResult;
                }
            }

            values[fieldName] = value;
        } else if (action == "hasValue") {
            return fieldName in values;
        }
    }
},

deriveImplicitArrayEntry : function(action, fieldName, field, values, component, segments, i, record) {
    return 0;
},

// _clearValue
// Clears the value for some field from a values object
// Handles datapath / nested values

_$slash:"/",
_$dot:".",
_clearFieldValue : function (field, values, component, useFirstEntryImplicitly)
{
    var dataPath = field;
    if (isc.isAn.Object(field) && !isc.isA.Date(field)) {
        dataPath = this._getDataPathFromField(field, component);
    } else {
        // If we were passed a string, don't pass it into pAOV as the field param - otherwise
        // that method would have to check for the param being a non-null non-object.
        field = null;
    }
    this._performActionOnValue("clear", dataPath, field, values, component, useFirstEntryImplicitly,
            null, false);
},

// _saveValue
// Updates some values object with a new field value.

_saveFieldValue : function (dataPath, field, value, values, component, useFirstEntryImplicitly, reason) {
    // if dataPath wasn't explicitly passed, pick it up from the field object
    if (dataPath == null && field != null) dataPath = this._getDataPathFromField(field, component);

    this._performActionOnValue("save", dataPath, field, values, component, useFirstEntryImplicitly,
        value, false, null, reason);

    return values;
},

_getDataPathFromField : function (field, component) {
    var dataPath;
    if (field.dataPath) {
        dataPath = field.dataPath;

        if (component) {
            dataPath = this._trimDataPath(field.dataPath, component);
        }
    } else {
        dataPath = field.name;
    }
    return dataPath;
},

// _getFieldValue() retrieves a field value from some values object
// handles being passed a datapath to navigate nested values objects
// We also pass in the component that is bound to / trying to bind to the value in question.
// This is necessary in the case of lists-within-lists, because such data structures can
// only sensibly be said to have a value if we know which of the items in the outer list
// is currently selected - passing in the component allows us to walk up its chain of
// selectionComponents (assuming item 0 where there is none)
_getFieldValue : function (dataPath, field, values, component, useFirstEntryImplicitly, reason)
{
    // if dataPath wasn't explicitly passed, pick it up from the field object
    if (dataPath == null && field != null) dataPath = this._getDataPathFromField(field, component);
    return this._performActionOnValue("get", dataPath, field, values, component,
            useFirstEntryImplicitly, null, false, null, reason);
},

_fieldHasValue : function (dataPath, field, values, component, useFirstEntryImplicitly, reason)
{
    // if dataPath wasn't explicitly passed, pick it up from the field object
    if (dataPath == null && field != null) dataPath = this._getDataPathFromField(field, component);
    return this._performActionOnValue("hasValue", dataPath, field, values, component,
            useFirstEntryImplicitly, null, false, null, reason);
},

// This method trims the component's dataPath off of the field, if the field dataPath reiterates
// it.  This puts the field dataPath in the correct context, since this ListGrid's data member
// will be the List of records corresponding to a multiple:true subfield of the overall data
// structure, NOT the overall data structure itself
_trimDataPath : function (dataPathParam, component) {
    if (!dataPathParam) return dataPathParam;
    var dataPath = dataPathParam.trim(isc.Canvas._$slash);
    if (!dataPath.contains(isc.Canvas._$slash)) return dataPathParam;
    var compDataPath = component.getFullDataPath();
    if (compDataPath == null || compDataPath == "") return dataPath;
    compDataPath = compDataPath.trim(isc.Canvas._$slash);
    var left = compDataPath.split(isc.Canvas._$slash);
    var right = dataPath.split(isc.Canvas._$slash);
    for (var i = 0; i < left.length; i++) {
        if (left[i] != right[i]) {
            break;
        }
    }

    if (i == 0) return dataPathParam;

    var trimmedDataPath = "";
    for (var j = i; j < right.length; j++) {
        trimmedDataPath += right[j];
        trimmedDataPath += "/";
    }
    // Remove the trailing slash from the return value
    return trimmedDataPath.substring(0, trimmedDataPath.length-1);
},

_combineDataPaths : function (baseDP, dp) {

    if (baseDP == null && dp == null) return null;

    // If dp starts with a slash, it is absolute and standalone
    if (isc.isA.String(dp) && dp.startsWith(this._$slash)) return dp;

    // if either param is empty just typecast the other to a string (may be required for
    // index within an array) and return!
    if (baseDP == null) return "" + dp;
    if (dp == null) return baseDP + "";

    if (isc.isA.String(baseDP) && baseDP.endsWith(this._$slash)) {
        return baseDP + dp;
    } else {
        return baseDP + this._$slash + dp;
    }
},

//> @attr dataBoundComponent.deepCloneOnEdit (Boolean : null : IRWA)
// Before we start editing values in this DataBoundComponent, should we perform a deep clone
// of the underlying values.  See +link{dataSource.deepCloneOnEdit} for details of what this means.
// <p>
// If this value is not explicitly set, it defaults to the value of +link{dataSource.deepCloneOnEdit}.
// This value can be overridden per-field with +link{dataSourceField.deepCloneOnEdit}.
// <p>
// Like the other <code>deepCloneOnEdit</code> settings, this flag only has an effect if you are
// editing a values object that contains nested objects or arrays, using
// +link{Canvas.dataPath,dataPath}s.
//
// @see canvas.dataPath
// @see formItem.dataPath
// @see dataSourceField.deepCloneOnEdit
// @see dataSource.deepCloneOnEdit
// @visibility external
//<

// _duplicateValues(): Take a values object and duplicate it
// This is a recursive duplication following dataPaths to duplicate nested objects.
// We do this when we start editing a record in DF or VM.
// This means that when the user makes changes to the values for items we don't update the
// original values object passed in directly.

// Params:
// - component - component doing the editing - DynamicForm or ValuesManager.  This can be
//               null, to allow safe recursive duplication of data structures that are not
//               currently linked to a component
// - values - record to duplicate
// - targetVals - object to drop the cloned values into - basically an empty object that the
//   calling code would apply as this.values or this._oldValues or whatever
// - defaultPaths - array of strings.
//   Used when "rememberValues" is running -- for each value in the
//   values object passed in, test whether its actually set to the default for some item in the
//   edit-component. If so hang onto the dataPath for this item in the "defaultPaths" array.
//   If defaultPaths is not passed in we don't hang onto this information.


_duplicateValues : function (component, values, targetVals, defaultPaths) {
    var ds = component ? component.getDataSource() : null;
    // no need for a returnVal - we've updated the targetVals object directly.
    this._cloneComponentValues(component, targetVals, values, ds, null, defaultPaths);
},

_cloneComponentValues : function (component, storedValues, values, dataSource,
                                  dataPath, defaultPaths, dupList) {

    if (values == null) return;
    var getDefaults = (defaultPaths != null);

    var dsDeepClone = component ? component.deepCloneOnEdit : null;
    if (dsDeepClone == null) dsDeepClone = dataSource ? dataSource.deepCloneOnEdit : null;
    var deepClone = dsDeepClone == null ?

                        (isc.DataSource ? isc.DataSource.deepCloneOnEdit : dsDeepClone)
                                          : dsDeepClone;

    // handle being passed an array as both the 'stored' object and the 'values' object
    // This allows recursive, safe cloning of arrays
    if (isc.isAn.Array(values)) {
        for (var i = 0; i < values.length; i++) {
            var value = values[i];
            if (isc.isA.Function(value)) continue;
            if (isc.isAn.Instance(values[prop]) || isc.isA.Class(values[prop])) continue;

            if (value == null || isc.isA.String(value) || isc.isA.Boolean(value) ||
                isc.isA.Number(value))
            {
                storedValues[storedValues.length] = value;

            } else if (isc.isA.Date(value)) {
                storedValues[storedValues.length] = new Date(value.getTime());

            } else if (isc.isAn.Object(value)) {
                var targetObj;
                if (isc.isAn.Array(value)) {
                    targetObj = storedValues[storedValues.length] = [];
                } else {
                    targetObj = storedValues[storedValues.length] = {};
                }
                this._cloneComponentValues(
                    component,
                    targetObj,
                    value,
                    dataSource,
                    (getDefaults ? dataPath : null),
                    defaultPaths
                );
            }
        }
        return;
    }


    if (values._isc_tree != null) {
        values = isc.JSONEncoder._serialize_cleanNode(values);
    }



    var propertiesToSkip = {
        __ref: true,
        __module: true
    };

    if (isc.DataSource && isc.DataSource.cloneValuesSafely) {
        if (!dupList) dupList = [];
        if (dupList.contains(values)) {
            storedValues = values;
            return;
        }
        dupList.add(values);
    }

    for (var prop in values) {
        if (isc.isA.Function(values[prop])) continue;

        if (propertiesToSkip[prop] == true) continue;


        if (isc.Browser.isSGWT && window.SmartGWT.isNativeJavaObject(values[prop])) continue;

        // Skip instances and classes

        if (isc.isAn.Instance(values[prop]) || isc.isA.Class(values[prop])) continue;

        // When this is running in rememberValues we want to remember defaults
        // Otherwise we can skip the dataPath stuff entirely here
        var fullDataPath;
        if (getDefaults) {

            if (dataPath) {
                fullDataPath = dataPath + prop;
            } else {
                fullDataPath = prop;
            }

            var item;

            if (component && component.getItem) item = component.getItem(fullDataPath);
            if (item && item.isSetToDefaultValue()) {
                defaultPaths.add(fullDataPath);
            }
        }

        // Special case for dates - duplicate them rather than copying the object
        // across
        var propValue = values[prop];
        if (isc.isA.Date(propValue)) {
            storedValues[prop] = propValue.duplicate();

        } else if (isc.isAn.Object(propValue) && !isc.isAn.Array(propValue)) {



            // Shallow-clone objects that do not have a corresponding DataSourceField.
            var field = dataSource ? dataSource.getField(prop) : null;
            if (!field) {
                storedValues[prop] = values[prop];

            } else {
                // If a field is of a SimpleType with a custom "duplicate" method call it to
                // duplicate the value.
                // This will allow for duplication / editing of "opaque" types where
                // a getAtomicValue / updateAtomicValue method is present.
                var type = isc.SimpleType.getType(field.type);
                if (type && type.duplicate) {
                    storedValues[prop] = type.duplicate(values[prop]);

                // Only deep-clone objects corresponding to fields that have deepCloneOnEdit
                // set (or inherited from the DataSource or from the static setting on
                // isc.DataSource)
                } else if (field.deepCloneOnEdit == true ||
                       (field.deepCloneOnEdit == null && deepClone))
                {
                    // If the global DataSource flag "cloneValuesSafely" is set, keep track
                    // of objects we've seen before and shallow clone any duplicates
                    if (isc.DataSource && isc.DataSource.cloneValuesSafely) {
                        if (dupList.contains(propValue)) {
                            storedValues[prop] = values[prop];
                            continue;
                        }
                        dupList.add(propValue);
                    }
                    storedValues[prop] = {};
                    this._cloneComponentValues(component, storedValues[prop], propValue,
                        isc.DataSource ? isc.DataSource.get(field.type) : null,
                        getDefaults ? (fullDataPath + isc.Canvas._$slash) : null,
                        defaultPaths, dupList);
                } else {
                    storedValues[prop] = values[prop];
                }
            }


        } else if (isc.isAn.Array(propValue)) {
            var field = dataSource ? dataSource.getField(prop) : null;
            if (!field) {
                storedValues[prop] = values[prop];
            } else {
                // handle an array of opaque SimpleType objects with a custom "duplicate" method
                var type = isc.SimpleType.getType(field.type);
                if (type && type.duplicate) {
                    var newArray = [];
                    for (var i = 0; i < storedValues[prop]; i < storedValues[prop].length) {
                        newArray[i] = type.duplicate(storedValues[prop][i]);
                    }

                } else if (field.deepCloneOnEdit == true ||
                       (field.deepCloneOnEdit == null && deepClone))
                {
                    if (isc.DataSource && isc.DataSource.cloneValuesSafely) {
                        if (dupList.contains(propValue)) {
                            storedValues[prop] = values[prop];
                            continue;
                        }
                        dupList.add(propValue);
                    }

                    storedValues[prop] = [];
                    this._cloneComponentValues(component, storedValues[prop], propValue,
                        isc.DataSource ? isc.DataSource.get(field.type) : null,
                        getDefaults ? (fullDataPath + isc.Canvas._$slash) : null,
                        defaultPaths, dupList);
                } else {
                    storedValues[prop] = values[prop];
                }
            }
        } else {
            storedValues[prop] = values[prop];
        }
    }
},

// evalViewState
// defined at the class level so we can call it from anywhere (Used in ResultTree)
evalViewState : function (state, stateName, suppressWarning, target) {
    //!OBFUSCATEOK
    if (isc.isA.String(state)) {
        var origState = state;
        try {
            state = isc.eval(state);
        } catch (e) {
            if (!suppressWarning) {
                var warning = "Unable to parse " + stateName + " object passed in: " +
                              isc.Log.echo(origState) + " Ignoring."
                if (!target || target.logWarn == null) {
                    if (target) warning += " [target:" + isc.Log.echo(target) + "]";
                    this.logWarn(warning);
                } else {
                    target.logWarn(warning);
                }
            }
            return;
        }
    }
    return state;
},

// Format a number, 'value', as a String.  This method implements formatting
// for data source fields of type "float" or "integer", considering the specified
// precision property set on the field.
// @param value (any) the value to be formatted
// @param [precision] (number) an integer to limit the number of significant digits
// @param [type] (string) type of the field
// @param [dontUseDefault] (boolean) whether to return null if `value` is not specified or
// return a formatted, default value
// @see dataSourceField.precision
getNumberValueAsString : function (value, precision, type, dontUseDefault) {
    // Assign default values to the arguments if they are invalid
    if (!isc.isA.Number(value)) {
        if (dontUseDefault) {
            return null;
        }
        value = isc.DataSource._getDefaultValueForFieldType(type);
    }
    if (!isc.isA.Number(precision) || precision <= 0) {
        precision = null;
    }
    if (precision != null) {
        precision = this._filterFieldValueAndWarn(precision, 1, 21, "precision");

        return isc.NumberUtil._expandExponent(value.toPrecision(precision));
    } else {
        return isc.DataSource._getTypedValueAsString(value, type);
    }
},

// Format a floating point number, `value`, as a string.  This method implements formatting
// for data source fields of type "float", considering the specified decimalPrecision and
// decimalPad properties set on the field.
// @param value (any) the value to be formatted
// @param [decimalPrecision] (number) an integer to limit the number of decimal digits
// @param [decimalPad] (number) an integer to fix the number of decimal digits
// @param [dontUseDefault] (boolean) whether to return null if `value` is not specified or
// return a formatted, default value
// @see dataSourceField.decimalPrecision
// @see dataSourceField.decimalPad
getFloatValueAsString : function (value, decimalPrecision, decimalPad, dontUseDefault) {
    // Assign default values to the arguments if they are invalid
    if (!isc.isA.Number(value)) {
        if (dontUseDefault) {
            return null;
        }
        value = isc.DataSource._getDefaultValueForFieldType("float");
    }
    if (!isc.isA.Number(decimalPrecision) || decimalPrecision < 0) {
        decimalPrecision = null;
    }
    if (!isc.isA.Number(decimalPad) || decimalPad < 0) {
        decimalPad = null;
    }

    if (decimalPrecision != null && decimalPad != null) {
        // Pad to the shorter of decimalPrecision and decimalPad if they are both
        // specified.
        if (decimalPrecision < decimalPad) {
            decimalPad = decimalPrecision;
        }
        decimalPrecision = null;
    }

    if (decimalPad != null) {
        decimalPad = this._filterFieldValueAndWarn(decimalPad, 0, 20, "decimalPad");
        return value.toFixed(decimalPad);
    } else if (decimalPrecision != null) {
        var pow10 = Math.pow(10, decimalPrecision);
        var roundedValue = Math.round(value * pow10)/pow10;
        return isc.DataSource._getTypedValueAsString(roundedValue, "float");
    } else {
        return isc.DataSource._getTypedValueAsString(value, "float");
    }
},

_filterFieldValueAndWarn : function (value, min, max, fieldName) {
    var limit;
    if      (value < min) limit = min;
    else if (value > max) limit = max;
    else return value;
    this.logWarn("Ignoring invalid value " + value + " for " + fieldName);
    return limit;
},

// Returns a list of DataSources from the ruleScope component. Uses
// DS of DBC which is databound and auto-generates a DS for non-databound
// components. The DS or auto-gen'd DS for the targetRuleScope component
// is excluded.
getRuleScopeDataSources : function (targetRuleScope) {
    if (!targetRuleScope) return [];
    targetRuleScope = (isc.isA.String(targetRuleScope) ? window[targetRuleScope] : targetRuleScope);
    if (!targetRuleScope.getRuleScopeDataBoundComponents) return [];
    var dataSources = [],
        dbcList = targetRuleScope.getRuleScopeDataBoundComponents()
    ;
    for (var i = 0; i < dbcList.length; i++) {
        if (dbcList[i] == targetRuleScope) {
            continue;
        }
        if (dbcList[i].dataSource) {
            if (!dataSources.contains(dbcList[i].dataSource)) {
                dataSources.add(dbcList[i].dataSource);
            }
        }
        if (dbcList[i] != targetRuleScope) {
            // Auto-generate
            dataSources.add(dbcList[i].makeDataSourceFromFields(dbcList[i].ID));
        }
    }
    return dataSources;
},

// Same as getRuleScopeDataSource except targetRuleScope component DS
// is included in list.
getAllRuleScopeDataSources : function (targetRuleScope) {
    var currentForm = (isc.isA.String(targetRuleScope) ? window[targetRuleScope] : targetRuleScope),
        currentFormDS = (currentForm.getDataSource ? currentForm.getDataSource() : null)
    ;
    if (!currentFormDS && isc.isA.DataBoundComponent(currentForm)) {
        currentFormDS = currentForm.makeDataSourceFromFields();
    }

    var dataSources = isc.Canvas.getRuleScopeDataSources(currentForm);
    if (currentFormDS) {
        dataSources.addAt(currentFormDS, 0);
    }
    return dataSources;
},

// Returns map of ruleScope dataSources->ownerID. Applies same rules
// for choosing an owner from conflicting contributors as writing to
// ruleContext.
getRuleScopeDataSourceOwners : function (targetRuleScope) {
    if (!targetRuleScope) return {};
    targetRuleScope = (isc.isA.String(targetRuleScope) ? window[targetRuleScope] : targetRuleScope);
    if (!targetRuleScope.getRuleScopeDataBoundComponents) return {};
    var dataSources = [],
        dbcList = targetRuleScope.getRuleScopeDataBoundComponents(),
        owners = {}
    ;
    for (var i = 0; i < dbcList.length; i++) {
        if (dbcList[i] != targetRuleScope && dbcList[i].dataSource) {
            var dbc = dbcList[i],
                dbcID = dbc.getID(),
                owner = owners[dbc.dataSource.ID]
            ;
            if (owner) {
                // Have seen this DS before. Resolve conflict to identify which DBC is the owner
                if (isc.Canvas.getRuleContextPreferredOwnerID(owner, dbc) == dbcID) {
                    owners[dbc.dataSource.ID] = dbc;
                }
            } else {
                // Initial owner
                owners[dbc.dataSource.ID] = dbc;
            }
        }
    }
    return owners;
}


});

isc.Canvas.addProperties({

_resolveEmptyDisplayValue : function (field) {

    var emptyVal = field.emptyCellValue;
    if (emptyVal == null) emptyVal = field.emptyDisplayValue;

    // Back off to the empty value for the widget as a whole
    if (emptyVal == null) emptyVal = this.emptyCellValue;

    return emptyVal;
},

//>    @attr dataBoundComponent.dataSource        (DataSource or ID : null : IRW)
// The DataSource that this component should bind to for default fields and for performing
// +link{DSRequest,DataSource requests}.
// <P>
// Can be specified as either a DataSource instance or the String ID of a DataSource.
//
// @group databinding
// @visibility external
// @example dataSourceFields
//<

//> @attr dataBoundComponent.dataFetchMode (FetchMode : "paged" : IR)
// How to fetch and manage records retrieve from the server.  See +link{type:FetchMode}.
// <P>
// This setting only applies to the +link{ResultSet} automatically created by calling
// +link{listGrid.fetchData,fetchData()}.  If a pre-existing ResultSet is passed to setData() instead, it's
// existing setting for +link{resultSet.fetchMode} applies.
//
// @group databinding
// @visibility external
//<

//> @attr dataBoundComponent.dataPageSize (integer : null : IRW)
// When using +link{dataFetchMode,data paging}, how many records to fetch at a time.  If set to
// a positive integer, <code>dataPageSize</code> will override the default
// +link{resultSet.resultSize,resultSize} for ResultSets automatically created when you call
// +link{fetchData()} (and similarly for the +link{resultTree.resultSize,resultSize} of
// ResultTrees).  Leaving <code>dataPageSize</code> at its default means to just use the default page
// size of the data container.
// <P>
// <b>Note</b> that regardless of the <code>dataPageSize</code> setting, a component will always fetch
// all of data that it needs to draw.  Settings such as
// +link{listGrid.showAllRecords,showAllRecords:true},
// +link{listGrid.drawAllMaxCells,drawAllMaxCells} and
// +link{listGrid.drawAheadRatio,drawAheadRatio} can cause more rows than the configured
// <code>dataPageSize</code> to be fetched.
//
// @group databinding
// @see ResultSet.resultSize
// @visibility external
//<

//>    @attr dataBoundComponent.fields            (Array of Field : null : IRW)
// A DataBoundComponent manipulates records with one or more fields, and
// <code>component.fields</code> tells the DataBoundComponent which fields to present, in what
// order, and how to present each field.
// <p>
// When both <code>component.fields</code> and
// <code>+link{dataBoundComponent.dataSource,component.dataSource}</code> are set,
// any fields in <code>component.fields</code> with the same name as a DataSource field
// inherit properties of the DataSource field.  This allows you to centralize data model
// information in the DataSource, but customize presentation of DataSource fields on a
// per-component basic.  For example, in a ListGrid, a shorter title or format for a field
// might be chosen to save space.
// <p>
// By default, only fields specified on the component are shown, in the order specified on
// the component.  The +link{useAllDataSourceFields} flag can be set to show all fields
// from the DataSource, with <code>component.fields</code> acting as field-by-field
// overrides and/or additional fields.
// <p>
// If a DataBoundComponent is given a DataSource, but no <code>component.fields</code>, the
// "default binding" is used: fields are shown in DataSource order, according
// to the properties <code>+link{showHiddenFields}</code> and
// <code>+link{showDetailFields}</code>.
//
// @group databinding
// @visibility external
// @example mergedFields
// @example validationFieldBinding
//<

//>    @attr dataBoundComponent.useAllDataSourceFields        (boolean : false : IRW)
// If true, the set of fields given by the "default binding" (see
// +link{attr:DataBoundComponent.fields}) is used, with any fields specified in
// <code>component.fields</code> acting as overrides that can suppress or modify the
// display of individual fields, without having to list the entire set of fields that
// should be shown.
// <P>
// If <code>component.fields</code> contains fields that are not found in the DataSource,
// they will be shown after the most recently referred to DataSource field.  If the new
// fields appear first, they will be shown first.
// <P>
// +explorerExample{validationFieldBinding,This example} shows a mixture of component
// fields and DataSource fields, and how they interact for validation.
// <P>
// This setting may be cleared if a +link{FieldPicker} is used to edit the component's field
// order.
//
// @group databinding
// @visibility external
// @example validationFieldBinding
// @see fieldPicker.dataBoundComponent
//<

//>    @attr dataBoundComponent.showHiddenFields (boolean : false : IRW)
// Whether to show fields marked <code>hidden:true</code> when a DataBoundComponent is given a
// DataSource but no <code>component.fields</code>.
// <p>
// The <code>hidden</code> property is used on DataSource fields to mark fields that are
// never of meaning to an end user.
//
// @group databinding
// @visibility external
//<

//>    @attr dataBoundComponent.showDetailFields (boolean : false : IRW)
// Whether to show fields marked <code>detail:true</code> when a DataBoundComponent is
// given a DataSource but no <code>component.fields</code>.
// <p>
// The <code>detail</code> property is used on DataSource fields to mark fields that
// shouldn't appear by default in a view that tries to show many records in a small space.
//
// @group databinding
// @visibility external
//<

//>    @attr dataBoundComponent.showComplexFields (boolean : true : IRWA)
// Whether to show fields of non-atomic types when a DataBoundComponent is given a
// DataSource but no <code>component.fields</code>.
// <p>
// If true, the component will show fields that declare a complex type, for example, a
// field 'shippingAddress' that declares type 'Address', where 'Address' is the ID of a
// DataSource that declares the fields of a shipping address (city, street name, etc).
// <P>
// Such fields may need custom formatters or editors in order to create a usable interface,
// for example, an Address field in a ListGrid might use a custom formatter to combine the
// relevant fields of an address into one column, and might use a pop-up dialog for
// editing.
//
// @group databinding
// @visibility external
//<
showComplexFields:true,

//>    @attr dataBoundComponent.fetchOperation (String : null : IRW)
// +link{dsRequest.operationId,operationId} this component should use when performing fetch operations.
// @group operations
// @visibility external
//<
setFetchOperation : function(operationId) {
    this.fetchOperation = operationId;
    // This is specific to DynamicForm
    if (this._propagateOperationsToFileItem) this._propagateOperationsToFileItem();
},

//>    @attr dataBoundComponent.updateOperation (String : null : IRW)
// +link{dsRequest.operationId,operationId} this component should use when performing update operations.
// @group operations
// @visibility external
//<
setUpdateOperation : function(operationId) {
    this.updateOperation = operationId;
    if (this._propagateOperationsToFileItem) this._propagateOperationsToFileItem();
},

//>    @attr dataBoundComponent.addOperation (String : null : IRW)
// +link{dsRequest.operationId,operationId} this component should use when performing add operations.
// @group operations
// @visibility external
//<
setAddOperation : function(operationId) {
    this.addOperation = operationId;
    if (this._propagateOperationsToFileItem) this._propagateOperationsToFileItem();
},

//>    @attr dataBoundComponent.removeOperation (String : null : IRW)
// +link{dsRequest.operationId,operationId} this component should use when performing remove operations.
// @group operations
// @visibility external
//<
setRemoveOperation : function(operationId) {
    this.removeOperation = operationId;
    if (this._propagateOperationsToFileItem) this._propagateOperationsToFileItem();
},

//> @attr dataBoundComponent.validateOperation (String : null : IRW)
// +link{dsRequest.operationId,operationId} this component should use when performing validate operations.
// @group operations
//<

//> @attr dataBoundComponent.exportFields (Array of String : null : IRW)
// The list of field-names to export.  If provided, the field-list in the exported output is
// limited and sorted as per the list.
// <P>
// If exportFields is not provided, the exported output includes all visible fields
// from this component, sorted as they appear.
//
// @visibility external
//<

//> @attr dataBoundComponent.exportAll (boolean : false : IRW)
// Setting exportAll to true prevents the component from passing it's list of fields to the
// export call.  The result is the export of all visible fields from +link{dataSource.fields}.
// <P>
// If exportAll is false, an export operation will first consider
// +link{dataBoundComponent.exportFields}, if it's set, and fall back on all visible fields from
// +link{dataSource.fields} otherwise.
//
// @visibility external
//<

//> @attr dataBoundComponent.exportIncludeSummaries (boolean : true : IRW)
// If Summary rows exist for this component, whether to include them when exporting client data.
//
// @visibility external
//<
exportIncludeSummaries: true,


ignoreEmptyCriteria: true,

//> @type RecategorizeMode
// Type for controlling when a "recategorize" is applied to records being dropped
// on a databound component from another databound component.
//
// @value "always" recategorize is always applied
// @value "checked" recategorize if normal checks pass
// @value "never" never recategorize
// @visibility external
//<

//> @attr dataBoundComponent.dragRecategorize (RecategorizeMode : "checked" : IRW)
// Flag controlling when to recategorize records being dropped on a databound
// component from another databound component.
// @visibility external
//<

dragRecategorize: "checked",

//> @attr dataBoundComponent.preventDuplicates (boolean : null : IR)
// If set, detect and prevent duplicate records from being transferred to this component, either via
// drag and drop or via +link{transferSelectedData()}.  When a duplicate transfer is detected,
// a dialog will appear showing the +link{duplicateDragMessage}.
// <P>
// If the component either does not have a +link{DataSource} or has a DataSource with no
// +link{dataSourceField.primaryKey,primaryKey} declared, duplicate checking is off by
// default.  If duplicate checking is enabled, it looks for an existing record in the dataset
// that has <b>all</b> of the properties of the dragged record, and considers that a duplicate.
// <P>
// For +link{dragDataAction}:"copy" where the target DataSource is related to the source
// DataSource by foreignKey, a duplicate means that the target list, as filtered by the current
// criteria, already has a record whose value for the foreignKey field matches the
// primaryKey of the record being transferred.
// <P>
// For example, consider dragging "employees" to "teams", where "teams" has a field
// "teams.employeeId" which is a foreignKey pointing to "employees.id", and the target
// grid has search criteria causing it to show all the members of one team.  A duplicate -
// adding an employee to the same team twice - is when the target grid's dataset contains an
// record with "employeeId" matching the "id" field of the dropped employee.
//
// @visibility external
//<

//> @attr dataBoundComponent.duplicateDragMessage (String : "Duplicates not allowed" : IR)
// Message to show when a user attempts to transfer duplicate records into this component, and
// +link{preventDuplicates} is enabled.
// <P>
// If set to null, duplicates will not be reported and the dragged duplicates will not be
// saved.
//
// @group i18nMessages
// @visibility external
//<
duplicateDragMessage: "Duplicates not allowed",

//> @attr dataBoundComponent.showOfflineMessage (boolean : true : [IRW])
// Indicates whether the text of the offlineMessage property should be displayed if no data is
// available because we do not have a suitable offline cache
// @visibility external
// @group offlineGroup
// @see offlineMessage
//<
showOfflineMessage:true,


//>    @attr dataBoundComponent.offlineMessage (string : "This data not available while offline" : [IRW])
// Message to display when this DataBoundComponent attempts to load data that is not available
// because the browser is currently offline.  Depending on the component, the message is either
// displayed in the component's body, or in a pop-up warning dialog.
// @example offlineSupport
// @group i18nMessages, offlineGroup
// @visibility external
//<
offlineMessage:"This data not available while offline",

//>    @attr listGrid.offlineMessageStyle (CSSStyleName : "offlineMessage" : [IRW])
// The CSS style name applied to the +link{dataBoundComponent.offlineMessage,offlineMessage} if displayed.
// @group offlineGroup
// @visibility external
//<
offlineMessageStyle:"offlineMessage",

//>    @attr dataBoundComponent.offlineSaveMessage (string : "Data cannot be saved because you are not online" : [IRW])
// Message to display when this DataBoundComponent attempts to save data while the application
// is offline.
// @example offline
// @group i18nMessages, offlineGroup
// @visibility external
//<
offlineSaveMessage:"Data cannot be saved because you are not online",


//>    @attr    dataBoundComponent.addDropValues        (Boolean : true : IRW)
//          Indicates whether to add "drop values" to items dropped on this component, if both
//          the source and target widgets are databound, either to the same DataSource or
//          to different DataSources that are related via a foreign key.  "Drop values" are
//          properties of the dropped item that you wish to change (and persist) as a
//          result of the item being dropped on this grid.
//          <P>
//          If this value is true and this component is databound, +link{getDropValues()} will
//          be called for every databound item dropped on this grid, and an update performed
//          on the item
//
//      @group  dragging
//      @visibility external
//      @example listRecategorize
//<
addDropValues: true,

//>    @attr    dataBoundComponent.dropValues        (Object : null : IRWA)
//          When an item is dropped on this component, and +link{addDropValues} is true and both
//          the source and target widgets are databound, either to the same DataSource or
//          to different DataSources that are related via a foreign key, this object
//          provides the "drop values" that SmartClient will apply to the dropped object
//          before updating it.
//          <P>
//          If this property is not defined, SmartClient defaults to returning the selection
//          criteria currently in place for this component.  Thus, any databound items (for example,
//          rows from other grids bound to the same DataSource) dropped on the grid will,
//          by default, be subjected to an update that makes them conform to the grid's
//          current filter criteria.
//
//      @group  dragging
//      @visibility external
//      @example listRecategorize
//<



// Property to be used as field identifier on field objects.
// The ID of the field is also the property in each record which holds the value
// for that field.
fieldIdProperty:"name",


//> @method dataBoundComponent.dragComplete()
// This method is invoked on the source component whenever a drag operation or
// +link{transferSelectedData()} completes.  This method is called when the entire chain of
// operations - including, for databound components, server-side updates and subsequent
// integration of the changes into the client-side cache - has completed.<p>
// There is no default implementation of this method; you are intended to override it if you
// are interested in being notified when drag operations complete.
//
// @see dropComplete()
// @group  dragging
// @visibility external
//<

//> @method dataBoundComponent.dropComplete()
// This method is invoked whenever a drop operation or +link{transferSelectedData()}
// targeting this component completes.  A drop is considered to be complete when all the client-
// side transfer operations have finished.  This includes any server turnarounds SmartClient
// needs to make to check for duplicate records in the target component; it specifically does
// not include any add or update operations sent to the server for databound components.  If
// you want to be notified when the entire drag operation - including server updates and cache
// synchronization - has completed, override +link{dataBoundComponent.dragComplete,dragComplete}
// on the source component.<p>
// There is no default implementation of this method; you are intended to override it if you
// are interested in being notified when drop operations complete.
//
// @param transferredRecords (List of Records) The list of records actually transferred to
//                    this component (note that this is not necessarily the same thing as the
//                    list of records dragged out of the source component because it doesn't
//                    include records that were excluded because of collisions with existing
//                    records)
// @see dragComplete()
// @group  dragging
// @visibility external
//<


//> @type DataPath
// String specifying a nested data field structure.
// <P>
// Each dataPath string is a slash-delimited set of field identifiers, for example
// <code>"id1/id2/id3"</code>. DataPaths may be applied directly to a
// +link{canvas.dataPath,component}, and/or to a databound component field specification.
// A datapath denotes a path to a nested field value in a hierarchical structure, giving
// developers the opportunity to easily view or edit nested data structures.
// Specifically:
// <ul><li>if the component is viewing or editing a record, the value for fields
//         will be derived from a nested structure of records</li>
//     <li>if the component is bound to a dataSource, field attributes may be picked up by
//         following the dataPath to a field definition on another dataSource</li></ul>
// <b>Examples:</b><br>
// If a dynamicForm is defined with the following fields:
// <pre>
//    [
//      { name:"name" },
//      { name:"street", dataPath:"address/street" }
//    ]
// </pre>
// If the <code>"name"</code> field is set to <i>"Joe Smith"</i> and the <code>"street"</code> field
// is set to <i>"1221 High Street"</i>, when the values for this form are retrieved via a
// <code>getValues()</code> call they will return an object in the following format:
// <pre>
//    {name:"Joe Smith", address:{street:"1221 High Street"}}
// </pre>
// <P>
// For databound components, dataPath also provides a way to pick up field attributes from nested
// dataSources. Given the following dataSource definitions:
// <pre>
//  isc.DataSource.create({
//      ID:"contacts",
//      fields:[
//          {name:"name"},
//          {name:"email"},
//          {name:"organization"},
//          {name:"phone"},
//          {name:"address", type:"Address"}
//      ]
//  });
//
//  isc.DataSource.create({
//      ID:"Address",
//      fields:[
//          {name:"street"},
//          {name:"city"},
//          {name:"state"},
//          {name:"zip"}
//      ]
//  });
//  </pre>
// and a databound component bound to the 'contacts' dataSource, specifying a field with a dataPath
// of <code>"address/street"</code> would ensure the field attributes were derived from the
// "street" field of the 'Address' dataSource.
// <P>
// dataPaths are also cumulative. In other words if a component has a specified dataPath,
// the dataPath of any fields it contains will be appended to that component level path when
// accessing data. For example the following form:
// <pre>
// isc.DynamicForm.create({
//     dataPath:"contact",
//     fields:[
//          {dataPath:"address/email"}
//     ]
// });
// </pre>
// Might be used to edit a data structure similar to this:
// <pre>{contact:{name:'Ed Jones', address:{state:"CA", email:"ed@ed.jones.com"}}}</pre>
// Nested canvases can also have dataPaths specified, which will similarly be combined. See
// the +link{canvas.dataPath} attribute for more information and examples of this.
// @visibility external
//<

//> @attr   DataBoundComponent.dataArity    (string : "multiple" : IRWA)
// Does this component represent singular or multiple "records" objects?
// Options are "multiple" or "single", or "either"
// @visibility external
//<
dataArity:"multiple",

//> @attr   DataBoundComponent.autoTrackSelection (boolean : true : IRWA)
// If set, for dataArity:"single" components bound to a multiple:true field in this ValuesManager
// automatically check for the presence of a dataArity:"multiple" component bound to the same path
// and set this up as the +link{dataBoundComponent.selectionComponent}.  Note that this property only
// applies to dataArity:"single" components; if you wish to auto-track selections for a
// component that is ordinarily of dataArity:"either" (for example, DetailViewer), you must
// explicitly override its dataArity to "single".
// @visibility selectionComponent
//<
autoTrackSelection:true,


//> @attr canvas.valuesManager (ValuesManager : null : IRWA)
// +link{ValuesManager} for managing values displayed in this component.
// If specified at initialization time, this component will be added to the valuesManager via
// +link{valuesManager.addMember()}.
// <P>
// ValuesManagers allow different fields of a single object to be displayed or edited
// across multiple UI components. Given a single values object, a valuesManager will handle
// determining the appropriate field values for its member components and displaying them /
// responding to edits if the components support this.
// <P>
// Data may be derived simply from the specified fieldNames within the member components, or for
// complex nested data structures can be specified by both component and field-level
// +link{dataPath}.
// <P>
// Note that components may be automatically bound to an existing valuesManager attached to a
// parent component if dataPath is specified. See +link{canvas.dataPath} for more information.
// Also note that if a databound component has a specified dataSource and dataPath but no specified
// valuesManager object one will be automatically generated as part of the databinding process
// @visibility external
//<


//> @attr DataBoundComponent.progressiveLoading (boolean : null : IRW)
// Indicates whether or not this component will load its data
// +link{DataSource.progressiveLoading,progressively}.
// @see attr:DataSource.progressiveLoading
// @see attr:ResultSet.progressiveLoading
// @visibility external
// @group progressiveLoading

//<
setProgressiveLoading : function(value) {
    this.progressiveLoading = value;
    if ((isc.ResultSet && isc.isA.ResultSet(this.data)) ||
        (isc.ResultTree && isc.isA.ResultTree(this.data)))
    {
        this.data.progressiveLoading = value;
    }
},


//> @method  canvas.setValuesManager()
// Setter for the +link{canvas.valuesManager} attribute. This method may be called directly at
// runtime to set the ValuesManager for a component; it has the same effect as calling
// +link{ValuesManager.addMember()}, passing in this DataBoundComponent.
// @param dataPath (dataPath) new dataPath
// @visibility external
//<
setValuesManager : function(valuesManager) {
    if (valuesManager) valuesManager.addMember(this);
},

// This method is fired as part of setDataPath - it generates an automatic valuesManager if
// necessary based on this.dataSource
initializeValuesManager : function () {
    var vM = this.valuesManager;
    delete this.valuesManager;

   if (vM != null) {
        if (isc.ValuesManager == null) {
            this.logWarn("Widget initialized with specified 'valuesManager' property but " +
                "ValuesManager class is not loaded. This functionality requires the " +
                "Forms module.");
            return;
        }

        if (isc.isA.ValuesManager(vM)) {
            vM.addMember(this);
        } else if (isc.isA.ValuesManager(window[vM])) {
            window[vM].addMember(this);

        // If it's a string, create a new VM with that ID;
        } else if (isc.isA.String(vM)) {
            isc.ValuesManager.create({
                ID:vM,
                dataSource:this.dataSource,
                members:[this]
            });
        } else {
            this.logWarn("Widget initialized with invalid 'valuesManager' property:"
                         + isc.Log.echo(vM) + ", clearing this property out");
        }
    }
},

//> @attr canvas.dataPath (DataPath : null : IRWA)
// A dataPath may be specified on any canvas. This provides a straightforward way to display or
// edit complex nested data.
// <P>
// For components which support displaying or editing data values, (such as +link{DynamicForm} or
// +link{ListGrid} components), the dataPath may be set to specify how the components data is
// accessed. In this case the dataPath essentially specifies a nested object to edit - typically
// a path to a field value within a dataSource record. Note that a ValuesManager will be required
// to handle connecting the dataBoundcomponent to the appropriate sub object. This may be explicitly
// specified on the component, or a parent of the component, or automatically generated
// if a DataSource is specified on either the component or a parent thereof.
// <P>
// To provide a simple example - if a complex object existed with the following format:
// <pre>
// { companyName:"Some Company",
//   address:{    street:"123 Main Street", city:"New York", state:"NY"  }
// }
// </pre>
// a developer could specify a DynamicForm instance with 'dataPath' set to "address" to edit
// the nested address object:
// <pre>
// isc.ValuesManager.create({
//      ID:'vm',
//      values: { companyName:"Some Company",
//              address:{    street:"123 Main Street", city:"New York", state:"NY"  }
//      }
// });
//
// isc.DynamicForm.create({
//      valuesManager:"vm",
//      dataPath:"address",
//      items:[{name:"street"}, {name:"city"}, {name:"state"}]
// });
// </pre>
// If a component is specified with a <code>dataPath</code> attribute but does not have an
// explicitly specified valuesManager, it will check its parent element chain for a specified
// valuesManager and automatically bind to that. This simplifies binding multiple components used
// to view or edit a nested data structure as the valuesManager needs only be defined once at a
// reasonably high level component. Here's an example of this approach:
// <pre>
// isc.ValuesManager.create({
//      ID:'vm',
//      values: { companyName:"Some Company",
//              address:{    street:"123 Main Street", city:"New York", state:"NY"  }
//      }
// });
//
// isc.Layout.create({
//      valuesManager:vm,
//      members:[
//          isc.DynamicForm.create({
//              dataPath:"/",
//              items:[{name:"companyName"}]
//          }),
//          isc.DynamicForm.create({
//              dataPath:"address",
//              items:[{name:"street"}, {name:"city"}, {name:"state"}]
//          })
//      ]
// });
// </pre>
// Note that in this case the valuesManager is specified on a Layout, which has no 'values'
// management behavior of its own, but contains items with a specified dataPath which do. In this
// example you'd see 2 forms allowing editing of the nested data structure.
// <P>
// dataPaths from multiple nested components may also be combined. For example:
// <pre>
// isc.ValuesManager.create({
//      ID:'vm',
//      values: { companyName:"Some Company",
//              address:{    street:"123 Main Street", city:"New York", state:"NY"  }
//              parentCompany:{
//                  companyName:"Some Corporation",
//                  address:{   street:"1 High Street", city:"New York", state:"NY" }
//              }
//      }
// });
//
// isc.Layout.create({
//      valuesManager:vm,
//      members:[
//          isc.DynamicForm.create({
//              dataPath:"/",
//              items:[{name:"companyName"}]
//          }),
//          isc.DynamicForm.create({
//              dataPath:"address",
//              items:[{name:"street"}, {name:"city"}, {name:"state"}]
//          }),
//          isc.Layout.create({
//              dataPath:"parentCompany",
//              members:[
//                  isc.DynamicForm.create({
//                      dataPath:"/",
//                      items:[{name:"companyName", type:"staticText"}]
//                  }),
//                  isc.DetailViewer.create({
//                      dataPath:"address",
//                      fields:[{name:"street", name:"city", name:"state"}]
//                  })
//              ]
//          })
//      ]
// });
// </pre>
// In this example the detailViewer will display data from the <code>parentCompany.address</code>
// object within the base record.
// <P>
// Note that if a component has a specified  dataSource and shows child components with a
// specified dataPath, there is no need to explicitly declare a valuesManager at all. If a component
// with a dataPath has a dataSource, or an ancestor with a dataSource specified, it will, a
// valuesManager will automatically be generated on the higher level component (and be available as
// <code>component.valuesManager</code>).
// @visibility external
//<

//> @method  canvas.setDataPath()
// Setter for the +link{canvas.dataPath} attribute. This method may be called directly at runtime
// to set the dataPath on a component, and will also be re-run automatically whenever a canvas'
// parent changes due to a call to addChild(). This method handles automatically binding
// the component to the appropriate valuesManager if necessary.
// @param dataPath (DataPath) new dataPath
// @visibility external
//<
setDataPath : function (dataPath) {

    this.dataPath = dataPath;

    // we run this on every change of widget hierarchy (addChild etc), allowing us to
    // pick up a valuesManager based on a values manager applied at some ancestor widget level.
    // detect true "databound" components by the presence of fields - if we have no fields
    // just bail here

    if (this.getFields == null || this.getFields() == null) return;

    // clearing dataPath? Disconnect from any dataPath-derived valuesManager, and bail
    if (dataPath == null) {
        delete this._fullDataPath;
        if (this.valuesManager && this._valuesManagerFromDataPath) {
            this.valuesManager.removeMember(this);
            delete this._valuesManagerFromDataPath;
        }
        return;
    }

    // If we have a dataSource applied directly to us we don't need to attach ourselves to another
    // valuesManager, etc
    // Note:
    // We support 'cumulative' dataPaths
    // In other words a valuesManager may be defined on a Layout
    // This can contain another layout with a specified dataPath, which in turn contains a form
    // with a specified dataPath.
    // In this case the forms data would be derived from the valuesManager on the top level layout
    // using a full dataPath combined from both the DynamicForm and the Layout's dataPath
    // Set up this 'fullDataPath' here - retrieved from 'getFullDataPath'
    var fullDataPath;
    var dataPathComponent = this;
    while (dataPathComponent &&
            (!dataPathComponent.valuesManager || dataPathComponent._valuesManagerFromDataPath) &&
             !dataPathComponent.dataSource)
    {
        if (dataPathComponent.dataPath) {
            if (fullDataPath) {
                fullDataPath = isc.Canvas._combineDataPaths(dataPathComponent.dataPath,
                                                            fullDataPath);
            } else {
                fullDataPath = dataPathComponent.dataPath;
            }
        }
        dataPathComponent = dataPathComponent.parentElement;
    }
    this._fullDataPath = fullDataPath;
    // If we have a valuesManager and/or dataSource specified directly on this component
    // no need to attach to another one!

    if (dataPathComponent) {
        if (dataPathComponent != this || !this.dataSource) {
            // assertion - the datapathComponent has a valuesManager already, or a dataSource
            // (in which case we can create a new valuesManager automatically)
            if (dataPathComponent.valuesManager == null) {
                dataPathComponent.createDefaultValuesManager();
            }
            // Assert - this component is not bound to a dataSource and should be bound to
            // the dataSource associated with the valuesManager we're about to add it to
            // (has to be done in this order, or the databinding step wipes out any values
            // that the VM might have assigned to the DBC when it was added)
            var fields = isc.isA.DynamicForm(this) ? this._itemsConfig : this.getFields();
            fields = fields || this.getFields();


            // The VM may not have been bound to a dataSource yet
            if (dataPathComponent.valuesManager.getDataSource()) {
                var dataSource = dataPathComponent.valuesManager.getDataSource(),
                    dataPath = this._fullDataPath;
                if (dataPath) {
                    dataSource = dataSource.getDataSourceForDataPath(dataPath, true);
                }
                this.setDataSource(dataSource, fields);
            }

            // second param ensures the _valuesManagerFromDataPath attr gets set.
            dataPathComponent.valuesManager.addMember(this, true);
        }
    }
},

//> @method canvas.getFullDataPath()
// Returns a fully qualified +link{type:DataPath} for this canvas. This is calculated by combining
// the canvas' specified +link{type:DataPath} with the <code>dataPath</code> of any parent
// canvases up to whichever canvas has a specified +link{canvas.valuesManager} specified to actually
// manage values from this component.
// @return (DataPath) fully qualified dataPath for this component
// @visibility external
//<
getFullDataPath : function () {
    var thisDP = this._fullDataPath || this.dataPath;
    // If both are undefined and we have a master element (eg, we are a summary row in a ListGrid),
    // return the master's dataPath
    if (!thisDP && this.masterElement) {
        return this.masterElement._fullDataPath || this.masterElement.dataPath;
    }
    return thisDP;
},

buildFieldDataPath : function (componentDataPath, field) {
    var dataPath = field.dataPath || field.name;
    if (componentDataPath != null) {
        dataPath = isc.Canvas._combineDataPaths(componentDataPath, dataPath);
    }
    // Strip any leading slashes off - we need to support them being entered because it
    // allows users to specify absolute dataPaths, which is important for some use cases, but
    // we don't want to send them to methods that process dataPath strings because they have
    // been written to not expect them.
    return !dataPath ? null : dataPath.replace(/^\/*/, "");
},

createDefaultValuesManager : function (defaultMembers) {
    if (!defaultMembers) defaultMembers = [];
    defaultMembers.add(this);

    isc.ValuesManager.create({
        members:defaultMembers,
        ID:this.getID() + "_valuesManager",
        dataSource:this.dataSource
    });
},

// This method trims the component's dataPath off of a field's dataPath, if the field dataPath reiterates
// it.  This puts the field dataPath in the correct context, since this component's data values
// will be the (List of) record(s) corresponding to a subfield of the overall data
// structure, NOT the overall data structure itself
_trimDataPath : function (dataPathParam) {
    return isc.Canvas._trimDataPath(dataPathParam, this);
},

//> @method dataBoundComponent.getDataPathField()
// For a component with a specified +link{DataSource}, find the associated dataSource field object
// from a specified +link{type:DataPath,dataPath}.
// @param dataPath (DataPath) dataPath for which the field definition should be returned.
// @visibility external
//<
getDataPathField : function (dataPath) {
    if (!dataPath) return null;
    var dataSource;
    // We're passed the full dataPath for the field.
    // this component may have a specified dataPath (in which case we'll be bound to the
    // dataSource that represents that). However the field dataPath may be absolute
    // so look at the dataSource on the valuesManager and apply the full dataPath to that
    // rather than looking at our dataSource and applying a partial dataPath.

    if (this.valuesManager && this.valuesManager.getDataSource) {
        dataSource = this.valuesManager.getDataSource();

    } else if (this.grid && this.grid.valuesManager && this.grid.valuesManager.getDataSource) {
        dataSource = this.grid.valuesManager.getDataSource();
    } else {
        dataSource = this.getDataSource();
    }

    var segments = dataPath.split(isc.slash),
        rtnField;
    if (!dataSource) return;

    for (var i = 0; i < segments.length; i++) {
        var fieldId = segments[i],
        field = dataSource.getField(fieldId);
        dataSource = field ? (dataSource.getSchema(field.type)  || dataSource) : dataSource;

        if (field == null) {
            this.logWarn("Unable to find dataSource field matching specified dataPath: '" +
                         dataPath + "'");
            return;
        }
    }
    return field;
},

registerWithDataView : function (dataView) {
    if (!this.inputDataPath) return;

    dataView = this.parentElement;
    while (dataView && !isc.isA.DataView(dataView)) dataView = dataView.parentElement;

    if (!dataView) {
        this.logWarn("Component initialized with an inputDataPath property, but no DataView " +
                     "was found in the parent hierarchy. inputDataPath is only applicable to " +
                     "DataBoundComponents and FormItems being managed by a DataView");
        return;
    }

    dataView.registerItem(this);
},

//>    @method    dataBoundComponent.bindToDataSource()
// Combine component's fields specifications with the fields specifications from the
// datasource the component works with (specified indirectly by component.operation).
// - check if fields property and dataSource property are specified
// - if just dataSource, then use dataSource fields
// - if just fields property, then default behavior
// - if both, then use fields, with each field using defaults of dataSource<br>
//   calls setFields() when finished
//        @group    data
//<
// Extra parameter 'hideExtraDSFields' used by ListGrid for the case where
// useAllDataSourceFields is false but we want to include fields picked up from the DataSource
// but mark them as not visible in the grid. This is used to achieve the
// +link{listGrid.canPickOmittedFields} behavior.
_dateEditorTypes:{date:true,DateItem:true},
bindToDataSource : function (fields, hideExtraDSFields) {

    //this.logWarn("bindToDataSource called with fields " + this.echoLeaf(fields));
    // call 'setDataPath' to ensure if we have a dataPath specified we bind to the correct
    // valuesManager
    if (this.dataPath) this.setDataPath(this.dataPath);
    // Most components operate on a datasource, displaying or otherwise manipulating fields from
    // that datasource.  We don't want to duplicate all the information about a field that is
    // specified in the datasource (type, title, etc) in each component that needs to display
    // that field.  So, we allow the component's field specifications to refer to the datasource
    // field by name, and combine the field specification from the component with the field
    // specification from the datasource.

    // pick up the dataSource of our dataset if it has one and we weren't given one
    if (this.dataSource == null && this.data != null) this.dataSource = this.data.dataSource;


    var origFields = this.fields || this.items;
    if (isc.isAn.Array(origFields)) this.originalFields = origFields.duplicate();

    // get the datasource versions of the field specifications.  NOTE: this method may be
    // called in a build that does not include DataSource
    var    ds = this.getDataSource();
    if (ds == null && this.valuesManager && this.valuesManager.getDataSource) {
        ds = this.valuesManager.getDataSource();
    }
    if (ds != null && isc.isA.String(ds)) {
        this.logWarn("unable to look up DataSource: " + ds + ", databinding will not be used");
        return fields;
    }

    // Shorthand - treat fields being null or an empty array as the same case - no (meaningful)
    // fields were passed in
    var noSpecifiedFields = (fields == null || fields.length == 0),
        dsFields;
    // get fields from the DataSource if we have one
    if (ds) {
        // flatten fields if so configured
        var flatten = this.useFlatFields;
        if (flatten == null) flatten = ds.useFlatFields;
        dsFields = flatten ? ds.getFlattenedFields() : ds.getFields();
    }

    if (!noSpecifiedFields && isc.Canvas.validateFieldNames) {
        // loop through each field and check that each field name is a valid JavaScript identifier.
        isc.Canvas._validateFieldNames(fields, this);
    }

    // Case 1: no dataSource specified
    // This widget isn't associated with a datasource - all fields are full specifications
    // intended for the underlying widget.  The fields property is thus left untouched.
    if (ds == null || dsFields == null) {
        //this.logWarn("No DataSource fields");
        if (fields != null && isc.SimpleType) {
            // type defaults are auto-applied to DS fields and combined fields, but we need to
            // do it here for any field that doesn't appear in the DataSource
            for (var i = 0; i < fields.length; i++) {

                if (fields[i] == null) continue;
                // For items with editorType set to DateItem or date, default the data type
                // to date also so we pick up type validators etc.

                if (fields[i].type == null &&
                    this._dateEditorTypes[fields[i].editorType] == true)
                {
                    fields[i].type = "date";
                }

                if (fields[i].type == null) {
                    var className = null;
                    if (fields[i]._constructor && isc[fields[i]._constructor]) {
                        className = fields[i]._constructor;
                    }
                    if (fields[i].editorType && isc[fields[i].editorType]) {
                        className = fields[i].editorType;
                    }
                    if (className && isc[className] && isc[className].getInstanceProperty) {
                        // if the field has no type, only use the type from the specified editorType
                        // if there is no valueMap available - if there's a valueMap,
                        // assume type: "text"
                        if (fields[i].valueMap || fields[i].editorValueMap) fields[i].type = "text";
                        else {
                            fields[i].type =
                                isc[className].getInstanceProperty("type") ||
                                isc[className].getInstanceProperty("defaultType");
                        }
                    }
                }
                isc.SimpleType.addTypeDefaults(fields[i]);
                if (fields[i].type) {
                    var type = isc.SimpleType.getType(fields[i].type);
                    fields[i] = this.addTypeFieldProperties(fields[i], type);

                    if (!fields[i].format && type && type.format) {
                        fields[i].format = type.format;
                    }
                }
            }
        }
        this.addFieldValidators(fields);
        return fields;
    }

    // Case 2: dataSource specified, but no fields specified
    if (this.doNotUseDefaultBinding) return [];
    // The widget will show all DataSource fields, applying reasonable defaults.
    if (ds != null && noSpecifiedFields) {


        if (this.suppressAllDSFields) return [];

        //this.logWarn("No Specified fields, use DS fields only");
        // NOTE we generally have to create a copy of the DataSource fields rather than having
        // everyone use the same objects, because widgets tend to scribble things into this.fields,
        // such as widths derived by a sizing policy.
        fields = [];
        for (var fieldName in dsFields) {
            var field = dsFields[fieldName];

            if (!this.shouldUseField(field, ds)) continue;

            var componentField = isc.addProperties({}, field)
            // modify 'canEdit' to match our canEditAttribute if necessary.
            var canEdit = this.getDefaultCanEdit(field);

            var undef;
            if (canEdit === undef) {
                delete componentField.canEdit;
            } else {
                componentField.canEdit = canEdit;
            }

            // If "showHiddenFields" is true we'll show fields which are marked as
            // hidden:true in the dataSource.
            // However we don't want that property picked up in the local field object,
            // since that would be an equivalent of 'showIf' false, meaning the
            // field would be present but hidden. If the dev wants that they'll have
            // to explicitly add a field definition to the component for this field
            if (componentField.hidden) delete componentField.hidden;

            fields.add(componentField);
        }
        this.addFieldValidators(fields);
        return fields;
    }

    // Case 3: dataSource and fields specified
    // fields provided to this instance act as an overlay on DataSource fields
    if (ds != null && !noSpecifiedFields) {
        //this.logWarn("Combining specified fields with dataSource fields");
        // Loop through local fields and apply type defaults.
        // This allows local fields to specify a type which takes precedence over
        // the DS field type.
        // Also ensure that any specified field with editorType set to "DateItem" has type
        // set to date if type isn't explicitly defined on either the item or the
        // corresponding dataSource field.

        var fieldCanEditMap = {};
        for (var i = fields.length - 1; i >= 0; i--) {
            var field = fields[i];
            if (field == null) continue;
            // Drop any field marked canView: false from the DBC, even if it was explicitly
            // included.  Fields that have been manually marked in this way are intended as
            // "server-only" fields; also, the security system can mark fields canView: false,
            // to ensure that client-side components do not attempt to display values the
            // user is not authorized to see (they would only see blank cells anyway, because
            // the server will also strip data values out)
            var dsField = (field.name != null) ? ds.getField(field.name) : null;
            if (dsField && dsField.canView === false) {
                this.logInfo("Dropping explicitly-named field " + field.name +
                             " because it is marked canView: false");
                fields.removeAt(i);
                continue;
            }


            if (field.type == null && this._dateEditorTypes[field.editorType] == true) {
                var name = field.name;
                var dsField = (name != null) ? ds.getField(name) : null;
                if (dsField == null || dsField.type == null) {
                    field.type = "date";
                }
            }
            if (isc.SimpleType) {
                isc.SimpleType.addTypeDefaults(field);
                var fieldType = field.type;
                if (fieldType == null) {
                    var dsField = (field.name != null) ? ds.getField(field.name) : null;
                    if (dsField) fieldType = dsField.type;
                }
                if (fieldType) {
                    var type = isc.SimpleType.getType(fieldType);

                    fields[i] = this.addTypeFieldProperties(fields[i], type);
                }
            }
            // set up field.canEdit based on settings on the DS field
            if (dsField) {
                var canEdit = field.canEdit;
                // if canEdit is set at the component field level, respect it

                if (canEdit == null) {
                    canEdit = this.getDefaultCanEdit(dsField);
                } else {
                    //>DEBUG
                    this.logDebug("DataBoundComponent respecting explicit 'canEdit' on target field " + dsField.name,
                        "canEditField");
                    //<DEBUG
                }
                // remember the default on a map - we'll apply it *after* we've copied the
                // dsField defaults onto the field object

                fieldCanEditMap[field.name] = canEdit;

            } else if (field.includeFrom != null) {
                // Disallow editing of includeFrom fields by default.
                var canEdit = field.canEdit;
                if ((canEdit == null) && (this.canEditIncludeFromFields() == false)) {
                    canEdit = false;
                }

                fieldCanEditMap[field.includeFrom] = canEdit;

            // No DS field, don't modify canEdit

            } else {
                fieldCanEditMap[field.name] = field.canEdit;
            }


            // Always apply type defaults to the local fields. This allows
            // local field.type to be specified and override ds field.type.
            // addTypeDefaults will bail immediately if it's already been applied
            if (field.type != null) {
                isc.SimpleType.addTypeDefaults(field);
            }
        }
        if (this.useAllDataSourceFields || hideExtraDSFields) {
            var canvas = this;
            var bothFields = ds.combineFieldOrders(
                        dsFields, fields,
                        function (field, ds, isLocal) {
                            return canvas.shouldUseField(field, ds, isLocal)
                        });

            // Loop through the combined fields:
            // - if hideExtraDSFields is true, hide any fields picked up from the
            //   DS that weren't explicitly specified
            // - handle any fields that should pick up defaults from another DS
            //   (where field.includeFrom is set).
            for (var i = 0; i < bothFields.length; i++) {
                var field = bothFields[i];
                if (!fields.containsProperty("name", field.name)) {
                    if (hideExtraDSFields && field.showIf == null) {
                        field.showIf = "return false";
                    }

                } else {
                    if (field.includeFrom != null && ds.getField(field.name) == null) {
                        this._combineIncludeFromFieldData(field);
                    }
                }

                // DS fields that weren't in the fields array need to have 'canEdit' updated
                var canEdit;
                if (fields.contains(field)) {
                    canEdit = field.includeFrom ? fieldCanEditMap[field.includeFrom]
                                                : fieldCanEditMap[field.name];
                } else {
                    canEdit = this.getDefaultCanEdit(field);
                }

                var undef;
                if (canEdit === undef) {
                    delete field.canEdit;
                } else {
                    field.canEdit = canEdit;
                }
            }
            this.addFieldValidators(bothFields);
            return bothFields;
        } else {
            // only the fields declared on the component will be shown, in the order specified on
            // the component
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (!field) continue;
                field = this.combineFieldData(field);
                field.canEdit = field.includeFrom ? fieldCanEditMap[field.includeFrom]
                                                  : fieldCanEditMap[field.name];
                if (field.canEdit == null) {
                    // need to delete field.canEdit, or we don't pick up class defaults later
                    delete field.canEdit;
                }
            }
            this.addFieldValidators(fields);
            // return the original fields array, with properties added to the field objects
            return fields;
        }
    }
},

// helper to apply duplicated 'fieldProperties' from type object to field

addTypeFieldProperties : function (field, type) {
    if (type && type.fieldProperties) {
        var finalField = {};
        for (var property in type.fieldProperties) {
            // Duplicate editorProperties - we manipulated it directly on the
            // widget and don't want to pollute the version on the type object

            if (property == "editorProperties") {
                finalField[property] = isc.addProperties({}, type.fieldProperties[property]);
            } else {
                finalField[property] = type.fieldProperties[property];
            }
        }
        // Allow explicit entries to clobber those picked up from the type.
        return isc.addProperties(finalField, field);
    }
    return field;
},


//> @attr dataBoundComponent.canEditFieldAttribute (identifier : "canEdit" : IRA)
// If this component is bound to a dataSource, this attribute may be specified to customize
// what fields from the dataSource may be edited by default. For example the +link{SearchForm}
// class has this attribute set to <code>"canFilter"</code> which allows search forms to edit
// dataSource fields marked as <code>canEdit:false</code> (but not those marked as
// <code>canFilter:false</code>).
// <P>
// Note that if <code>canEdit</code> is explicitly specified on a field in
// the +link{DataBoundComponent.fields} array, that property will be respected in preference to
// the canEditAttribute value. (See +link{FormItem.canEdit}, +link{ListGridField.canEdit}).
// Also note that individual dataBoundComponents may have additional logic around whether a field
// can be edited - for example +link{listGrid.canEditCell()} may be overridden.
// @visibility external
//<

// if field.canEdit is not explicitly set (at the item level), derive it from the
// dataSource field value for our canEditAttribute
getDefaultCanEdit : function (dsField) {

    var canEditAttribute = this.canEditFieldAttribute;
    if (canEditAttribute == null) canEditAttribute = "canEdit";
    var canEditValue = dsField[canEditAttribute];
    // If null check 'canSave' - this should be respected if no explicit canEdit is set
    if (canEditValue == null) {
        if (dsField.canSave == false && !this._canEditUnsaveableFields) {
            canEditValue = false;
        }
    }

    //>DEBUG
    this.logDebug("DataBoundComponent using canEditFieldAttribute:" + canEditAttribute +
                  " setting 'canEdit' to " + canEditValue + " on target field " + dsField.name,
                  "canEditField");
    //<DEBUG

    return canEditValue;

},

//> @method dataBoundComponent.fieldIsEditable()
// Can the field be edited?  This base method always returns false, but it's
// overridden by subclasses such as +link{DynamicForm} and +link{ListGrid}.
//
// @param field (object | number | string)  field object or identifier
// @return      (boolean)                   whether field can be edited
//
// @group editing
// @see listGrid.fieldIsEditable
// @see dynamicForm.fieldIsEditable
// @visibility external
//<
fieldIsEditable : function (field) {
    return false;
},

// If a field is inherited from another DS via 'includeFrom', should it be editable?
// We want to allow this for filtering, but not for record-editing (for db saving) by
// default.
// Rely on the fact that the 'canEditFieldAttribute' will be set to "canFilter" in
// the case where we're filtering fields.
_$canEdit:"canEdit",
canEditIncludeFromFields : function () {
    var canEditAttribute = this.canEditFieldAttribute;
    if (canEditAttribute == null || canEditAttribute == this._$canEdit) {
        return false;
    }
    return true;
},

combineFieldData : function (field) {
    var ds = this.getDataSource();

    // specified dataPath -- will pick up defaults from another (nested) ds field
    if (this.getFullDataPath() || field.dataPath) {

        var dataPath = this.buildFieldDataPath(this.getFullDataPath(), field);
        isc.DataSource.combineFieldData(field, this.getDataPathField(dataPath));
        return field;
    // specified ds field -- will pick up defaults from field in this dataSource
    } else if (ds != null && ds.getField(field.name)) {

        // combine the component field specification with the datasource field
        // specification - component fields override so that you can eg, retitle a field
        // within a summary
        return ds.combineFieldData(field);



    // specified 'includeFrom' field -- will pick up defaults from field in another dataSource
    } else if (field.includeFrom != null) {
        return this._combineIncludeFromFieldData(field);
    }

    return field;
},

_combineIncludeFromFieldData : function (field) {

    var split = field.includeFrom.split(".");
    if (split == null || split.length != 2) {
        this.logWarn("This component includes a field with includeFrom set to:"
            + field.includeFrom + ". Format not understood.");
    } else {
        var relatedDS = isc.DataSource.get(split[0]),
            fieldName = split[1];
        if (relatedDS == null) {
            this.logWarn("Field specifies includeFrom:" + field.includeFrom +
                ". Unable to find dataSource with ID:" + split[0]);
        } else {
            // default the field name to the includeField's name if not explicitly set.
            if (field.name == null) field.name = fieldName;
            return relatedDS.combineFieldData(field, relatedDS.getField(fieldName));
        }
    }
},

// return whether this component wants to use the field when binding to a DataSource
shouldUseField : function (field, ds, isLocal) {
    // canView: false means this field should never be shown to a user, even if explicitly
    // declared on a DBC
    if (field.canView === false) return false;
    // hidden at the DS level means don't include in the component.
    // If this is a local field (no ds passed in, or has explicit "isLocal" flag indicating
    // we're looking at a local field definition object, ignore this flag
    // (Hidden at the widget-field level is less strong - equivalent to just showIf:false.
    // See ListGridField.hidden docs)
    if (ds && !isLocal && !this.showHiddenFields) {
        if (field.hidden) return false;
    }
    if (field.canFilter == false && this.showFilterFieldsOnly) {
        return false;
    }

    // don't use the field if the field is marked as a detail field and the component is not a
    // detail component

    if (field.detail && !this.showDetailFields) return false;

    if (!this.showComplexFields && ds.fieldIsComplexType(field.name)) return false;

    return true;
},

// Add validators that replace basic field properties (ex. required)
addFieldValidators : function (fields) {
    if (fields == null) return;


    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        // Ensure we don't share validators array instances across different components etc
        if (field.validators != null) field.validators = field.validators.duplicate();

        if (field.required) {
            var validator = this.getRequiredValidator(field),
                message = validator.errorMessage;

            // Add validator to field
            if (!field.validators) {
                field.validators = [validator];
            } else {
                if (!isc.isAn.Array(field.validators)) {
                    field.validators = [field.validators];
                }
                // See if we already have a required validator.
                // If so, we need to make sure the errorMessage is correct.
                // If not, add a new required validator.
                if (!field.validators.containsProperty("type", validator.type) &&
                    !field.validators.containsProperty("_constructor", validator.type))
                {
                    // if the field is using the shared, default validators for the type,
                    // make a copy before modifying
                    if (field.validators._typeValidators) {
                        field.validators = field.validators.duplicate();
                    }
                    field.validators.add(validator);
                } else if (message != null) {
                    var ds = this.getDataSource(),
                        v = (field.validators.find("type", validator.type) ||
                             field.validators.find("_constructor", validator.type))
                    ;
                    // See if our error message should override current one
                    // created on the DataSource.
                    if (v.errorMessage == null || (ds && v.errorMessage == ds.requiredMessage)) {
                        v.errorMessage = message;
                    }
                }
            }
        // If a required validator is present on the field but field.required is explicitly false,
        // required must be true at the type level (set on the DS field probably), but have
        // been overridden at the component field level.
        // In this case, remove the required validator from the component field.
        } else if (field.required == false) {
            var validators= field.validators;
            if (field.validators != null) {
                var requiredValidatorIndex = field.validators.findIndex("type", "required");
                if (requiredValidatorIndex != -1) {
                    field.validators.removeAt(requiredValidatorIndex);
                }
            }
        }

        // If field.length is specified, apply a length validator

        if (this.applyLengthValidators && field.length != null) {
            var validator = this.getMaxLengthValidator(field);

            // Add validator to field
            if (!field.validators) {
                field.validators = [validator];
            } else {
                if (!isc.isAn.Array(field.validators)) {
                    field.validators = [field.validators];
                }
                // See if we already have a length range validator
                // If we do, and it has a specified max which is <= this.length,
                // don't add this validator.
                var hasLengthValidator = false;
                for (var ii = 0 ; ii < field.validators.length; ii++) {
                    var existingValidator = field.validators[ii];
                    if ((existingValidator.type == validator.type ||
                         existingValidator._constructor == validator.type) &&
                        existingValidator.max != null && existingValidator.max <= validator.max)
                    {
                        hasLengthValidator = true;
                        break;
                    }
                }
                if (!hasLengthValidator) {
                    field.validators.add(validator);
                }
            }
        }

        if (field.maxFileSize != null) {
            var validator = this.getMaxFileSizeValidator(field),
                message = validator.errorMessage;

            if (!field.validators) {
                field.validators = [validator];
            } else {
                if (!isc.isAn.Array(field.validators)) {
                    field.validators = [field.validators];
                }

                // See if there is already a 'maxFileSize' validator.
                // If so, see if we need to set the errorMessage.
                if (!field.validators.containsProperty("type", validator.type) &&
                    !field.validators.containsProperty("_constructor", validator.type))
                {
                    if (field.validators._typeValidators) {
                        field.validators = field.validators.duplicate();
                    }
                    field.validators.add(validator);
                } else if (message != null) {
                    var v = (field.validators.find("type", validator.type) ||
                             field.validators.find("_constructor", validator.type))
                    ;
                    if (v.errorMessage == null) {
                        v.errorMessage = message;
                    }
                    v.maxFileSize = validator.maxFileSize;
                }
            }
        }

        // For multiple:true fields, default to validating each selected value
        // individually.
        // This is required to ensure that (for example) type validators don't auto-convert
        // from an array of strings to a single comma-separated string

        if (field.multiple && field.validateEachItem == null) field.validateEachItem = true;
    }
},


getRequiredValidator : function (field) {
    var requiredValidator = {
            type: "required"
        },
        message = field.requiredMessage || this.requiredMessage;

    if (message != null) requiredValidator.errorMessage = message;
    return requiredValidator;
},

// If field.length is specified, apply a lengthRange validator to the field.
// We also do this on the server side
applyLengthValidators:true,
getMaxLengthValidator : function (field) {
    var lengthValidator = {
        type:"lengthRange",
        max:field.length
    }
    return lengthValidator;
},

getMaxFileSizeValidator : function (field) {
    var maxFileSizeValidator = {
            type: "maxFileSize",
            maxFileSize: field.maxFileSize
        },
        message = field.maxFileSizeMessage;

    if (message != null) maxFileSizeValidator.errorMessage = message;
    return maxFileSizeValidator;
},

// doc'd at ListGrid level
getAllFields : function () {
    return this.completeFields || this.fields;
},

//>    @method    dataBoundComponent.getField()
// Return a field by a field index or field name.
//
// @param fieldID (String || Number) field index or field.name
//
// @return (object) Field description
// @visibility external
//<
getField : function (fieldId) {
    if (!this.fields) return null;
    return isc.Class.getArrayItem(fieldId, this.fields, this.fieldIdProperty);
},


// get a reference to a field by name - this might be in fields, completeFields or ds.fields
getUnderlyingField : function (fieldId) {
    if (!this.fields && !this.completeFields && !this.dataSource) {
        this.logWarn("fields and completeFields are null and there is no DataSource");
        return null;
    }
    var item = null;
    if (this.fields) {
        // see if there's a valid field - use getField() rather than isc.Class.getArrayItem()
        // because:
        // 1) getField() is overridden to support dataPath in LG, and to return formItems in DF
        // 2) the default implementation, in DBC.getField(), calls getArrayItem() anyway
        item = this.getField(fieldId);
    }
    if (!item && this.completeFields) {
        item = isc.Class.getArrayItem(fieldId, this.completeFields, this.fieldIdProperty);
    }
    if (!item && this.dataSource) {
        if (!isc.isA.DataSource(this.dataSource)) this.dataSource = this.getDataSource(this.dataSource);
        item = this.dataSource.getField(fieldId);
    }
    return item;
},

//> @method dataBoundComponent.getFieldNum()
// Find the index of a currently visible field.
//
// @param fieldID (String || Field) field name or field
// @return (int) index of field within currently visible fields, or -1 if not found.
// @visibility external
//<
getFieldNum : function (fieldId) {
    if (!this.fields) return -1;
    // handle being passed a field object (or a clone of a field object)
    if (isc.isA.Object(fieldId) && (fieldId[this.fieldIdProperty] != null)) {
        fieldId = fieldId[this.fieldIdProperty];
    }
    return isc.Class.getArrayItemIndex(fieldId, this.fields, this.fieldIdProperty);
},

// Whether a field derived from XML Schema is considered structurally required.
// <P>
// A field is considered required if the field itself must be present within it's complexType
// *and* the complexType and all parent complexTypes are required.
// <P>
// Note that this is relative to how much of a given structure this component edits.  If you
// bind a component to a DataSource representing an entire WSDLMessage, a field may not be
// considered required because it has an optional parent, whereas if you instead bind to a
// particular sub-part of the message the field could be considered required since no optional
// parent elements are in play.  This is the correct behavior but it does mean that to get
// correct "required" behavior you want to coordinate all of your components to use a
// ValuesManager that actually represents the *whole* structure they are meant to be editing.
// <P>
// NOTE that a more complete implementation might dynamically check the current values to check
// whether at least one entry had been added to a structure that is otherwise optional; at that
// point the rest of the values should be considered required as well
isXMLRequired : function (field) {

    if (!field || !this.useXMLRequired || !field.xmlRequired) return false;

    if (!field.dataPath) return true;

    var dataSource = this.getDataSource();
    if (!dataSource) return true;

    //this.logWarn("field: " + this.echoLeaf(field) + " has path: " + field.dataPath);

    var segments = field.dataPath.split(isc.slash),
        field;
    for (var i = 0; i < segments.length; i++) {
        var fieldId = segments[i];

        //this.logWarn("checking segment: " + fieldId + " against DataSource: " + dataSource);

        // invalid dataPath, but will be warned about elsewhere.  The field's individual
        // xmlRequired status should be considered authoritative
        if (!dataSource) return true;

        field = dataSource.getField(fieldId);

        // invalid dataPath again
        if (!field) return true;

        // a parent XML structure is not required, so the field should not be
        if (field.xmlMinOccurs != null && field.xmlMinOccurs < 1) {
            //this.logWarn("optional field found: " + fieldId);
            return false;
        }

        dataSource = dataSource.getSchema(field.type);

    }
    return true;

},

// Field State management
// ---------------------------------------------------------------------------------------
// Retrieve and restore metadata about fields of a DataBoundComponent such as visibility,
// width or other user-settable display settings.

// Helper method to evaluate the various viewState objects (stored as strings)
evalViewState : function (state, stateName, suppressWarning) {
    return isc.Canvas.evalViewState(state, stateName, suppressWarning, this);
},

// documented in ListGrid.js
canEditTitles:false,

shouldIncludeTitleInFieldState : function () {
    return this.canEditTitles;
},

// DBC-level fieldState methods
getFieldState : function (returnObject) {
    var includeTitle = this.shouldIncludeTitleInFieldState();
    var fieldStates = [];
    var allFields = this.getAllFields();
    if (allFields) {
        for (var i = 0; i < allFields.length; i++) {
            var field = allFields[i];

            // defensive null check
            if (!field || field.excludeFromState) continue;

            var fieldName = field[this.fieldIdProperty],
                fieldState = this.getStateForField(fieldName, includeTitle)
            ;
            fieldStates.add(fieldState);
        }
    }

    if (returnObject) return fieldStates;
    return isc.Comm.serialize(fieldStates, false);
},

// get the state for a given field by name
getStateForField : function (fieldName, includeTitle) {
    var field = this.getAllFields().find(this.fieldIdProperty, fieldName),
        fieldState = { name:fieldName };

    // defensive null check
    if (!field) return null;

    if (field.frozen == true) fieldState.frozen = true;

    if (!this.fieldShouldBeVisible(field, this.getFieldNum(fieldName))) fieldState.visible = false;
    // store the userFormula if this is a formula field
    if (field.userFormula) {
       fieldState.userFormula = field.userFormula;
       // also persist type because it's set to 'float' by the FormulaBuilder - and this value
       // is required for e.g. decimalPrecision - and frequently formula fields are added by
       // the end user such that there's no matching field in the ds to define the type
       fieldState.type = field.type;
    }
    // store the userSummary if one is present
    if (field.userSummary) fieldState.userSummary = field.userSummary;

    // auto-persist title for formula / summary fields, since it's user entered
    if (includeTitle || field.userSummary || field.userFormula) {
        fieldState.title = field.title;
    }

    var undef;
    // for these fields, a value of null is meaningful vs undefined.  We want any such
    // meaningful value to override field defaults as supplied by the component or
    // datasource
    if (field.autoFitWidth !== undef) fieldState.autoFitWidth = field.autoFitWidth;
    //
    // these may also be set by the user via the FieldPicker
    if (field.precision !== undef) fieldState.precision = field.precision;
    if (field.decimalPrecision !== undef) fieldState.decimalPrecision = field.decimalPrecision;
    if (field.decimalPad !== undef) fieldState.decimalPad = field.decimalPad;

    if (this.getSpecifiedFieldWidth) {
        // don't write out null widths - retains pre-specified percentage widths
        var width = this.getSpecifiedFieldWidth(field);
        if (width != null) fieldState.width = width;
    }

    return fieldState;
},

// internal method that modifies this.completeFields according to the fieldState argument
// doesn't redraw the LG; call setFieldState instead.
// -- DetailViewer has no way of removing unwanted fields from the fields array, so add an
// optional param hideExtraDSFields to add the additional fields from the DS with showIf:"false"
_setFieldState : function (fieldState, hideExtraDSFields) {
    if (fieldState == null) return this.getAllFields();
    var allFields = this.getAllFields();
    var remainingFields = allFields.getProperty(this.fieldIdProperty),
        completeFields = []
    ;

    // set visibility and width according to fieldState
    for (var i = 0; i < fieldState.length; i++) {
        var state = fieldState[i],
            field = allFields.find(this.fieldIdProperty, state.name)
        ;
        // if a field is specified in fieldState which is not present in the grid, check if its
        // a formula or summary field and add a field-def for it
        if (field == null) {
            if (state.userFormula || state.userSummary) {
                field={};
                field[this.fieldIdProperty] = state.name;
            } else continue;
        }
        remainingFields.remove(state.name);
        if (state.visible == false) {
            field.showIf = this._$false;
            field.hidden = true;
        } else {
            field.showIf = null;
            // set field.detail to false if the field is visible. This makes sure that
            // ds.combineFieldData skips setting detail to true on this field if the
            // field has been set to visible by the user.
            field.detail = false;
            field.hidden = false;
        }
        if (state.width != null && (!isNaN(state.width) || state.width=="*")) field.width = state.width;

        field.frozen = state.frozen;

        var undef;
        if (state.title) field.title = state.title;
        // restore state for userFomula and userSummary
        if (state.userFormula != null) field.userFormula = state.userFormula;
        if (state.userSummary != null) field.userSummary = state.userSummary;
        if (state.type != null) field.type = state.type;

        // for these fields, a value of null is meaningful vs undefined.  We want any such
        // meaningful value to override field defaults as supplied by the component or
        // datasource
        if (state.autoFitWidth !== undef && state.autoFitWidth != field.autoFitWidth) field.autoFitWidth = state.autoFitWidth;
        if (state.precision !== undef && state.precision != field.precision) field.precision = state.precision;
        if (state.decimalPrecision !== undef && state.decimalPrecision != field.decimalPrecision) field.decimalPrecision = state.decimalPrecision;
        if (state.decimalPad !== undef && state.decimalPad != field.decimalPad) field.decimalPad = state.decimalPad;
        completeFields.add(field);
    }

    // if a field is specified for the grid for which there is no entry in fieldState
    //   check for a preceding field in the grid's fields which is specified in the fieldState
    //    and put it after that one
    //   otherwise, place it after the last visible field if it's visible, or last field
    //    altogether if not
    // Undocumented feature "defaultFieldState" - if this exists and has an entry for any fields
    // not included in the explicit field state, apply it.
    // We use this in the ListGrid to re-apply the initial field settings from when "setFields"
    // was first called.
    var defaultFieldState = this.defaultFieldState;
    if (defaultFieldState != null) defaultFieldState = this.evalViewState(defaultFieldState, "fieldState");

    for (var i = 0; i < remainingFields.length; i++) {
        var name = remainingFields[i],
            index = allFields.findIndex(this.fieldIdProperty, name),
            field = allFields[index],
            precedingField = allFields[index - 1];

        var defaultState = defaultFieldState ? defaultFieldState.find("name", name) : null;
        // don't modify fields where there was no default state
        // In this case we want fields to remain at their current size, visibility, etc
        if (defaultState != null) {

            var hidden = defaultState.visible == false;
            if (hidden) {
                field.showIf = this._$false;
            } else {
                field.showIf = null;

                // set field.detail to false if the field is visible. This makes sure that
                // ds.combineFieldData skips setting detail to true on this field if the
                // field has been set to visible by the user.
                field.detail = false;
            }

            if (defaultState.width != null
                && (!isNaN(defaultState.width) || defaultState.width=="*"))
            {
                field.width = defaultState.width;
            }
            field.frozen = defaultState.frozen;

            if (defaultState.title) field.title = defaultState.title;
            // restore state for userFomula and userSummary
            if (defaultState.userFormula != null) field.userFormula = defaultState.userFormula;
            if (defaultState.userSummary != null) field.userSummary = defaultState.userSummary;
            if (defaultState.autoFitWidth != field.autoFitWidth) field.autoFitWidth = defaultState.autoFitWidth;
        }

        if (precedingField != null) {
            var precedingIndex = completeFields.indexOf(precedingField);
            if (precedingIndex != -1) {
                completeFields.addAt(field, precedingIndex + 1);
                continue;
            }
        }

        if (this.fieldShouldBeVisible(field, index) && !hideExtraDSFields) {
            completeFields.addAt(field, this._lastVisibleFieldIndex(completeFields) + 1);
        } else {
            completeFields.add(field);
        }
    }
    //this.completeFields = completeFields;
    return completeFields;
},

// observe this method to be notified on column resize or reorder and show/hide/freeze field
fieldStateChanged : function () {},

// returns the last visible field in an array of fields
_lastVisibleFieldIndex : function (fields) {
    if (fields == null) fields = this.completeFields;
    var visibleFields = this.getVisibleFields(fields);
    if (visibleFields.length == 0) return -1;
    return fields.lastIndexOf(visibleFields.last());
},

// determine which of the passed fields should be shown, and return them as a new array
getVisibleFields : function (fields) {
    var visibleFields = [];
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        // make sure we don't have any null fields
        if (field == null) continue;

        if (this.fieldShouldBeVisible(field, i)) visibleFields.add(field);
    }
    return visibleFields;
},

// fieldShouldBeVisible: intended as a possible advanced override point for a field visibility
// policy not easily expressed via showIf()
_$falseSemi:"false;",
_$false:"false",
_$true:"true",
fieldShouldBeVisible : function (field, fieldNum) {
    // evaluate a showIf expression if present
    if (field.showIf != null) {
        // CALLBACK API:  available variables:  "list,field,fieldNum"
        // Convert a string callback to a function


        if (field.showIf == this._$false || field.showIf == this._$falseSemi) return false;
        if (field.showIf == this._$true) return true;
        isc.Func.replaceWithMethod(field, "showIf", "list,field,fieldNum");
        if (!field.showIf(this, field, fieldNum)) return false;
    } else if ((this.fields != null || !this.showHiddenFields) && field.hidden) {
        return false;
    }
    return true;
},

// ---------------------------------------------------------------------------------------

//>    @method    dataBoundComponent.setFieldValueMap()
// Set the valueMap for a field
//
// @param fieldID (String | int) name or index of the field to update
// @param valueMap (object) ValueMap for the field with the passed fieldID
//<
setFieldValueMap : function (field, valueMap) {

    if (!isc.isAn.Object(field)) field = this.getField(field);
    if (!field) return;

    field.valueMap = valueMap;
},

//> @method dataBoundComponent.find()
// This API is equivalent to +link{List.find()} but searches for a matching record among already-loaded data only.
// Use +link{listGrid.fetchData,fetchData} to load data from the server.
// @param advancedCriteria  (AdvancedCriteria)  AdvancedCriteria to use with
// @return (Object) first matching object or null if not found
//
// @visibility external
//<
find : function (advancedCriteria) {
   return this.data.find(advancedCriteria);
},

//> @method dataBoundComponent.findAll()
// This API is equivalent to +link{List.findAll()} but searches for a matching record among already-loaded data only.
// Use +link{listGrid.fetchData,fetchData} to load data from the server.
// @param advancedCriteria  (AdvancedCriteria)  AdvancedCriteria to use with
// @return (Array) all matching Objects or null if none found
//
// @visibility external
//<
findAll : function (advancedCriteria) {
    return this.data.findAll(advancedCriteria);
},
//> @method dataBoundComponent.findIndex()
// This API is equivalent to +link{List.findIndex()} but searches for a matching record among already-loaded data only.
// Use +link{listGrid.fetchData,fetchData} to load data from the server.
// @param advancedCriteria  (AdvancedCriteria)  AdvancedCriteria to use with
// @return (int) index of the first matching Object or -1 if not found
//
// @visibility external
//<
findIndex : function (advancedCriteria) {
    return this.data.findIndex(advancedCriteria);
},

//> @method dataBoundComponent.findNextIndex()
// This API is equivalent to +link{List.findNextIndex()} but searches for a matching record among already-loaded data only.
// Use +link{listGrid.fetchData,fetchData} to load data from the server.
// @param startIndex  (int)  first index to consider
// @param advancedCriteria  (AdvancedCriteria)  AdvancedCriteria to use with
// @param [endIndex]  (int) last index to consider
// @return (int) index of the first matching Object or -1 if not found
//
// @visibility external
//<
findNextIndex : function (startIndex, advancedCriteria, endIndex) {
    return this.data.findNextIndex(startIndex, advancedCriteria, null, endIndex);
},

//> @method dataBoundComponent.setDataSource()
// Bind to a new DataSource.
// <P>
// Like passing the "dataSource" property on creation, binding to a DataSource means that the
// component will use the DataSource to provide default data for its fields.
// <P>
// When binding to a new DataSource, if the component has any existing "fields" or has a dataset,
// these will be discarded by default, since it is assumed the new DataSource may represent a
// completely unrelated set of objects.  If the old "fields" are still relevant, pass them to
// setDataSource().
//
// @param dataSource  (ID or DataSource)  DataSource to bind to
// @param fields      (Array of Fields)  optional array of fields to use
//
// @visibility external
// @example WSDLDataSource
//<
setDataSource : function (dataSource, fields) {
    if (isc._traceMarkers) arguments.__this = this;

    // if passed in value is null then bind() will then work on the declared ds.
    this.dataSource = dataSource || this.dataSource;

    if (this.dataSource == null && !this.skipNullDataSourceCheck) {
        this.logWarn("Invalid call to setDataSource() passing null.  (Set the property " +
            "'skipNullDataSourceCheck' on the component to avoid this warning.)  If you're " +
            "having trouble with loading DataSources, please see the following FAQ: " +
            "http://forums.smartclient.com/showthread.php?t=8159#aDSLoad");
    }

    // NOTE: actual dataBinding, meaning picking up dataSource field data, is done by
    // "bindToDataSource".  This call *must* be within setFields() because setFields() may be
    // called again after binding, and must pick up DataSource field data at that time too.
    if (this.setFields) this.setFields(fields);

    // since we've (re)bound this widget, clear any data it may have as it may no longer be
    // valid.
    if (this.dataSource) {

        if (this.isA("DynamicForm")) this.setData({});
        else this.setData([]);
    }
    this.markForRedraw("bind");
},
// backCompat
bind : function (dataSource, fields) {
    this.setDataSource(dataSource, fields);
},

getDataSource : function () {
    if (isc.isA.String(this.dataSource)) {
        if (this.serviceNamespace || this.serviceName) {
            this.dataSource = this.lookupSchema();
        } else {
            var ds = isc.DS.get(this.dataSource);
            if (ds != null) return ds;

            // support "dataSource" being specified as the name of a global, and if so, assign
            // that to this.dataSource
            ds = this.getWindow()[this.dataSource];
            if (ds && isc.isA.DataSource(ds)) return (this.dataSource = ds);
        }
    }
    return this.dataSource;
},

makeDataSourceFromFields : function (id) {
    if (id == null) id = this.ID;

    var titleSuffix = "",
        criteriaBasePathSuffix,
        metaFields
    ;
    for (var className in isc.Canvas._dbcTypeDetails) {
        if (this.isA(className)) {
            titleSuffix = isc.Canvas._dbcTypeDetails[className].titleSuffix;
            criteriaBasePathSuffix = isc.Canvas._dbcTypeDetails[className].criteriaBasePathSuffix;
            metaFields = isc.Canvas._dbcTypeDetails[className].metaFields;
        }
    }
    if (criteriaBasePathSuffix) {
        criteriaBasePathSuffix = id + "." + criteriaBasePathSuffix;
    }
    var title = id + " " + titleSuffix,
        dsID = id + "_values"
    ;
    if (isc.DataSource.get(dsID)) {
        // This really shouldn't occur unless the user explicitly assigns the
        // same ID to two DBCs.
        var count = 2,
            testDsID;
        do {
            testDsID = dsID + count++;
        } while (isc.DataSource.get(testDsID));
        dsID = testDsID;
    }
    var properties = { ID: dsID, clientOnly: true, criteriaBasePath: criteriaBasePathSuffix, title: title, pluralTitle: title };

    var fields = this.fields || this.items;
    if (fields) {
        var dsFields = [];
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];

            // defensive null check
            if (!field) continue;

            var fieldName = field[this.fieldIdProperty],
                fieldType = (isc.isA.FormItem(field) ? field.getType() : field.type) || "text"
            ;
            if (fieldType == "select") fieldType = "text";

            dsFields.push({ name: fieldName, type: fieldType })
        }
        properties.fields = dsFields;
    }

    if (metaFields) {
        var dsFields = [];
        for (var i = 0; i < metaFields.length; i++) {
            var fieldName = metaFields[i],
                fieldType = isc.Canvas._dbcTypeMetaFieldTypes[fieldName]
            ;
            if (fieldType) {
                dsFields.push({ name: isc.Canvas._makeRuleScopeMetaFieldName(fieldName),
                    title: "[meta] " + fieldName,
                    type: fieldType,
                    criteriaPath: id + "." + fieldName
                });
            }
        }
        if (dsFields.length > 0) properties.fields.addList(dsFields);
    }

    return isc.DS.create(properties);
},

getDefaultData : function () { return []; },

setData : function (data) { this.data = data },

lookupSchema : function () {
    // see if we have a WebService instance with this serviceName / serviceNamespace
    var service;
    if (this.serviceName) service = isc.WebService.getByName(this.serviceName, this.serviceNamespace);
    else service = isc.WebService.get(this.serviceNamespace);

    if ((this.serviceNamespace || this.serviceName) && service == null) {
        this.logWarn("Could not find WebService definition: " +
                     (this.serviceName ? "serviceName: " + this.serviceName : "") +
                     (this.serviceNamespace ? "   serviceNamespace: " + this.serviceNamespace : ""));
    }

    // If this.dataSource is not a String, we shouldn't have ended up here
    if (!isc.isA.String(this.dataSource)) {
        this.logWarn("this.dataSource was not a String in lookupSchema");
        return;
    }

    var ds;
    if (service) ds = service.getSchema(this.dataSource);
    // note return this.dataSource if the lookup failed so that this.dataSource is still set to
    // the String value, even if we failed to look up the DataSource, since the service may
    // load later
    return ds || this.dataSource;
},


//>@method DataBoundComponent.fieldValuesAreEqual()
// Compares two values in the context of the passed field and returns true if they're equal.
// Used by components that need to check whether edited values are equivalent to saved values.
// <P>
// If passed a string field-name, a field with that name must be available either in the DBC
// directly, or in the associated +link{dataBoundComponent.dataSource, dataSource}.  If a field
// can be found, it's data type is used as the context for comparison.  Otherwise, a simple
// JavaScript comparison (a == b) is used, except in the case of Date values, which are
// compared as logical dates or times if either value is flagged as logical, or as milliseconds
// otherwise.
// @param field (object | String) field object or name of the field in the context of which the
//                                values should be compared
// @param value1 (any) first value to be compared
// @param value2 (any) second value to be compared
// @visibility internal
//<
// Leave visibility internal, but non obfuscated - we may allow developers to override this for
// custom field types
// Used by the saveData flow to compare updated values (from the server) with
// submitted values


fieldValuesAreEqual : function (field, value1, value2) {
    if (field != null) {
        // if passed field isn't an object, try to find one in fields, completeFields or DS
        if (!isc.isAn.Object(field)) field = this.getUnderlyingField(field) || field;

        if (field.type != null) {
            // If the type is a SimpleType with a compareValues() impl, use that first
            var simpleType = isc.SimpleType.getType(field.type);
            if (simpleType && simpleType.compareValues) {
                return simpleType.compareValues(value1, value2, field) == 0;
            }
            if (isc.SimpleType.inheritsFrom(field.type, "datetime")) {
                if (isc.isA.Date(value1) && isc.isA.Date(value2)) {
                    return (Date.compareDates(value1, value2) == 0);
                }
            } else if (isc.SimpleType.inheritsFrom(field.type, "date")) {
                if (isc.isA.Date(value1) && isc.isA.Date(value2)) {
                    return (Date.compareLogicalDates(value1, value2) == 0);
                }


            } else if (field.type == "valueMap") {
                if (isc.isAn.Array(value1) && isc.isAn.Array(value2)) {
                    return value1.equals(value2)

                } else if (isc.isAn.Object(value1) && isc.isAn.Object(value2)) {
                    for (var i in value1) {
                        if (value2[i] != value1[i]) return false;
                    }

                    for (var j in value2) {
                        if (value1[j] != value2[j]) return false;
                    }

                    // everything matched
                    return true;
                }
            }
        }
    }

    if (!isc.isAn.Object(field)) {
        // If no field was detected and both values are Date instances, compare them according
        // to whether they are logical dates or times, or do a basic millisecond comparison
        // otherwise.  If this behavior misfires for whatever reason, the developer should
        // provide a field.
        if (isc.isA.Date(value1) && isc.isA.Date(value2)) {
            if (value1.logicalDate || value2.logicalDate)
                return isc.Date.compareLogicalDates(value1, value2) == 0;
            else if (value1.logicalTime || value2.logicalTime)
                return isc.Time.compareLogicalTimes(value1, value2) == 0;
            else return value1.getTime() == value2.getTime();
        }
    }

    // no matter what the type, if we get this far, the field type had no custom comparison
    // mechanism - just rely on the "==" comparison

    if (value1 == value2) return true;

    // return false
    return false;
},

//> @attr dataBoundComponent.useFlatFields (boolean : null : IR)
// The <code>useFlatFields</code> flag causes all simple type fields anywhere in a nested
// set of DataSources to be exposed as a flat list for form binding.
// <P>
// <code>useFlatFields</code> is typically used with imported metadata, such as
// +link{XMLTools.loadXMLSchema,XML Schema} from a
// +link{XMLTools.loadWSDL,WSDL-described web service}, as a means of eliminating levels of XML
// nesting that aren't meaningful in a user interface, without the cumbersome and fragile
// process of mapping form fields to XML structures.
// <P>
// For example, having called +link{webService.getInputDS()} to retrieve the input message
// schema for a web service operation whose input message looks like this:
// <pre>
// &lt;FindServices&gt;
//     &lt;searchFor&gt;search text&lt;/searchFor&gt;
//     &lt;Options&gt;
//         &lt;caseSensitive&gt;false&lt;/caseSensitive&gt;
//     &lt;/Options&gt;
//     &lt;IncludeInSearch&gt;
//         &lt;serviceName&gt;true&lt;/serviceName&gt;
//         &lt;documentation&gt;true&lt;/documentation&gt;
//         &lt;keywords&gt;true&lt;/keywords&gt;
//     &lt;/IncludeInSearch&gt;
// &lt;/FindServices&gt;
// </pre>
// Setting <code>useFlatFields</code> on a +link{DynamicForm} that is bound to this input
// message schema would result in 5 +link{FormItem,FormItems} reflecting the 5 simple type
// fields in the message.
// <P>
// For this form, the result of +link{dynamicForm.getValues(),form.getValues()} might look
// like:
// <P>
// <pre>{
//    searchFor: "search text",
//    caseSensitive: false,
//    serviceName: true,
//    documentation : true,
//    keywords : true
// }</pre>
// When contacting a +link{WebService,WSDL web service}, these values can be automatically
// mapped to the structure of the input message for a web service operation by setting
// +link{wsRequest.useFlatFields} (for use with +link{webService.callOperation()}) or by setting
// +link{dsRequest.useFlatFields} (for use with a +link{DataSource} that is
// +link{group:wsdlBinding,bound to a WSDL web service} via
// +link{operationBinding.wsOperation}).
// <P>
// Using these two facilities in conjunction (component.useFlatFields and
// request.useFlatFields) allows gratuitous nesting to be consistently bypassed in both the user
// presentation and when providing the data for XML messages.
// <P>
// You can also set +link{operationBinding.useFlatFields} to automatically enable
// "flattened" XML serialization (request.useFlatFields) for all DataSource requests of a
// particular operationType.
// <P>
// Note that <code>useFlatFields</code> is not generally recommended for use with structures
// where multiple simple type fields exist with the same name, however if used with such a
// structure, the first field to use a given name wins.  "first" means the first field
// encountered in a depth first search.  "wins" means only the first field will be present as a
// field when data binding.
//
// @visibility external
//<

//> @attr dataBoundComponent.showFilterFieldsOnly (boolean : null : IRWA)
// If this attribute is true any +link{dataSourceField.canFilter,canFilter:false} fields
// specified on the dataSource will not be shown unless explicitly included in this component's
// +link{dataBoundComponent.fields,fields array}
//<
// Exposed and defaulted to true on SearchForm

// minimal implementation of setFields()
setFields : function (fields) {
    // combine specified "fields" with reference declarations in the dataSource
    fields = this.bindToDataSource(fields);
    this.updateFieldDependencies();
    this.fields = fields;
},

// common routine; call in all component implementations
updateFieldDependencies : function () {

    this.invalidateUserCache();
    // recreate common varMaps for the component from the varMaps of the individual fields
    this.rebuildAllFieldsFormulaVarMaps();
},

getSerializeableFields : function (removeFields, keepFields) {
    removeFields = removeFields || [];

    // data may actually be valid in some cases - but removing it is a good default.
    removeFields.addList(["zIndex", "data"]);

    // don't save ID if it's auto-generated
    if (this.ID && this.ID.startsWith("isc_")) removeFields.add("ID");

    // if this component is bound to a datasource, don't serialize its fields or items

    if (this.dataSource) removeFields.addList(["fields", "items"]);

    // we only want to serialize children created explicitly by a developer - not children
    // auto-created by an ISC component (such as the ListGrid header)

    if (this.getClassName() != "Canvas" && this.getClassName() != "Layout") {
        removeFields.add("children");
    }

    return this.Super("getSerializeableFields", [removeFields, keepFields], arguments);
},


addField : function (field, index, fields) {
    if (field == null) return;

    if (fields == null) fields = (this.fields || this.items || isc._emptyArray);
    fields = fields.duplicate();

    // if this field already exists, replace it

    var existingField = isc.Class.getArrayItem(field.name, this.getAllFields(), this.fieldIdProperty);
    if (existingField) fields.remove(existingField);

    // If index wasn't passed, add at the end (Array.addAt() defaults to the beginning)
    // Also, if the requested index is greater than the size of the array, just add to
    // the end.  This is a corner case that can happen in VB, where the same index is
    // being used for two different things (index into the list of a DBC's fields and
    // index into the list of a DBC's children in the componentTree - sometimes the same
    // thing, but not necessarily so)
    if (index == null || index > fields.length) index = fields.length;
    fields.addAt(field, index);
    this.setFields(fields);
},

removeField : function (fieldName, fields) {
    if (fields == null) fields = (this.fields || this.items || isc._emptyArray);
    fields = fields.duplicate();

    // Cope with being passed an object rather than a name
    var name = fieldName.name ? fieldName.name : fieldName;
    fields.remove(fields.find("name", name));
    this.setFields(fields);
},

// DataBound Component Methods
// --------------------------------------------------------------------------------------------
//> @groupDef dataBoundComponentMethods
// An Action Method initiates an orchestrated client-server flow that stores or retrieves data
// and updates one or more components.
// <P>
// For example, the +link{DynamicForm.saveData(),editor.saveData()} Action Method saves the
// record currently being edited in the form, transparently handling the trip to the server,
// standard error conditions such as validation errors (whether the validation error
// happens on the client or server), and update of client-side caches.
// <P>
// Action Methods are available on DataBoundComponents.
//
// @treeLocation Client Reference/Data Binding
// @see interface:DataBoundComponent
// @title DataBound Component Methods
// @visibility external
//<

// NOTE: the DataBound Component Methods are mostly implemented directly on Canvas, and act
// as a basic framework for building a DataBound widget, however, we document them as existing
// on the specific components where it actually makes sense to call them.

//> @method listGrid.fetchData()
// @include dataBoundComponent.fetchData()
// @group dataBoundComponentMethods
// @visibility external
// @example databoundFetch
//<

//> @method listGrid.exportData()
// @include dataBoundComponent.exportData()
// @group dataBoundComponentMethods
// @visibility external
//<

//>    @attr listGrid.autoFetchData       (boolean : false : IR)
// @include dataBoundComponent.autoFetchData
// @group databinding
// @visibility external
// @example fetchOperation
//<

// Note: listGrid.autoFetchTextMatchStyle overridden and documented in ListGrid.js

//> @attr listGrid.initialCriteria   (Criteria : null :IR)
// @include dataBoundComponent.initialCriteria
// @group dynamicCriteria
// @visibility external
//<

//> @method listGrid.filterData()
// @include dataBoundComponent.filterData()
// @group dataBoundComponentMethods
// @visibility external
// @example databoundFilter
//<

//> @method listGrid.fetchRelatedData()
// @include dataBoundComponent.fetchRelatedData()
// @group dataBoundComponentMethods
// @visibility external
//<

//> @method listGrid.clearCriteria()
// @include dataBoundComponent.clearCriteria()
// @group dataBoundComponentMethods
// @visibility external
// @example databoundFilter
//<

//> @method listGrid.getCriteria()
// Retrieves a copy of the current criteria for this component (may be null).
// <P>
// Note: if +link{listGrid.showFilterEditor} is true, the criteria returned by this method may not
// match the values currently displayed in the filter editor, since the user may have entered
// values which have not yet been applied to our data. +link{listGrid.getFilterEditorCriteria()}
// may be used to retrieve the current criteria displayed in the filterEditor.
// @include dataBoundComponent.getCriteria()
// @group dataBoundComponentMethods
// @visibility external
//<
//> @method listGrid.setCriteria()
// Sets this component's filter criteria.
// Default implementation calls this.data.setCriteria().
// <P>
// Note: if +link{listGrid.showFilterEditor} is true, the +link{listGrid.setFilterEditorCriteria()}
// method may be used to update the values displayed in the filter editor without effecting the
// data object.
// @include dataBoundComponent.setCriteria()
// @group dataBoundComponentMethods
// @visibility external
//<
// Overridden in ListGrid.js to apply the new criteria to the filter editor if it is showing


//> @method listGrid.invalidateCache()
// @include dataBoundComponent.invalidateCache()
// @group dataBoundComponentMethods
// @visibility external
//<

//> @method listGrid.refreshData()
// @include dataBoundComponent.refreshData()
// @group dataBoundComponentMethods
// @visibility external
//<

//> @method listGrid.willFetchData()
// @include dataBoundComponent.willFetchData()
// @visibility external
//<


//> @method listGrid.addData()
// @include dataBoundComponent.addData()
// @group dataBoundComponentMethods
// @visibility external
// @example databoundAdd
//<

//> @method listGrid.updateData()
// @include dataBoundComponent.updateData()
// @group dataBoundComponentMethods
// @visibility external
// @example databoundUpdate
//<

//> @method listGrid.removeSelectedData()
// @include dataBoundComponent.removeSelectedData()
// @group dataBoundComponentMethods
// @visibility external
// @example removeOperation
//<

//> @method listGrid.getSelectedRecord()
// Returns the first selected record in this grid.
// <p>
// This method is appropriate if the +link{attr:selectionType,selectionType} is
// <smartclient>"single",</smartclient>
// <smartgwt>{@link com.smartgwt.client.types.SelectionStyle#SINGLE},</smartgwt>
// or if you only care about the first selected record in a multiple-record selection. To access
// all selected records, use +link{method:getSelection()} instead.
// <p>
// <strong>NOTE:</strong> If a record is returned, it should be treated as read-only and not
// modified.
//      @group  selection
//      @return (ListGridRecord) the first selected record, or null if no record is selected.
// @visibility external
// @example databoundRemove
//<

//> @method listGrid.getSelectedRecords()
// Returns all selected records in this grid.
// <p>
// <strong>NOTE:</strong> Records in the returned array should be treated as read-only and not
// modified.
// @param [excludePartialSelections] (boolean) When true, partially selected records will not be returned.
//                                   Otherwise, both fully and partially selected records are
//                                   returned.
// @return (Array of ListGridRecord) array of selected records, which will be empty if no record
// is selected.
// @group  selection
// @visibility external
//<

//> @method treeGrid.fetchData()
// Uses a "fetch" operation on the current +link{DataSource,grid.dataSource} to retrieve data
// that matches the provided criteria, and displays the matching data in this component as a
// tree.
// <P>
// This method will create a +link{ResultTree} to manage tree data, which will
// subsequently be available as <code>treeGrid.data</code>.  DataSource records
// returned by the "fetch" operation are linked into a tree structure according to
// +link{dataSourceField.primaryKey,primaryKey} and
// +link{dataSourceField.foreignKey,foreignKey} declarations on DataSource fields.  See the
// +link{group:treeDataBinding} topic for complete details.
// <P>
// By default, the created ResultTree will use folder-by-folder load on demand, asking the
// server for the children of each folder as the user opens it.
// <P>
// The +link{ResultTree} created by <code>fetchData()</code> can be customized by setting
// +link{listGrid.dataProperties} to an Object containing properties and methods to apply to
// the created ResultTree.  For example, the property that determines whether a node is a
// folder (+link{Tree.isFolderProperty,isFolderProperty}) can be customized, or
// level-by-level loading can be disabled via
// +link{resultTree.loadDataOnDemand,loadDataOnDemand:false}.
// <P>
// If +link{loadDataOnDemand} is true, this grid will issue fetch requests each time the
// user opens a folder to load its child data.<br>
// The criteria on this fetch request will consist of the appropriate value for the
// foreignKey field, combined with the criteria passed to <code>fetchData()</code>
// when the data was first loaded.
// This allows you to retrieve multiple different tree structures from the same DataSource.
// However note that the server is expected
// to always respond with an intact tree - returned nodes which do not have parents are dropped
// from the dataset and not displayed.
// <P>
// The callback passed to <code>fetchData</code> will fire once, the first time that data is
// loaded from the server.  If using folder-by-folder load on demand, use the
// +link{resultTree.dataArrived()} notification to be notified each time new nodes are loaded.
// <P>
// Note that when calling 'fetchData()', changes to criteria may or may not result in a
// DSRequest to the server due to client-side filtering (see +link{ResultTree.fetchMode}.
// You can call willFetchData(criteria) to determine if new criteria will result in a
// server fetch.
// <P>
// If you need to force data to be re-fetched, you can call invalidateCache() and
// new data will automatically be fetched from the server using the current criteria
// and sort direction.<br>
// When using invalidateCache() there is no need to also call fetchData() and
// in fact this could produce unexpected results.
// <P>
//
// @include dataBoundComponent.fetchData()
// @group dataBoundComponentMethods
// @visibility external
//<

//> @method treeGrid.filterData()
// Retrieves data that matches the provided criteria and displays the matching data in this
// component.
// <P>
// This method behaves exactly like +link{treeGrid.fetchData()} except that
// +link{dsRequest.textMatchStyle} is automatically set to "substring" so that String-valued
// fields are matched by case-insensitive substring comparison.
//
// @include dataBoundComponent.filterData()
// @group dataBoundComponentMethods
// @visibility external
//<

//> @method tileGrid.exportData()
// @include dataBoundComponent.exportData()
// @group dataBoundComponentMethods
// @visibility external
//<

//> @attr detailViewer.initialCriteria   (Criteria : null :IR)
// @include dataBoundComponent.initialCriteria
// @visibility external
//<

//> @attr detailViewer.autoFetchData       (boolean : false : IR)
// @include dataBoundComponent.autoFetchData
// @group databinding
// @visibility external
//<

//> @method detailViewer.exportData()
// @include dataBoundComponent.exportData()
// @group dataBoundComponentMethods
// @visibility external
//<

//>    @attr dynamicForm.autoFetchData       (boolean : false : IR)
// @include dataBoundComponent.autoFetchData
// @group databinding
// @visibility external
//<

//>    @attr dynamicForm.autoFetchTextMatchStyle       (TextMatchStyle : null : IR)
// @include dataBoundComponent.autoFetchTextMatchStyle
// @group databinding
// @visibility external
//<

//> @attr dynamicForm.initialCriteria   (Criteria : null :IR)
// @include dataBoundComponent.initialCriteria
// @visibility external
//<



// Filtering
// -----------------------------------------------------------------------------

// whether this control should show end-user editing controls (if it is capable of doing so).
setCanEdit : function (newValue) {
    this.canEdit = newValue;
},

//>    @method dataBoundComponent.filterData()
// Retrieves data that matches the provided criteria and displays the matching data in this
// component.
// <P>
// This method behaves exactly like +link{listGrid.fetchData()} except that
// +link{dsRequest.textMatchStyle} is automatically set to "substring" so that String-valued
// fields are matched by case-insensitive substring comparison.
//
// @param [criteria]          (Criteria)      Search criteria.
//                      If a +link{DynamicForm} is passed in as this argument
//                      instead of a raw criteria object, will be derived by calling
//                      +link{DynamicForm.getValuesAsCriteria()}
// @param [callback]          (DSCallback)  callback to invoke when a fetch is complete.  Fires
//                                          only if server contact was required; see
//                                          +link{listGrid.fetchData,fetchData()} for details
// @param [requestProperties] (DSRequest)   for databound components only - optional
//                           additional properties to set on the DSRequest that will be issued
//
// @see dataBoundComponent.willFetchData()
// @group dataBoundComponentMethods
// @visibility internal
//<
filterData : function (criteria, callback, requestProperties) {
    this._filter("filter", criteria, callback, requestProperties);
},

//> @method dataBoundComponent.fetchData()
// Retrieves data from the DataSource that matches the specified criteria.
// <p>
// When <code>fetchData()</code> is first called, if data has not already been provided via
// +link{listGrid.setData(),setData()}, this method will create a +link{class:ResultSet}, which will be
// configured based on component settings such as +link{attr:dataBoundComponent.fetchOperation}
// and +link{attr:dataBoundComponent.dataPageSize}, as well as the general purpose
// +link{listGrid.dataProperties}.  The created ResultSet will automatically send a DSRequest
// to retrieve data from +link{listGrid.dataSource,listGrid.dataSource}, and from then on will
// automatically manage paging through large datasets, as well as performing filtering and
// sorting operations inside the browser when possible - see the +link{ResultSet} docs for
// details.
// <p>
// <b>NOTE:</b> do not use <b>both</b> +link{dataBoundComponent.autoFetchData,autoFetchData:true} <b>and</b> a
// call to <code>fetchData()</code> - this may result in two DSRequests to fetch data.  Use
// either +link{dataBoundComponent.autoFetchData,autoFetchData} and +link{criteria} <b>or</b> a manual call to fetchData()
// passing criteria.
// <p>
// Whether a ResultSet was automatically created or provided via +link{listGrid.setData(),setData()}, subsequent
// calls to fetchData() will simply call +link{resultSet.setCriteria()}.
// <p>
// Changes to criteria may or may not result in a DSRequest to the server due to
// +link{resultSet.useClientFiltering,client-side filtering}.  You can call
// +link{dataBoundComponent.willFetchData,willFetchData(criteria)} to determine if new criteria will result in a
// server fetch.
// <P>
// If you need to force data to be re-fetched, you can call
// +link{ListGrid.invalidateCache,invalidateCache()} and new data will automatically be fetched
// from the server using the current criteria and sort direction.  <b>NOTE:</b> when using
// <code>invalidateCache()</code> there is no need to <b>also</b> call <code>fetchData()</code>
// and in fact this could produce unexpected results.
// <p>
// This method takes an optional callback parameter (set to a +link{DSCallback}) to fire when
// the fetch completes. Note that this callback will not fire if no server fetch is performed.
// In this case the data is updated synchronously, so as soon as this method completes you
// can interact with the new data. If necessary, you can use
// +link{dataBoundComponent.willFetchData,willFetchData()} to determine whether or not a server
// fetch will occur when <code>fetchData()</code> is called with new criteria.
// <p>
// In addition to the callback parameter for this method, developers can use
// +link{ListGrid.dataArrived(),dataArrived()} to be notified every time data is loaded.
// <p>
// By default, this method assumes a +link{textMatchStyle} of "exact"; that can be overridden
// by supplying a different value in the requestProperties parameter.
// See +link{dataBoundComponent.willFetchData()};
//
// @param [criteria]          (Criteria)    Search criteria. If a +link{DynamicForm} is passed
//                                          in as this argument instead of a raw criteria
//                                          object, will be derived by calling
//                                          +link{DynamicForm.getValuesAsCriteria()}
// @param [callback]          (DSCallback)  callback to invoke when a fetch is complete. Fires
//                                          only if server contact was required
// @param [requestProperties] (DSRequest)   additional properties to set on the DSRequest
//                                          that will be issued
//
// @group dataBoundComponentMethods
// @visibility internal
// @see listGrid.refreshData
//<
// NOTE: this doc is marked internal because listGrid.fetchData() @includes it and makes it
// external
fetchData : function (criteria, callback, requestProperties) {
    if (!requestProperties) requestProperties = {};
    if (!requestProperties.textMatchStyle) requestProperties.textMatchStyle = "exact";
    this._filter("fetch", criteria, callback, requestProperties);
},

_canExportField : function (field) {
    return (this.canExport != false && field.canExport != false &&
            !field.hidden)
    ;
},

//>    @method dataBoundComponent.exportData()
// Sends the current filter criteria and sort direction to the server, then exports data in the
// requested +link{dsRequest.exportAs,exportFormat}.
// <P>
// A variety of DSRequest settings, such as
// +link{dsRequest.exportAs,exportAs} and +link{dsRequest.exportFilename}, affect the
// exporting process: see +link{dsRequest.exportResults, exportResults} for further detail.
// <P>
// Note that data exported via this method does not include any client-side formatting and
// relies on both the SmartClient server and server-side DataSources.  To export client-data
// with formatters applied,
// see +link{listGrid.exportClientData, exportClientData}, which still requires the
// SmartClient server but does not rely on server-side DataSource definitions (.ds.xml files).
// <P>
// For more information on exporting data, see +link{dataSource.exportData()}.
//
// @param [requestProperties] (DSRequest)   additional properties to set on the DSRequest
//                                            that will be issued
// @param [callback] (DSCallback)   callback to invoke on completion.  Note that this parameter
//                                  only applies where +link{dsRequest.exportToClient} is
//                                  explicitly set to false, because  file downloads do not
//                                  provide ordinary SmartClient callbacks
//
// @group dataBoundComponentMethods
// @visibility external
//<
exportData : function (requestProperties, callback) {
    if (!requestProperties) requestProperties = {};

    var sort = this.getSort();
    if (sort) {
        requestProperties.sortBy = isc.DS.getSortBy(sort);
    } else if (this.sortField) {
        requestProperties.sortBy = (Array.shouldSortAscending(this.sortDirection) ? "" : "-")
            + this.sortField;
    }

    if (!requestProperties.textMatchStyle) {
        // if not provided, set the textMatchStyle to that already in use in this component
        var context = this.data.context;
        if (context && context.textMatchStyle) {
            requestProperties.textMatchStyle = context.textMatchStyle;
        }
    }

    if (!this.exportAll && !requestProperties.exportFields) {
        // pass up only visible fields
        var vFields = this.exportFields,
            outputs = "",
            ds = this.getDataSource()
        ;

        if (!vFields) {
            vFields = [];
            for (var i = 0; i < this.fields.length; i++) {
                var field = this.fields.get(i),
                    dsField = ds ? ds.getField(field.name) : null
                ;

                if (this._canExportField(field)) {
                    if (field.includeFrom || (dsField && dsField.includeFrom)) {
                        var includeFrom = field.includeFrom ? field.includeFrom :
                                dsField.includeFrom;

                        outputs += field.name + "!" + includeFrom + ",";
                        vFields.add(field.name);
                    } else {
                        vFields.add(field.name);
                    }

                    if (field.displayField && !field.optionDataSource) {
                        vFields.add(field.displayField);
                    }
                }
            }
        }
        if (outputs.length > 1) {
            if (outputs.endsWith(",")) {
                outputs = outputs.substring(0, outputs.length-1);
            }
            requestProperties.additionalOutputs = outputs;
        }
        if (vFields && vFields.length > 0) requestProperties.exportFields = vFields;
    }

    var wkFields = requestProperties.exportFields || this.exportFields || this.fields,
        exportFieldTitles = {},
        ds = this.getDataSource();

    for (var i = 0; i < wkFields.length; i++) {
        var field = wkFields[i];
        var fieldName;
        if (isc.isA.String(field)) {
            fieldName = field;
            field = this.getField(fieldName);
            if (!field && ds != null) field = ds.getField(fieldName);
        }
        if (field) {
            exportFieldTitles[field.name] = this.htmlUnescapeExportFieldTitle(field.exportTitle || field.title);
        } else {
            exportFieldTitles[fieldName] = this.htmlUnescapeExportFieldTitle(fieldName);
        }
    }
    requestProperties.exportFieldTitles = exportFieldTitles;

    if (requestProperties.exportRawValues == null) {
        requestProperties.exportRawValues = true;
    }

    if (this.headerHeight && this.exportHeaderHeights) {
        requestProperties.exportHeaderHeight = this.headerHeight;
    }

    // header spans
    var exportTitles = {};
    if (this.headerSpans && requestProperties.exportShowHeaderSpanTitles !== false) {
        requestProperties.exportHeaderSpans =
            this.prepareHeaderSpansForExport(this.headerSpans, this.getAllFields(), exportTitles);
    }

    // non-spanned fields
    // 'exportOtherFields' is passed to the server so that it knows what titles to use for
    // non-spanned fields.
    requestProperties.exportOtherFields = {};
    for (var i = 0; i < wkFields.length; ++i) {
        var fieldName = wkFields[i];
        if (!exportTitles.hasOwnProperty(fieldName)) {
            requestProperties.exportOtherFields[fieldName] = exportFieldTitles[fieldName];
        }
    }

    if (this.exportFieldWidths && isc.isAn.Array(this.fields) && this.getFieldWidth) {
        requestProperties.exportFieldPixelWidths = this.getFieldPixelWidths();
        requestProperties.exportWidthScale = this.exportWidthScale;
    }

    if (requestProperties.exportWrapHeaderTitles == null) {
        requestProperties.exportWrapHeaderTitles = this.exportWrapHeaderTitles;
    }

    if (this.exportFieldAlignments && isc.isAn.Array(this.fields)) {
        requestProperties.exportAlignments = this.getFieldAlignments();
    }

    if (requestProperties.exportPropertyIdentifier == null) {
        requestProperties.exportPropertyIdentifier = "name";
    }

    this.getDataSource().exportData(this.getCriteria(), requestProperties, callback, this);
},

getFieldPixelWidths : function() {
    var widths = [];
    for (var i = 0; i < this.fields.length; i++) {
        if (this.fields[i].exportFieldWidth === false) {
            widths[i] = -1;
        } else {
            widths[i] = this.getFieldWidth(i);
        }
    }
    return widths;
},

//> @method dataBoundComponent.getFieldAlignments()
// Returns an array of +link{type:Alignment,field alignments} for this grid
// @return (Array of Alignment)
// @visibility external
//<
getFieldAlignments : function() {
    var alignments = [];
    for (var i = 0; i < this.fields.length; i++) {
        alignments[i] = []
        // If alignments are not explicitly stated, we force SmartClient's default values
        // for export rather than allow Excel or whatever to make the decision.  We do this
        // so that there is the same consistent columnar alignment seen in the browser, rather
        // than allowing Excel to make its own decision about each cell
        var field = this.fields[i],
            type = isc.SimpleType.getBaseType(field.type);
        if (field.align) {
            alignments[i][0] = field.align;
        } else if (type == "integer" || type == "float" || type == "date" || type == "time") {
            alignments[i][0] = "right";
        } else {
            alignments[i][0] = "left";
        }
        if (field.cellAlign) {
            alignments[i][1] = field.cellAlign;
        } else {
            alignments[i][1] = alignments[i][0];
        }
    }
    return alignments;
},

//> @method dataBoundComponent.setCriteria()
// Sets this component's filter criteria.
// Default implementation calls this.data.setCriteria().
// @param (Criteria or AdvancedCriteria) new criteria to show
//<
setCriteria : function (criteria) {
    if (this.data && this.data.setCriteria) {
        this.data.setCriteria(criteria);
    } else {
        // if there is no data yet, set initial criteria to parameter criteria
        this.initialCriteria = criteria;
    }
},

//> @method dataBoundComponent.getCriteria()
// Retrieves a copy of the current criteria for this component, excluding criteria specified by
// +link{dataBoundComponent.implicitCriteria}.  May return null.
// @return (Criteria) current filter criteria
//<
// Overridden for CubeGrids
getCriteria : function (excludeImplicit) {
    var result;
    if (!this.isDrawn() && (!this.data || this.data.getLength() == 0)) {
        result = isc.shallowClone(this.initialCriteria);
    } else if (this.data && this.data.getCriteria) {
        if (isc.isA.Tree(this.data)) {

            result = isc.shallowClone(this.data.getCriteria(this.getDataSource()));
        } else {
            result = isc.shallowClone(this.data.getCriteria());
        }
    } else result = null;

    return result;
},

//>    @attr dataBoundComponent.autoFetchData (boolean : false : IR)
// If true, when this component is first drawn, automatically call <code>this.fetchData()</code>.
// Criteria for this fetch may be picked up from +link{initialCriteria}, and textMatchStyle may
// be specified via +link{listGrid.autoFetchTextMatchStyle,autoFetchTextMatchStyle}.
// <P>
// <span style='color:red'>NOTE:</span> if <code>autoFetchData</code> is set, calling
// +link{listGrid.fetchData(),fetchData()} before draw will cause two requests to be issued, one from the manual
// call to fetchData() and one from the autoFetchData setting.  The second request will use
// only +link{initialCriteria} and not any other criteria or settings from the first request.
// Generally, turn off autoFetchData if you are going to manually call +link{listGrid.fetchData(),fetchData()} at any time.
//
// @group dataBoundComponentMethods
// @visibility external
// @see listGrid.fetchData()
//<

// Called at draw() - if we are databound, and autoFetchData is true, do a one time fetch on initial draw.
doInitialFetch : function () {
    var fetchQueued = false;
    if (this.autoFetchData && !this._initialFetchFired && this.fetchData) {

        if (!this.dataSource) {
            this.logWarn("autoFetchData is set, but no dataSource is specified, can't fetch");
        } else {
            // Queue the fetch - this means we can batch up any requests our children make on draw
            // and send them all off together
            // Specific use case: this means if a ListGrid is autoFetchData:true and has a field
            // with an optionDataSource we can use the same transaction to fetch the valid options
            // as to fetch the LG data
            fetchQueued = !isc.RPCManager.startQueue();
            // getInitialCriteria() picks up this.initialCriteria
            // getInitialFetchContext() picks up this.autoFetchTextMatchStyle
            this.fetchData(this.getInitialCriteria(), null, this.getInitialFetchContext());

            this._initialFetchFired = true;
        }
    }
    return fetchQueued;
},

// getInitialCriteria() - used to retrieve the initialCriteria when performing auto-fetch of data
getInitialCriteria : function () {
    if (!this.initialCriteria) return null;
    return isc.shallowClone(this.initialCriteria);
},

getInitialFetchContext : function () {
    var context = {};
    context.textMatchStyle = this.autoFetchTextMatchStyle;
    return context;
},

//> @attr dataBoundComponent.autoFetchTextMatchStyle (TextMatchStyle : null : IR)
// If +link{autoFetchData} is <code>true</code>, this attribute allows the developer to
// specify a textMatchStyle for the initial +link{listGrid.fetchData(),fetchData()} call.
// @group dataBoundComponentMethods
// @visibility internal
//<

//> @attr dataBoundComponent.initialCriteria (Criteria : null : IR)
// Criteria to be used when +link{autoFetchData} is set.
// @visibility external
//<

//> @attr dataBoundComponent.implicitCriteria (Criteria : null : IRW)
// Criteria that are never shown to or edited by the user and are cumulative with any criteria
// provided via +link{dataBoundComponent.initialCriteria}, +link{dataBoundComponent.setCriteria}
// etc.
// @visibility external
//<

getImplicitCriteria : function () {
    if (!this.implicitCriteria) return null;
    return isc.shallowClone(this.implicitCriteria);
},

//> @method dataBoundComponent.fetchRelatedData()
// Based on the relationship between the DataSource this component is bound to and the
// DataSource specified as the "schema" argument, call fetchData() to retrieve records in this
// grid that are related to the passed-in record.
// <P>
// Relationships between DataSources are declared via +link{dataSourceField.foreignKey}.
// <P>
// For example, given two related DataSources "orders" and "orderItems", where we want to fetch
// the "orderItems" that belong to a given "order".  "orderItems" should declare a field that
// is a +link{dataSourceField.foreignKey,foreignKey} to the "orders" table (for example, it
// might be named "orderId" with foreignKey="orders.id").  Then, to load the records related to
// a given "order", call fetchRelatedData() on the component bound to "orderItems", pass the
// "orders" DataSource as the "schema" and pass a record from the "orders" DataSource as the
// "record" argument.
//
// @param record              (ListGridRecord) DataSource record
// @param schema              (Canvas or DataSource or ID) schema of the DataSource record, or
//                            DataBoundComponent already bound to that schema
// @param [callback]          (DSCallback)  callback to invoke on completion
// @param [requestProperties] (DSRequest)   additional properties to set on the DSRequest
//                                            that will be issued
//
// @visibility internal
//<
fetchRelatedData : function (record, schema, callback, requestProperties) {
    var otherDS = isc.isA.DataSource(schema) ? schema :
            isc.isA.String(schema) ? isc.DS.get(schema) :
            isc.isA.Canvas(schema) ? schema.dataSource : null;
    if (!otherDS) {
        this.logWarn("schema not understood: " + this.echoLeaf(schema));
        return;
    }
    var relationship = this.getDataSource().getTreeRelationship(otherDS);

    // form criteria to find related records
    var criteria = {};
    criteria[relationship.parentIdField] = record[relationship.idField];

    this.fetchData(criteria, callback, requestProperties);
},

//>    @method dataBoundComponent.clearCriteria()
// Clear the current criteria used to filter data.
//
// @param [callback]          (DSCallback)  callback to invoke on completion
// @param [requestProperties] (DSRequest)   additional properties to set on the DSRequest
//                                            that will be issued
//
// @see listGrid.fetchData()
//
// @group dataBoundComponentMethods
// @visibility internal
//<
clearCriteria : function (callback, requestProperties) {
    this._filter("filter", null, callback, requestProperties);
},

_filter : function (type, criteria, callback, requestProperties) {
    if (isc._traceMarkers) arguments.__this = this;

    requestProperties = this.buildRequest(requestProperties, type, callback);

    // Resolve dynamicCriteria except for PickListMenus. A PickListMenu
    // is provided criteria from optionCriteria handled by the containing
    // FormItem.
    if (criteria && (!isc.isA.PickListMenu || !isc.isA.PickListMenu(this))) {

        if (!isc.DS.isAdvancedCriteria(criteria)) {
            var criteria = isc.addProperties({}, criteria);

            if (criteria.operator && criteria.criteria) {
                // Advanced format but missing constructor
                criteria._constructor = "AdvancedCriteria";
            } else if (criteria.fieldName && criteria.operator) {
                // Shorthand format
                criteria = {
                        _constructor: "AdvancedCriteria",
                        operator: "and",
                        criteria: isc.isAn.Array(criteria) ? criteria : [criteria]
                };
            }
        }

        if (isc.DS.isAdvancedCriteria(criteria)) {
            criteria = isc.DataSource.resolveDynamicCriteria(criteria, this.getRuleContext());
        }
    }

    // notification method fired when the user modifies the criteria in the filter editor
    // and hits the filter button / enter key.

    if (this.onFetchData != null) {
        this.onFetchData(criteria, requestProperties);
    }


    // support for dataBoundComponentField.includeFrom:<dataSourceID>.<fieldName>
    // for fields that are not in the dataSource but pick up their value from
    // a related dataSource
    // In this case simply update the outputs property of the request -- the
    // server will be responsible for actually getting the value from the other
    // dataSource
    var completeFields = this.getAllFields();
    if (completeFields != null) {
        for (var i = 0; i < completeFields.length; i++) {
            if (completeFields[i].includeFrom != null &&
                this.getDataSource().getField(completeFields[i].name) == null)
            {
                if (requestProperties.additionalOutputs == null) requestProperties.additionalOutputs = "";
                else requestProperties.additionalOutputs += ",";
                requestProperties.additionalOutputs += [
                        completeFields[i].name,
                        completeFields[i].includeFrom].join("!")

            }
        }
    }

    // handle being passed a criteria object (map of keys to values), or a filter-component
    if (criteria == null) {
        criteria = {};
    } else if (isc.isA.Class(criteria)) {
        // otherwise assume "filter" is something we can ask for filter criteria
        // (DynamicForm or ValuesManager)
        criteria = isc.DynamicForm.getFilterCriteria(criteria);
    }

    this.filterWithCriteria(criteria, requestProperties.operation, requestProperties);
},

filterWithCriteria : function (criteria, operation, context) {
    context.prompt = (context.prompt || isc.RPCManager.fetchDataPrompt);

    // get rid of empty criteria that come from raw form values
    var filterCriteria = criteria;
    if ( this.ignoreEmptyCriteria ) {
       filterCriteria = isc.DataSource.filterCriteriaForFormValues(criteria);

    // duplicate the criteria to ensure any downstream modification (EG touching dsRequest.data in
    // transformRequest) doesn't modify live widget criteria objects.
    // [filterCriteriaForFormValues already performs a duplication step].
    } else {
        filterCriteria = isc.addProperties({},filterCriteria);
    }

    filterCriteria = isc.DS.checkEmptyCriteria(filterCriteria);

    var dataModel = this.getData();

    // if not already viewing a result set/tree for this operation, create one for it

    if (this.useExistingDataModel(criteria, operation, context)) {
        var updatedModel = this.updateDataModel(filterCriteria, operation, context);
        if (updatedModel != null) dataModel = updatedModel;
    } else {
        dataModel = this.createDataModel(filterCriteria, operation, context);
    }
    // we will ask the result set for the data we currently need to display,
    // which will cause data to be fetched
    this.setData(dataModel);


    var data = this.data;
    if (!context._suppressFetch && this.requestVisibleRows != null && data != null) {
        var fetchDelay = data.fetchDelay;

        data.fetchDelay = 0;
        this.requestVisibleRows();
        data.fetchDelay = fetchDelay;
    }
},

shouldFilterLocalData : function () {
    if (this.filterLocalData != null) {
        return this.filterLocalData;
    } else {
        return this.dataPath != null;
    }
},


useExistingDataModel : function (criteria, operation, context) {
    var resultSet = this.getData();
    if (!this.dataObjectSupportsFilter(resultSet)) {
        resultSet = this.originalData;
        if (resultSet == null) return false;
        if (!this.dataObjectSupportsFilter(resultSet)) {
            return false;
        }
    }
    // at this point we know the data is a ResultSet or ResultTree and have its
    // criteria updated unless there's a custom operation mismatch.
    var resultSetOperation = resultSet.getOperationId("fetch");
    var opID;
    if (isc.isA.String(operation)) opID = operation;
    else if (operation) opID = operation.ID;
    if (opID == null) {
        var dataSource = resultSet.getDataSource(),
            dataSourceID = dataSource ? dataSource.ID : null,
            opType = operation ? operation.type : null;
            if (opType == null) opType = "fetch";
        if (dataSourceID != null) opID = dataSourceID + "_" + opType;
    }
    return resultSetOperation == null || resultSetOperation == opID;
},


createDataModel : function (filterCriteria, operation, context) {
    //>DEBUG
    if (this.logIsInfoEnabled("ResultSet")) {
        this.logInfo("Creating new isc.ResultSet for operation '" + operation.ID +
                      "' with filterValues: " + this.echoFull(filterCriteria), "ResultSet");
    }
    //<DEBUG
    var dataSource = this.getDataSource();

    if (!isc.isA.DataSource(dataSource)) {
        this.logWarn("No DataSource or invalid DataSource specified, can't create data model" +
                     this.getStackTrace());
        return null;
    }

    var resultSet = isc.addProperties({}, this.dataDefaults, this.dataProperties);

    // if context is included as part of dataProperties, combine it with any passed context
    // because we'll overwrite it on resultSet below
    if (resultSet.context) context = isc.addProperties({}, resultSet.context, context);

    if (this.dataFetchDelay) resultSet.fetchDelay = this.dataFetchDelay;

    isc.addProperties(resultSet, { operation:operation, filter:filterCriteria, context:context,
        componentId: this.ID});

    if (this.progressiveLoading === true || this.progressiveLoading === false) {
        isc.addProperties(resultSet, {progressiveLoading: this.progressiveLoading});
    }

    if (this.getSort != null) {
        // getSort will normalize specified sortField / initialSort to
        // this._sortSpecifiers
        // We run this as part of setData(), but by also doing this here we initialize the
        // ResultSet with the appropriate sort, meaning it will already be sorted / won't
        // need to re-fetch when setData() runs and sets up the sortSpecifiers on the ListGrid
        var sortSpecifiers = this.getSort();
        if (sortSpecifiers != null && sortSpecifiers.length > 0) {
            resultSet._sortSpecifiers = sortSpecifiers;
            resultSet._serverSortBy = isc.DS.getSortBy(resultSet._sortSpecifiers);
        }
    }

    if (this.shouldFilterLocalData()) {
        var data = this._originalData != null ? this._originalData : this.data;
        if (isc.isAn.Array(data)) {
            resultSet.allRows = data;
            resultSet.fetchMode = "local";
            resultSet.useClientFiltering = true;
            resultSet.useClientSorting = true;
            resultSet.disableCacheSync = true;
            resultSet.neverDropCache = true;
        } else {
            isc.logWarn("createDataModel method: data should be an array.");
        }
    }
    return dataSource.getResultSet(resultSet);
},

// updateDataModel() - apply criteria to our dataModel
// Default implementation assumes a resultSet - override if necessary

updateDataModel : function (filterCriteria, operation, context) {

    // tell the ResultSet/ResultTree the filter changed
    if (this.logIsDebugEnabled()) {
        this.logDebug("Setting filter to: " + this.echoFull(filterCriteria));
    }

    // update the context - this allows requestProperties like "showPrompt" / textMatchStyle
    // to change
    var resultSet = this.getData();
    // Handle the grid being grouped
    if (!this.dataObjectSupportsFilter(resultSet)) resultSet = this.originalData;

    if (!this.dataObjectSupportsFilter(resultSet)) {
        return resultSet;
    }
    resultSet.setContext(context);
    // if the ResultSet won't kick off an immediate fetch, kill the afterFlowCallback
    // This is the callback passed into fetchData(...) and would normally be cleared by
    // ResultSet.fetchDataReply()
    // If we don't clear it here, the next time a fetch occurs (EG via 'invalidateCache()') the
    // callback will occur (once) when that fetch completes.
    if (!resultSet.willFetchData(filterCriteria)) delete context.afterFlowCallback;
    resultSet.setCriteria(filterCriteria);

    return resultSet;
},

dataObjectSupportsFilter : function (dataObject) {
    return (isc.ResultSet && isc.isA.ResultSet(dataObject)) ||
            (isc.ResultTree && isc.isA.ResultTree(dataObject));
},

// add this here so that all dataBoundComponents have data available by default.
requestVisibleRows : function () {
    return this.data.get(0);
},

// Helper to return this widget's data as a list - singular data objects
// (eg: DynamicForm record) will be wrapped in a single element array.

getDataAsList : function () {
    var data = this.getData ? this.getData() : this.data;
    if (data == null) return null;

    if (!isc.isA.List(data)) data = [data];
    return data;
},

//> @method dataBoundComponent.invalidateCache()
// Invalidate the current data cache for this databound component via a call to
// the dataset's <code>invalidateCache()</code> method, for example,
// +link{ResultSet.invalidateCache()}.
// <P>
// <b>NOTE:</b> there is no need to call <code>invalidateCache()</code> when a save operation
// is performed on a DataSource.  Automatic cache synchronization features will automatically
// update caches - see +link{ResultSet} for details.  If automatic cache synchronization isn't
// working, troubleshoot the problem using the steps suggested
// +externalLink{http://forums.smartclient.com/showthread.php?t=8159#aGrid,in the FAQ} rather
// than just calling invalidateCache().  Calling <code>invalidateCache()</code> unnecessarily
// causes extra server load and added code complexity.
// <P>
// Calling <code>invalidateCache()</code> will automatically cause a new fetch to
// be performed with the current set of criteria if data had been previously fetched and the
// component is currently drawn with data visible - there is no need to manually call
// fetchData() after invalidateCache() and this could result in duplicate fetches.
// <P>
// While data is being re-loaded after a call to <code>invalidateCache()</code>, the widget is
// in a state similar to initial data load - it doesn't know the total length of the dataset
// and any APIs that act on records or row indices will necessarily fail and should not be
// called.  To detect that the widget is in this state, call +link{ResultSet.lengthIsKnown()}.
// <P>
// <code>invalidateCache()</code> only has an effect if this components dataset is a data
// manager class that manages a cache (eg ResultSet or ResultTree).  If data was provided as a
// simple Array or List, invalidateCache() does nothing.
//
// @group dataBoundComponentMethods
// @visibility internal
// @see listGrid.refreshData
//<
invalidateCache : function () {
    if (this.data && this.data.invalidateCache != null) return this.data.invalidateCache();
    else if (this.isGrouped && isc.isA.ResultSet(this.originalData)) {
        // currently only valid for ListGrid: data is currently a Tree and has no
        // invalidateCache() - in order to preserve criteria, textMatchStyle, sort, etc, we
        // need to have the ResultSet from which this tree refetch.  Calling regroup right
        // after the cache is cleared sets us up to regroup when the data arrives

        this.originalData.setSort(this.data.getSort(), true);
        this.originalData.invalidateCache();
        this.regroup();
    }
},

//> @method dataBoundComponent.refreshData(callback)
// Unlike +link{listGrid.invalidateCache,invalidateCache} this will perform an asynchronous
// (background) refresh of this components data and then call the provided callback method on
// completion.
// <p>
// If refreshData is called while the grid is waiting for a response from +link{listGrid.fetchData}
// the refreshData call will be aborted. This is because the fetch has higher priority.
// <p>
// If +link{listGrid.fetchData} is called while the grid is waiting for a response from refreshData
// and the fetchData call has altered the criteria or sort specifiers, the refreshData call will
// be aborted.
// <p>
// If data is being edited or has been edited without being saved when refreshData is called, the
// data will be retained so you can save it after the refresh is complete. If you however want
// to throw away your edited but unsaved data when calling refreshData you first need to call
// +link{listGrid.discardAllEdits} which will discard any unsaved edited data.
// <p>
// In order to use refreshData() this grid needs to have a +link{DataSource} associated with it.
//
// @param [callback]    (DSCallback) callback method to run once the refresh completes.
//
// @group dataBoundComponentMethods
// @visibility internal
// @see listGrid.fetchData
// @see listGrid.invalidateCache
//<
refreshData : function (callback) {
    if (!this.getDataSource()) {
        this.logError("In order to refresh data a dataSource has to be specified for the component '" + this.ID + "'.");
        return;
    }

    if (this.data && this.data.fetchIsPending && this.data.fetchIsPending()) {
        this.logWarn("A fetch for this component is currently pending, please try again later.");
        return;
    }

    var dataSource = this.getDataSource(),
        visibleRows = this.getVisibleRows(),
        selectedState = this.getSelectedState();

    // request one page's worth of data on either side of the current viewport
    var startRow = visibleRows[0] - this.data.resultSize,
        endRow = visibleRows[1] + this.data.resultSize;

    if (startRow < 0) {
        startRow = 0;
    }

    var request = {
        startRow: startRow,
        endRow: endRow,
        sortBy: this.getSort(),
        showPrompt: false,
        componentId: this.getID()
    };

    var context = this.data.context;
    if (context && context.textMatchStyle) request.textMatchStyle = context.textMatchStyle;
    if (context && context.operationId) request.operationId = context.operationId;

    var oldCriteria = isc.clone(this.data.getCriteria());
    var oldSort = isc.clone(this.data.getSort());

    dataSource.fetchData(this.getCriteria(), function (dsResponse, data, dsRequest) {
        var newCriteria = this.data.getCriteria();
        var newSort = this.data.getSort();
        var criteriaOrSortChanged = this.data.compareCriteria(newCriteria, oldCriteria) === 0 || this.data.compareSort(newSort, oldSort);

        // If we've reached this point and a fetch is pending on the previous ResultSet then
        // the user has most likely asked for a fetch after refreshData was called. In this
        // case lets abort this refreshData call.
        if (this.data && this.data.fetchIsPending && this.data.fetchIsPending() && criteriaOrSortChanged) {
            this.logDebug("refreshData aborted as a fetch had been issued while waiting for refreshData to complete.");
            return;
        }

        var result = dsResponse.data,
            initialData = [];

        // correctly position the result in the resultset's cache
        initialData.length = dsResponse.totalRows;

        // Copy results
        var start = dsResponse.startRow || 0;
        for (var i = 0; i < result.length; i++) {
            initialData.set(start + i, result.get(i));
        }

        var resultSet = dataSource.getResultSet({
            dataSource: this.getDataSource(),
            initialLength: dsResponse.totalRows,
            initialData: initialData,
            sortSpecifiers: this.getSort(),
            criteria: this.getCriteria(),
            context : this.data && isc.isA.ResultSet(this.data) ? this.data.context : null
        });

        // Lets temporarily enable this component to preserve edits on setData call. This means
        // that if a cell or row edit is in place with an edited value, this value will be retained
        // after the refreshData call has completed.
        var originalPreserveEditsOnSetData = this.preserveEditsOnSetData;
        this.preserveEditsOnSetData = true;
        this.setData(resultSet);
        this.preserveEditsOnSetData = originalPreserveEditsOnSetData;
        this.setSelectedState(selectedState);

        if (callback) {
            callback(dsResponse, data, dsRequest);
        }
    }.bind(this), request);
},

//> @method dataBoundComponent.willFetchData()
// Compares the specified criteria with the current criteria applied to this component's
// data object and determines whether the new criteria could be satisfied from the currently
// cached set of data, or if a new filter/fetch operation will be required.
// <P>
// This is equivalent to calling <code>this.data.willFetchData(...)</code>.
// Always returns true if this component is not showing a set of data from the dataSource.
// <p>
// Note that to predict correctly the decision that will be made by filter/fetch, you'll need to
// pass the same +link{textMatchStyle} that will be used by the future filter/fetch.  Fetching
// manually (e.g. +link{listGrid.fetchData()}) will by default use "exact" while filtering
// (e.g. +link{listGrid.filterData()}) will by default use "substring".  If the component
// is configured for autofetch (i.e. +link{listGrid.autoFetchData}: true), that will
// use +link{listGrid.autoFetchTextMatchStyle}, which defaults to "substring".  If nothing/null
// is passed for the style, this method assumes you want the style from the last filter/fetch.
// <p>
// To determine what +link{textMatchStyle} is being used, check the RPC Tab of the
// +link{group:debugging,SmartClient Developer Console} and check the relevant +link{DSRequest}.
//
// @param newCriteria (Criteria) new criteria to test.
// @param [textMatchStyle] (TextMatchStyle) New text match style. If not passed assumes
//      textMatchStyle will not be modified.
// @return (Boolean) true if server fetch would be required to satisfy new criteria.
//
// @group dataBoundComponentMethods
// @visibility external
//<
willFetchData : function (newCriteria, textMatchStyle) {
    var data = this.data;
    if (data && data.willFetchData == null && this.originalData != null) data = this.orginalData;
    if (data && data.willFetchData != null) {
        return data.willFetchData(newCriteria, textMatchStyle);
    }
    return !this.shouldFilterLocalData();
},

//> @method dataBoundComponent.findByKey()
// @include resultSet.findByKey()
//<
findByKey : function(keyValue) {
    if (isc.isA.ResultSet(this.data)) return this.data.findByKey(keyValue);
    else if (isc.isA.Tree(this.data)) return this.data.findById(keyValue);
    else return null;
},

// Persistence
// -----------------------------------------------------------------------------

// This method factored up from ListGrid, July 2011
shouldSaveLocally : function () {
    return (!this.dataSource || this.getFullDataPath() != null || this.saveLocally ||
            this.shouldFilterLocalData());
},



//> @method dataBoundComponent.addData()
// Perform a DataSource "add" operation to add new records to this component's DataSource.
//
// @param newRecord (Record)            new record
// @param [callback] (DSCallback)  method to call on operation completion
// @param  [requestProperties] (DSRequest Properties)   additional properties to set on the DSRequest
//                                          that will be issued
//
// @group dataBoundComponentMethods
// @visibility internal
//<
addData : function (newRecord, callback, requestProperties) {
    return this._performDSOperation("add", newRecord, callback, requestProperties);
},

//> @method dataBoundComponent.updateData()
// Perform a DataSource "update" operation to update existing records in this component's
// DataSource.
//
// @param updatedRecord  (Record)            updated record
// @param [callback]          (DSCallback)  method to call on operation completion
// @param [requestProperties] (DSRequest Properties)   additional properties to set on the DSRequest
//                                          that will be issued
//
// @group dataBoundComponentMethods
// @visibility internal
//<
updateData : function (updatedRecord, callback, requestProperties) {
    return this._performDSOperation("update", updatedRecord, callback, requestProperties);
},

//> @method dataBoundComponent.removeData()
// Perform a DataSource "remove" operation to remove records from this component's
// DataSource.
//
// @param data (Record)            primary key values of record to delete,
//                                          (or complete record)
// @param [callback] (DSCallback)  method to call on operation completion
// @param [requestProperties] (DSRequest Properties)   additional properties to set on the DSRequest
//                                          that will be issued
//
// @group dataBoundComponentMethods
// @visibility internal
//<
removeData : function (recordKeys, callback, requestProperties) {
    return this._performDSOperation("remove", recordKeys, callback, requestProperties);
},

_performDSOperation : function (operationType, data, callback, requestProperties) {
    if (isc._traceMarkers) arguments.__this = this;

    if (this.shouldSaveLocally() || this.getDataSource() == null) {
        return this._performDSOperationInner(operationType, data);
    }

    // Call buildRequest - this will hang the default operationID (as well as various other
    // properties) onto the request.
    // We're passing the callback into performDSOperation directly so no need to hang it onto
    // the request in buildRequest
    requestProperties = this.buildRequest(requestProperties, operationType);

    return this.getDataSource().performDSOperation(operationType, data,
                                                   callback, requestProperties);
},

_performDSOperationInner : function (operationType, data) {
    if (operationType == "update") {
        var ds = this.getDataSource();
        if (!ds) {
            isc.logWarn("Update by primary key cannot be performed without a DataSource." +
                        "Modify the record directly instead");
            return;
        }
        if (this.originalData) {
            // grouped - look up the original record by PK and update it
            var origRecord = this.originalData.get(ds.findByKeys(data, this.originalData));
            isc.addProperties(origRecord, data);
        }
        // look up the record by PK and update it
        var record = this.data.get(ds.findByKeys(data, this.data));
        isc.addProperties(record, data);

        if (this.originalData) {
            this.dataChanged("update", null, null, record);
        } else this.data.dataChanged();

        return;
    } else if (operationType == "add") {
        // for listGrid grouping, add record to original data and regroup
        if (this.originalData) {
            this.originalData.add(data);
            this.dataChanged("add", null, null, data);
        } else {
            // dataChanged fires automatically
            if (isc.isA.Tree(this.data)) {
                var parent = this.data.getParent(data) || this.data.getRoot();
                this.data.add(data, parent);
            } else if (isc.ResultSet && isc.isA.ResultSet(this.data)) {
                if (this.data.allRows != null) {
                    this.data.allRows.add(data);
                    this.data.filterLocalData();
                } else {
                    isc.logWarn("Unable to add data to resultSet - allRows is not set");
                }
            } else {
                this.data.add(data);
            }
        }
        return;
    } else if (operationType == "remove") {
        // for listGrid grouping, remove record from original data and regroup
        if (this.originalData) {
            this.originalData.remove(data);
            this.dataChanged("remove", null, null, data);
        } else {
            // dataChanged fires automatically
            if (isc.ResultSet && isc.isA.ResultSet(this.data)) {
                if (this.data.allRows != null) {
                    this.data.allRows.remove(data);
                    this.data.filterLocalData();
                } else {
                    isc.logWarn("Unable to remove data from resultSet - allRows is not set");
                }
            } else {
                this.data.remove(data);
            }
        }
        return;
    }
},

//>    @method dataBoundComponent.removeSelectedData()
// Remove the currently selected records from this component.
// If this is a databound grid, the records will be removed directly from the DataSource.
// <P>
// If no records are selected, no action is taken. The grid will automatically be
// updated if the record deletion succeeds.
//
// @param [callback] (DSCallback) callback to fire when the data has been removed
// @param [requestProperties] (DSRequest)   additional properties to set on the DSRequest
//                                          that will be issued
//
// @group dataBoundComponentMethods
// @visibility internal
//<
removeSelectedData : function (callback, requestProperties) {

    var selection = this.getSelection(),
        selectionLength = selection.length;

    // In an editable ListGrid, you can't select unsaved data.  If we are editing and
    // selectOnEdit is set and this is an unsaved row, call discardEdits() as an equivalent to
    // removeSelectedData()
    if (isc.isA.ListGrid(this) && this.canEdit && this.selectOnEdit &&
        selectionLength == 0 &&
        this.getEditRow() != null && this.getRecord(this.getEditRow()) == null)
    {
        this.discardEdits(this.getEditRow());
        return;
    }

    // if this is not a databound grid or we are working with local-only data (an Array)
    if (this.dataSource == null || this.shouldSaveLocally()) {
        if (this.data) {
            if (isc.ResultSet && isc.isA.ResultSet(this.data) && this.shouldSaveLocally()) {
                if (this.data.allRows != null) {
                    this.data.allRows.removeList(selection);
                    this.data.filterLocalData();
                } else {
                    isc.logWarn("Unable to remove data from resultSet - allRows is not set");
                }
            } else {
                this.data.removeList(selection);
            }
            if (callback) this.fireCallback(callback);
        }
        return;
    }

    var context = this.buildRequest(requestProperties, "remove", callback),
        dataSource = this.getDataSource();

    if (selectionLength > 0) {
        this.deleteRecords(selection, context.operation, context, dataSource);
    }
    // notify that they have to select something to delete first... ???
},

// delete a specific list of records from the server
deleteRecords : function (records, deleteOperation, context, dataSource) {
    isc.addProperties(context, {
        prompt:(context.prompt || isc.RPCManager.removeDataPrompt)
    });

    var keyFieldNames = dataSource.getPrimaryKeyFieldNames(),
        fieldNames = dataSource.getFieldNames();

    // perform the delete as a multi-op, one per record
    var wasAlreadyQueuing = isc.RPCManager.startQueue();
    if (!isc.isAn.Array(records)) records = [records];
    for (var i = 0; i < records.length; i++) {
        var record = records[i];
        if (record._isGroup) continue;
        // Apply a mask to remove any non primary key fields before sending request in order
        // to stay consistent with other remove operations such as DataSource.removeData().
        var recordKeys = isc.applyMask(record, keyFieldNames);
        context.oldValues = isc.applyMask(record, fieldNames);
        dataSource.performDSOperation(deleteOperation.type, recordKeys, null, context);
    }

    // don't kickoff the transaction unless this flow initiated queuing, in case caller
    // wants to include other operations
    if (!wasAlreadyQueuing) isc.RPCManager.sendQueue();
},


// Selection
// ---------------------------------------------------------------------------------------

//> @type CellRecordMode
// When +link{canSelectCells} is true, whether +link{getSelection} on a
// +link{class:DataBoundComponent} or individual +link{class:CellSelection} should return one
// record per selected cell, as with +link{class:CubeGrid}, or one record per row that has any
// selected cells, as with +link{class:ListGrid}.
// @value "cell" getSelection returns one record for each selected cell via +link{getCellRecord}
// @value "row" getSelection returns distinct records for each row with one or more selected cells
// @visibility @external
// @group selection
//<

//> @attr dateBoundComponent.cellRecordMode (CellRecordMode : null : IRW)
// Whether calling +link{getSelection} on this class should return one record per cell, the
// default behavior and that used by, eg, +link{class:CubeGrid}, or a list of distinct records,
// as required by +link{class:ListGrid}.
// @visibility @internal
//<

//> @method dataBoundComponent.createSelectionModel()
// Creates the selection object for this +link{DataBoundComponent}
//
// @return (Selection | CellSelection) null
// @group  selection
// @visibility internal
//<
createSelectionModel : function (extraParams) {
    // clean up old selection object before creating new selection, if we have one.
    if (this.selection) this.destroySelectionModel();

    if (this.canSelectCells && this.cellDataModel) {

        var data = [];
        if (this.numRows != null) {
            for (var i = 0; i < this.numRows; i++) {
                data[i] = {};
            }
        }
    } else {
        var data = this.data;
    }

    var selection,
        params = {ID:this.getID()+"_selection",
                  data:data,

                  target: this,
                  selectionProperty:this.selectionProperty,
                  simpleDeselect : this.simpleDeselect,
                  dragSelection : this.canDragSelect
                };


    if (this.canSelectCells && this.fields != null) params.numCols = this.fields.length;

    // pass "reselectOnUpdate" through to the selection model, and override the
    // method to perform this reselection, so we can customize what notifications
    // get fired.
    if (!this.canSelectCells) {
        isc.addProperties(params, {
            reselectOnUpdate : this.reselectOnUpdate,
            performReselectOnUpdate:function (modifiedRecord) {
                if (this.target && this.target.performReselectOnUpdate) {
                    this.target.performReselectOnUpdate(modifiedRecord);
                } else {
                    this.Super("performReselectOnUpdate", arguments);
                }
            }
        });
    }

    // Copy our "enabled" property across if we have one.
    if (this.recordEnabledProperty != null) params.enabledProperty = this.recordEnabledProperty;

    // Copy our selection properties
    if (this.recordCanSelectProperty != null) params.canSelectProperty = this.recordCanSelectProperty;
    var cascade = this._shouldCascadeSelection();
    if (cascade != null) params.cascadeSelection = cascade;
    // if the data object supports a special selection class, use it
    if (this.data.getNewSelection) {
        selection = this.data.getNewSelection(params);
    }
    if (selection == null) {
        // otherwise use the default Selection or CellSelection class
        if (this.canSelectCells) {
            if (this.cellRecordMode) params.cellRecordMode = this.cellRecordMode;
            selection = isc.CellSelection.create(params);
        } else {
            selection = isc.Selection.create(params);
        }
    }

    this.selection = selection;

},


_shouldCascadeSelection : function () {
    return this.cascadeSelection;
},

// destroySelectionModel: Decouple from selection object and destroy it.
destroySelectionModel : function () {
    if (!this.selection) return;
    if (this.selection.destroy) this.selection.destroy();
    delete this.selection;
},

// undoc'd utility method to remove the selection-property applied to selected-rows
removeSelectionMarkers : function (data) {
    var returnArray = true;
    if (!isc.isAn.Array(data)) {
        data = [data];
        returnArray = false;
    }
    data.clearProperty(this.selectionProperty || this.selection ? this.selection.selectionProperty : null);
    return returnArray ? data : data[0];
},

//> @method dataBoundComponent.getSelection()
// Returns all selected records, as an Array.
//
// @param [excludePartialSelections] (Boolean) When true, partially selected records will not be returned.
//                                   Otherwise, both fully and partially selected records are
//                                   returned.
// @return (Array of ListGridRecord) list of records, empty list if nothing selected
// @group  selection
// @visibility internal
// @example databoundRemove
//<

getSelection : function (excludePartialSelections, internalParam, dontSort) {
    if (!this.selection) return [];

    if (this.canSelectCells) {
        return this.selection.getSelection(null, dontSort);
    } else {
        return this.selection.getSelection(excludePartialSelections, dontSort);
    }
},

//> @method dataBoundComponent.getSelectedRecords()
// Returns all selected records in this component.
// <p>
// <strong>NOTE:</strong> Records in the returned array should be treated as read-only and not
// modified.
// @param [excludePartialSelections] (Boolean) When true, partially selected records will not be returned.
//                                   Otherwise, both fully and partially selected records are
//                                   returned.
// @return (Array of ListGridRecord) array of selected records, which will be empty if no record
// is selected.
// @group  selection
// @visibility internal
//<
// This is a (better) synonym for getSelection(). It's documented at the ListGrid level.
getSelectedRecords : function (excludePartialSelection) {
    return this.getSelection(excludePartialSelection);
},

//> @method dataBoundComponent.getSelectedRecord()
// Returns the first selected record in this component.
// <p>
// <strong>NOTE:</strong> If a record is returned, it should be treated as read-only and not
// modified.
// @return (ListGridRecord) the first selected record, or null if no record is selected.
// @visibility internal
// @group selection
// @example databoundRemove
//<
getSelectedRecord : function() {
    if (!this.selection) return null;
    return this.selection.getSelectedRecord();
},

//> @method dataBoundComponent.getSelectionObject()
// Return the dataBoundComponent's underlying +link{Selection} object.  Note that this differs
// from +link{dataBoundComponent.getSelection}, which returns an array containing the actual
// selected objects
//      @group  selection
//      @return (Selection) This dataBoundComponent's underlying +link{Selection} object
// @visibility internal
//<
getSelectionObject : function() {
    return this.selection;
},

//> @method listGrid.isSelected()
// Returns true if the record is selected.
//
// @param record (ListGridRecord) record to check
// @return (Boolean) true if record is selected; false otherwise
// @group selection
// @visibility external
//<
isSelected : function (record) {
    if (!record || !this.selection) return false;
    return this.selection.isSelected(record);
},

//> @method listGrid.isPartiallySelected()
// When using tree-oriented selection modes like +link{treeGrid.cascadeSelection}, returns true
// if the record is considered partially selected because only some of it's children are
// selected.
//
// @param record (ListGridRecord) record to check
// @return (Boolean) true if record is partially selected; false otherwise
// @group selection
// @visibility external
//<
isPartiallySelected : function (record) {
    if (!record || !this.selection) return false;
    return this.selection.isPartiallySelected(record);
},

//> @groupDef selection
// APIs for marking +link{Record}s as selected and retrieving the selected record or records.
// <P>
// Only applicable to a +link{DataBoundComponent} that manages a list of Records, or manages a
// data model that can be viewed as a list (for example, the current list of visible nodes
// on a tree can be treated as a list for selection purposes).
//
// @title Selection
// @visibility external
//<




//> @method dataBoundComponent.selectRecord()
//
// Select/deselect a +link{Record} passed in explicitly, or by index.
//
// @param record (Record | number) record (or row number) to select
// @param [newState] (boolean) new selection state (if null, defaults to true)
//
// @group selection
// @visibility external
//<
selectRecord : function (record, state, colNum) {
    this.selectRecords(record, state, colNum);
},

//> @method dataBoundComponent.selectSingleRecord()
// Select a single +link{Record} passed in explicitly, or by index, and deselect everything else.
// When programmatic selection of records is a requirement and
// +link{listGrid.selectionType, selectionType()} is "single", use this method rather than
// +link{dataBoundComponent.selectRecord(), selectRecord()} to
// enforce mutually-exclusive record-selection.
//
// @param record (Record | number) record (or row number) to select
//
// @group selection
// @visibility external
//<
selectSingleRecord : function (record) {

    this.selection.deselectAll();
    this.selectRecord(record);
},

//> @method dataBoundComponent.deselectRecord()
//
// Deselect a +link{Record} passed in explicitly, or by index.
// <P>
// Synonym for <code>selectRecord(record, false)</code>
//
// @param record (Record | number) record (or row number) to deselect
//
// @group selection
// @visibility external
//<
deselectRecord : function (record, colNum) {
    this.selectRecord(record, false, colNum);
},

//> @method dataBoundComponent.selectRecords()
//
// Select/deselect a list of +link{Record}s passed in explicitly, or by index.
// <P>
// Note that developers may wish to use +link{selectRange()} to select a single
// contiguous range.
//
// @param records (Array of Record | numbers) records (or row numbers) to select
// @param [newState]  (boolean) new selection state (if null, defaults to true)
//
// @group selection
// @visibility external
//<
selectRecords : function (records, state, colNum) {
    if (state == null) state = true;
    if (!isc.isAn.Array(records)) records = [records];

    if (isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown()) {
        this.logWarn("ignoring attempt to select records while data is loading");
        return;
    }

    for (var i = 0; i < records.length; i++) {

        if (records[i] == null) continue;

        // assume any number passed is a rownum
        if (isc.isA.Number(records[i])) {
            var index = records[i];
            records[i] = this.getRecord(index, colNum);
        }
    }

    var selObj = this.getSelectionObject(colNum);
    if (selObj) {

        selObj.selectList(records, state, null, this);
        this.fireSelectionUpdated();
    }
},

//> @method dataBoundComponent.deselectRecords()
//
// Deselect a list of +link{Record}s passed in explicitly, or by index.
// <P>
// Synonym for <code>selectRecords(records, false)</code>
// <P>
// Note that developers may wish to use +link{deselectRange()} to select a single
// contiguous range.
//
// @param records (Array of Record | numbers) records (or row numbers) to deselect
//
// @group selection
// @visibility external
//<
deselectRecords : function (records, colNum) {
    this.selectRecords(records, false, colNum);
},

//> @method dataBoundComponent.selectAllRecords()
// Select all records
//
// @group selection
// @visibility external
//<
selectAllRecords : function () {
    this.selection.selectAll();
    this.fireSelectionUpdated();
},

//> @method dataBoundComponent.deselectAllRecords()
//
// Deselect all records
//
// @group selection
// @visibility external
//<
deselectAllRecords : function () {
    this.selection.deselectAll();
    this.fireSelectionUpdated();
},

//> @method dataBoundComponent.selectRange()
// Select a contiguous range of records by index
// @param startRow (int) start of selection range
// @param endRow (int) end of selection range (non-inclusive)
// @param [newState]  (boolean) new selection state (if null, defaults to true)
// @visibility external
//<
selectRange : function (startRow, endRow, newState) {
    this.selection.selectRange(startRow, endRow, newState);
    this.fireSelectionUpdated();
},

//> @method dataBoundComponent.deselectRange()
// Deselect a contiguous range of records by index.
// <P>
// This is a synonym for <code>selectRange(startRow, endRow, false);</code>
// @param startRow (int) start of selection range
// @param endRow (int) end of selection range (non-inclusive)
// @visibility external
//<
deselectRange : function (startRow, endRow) {
    this.selection.selectRange(startRow, endRow);
    this.fireSelectionUpdated();
},

//> @method dataBoundComponent.anySelected()
// @include selection.anySelected()
//<
anySelected : function () {
    return this.selection && this.selection.anySelected();
},

//> @method dataBoundComponent.getSelectionLength()
// @include selection.getLength()
//<
getSelectionLength : function () {
    return this.selection ? this.selection.getLength() : 0;
},

getRecord : function (index, column) {
    var recordContainer = isc.isA.List(this.data) || isc.isA.ResultSet(this.data);
    return recordContainer ? this.data.get(index) : this.data;
},

fireSelectionUpdated : function () {
    var ruleScopeComponent = (this.getRuleScopeComponent ? this.getRuleScopeComponent() : null);


    if (this.selectionUpdated || (ruleScopeComponent != null && (ruleScopeComponent.ruleScope || ruleScopeComponent.isRuleScope))) {

        var recordList = this.getSelection(null, null, true),
            record = (recordList.length > 0 ? recordList[0] : null)
        ;
        if (this.selectionUpdated) this.selectionUpdated(record, recordList);


        if (ruleScopeComponent != null && isc.isA.DataBoundComponent(this)) {
            var grid = this,
                ds = grid.getDataSource(),
                id = grid.getLocalId(),
                hasStableID = grid.hasStableLocalID() || (grid.editNode != null)
            ;

            // Remove metadata from record for ruleContext
            if (record) {
                record = this.getCleanRecordData(record);
                delete record._ignoreStyleUpdates;
            }

            if (ds) ruleScopeComponent.provideRuleContext(ds.getID(), record, this, hasStableID);
            if (hasStableID) {
                ruleScopeComponent.provideRuleContext(id + ".selectedRecord", record, this, true);
                ruleScopeComponent.provideRuleContext(id + ".anySelected", (record != null), this, true);
                ruleScopeComponent.provideRuleContext(id + ".multiSelected", (record ? recordList.length > 1 : false), this, true);
                ruleScopeComponent.provideRuleContext(id + ".numSelected", (record ? recordList.length : 0), this, false);
            }
        }
    }
},

// Hiliting
// ---------------------------------------------------------------------------------------

//> @groupDef hiliting
// Hiliting means special visual styling which is applied to specific data values that meet
// certain criteria.
// <P>
// A +link{Hilite} definition contains styling information such as +link{hilite.cssText} and
// +link{hilite.htmlBefore} that define what the hilite looks like, as well as properties
// defining where the hilite is applied.  If you create hilites manually, they should ideally
// specify +link{hilite.textColor, textColor} and/or
// +link{hilite.backgroundColor, backgroundColor} in order to be editable in a
// +link{class:HiliteEditor}.  If these are not provided, however, note that they will be
// manufactured automatically from the +link{hilite.cssText, cssText} attribute if it is present.
// <P>
// A hilite can be applied to data <b>either</b> by defining +link{hilite.criteria,criteria}
// or by explicitly including markers on the data itself.
// <P>
// Hiliting rules such as hiliting different ranges of values with different colors can be
// accomplished entirely client-side by defining +link{AdvancedCriteria} in hilite definitions
// that pick out values to be highlighted.
// <P>
// Hiliting rules that require server-side calculations can be achieved by assigning a
// +link{hilite.id} to a hilite definition, and setting the
// +link{dataBoundComponent.hiliteProperty} on the records that should show that highlight.
// This can be used, for example, to hilite the record with the maximum value for a dataset
// that the application will load incrementally.
//
// @title Hiliting
// @visibility external
//<

// Hilite Declarations
// ---------------------------------------------------------------------------------------

//> @object Hilite
// An object representing a user-created and user-modifiable hilite, which can be created and
// edited with a +link{class:HiliteEditor} either directly or via the
// +link{ListGrid.canEditHilites} behavior.
// <P>
// See +link{group:hiliting} for an overview.
//
// @treeLocation Client Reference/Grids/ListGrid
// @visibility external
// @group hiliting
//<

//> @attr hilite.id (String : null : IR)
// Unique id for this hilite definition.
// <P>
// For hilites that include +link{hilite.criteria} this is not required.
// <P>
// If you are explicitly marking records for hiliting, set
// +link{dataBoundComponent.hiliteProperty} on the record to this id.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.cssText (CSSText : null : IR)
// CSS text to be applied to cells where this hilite is applied, for example,
// "background-color:#FF0000"
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.fieldName (identifier : null : IR)
// Name of the field, or array of fieldNames, this hilite should be applied to.
// <P>
// If unset, hilite is applied to every field of the record.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.criteria (Criteria or AdvancedCriteria : null : IR)
// Criteria defining what records this hilite should apply to.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.htmlBefore (HTML : null : IR)
// HTML to pre-pend to cell values where this hilite is applied.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.htmlAfter (HTML : null : IR)
// HTML to append to the end of cell values where this hilite is applied.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.htmlValue (String : null : IR)
// Value to show <b>in place of</b> the actual value from the record, for a record that matches
// this hilite.
// <P>
// This can be used to take ranges of numeric values and simplify them to "Low", "Medium",
// "High" or similar textual values, translate very small or very large values to "Outlier" or
// "Negligible", and similar use cases.
//
// @deprecated <code>htmlValue</code> is deprecated in favor of +link{hilite.replacementValue}.
//  Note that unlike <code>replacementValue</code>, this property does not respect
//  +link{hilite.disabled}, and will be applied even if <code>disabled</code> is set to
//  <code>true</code>
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.disabled (Boolean : false : IRW)
// Whether this hilite is currently disabled.
// <P>
// Hilites can be programmatically enabled and disabled via +link{dataBoundComponent.enableHilite()}.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.canEdit (Boolean : null : IR)
// Can highlight be edited from header context menu? Setting attribute to
// <code>false</code> prevents editing. A <code>null</code> or <code>true</code>
// value allows editing.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.title (String : null : IRW)
// User-visible title for this hilite.  Used for interfaces such as menus that can enable or
// disable hilites.
//
// @visibility external
// @group hiliting
//<


//> @attr hilite.textColor (String : null : IRW)
// When edited via a +link{class:HiliteEditor}, the value for the foreground color of this
// hilite.  If this is omitted, it will be automatically derived from the <i>textColor</i>
// attribute of +link{hilite.cssText}.  When a hilite is saved in a HiliteEditor, both
// attributes are set automatically.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.backgroundColor (String : null : IRW)
// When edited via a +link{class:HiliteEditor}, the value for the background color of this
// hilite.  If this is omitted, it will be automatically derived from the <i>backgroundColor</i>
// attribute of +link{hilite.cssText}.  When a hilite is saved in a HiliteEditor, both
// attributes are set automatically.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.icon (SCImgURL : null : IR)
// URL of an icon to show when this hilite is applied to a cell.  Position of the icon
// is controlled by +link{dataBoundComponent.hiliteIconPosition} or
// +link{listGridField.hiliteIconPosition}.
//
// @visibility external
// @group hiliting
//<

//> @attr hilite.replacementValue (HTML : null : IR)
// HTML which replaces the cell's textual value where this hilite is applied.
// <p>
// Note that sorting, filtering, etc behavior will still operate on the underlying value.
// For example, if there is a date field with the FilterEditor enabled, the default search
// interface will still offer date-range based filtering even if hilites have caused values
// to be displayed as text such as "current" or "past due".
//
// @visibility external
// @group hiliting
//<


styleOpposite:"cellHiliteOpposite",

// Hilites
// ---------------------------------------------------------------------------------------

//> @attr dataBoundComponent.canEditHilites (boolean : false : [IRW])
// Adds an item to the header context menu allowing users to launch a dialog to define
// grid hilites using the +link{class:HiliteEditor}.
// <P>
// User-added hilites can be persisted via +link{dataBoundComponent.getHiliteState()} and
// +link{dataBoundComponent.setHiliteState()}.
//
// @visibility external
// @group hiliting
//<
canEditHilites:false,

//> @attr dataBoundComponent.hilites (Array of Hilite : null : [IRW])
// Hilites to be applied to the data for this component.  See +link{group:hiliting}.
//
// @visibility external
// @group hiliting
//<

//> @attr dataBoundComponent.hiliteIcons (Array of String : ["[SKINIMG]/Dialog/notify.png", "[SKINIMG]/Dialog/warn.png", "[SKINIMG]/actions/approve.png"] : IR)
// Specifies a list of icons that can be used in +link{dataBoundComponent.editHilites(),hilites}.
// <P>
// <code>hiliteIcons</code> should be specified as an Array of +link{SCImgURL}.
// When present, the hilite editing interface shown when +link{dataBoundComponent.editHilites()} is called
// will offer the user a drop down for picking one of these icons when defining either a
// simple or advanced hilite rule.
// <P>
// If the user picks an icon, the created hiliting rule will have +link{hilite.icon} set to
// the chosen icon.  +link{dataBoundComponent.hiliteIconPosition} controls where the icon will
// appear for that field -- the default is that it appears in front of the normal cell content.
// This can also be overridden at the field level.
//
// @visibility external
// @group hiliting
//<
hiliteIcons: [
    "[SKINIMG]/Dialog/notify.png",
    "[SKINIMG]/Dialog/warn.png",
    "[SKINIMG]/actions/approve.png"
],

//> @type HiliteIconPosition
// Where a +link{dataBoundComponent.hiliteIcons,hilite icon} will be placed relative to
// normal cell content.
//
// @value "before" icon will be placed before the normal cell contents
// @value "after" icon will be placed after the normal cell contents
// @value "replace" icon will be shown instead of the normal cell contents
//
// @visibility external
// @group hiliting
//<

//> @attr dataBoundComponent.hiliteIconPosition (HiliteIconPosition : "before" : IR)
// When +link{hiliteIcons,hiliteIcons} are present, where the hilite icon will be placed
// relative to the field value.  See +link{type:HiliteIconPosition}. Can be overridden at the
// field level.
//
// @visibility external
// @group hiliting
//<
hiliteIconPosition: "before",

//> @attr dataBoundComponent.hiliteIconSize (number : 12 : IRW)
// Default width and height of +link{hiliteIcons,hilite icons} for this component.
// Can be overridden at the component level via explicit
// +link{hiliteIconWidth, hiliteIconWidth} and
// +link{hiliteIconHeight, hiliteIconHeight}, or at the field level via
// +link{ListGridField.hiliteIconSize, hiliteIconSize},
// +link{ListGridField.hiliteIconWidth, hiliteIconWidth} and
// +link{ListGridField.hiliteIconHeight, hiliteIconHeight}
// @group hiliting
// @see DataBoundComponent.hiliteIconWidth
// @see DataBoundComponent.hiliteIconHeight
// @see ListGridField.hiliteIconSize
// @visibility external
//<
hiliteIconSize: 12,

//> @attr dataBoundComponent.hiliteIconWidth (number : null : IRW)
// Width for hilite icons for this component.
// Overrides +link{hiliteIconSize, hiliteIconSize}.
// Can be overridden at the field level.
// @group hiliting
// @visibility external
//<

//> @attr dataBoundComponent.hiliteIconHeight (number : null : IRW)
// Height for hilite icons for this listGrid.
// Overrides +link{hiliteIconSize, hiliteIconSize}.
// Can be overridden at the field level
// @group hiliting
// @visibility external
//<

//> @attr   dataBoundComponent.hiliteIconLeftPadding (number : 2 : IRW)
// How much padding should there be on the left of +link{hiliteIcons, hilite icons} by default?
// Can be overridden at the field level
// @group hiliting
// @visibility external
//<
hiliteIconLeftPadding: 2,

//> @attr   dataBoundComponent.hiliteIconRightPadding (number : 2 : IRW)
// How much padding should there be on the right of +link{hiliteIcons, hilite icons} by default?
// Can be overridden at the field level
// @group hiliting
// @visibility external
//<
hiliteIconRightPadding: 2,

// Helpers to get hiliteIcon attributes from field level or component level
getHiliteIconLeftPadding : function (field) {
    return (field.hiliteIconLeftPadding != null ? field.hiliteIconLeftPadding
            : this.hiliteIconLeftPadding || 0);
},

getHiliteIconRightPadding : function (field) {
    return (field.hiliteIconRightPadding != null ? field.hiliteIconRightPadding
            : this.hiliteIconRightPadding || 0);
},

getHiliteIconWidth : function (field) {
    return (field.hiliteIconWidth != null ? field.hiliteIconWidth  :
                (field.hiliteIconSize != null ? field.hiliteIconSize :
                    (this.hiliteIconWidth != null ? this.hiliteIconWidth : this.hiliteIconSize)));
},

getHiliteIconHeight : function (field) {
    return (field.hiliteIconHeight != null ? field.hiliteIconHeight  :
                (field.hiliteIconSize != null ? field.hiliteIconSize :
                    (this.hiliteIconHeight != null ? this.hiliteIconHeight : this.hiliteIconSize)));
},

getHiliteIconPosition : function (field) {
    return field.hiliteIconPosition != null ? field.hiliteIconPosition : this.hiliteIconPosition;
},

getHiliteIconHTML : function (icon, field) {
    var prefix = field.imageURLPrefix,
        width = this.getHiliteIconWidth(field),
        height = this.getHiliteIconHeight(field),
        leftPad = this.getHiliteIconLeftPadding(field),
        rightPad = this.getHiliteIconRightPadding(field);

    var iconHTML = isc.Canvas._getValueIconHTML(icon, prefix, width, height, leftPad, rightPad, null, this);
    return iconHTML;
},


//> @attr dataBoundComponent.hiliteProperty (string : "_hilite" : [IRW])
// Marker that can be set on a record to flag that record as hilited.  Should be set to a value
// that matches +link{hilite.id} for a hilite defined on this component.
//
// @visibility external
//<
// NOTE: not the same as hiliteMarker, which is an internal property used to track generated
// hilites
hiliteProperty:"_hilite",


// Hilite APIs

// user:
//   component.hilites && setHilites()
//   record[hiliteProperty] (CubeGrid only)
// component/framework:
//   note: setup is automatic on first call any of the below, or setHilites()
//   applyHilites() (to data)
//   getHiliteCSSText() / addHiliteCSSText()


//> @attr dataBoundComponent.hiliteState (String : null : IRW)
// Initial hilite state for the grid.
// <P>
// +link{listGrid.viewState} can be used to initialize all view properties of the grid.
// When doing so, <code>hiliteState</code> is not needed because <code>viewState</code>
// includes it as well. If both are provided, <code>hiliteState</code> has priority for
// hilite state.
// <smartclient>
// <P>
// To retrieve current state call +link{DataBoundComponent.getHiliteState,getHiliteState}.
// </smartclient>
//
// @group viewState
// @visibility external
//<

//>    @method dataBoundComponent.getHilites()
// Return the set of hilite-objects currently applied to this DataBoundComponent.  These
// can be serialized for storage and then restored to a component later via
// +link{dataBoundComponent.setHilites, setHilites()}.
//
// @visibility external
// @return (Array) Array of hilite objects
// @group  hiliting
//<
getHilites : function () {
    return this.hilites;
},

// property used to store hilite state for generated hilites
hiliteMarker:"_hmarker",
_hiliteCount: 0,

//>    @method dataBoundComponent.setHilites()
// Accepts an array of hilite objects and applies them to this DataBoundComponent.  See also
// +link{dataBoundComponent.getHilites, getHilites()} for a method of retrieving the hilite
// array for storage, including hilites manually added by the user.
//
// @param hilites (Array of Hilite) Array of hilite objects
// @group hiliting
// @visibility external
//<
setHilites : function (hilites) {

    this.hilites = hilites;
    this._setupHilites(this.hilites);

},

//>    @method dataBoundComponent.getHiliteState()
// Get the current hilites encoded as a String, for saving.
//
// @return (String) hilites state encoded as a String
// @group  viewState
// @visibility external
//<
getHiliteState : function (returnObject) {
    var hilites = this.getHilites();
    if (hilites == null) return null;
    if (returnObject) return hilites;
    return "(" + isc.JSON.encode(hilites, {dateFormat:"logicalDateConstructor", prettyPrint:false}) + ")";
},

//>    @method dataBoundComponent.setHiliteState()
// Set the current hilites based on a hiliteState String previously returned from
// +link{getHiliteState()}.
// @param hiliteState (String) hilites state encoded as a String
// @group viewState
// @visibility external
//<
setHiliteState : function (hilitesState) {
    //!OBFUSCATEOK
    if (hilitesState == null) this.setHilites(null);
    var hilites = eval(hilitesState);
    this.setHilites(hilites);
},

// factored so it can also get called lazily the first time getHilite() is called
_setupHilites : function (hilites, dontApply) {
    // auto-assign ids if unset
    if (hilites != null) {
        this._lastHiliteId = this._lastHiliteId || 0;
        var currentIds = {},
            needsId = [];
        for (var i = 0; i < hilites.length; i++) {
            var id = hilites[i].id;
            if (id != null) {
                if (currentIds[id]) {
                    this.logWarn("This component has more than one hilite object with " +
                        "the same specified id:" + id +
                        ". Hilite IDs must be unique within a component.", "hiliting");
                    // We could tweak the ID to fix it perhaps, but instead we'll just
                    // pass in the param to 'makeIndex' to cause collisions to just
                    // clobber each other, rather than making an array which we don't
                    // handle. User visible effect - one of the hilites just won't show
                    // up.
                } else {
                    currentIds[id] = true;
                    var numericID = parseInt(id);
                    if (id == numericID) {
                        this._lastHiliteId = Math.max(this._lastHiliteId, (numericID+1));
                    }
                }
            } else {
                needsId.add(hilites[i]);
            }
        }
        for (var  i= 0; i < needsId.length; i++) {
            needsId[i].id = this._lastHiliteId++;
        }

        // for quick hilite lookups
        this._hiliteIndex = hilites.makeIndex("id", -1);
    }
    if (!dontApply) this.applyHilites();
},

// update the user formula fields present in the component and refresh their value
_storeFormulaFieldValues : function (data, fields, skipGroupRecord, oldFormulaFields) {
    var formulaFields = [],
        formulaFunctions = [];
    for (var i = 0; i < fields.length; i ++) {
        var formulaFunction = this.getFormulaFunction(fields[i]);
        if (formulaFunction) {
            formulaFields.add(fields[i]);
            formulaFunctions.add(formulaFunction);
        }
    }
    if ((oldFormulaFields && isc.getKeys(oldFormulaFields).length > 0) ||
        formulaFields.length > 0)
    {
        for (var j=0; j<data.length; j++) {
            var record = data[j];
            for (var i=0; i<formulaFields.length; i++) {
                var field = formulaFields[i],
                    fieldName = field[this.fieldIdProperty];

                if (this.shouldApplyUserFormulaAfterSummary(field) &&
                    this.shouldShowUserFormula(field, record))
                {
                    if (!skipGroupRecord || !record._isGroup) {
                        this.storeFormulaFieldValue(field, record, formulaFunctions[i]);
                    }
                    if (j == 0) {
                        delete oldFormulaFields[fieldName];
                    }
                }
            }
            for (var oldFormula in oldFormulaFields) {
                delete record[oldFormula];
            }
        }
    }
    // update the metadata indicating what calculated formula field
    // have had values applied to our data
    for (var oldFormula in oldFormulaFields) {
        delete this._storedFormulaFields[oldFormula];
    }
},

// update the user summary fields present in the component and refresh their value
_storeSummaryFieldValues : function (data, fields, skipGroupRecord, oldSummaryFields) {
    var summaryFields = [],
        summaryFunctions = [];
    for (var i = 0; i < fields.length; i++) {
        if (fields[i].userSummary != null) {
            summaryFields.add(fields[i]);
            summaryFunctions.add(this.getSummaryFunction(fields[i]));
        }
    }
    if ((oldSummaryFields && isc.getKeys(oldSummaryFields).length > 0) ||
        summaryFields.length > 0)
    {
        for (var j=0; j<data.length; j++) {
            var record = data[j];
            for (var i=0; i<fields.length; i++) {
                var field = fields[i],
                fieldName = field[this.fieldIdProperty];
                if (field.userSummary) {
                    if (!skipGroupRecord || !record._isGroup) {
                        this.storeSummaryFieldValue(field, record, summaryFunctions[i]);
                    }
                    if (j == 0) {
                        delete oldSummaryFields[fieldName];
                    }
                }
            }
            for (var oldSummary in oldSummaryFields) {
                delete record[oldSummary];
            }
        }
    }
    // update the metadata indicating what calculated summary fields
    // have had values applied to our data
    for (var oldSummary in oldSummaryFields) {
        delete this._storedSummaryFields[oldSummary];
    }
},


             _$nonSummaryAffectingHiliteRule:              "nonSummaryAffecting",
          _$simpleSummaryAffectingHiliteRule:           "simpleSummaryAffecting",
_$summaryDependentSummaryAffectingHiliteRule: "summaryDependentSummaryAffecting",

_partitionSummaryHiliteRules : function (hiliteRules, summaryFieldsToRecalculate) {

    var partition = {
                     nonSummaryAffecting: [],
                  simpleSummaryAffecting: [],
        summaryDependentSummaryAffecting: []
    };

    // nothing to do if there are no hilite rules or no defined fields
    if (hiliteRules == null || this.fields == null) return partition;

    var component = this,
        dependencyTable = this._getFieldDependencyTable();

    for (var i = 0; i < hiliteRules.length; i++) {
        var hilite = this.getHilite(hiliteRules[i]);
        if (!hilite || hilite.disabled) continue;

        var targetFields = hilite.fieldName ||
            (this.fields ? this.fields.getProperty("name") : []);
        if (!isc.isAn.Array(targetFields)) targetFields = [targetFields];

        var criteriaFields = isc.DataSource ?
            isc.DataSource.getCriteriaFields(hilite.criteria, this.dataSource) : null;
        if (criteriaFields) criteriaFields = criteriaFields.filter(function (field) {
            var field = component.getField(field);
            return field && field.userSummary != null;
        });

        // If a target field of the rule affects a summary field, the rule is not a
        // nonSummaryAffecting rule; if furthermore any summary fields are in the rule criteria,
        // or we can't determine the criteria fields, it's not a simpleSummaryAffecting rule.
        var ruleType = this._$nonSummaryAffectingHiliteRule;

        for (var j = 0; j < targetFields.length; j++) {
            var dependentFields = dependencyTable[targetFields[j]] || {};
            for (var fieldName in dependentFields) {
                var dependentField = dependentFields[fieldName];
                if (dependentField.userSummary == null ||
                    !this.shouldIncludeHiliteInSummaryField(fieldName, targetFields[j]))
                {
                    continue; // nonSummaryAffecting rule
                }
                if (ruleType == this._$nonSummaryAffectingHiliteRule) {
                    ruleType = this._$simpleSummaryAffectingHiliteRule;
                }
                if (!criteriaFields  || criteriaFields.length > 0) {
                    ruleType = this._$summaryDependentSummaryAffectingHiliteRule;
                    summaryFieldsToRecalculate[fieldName] = dependentField;
                }
            }
        }
        partition[ruleType].push(hilite);
    }
    return partition;
},

applyHilites : function (suppressRedraw) {
    var hilites = this.hilites,
        data = this.data;
    if (hilites && !this._hiliteIndex) this._setupHilites(hilites, true);

    // wipe all existing hilite markers
    if (isc.isA.ResultSet(data)) data = data.getAllLoadedRows();
    if (isc.isA.Tree(data)) data = data.getAllItems();
    data.setProperty(this.hiliteMarker, null);

    var fields = this.getAllFields();
    if (fields == null) fields = [];

    // clear the _hilites flag

    fields.setProperty("_hilites", null);

    var skipGroupRecord = this.isGrouped && !this.showGroupSummaryInHeader;

    // refresh formula fields and content
    var oldFormulaFields = isc.addProperties({}, this._storedFormulaFields);

    this._storeFormulaFieldValues(data, fields, skipGroupRecord, oldFormulaFields);
    var component = this,
        summaryFieldsToRecalculate = {},
        applyHiliteRule = function (hilite) { component.applyHilite(hilite, data); },
        partition = this._partitionSummaryHiliteRules(hilites, summaryFieldsToRecalculate);

    // apply rules that don't depend on summary fields but are summary field inputs
    partition.simpleSummaryAffecting.map(applyHiliteRule);
    // refresh summary fields and content
    var oldSummaryFields = isc.addProperties({}, this._storedSummaryFields);
    this._storeSummaryFieldValues(data, fields, skipGroupRecord, oldSummaryFields);

    // apply all rules for target fields that are not inputs to summary fields
    partition.nonSummaryAffecting.map(applyHiliteRule);

    // recalculate summary fields for complicated rules that both are applied
    // using summary field-based criteria and also affect inputs to summary fields
    if (partition.summaryDependentSummaryAffecting.length > 0) {
        partition.summaryDependentSummaryAffecting.map(applyHiliteRule);
        this.invalidateUserCache(null, isc.getValues(summaryFieldsToRecalculate));
        this._storeSummaryFieldValues(data, fields, skipGroupRecord, {});
    }


    if (!suppressRedraw) this.redrawHilites();
},


// Store a calculated formula field value on a record in our data array.
// This also sets up some metadata so we can clear such values if the formula field
// is removed.
storeFormulaFieldValue : function (field, record, formulaFunction) {
    var fieldName = field[this.fieldIdProperty];
    if (this._storedFormulaFields == null) this._storedFormulaFields = {};
    if (!this._storedFormulaFields[fieldName]) this._storedFormulaFields[fieldName] = true;

    this.getFormulaFieldValue(field, record, formulaFunction);
},
storeSummaryFieldValue : function (field, record, summaryFunction) {
    var fieldName = field[this.fieldIdProperty];
    if (this._storedSummaryFields == null) this._storedSummaryFields = {};
    if (!this._storedSummaryFields[fieldName]) this._storedSummaryFields[fieldName] = true;

    this.getSummaryFieldValue(field, record, summaryFunction);
},

//> @type FieldNamingStrategy
// The strategy to use when generating field names - for example, for new formula or summary
// fields created using the built-in editors.
// @value "simple" generate names in the format fieldTypeX, where field type might be
//         "formulaField" and X is an index specific to the field-type and component instance
// @value "uuid" generates a UUID for all generated field names
// @visibility external
//<

//> @attr dataBoundComponent.fieldNamingStrategy (FieldNamingStrategy : "simple" : IRW)
// The strategy to use when generating names for new fields in this component.  The default
// strategy, "simple", combines the field-type with an index maintained by field-type and
// component instance.  For example, "formulaField1".
// @visibility external
//<
fieldNamingStrategy: "simple",
fieldNameGenerator: {},

getHilite : function (hiliteId) {
    if (isc.isAn.Object(hiliteId)) return hiliteId;

    if (this.hilites == null) return null;

    if (!this._hiliteIndex && this.hilites) {
        this._setupHilites(this.hilites);
    }

    var hilite = this._hiliteIndex[hiliteId];

    // try hiliteId as an array index
    if (hilite == null) hilite = this.hilites[hiliteId];

    return hilite;
},


applyHilite : function (hilite, data, fieldName) {

    var matches = this.getRecordsMatchingHilite(hilite, data);
    if (matches == null || matches.length == 0) return;

    hilite = this.getHilite(hilite);
    // recordsMatchingHilite will have eliminated disabled hilites already.
    // if (hilite.disabled) return;

    var fieldName = fieldName || hilite.fieldName;

    // hilite all fields if no field is specified
    if (fieldName == null) fieldName = this.fields ? this.fields.getProperty("name") : [];

    var fieldNames = isc.isAn.Array(fieldName) ? fieldName : [fieldName];

    if (this.logIsDebugEnabled("hiliting")) {
        this.logDebug("applying hilite: " + this.echo(hilite) +
                      ", to fields: " + fieldNames, "hiliting");
    }

    for (var j = 0; j < fieldNames.length; j++) {
        var field = this.getField(fieldNames[j]);
        for (var i = 0; i < matches.length; i++) {
            var record = matches[i];
            this.hiliteRecord(record, field, hilite);
        }
    }
},

// Apply filter to find the subset of data that matches a specified hilite's criteria.
getRecordsMatchingHilite : function (hilite, data) {
    hilite = this.getHilite(hilite);

    // hilite may be applied in some other way, eg manual calls
    if (!hilite.criteria) return;

    if (hilite.disabled) return;

    var matches = [],
        dataSource = this.getDataSource();

    if (dataSource) {
        var drop = dataSource.dropUnknownCriteria;
        var strictSQLFiltering = dataSource.strictSQLFiltering;


        dataSource.dropUnknownCriteria = false;
        var undef;
        if (this.strictSQLFilteringForHilites !== undef) dataSource.strictSQLFiltering = this.strictSQLFilteringForHilites;
        matches = this.getDataSource().applyFilter(data, hilite.criteria);
        dataSource.dropUnknownCriteria = drop;
        if (this.strictSQLFilteringForHilites !== undef) dataSource.strictSQLFiltering = strictSQLFiltering;
    } else {
        // Call a local DBC version of DS.applyFilter which provides the same facilities but
        // against array data
        matches = this.unboundApplyFilter(data, hilite.criteria);
    }
    if (this.logIsDebugEnabled("hiliting")) {
        this.logDebug("applying filter: " + this.echoFull(hilite.criteria) +
                      ", produced matches: " + isc.echoLeaf(matches), "hiliting");
    }

    return matches;
},


// Utility method to provide searching by criteria/AdvancedCriteria in the absence of a DS
unboundApplyFilter : function (data, criteria) {
    var matches = [];

    if (data) {
        if (criteria) {
            for (var idx = 0; idx < data.length; idx++) {
                // The AdvancedCriteria system makes this very easy - just call evaluateCriterion
                // on the top-level criterion, and it handles all the recursion and evaluation of
                // sub-criteria that it needs to do automatically.
                if (!criteria.operator || this.evaluateCriterion(data[idx], criteria)) {
                    matches.add(data[idx]);
                }
            }
        } else {
            matches = data;
        }
    }

    return matches;
},
evaluateCriterion : function (record, criterion) {

    var op = isc.DataSource._operators[criterion.operator];
    if (op == null) {
        isc.logWarn("Attempted to use unknown operator " + criterion.operator);
        return false;
    }

    var ds = this.getDataSource();

    var field = this.getField(criterion.fieldName);
    var fieldValue = isc.DataSource.getPathValue(record, criterion.fieldName, field);
    var isDateField = field && (isc.SimpleType.inheritsFrom(field.type, "date") || isc.SimpleType.inheritsFrom(field.type, "datetime"));
    //criterion.fieldName, fieldValueToTest, criterionValues, this, isDateField

    var convertToAbsoluteDateOrKeepOriginalValue = function(value) {
        if (isDateField && !isc.isA.Date(value) && isc.DateUtil.isRelativeDate(value)) {
            return isc.DateUtil.getAbsoluteDate(value);
        }

        return value;
    }

    var criterionValues = {
        value: convertToAbsoluteDateOrKeepOriginalValue(criterion.value),
        start: convertToAbsoluteDateOrKeepOriginalValue(criterion.start),
        end: convertToAbsoluteDateOrKeepOriginalValue(criterion.end)
    };

    if(op.valueType === "fieldName") {
        var otherField = this.getField(criterionValues.value);
        var otherFieldValue = isc.DataSource.getPathValue(record, criterionValues.value, otherField);
        criterionValues.otherValue = convertToAbsoluteDateOrKeepOriginalValue(otherFieldValue);
    } else if (op.valueType === "criteria") {
        // If we're dealing with a criteria operator such as AND, NOT & OR, lets add the criterion
        // to the criterionValues object.
        criterionValues.criterion = criterion;
        criterionValues.record = record;
    }

    var condition = op.condition(criterion.fieldName, fieldValue, criterionValues, ds || this, isDateField);

    // If the operator is negated, return a negated condition
    return (op.negate ? !condition : condition);
},

compareValues : function (value1, value2, fieldName, ignoreCase) {
    if (isc.isA.Date(value1) && isc.isA.Date(value2)) {
        if (value1.logicalDate || value2.logicalDate) {
            return Date.compareLogicalDates(value1, value2);
        } else {
            return Date.compareDates(value1, value2);
        }
    } else {
        var v1 = ignoreCase && value1.toLowerCase ? value1.toLowerCase() : value1,
            v2 = ignoreCase && value2.toLowerCase ? value2.toLowerCase() : value2;
        // Javascript does not consider null to be less than "some string", though it does
        // consider null to be less than "1".  Work around this anomalous behavior.
        if (v1 == null && v2 != null) return 1;
        if (v1 != null && v2 == null) return -1;
        // NOTE: The special return value 2 means that we've been asked to compare two values
        // that are not equal but also are not sensibly "greater than" or "less than"
        // one another - for example "Blink" and 182.
        return v1 > v2 ? -1 : (v1 < v2 ? 1 : (v1 == v2 ? 0 : 2))
    }
},

// hiliteRecord(): Given a record, field, hilite, hang markers on the record/field
// objects such that we can rapidly look up the hilite from the data
// TODO: make external version that checks params

hiliteRecord : function (record, field, hilite) {

    if (!field) return;

    var hiliteCount = record[this.hiliteMarker];
    if (hiliteCount == null) hiliteCount = record[this.hiliteMarker] = this._hiliteCount++;

    var fieldHilites = field._hilites = field._hilites || {}, // XXX wipe these in setFields or
                                                              // similar
        existingHilite = fieldHilites[hiliteCount];

    if (existingHilite == null) fieldHilites[hiliteCount] = hilite.id;
    else if (isc.isAn.Array(existingHilite)) existingHilite.add(hilite.id);
    else fieldHilites[hiliteCount] = [existingHilite, hilite.id];
},

getHiliteCSSText : function (hilite) {
    var hilite = this.getHilite(hilite);
    if (hilite == null) return;

    var cssText = hilite.cssText || "";
    if (cssText == "") {
        if (hilite.textColor) cssText += "color:" + hilite.textColor + ";";
        if (hilite.backgroundColor) cssText += "background-color:" + hilite.backgroundColor + ";";
        if (cssText == "") cssText == null;
    }

    // .style is backcompat for old CubeGrid hilites
    return cssText || hilite.style;
},

_hiliteIterator : [],
// addHiliteCSSText(): Given a record and a field, look up the hilite(s) for the
// cell and return appropriate cssText.
// This applies to hilites with a specified criteria that match the record in question,
// and makes use of the markers set up by applyHilites() / hiliteRecord()
addHiliteCSSText : function (record, field, cssText) {
    if (!record) return cssText;

    var hiliteCount = record[this.hiliteMarker],
        field = this.getField(field);

    if (!field || !field._hilites) return cssText;

    var hiliteIds = field._hilites[hiliteCount];
    if (hiliteIds == null) return cssText;

    //this.logWarn("add hiliteCSS: hiliteCount: " + hiliteCount +
    //             " on field:" + field.name + ", hiliteIds: " + hiliteIds);

    // convert to Array
    if (!isc.isAn.Array(hiliteIds)) {
        this._hiliteIterator[0] = hiliteIds;
        hiliteIds = this._hiliteIterator;
    }

    // multiple hilites apply to cell
    for (var i = 0; i < hiliteIds.length; i++) {
        var hiliteCSSText = this.getHiliteCSSText(hiliteIds[i]);
        if (hiliteCSSText != null) {
            cssText = cssText ? cssText + isc.semi + hiliteCSSText : hiliteCSSText;
        }
    }

    return cssText;
},

// addObjectHilites(): Given an object with a specified value for the
// 'hiliteProperty', return the cssText for the matching hilite.
// Allows developers to specify record._hilite for explicit custom hiliting rather than
// using hilite.criteria

addObjectHilites : function (object, cellCSSText, field) {
    if (!this.hilites || !object) return cellCSSText;

    var objArr;
    if (!isc.isAn.Array(object)) {
        this._hiliteIterator[0] = object;
        objArr = this._hiliteIterator;
    }

    if (objArr && objArr.length>0) {
        for (var i = 0; i < objArr.length; i++) {
            var hiliteID, hilite, hiliteCSSText;
            var currObj = objArr[i];

            if (isc.isA.String(currObj)) hiliteID = currObj;
            else hiliteID = (currObj != null ? currObj[this.hiliteProperty] : null);

            // get the hilite object (ENH: could support arrays of multiple hilite objects)
            hilite = this.getHilite(hiliteID);
            if (hilite != null && !hilite.disabled) { // we have a hilite object
                // NOTE: "style" is backcompat
                hiliteCSSText = hilite.cssText || hilite.style;
                // make sure that hilites that spec a fieldName are respected

                var fieldNames = [];
                if (hilite)
                    fieldNames = isc.isAn.Array(hilite.fieldName) ? hilite.fieldName : [hilite.fieldName];

                var matchesField = (!hilite.fieldName || !field || fieldNames.contains(field.name));
                if (hiliteCSSText != null && hiliteCSSText != isc.emptyString && matchesField) {
                    // we have a hilite style
                    if (cellCSSText == null) cellCSSText = hiliteCSSText;
                    // NOTE: add a semicolon, even though it may be redundant
                    else cellCSSText += isc.semi + hiliteCSSText;
                }
            }
        }
    }
    return cellCSSText;
},

// getFieldHilites() returns the actual hilite object(s) for a cell

getFieldHilites : function (record, field) {

    if (!record || !field) return null;

    if (record[this.hiliteProperty] != null) {
        var hilite = this.getHilite(record[this.hiliteProperty]),
            fieldNames;
        if (hilite)
            fieldNames = isc.isAn.Array(hilite.fieldName) ? hilite.fieldName : [hilite.fieldName];
        if (fieldNames && fieldNames.contains(field.name)) return [hilite];
        else return null;
    }

    if (record[this.hiliteMarker] != null) {
        var hiliteCount = record[this.hiliteMarker];
        if (!field._hilites) return null;
        else return field._hilites[hiliteCount];
    }
},

applyHiliteHTML : function (hiliteIDs, valueHTML) {
    if (!this.hilites) return valueHTML;
    var hilite, hiliteHTML, hiliteID;
    // convert to Array
    if (!isc.isAn.Array(hiliteIDs)) {
        this._hiliteIterator[0] = hiliteIDs;
        hiliteIDs = this._hiliteIterator;
    }

    for (var i = 0; i< hiliteIDs.length; i++) {
        hiliteID = hiliteIDs[i];
        // get the hilite object

        hilite = this.getHilite(hiliteID);
        if (hilite != null) {
            if (hilite.htmlValue != null) valueHTML = hilite.htmlValue;
            if (!hilite.disabled) { // we have a hilite object, not disabled
                if (hilite.replacementValue) {
                    valueHTML = hilite.replacementValue;
                }
                hiliteHTML = hilite.htmlBefore;
                if (hiliteHTML != null && hiliteHTML.length > 0) { // we have hilite htmlBefore, so pre-pend it
                    valueHTML = hiliteHTML + valueHTML;
                }
                hiliteHTML = hilite.htmlAfter;
                if (hiliteHTML != null && hiliteHTML.length > 0) { // we have hilite htmlAfter, so append it
                    valueHTML = valueHTML + hiliteHTML;
                }

                // position a special glyph of some sort (eg an image or small text code) opposite the
                // cell value.  NOTE name "htmlOpposite" reflects future support for automatically
                // flipping direction column align and/or RTL.
                var oppositeContent = hilite.htmlOpposite,
                    style = hilite.styleOpposite || this.styleOpposite;
                if (oppositeContent) {
                    if (!isc.Browser.isIE) {
                        // in browsers other than IE, <nobr> works even when surrounding a mixture of
                        // floating and non-floating content
                        valueHTML = "<nobr><div class='" + style + "' style='float:left'>&nbsp;" +
                                 oppositeContent + "&nbsp;</div>" + valueHTML + "</nobr>";
                    } else {

                        valueHTML = "<nobr><table role='presentation' align=left><tr><td class='" + style + "'>" +
                                 oppositeContent + "</td></tr></table>" + valueHTML + "</nobr>";
                    }
                }
            }
        }
    }
    return valueHTML;
},

applyHiliteIcon : function (hiliteIDs, field, cellValue) {
    if (!this.hilites || !field) return cellValue;
    var hilite, hiliteHTML, hiliteID;

    // convert to Array
    if (!isc.isAn.Array(hiliteIDs)) {
        this._hiliteIterator[0] = hiliteIDs;
        hiliteIDs = this._hiliteIterator;
    }

    for (var i = 0; i < hiliteIDs.length; i++) {
        hiliteID = hiliteIDs[i];
        // get the hilite object

        hilite = this.getHilite(hiliteID);
        if ((hilite != null) && hilite.icon) {
            hiliteHTML = this.getHiliteIconHTML(hilite.icon, field);
            var hiliteIconPosition = this.getHiliteIconPosition(field);
            if (hiliteIconPosition == "after") {
                cellValue = cellValue + hiliteHTML;
            } else if (hiliteIconPosition == "replace") {
                cellValue = hiliteHTML;
            } else {
                // default is "before"
                cellValue = hiliteHTML + cellValue;
            }
        }
    }

    return cellValue;
},

//>    @method dataBoundComponent.enableHilite()
// Enable / disable a +link{dataBoundComponent.hilites,hilite}
//
// @visibility external
// @group  hiliting
//
// @param  hiliteID    (string)    ID of hilite to enable
// @param  [enable]    (boolean)   new enabled state to apply - if null, defaults to true
//<
enableHilite : function (hiliteID, enable) {
    if (enable == null) enable = true;
    var hilite = this.getHilite(hiliteID);
    if (hilite == null) return;
    hilite.disabled = !enable;
    // redraw to show hilite / lack of hilite
    this.redrawHilites();
},

//>    @method dataBoundComponent.disableHilite()
// Disable a hilite
//
// @visibility external
// @group  hiliting
//
// @param  hiliteID    (string)    ID of hilite to disable
//<
disableHilite : function (hiliteID) { this.enableHilite(hiliteID, false); },

//>    @method dataBoundComponent.enableHiliting()
// Enable all hilites.
//
// @visibility external
// @group  hiliting
//
// @param  [enable]    (boolean)   new enabled state to apply - if null, defaults to true
//<
enableHiliting : function (enable) {
    if (enable == null) enable = true;
    if (this.hilites) this.hilites.setProperty("disabled", !enable);
    this.redrawHilites();
},

//>    @method dataBoundComponent.disableHiliting()
// Disable all hilites.
//
// @visibility external
// @group  hiliting
//<
disableHiliting : function () { this.enableHiliting(false) },

redrawHilites : function () {
    this.markForRedraw();
},

// Returns the fields shown in the hiliteEditor
getHiliteCriteriaFields : function () {
    var fields = this.getAllFields();

    if (!fields) return;

    // if any fields are specifically marked as canHilite: false, remove them from the list -
    // we use this for special listGrid fields, like rowNumber and expansion fields
    var invalidFields = fields ? fields.findAll("canHilite", false) : null;

    if (invalidFields && invalidFields.length > 0) {
        fields.removeList(invalidFields);
    }

    for (var i = 0; i < fields.length; i++) {
        if (fields[i].dataPath) {
            fields[i] = isc.addProperties({}, fields[i],
                {dataPath:this._trimDataPath(fields[i].dataPath)} );
        }
    }
    return fields;
},

//> @attr dataBoundComponent.editHilitesText (String : "Edit Highlights..." : IRW)
// Text for a menu item allowing users to edit grid highlights.
//
// @group i18nMessages
// @visibility external
//<
editHilitesText: "Edit Highlights...",

//> @attr dataBoundComponent.editHilitesDialogTitle (String : "Edit Highlights" : IR)
// The title for the +link{dataBoundComponent.editHilites, Hilite Editor} dialog.
//
// @group i18nMessages
// @visibility external
//<
editHilitesDialogTitle: "Edit Highlights",

//> @attr dataBoundComponent.hiliteWindow (AutoChild Window : null : R)
// The +link{Window} containing this databound component's +link{DataBoundComponent.hiliteEditor,hiliteEditor}.
// <p>
// The following +link{autoChildUsage,passthroughs} apply:
// <ul>
// <li>+link{DataBoundComponent.editHilitesDialogTitle} for +link{Window.title}</li>
// </ul>
//
// @group hiliting
//<
hiliteWindowConstructor: "Window",

hiliteWindowDefaults: {
    autoDraw: false,
    autoParent: "none",
    height: 400,
    width: 875,
    autoCenter: true,
    overflow: "visible",
    canDragResize: true,
    keepInParentRect:true,
    isModal: true,
    showModalMask: true,
    bodyProperties : {
        layoutMargin: 8,
        membersMargin: 8,
        overflow: "visible"
    },
    closeClick : function () {
        this.hide();
    }
},

//> @attr dataBoundComponent.fieldEditorWindowTitle (HTMLString : "${builderType} Editor [${fieldTitle}]" : IRWA)
// The title for the +link{dataBoundComponent.fieldEditorWindow, Window} used to edit calculated
// fields.
// <P>
// This is a dynamic string - text within <code>&#36;{...}</code> are dynamic variables and will
// be evaluated as JS code whenever the message is displayed.
// <P>
// Two dynamic variables are available - "builderType", either Formula or Summary, and
// "fieldTitle", which is the title of the calculated field being edited.
// @visibility external
//<
fieldEditorWindowTitle: "${builderType} Editor [${fieldTitle}]",

//> @attr dataBoundComponent.fieldEditorWindow (AutoChild Window : null : R)
// The +link{Window} used to edit calculated fields for this component.
//
// @visibility external
//<
fieldEditorWindowConstructor: "Window",
fieldEditorWindowDefaults: {
    keepInParentRect:true,
    showMinimizeButton: false, showMaximizeButton: false,
    autoDraw: false,
    isModal: true,
    showModalMask:true,
    width: 400,
    height: 400,
    overflow: "visible",
    autoCenter: true,
    bodyProperties: {
        overflow: "visible"
    },
    canDragResize: true,
    headerIconProperties: { padding: 1,
        src: "[SKINIMG]ListGrid/formula_menuItem.png"
    },
    closeClick: function () {
        this.items.get(0).completeEditing(true);
        return this.Super('closeClick', arguments);
    }
},

//> @attr dataBoundComponent.hiliteEditor (AutoChild HiliteEditor : null : R)
// This component's HiliteEditor instance used to allow the user to create, modify, or delete
// hilites.
// <p>
// The following +link{group:autoChildUsage,passthroughs} apply:
// <ul>
// <li>+link{DataBoundComponent.hiliteIcons} for +link{HiliteEditor.hiliteIcons}</li>
// </ul>
//
// @group hiliting
// @visibility external
//<
// <li>+link{DataBoundComponent.hiliteCanReplaceValue} for +link{HiliteEditor.hiliteCanReplaceValue}</li>
// <li>+link{DataBoundComponent.hiliteReplaceValueFieldTitle} for +link{HiliteEditor.hiliteReplaceValueFieldTitle}</li>
hiliteEditorConstructor: "HiliteEditor",

hiliteEditorDefaults: {
    autoDraw: false,
    autoParent: "none",
    callback : function (hilites) {
        var grid = this.creator;
        if (hilites != null) grid._handleHilitesChanged(hilites);
        grid.hiliteWindow.hide();
    }
},

//>    @method dataBoundComponent.editHilites()
// Shows a +link{class:HiliteEditor, HiliteEditor} interface allowing end-users to edit
// the data-hilites currently in use by this DataBoundComponent.
//
// @visibility external
// @group  hiliting
//<
editHilites : function () {

    var thisDS = this.getDataSource(),
        fields = thisDS ? isc.getValues(thisDS.getFields()).duplicate() : [],
        dbcFields = (this.getHiliteCriteriaFields() || []).duplicate(),
        includeAsSummary = []
    ;

    // build a list of fields that are used by any visible summary fields
    for (var i=0; i<dbcFields.length; i++) {
        var dbcField = dbcFields[i];
        if (dbcField.userSummary && this.fieldIsVisible(dbcField.name)) {
            var vars = dbcField.userSummary.summaryVars;
            for (var key in vars) {
                var fieldName = vars[key];
                if (!includeAsSummary.contains(fieldName)) includeAsSummary.add(fieldName);
            }
        }
    }

    fields.setProperty("showInSimpleEditor", false);
    dbcFields.setProperty("showInSimpleEditor", true);
    for (var i=0; i<dbcFields.length; i++) {
        var dbcField = dbcFields[i],
            fieldVisible = this.fieldIsVisible(dbcField.name), // visible in the DBC
            fieldUsedInSummary = includeAsSummary.contains(dbcField.name), // used in a visible summary
            field = fields.find("name", dbcField.name)
        ;
        if (!field) {
            field = isc.addProperties({}, dbcField);
            fields.add(field);
        }

        if (dbcField.canHilite != null) field.canHilite = dbcField.canHilite;

        field.title = this.getFieldTitle ? this.getFieldTitle(dbcField) :
                            dbcField.title || dbcField.name;
        // show the field in the simple list if it is either visible or in use by a visible
        // summary field
        field.showInSimpleEditor = fieldVisible || fieldUsedInSummary;
    }

    // Define dataSource dynamically based on our fields. Will include Formula fields etc.
    var ds = isc.DataSource.create({
        // inheritsFrom is required to pick up fields where the component has a
        // dataPath specified to navigate nested data objects, so we need the fields
        // from the underlying dataSource present in the "hilites" criteria source DS.
        inheritsFrom:this.getDataSource(),
        isHiliteCriteriaDS:true,
        fields: fields

    });

    if (this.hiliteWindow) {
        this.hiliteEditor.setDataSource(ds);
        // rootDataSource used by the hiliteEditor getDefaultOptionDataSource stuff
        this.hiliteEditor.rootDataSource = this.getDataSource();
        this.hiliteEditor.clearHilites();
        this.hiliteEditor.setHilites(this.getHilites());
        this.hiliteEditor.setHiliteIcons(this.hiliteIcons);
        this.hiliteWindow.show();
        return;
    }
    var grid = this,
        hiliteEditor = this.addAutoChild("hiliteEditor", {
            dataSource:ds,
            // If a field has a displayField set, and no explicit optionDataSource,
            // we typically fetch options from the component-datasource
            // Pass this to the hiliteEdior so it perform this fetch if necessary
            // (a fetch against the specified "ds" would fail as it is just
            // a schema with no data management set up)
            rootDataSource:this.getDataSource(),
            hilites:this.getHilites(),
            hiliteIcons:this.hiliteIcons,
            hiliteCanReplaceValue:this.hiliteCanReplaceValue,
            hiliteReplaceValueFieldTitle:this.hiliteReplaceValueFieldTitle
        }),
        theWindow = this.addAutoChild("hiliteWindow", {
            title: this.editHilitesDialogTitle,
            items: [ hiliteEditor ]
        });
    theWindow.centerInPage();
    theWindow.show();
    return theWindow;
},

_handleHilitesChanged : function (hilites) {
    this.setHilites(hilites);
},

//
// Drag & Drop
// -----------------------------------------------------------------------------

// These methods are factored up from ListGrid, to make them available to TileGrid.
// They are only applicable to list-type components (as of Oct 2008, ListGrid, TreeGrid
// and TileGrid).  Although they are here in DataBoundComponent, they also work in the
// case of non-databound components (as source, target or both).

//> @method dataBoundComponent.transferRecords()
//
// Transfer a list of +link{Record}s from another component (does not have to be a databound
// component) into this component.  This method is only applicable to list-type components,
// such as +link{ListGrid,listGrid}, +link{TreeGrid,treeGrid} or +link{TileGrid,tileGrid}
// <P>
// This method implements the automatic drag-copy and drag-move behaviors of components like
// +link{ListGrid}, and calling it is equivalent to completing a drag and drop of the
// <code>dropRecords</code>.
// <P>
// Note that this method is asynchronous - it may need to perform server turnarounds to prevent
// duplicates in the target component's data.  If you wish to be notified when the transfer
// process has completed, you can either pass the optional callback to this method or implement
// the +link{dropComplete()} method on this component.
// <P>
// See also +link{transferSelectedData}.
//
// @param dropRecords (Array of Record) Records to transfer to this component
// @param targetRecord (Record) The target record (eg, of a drop interaction), for context
// @param index (integer) Insert point in this component's data for the transferred records
// @param sourceWidget (Canvas) The databound or non-databound component from which the records
//                            are to be transferred.
// @param [callback] (Callback) optional callback to be fired when the transfer process has completed
//
// @group dragdrop
// @visibility external
//<
transferRecords : function (dropRecords, targetRecord, index, sourceWidget, callback) {
    // storeTransferState returns false if a prior transfer is still running, in which case
    // we just bail out (transferRecords() will be called again when the first transfer
    // completes, so we aren't abandoning this transfer, just postponing it)
    if (!this._storeTransferState("transferRecords", dropRecords, targetRecord, index,
                                  sourceWidget, callback)) {
        return;
    }

    // If this component is databound but has not yet issued a fetchData(), we need to
    // initialize the ResultSet before adding records, otherwise cache sync will not be in
    // place and it will look to the user like the records haven't been added.  We
    // initialize the ResultSet with a special call to fetchData() that creates the
    // ResultSet but suppresses the actual server visit.
    if (isc.isAn.Array(this.data) && this.data.length == 0 &&
        this.dataSource && !this.shouldSaveLocally())
    {
        this.fetchData(null, null, {_suppressFetch:true});
        this.data.setFullLength(0);
    }

    // if reordering records from this list
    if (sourceWidget == this) {
        // slide them into their new home, if no grouping is applied

        if (index != null && !this.isGrouped) this.data.slideList(dropRecords, index);

    } else {

        var dataSource = this.getDataSource();
        var sourceDS = sourceWidget.getDataSource();

        // If we're bound to the same dataSource as the source widget and doing a move, apply
        // an update to the source nodes - by default, changing them to match the current
        // filter criteria of this grid
        if (dataSource && dataSource == sourceDS &&
            sourceWidget.dragDataAction == isc.Canvas.MOVE &&
            !(sourceWidget.shouldSaveLocally() || this.shouldSaveLocally()))
        {
            var wasAlreadyQueuing = isc.rpc.startQueue();
            for (var i = 0; i < dropRecords.length; i++) {
                var record = {};
                var pks = dataSource.getPrimaryKeyFieldNames();
                for (var j = 0; j < pks.length; j++) {
                    record[pks[j]] = dropRecords[i][pks[j]];
                }
                isc.addProperties(record, this.getDropValues(record, sourceDS,
                                          targetRecord, index, sourceWidget));
                this.updateDataViaDataSource(record, sourceDS, null, sourceWidget);
            }
            if (!wasAlreadyQueuing) isc.rpc.sendQueue();
        } else {
            if (!isc.isAn.Array(dropRecords)) dropRecords = [dropRecords];

            // select the stuff that's being dropped
            // (note: if selectionType == SINGLE we only select the first record)



            var selectRecords = true;
            // If we're dropping between 2 dataSources and the pkField doesn't exist
            // on the source dataSource, don't attempt to select records immediately as
            // they'll likely have no primary key yet meaning we can't perform
            // a selection immediately (this is likely to occur for
            // primary keys generated by the server - for example 'sequence' type fields)
            if (sourceDS != null && dataSource != null) {
                var pkFields = dataSource.getPrimaryKeyFieldNames(),
                    selectRecords = true;
                if (pkFields) {
                    for (var i = 0; i < pkFields.length; i++) {
                        if (sourceDS.getField(pkFields[i]) == null) {
                            selectRecords = false;
                            break;
                        }
                    }
                }
            }
            if (selectRecords) {
                if (this.selectionType == isc.Selection.MULTIPLE ||
                    this.selectionType == isc.Selection.SIMPLE)
                {
                    this.selection.deselectAll();

                    this.selection.selectList(dropRecords, true, null, this);
                } else if (this.selectionType == isc.Selection.SINGLE) {
                    this.selection.selectSingle(dropRecords[0]);
                }
                this.fireSelectionUpdated();
            }


            if (dataSource) {
                this._wasAlreadyQueuing = isc.rpc.startQueue();
                for (var i = 0; i < dropRecords.length; i++) {
                    // groups contain circular references which will hang at clone - skip
                    if (dropRecords[i]._isGroup) continue;
                    var record = {};
                    isc.addProperties(record, dropRecords[i]);
                    isc.addProperties(record, this.getDropValues(record, sourceDS,
                                            targetRecord, index, sourceWidget));
                    if (dataSource != sourceDS) {
                        // If there is a foreign key relationship from the target DS to the
                        // source DS, populate the foreignKey field on the record we're
                        // dropping with the contents of the field the foreignKey points to.
                        var fks = dataSource.getForeignKeysByRelation(record, sourceDS);
                        var cannotRecat = false;
                        isc.addProperties(record, fks);

                        // If we have explicitly defined titleFields and the target one is not
                        // going to be populated, populate it with the value in the source one
                        if (dataSource.titleField && sourceDS && sourceDS.titleField &&
                                dataSource.titleField != sourceDS.titleField) {
                            var undef;
                            if (record[dataSource.titleField] === undef) {
                                record[dataSource.titleField] = record[sourceDS.titleField];
                            }
                        }
                    }

                    this._addIfNotDuplicate(record, sourceDS, sourceWidget, fks);
                }
            } else { // target grid does not have a DataSource
                // handle grouping
                if (this.isGrouped) {
                    // add to tree
                    for (var i = 0; i < dropRecords.length; i++) {
                        var record = {};
                        isc.addProperties(record, dropRecords[i]);
                        isc.addProperties(record, this.getDropValues(record, sourceDS,
                                            targetRecord, index, sourceWidget));
                        if (!this._isDuplicateOnClient(record)) {
                            this._addRecordToGroup(this.groupTree, record, true);

                            // add to originalData
                            // Ignore the index in this case - it will refer to the position within
                            // the tree which doesn't map to a position within the original data
                            // array
                            this.originalData.add(record);
                        }
                    }
                    // add to originalData
                    //if (index != null) this.originalData.addListAt(dropRecords, index);
                    //else this.originalData.addList(dropRecords);

                } else {
                    // If we've been passed an index respect it - this will happen if canReorderRecords
                    // is true

                    for (var i = 0; i < dropRecords.length; i++) {
                        var record = {};
                        isc.addProperties(record, dropRecords[i]);
                        isc.addProperties(record, this.getDropValues(record, sourceDS,
                                                targetRecord, index, sourceWidget));
                        if (index != null) {

                            // Although _addIfNotDuplicate is an asynchronous method, we know
                            // that this particular invocation of it will be synchronous (because
                            // there's no DataSource and thus no server contact), so if it returns
                            // false, we know authoritatively that no data was added and thus
                            // index should not be incremented
                            if (this._addIfNotDuplicate(record, null, sourceWidget,
                                                                null, index)) {
                                // Because we're adding one-at-a-time, increment the index - otherwise,
                                // the effect will be to insert into the grid in reverse order
                                index++;
                            }
                        } else {
                            this._addIfNotDuplicate(record, null, sourceWidget);
                        }
                    }
                }

            }
        }
    }

    // unsort if we were sorted and records were just placed at an explicit position
    if (this.canReorderRecords && this.getSort) {
        var sort = this.getSort();
        if (sort && sort.length > 0) this.unsort();
    }

    // If this._transferDuplicateQuery is undefined or 0, we didn't need to fire any server
    // queries, so we can call transferDragData to complete the transfer and send the queue
    // of updates to the server
    if (!this._transferDuplicateQuery) {
        isc.Log.logDebug("Invoking transferDragData from inside transferRecords - no server " +
                         "queries needed?", "dragDrop");
        sourceWidget.transferDragData(this._transferExceptionList, this);
        if (dataSource) {
            // send the queue unless we didn't initiate queuing
            if (!this._wasAlreadyQueuing) isc.rpc.sendQueue();
        }
    }

    this._transferringRecords = false;

},

// Store the details of a transfer in the _dropRecords queue on this component.  We work via
// a queue so that, if we get a transfer request when one is already running (this can happen
// because server-side duplicate checking makes the process asynchronous), we can postpone it
// and run it later as part of the first transfer's cleanup.
_storeTransferState : function (impl, dropRecords, targetRecord, index, sourceWidget, callback) {
    if (!isc.isAn.Array(this._dropRecords)) this._dropRecords = [];

    // If the transfer must wait its turn, add it to the end of the queue.  transferDragData()
    // will re-invoke anything put on the queue when it is its turn
    if (this._transferDuplicateQuery && this._transferDuplicateQuery != 0) {
        isc.logWarn("transferRecords was invoked but the prior transfer is not yet complete - \
                     the transfer will be queued up to run after the current transfer");
        this._dropRecords.add({
            implementation: impl,
            dropRecords: dropRecords,
            targetRecord: targetRecord,
            index: index,
            sourceWidget: sourceWidget,
            callback: callback
        });
        return false;
    }

    // If there's nothing in the way, it's this transfer's turn, so add it to the front of the
    // queue for later reading in transferDragData()
    this._dropRecords.addAt({
        implementation: impl,
        dropRecords: dropRecords,
        targetRecord: targetRecord,
        index: index,
        sourceWidget: sourceWidget,
        callback: callback
    }, 0);

    this._transferringRecords = true;
    this._transferExceptionList = [];
    this._transferDuplicateQuery = 0;

    return true;
},


updateDataViaDataSource : function(record, ds, updateProperties, sourceWidget) {

    var _listGrid = this;

    // Use updateOperation if applicable
    if (this.updateOperation) {
        if (updateProperties == null) updateProperties = {};
        isc.addProperties(updateProperties, {operationId: this.updateOperation});
    }

    if (!this.preventDuplicates) {
        if (!sourceWidget._updatesSent) sourceWidget._updatesSent = 0;
        sourceWidget._updatesSent++;
        ds.updateData(record, function (dsResponse, data, dsRequest) {
            sourceWidget._updateComplete(dsResponse, data, dsRequest);
        }, updateProperties);
        return;
    }

    var criteria = this.getCleanRecordData(record);

    if (this.data.find(criteria, null, Array.DATETIME_VALUES)) {

        isc.Log.logDebug("Found client-side duplicate, skipping update for '" +
                     record[isc.firstKey(record)] + "'", "dragDrop");
        this._transferExceptionList.add(this.getCleanRecordData(record));
    } else {
        // If we have a full cache, we can go ahead and update now
        if (this.data.allMatchingRowsCached()) {
        if (!sourceWidget._updatesSent) sourceWidget._updatesSent = 0;
            sourceWidget._updatesSent++;
            ds.updateData(record, function (dsResponse, data, dsRequest) {
                sourceWidget._updateComplete(dsResponse, data, dsRequest);
            }, updateProperties);
        } else {
            // Cache is incomplete, we'll have to ask the server
            isc.Log.logDebug("Incrementing dup query count: was " +
                             _listGrid._transferDuplicateQuery, "dragDrop");
            this._transferDuplicateQuery++;
            ds.fetchData(criteria,
                function (dsResponse, data, dsRequest) {
                    if (data && data.length > 0) {

                        isc.Log.logDebug("Found server-side duplicate, skipping update for '" +
                                     record[isc.firstKey(record)] + "'", "dragDrop");
                        _listGrid._transferExceptionList.add(_listGrid.getCleanRecordData(data[0]));
                    } else {
                        if (!sourceWidget._updatesSent) sourceWidget._updatesSent = 0;
                        sourceWidget._updatesSent++;
                        ds.updateData(record, function (dsResponse, data, dsRequest) {
                            sourceWidget._updateComplete(dsResponse, data, dsRequest);
                        }, updateProperties);
                    }
                    // If there are no further duplicate queries pending, we can finish up this
                    // transfer and send the queue of updates to the server
                    isc.Log.logDebug("Decrementing dup query count: was " +
                                     _listGrid._transferDuplicateQuery, "dragDrop");
                    if (--_listGrid._transferDuplicateQuery == 0 &&
                        !_listGrid._transferringRecords) {
                        if (sourceWidget.dragDataAction == isc.Canvas.MOVE) {
                            isc.Log.logDebug("Invoking transferDragData from inside callback", "dragDrop");
                            sourceWidget.transferDragData(_listGrid._transferExceptionList, _listGrid);
                            delete _listGrid._transferExceptionList;
                            // send the queue unless we didn't initiate queuing
                            if (!_listGrid._wasAlreadyQueuing) isc.rpc.sendQueue();
                        }
                    }
                },
                {sendNoQueue: true});
        }
    }

},


_addIfNotDuplicate : function (record, sourceDS, sourceWidget, foreignKeys, index, folder) {

    var ds = this.getDataSource(),
        pks,
        _listGrid = this,
        addProps = {};

    if (this.addOperation) {
        isc.addProperties(addProps, {operationId: this.addOperation});
    }

    if (ds) pks = ds.getPrimaryKeyFields();

    // If we have a target datasource and we have a PK, and at least one of the PK fields is
    // a sequence, we don't need to check for duplicates because we can assume the server
    // arranges for a unique value as part of the create process.  This is the only
    // circumstance in which we have a dataSource but don't need to check the server.  Note
    // that this special case code is duplicated in _isDuplicateOnClient() because that method
    // is called from other places.
    //
    // Note that we do this special check even before the simple check on this.preventDuplicates
    // because we need special key handling in this circumstance, even if the duplicate check
    // was going to pass anyway because we haven't set preventDuplicates.
    //

    if (ds) {
        var proceed;
        if (pks && isc.firstKey(pks) != null) {
            for (var field in pks) {
                if (pks[field].type == "sequence") {
                    proceed = true;
                    break;
                }
            }
        }

        if (proceed) {
            // Clear the primary key field(s) before calling to the server, otherwise the add
            // works but we get sent back the original keys and it confuses the client-side
            var undef;
            for (var field in pks) {
                record[field] = undef;
            }

            if (!sourceWidget._updatesSent) sourceWidget._updatesSent = 0;
            sourceWidget._updatesSent++;
            this.addData(record, function (dsResponse, data, dsRequest) {
                sourceWidget._updateComplete(dsResponse, data, dsRequest);
            });
            return true;
        }
    }

    if (!this.preventDuplicates) {
        if (ds) {
            if (!sourceWidget._updatesSent) sourceWidget._updatesSent = 0;
            sourceWidget._updatesSent++;

            this.addData(record, function (dsResponse, data, dsRequest) {
                sourceWidget._updateComplete(dsResponse, data, dsRequest);
            }, addProps);
        } else {
            if (isc.Tree && isc.isA.Tree(this.data)) {
                this.data.add(record, folder, index);
            } else if (isc.ResultSet && isc.isA.ResultSet(this.data)) {
                if (this.data.allRows != null) {
                    if (index != null) this.data.allRows.addAt(record, index);
                    else this.data.allRows.add(record);
                    this.data.filterLocalData();
                } else {
                    isc.logWarn("Unable to add data to resultSet - allRows is not set");
                }
            } else {
                if (index != null) this.data.addAt(record, index);
                else this.data.add(record);
            }
        }
        return true;
    }

    if (this._isDuplicateOnClient(record, sourceDS, foreignKeys)) {
        if (this.duplicateDragMessage != null) isc.warn(this.duplicateDragMessage);
        isc.Log.logDebug("Found client-side duplicate, adding '" +
                         record[isc.firstKey(record)] +
                         "' to exception list", "dragDrop");
        this._transferExceptionList.add(this.getCleanRecordData(record));
        return false;
    } else {
        if (!ds) {
            // Simplest case - no DS and no dup on client-side, so go ahead and add the record to
            // the underlying data model
            if (isc.Tree && isc.isA.Tree(this.data)) {
                this.data.add(record, folder, index);
            }  else if (isc.ResultSet && isc.isA.ResultSet(this.data)) {
                if (this.data.allRows != null) {
                    if (index != null) this.data.allRows.addAt(record, index);
                    else this.data.allRows.add(record);
                } else {
                    isc.logWarn("Unable to add data to resultSet - allRows is not set");
                }
            } else {
                if (index != null) this.data.addAt(record, index);
                else this.data.add(record);
            }
            return true;
        } else {
            if (!isc.ResultSet || !isc.isA.ResultSet(this.data)) {

                if (!sourceWidget._updatesSent) sourceWidget._updatesSent = 0;
                sourceWidget._updatesSent++;
                this.addData(record, function (dsResponse, data, dsRequest) {
                    sourceWidget._updateComplete(dsResponse, data, dsRequest);
                }, addProps);
                return true
            } else {
                // If we're dropping in a grid bound to a DS different from the source DS
                // and the two are related by foreignKey(s) (ie, the fks object is non-null), this is a
                // different scenario from a normal copy because it's enough to to know that the dropped
                // item doesn't exist in the current filtered view of this ListGrid.  So, if we have a
                // complete cache for the current filter criteria, we don't need to query the server.
                // This is not true for other copying scenarios, where we need a complete, unfiltered
                // cache to avoid the server query.
                if (this.data.allRowsCached() ||
                    (foreignKeys && isc.firstKey(foreignKeys) && this.data.allMatchingRowsCached())) {
                    if (!sourceWidget._updatesSent) sourceWidget._updatesSent = 0;
                    sourceWidget._updatesSent++;
                    this.addData(record, function (dsResponse, data, dsRequest) {
                        sourceWidget._updateComplete(dsResponse, data, dsRequest);
                    }, addProps);
                    return true;
                }
                // We have a dataSource and client-side search failed to find a duplicate.  We need a
                // server turnaround to know for sure whether we're proposing to add a duplicate
                if (ds && sourceDS == ds) {
                    if (pks && isc.firstKey(pks) != null) {
                        // Source DS and target DS are the same and we have a primary key
                        var criteria = isc.applyMask(record, pks);
                    } else {
                        // Source DS and target DS are the same and we have no primary key
                        criteria = this.getCleanRecordData(record);
                    }
                } else if (foreignKeys && isc.firstKey(foreignKeys)) {
                    // Source DS and target DS are different but related via a foreign key
                    criteria = isc.addProperties({}, this.data.getCriteria());
                    isc.addProperties(criteria, foreignKeys);
                } else if (ds && pks && isc.firstKey(pks) != null) {
                    // Target DS exists and has PKs defined, but either there is no source DS, or the
                    // source DS is different.  Report duplicate if there is a PK collision
                    criteria = isc.applyMask(record, pks);
                } else {
                    // Either the target grid is not bound to a DS, or the target DS has no PKs
                    criteria = this.getCleanRecordData(record);
                }
                isc.Log.logDebug("Incrementing dup query count: was " +
                                 _listGrid._transferDuplicateQuery, "dragDrop");
                this._transferDuplicateQuery++;
                ds.fetchData(criteria, function (dsResponse, data, dsRequest) {
                    if (data && data.length > 0) {

                        if (_listGrid.duplicateDragMessage != null) isc.warn(_listGrid.duplicateDragMessage);
                        isc.Log.logDebug("Found server-side duplicate, adding '" +
                                     record[isc.firstKey(record)] +
                                     "' to exception list", "dragDrop");
                        _listGrid._transferExceptionList.add(_listGrid.getCleanRecordData(record));
                    } else {
                        if (!sourceWidget._updatesSent) sourceWidget._updatesSent = 0;
                        sourceWidget._updatesSent++;
                        ds.addData(record, function (dsResponse, data, dsRequest) {
                            sourceWidget._updateComplete(dsResponse, data, dsRequest);
                        }, addProps);
                    }
                    // If there are no further duplicate queries pending, we know exactly which
                    // attempted transfers were duplicates (if any), so we're in a position to
                    // remove the source records if this was a MOVE, and to send the queue of
                    // updates to the server
                    isc.Log.logDebug("Decrementing dup query count: was " +
                                     _listGrid._transferDuplicateQuery, "dragDrop");
                    if (--_listGrid._transferDuplicateQuery == 0 &&
                        !_listGrid._transferringRecords) {
                        if (sourceWidget.dragDataAction == isc.Canvas.MOVE) {
                            isc.Log.logDebug("Invoking transferDragData from inside callback", "dragDrop");
                            sourceWidget.transferDragData(_listGrid._transferExceptionList, _listGrid);
                            delete _listGrid._transferExceptionList;
                            // send the queue unless we didn't initiate queuing
                            if (!_listGrid._wasAlreadyQueuing) isc.rpc.sendQueue();
                        }
                    }

                    },
                    {sendNoQueue: true});
            }
        }
    }
},

// Returns true if the passed-in record is a duplicate - according to the rules described in the
// discussion above _addIfNotDuplicate() - in the currently-known client data.  Handles both
// dataSource and non-dataSource cases.  Note that this function can return false even if the
// record is a duplicate - for example, if this.preventDuplicates is false.
_isDuplicateOnClient : function (record, sourceDS, foreignKeys) {
    var ds = this.getDataSource(),
        pks;

    if (!this.preventDuplicates) return false;

    if (ds) pks = ds.getPrimaryKeyFields();

    // If the source and target datasource are the same, and we have a PK, and at least one of
    // the PK fields is a sequence, we don't need to check for duplicates because we can assume
    // the server arranges for a unique value as part of the create process.  Note that
    // this logic is duplicated from _addIfNotDuplicate() because this method is called from
    // other places.
    if (ds && ds == sourceDS) {
        if (pks && isc.firstKey(pks) != null) {
            for (var field in pks) {
                if (pks[field].type == "sequence") {
                    return false;
                }
            }
        }
    }

    if (!ds) {
        // No DS - a duplicate is one that is identical in every property
        var criteria = this.getCleanRecordData(record);
    } else if (ds && sourceDS == ds) {
        if (pks && isc.firstKey(pks) != null) {
            // Source DS and target DS are the same and we have a primary key - compare PK fields
            criteria = isc.applyMask(record, pks);
        } else {
            // Source DS and target DS are the same and we have no primary key - compare all fields
            criteria = this.getCleanRecordData(record);
        }
        // no foreignKeys is supplied as {} rather than null, hence the firstKey check
    } else if (foreignKeys && isc.firstKey(foreignKeys)) {
        // Source DS and target DS are different but related via a foreign key - check for a record
        // that matches for the combination of the foreign key values and current filter criteria
        criteria = {};
        var tempCrit = this.data.getCriteria();
        if (!ds.isAdvancedCriteria(tempCrit)) {
            var context = this.data.context;
            if (!context || (context.textMatchStyle == null || context.textMatchStyle == "exact")) {
                isc.addProperties(criteria, tempCrit);
            }
        }
        isc.addProperties(criteria, foreignKeys);
    } else if (ds && pks && isc.firstKey(pks) != null) {
        // Target DS exists and has PKs defined, but either there is no source DS, or the
        // source DS is different.  Report duplicate if there is a PK collision

        criteria = isc.applyMask(record, pks);
    } else {
        // Either the target grid is not bound to a DS, or the target DS has no PKs
        criteria = this.getCleanRecordData(record);
    }

    // check the originalData if it's there, because rows in closed groups may not be in the data
    var data = this.originalData || this.data;
    if (data.findIndex(criteria, null, Array.DATETIME_VALUES) >= 0) return true;
    else return false;
},

getCleanRecordData : function (record) {
    if (isc.Tree && isc.isA.Tree(this.data)) {
        return this.data.getCleanNodeData(record, false);
    }
    var clean = {};
    for (var key in record) {
        // These are just the properties that LG scribbles onto its records. If you have others, it's
        // safe to exclude them in-place below, or just override this method.
        if (key.startsWith("_selection_")) continue;

        clean[key] = record[key];
    }

    return clean;
},

_updateComplete : function (dsResponse, data, dsRequest) {
    if (this._updatesSent) {
        isc.Log.logDebug("Decrementing update count - was " + this._updatesSent, "dragDrop");
        this._updatesSent -= 1;
    }
    if (!this._updatesSent) {
        isc.Log.logDebug("All updates complete, calling dragComplete()", "dragDrop");
        if (isc.isA.Function(this.dragComplete)) this.dragComplete();
    }
},

//> @method dataBoundComponent.getDropValues()
// Returns the "drop values" to apply to a record dropped on this component prior to update.  Only
// applicable to databound components - see +link{dropValues} for more details.  If multiple records
// are being dropped, this method is called for each of them in turn.
// <P>
// The default implementation of this method returns the following:
// <UL>
// <LI>Nothing, if +link{addDropValues} is false</LI>
// <LI>dropValues, if that property is set.  If the component's criteria object is applicable (as explained
// in the next item), it is merged into dropValues, with properties in dropValues taking precedence.</LI>
// <LI>The component's criteria object, if the most recent textMatchStyle for the component was "exact"
//     and it is simple criteria (ie, not an AdvancedCriteria object)</LI>
// <LI>Otherwise nothing</LI>
// </UL>
// <P>
// You can override this method if you need more complex setting of drop values than can be
// provided by simply supplying a dropValues object.
//
// @param record (Record) record being dropped
// @param sourceDS (DataSource) dataSource the record being dropped is bound to
// @param targetRecord (Record) record being dropped on
// @param index (int) index of record being dropped on
// @param sourceWidget (Canvas) widget where dragging began
// @return (object) dropValues, as described above.
//
// @visibility external
//<
getDropValues : function (record, sourceDS, targetRecord, index, sourceWidget, droppedRecords) {
    if (!this.addDropValues) return;

    var criteria = {},
        recordDS;

    // At the moment, only trees can contain records (nodes) that have their own dataSource
    if (this.data && this.data.getNodeDataSource) {
        recordDS = this.data.getNodeDataSource(targetRecord);
    }
    // recordDS may be null at this point:
    // - we may have never been populated with data (no filter)
    // - getNodeDataSource returns null if you pass the root node in - this appears to be
    //    intentional, so we'll cope with it here rather than risk breaking something
    if (!recordDS) {
        recordDS = this.getDataSource();
    }

    // Use original data for a grouped grid for correct criteria and context
    var data = (this.isGrouped ? this.getOriginalData() : this.data);

    // Passing the recordDS parameter is only applicable to trees, but does no harm for lists
    if (data && data.getCriteria) criteria = data.getCriteria(recordDS);

    var merged;
    // If we have an empty object we know it's not 'advanced' criteria
    if (isc.isAn.emptyObject(criteria) || (recordDS && !recordDS.isAdvancedCriteria(criteria))) {
        var context = data.context;
        if (context && (context.textMatchStyle == null || context.textMatchStyle == "exact")) {
            merged = isc.addProperties({}, criteria);
            if (this.dropValues) {
                merged = isc.addProperties(merged, this.dropValues);
            }
            return merged;
        }
    }

    return this.dropValues;
},

//>    @method    dataBoundComponent.transferDragData()    (A)
//
// During a drag-and-drop interaction, this method is called to transfer a set of records that
// were dropped onto some other component.  This method is called after the set of records has
// been copied to the other component.  Whether or not this component's data is modified is
// determined by the value of +link{dataBoundComponent.dragDataAction}.
// <P>
// With a <code>dragDataAction</code> of "move", a databound component will issue "remove"
// dsRequests against its DataSource to actually remove the data, via
// +link{dataSource.removeData()}.
//
// @return        (Array)        Array of objects that were dragged out of this ListGrid.
//
//
// @see DataBoundComponent.getDragData()
// @see ListGrid.willAcceptDrop();
//
// @visibility external
//<

transferDragData : function (transferExceptionList, targetWidget) {
    var selection = [],
        workSelection,
        callback,
        data;

    if (targetWidget && targetWidget._dropRecords != null && !targetWidget._dropRecords.isEmpty()) {
        data = targetWidget._dropRecords.shift();
        workSelection = data.dropRecords;
        callback = data.callback;
    } else {
        workSelection = this.getDragData();
        data = {};
    }

    if (workSelection == null) workSelection = [];

    // Filter the entries in the exception list out of the selection - we're not going to do
    // anything with them whatever the circumstances
    for (var i = 0; i < workSelection.length; i++) {
        var clean = this.getCleanRecordData(workSelection[i]);
        if (!transferExceptionList || !transferExceptionList.find(clean, null, Array.DATETIME_VALUES)) {
            // Include the dirty version of the record - it will likely have _selection_
            // scribbles on it that are required for an exact match lookup in the underlying
            // dataset
            selection.add(workSelection[i]);
        }
    }

    if (this.dragDataAction == isc.Canvas.MOVE && targetWidget != this && !data.noRemove) {

        if (this.dataSource && !this.shouldSaveLocally()) {

            // In the special case of a MOVE between two components bound to the same dataSource,
            // transferRecords() handles the transfer with update operations rather than removing
            // and adding. So in that case, we don't want to remove anything from the source
            // component (since it's databound, it will be sync'd automatically)
            var targetDS = targetWidget.getDataSource();
            if (targetDS != this.getDataSource()) {
                var wasAlreadyQueuing = isc.rpc.startQueue();
                for (var i = 0; i < selection.length; i++) {
                    this.getDataSource().removeData(selection[i]);
                }
                // send the queue unless we didn't initiate queuing
                if (!wasAlreadyQueuing) isc.rpc.sendQueue();
            }
        } else if (this.data) {
            var removeFromAllRows = isc.ResultSet && isc.isA.ResultSet(this.data) && this.shouldSaveLocally();
            for (var i = 0; i < selection.length; i++) {
                if (removeFromAllRows) {
                    if (this.data.allRows != null) {
                        this.data.allRows.remove(selection[i]);
                    } else {
                        isc.logWarn("Unable to remove data from resultSet - allRows is not set");
                    }
                } else {
                    this.data.remove(selection[i]);
                }
                if (this.isGrouped) {
                    this.originalData.remove(selection[i]);
                }
            }
            if (removeFromAllRows) this.data.filterLocalData();
        }
        // de-select the selection in the context of this list
        // so if it is dragged *back* into the list, it won't already be selected!
        if (this.selection && this.selection.deselectList) {

            this.selection.deselectList(workSelection, this);
        }
    }

    if (targetWidget) {
        // Invoke the user event, if one is implemented
        if (isc.isA.Function(targetWidget.dropComplete)) targetWidget.dropComplete(selection);

        // Fire the callback, if one was provided
        if (callback) {
            this.fireCallback(callback, "records", [selection]);
        }

        // If the target widget's _dropRecords member still has entries, we've got drag and drop
        // transactions queuing up for it, so schedule the next one before ending.
        if (targetWidget._dropRecords && targetWidget._dropRecords.length > 0) {
            var next = targetWidget._dropRecords.shift();
            isc.Timer.setTimeout(function () {
                if (next.implementation == "transferNodes") {
                    targetWidget.transferNodes(next.dropRecords, next.targetRecord, next.index,
                                               next.sourceWidget, next.callback);
                } else {
                    targetWidget.transferRecords(next.dropRecords, next.targetRecord, next.index,
                                                 next.sourceWidget, next.callback);
                }
            }, 0);
        }
    }

    return selection;
},

//>    @method    dataBoundComponent.getDragData()    (A)
//
// During a drag-and-drop interaction, this method returns the set of records being dragged out
// of the component.  In the default implementation, this is the list of currently selected
// records.<p>
//
// This method is consulted by +link{ListGrid.willAcceptDrop()}.

// @param source (DataBoundComponent) source component from which the records will be transferred
//
// @group    dragging, data
//
// @return    (Array of Record)        Array of +link{Record}s that are currently selected.
//
// @visibility external
//<
getDragData : function () {
    var selection = (this.selection && this.selection.getSelection) ?
                                        this.selection.getSelection() : null;

    return selection;
},

//>    @method    dataBoundComponent.cloneDragData()    (A)
//
// During a drag-and-drop interaction, this method returns the set of records being dragged out
// of the component.  It differs from +link{dataBoundComponent.getDragData()} in that some extra
// preparation is done to the set of records, making them suitable for passing to the method
// that actually carries out the transfer (+link{dataBoundComponent.transferRecords()}.  Note that,
// despite the name, records are not always cloned - sometimes they new, cleaned versions of the
// selected records and sometimes (if we're doing a move rather than a copy) we return the
// selected records themselves.
//
// This method is called by functions that commence the actual record transfer process:
// +link{dataBoundComponent.transferSelectedData() and the drop() methods of record-based,
// databound classes like +link{class:ListGrid}

// @param source (DataBoundComponent) source component from which the records will be transferred
//
// @group    dragging, data
//
// @return    (Array of Record)        Array of +link{Record}s that are currently selected.
//
// @see DataBoundComponent.getDragData
// @visibility internal
//<
cloneDragData : function () {
    var selection = this._selectionAtDragStart;
    if (selection == null) {
        selection = this.getDragData();
    }
    this._selectionAtDragStart = null;

    var copyData = this.dragDataAction == isc.Canvas.COPY ||
                   this.dragDataAction == isc.Canvas.CLONE;

    var oldComponents = []

    if (copyData && selection) {
        if (isc.isA.Tree(this.data)) {
            selection = this.data.getCleanNodeData(selection);
        } else {
            if (!isc.isAn.Array(selection)) selection = [selection];

            var clonedSelection = [];
            for (var i=0; i<selection.length; i++) {
                // clear any embedded components as part of cloning
                clonedSelection[i] = this.getCleanRecordData(selection[i]);
            }

            selection = clonedSelection;
        }
    }

    return selection;
},

//>    @attr dataBoundComponent.dragDataAction (DragDataAction : isc.Canvas.MOVE : IRW)
// Indicates what to do with data dragged into another DataBoundComponent. See
// DragDataAction type for details.
// @group dragging
// @visibility external
// @example gridsDragMove
// @example gridsDragCopy
//<

dragDataAction: isc.Canvas.MOVE,

//> @method dataBoundComponent.transferSelectedData()
// Simulates a drag / drop type transfer of the selected records in some other component to this
// component, without requiring any user interaction.  This method acts on the dropped records
// exactly as if they had been dropped in an actual drag / drop interaction, including any
// special databound behavior invoked by calling
// +link{DataBoundComponent.getDropValues,getDropValues} for each dropped record.
// <P>
// To transfer <b>all</b> data in, for example, a +link{ListGrid}, call grid.selection.selectAll() first.
// <P>
// Note that drag/drop type transfers of records between components are asynchronous operations:
// SmartClient may need to perform server turnarounds to establish whether dropped records
// already exist in the target component.  Therefore, it is possible to issue a call to
// transferSelectedData() and/or the +link{listGrid.drop(),drop()} method of a databound
// component whilst a transfer is still active.  When this happens, SmartClient adds the
// second and subsequent transfer requests to a queue and runs them one after the other.  If
// you want to be notified when a transfer process has actually completed, either provide a
// callback to this method or implement +link{dataBoundComponent.dropComplete()}.
// <P>
// See the +link{group:dragging} documentation for an overview of list grid drag/drop data
// transfer.
//
// @param source (DataBoundComponent) source component from which the records will be transferred
// @param [index] (integer) target index (drop position) of the rows within this grid.
// @param [callback] (Callback) optional callback to be fired when the transfer process has
//                       completed.  The callback will be passed a single parameter "records",
//                       the list of records actually transferred to this component.
// @group dragdrop
// @example dragListMove
// @visibility external
//<
transferSelectedData : function (source, index, callback) {

    if (!this.isValidTransferSource(source)) {
        if (callback) this.fireCallback(callback);
        return;
    }

    // don't check willAcceptDrop() this is essentially a parallel mechanism, so the developer
    // shouldn't have to set that property directly.
    if (index != null) index = Math.min(index, this.data.getLength());

    // Call cloneDragData to pull the records out of our dataset




    var dropRecords = source.cloneDragData();
    var targetRecord;
    if (index != null) targetRecord = this.data.get(index);

    this.transferRecords(dropRecords, targetRecord, index, source, callback);
},

// helper for transferSelectedData()
isValidTransferSource : function (source) {
    if (!source || !source.transferDragData) {
        this.logWarn("transferSelectedData(): " + (source ? "Invalid " : "No ") +
                     "source widget passed in - " + (source || "") +
                     " taking no action.");
        return false;
    }
    if (source == this) {
        this.logWarn("transferSelectedData(): target parameter contains a pointer back to this grid - ignoring");
        return false;
    }
    return true;
},

// -----------------------------------------------------------------------------------
// Drag tracker and drag line

//>@method  dataBoundComponent.setDragTracker()
// Sets the custom tracker HTML to display next to the mouse when the user initiates a drag
// operation on this component. Default implementation will examine +link{listGrid.dragTrackerMode}
// and set the custom drag tracker to display the appropriate HTML based on the selected record.
// <br>
// To display custom drag tracker HTML, this method may be overridden - call
// +link{EventHandler.setDragTracker()} to actually update the drag tracker HTML.
// @return (boolean) returns false by default to suppress 'setDragTracker' on any ancestors
//                   of this component.
// @group dragTracker
// @visibility external
//<
setDragTracker : function () {
    var EH = isc.EH, dragTrackerMode = this.dragTrackerMode;

    // When canDragSelectText:true no tracker should be shown. This option is mutually
    // exclusive with other drag actions.
    if (dragTrackerMode == "none" || EH.dragOperation == EH.DRAG_SCROLL || this.canDragSelectText) {
        // we can't just not call setDragTracker(), or the dragTracker will be set to the
        // default canvas tracker image.
        EH.setDragTracker("");
        return false;
    } else if (dragTrackerMode == "icon") {
        var selection = this.getSelection(),
            icon = this.getDragTrackerIcon(selection);

            EH.setDragTracker(this.imgHTML(icon), null,null,null,null, this.getDragTrackerProperties());
            return false;
    } else {

        var record = this.getSelectedRecord(),
            rowNum = record && this.data ? this.data.indexOf(record) : -1;

        // can happen on grids with no selection enabled
        if (record == null) return false;

        if (dragTrackerMode == "title") {
            var title = this.getDragTrackerTitle(record, rowNum);
            EH.setDragTracker(title,  null,null,null,null, this.getDragTrackerProperties());
            return false;
        } else if (dragTrackerMode == "record") {
            var rowHTML = this.body.getTableHTML([0, this.fields.length-1], rowNum, rowNum+1);
            //this.logWarn("row html:"+ rowHTML);
            EH.setDragTracker(rowHTML,  null,null,null,null, this.getDragTrackerProperties());
            return false;
        }
    }
    // If dragTrackerMode is unrecognized, let the normal tracker show up.
},

//> @method dataBoundComponent.getDragTrackerProperties()
// Return properties to apply to the drag tracker when the user drags some record.<br>
// Default implementation returns an object with attribute <code>opacity</code> set
// to <code>50</code> if +link{listGrid.dragTrackerMode} is set to <code>"record"</code>,
// otherwise returns null.
// @group dragTracker
// @return (object | null) Properties apply to the drag tracker
//<
getDragTrackerProperties : function () {
    var props = isc.addProperties({}, this.dragTrackerProperties);
    props.styleName = this.dragTrackerStyle;
    if (this.dragTrackerMode == "record") props.opacity = 50;
    return props;
},

//> @attr dataBoundComponent.dragTrackerStyle (CSSStyleName : "gridDragTracker" : IRW)
// CSS Style to apply to the drag tracker when dragging occurs on this component.
// @visibility external
//<
dragTrackerStyle:"gridDragTracker",

//>    @method    dataBoundComponent.makeDragLine()    (A)
//        @group    dragging, drawing
//            make the dragLine
//        @return    (boolean)    false if this._dragLine already exists
//<
makeDragLine : function () {
    if (this._dragLine) return false;

    // create the dragLine and move it to the front

    var dragLine = {
        ID:this.getID()+"_dragLine",
        width:2,
        height:2,
        overflow:isc.Canvas.HIDDEN,
        visibility:isc.Canvas.HIDDEN,
        isMouseTransparent:true, // to prevent dragline occlusion of drop events
        dropTarget:this, // delegate dropTarget
        redrawOnResize:false,
        styleName:"dragLine"
        //,backgroundColor:"black"
    };
    //>!BackCompat 2005.01.01 XXX old skin files didn't define a drag line style, so ensure the
    // line shows up.
    if (this.ns.Element.getStyleEdges(dragLine.styleName) == null) {
        dragLine.backgroundColor = "black";
    } //<!BackCompat
    isc.addProperties(dragLine, this.dragLineDefaults, this.dragLineProperties);
    this._dragLine = this.ns.Canvas.create(dragLine);

    return true;
},

//>    @method    dataBoundComponent.hideDragLine()    (A)
//        @group    dragging, drawing
//            hide the dragLine
//<
hideDragLine : function () {
    if (this._dragLine) {
        this._dragLine.hide();
        // shift it offscreen too so it doesn't take up any scroll space!
        this._dragLine.moveTo(0, -9999);
    }
},

// Properties related to panelHeader Actions
canExport: true,
canPrint: true,

panelControls: ["action:edit", "action:editNew", "action:sort", "action:export", "action:print"],

dbcProperties: ["autoFetchData", "autoFetchTextMatchStyle", "autoFetchAsFilter", "dataSource"],

// Core facility to configure one DBC from another (initially for use in MultiView)
configureFrom : function (existingDBC) {
    var props = this.dbcProperties;

    for (var i=0; i<props.length;i++) {
        this[props[i]] = existingDBC[props[i]];
        if (props[i] == "dataSource") {
            var fetchData = this.autoFetchData;
            this.autoFetchData = false;
            this.setDataSource(isc.DS.getDataSource(this.dataSource));
            this.autoFetchData = fetchData;
        }
    }


    this.setCriteria(existingDBC.getCriteria());
    this.setData(existingDBC.getData());
},

// Formula/Summary Builders
// -----------------------------------------------------------------------------------

//>    @attr dataBoundComponent.badFormulaResultValue        (String : "." : IRW)
// If the result of a formula evaluation is invalid (specifically, if isNaN(result)==true),
// badFormulaResultValue is displayed instead.  The default value is ".".
//
// @group formulaFields
// @visibility external
//<
badFormulaResultValue: ".",

//>    @attr dataBoundComponent.missingSummaryFieldValue        (String : "-" : IRW)
// If a summary format string contains an invalid field reference, replace the reference
// with the missingSummaryFieldValue. The default value is "-".
//
// @group summaryFields
// @visibility external
//<
missingSummaryFieldValue: "-",

//>    @attr dataBoundComponent.missingFormulaFieldValue (String : "-" : IRW)
// If a formula format string contains an invalid field reference, replace the reference
// with the missingFormulaFieldValue. The default value is "-".
//
// @group formulaFields
//<
missingFormulaFieldValue: "-",

//> @attr dataBoundComponent.canAddFormulaFields (boolean : false : IRW)
// Adds an item to the header context menu allowing users to launch a dialog to define a new
// field based on values present in other fields, using the +link{FormulaBuilder}.
// <P>
// User-added formula fields can be persisted via +link{listGrid.getFieldState()} and
// +link{listGrid.setFieldState()}.
//
// @group formulaFields
// @visibility external
//<
canAddFormulaFields:false,

//> @attr dataBoundComponent.addFormulaFieldText (String : "Add formula column..." : IRW)
// Text for a menu item allowing users to add a formula field
//
// @group i18nMessages
// @visibility external
//<
addFormulaFieldText: "Add formula column...",

//> @method dataBoundComponent.addFormulaField
// Convenience method to display a +link{FormulaBuilder} to create a new Formula Field.  This
// is equivalent to calling +link{dataBoundComponent.editFormulaField, editFormulaField()} with
// no parameter.
//
// @group formulaFields
// @visibility external
//<
addFormulaField : function () {
    this.editFormulaField();
},

//> @attr dataBoundComponent.editFormulaFieldText (String : "Edit formula..." : IRW)
// Text for a menu item allowing users to edit a formula field
//
// @group i18nMessages
// @visibility external
//<
editFormulaFieldText: "Edit formula...",

//> @attr dataBoundComponent.removeFormulaFieldText (String: "Remove formula" : IRW)
// Text for a menu item allowing users to remove a formula field
//
// @group i18nMessages
// @visibility external
//<
removeFormulaFieldText: "Remove formula",


_editComputedField : function (field, builderType) {
    // return if FormulaBuilder isn't available
    if (isc.FormulaBuilder == null) return;

    var component = this,
        editMode = !field ? false : true,
        lowercaseBuilderType = builderType.toLowerCase();

    if (isc.isA.String(field)) {
        field = this.getField(field);
    }

    var builder = isc[builderType + "Builder"].create({
        autoDraw: false,
        overflow: "visible",
        component: component, dataSource: component.getDataSource(),
        editMode: editMode, field: field,
        mathFunctions: builderType == "Formula" ?
            isc.MathFunction.getDefaultFunctionNames() : null,
        headerSpans: this.headerSpans,
        showHeaderSpanTitles: this.showHeaderSpanTitlesInFormulaBuilder,
        spanTitleSeparator: this.formulaBuilderSpanTitleSeparator,
        fieldKeyProperties: {
            // star height ensures the grid expands vertically to fill all available
            // space if window is resized, even if there are no more records to show.
            // This looks better than having a bunch of blank space at bottom of window
            height: "*"
        },
        fireOnClose: function(){
            component.userFieldCallback(this);
        }
    }, this[lowercaseBuilderType + "BuilderProperties"]);


    this.fieldEditorWindow = this.createAutoChild("fieldEditorWindow", isc.addProperties({}, {
            title: this.fieldEditorWindowTitle.evalDynamicString(this,
                { builderType: builderType, fieldTitle: builder.field.title }),
            items: [builder]
        }, this[lowercaseBuilderType + "EditorProperties"])
    );

    this.fieldEditorWindow.show();
},

//> @method dataBoundComponent.editFormulaField
// Method to display a +link{FormulaBuilder} to edit a formula Field.  If the function is called
// without a parameter, a new field will be created when the formula is saved.
//
// @param    field       (Field)    Field to edit or null to add a new formula field
// @group formulaFields
// @visibility external
//<
editFormulaField : function (field) {
    return this._editComputedField(field, "Formula");
},

//> method dataBoundComponent.invalidateUserCache
// Marks the dataBoundComponent as having no cached values,
// effectively clearing them with respect to any client code
// (or removes some of the cached values if called with parameters).
// @param records (Array of Record) records whose cache should be cleared
// @param fields  (Array of Field)  fields whose cache should be cleared
//<

_cacheOrdinal: 0,
invalidateUserCache : function (records, fields) {

    // handle the O(1) "clear everything" operation, as well as cases where
    // the caller has not supplied any records, but wants certain fields targeted
    if (!records) {
        if (!fields) {
            this._cacheOrdinal++;
            return;
        }
        records = this.data || [];
        if (isc.ResultSet && isc.isA.ResultSet(records)) records = records.getAllLoadedRows();
        if (isc.Tree      && isc.isA.Tree     (records)) records = records.getAllItems();
    }
    if (!records) return;

    // promote single record to an array of records
    if (!isc.isAn.Array(records)) records = [records];

    if (fields != null) {
        // promote single field to an array of fields
        if (!isc.isAn.Array(fields)) fields = [fields];
        // remove non-user formula/summary fields
        fields = this.getCacheableFields(fields);
    }

    // clear the requested cache bits based on supplied records/field names
    for (var i = 0; i < records.length; i++) {
        if (!records[i]) continue;

        var cache = records[i]["_cache_" + this.ID];
        if (!cache) continue;

        if (fields == null) delete records[i]["_cache_" + this.ID]
        else {
            for (var j = 0; j < fields.length; j++) {
                delete cache[fields[j].name];
            }
        }
    }
},


_addDependentUserFields : function (fields) {
    var result = {},
        dependencies = this._getFieldDependencyTable();

    for (var i = 0; i < fields.length; i++) {
        var dependentFields = dependencies[fields[i].name];
        if (dependentFields) isc.addProperties(result, dependentFields);
        result[fields[i].name] = fields[i];
    }
    return isc.getValues(result);
},
_getUserFieldInputFields : function (field) {
    var fields;
    if (field.userFormula != null) {
        fields = field.userFormula.formulaVars;
    } else if (field.userSummary != null) {
        fields = field.userSummary.summaryVars;
    }
    if (!fields) return {};
    else fields = isc.getValues(fields);

    var result = {};
    for (var i = 0; i < fields.length; i++) {
        var inputField = this.getField(fields[i]);
        if (inputField) {
            result[inputField.name] = inputField;
            isc.addProperties(result, this._getUserFieldInputFields(inputField));
        }
    }
    return result;
},
_getFieldDependencyTable : function () {

    if (this._fieldDependencyTable == null) {
        var dependencyTable = this._fieldDependencyTable = {};

        var fields = this.fields;
        for (var i = 0; i < fields.length; i++) {
            var inputFieldNames = isc.getKeys(this._getUserFieldInputFields(fields[i]));
            for (var j = 0; j < inputFieldNames.length; j++) {
                var fieldName = inputFieldNames[j];
                if (dependencyTable[fieldName] == null) {
                    dependencyTable[fieldName] = {};
                }
                dependencyTable[fieldName][fields[i].name] = fields[i];
            }
        }
    }
    return this._fieldDependencyTable;
},
_clearFieldDependencyTable : function () {
    delete this._fieldDependencyTable;
},

// provide consistent map between variables and fields across component
rebuildAllFieldsFormulaVarMaps : function () {
    var fields = this.getAllFields(),
        varToFieldName = {},
        fieldNameToVar = {};

    if (fields == null) return;

    // the first binding of a field to a variable in the field list wins
    for (var i = 0; i < fields.getLength(); i++) {
        var item = fields.get(i);
        if (item.userFormula) {
            var formula = item.userFormula,
                formulaVars = formula.formulaVars,
                keys = isc.getKeys(formulaVars);
            for (var j = 0; j < keys.length; j++) {
                var formulaVar = keys[j],
                    fieldName = formulaVars[formulaVar];
                if (!fieldNameToVar[fieldName]) {
                    fieldNameToVar[fieldName] = formulaVar;
                    varToFieldName[formulaVar] = fieldName;
                }
            }
        }
    }

    // store both variable => fieldName and fieldName => variable maps
    this._allFieldsFormulaVarMaps = {varToFieldName: varToFieldName,
                                     fieldNameToVar: fieldNameToVar};
},

// define versions of these APIs for +link{DataBoundComponent} to simplify the logic;
// they are meaningful mostly in +link{ListGrid} where summary records are possible
shouldApplyUserFormulaAfterSummary : function (field) {
    return field && field.userFormula != null;
},
shouldShowUserFormula : function (field, record) {
    return true;
},

// provide an API to return all fields that we are capable of caching
getCacheableFields : function (fields) {
    var fields = fields != null ? fields : this.getFields();
    if (fields == null) return []; // allow Array.getProperty()
    return fields.filter(function (field) {
        return field.userFormula != null || field.userSummary != null;
    });
},

//> @method dataBoundComponent.getFormulaFieldValue()
// Get the computed value of a +link{canAddFormulaFields,formula field}.
// @param field (Field) field that has a formula
// @param record (Record) record to use to compute formula value
// @return (Double or String) formula result if a valid number or
// +link{dataBoundComponent.badFormulaResultValue} if invalid
// @visibility external
//<
getFormulaFieldValue : function (field, record, formulaFunction) {
    if (!isc.isAn.Object(field)) field = this.getField(field);

    if (record && record["_cache_" + this.ID] && field && field.name &&
        record["_cache_" + this.ID][field.name] == this._cacheOrdinal)
    {
        return record[field.name];
    }

    if (formulaFunction == null) formulaFunction = this.getFormulaFunction(field);
    if (!formulaFunction) return null;

    var result = formulaFunction(record, this);

    if (record && !record._noCache) {
        if (!record["_cache_" + this.ID]) record["_cache_" + this.ID] = {};
        record["_cache_" + this.ID][field.name] = this._cacheOrdinal;
        record[field.name] = result;
    }

    return result;
},

// for a field with a userFormula, get the function that will generate formula output for a
// record
getFormulaFunction : function (field) {
    if (!field || !field.userFormula) return null;
    var func = field._generatedFormulaFunc;
    if (func != null && func._userFormula == field.userFormula) return func;
    // first use of formula field - generate the formula function and install as sortNormalizer
    // too
    func = field._generatedFormulaFunc =
            isc.FormulaBuilder.generateFunction(field.userFormula, this.getAllFields(), this);
    func._userFormula = field.userFormula;



    return func;
},

//> @attr dataBoundComponent.canAddSummaryFields (boolean : false : IRW)
// Adds an item to the header context menu allowing users to launch a dialog to define a new
// text field that can contain both user-defined text and the formatted values present in other
// fields, using the +link{SummaryBuilder}.
// <P>
// User-added summary fields can be persisted via +link{listGrid.getFieldState()} and
// +link{listGrid.setFieldState()}.
//
// @group summaryFields
// @visibility external
//<
canAddSummaryFields:false,

//> @attr dataBoundComponent.addSummaryFieldText (String : "Add summary column..." : IRW)
// Text for a menu item allowing users to add a formula field
//
// @group i18nMessages
// @visibility external
//<
addSummaryFieldText: "Add summary column...",

//> @method dataBoundComponent.addSummaryField
// Convenience method to display a +link{SummaryBuilder} to create a new Summary Field.  This
// is equivalent to calling +link{dataBoundComponent.editSummaryField, editSummaryField()} with
// no parameter.
//
// @group summaryFields
// @visibility external
//<
addSummaryField : function () {
    this.editSummaryField();
},

//> @attr dataBoundComponent.editSummaryFieldText (String : "Edit summary format..." : IRW)
// Text for a menu item allowing users to edit the formatter for a field
//
// @group i18nMessages
// @visibility external
//<
editSummaryFieldText: "Edit summary format...",

//> @attr dataBoundComponent.removeSummaryFieldText (String: "Remove summary format..." : IRW)
// Text for a menu item allowing users to remove a summary field
//
// @group i18nMessages
// @visibility external
//<
removeSummaryFieldText: "Remove summary column..",

//> @method dataBoundComponent.editSummaryField
// Method to display a +link{SummaryBuilder} to edit a Summary Field.  If the function is called
// without a parameter, a new field will be created when the summary is saved.
//
// @param    field       (Field)    Field to edit or null to add a new summary column
// @group summaryFields
// @visibility external
//<
editSummaryField : function (field) {
    return this._editComputedField(field, "Summary");
},

// after a FormulaBuilder or SummaryBuilder completes, add the new field (or update the field)
userFieldCallback : function (builder) {
    if (!builder) return;

    var editorWindow = this.fieldEditorWindow;

    if (builder.cancelled) {
        editorWindow.destroy();
        return;
    }

    var field = builder.getUpdatedFieldObject();

    // If this is a new field (rather than an edit of an existing Summary / Formula field),
    // base the unique field name on the title if this is easy to do.

    var fieldName = field.name;
    if (this.getField(fieldName) == null) {
        var title = field.title;
        if (title != null && !isc.isA.emptyString(title)
            && title != builder.defaultNewFieldTitle)
        {
            var namePrefix = title;

            namePrefix = namePrefix.replace(/ |\.|-/g, "_");
            if (namePrefix.match(/^[0-9]/)) namePrefix = "_" + namePrefix;
            if (String.isValidID(namePrefix)) {
                field.name = builder.getNewUniqueFieldName(namePrefix);
            } else {
                this.logInfo(
                    "User-created field: unable to create fieldName based on specified title " +
                    title + ", using default name:" + field.name,
                    "summaryField"
                );
            }
        } else {
            this.logDebug(
                "User-created field: not attempting to create fieldName based on specified title " +
                title + ", using default name:" + field.name,
                "summaryField"
            );
        }

        var undef, first = builder.getUsedFields(true).first();
        if (field.summaryFunction === undef && first && first.summaryFunction != null) {
            field.summaryFunction = first.summaryFunction;
        }
    }

    // Fire a notification method here - this will allow the developer to modify the
    // added field
    if (this.userAddedField && this.userAddedField(field) == false) {
        editorWindow.destroy();
        return;
    }

    if (this.formulaUpdated && builder.builderTypeText == "Formula") {
        this.formulaUpdated(field, field.userFormula);
    }

    if (this.summaryUpdated && builder.builderTypeText == "Summary") {
        this.summaryUpdated(field, field.userSummary);
    }

    if (this.hideField && builder.shouldHideUsedFields()) {
        var usedFields = builder.getUsedFields();
        for (var i = 0; i < usedFields.length; i++) {
            var item = usedFields.get(i);
            if (item.canHide != false) this.hideField(item.name);
        }
    }


    var allFields = this.getAllFields();

    // if we edited a pre-existing field object (eg modified a pre-existing formula), find
    // and replace that field
    var fieldNum = isc.Class.getArrayItemIndex(field.name, allFields, this.fieldIdProperty);
    if (fieldNum >= 0) allFields[fieldNum] = field;
    // otherwise add as last visible field
    else allFields.addAt(field, this.getFields().length);

    this.setFields(allFields);

    if (this.markForRedraw) this.markForRedraw();

    var restart = builder.restartBuilder,
        type = builder.builderTypeText;

    editorWindow.destroy();

    if (restart) {
        if (type == "Formula") this.addFormulaField();
        else this.addSummaryField();
    }

    // if the grid is grouped on this formula or summary field, regroup() it now
    if (this.isGrouped && this.getGroupByFields && this.getGroupByFields().contains(field.name)) {
        this.regroup();
    }

    // if the DBC supports resorting, do that now
    if (this.resort) this.resort();
},

// for a field with a userSummary, get the function that will generate summary output for a
// record
getSummaryFunction : function (field) {
    if (!field || !field.userSummary) return null;
    var func = field._generatedSummaryFunc;
    if (func != null) return func;
    // first use of summary field - generate the summary function and install as sortNormalizer
    // too
    func = field._generatedSummaryFunc =
            isc.SummaryBuilder.generateFunction(field.userSummary, this.getAllFields(), this)
    ;


    return func;
},

//> @method dataBoundComponent.getSummaryFieldValue()
// Get the computed value of a +link{canAddSummaryFields,summary field}.
// @param field (Field) field that has a summary format
// @param record (Record) record to use to compute formula value
// @return (String) formula result
// @visibility external
//<
getSummaryFieldValue : function (field, record, summaryFunction) {
    if (!isc.isAn.Object(field)) field = this.getField(field);

    if (record && record["_cache_" + this.ID] && field && field.name &&
        record["_cache_" + this.ID][field.name] == this._cacheOrdinal)
    {
        return record[field.name];
    }

    if (summaryFunction == null) summaryFunction = this.getSummaryFunction(field);
    if (!summaryFunction) return null;

    var result = summaryFunction(record, field[this.fieldIdProperty], this);

    if (record) {
        if (!record["_cache_" + this.ID]) record["_cache_" + this.ID] = {};
        record["_cache_" + this.ID][field.name] = this._cacheOrdinal;
        record[field.name] = result;
    }

    return result;
},

//> @method dataBoundComponent.shouldIncludeHiliteInSummaryField()
// When assembling a value for a +link{canAddSummaryFields,summary field}, if a referenced
// field is hilited, should the hilite HTML be included in the summary field value?
// <P>
// Example use case: Consider a grid containing a numeric field, and a summary field
// which contains some string value, plus the contents of the numeric field.
// If a hilite is defined for the grid which turns the numeric field text red when
// the value is negative, this property will govern whether the number will also be
// rendered in red within the summary field cells. Any other text in the summary field
// cells would not be effected by this hilite.
// <P>
// Default implementation returns +link{dataBoundComponent.includeHilitesInSummaryFields,
// includeHilitesInSummaryFields}.
// <P>
// To control hilites showing in group summaries, see +link{listGrid.showHilitesInGroupSummary,
// showHilitesInGroupSummary}.
//
// @param summaryFieldName (string) name of the summary field
// @param usedFieldName (string) name of the field referenced by this summary
// @return (boolean) Return true to include hilites from the used field in the generated
//   summary field value.
// @visibility external
//<
shouldIncludeHiliteInSummaryField : function (summaryFieldName, usedFieldName) {
    return this.includeHilitesInSummaryFields
},

//> @attr dataBoundComponent.includeHilitesInSummaryFields (boolean : true : IRWA)
// When assembling a value for a +link{canAddSummaryFields,summary field}, if a referenced
// field is hilited, should the hilite HTML be included in the summary field value?
// <P>
// To control hilites showing in group summaries, see +link{listGrid.showHilitesInGroupSummary,
// showHilitesInGroupSummary}.
//
// @see shouldIncludeHiliteInSummaryField
// @visibility external
//<
includeHilitesInSummaryFields: true,


_setUserField : function (field, property, value, redrawFunc) {
    var undef;
    if (isc.isA.String(field)) field = this.getField(field);
    if (value !== undef) field[property] = value;
    this.invalidateUserCache(null, field);
    if (property == "userFormula") this.rebuildAllFieldsFormulaVarMaps();
    if (redrawFunc) redrawFunc(field);
},
_setUserFieldText : function (field, property, text, redrawFunc) {
    var undef;
    if (isc.isA.String(field)) field = this.getField(field);

    var value = field[property];
    if (value == null) {
        this.logWarn("Cannot set text for " + property + " of field '" + field.name +
                     "' since that user field is null");
        return;
    }
    if (text !== undef) value.text = text;
    this.invalidateUserCache(null, field);
    switch (property) { // ensure new function is generated
        case "userFormula": delete field._generatedFormulaFunc; break;
        case "userSummary": delete field._generatedSummaryFunc; break;
    }
    if (redrawFunc) redrawFunc(field);
},

//> @method dataBoundComponent.getRecordIndex()
// Get the index of the provided record.
// <P>
// Override in subclasses to provide more specific behavior, for instance, when data holds a
// large number of records
//
// @param record (Record) the record whose index is to be retrieved
// @return index (Number) index of the record, or -1 if not found
// @visibility external
//<
getRecordIndex : function (record) {
    return this.data.indexOf(record);
},

//> @method dataBoundComponent.getTitleFieldValue()
// Get the value of the titleField for the passed record
// <P>
// Override in subclasses
//
// @param record (Record) the record whose index is to be retrieved
// @return value (String) the value of the titleField for the passed record
// @visibility external
//<
getTitleFieldValue : function (record) {},



//> @attr dataBoundComponent.titleField (string : null : IR)
// Best field to use for a user-visible title for an individual record from this
// component.
// <P>
// This attribute has the same function as +link{DataSource.iconField} but can be
// set for a component with no dataSource, or can be used to override the dataSource setting.
//
// @visibility external
//<

//> @attr dataBoundComponent.iconField (string : null : IR)
// Designates a field of +link{FieldType,type}:"image" as the field to use when rendering a
// record as an image, for example, in a +link{TileGrid}.
// <P>
// This attribute has the same function as +link{DataSource.iconField} but can be
// set for a component with no dataSource, or can be used to override the dataSource setting.
//
// @visibility external
//<

//> @attr dataBoundComponent.infoField (String : null : IR)
// Name of the field that has the second most pertinent piece of textual information in the
// record, for use when a +link{DataBoundComponent} needs to show a short summary of a record.
// <P>
// This attribute has the same function as +link{DataSource.infoField} but can be
// set for a component with no dataSource, or can be used to override the dataSource setting.
//
// @visibility external
//<


//> @attr dataBoundComponent.dataField (String : null : IR)
// Name of the field that has the most pertinent numeric, date, or enum value, for use when a
// +link{DataBoundComponent} needs to show a short summary of a record.
// <P>
// This attribute has the same function as +link{DataSource.dataField} but can be
// set for a component with no dataSource, or can be used to override the dataSource setting.
//
// @visibility external
//<

//> @attr dataBoundComponent.descriptionField (String : null : IR)
// Name of the field that has a long description of the record, or has the primary text data
// value for a record that represents an email message, SMS, log or similar.
// <P>
// This attribute has the same function as +link{DataSource.descriptionField} but can be
// set for a component with no dataSource, or can be used to override the dataSource setting.
//
// @visibility external
//<




//> @method dataBoundComponent.getTitleField()
// Method to return the fieldName which represents the "title" for records in this
// Component.<br>
// If this.titleField is explicitly specified it will always be used.
// Otherwise, default implementation will check +link{dataSource.titleField} for databound
// compounds.<br>
// For non databound components returns the first defined field name of <code>"title"</code>,
// <code>"name"</code>, or <code>"id"</code> where the field is visible. If we don't find any
// field-names that match these titles, the first field in the component will be used instead.
// @return (string) fieldName for title field for this component.
// @visibility external
//<
getTitleField : function () {
    if (this.titleField != null) return this.titleField;

    if (this.dataSource != null) {
        var field = this.getDataSource().getTitleField(),
            fieldDef = this.getField(field);
        if (!fieldDef || fieldDef.excludeFromState) {
            var fields = this.getFields(),
                foundVisibleField = false;
            for (var i = 0, numFields = fields.length; !foundVisibleField && i < numFields; ++i) {
                fieldDef = fields[i];
                if (!fieldDef.excludeFromState) {
                    // Save the first field not excluded from state.
                    if (field == null) field = fieldDef[this.fieldIdProperty];

                    if (this.fieldIsVisible(fieldDef) && this.shouldUseField(fieldDef)) {
                        field = fieldDef[this.fieldIdProperty];
                        foundVisibleField = true;
                    }
                }
            }
            if (field == null) {
                field = fields[0][this.fieldIdProperty];
            }
        }

        this.titleField = field;
    } else {
        // if a title field hasn't been explicitly specified, take a guess.
        // Also, remember the guess (this is an inner loop)
        var fields = this.getFields(),
            guesses = ["title", "label", "name", "id"],
            foundVisibleField = false;

        for (var i = 0; !foundVisibleField && i < guesses.length; ++i) {
            var guess = guesses[i],
                field = fields.find(this.fieldIdProperty, guess);
            if (field && this.fieldIsVisible(field) && this.shouldUseField(field) &&
                !field.excludeFromState)
            {
                this.titleField = guess;
                foundVisibleField = true;
            }
        }
        if (!foundVisibleField) {
            this.titleField = fields.first()[this.fieldIdProperty];

            // Search for the first field not excluded from state to use as the default.
            for (var i = 0; i < fields.length; ++i) {
                var field = fields[i];
                if (!field.excludeFromState) {
                    this.titleField = field[this.fieldIdProperty];
                    break;
                }
            }
        }
   }
   return this.titleField;
},

//> @method dataBoundComponent.getRecordHiliteCSSText()
// Return all CSS style declarations associated with the hilites of a record's field.
// @param record (Record)
// @param cssText (String) if set, returned CSS will be appended to this text
// @param field (Field) field object identifying whose CSS is to be returned
// @return value (String) CSS style declarations for this record and field
// @visibility external
//<
getRecordHiliteCSSText : function (record, cssText, field, visibleRecord) {
    if (record == null) return cssText;
    if (record.isGroupSummary && (!this.showHilitesInGroupSummary || field.showHilitesInGroupSummary == false)) return cssText;

    // addObjectHilites() will check for explicit record[this.hiliteProperty], find
    // the associated hilite and return the cssText for it (added to the cssText passed in)
    // The 'field' param allows that code to skip hilites that are specified for some
    // other field.
    cssText = this.addObjectHilites(record, cssText, field);


    if (visibleRecord == null) {
        visibleRecord =
            this.getFields().contains(field) &&
                ((isc.isA.List(this.data) && this.getRecordIndex(record) != -1)
                 || this.data == record);
    }
    // addHiliteCSSText() picks up cssText for hilites that apply to the cell due
    // to criteria/fieldName
    // Only works for records/fields that are present in the component's data/fields array

    if (visibleRecord) {
        cssText = this.addHiliteCSSText(record, field, cssText);

    // Handle the case where the record isn't part of data or the field isn't
    // one of the fields in the component by explicitly running the filter logic and
    // calculating hilite cssText.
    } else {
        var hilites = this.hilites;
        if (hilites) {
            for (var i = 0; i < hilites.length; i++) {
                if (field && field.name) {
                    var hilitedField = hilites[i].fieldName;
                    if (hilitedField &&
                        (isc.isAn.Array(hilitedField) ? !hilitedField.contains(field.name)
                                                      : hilitedField != field.name))
                    {
                        continue;
                    }
                }
                var matches = this.getRecordsMatchingHilite(hilites[i], [record]);
                if (matches && matches.length != 0) {
                    if (cssText == null) {
                        cssText = this.getHiliteCSSText(hilites[i]);
                    } else {
                        cssText += this.getHiliteCSSText(hilites[i]);
                    }
                }
            }
        }
    }
    if (this.logIsDebugEnabled("hiliting") && cssText != null) {
        this.logDebug("getRecordHiliteCSSText for field:" + field.name +
            " on record:" + this.echo(record)
            + "\n- gives back value: " + cssText, "hiliting");
    }
    return cssText;
},

//> @method dataBoundComponent.convertCSSToProperties()
// Convert a string containing CSS declarations into an object mapping CSS
// camelCaps property names with the declared values.
// @param css (string) Block of CSS style text
// @param allowedProperties (Array) optional array of CSS property names (camelCaps format)
//        constraining the allowed properties to be returned
// @return value (Object) CSS property-value pairs in camelCaps notation,
//         or null if no CSS was found
//<
convertCSSToProperties : function (css, allowedProperties) {
    if (css == null) return null;

    var statementList = css.split(";"),  // split into [name, value] pairs
        propertyList;

    statementList.map(function (decl) {
        var pair = decl.split(":");          // [ name, value ]
        if (pair.length != 2) return null;

        // Convert name to camelCaps. Trim whitespace from both name and value.
        var trimRe = /^\s*(\S*)\s*$/,
            name  = pair[0].cssToCamelCaps().replace(trimRe, "$1"),
            value = pair[1]                 .replace(trimRe, "$1");

        if (!allowedProperties || allowedProperties.contains(name)) {
            if (!propertyList) propertyList = {};
            propertyList[name] = value;
        }
    });

    return propertyList;
},
// Overridable method to return the exportable value of a record's field.
// By default, the display value is returned (via getStandaloneFieldValue),
// stripped of HTML tags.
getExportFieldValue : function (record, fieldName, fieldIndex) {
    return this.htmlUnescapeExportFieldValue(
        this.getStandaloneFieldValue(record, fieldName, false));
},

// Overridable method to store the exportable value of a record's field, including
// its style information, in exportObject[exportProp]. If the field is unstyled then
// exportObject is not modified. The exportable value is in one of two formats, depending
// on if the style information applies to the entire cell, or a part of the cell (eg
// if cell used in a summary has hiliting applied to it):
//
// * Cell-wide style: { backgroundColor: "#f00000" }
//
// * Sub-cell style:
//   [
//     { value: "1",
//       style: { backgroundColor: "#f00000" }
//     },
//     { value: " --- baz" }
//   ]
addDetailedExportFieldValue : function(exportObject, exportProp, record, exportField,
                                       exportFieldIndex, settings, rowIndex)
{
    var allowedProperties            = settings.allowedProperties,
        propagateInputHilites        = settings.propagateInputHilites,
        alwaysExportExpandedStyles   = settings.alwaysExportExpandedStyles,
        exportDatesAsFormattedString = settings.exportDatesAsFormattedString;

    var exportFieldName = exportField.name,
        exportFieldCSS = this.getRecordHiliteCSSText(record, null, exportField),
        simpleValue,
        formatProperties = {};

    // Inject background color explicitly defined for cell, if any

    var backgroundColor = this.getExportBGColor(rowIndex, exportFieldIndex, record);
    if (rowIndex != null && backgroundColor) {
       exportFieldCSS += "; backgroundColor: " + backgroundColor;
    }

    var declarativeFormat = this.getDeclarativeFormat(exportField);
    if (declarativeFormat) {
        formatProperties.rawValue = record[exportField.name];
        formatProperties.format = declarativeFormat;
    } else if (isc.isA.Date(record[exportField.name]) && !exportDatesAsFormattedString) {
        formatProperties = this.getDateFormattingProperties(exportField, record[exportField.name],
                                                                exportObject[exportField.title]);
    }

    // server-side performs conversion of "strings that look like numbers" if unformatted numeric
    // values are exported through POI (Excel), which may lead to rawValue (ID) replacing the
    // displayValue (VALUE) in case of valueMap set on a field. Docs say, that exportClientData
    // will always export displayValue for fields with valueMap despite any other settings.
    // This "hasValueMap" flag is preventing these replacements (search ExcelDataExport.java).
    // This code is executed only if exportClientData was called, so other exports are untouched.
    if (exportField.valueMap) {
        formatProperties.hasValueMap = true;
    }

    if (isc.isA.Number(record[exportField.name])) {
        formatProperties.rawValue = record[exportField.name];
    }

    if (formatProperties && isc.getKeys(formatProperties).length == 0) {
        formatProperties = null;
    }

    if (exportField.exportRawValues || (this.exportRawValues && exportField.exportRawValues != false))
        simpleValue = record[exportField[this.fieldIdProperty]];
    else
        simpleValue = this.getExportFieldValue(record, exportField.name, exportFieldIndex);

    if (!exportField.userSummary || !propagateInputHilites) {
        if (exportFieldCSS || formatProperties) {
            var props = this.convertCSSToProperties(exportFieldCSS, allowedProperties);
            if (formatProperties) {
                if (!props) props = {};
                isc.addProperties(props, formatProperties);
            }
            if (props) {
                if (alwaysExportExpandedStyles)
                    exportObject[exportProp] = [{value: simpleValue, style: props }];
                else
                    exportObject[exportProp] = props;
            }
        }
        return;
    }

    if (!exportField.userSummary.text) this.logError("Summary field does not have text format");

    // Code below generally adapted from SummaryBuilder.getFieldDetailsFromValue, generateFunction
    var missingFields = [], usedFields = {}, usedFieldsCSS = {};
    var cssFound = (exportFieldCSS && exportFieldCSS != "");

    // compile lists of used and missing fields and save off used field CSS for later
    for (var key in exportField.userSummary.summaryVars) {
        var varFieldName = exportField.userSummary.summaryVars[key],
            varField = this.getField(varFieldName);
        if (!varField) missingFields.add(varFieldName);
        else {
            usedFields[key] = varField;

            var varCSS = this.getRecordHiliteCSSText(record, null, varField);
            if (varCSS) {
                usedFieldsCSS[key] = varCSS;
                cssFound=true;
            }
        }
    }

    // if there's no style info, there's no need for a $style entry.
    if (!cssFound) return;

    // missing fields fail the method and probably ought to be styled
    if (missingFields.length != 0 && exportFieldCSS) {
        if (alwaysExportExpandedStyles) {
            exportObject[exportProp] = {
                style: this.convertCSSToProperties(exportFieldCSS, allowedProperties),
                value: simpleValue
            };
        } else {
            exportObject[exportProp] = this.convertCSSToProperties(
                exportFieldCSS, allowedProperties);
        }
        return;
    }

    // substrings of summary value are stored in currentFragment along with its associated
    // CSS in currentCSS, before they are combined into a single object and appended to output
    // array detailedValues. Consecutive fragments with equal css strings are merged.
    var currentFragment = null, currentCSS = null, detailedValue = [];

    // addToOutput(): helper function for outputting value/css pairs.
    var _this=this;
    var addToOutput = function (value, css) {
        if (value) {
            value = _this.htmlUnescapeExportFieldValue(value);

            if (currentFragment && currentCSS == css) {
                currentFragment.value += value; // merge if styles are equal
            } else {
                // add current fragment to output array and create new fragment
                if (currentFragment) detailedValue.push(currentFragment);

                currentFragment = {value: value};
                currentCSS = css;
                if (css) currentFragment.style = _this.convertCSSToProperties(
                    css, allowedProperties);
            }
        }
    };

    // Split summary format on formula alias prefix "#" and consider each substring a
    // potential formula alias. The "#X" alias form is attempted first then "#{ABC}".
    var splitFmt = exportField.userSummary.text.split("#"),
        braceRegexp = /^\{([A-Z]+)\}/;

    // If format started with literal text, add it to output
    if (splitFmt[0]) addToOutput(splitFmt[0], exportFieldCSS);
    for (var i=1; i<splitFmt.length; i++) {
        var fragment = splitFmt[i], braceRegexpMatch, matchField, matchKey, fieldValue,
            fieldCSS, textAfterField;

        matchKey = fragment.charAt(0);
        matchField = usedFields[matchKey];

        if (matchField) textAfterField = fragment.substr(1); // #X
        else if (braceRegexpMatch = fragment.match(braceRegexp)) {
            textAfterField = fragment.substr(braceRegexpMatch[0].length); // #{XXX}
            matchKey = braceRegexpMatch[1];
            matchField = usedFields[matchKey];

            // always assume #{..} is meant to be an alias, so fail this out
            if (!matchField) textAfterField = this.missingSummaryFieldValue + textAfterField;
        } else textAfterField = "#" + fragment; // possibly not an alias

        // If a field matched, get its value and style; merge style with summary-wide
        // style as appropriate
        if (matchField) {
            fieldValue = this.getExportFieldValue(record, matchField.name,
                this.getFieldNum(matchField.name));
            fieldCSS=null;
            if (exportFieldCSS) fieldCSS = (fieldCSS||"") + exportFieldCSS;
            if (usedFieldsCSS[matchKey]) fieldCSS = (fieldCSS||"") + usedFieldsCSS[matchKey];
        }
        // add possible fragments for formula alias and the literal text following it
        addToOutput(fieldValue, fieldCSS);
        addToOutput(textAfterField, exportFieldCSS);
    }
    // Above loop leaves last fragment not added to output: add it now
    if (currentFragment) detailedValue.push(currentFragment);

    exportObject[exportProp] = detailedValue;
},

getDeclarativeFormat : function(field) {
    return !field ? null : field.exportFormat || field.format;
},


//> @method dataBoundComponent.getClientExportData()
// Export visual description of component data into a JSON form suitable for export.
// @param settings (Object) contains configuration settings for the export, including:<br/>
//        includeHiddenFields (Boolean) - controls if hidden fields should be exported<br/>
//        allowedProperties (Array) optional array of CSS property names (camelCaps format)
//             constraining the allowed properties to be returned<br/>
//        includeCollapsedNodes (Boolean) - if true, when exporting a TreeGrid, include tree
//             nodes underneath collapsed folders in the export output<br/>
//        propagateInputHilites - controls whether to propagate hilites defined on inputs
//             of user summaries to the summaries themselves (unset means don't propagate)
// @param callback (Callback) callback to fire when data is ready
// @return exportData (Object) exported data
//<
// * Data is exported as an array of objects, with one object per record (visual row)
//   of the grid.
// * The name of each exported field of the component is mapped to a property
//   of a record's object. Correspondingly, the value of each exported field in a record is
//   mapped to each value of a record's object.
// * If CSS hiliting styles are present on a field, style information is stored in property
//   "<field name>$style". This contains an array of objects. Each object has a
//   'value' property containing a fragment or substring of the field value. If that
//   value fragment is styled, the CSS text is converted into an object mapping CSS
//   properties in camelCaps format to CSS values, and the object is stored in the 'style'
//   property.
// * Null record values are converted to empty strings.
//
// For instance, suppose a record has a field "Foo_Fighter" equal to 1 with a
// backgroundColor set through hiliting, a field "bar" set to "baz", a field
// "xyzzy" set to null, and a summary field with the format "#A -- #B", with
// #A referring to "Foo_Fighter" and #B referring to "bar". The return value would be:
//
// [
//     {
//         Foo_Fighter: "1",
//         Foo_Fighter$style:
//         [
//             {
//                 value: "1",
//                 style:
//                 {
//                     backgroundColor: "#f00000"
//                 }
//             }
//         ],
//         bar: "baz",
//         xyzzy: "",
//         summaryField1: "1 --- baz",
//         summaryField1$style:
//         [
//             {
//                 value: "1",
//                 style:
//                 {
//                     backgroundColor: "#f00000"
//                 }
//             },
//             {
//                 value: " --- baz"
//             }
//         ]
//     }, /* other records... */
// ]
exportDataChunkSize: 50,
getClientExportData : function (settings, callback) {
    var data = this.originalData || this.data,
        exportData = [],
        fields = this.getClientExportFields(settings),
        includeHiddenFields,
        allowedProperties,
        includeCollapsedNodes,
        alwaysExportExpandedStyles,
        exportFieldsSpecified = settings && settings.exportFields
    ;

    if (settings == null) settings = {};

    if (settings.exportData != null) data = settings.exportData;

    includeHiddenFields = settings.includeHiddenFields;
    allowedProperties = settings.allowedProperties;
    includeCollapsedNodes = settings.includeCollapsedNodes;
    alwaysExportExpandedStyles = settings.alwaysExportExpandedStyles;
    // support export fields as per server-side export
    if (exportFieldsSpecified) {
        // when exportFields is specified and unless includeHiddenFields is explicitly set to
        // false, assume that the user actually wants to see the fields that he provided via
        // exportFields.
        if (includeHiddenFields !== false) includeHiddenFields = true;
    }


    if (isc.isA.ResultSet(data)) data = data.getAllLoadedRows();
    if (isc.isA.Tree(data)) {
        if (includeCollapsedNodes) data = data.getAllNodes();
        else data = data.getOpenList();
    }

    var context = {
        settings: settings,
        callback: callback,
        chunkSize: this.exportDataChunkSize,
        data: data,
        exportData: exportData,
        fields: fields,
        includeHiddenFields: includeHiddenFields,
        allowedProperties: allowedProperties,
        includeCollapsedNodes: includeCollapsedNodes,
        alwaysExportExpandedStyles: alwaysExportExpandedStyles,
        totalRows: data.getLength(),
        startRow: 0,
        endRow: Math.min(this.exportDataChunkSize, data.getLength()),
        exportFieldsSpecified: exportFieldsSpecified
    };

    settings.exportRowBGColors = {};
    settings.exportColumnBGColors = {};

    context.firstTimeStamp = context.thisTimeStamp = isc.timeStamp();

    this.logInfo("starting export chunking process - "+context.firstTimeStamp, "export");
    this.getClientExportDataChunk(context);

    return;
},

getClientExportDataChunk : function (context) {
    var settings = context.settings,
        data = context.data,
        exportData = context.exportData,
        fields = context.fields,
        includeHiddenFields = context.includeHiddenFields,
        includeCollapsedNodes = context.includeCollapsedNodes,
        totalRows = context.totalRows,
        startRow = context.startRow,
        endRow = context.endRow,
        exportValueFields = settings.exportValueFields,
        exportFieldsSpecified = context.exportFieldsSpecified,
        exportRowBGColors = settings.exportRowBGColors,
        exportColumnBGColors = settings.exportColumnBGColors
    ;

    // Generate a separate object for each row of data
    for (var dataRow = startRow; dataRow < endRow; dataRow++) {
        var record = data[dataRow],

            exportObject = this.getRecordExportObject(record, fields, includeHiddenFields,
                includeCollapsedNodes, exportValueFields, exportFieldsSpecified, settings,
                dataRow);
        ;

        exportData.push(exportObject);

        // Get background color explicitly defined by component for row
        var rowColor = this.getExportRowBGColor(dataRow, record);
        if (rowColor) {
            exportRowBGColors[dataRow] = rowColor;
        }

    }

    // Iterate through all fields, again
    for (var fieldIndex = 0; fieldIndex < fields.length; fieldIndex++) {
        var field = fields[fieldIndex];

        // Skip field if it's hidden, again
        if ((!this.fields.contains(field)) && !includeHiddenFields) continue;
        var fieldNum = this.getFieldNum(field.name);

        // Set background colors explicitly defined by component for column
        var columnColor = this.getExportColumnBGColor(fieldNum);
        if (columnColor) {
            exportColumnBGColors[fieldNum] = columnColor;
        }
    }

    if (context.endRow < context.totalRows) {
        context.lastTimeStamp = context.thisTimeStamp;
        context.thisTimeStamp = isc.timeStamp();
        if (this.logIsInfoEnabled("export")) {
            this.logInfo("processed "+context.endRow+" rows - starting next chunk - "+
                ((context.thisTimeStamp-context.lastTimeStamp)/1000), "export");
        }
        // more rows remain - delayCall() this method again to process the next chunk
        context.startRow = context.endRow;
        context.endRow = Math.min(context.startRow + context.chunkSize, context.totalRows);
        return this.delayCall("getClientExportDataChunk", [context], 0);
    }

    if (this.showGridSummary && this.summaryRow && this.exportIncludeSummaries) {
        // append the summaries for this component if it has them
        var summaryRow = this.summaryRow,
            data = this.getGridSummaryData(true)
        ;

        for (var dataRow = 0; dataRow < data.getLength(); dataRow++) {
            var record = data[dataRow],
                exportObject = this.getRecordExportObject(record, fields, includeHiddenFields,
                    includeCollapsedNodes, exportValueFields, exportFieldsSpecified, settings,
                    dataRow);
            ;

            exportData.push(exportObject);
        }
    }

    if (context.callback) {
        var data = context.exportData;
        if (this.logIsInfoEnabled("export")) {
            this.logInfo("finished processing "+context.endRow+
                " rows - about to export - "+isc.timestamp(), "export");
        }
        this.fireCallback(context.callback, "data,context", [data,context.settings]);
    }
},

getClientExportFields : function (settings) {
    var fields = this.getAllFields();

    // support export fields as per server-side export
    var newFields = [],
        i,
        fieldsLen = fields.length,
        field;
    if (isc.isAn.Object(settings) && settings.exportFields) {
        for (i = 0; i < fieldsLen; ++i) {
            field = fields[i];
            if (settings.exportFields.contains(field.name)) newFields.add(field);
        }
        fields = newFields;
    } else {
        for (i = 0; i < fieldsLen; ++i) {
            field = fields[i];
            if (this._canExportField(field)) {
                newFields[newFields.length] = field;
            }
        }
        fields = newFields;
    }

    return fields;
},
getRecordExportObject : function (record, fields, includeHiddenFields, includeCollapsedNodes,
                                  exportValueFields, exportFieldsSpecified, settings, rowNum)
{
    var exportObject = {};

    // Iterate through all fields
    for (var fieldIndex = 0; fieldIndex < fields.length; fieldIndex++) {
        var field = fields[fieldIndex];

        // Skip field if it's hidden
        if ((!this.fields.contains(field)) && !includeHiddenFields) continue;
        var fieldNum = this.getFieldNum(field.name),
            exportProp=field.name,
            styleProp=exportProp+"$style",
            value;

        if (field.exportRawValues || (this.exportRawValues && field.exportRawValues != false))
            value = record[field[this.fieldIdProperty]];
        else
            value = this.getExportFieldValue(record, field.name, fieldNum);

        //var value = this.getExportFieldValue(record, field.name, fieldNum);

        if (value == null || value == "&nbsp;") value = "";

        if (!exportFieldsSpecified) {
            if (exportValueFields) {
                if (field.displayField) {
                    var key = field.name;
                    if (key == exportProp) key += "_value";
                    exportObject[key] = record[field.name];
                }
            }
        }

        exportObject[exportProp] = value;
        this.addDetailedExportFieldValue(exportObject, styleProp, record, field, fieldNum,
                                         settings, rowNum);
    }
    return exportObject;
},
htmlUnescapeExportFieldTitle : function (fieldName) {
    return this.htmlUnescapeExportFieldValue(fieldName);
},
htmlUnescapeExportFieldValue : function (value) {
    // convert basic HTML like &nbsp; and <br> into normal text equivalents and escape all
    // other HTML
    if (isc.isA.String(value)) return value.unescapeHTML().replace(/<.*?>/g, isc.emptyString);
    return value;
},
// Takes a formatted value and, if hilites apply to the value, adds hilite styling via adding
// a surround <span> tag with a STYLE attribute.  Otherwise returns the value unchanged.
addHiliteSpan : function(record, field, value) {
    var fieldCss = this.getRecordHiliteCSSText(record, null, field);
    if (fieldCss) return "<span style=\"" + fieldCss + "\">" + value + "</span>";
    else return value;
},

// Get the "raw" value for a record/field.
// (Overridden by ListGrid)
// Used by FormulaBuilder
getRawValue : function (record, field) {
    if (!record || !field) return null;

    // Canvas._getFieldValue() tries the `dataPath` argument, then `field.dataPath`,
    // then `field.name` to find a non-null "dataPath" to use.  Using
    // `field.displayField` as the first argument only if `field.dataPath` is not set
    // means that `field.dataPath` overrides `field.displayField` and the latter overrides
    // `field.name`, when getting a value of a record.
    var dataPath = field.dataPath == null ? field.displayField
                                          : isc.Canvas._getDataPathFromField(field, this);

    return isc.Canvas._getFieldValue(dataPath, field, record, this);
},

// This is overridden by ListGrid / DetailViewer
// Used by formulaBuilder / TableView
// Default implementation just returns the raw value passed in.
getFormattedValue : function (record, fieldName, value) {
    return value;
},

fieldIsVisible : function (field) {
    return true;
},

getSpecifiedField : function (fieldName) {
    return this.getField(fieldName);
},

// Returns the formatted record/field value enclosed in any Hilite HTML.
// used in exportFieldValue dataPath as well as in the TileGrid.
getStandaloneFieldValue : function (record, fieldName, unformatted) {
    var field = this.getSpecifiedField(fieldName),
        value;

    if (!field) return;

    if      (field.userFormula) value = this.getFormulaFieldValue(field, record);
    else if (field.userSummary) value = this.getSummaryFieldValue(field, record);
    else {
        if (this._useDisplayFieldValue && this._useDisplayFieldValue(field)) {
            value = record[field.displayField];
        } else {
            value = this.getRawValue(record, fieldName);
        }
        if (!unformatted) value = this.getFormattedValue(record, fieldName, value);
    }

    var ret = this.addHiliteSpan(record, field, value);
    return ret;
},

// For client-driven exports (exportClientData()), if a date or datetime field is being
// formatted by a standard built-in formatter, send the raw Date value and the name of the
// built-in formatter to the server, as part of the $style information for the cell, like so:
//    independence:"Fri Jan 01 1238 12:00:00 GMT-0800 (Pacific Standard Time)",
//    independence$style:{
//        rawValue:new Date(-23099011200000),
//        dateFormatter:"toUSShortDate"
//    },
// This allows the server to generate a corresponding XLS/OOXML format for the
// spreadsheet cell, so that formatting is preserved, but Excel knows the value is a date and
// will offer appropriate features.

getDateFormattingProperties : function (field, value, formattedValue) {
    if (!isc.SimpleType.inheritsFrom(field.type, "date")) return;
    if (!isc.isA.Date(value)) return;

    var isDatetime = isc.SimpleType.inheritsFrom(field.type, "datetime");

    var dateFormatter;

    if (field.dateFormatter && isc.isA.Function(Date.prototype[field.dateFormatter])) {
        dateFormatter = field.dateFormatter;
    } else if (field.displayFormat && isc.isA.Function(Date.prototype[field.displayFormat])) {
        dateFormatter = field.displayFormat;
    }

    // Probably no need to check this because it should have been copied onto the LGF, but
    // it does no harm
    if (!dateFormatter) {
        var dataSource = this.getDataSource(),
            dsField = dataSource ? dataSource.getField(field.name) : null,
            dsFormat = dsField ? dsField.dateFormatter || dsField.displayFormat : null;
        if (dsFormat && isc.isA.Function(Date.prototype[dsFormat])) {
            dateFormatter = dsFormat;
        }
    }

    // Defaults from the DBC
    if (!dateFormatter) {
        var dbcFormat;
        if (this.datetimeFormatter != null && isDatetime) {
            dbcFormat = this.datetimeFormatter;
        } else {
            dbcFormat = this.dateFormatter;
        }
        if (dbcFormat && isc.isA.Function(Date.prototype[dbcFormat])) {
            dateFormatter = dbcFormat;
        }
    }


    // ListGrid defaults to the default short date or datetime formatter, not the "normal"
    // format
    if (!dateFormatter) {
        var shortFormat = !isDatetime ? Date.prototype._shortFormat
                                               : Date.prototype._shortDatetimeFormat;
        if (shortFormat && isc.isA.Function(Date.prototype[shortFormat])) {
            dateFormatter = shortFormat;
        }
    }

    var dateProps = {
        rawValue: value,
        dateFormatter: dateFormatter
    };

    return dateProps;
},

//> @groupDef exportBGColor
// Several APIs and settings influence the background color which will be used for spreadsheet
// cells when exporting to Excel/OpenOffice formats using +link{listGrid.exportData()} or
// +link{listGrid.exportClientData()}.  The following APIs are called in the order
// shown, so <code>hilite.backgroundColor</code> takes precedence over
// <code>exportDefaultBGColor</code>, for example.
// <ol>
// <li> +link{listGrid.getExportBGColor,getExportBGColor(rowNum, colNum, record)}
// <li> +link{hilite.backgroundColor}
// <li> +link{listGrid.getExportRowBGColor,getExportRowBGColor(rowNum, record)}
// <li> +link{listGrid.getExportColumnBGColor,getExportColumnBGColor(colNum)}
// <li> +link{listGrid.exportAlternateRowBGColor,exportAlternateRowBGColor}
// <li> +link{listGrid.exportDefaultBGColor,exportDefaultBGColor}
// </ol>
// If overriding any of the above methods, return null to allow methods later in the precedence
// order to influence background color.  For example, if you want certain rows to have a
// special background color but also want to show alternating colors per row, override
// getExportRowBGColor and return null for all rows that should just show normal alternating
// colors, and not a special color.
//
// @title Exports &amp; Cell Background Color
// @visibility external
//<

//> @attr listGrid.exportDefaultBGColor (CSSColor : null : IR)
// Default background color to use when exporting data to Excel/OpenOffice format using
// +link{exportData(),exportData()} or
// +link{exportClientData(),exportClientData()}.
// <p>
// If unset (the default), cells that are not provided a background color by more specific APIs
// will be the default background color used by the spreadsheet program where they are viewed.
// <p>
// See +link{group:exportBGColor} for an overview.
// @group exportBackgroundColor
// @visibility external
//<

//> @attr listGrid.exportAlternateRowBGColor (CSSColor : null : IR)
// When exporting data to Excel/OpenOffice format using +link{exportData(),exportData()} or
// +link{exportClientData(),exportClientData()}, background color to use
// for even-numbered rows, to create a "banded" or "ledger" effect.  Odd-numbered rows will
// use the +link{exportDefaultBGColor}.
// <p>
// See +link{group:exportBGColor} for an overview.
// @group exportBackgroundColor
// @visibility external
//<

//> @method listGrid.getExportBGColor()
// When exporting data to Excel/OpenOffice format using +link{exportData(),exportData()} or
// +link{exportClientData(),exportClientData()}, background color to use
// for the cell at the given rowNum and colNum.
// <p>
// See +link{group:exportBGColor} for an overview.
//
// @param rowNum (int) row number of cell
// @param colNum (int) column number of cell
// @param record (Record) the record object behind the row being exported
// @return (CSSColor) background color to use for the cell, or null to use the default
//                    background color
//
// @group exportBackgroundColor
// @visibility external
//<
getExportBGColor: function (rowNum, colNum, record) {
    return null;
},

//> @method listGrid.getExportRowBGColor()
// When exporting data to Excel/OpenOffice format using +link{exportData(),exportData()} or
// +link{exportClientData(),exportClientData()}, background color to use
// for the given rowNum.
// <p>
// See +link{group:exportBGColor} for an overview.
//
// @param rowNum (int) row number
// @param record (Record) the record object behind the row being exported
// @return (CSSColor) background color to use for the row, or null to use the default
//                    background color
//
// @group exportBackgroundColor
// @visibility external
//<
getExportRowBGColor: function (rowNum, record) {
    return null;
},

//> @method listGrid.getExportColumnBGColor()
// When exporting data to Excel/OpenOffice format using +link{exportData(),exportData()} or
// +link{exportClientData(),exportClientData()}, background color to use
// for the given colNum.
// <p>
// See +link{group:exportBGColor} for an overview.
//
// @param colNum (int) column number
// @return (CSSColor) background color to use for the column, or null to use the default
//                    background color
//
// @group exportBackgroundColor
// @visibility external
//<
getExportColumnBGColor: function (colNum) {
    return null;
},

//> @attr listGrid.exportHeaderHeights (boolean : false : IRW)
// When exporting data to Excel/OpenOffice format using +link{exportData()} or
// +link{exportClientData()}, causes the +link{listGrid.headerHeight} and
// +link{headerSpan.height,headerSpan heights} to be applied to the corresponding cells in the
// spreadsheet.
//
// @visibility external
//<

//> @attr listGrid.exportFieldWidths (boolean : false : IRW)
// When exporting data to Excel/OpenOffice format using +link{exportData()} or
// +link{exportClientData()}, whether widths of fields should be replicated
// in the resulting spreadsheet.
// <p>
// Because Excel's unit of measurement for field widths is based on the default system font,
// there is no exact way to translate field widths in pixels to Excel column widths.  The
// +link{exportWidthScale} property can be set to adjust scaling; it's default value errs on
// the side of making Excel's columns slightly wider than the ListGrid field's actual width to
// avoid clipping.
// <p>
// Note that you can switch off width export for individual fields with the
// +link{listGridField.exportFieldWidth} flag.
//
// @visibility external
//<

//> @attr listGridField.exportFieldWidth (boolean : true : IRW)
// When exporting data to Excel/OpenOffice format using +link{listGrid.exportData()} or
// +link{listGrid.exportClientData()} with +link{listGrid.exportFieldWidths} set,
// set this flag false to cause this field to "opt out" of width export.  Fields that opt out
// in this way have the corresponding spreadsheet column autosized (ie, made just wide enough
// that content is not clipped).
// <p>
// This setting has no effect if <code>listGrid.exportFieldWidths</code> is not set.
//
// @visibility external
//<

//> @attr listGrid.exportWidthScale (float : 0.12 : IRW)
// Scaling factor to translate from ListGrid field widths in pixels to Excel/OpenOffice units
// for field width, which are 1/256th of the width of the widest digit character in the default
// font for the spreadsheet.  See +link{exportFieldWidths} for where this is used.
//
// @visibility external
//<
exportWidthScale : 0.12,

//> @attr listGrid.exportWrapHeaderTitles (boolean : false : IRW)
// When exporting data to Excel/OpenOffice format using +link{exportData()} or
// +link{exportClientData()}, whether titles in the
// +link{listGrid.header,ListGrid header} and +link{listGrid.headerSpans,headerSpans} should be
// allowed to wrap.
// <p>
// Excel will wrap at the column boundary automatically; for explicit control over wrapping,
// insert "<br>" tags into your titles.
// <p>
// See also +link{exportFieldWidths} for replicating the widths of fields in the exported
// spreadsheet.
//
// @visibility external
//<

//> @attr listGrid.exportFieldAlignments (boolean : false : IRW)
// When exporting data to Excel/OpenOffice format using +link{exportData()} or
// +link{exportClientData()}, whether field
// +link{listGridField.align,horizontal header alignments} and
// +link{listGridField.cellAlign,data value alignments} should be replicated in the resulting
// spreadsheet.
// <p>
// If this attribute is not set, cells will be assigned a default alignment by the spreadsheet,
// which is typically right-aligned for numeric and date values, and left-aligned for
// everything else (including dates and numbers that have been exported as strings, as would
// be the case, for example, if +link{dsRequest.exportDatesAsFormattedString} is set)
//
// @visibility external
//<




//> @method listGrid.exportClientData()
// Exports this component's data with client-side formatters applied, so is suitable for direct
// display to users.  This feature requires the SmartClient server.
// <P>
// Ordinarily, calls to this method go through the static classMethod
// +link{classMethod:DataSource.exportClientData}.  In this case, no server-side DataSources
// are required.  However, if this component is
// +link{DataBoundComponent.setDataSource(),databound} and you specify a valid
// +link{dsRequest.operationId,operationId} in the properties passed to this method, the call
// will go through the instance method +link{dataSource.exportClientData} instead.  As the
// documentation for that method explains, this allows you more control on the server side.
// This approach requires both the SmartClient server and server-side DataSource definitions.
// <P>
// If your ListGrid has custom formatters, formatted values will be exported by default, with
// HTML normalized to text where possible.  Since some levels of HTML normalizing aren't
// possible, this may result in missing or incorrect export values.  In this case, you have
// two options:<ul>
// <li>Set +link{listGridField.exportRawValues,exportRawValues} on the field.  This will export
//     the raw underlying value of the field; your formatter will not be called</li>
// <li>Have your formatter call +link{listGrid.isExportingClientData(),isExportingClientData()}
//     and perform whatever alternative formatting you require if that method returns true</li>
// </ul>
// <P>
// To export data from this component's dataSource,
// see +link{dataBoundComponent.exportData, exportData}, which does not include client-side
// formatters, but <b>does</b> include formatters declared in the <code>.ds.xml</code> file.
// <code>exportData()</code> relies on both the SmartClient server and server-side DataSources.
// @param [requestProperties] (DSRequest Properties) Request properties for the export.
//  Note that specifying +link{DSRequest.exportData,exportData} on the request properties
//  allows the developer to pass in an explicit data set to export.
// @param [callback] (RPCCallback) Optional callback.  If
//  you specify +link{DSRequest.exportToClient,exportToClient}: false in the request
//  properties, this callback will fire after export completes.  Otherwise the callback will
//  fire right before the download request is made to the server.
// @see dataSource.exportClientData
// @visibility external
//<
exportClientData : function (requestProperties, callback) {
    this._exportingClientData = true;
    if (callback) requestProperties.__callback = callback;
    this.getClientExportData(requestProperties,
        this.getID()+".exportClientDataReply(data,context)");
    return;
},

//>    @method listGrid.isExportingClientData()
// Returns true if this component is currently
// +link{listGrid.exportClientData(), exporting client data}.  This method can be called from
// custom cell formatters if you need to return a different formatted value for an export
// than for a live ListGrid
// @return (boolean)  returns true if this component is currently exporting client data
// @see listGrid.exportClientData
// @visibility external
//<
_exportingClientData: false,
isExportingClientData : function() {
    return !!this._exportingClientData;
},

//>    @method treeGrid.exportClientData()
// Exports this component's data with client-side formatters applied, so is suitable for direct
// display to users.  See +link{listGrid.exportClientData()} for details of the general
// requirements and restrictions when exporting client data.
// <p>
// The following notes apply when exporting client data from TreeGrids:<ul>
// <li>Export only works correctly if you specify +link{fields,fields}; if you allow it to
//     generate a +link{createDefaultTreeField,default field}, nothing will be exported</li>
// <li>Only visible nodes are exported; if you close a node, its children are not exported
//     even if they are loaded and known to the client</li>
// <li>Tree nodes are exported as a flat list, in the same order they are displayed in the
//     TreeGrid</li>
// </ul>
// <P>
// If your TreeGrid has custom formatters, formatted values will be exported by default, with
// HTML normalized to text where possible.  Since some levels of HTML normalizing aren't
// possible, this may result in missing or incorrect export values.  In this case, you have
// two possible approaches:<ul>
// <li>Set +link{listGridField.exportRawValues,exportRawValues} on the field.  This will export
//     the raw underlying value of the field; your formatter will not be called</li>
// <li>Have your formatter call +link{treeGrid.isExportingClientData(),isExportingClientData()}
//     and perform whatever alternative formatting you require if that method returns true</li>
// </ul>
// @param [requestProperties] (DSRequest Properties) Request properties for the export.
//  Note that specifying +link{DSRequest.exportData,exportData} on the request properties
//  allows the developer to pass in an explicit data set to export.
// @param [callback] (RPCCallback) Optional callback.  If
//  you specify +link{DSRequest.exportToClient,exportToClient}: false in the request
//  properties, this callback will fire after export completes.  Otherwise the callback will
//  fire right before the download request is made to the server.
// @see listGrid.exportClientData
// @visibility external
//<

//>    @method treeGrid.isExportingClientData()
// Returns true if this component is currently
// +link{treeGrid.exportClientData(), exporting client data}.  This method can be called from
// custom cell formatters if you need to return a different formatted value for an export
// than for a live TreeGrid
// @return (boolean)  returns true if this component is currently exporting client data
// @see treeGrid.exportClientData
// @visibility external
//<

//>    @method detailViewer.exportClientData()
// Exports this component's data with client-side formatters applied, so is suitable for direct
// display to users.  See +link{listGrid.exportClientData()} for details of the general
// requirements and restrictions when exporting client data.
// <p>
// The following notes apply when exporting client data from DetailViewers:<ul>
// <li>Data is exported in "grid" format, with each record shown in a single row and each
//     column representing a single field. This is quite different from the way DetailViewers
//     display records in the browser</li>
// </ul>
// <P>
// If your detailViewer has custom formatters, formatted values will be exported by default, with
// HTML normalized to text where possible.  Since some levels of HTML normalizing aren't
// possible, this may result in missing or incorrect export values.  In this case, you have
// two possible approaches:<ul>
// <li>Set +link{detailViewerField.exportRawValues,exportRawValues} on the field.  This will export
//     the raw underlying value of the field; your formatter will not be called</li>
// <li>Have your formatter call +link{detailViewer.isExportingClientData(),isExportingClientData()}
//     and perform whatever alternative formatting you require if that method returns true</li>
// </ul>
// @param [requestProperties] (DSRequest Properties) Request properties for the export.
//  Note that specifying +link{DSRequest.exportData,exportData} on the request properties
//  allows the developer to pass in an explicit data set to export.
// @param [callback] (RPCCallback) Optional callback.  If
//  you specify +link{DSRequest.exportToClient,exportToClient}: false in the request
//  properties, this callback will fire after export completes.  Otherwise the callback will
//  fire right before the download request is made to the server.
// @see listGrid.exportClientData
// @visibility external
//<


//>    @method detailViewer.isExportingClientData()
// Returns true if this component is currently
// +link{detailViewer.exportClientData(), exporting client data}.  This method can be called from
// custom cell formatters if you need to return a different formatted value for an export
// than for a live detailViewer
// @return (boolean)  returns true if this component is currently exporting client data
// @see listGrid.exportClientData
// @visibility external
//<

//> @attr dataBoundComponent.emptyExportMessage (string : "You are attempting to export an empty dataset" : [IRW])
// The message to display to the user if an export of a DataBoundComponent's data is attempted
// while the DataBoundComponent's data is null or an empty list.
// @see listGrid.exportClientData
// @group i18nMessages
// @visibility external
//<
emptyExportMessage: "You are attempting to export an empty dataset",


defaultExportAs:"csv",
defaultExportFilename:"export",
defaultExportDisplay:"download",

exportClientDataReply : function (data, context) {

    if (data == null || data.length == 0) {
        // if there's no client-data to export, show a dialog and bail
        isc.warn(this.emptyExportMessage);
        return;
    }

    var props = context || {},
        format = props.exportAs ? props.exportAs : this.defaultExportAs,
        fileName = props.exportFilename ? props.exportFilename : this.defaultExportFilename,
        exportDisplay = props.exportDisplay ? props.exportDisplay : this.defaultExportDisplay,
        downloadToNewWindow = props.downloadToNewWindow == null
                            ? (exportDisplay == "window") : props.downloadToNewWindow
    ;

    var serverProps = {
        operationId: props.operationId,
        showPrompt:false,
        transport: props.exportToClient === false ? "xmlHttpRequest" : "hiddenFrame",
        exportResults: true,
        downloadResult: !(props.exportToClient === false),
        download_filename: (exportDisplay == "window" ? fileName : null),
        params:props.params,
        xmlHttpRequestResponseType:props.xmlHttpRequestResponseType
    };

    if (props.exportRawValues == null) {
        props.exportRawValues = false;
    }

    var settings = {

        targetMainWindow: props.targetMainWindow,
        downloadToNewWindow: downloadToNewWindow,

        exportDisplay: props.exportDisplay,
        exportAs: props.exportAs,
        exportToClient: props.exportToClient,
        exportToFilesystem: props.exportToFilesystem,
        exportPath: props.exportPath,
        exportFilename: fileName,
        exportDelimiter: props.exportDelimiter,
        exportHeader: props.exportHeader,
        exportHeaderless: props.exportHeaderless,
        exportFooter: props.exportFooter,
        exportDefaultBGColor: props.exportDefaultBGColor,
        exportAlternateRowBGColor: props.exportAlternateRowBGColor,
        exportRowBGColors: props.exportRowBGColors,
        exportColumnBGColors: props.exportColumnBGColors,
        exportWrapHeaderTitles: props.exportWrapHeaderTitles,
        exportTitleSeparatorChar: props.exportTitleSeparatorChar,
        exportSpanTitleSeparator: props.exportSpanTitleSeparator,
        exportShowHeaderSpanTitles: props.exportShowHeaderSpanTitles,
        exportValueFields: props.exportValueFields,
        lineBreakStyle: props.lineBreakStyle,
        exportDatesAsFormattedString: props.exportDatesAsFormattedString,
        exportHeaderBGColor: props.exportHeaderBGColor,
        exportHeaderTextColor: props.exportHeaderTextColor,
        exportRawValues: props.exportRawValues,
        exportStreaming: props.exportStreaming,
        exportCurrencySymbol: isc.NumberUtil.currencySymbol,
        params:props.params
    };


    var exportFields = data._exportFields,
        exportTitles = data._exportTitles;

    if (exportFields == null) {
        // call getClientExportFields() to pick up fields from this component if necessary
        // (omitting canExport:false fields as appropriate).  This method already handles the
        // fields being defined on the "props" block directly.  Apply these explicitly to the
        // "settings" block so the server doesn't attempt to look at dataSource fields.
        exportFields = this.getClientExportFields(props);
        // Convert to strings
        for (var i = 0; i < exportFields.length; i ++) {
            if (isc.isAn.Object(exportFields[i])) exportFields[i] = exportFields[i].name
        }
        // validate that each field actually exists on the DBC

        var validExportFields = [];
        for (var i = 0; i < exportFields.length; ++i) {
            if (this.getField(exportFields[i]) != null) {
                validExportFields.add(exportFields[i]);
            }
            if (settings.exportValueFields && this.getField(exportFields[i]).displayField) {
                validExportFields.add(exportFields[i] + "_value");
            }
        }
        exportFields = validExportFields;
    }
    settings.exportFields = exportFields;

    var allFields = this.getAllFields();

    var formulaFields = [];
    for (var i = 0; i < allFields.length; ++i) {
        var field = allFields[i];
        if (field.userFormula != null) {
            formulaFields[formulaFields.length] = field.userFormula;
            formulaFields[formulaFields.length - 1].name = field.name;
            formulaFields[formulaFields.length - 1].title = field.title;
        }
    }

    if (formulaFields.length > 0) {
        var formulaRemap = [];
        for (var u = 0; u < allFields.length; ++u) {
            formulaRemap[u] = {
                name: allFields[u].name,
                title: allFields[u].title
            };
        }
        settings.formulaFields = formulaFields;
        settings.formulaRemap = formulaRemap;
    }

    if (exportTitles == null) {
        // header spans
        var exportTitles = {};
        if (this.headerSpans && props.exportShowHeaderSpanTitles !== false) {
            settings.exportHeaderSpans =
                this.prepareHeaderSpansForExport(this.headerSpans, allFields, exportTitles);
        }

        // non-spanned fields
        if (exportFields) {
            // `exportOtherFields' is passed to the server so that it knows what titles to use
            // for non-spanned fields.
            settings.exportOtherFields = {};
            for (var i = 0; i < exportFields.length; ++i) {
                var fieldName = exportFields[i];
                if (!exportTitles.hasOwnProperty(fieldName)) {
                    var field = this.getField(fieldName);
                    settings.exportOtherFields[fieldName] =
                        this.htmlUnescapeExportFieldTitle(field == null ? fieldName :
                                              field.exportTitle || field.title || field.name);
                }
            }
        }
    } else {
        settings.exportOtherFields = exportTitles;
    }

    settings.exportDefaultBGColor = this.exportDefaultBGColor;
    settings.exportAlternateRowBGColor = this.exportAlternateRowBGColor;
    if (isc.isA.Function(this.getExportRowBGColors)) {
        settings.exportRowBGColors = this.getExportRowBGColors();
    }
    if (isc.isA.Function(this.getExportColumnBGColors)) {
        settings.exportColumnBGColors = this.getExportColumnBGColors();
    }

    if (this.headerHeight && this.exportHeaderHeights) {
        settings.exportHeaderHeight = this.headerHeight;
    }

    if (this.exportFieldWidths && isc.isAn.Array(this.fields) && this.getFieldWidth) {
        settings.exportFieldPixelWidths = this.getFieldPixelWidths();
        settings.exportWidthScale = this.exportWidthScale;
    }


    if (settings.exportWrapHeaderTitles == null) {
        settings.exportWrapHeaderTitles = this.exportWrapHeaderTitles;
    }

    if (this.exportFieldAlignments && isc.isAn.Array(this.fields)) {
        settings.exportAlignments = this.getFieldAlignments();
    }

    if (props.exportPropertyIdentifier) {
        settings.exportPropertyIdentifier = props.exportPropertyIdentifier;
    }


    if (this.getDataSource()) {
        isc.addProperties(serverProps, {exportContext: settings});
        this.getDataSource().exportClientData(data, serverProps, context.__callback);
    } else {
        isc.DMI.callBuiltin({
            methodName: "downloadClientExport",
            arguments: [ data, format, fileName, exportDisplay, settings ],
            requestParams: serverProps,
            callback: context.__callback
        });
    }

    delete this._exportingClientData;

    // can't fire callback on the DMI response because it's a download - fire now instead
    if (context.__callback && serverProps.downloadResult) this.fireCallback(context.__callback);
},

prepareHeaderSpansForExport : function (spans, fields, exportTitles) {
    exportTitles = exportTitles || {};
    var output = [];
    for (var i = 0; i < spans.length; i++) {
        var spanExportTitle = spans[i].exportTitle || spans[i].title || isc.emptyString;
        output[i] = {title: this.htmlUnescapeExportFieldTitle(spanExportTitle)};
        if (spans[i].height != null) {
            output[i].height = spans[i].height;
        }
        if (spans[i].spans) {
            output[i].spans = this.prepareHeaderSpansForExport(spans[i].spans, fields, exportTitles);
        } else {
            output[i].fields = [];
            for (var j = 0; j < spans[i].fields.length; j++) {
                var fieldName = spans[i].fields[j],
                    field = fields.find("name", fieldName);
                // field not present or hidden
                if (!field || this.getFieldNum(fieldName) == -1) continue;
                var fieldTitle = field.exportTitle || field.title || field.name;

                if (fieldTitle) {
                    var escapedTitle = this.htmlUnescapeExportFieldTitle(fieldTitle);
                    output[i].fields.push({
                        name: fieldName,
                        title: escapedTitle
                    });
                    exportTitles[fieldName] = escapedTitle;
                }
            }
        }
    }
    return output;
},

//> @method dataBoundComponent.getSort()
// Return the +link{SortSpecifier}s representing the current sort configuration of this
// component.
// @return sortSpecifiers (Array of SortSpecifier) The current sort specification for this component
// @visibility external
//<
getSort : function () {
    return this._sortSpecifiers ? this.removeSortSpecifierMarkers(isc.shallowClone(this._sortSpecifiers)) : null;
},
// remove internal scribbles such as 'context', 'sortIndex', etc
removeSortSpecifierMarkers : function (sortSpecifiers) {
   if (sortSpecifiers == null) return null;
   sortSpecifiers.clearProperty("context");
   sortSpecifiers.clearProperty("sortIndex");
   return sortSpecifiers;
},

//> @method dataBoundComponent.setSort()
// Sort this component by a list of +link{SortSpecifier}s.  If the component's data is not a
// +link{ResultSet}, only the first specifier is applied.
//
// @param sortSpecifiers (Array of SortSpecifier)  List of +link{SortSpecifier} objects, one
//   per sort-field and direction
// @visibility external
//<
setSort : function (sortSpecifiers) {
    this._sortSpecifiers = isc.shallowClone(sortSpecifiers);
    if (this.data && this._sortSpecifiers && this._sortSpecifiers.length>0) {
        for (var i = 0; i < this._sortSpecifiers.length; i++) {
            var item = this._sortSpecifiers[i];
            if (!item.context) item.context = this;
        }
        if (this.data.setSort) this.data.setSort(this._sortSpecifiers);
        else if (this.data.sortByProperty) {
            var item = this._sortSpecifiers[0];
            this.data.sortByProperty(
                item.property,
                Array.shouldSortAscending(item.direction),
                item.normalizer,
                item.context
            );
        }
    }
},

//> @attr dataBoundComponent.multiSortDialogProperties (MultiSortDialog Properties : null : IR)
// Properties to apply to the +link{MultiSortDialog} which gets automatically generated
// when +link{dataBoundComponent.askForSort()} is called.
// <P>
// See also +link{listGrid.showHeaderSpanTitlesInSortEditor} and +link{listGrid.sortEditorSpanTitleSeparator}
//
// @visibility external
//<

//> @attr dataBoundComponent.multiSortDialogDefaults (MultiSortDialog Properties : null : IR)
// Class level defaults to apply to the +link{MultiSortDialog} which gets automatically
// generated when +link{dataBoundComponent.askForSort()} is called.
// <P>
// See also +link{listGrid.showHeaderSpanTitlesInSortEditor} and +link{listGrid.sortEditorSpanTitleSeparator}
//
// @visibility external
//<


//> @method dataBoundComponent.askForSort()
// Show a dialog to configure the sorting of multiple fields on this component.  Calls through
// to +link{MultiSortDialog.askForSort()}, passing this component as the fieldSource and the
// current +link{dataBoundComponent.getSort, sort-specification} if there is one.
// <P>
// The generated multiSortDialog can be customized via +link{multiSortDialogDefaults},
// +link{multiSortDialogProperties}.
//
// @visibility external
//<
askForSort : function (fieldName) {
    if (isc.MultiSortDialog && this.canMultiSort != false) {
        var sortSpecifiers = this.getSort();
        if (fieldName && (!sortSpecifiers || sortSpecifiers.length == 0)) {
            sortSpecifiers = [{ property: fieldName, direction: "ascending" }];
        }
        isc.MultiSortDialog.askForSort(
            this,
            sortSpecifiers,
            {target:this, methodName:"multiSortReply"},
            isc.addProperties({},
                this.multiSortDialogDefaults,
                this.multiSortDialogProperties)
        );
    }
},
multiSortReply : function (sortLevels) {
    if (sortLevels != null) {
        this.setSort(sortLevels);
    }
},

askForGrouping : function () {
    var groupFields = this.getGroupByFields();
    isc.MultiGroupDialog.askForGrouping(this, groupFields, this.getID()+".multiGroupReply(groupLevels)");
},
multiGroupReply : function (groupLevels) {
     if (groupLevels) this.groupBy(groupLevels);
},


editCriteria : function () {
    var filterBuilder = isc.FilterBuilder.create({
        dataSource:this.dataSource,
        criteria: this.data && this.data.getCriteria ? this.data.getCriteria() : this.initialCriteria
    });
    var _this = this;
    var theWindow = isc.Window.create({
        autoDraw:true,
        autoSize:true, width:600,
        autoCenter:true, isModal:true,
        title:"Define Filter",
        bodyProperties : { layoutMargin:5, membersMargin:5 },
        items : [
            isc.HTMLFlow.create({
                width:"100%",
                isGroup:true,
                groupTitle:"Instructions",
                padding:5,
                contents:"Define field by field filter criteria below"
            }),
            filterBuilder,
            isc.IButton.create({
                title:"Save",
                click : function () {
                    var criteria = filterBuilder.getCriteria();
                    _this.editCriteriaReply(criteria);
                    this.parentElement.parentElement.closeClick();
                }
            })
        ]
    });
},
editCriteriaReply : function (criteria) {
    this.setCriteria(criteria);
},

//> @method dataBoundComponent.addValidationError()  (A)
// Helper method to add a validation error (or array of errors) to a list of existing errors
// (passed in).
// Avoids duplicating errors.
// @group validation
//
// @param errors       (object)  current set of errors
//                               {itemName:"error", itemName:["error 1", "error 2"]}
// @param itemName     (string)  name of the item that has the error
// @param errorMessage (string)  actual error message
//
// @return (boolean)  returns true if error is not a duplicate
// @visibility internal
//<
// Not intended for public use - this is for directly updating an errors object.
addValidationError : function (errors, itemName, errorMessage) {
    var addedError = false;

    if (isc.isAn.Array(errorMessage)) {
        for (var i = 0; i < errorMessage.length; i++) {
            addedError = this.addValidationError(errors, itemName, errorMessage[i]) || addedError;
        }
        return addedError;
    }

    var isDataPath = itemName.contains(this._$slash);
    if (isDataPath) {
        var work = errors,
            elements = itemName.trim(this._$slash).split();
        for (var i = 0; i < elements.length; i++) {
            if (!work[elements[i]]) {
                if (i < elements.length - 1) {
                    if (parseInt(elements[i+1]) == elements[i+1]) {
                        work[elements[i]] = [];
                    } else {
                        work[elements[i]] = {};
                    }
                } else {
                    work[elements[i]] = errorMessage;
                    addedError = true;
                }
            }
            work = work[elements[i]];
        }
    } else {
        if (!errors[itemName]) {
            errors[itemName] = errorMessage;
            addedError = true;
        } else {
            if (!isc.isAn.Array(errors[itemName])) errors[itemName] = [errors[itemName]];

            if (!errors[itemName].contains(errorMessage)) {
                errors[itemName].add(errorMessage);
                addedError = true;
            }
        }
    }
    // Let caller know if we saved a new error message
    return addedError;
},

// Is <field> dependent on <fieldName>?
isFieldDependentOnOtherField : function (field, fieldName) {
    if (!field.validators) return false;

    var ds = this.getDataSource();

    for (var i = 0; i < field.validators.length; i++) {
        var validator = field.validators[i];
        if (!validator) continue;

        // Cache derived dependencies, if any.
        // Cannot derive dependencies unless we have a data source.
        if (!validator._derivedDependentFields && validator.applyWhen && ds != null) {
            validator._derivedDependentFields = ds.getCriteriaFields (validator.applyWhen);
        }

        // Explicit dependency?
        if (validator.dependentFields && validator.dependentFields.contains(fieldName)) {
            return true;
        }
        // ApplyWhen dependency?
        if (validator._derivedDependentFields &&
            validator._derivedDependentFields.length > 0 &&
            validator._derivedDependentFields.contains(fieldName))
        {
            return true;
        }
    }
    return false;
},

// Return dependencies for field (i.e. what fields it is dependent on)
getFieldDependencies : function (field) {
    if (!field.validators) return null;

    var ds = this.getDataSource(),
        dependencies = []
    ;

    for (var i = 0; i < field.validators.length; i++) {
        var validator = field.validators[i];
        if (!validator) continue;

        // Cache derived dependencies, if any.
        // Cannot derive dependencies unless we have a data source.
        if (!validator._derivedDependentFields && validator.applyWhen && ds != null) {
            validator._derivedDependentFields = ds.getCriteriaFields (validator.applyWhen);
        }

        // Explicit dependencies
        if (validator.dependentFields) {
            if (!isc.isAn.Array(validator.dependentFields)) {
                validator.dependentFields = [validator.dependentFields];
            }
            for (var j = 0; j < validator.dependentFields.length; j++) {
                dependencies.add(validator.dependentFields[j]);
            }
        }

        // ApplyWhen dependencies
        if (validator._derivedDependentFields &&
            validator._derivedDependentFields.length > 0)
        {
            dependencies.addList (validator._derivedDependentFields);
        }
    }
    return (dependencies.length == 0 ? null : dependencies);
},


//> @method dataBoundComponent.validateFieldAndDependencies() (A)
// Validate the field value against any validators defined on the field
// where validateOnChange is true and validate any fields that are dependent
// on the field.
//
// @param  field      (object)    pointer to the field descriptor object
// @param  validators (array)     Validators to be applied to field
// @param  newValue   (any)       value to be validated
// @param  record     (object)    copy of the record object
// @param  options    (object)    options object to control the validation process
//                  in the format {dontValidateNullValue: true/false,
//                                 typeValidationsOnly: true/false,
//                                 unknownErrorMessage: value or null,
//                                 changing: true/false,
//                                 serverValidationMode: "full"/"partial"}
// @return (object) null if no validation was performed, or validation result object
//                  in the format {valid: true/false,
//                                 errors: null or {fieldName: ["error", ...], ...}
//                                 resultingValue: value or null,
//                                 stopOnError: true/false}
//                  Note that if a dependent field has no errors an entry in the errors
//                  object will still exist but be null. This lets the caller know the
//                  field was validated and it is valid.
//<

validateFieldAndDependencies : function (field, validators, newValue, record, options) {

    var errors = {},
        validated = false,
        result = {valid: true,
                  errors: null,
                  resultingValue: null}
    ;

    // Apply newValue to record so that dependencies can reference it
    // If a validator changes newValue, the new value will overwrite this one.
    record[field.name] = newValue;

    // Process all validators for this field
    var fieldResult = this.validateField(field, field.validators, newValue, record, options);
    if (fieldResult != null) {
        result.valid = fieldResult.valid;
        result.stopOnError = fieldResult.stopOnError;
        if (fieldResult.errors != null) {
            this.addValidationError (errors, field.name||field.dataPath, fieldResult.errors);
        }
        if (fieldResult.resultingValue != null) {
            result.resultingValue = fieldResult.resultingValue;
            record[field.name] = fieldResult.resultingValue;
        }
        validated = true;
    }

    // Validate other fields that are dependent on this one.

    var fieldName = field.name || field.dataPath,
        fields = this.getFields() || []
    ;

    for (var i = 0; i < fields.length; i++) {

        var depField = fields[i];
        if (depField.name != fieldName  && depField.dataPath != fieldName &&
            this.isFieldDependentOnOtherField(depField, fieldName))
        {
            fieldResult = this.validateField(depField, depField.validators,
                                              record[depField.name], record, options);
            if (fieldResult != null ) {
                if (fieldResult.errors != null) {
                    this.addValidationError (errors, depField.name || depField.dataPath,
                                            fieldResult.errors);
                } else {
                    // Record the field in the errors object even though there is no error.
                    // This lets the caller know the field was validated _and_ it is valid.
                    this.addValidationError (errors, depField.name || depField.dataPath, null);
                }
                if (fieldResult.resultingValue != null) {
                    record[depField.name] = fieldResult.resultingValue;
                }
            }
        }
    }

    result.errors = errors;
    return (validated ? result : null);
},


//>    @attr dataBoundComponent.unknownErrorMessage (HTMLString : "Invalid value" : [IRW])
// For databound components that support editing, the error message for a failed validator
// that does not specify its own errorMessage.
// @group validation, i18nMessages
// @visibility external
//<
unknownErrorMessage : "Invalid value",

_$typeValidators: ["isInteger", "isFloat", "isBoolean", "isString"],

//> @method dataBoundComponent.validateField() (A)
// Validate the field value against any validators defined on the field.
//
// @param  field      (object)    pointer to the field descriptor object
// @param  validators (array)     Validators to be applied to field
// @param  value      (any)       Value to be validated
// @param  record     (object)    pointer to the record object
// @param  options    (object)    options object to control the validation process
//                  in the format {dontValidateNullValue: true/false,
//                                 typeValidationsOnly: true/false,
//                                 unknownErrorMessage: value or null,
//                                 changing: true/false,
//                                 serverValidationMode: "full"/"partial",
//                                 skipServerValidation: true/false,
//                                 deferServerValidation: true/false}
// @return (object) null if no validation was performed, or validation result object
//                  in the format {valid: true/false,
//                                 errors: null or {fieldName: ["error", ..], ...}
//                                 resultingValue: value or null,
//                                 stopOnError: true/false,
//                                 needsServerValidation: true/false}
//<
_$partial: "partial",
validateField : function (field, validators, value, record, options) {

    // If there are no validators for this field, we are done
    if (!validators) return null;

    var errors = [],
        validated = false,
        stopOnError = null,
        result = {valid: true,
                  errors: null,
                  resultingValue: null},
        needsServerValidation = false,
        forceShowPrompt = false
    ;

    if (!isc.isAn.Array(validators)) {
        validators = [validators];
    }

    // loop through validators
    for (var i = 0; i < validators.length; i++) {
        var validator = validators[i];
        if (!validator) continue;

        // If we're validating type only (eg, for a filter field), ignore other types
        // of validator
        var valType = isc.Validator.getValidatorType(validator);
        if (options && options.typeValidationsOnly &&
            !this._$typeValidators.contains(valType))
        {
            continue;
        }

        // Unless we're looking at a 'required' or  'requiredIf' field, don't try to validate
        // null values.

        if (options && options.dontValidateNullValue &&
            value == null && valType != "required" && valType != 'requiredIf')
        {
            continue;
        }

        // If we are processing all validators
        // OR only validateOnChange ones and settings allow
        if (!options || !options.changing ||
            (validator.validateOnChange != false &&
             (validator.validateOnChange || field.validateOnChange || this.validateOnChange)))
        {
            // Postpone server validations until we complete client-side ones
            if (isc.Validator.isServerValidator(validator)) {
                needsServerValidation = true;
                // If any server validator has stopOnError set, force synchronous mode
                if (validator.stopOnError) forceShowPrompt = true;
                continue;
            }

            if (validator.applyWhen) {
                var ds = this.getDataSource(),
                    criteria = validator.applyWhen
                ;
                if (ds == null) {
                    isc.logWarn("Conditional validator criteria ignored because form has no dataSource");
                } else {
                    var matchingRows = ds.applyFilter([record], criteria);
                    // Skip validator if condition does not apply
                    if (matchingRows.length == 0) {
                        // Use result of null to let validator know it was skipped
                        isc.Validator.performAction(null, field, validator, record, this);
                        continue;
                    }
                }
            }

            // process the validator
            validated = true;

            var isValid = (isc.Validator.processValidator(field, validator, value, null, record) == true);
            isc.Validator.performAction(isValid, field, validator, record, this);
            if (!isValid) {
                var errorMessage = isc.Validator.getErrorMessage(validator);
                if (errorMessage == null) {
                    if (options && options.unknownErrorMessage) {
                        errorMessage = options.unknownErrorMessage;
                    } else {
                        errorMessage = this.unknownErrorMessage;
                    }
                }
                errors.add(errorMessage);

                // Update stopOnError status based on the validator
                if (validator.stopOnError) stopOnError = true;
            }

            // if the validator returned a resultingValue, use that as the new value
            // whether the validator passed or failed.  This lets us transform data
            // (such as with the mask validator).
            if (validator.resultingValue != null) {
                result.resultingValue = validator.resultingValue;

                // Save resulting value for remaining validators
                value = validator.resultingValue;
            }
            // if the validator failed and we're supposed to stop on a false validator, bail!
            if (!isValid && validator.stopIfFalse) break;
        }
    }
    if (needsServerValidation == true && !validated) validated = true;

    // Process server-side validators
    if (needsServerValidation && options && options.deferServerValidation) {
        result.needsServerValidation = true;
    } else if (needsServerValidation && (!options || options.skipServerValidation != true)) {
        // If field or form has stopOnError set, we must show prompt for synchronous operation
        forceShowPrompt = this._resolveStopOnError(forceShowPrompt, field.stopOnError,
                                                   this.stopOnError);

        // Default to partial validation unless overridden by the caller
        var validationMode = ((options && options.serverValidationMode)
                              ? options.serverValidationMode
                              : this._$partial),
            showPrompt = (forceShowPrompt || field.synchronousValidation ||
                          this.synchronousValidation || false)
        ;
        var values;
        if (this.getDataSource()) {
            values = this.getDataSource()._cloneValues(record);
        } else {
            values = isc.addProperties({}, record);
        }
        var pendingAdd = this.getSaveOperationType && this.getSaveOperationType() == "add";
        // Make sure if local validators have converted the value, the converted value is sent
        var dataPath = isc.Canvas._getDataPathFromField(field, this);
        isc.DynamicForm._saveFieldValue(dataPath, field, value, values, this, true, "validate");
        // send validation request to server
        this.fireServerValidation(field, values, validationMode, showPrompt, options.rowNum,
                                  pendingAdd);

        validated = true;
    }

    // If validation failed and focus should be retained in field, let caller know
    result.stopOnError = (errors.length > 0 &&
                          this._resolveStopOnError(stopOnError, field.stopOnError,
                                                   this.stopOnError));

    // Populate remainder of result object
    result.errors = (errors.length == 0 ? null : errors);
    result.valid = (errors.length == 0);
    return (validated ? result : null);
},

validateFieldsOnServer : function (fields, record, options) {
    if (!isc.isAn.Array(fields)) fields = [fields];

    var primaryField = null,
        forceShowPrompt = false
    ;

    // loop through fields/validators to determine
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            validators = field.validators
        ;

        // loop through validators
        for (var j = 0; j < validators.length; j++) {
            var validator = validators[j];
            if (!validator) continue;

            // Skip non-server validators
            if (!isc.Validator.isServerValidator(validator)) continue;

            // If any server validator has stopOnError set, force synchronous mode
            if (validator.stopOnError) {
                primaryField = field;
                forceShowPrompt = true;
            }
        }
    }

    // If field or form has stopOnError set, we must show prompt for synchronous operation
    forceShowPrompt = this._resolveStopOnError(forceShowPrompt, field.stopOnError,
                                               this.stopOnError);

    // Default to partial validation unless overridden by the caller
    var validationMode = ((options && options.serverValidationMode)
                          ? options.serverValidationMode
                          : this._$partial),
        showPrompt = (forceShowPrompt || field.synchronousValidation ||
                      this.synchronousValidation || false)
    ;
    var values;
    if (this.getDataSource()) {
        values = this.getDataSource()._cloneValues(record);
    } else {
        values = isc.addProperties({}, record);
    }
    var pendingAdd = this.getSaveOperationType && this.getSaveOperationType() == "add";
    // send validation request to server
    if (!primaryField) primaryField = fields[0];
    this.fireServerValidation(primaryField, values, validationMode, showPrompt, options.rowNum,
                              pendingAdd);
},

// stopOnError is resolved validator value
_resolveStopOnError : function(stopOnError, fieldStopOnError, formStopOnError) {
    if (stopOnError != null) return stopOnError;
    return (fieldStopOnError == null && formStopOnError) || fieldStopOnError || false;
},

fireServerValidation : function (field, record, validationMode, showPrompt, rowNum, pendingAdd) {
    var ds = this.getDataSource();
    if (ds == null) return;

    var requestProperties = {showPrompt: showPrompt,
                             prompt: isc.RPCManager.validateDataPrompt,
                             validationMode: validationMode,
                             internalClientContext: {
                                 component: this,
                                 fieldName: field.name,
                                 rowNum: rowNum }
                             };
    if (pendingAdd) requestProperties.pendingAdd = true;

    // Drop null values if validating in "partial" mode
    if (validationMode == this._$partial) {
        for (var fieldName in record) {
            if (record[fieldName] === null) delete record[fieldName];
        }
    }

    // If processing asynchronously, we must keep a list of outstanding requests
    // so that the DBC can check for dependencies before editing a field.
    if (!showPrompt) {
        var pendingFields = this._registerAsyncValidation(field);
        requestProperties.internalClientContext.pendingFields = pendingFields;
    }
    ds.validateData(record,
                    this._handleServerValidationReply,
                    requestProperties);
},

_handleServerValidationReply : function (dsResponse, data, dsRequest) {
    if (dsResponse.status == isc.DSResponse.STATUS_FAILURE) {
        isc.logWarn("Server-side validation failed: " + dsResponse.data);
        isc.say(dsResponse.data);
    }
    var context = dsResponse.internalClientContext,
        component = context.component,
        pendingFields = context.pendingFields,
        errors = dsResponse.errors == null ? null : isc.DynamicForm.getSimpleErrors(dsResponse.errors);

    if (dsResponse.errors) {
        // Show server errors
        for (var fieldName in errors) {
            var fieldErrors = errors[fieldName],
                field = component.getField(fieldName);

            if (fieldErrors != null && field != null) {
                // Avoid changing focus by delaying update until redraw
                if (!isc.isAn.Array(fieldErrors)) fieldErrors = [fieldErrors];
                var stopOnError = null;
                for (var i = 0; i < fieldErrors.length; i++) {
                    component.addFieldErrors(fieldName, fieldErrors[i].errorMessage, false, context.rowNum);
                    if (fieldErrors[i].stopOnError) stopOnError = true;
                }
                if (field.redraw) field.redraw();

                stopOnError = component._resolveStopOnError(stopOnError, field.stopOnError,
                                                            component.stopOnError);

                // Restore focus to primary field if stopOnError
                if (fieldName == context.fieldName && stopOnError == true && !field.hasFocus) {
                    if (!field.synchronousValidation && !component.synchronousValidation) {
                        isc.logWarn("Server validation for " + fieldName +
                                    " signaled stopOnError but validation is not set for" +
                                    " synchronousValidation:true - stop ignored.");
                    } else {
                        component.focusInItem (field);
                    }
                }
            }
        }
    }

    // If request marked pending fields, clear them now.
    if (pendingFields) {
        component._clearAsyncValidation(pendingFields);
    }

    // support a callback method to fire when remote validation completes
    if (component && component.handleAsyncValidationReply != null) {

        if (errors != null) {
            errors = isc.DynamicForm.formatValidationErrors(errors);
        }
        component.handleAsyncValidationReply(errors == null, errors);
    }
},

//> @method dynamicForm.handleAsyncValidationReply()
// Notification fired when an asynchronous validation completes.
// @param success (boolean) true if validation succeeded, false if it failed
// @param errors (object) Map of errors by fieldName. Will be null if validation succeeded.
// @visibility external
//<
handleAsyncValidationReply : function (success, errors) {
},

//> @method dynamicForm.isPendingAsyncValidation()
// Is this component waiting for an asynchronous validation to complete?
// This method will return true after +link{dynamicForm.validate()} is called on a component with
// server-side validators for some field(s), until the server responds.
// <P>
// Note that the notification method +link{dynamicForm.handleAsyncValidationReply} will be fired
// when validation completes.
// @return (Boolean) true if this widget has pending asynchronous validations in process
// @visibility external
//<
isPendingAsyncValidation : function () {
    return !isc.isAn.emptyObject(this._pendingAsyncValidations);
},

// Pending asynchronous validations
// Format: <field>: <outstandingRequestCount>,
//         ...
_pendingAsyncValidations: {},

// Register async validation request for <field>.
// Returns: array of fields affected by this validation. Includes <field>.
_registerAsyncValidation : function (field) {
    var fields = this.getFields() || [],
        pendingFields = [field.name],
        fieldName = field.name
    ;

    // Register pending on field being validated
    this._pendingAsyncValidations[fieldName] =
        (this._pendingAsyncValidations[fieldName] == null
            ? 1
            : this._pendingAsyncValidations[fieldName]++);

    // Register pending on fields dependent on field being validated
    for (var i = 0; i < fields.length; i++) {
        var depField = fields[i];
        if (depField.name != fieldName && this.isFieldDependentOnOtherField(depField, fieldName)) {
            var depFieldName = depField.name;
            pendingFields.add(depFieldName);

            this._pendingAsyncValidations[depFieldName] =
                (this._pendingAsyncValidations[depFieldName] == null
                    ? 1
                    : this._pendingAsyncValidations[depFieldName]++);
        }
    }
    return pendingFields;
},

// Clear pending validation for <fieldNames> array.
// If a pending UI interaction is blocked by a showPrompt, clear that.
_clearAsyncValidation : function (fieldNames) {
    var clearedAField = false;
    for (var i = 0; i < fieldNames.length; i++) {
        this._pendingAsyncValidations[fieldNames[i]]--;
        if (this._pendingAsyncValidations[fieldNames[i]] == 0) {
            delete this._pendingAsyncValidations[fieldNames[i]];
            clearedAField = true;
        }
    }
    // If any field was cleared see if we have a blocking focus to continue
    if (clearedAField && this._blockingFocus != null) {
        var unblock = true;
        for (var i = 0; i < this._blockingFocus; i++) {
            if (this._pendingAsyncValidations[this._blockingFocus[i]] > 0) {
                unblock = false;
                break;
            }
        }

        if (unblock) {
            this._blockingFocus = null;
            isc.clearPrompt();
        }
    }
},

// Array of field names which must be cleared from pending validations
// before unblocking focus.
_blockingFocus: null,

//> @method dataBoundComponent.blockOnFieldBusy
// Block UI activity by displaying showPrompt if validation is pending for specified field
// or any dependency. If shown the prompt will be removed automatically when responses
// are received.
//
// @param field (FormItem) Field being entered.
// @return (boolean) True if prompt was shown
//
// @visibility internal
//<
blockOnFieldBusy : function (field) {
    // If already blocking, nothing more to do. Let caller know we are blocked.
    if (this._blockingFocus != null) return true;

    // See if any requests are pending to matter
    var havePendingRequest = false;
    for (var fieldName in this._pendingAsyncValidations) {
        havePendingRequest = true;
        break;
    }
    if (!havePendingRequest) return false;

    // Get the list of fields we should check
    var dependentOnFields = this.getFieldDependencies(field) || [];
    dependentOnFields.add(field.name);

    // Determine which fields are still pending, if any
    var waitForFieldNames = [];
    for (var i = 0; i < dependentOnFields.length; i++) {
        var depFieldName = dependentOnFields[i];
        if (this._pendingAsyncValidations[depFieldName] > 0) {
            waitForFieldNames.add(depFieldName);
        }
    }
    if (waitForFieldNames.length > 0) {
        // We have at least one of our dependent fields pending a response - we have to block.
        this._blockingFocus = waitForFieldNames;


        this.delayCall("showValidationBlockingPrompt");
        return true;
    }
    return false;
},

// Called on a delay so execution occurs outside the "focus" thread.
// Don't show the prompt if this._blockingFocus has already been cleared
showValidationBlockingPrompt : function () {
    if (this._blockingFocus) isc.showPrompt(isc.RPCManager.validateDataPrompt);

},

//> @attr DataBoundComponent.rulesEngine (RulesEngine : null : IR)
// +link{RulesEngine} associated with this dataBoundComponent. The rulesEngine will associate
// a set of specified +link{Rule} objects with dataBoundComponents.
// <P>
// To apply a rulesEngine at runtime, use +link{rulesEngine.addMember()}
// @visibility rules
//<

// The following methods should be overridden by DBC implementations.
// These are used in validatorDefinition.action() methods to set the
// appearance of a field.
enableField : function (fieldName) {
    if (fieldName == null || isc.isAn.emptyString(fieldName)) return;

    var field = this.getField(fieldName);
    if (field) {
        field.disabled = false;
        this.redraw();
    }
},

disableField : function (fieldName) {
    if (fieldName == null || isc.isAn.emptyString(fieldName)) return;

    var field = this.getField(fieldName);
    if (field) {
        field.disabled = true;
        this.redraw();
    }
},

showField : function (fieldName) {
    if (fieldName == null || isc.isAn.emptyString(fieldName)) return;

    var field = this.getField(fieldName);
    if (field) field.show();
},

hideField : function (fieldName) {
    if (fieldName == null || isc.isAn.emptyString(fieldName)) return;

    var field = this.getField(fieldName);
    if (field) field.hide();
},


setFieldCanEdit : function (fieldName, canEdit) {
    if (fieldName == null || isc.isAn.emptyString(fieldName)) return;

    var field = this.getField(fieldName);
    if (field) {
        field.canEdit = canEdit;
        this.redraw();
    }
},

//> @method dataBoundComponent.isOffline()
// Returns true if the component's current data model is marked as offline.  This does not
// necessarily mean that the component has no data; it may have data that was supplied from
// the +link{class:Offline,offline cache}.
// @return (boolean) Offline if true
// @group offlineGroup
// @visibility external
//<
isOffline : function () {
    if (this.data && this.data._offline) return true;
    return false;
},

//> @method dataBoundComponent.setSelectionComponent()
// setter for +link{dataBoundComponent.selectionComponent}
// @param component (ID | canvas) new selection component
// @visibility selectionComponent
//<
setSelectionComponent : function (component, init) {
    if (!component) {
        if (this.selectionComponent != null) {
            this.ignore(this.selectionComponent, "selectionChanged");
            this.ignore(this.selectionComponent, "cellSelectionChanged");
        }
        delete this.selectionComponent;
        if (this.valuesManager) {
            this.ignore(this.valuesManager, "_updateMultipleMemberValue");
        }
    } else {
        var specifiedComponent = component;
        if (isc.isA.String(component)) component = window[component];
        if (!component || !isc.isA.Canvas(component) || component.dataArity != "multiple") {
            this.logWarn("setSelectionComponent() - selection component specified as:" +
                specifiedComponent + " this is not a valid component");
            return;
        }

        if (!component.getSelection) {
            this.logWarn("setSelectionComponent() - specified selection component:" + component +
              " does not support selection - ignoring");
            return;
        }
        // if we had a previous selection component, clear up observations
        if (!init && this.selectionComponent) {
            // already pointing at the sc - we're done!
            if (this.selectionComponent == component) return
            if (this.isObserving(this.selectionComponent, "selectionChanged")) {
                this.ignore(this.selectionComponent, "selectionChanged");
            }
            if (this.isObserving(this.selectionComponent, "cellSelectionChanged")) {
                this.ignore(this.selectionComponent, "cellSelectionChanged");
            }
        }
        this.selectionComponent = component;

        // Possibilities for ListGrid:
        // selectionChanged - record, state
        // cellSelectionChanged - cellList

        if (!this.selectionComponent.useCellRecords) {
            this.observe(this.selectionComponent, "selectionChanged",
                         "observer.selectionComponentSelectionChanged(observed, record,state)");
        } else {
            this.observe(this.selectionComponent, "cellSelectionChanged",
                         "observer.selectionComponentCellSelectionChanged(observed, cellList)");
        }
    }
},

// selectionChanged / cellSelectionChanged on the selectionComponent.  This is a generic
// handler for anything that has a setData() method - note that DynamicForm has a custom
// version
selectionComponentSelectionChanged : function (selectionComponent, record, state) {
    if (!state) {
        if (this.dataArity == "single") {
            record = null;
        } else {
            return;
        }
    }

    if (this.dataArity == "single") {
        this.setData(record);
    } else {
        var elements = this.dataPath.split("/");
        this.setData(record[elements[elements.length - 1]]);
        // For a multi-record component, clear the current selection - if this component is acting
        // as the selectionComponent for a lower-level single-record component, this will cause
        // that item to be cleared (which is what we want)
        if (this.dataArity == "multiple" && isc.isA.Function(this.deselectAllRecords)) {
            this.deselectAllRecords();
        }
    }
},

selectionComponentCellSelectionChanged : function (selectionComponent, cellList) {
    for (var i = 0; i < cellList.length; i++) {
        var cell = cellList[i],
            record = this.selectionComponent.getCellRecord(cell[0], cell[1]);
        if (selectionComponent.cellIsSelected(record)) break;
        record = null;
    }
    if (record) {
        this._selectionComponentRecordPKs = selectionComponent.getPrimaryKeys(record);
        this.editRecord(record);
    }
},

// Build the MenuItem that DataBoundComponents will use to
// launch the FieldPickerWindow to edit the order of their fields.
createFieldPickerWindowMenuItem : function (title) {
    return {
        title: title,
        component: this,
        click: function () {
            this.component.editFields();
        }
    }
},


//>    @method dataBoundComponent.editFields()
// Shows a +link{class:FieldPicker, FieldPicker} interface allowing end-users to edit
// the fields currently shown by this DataBoundComponent.
//
// @visibility external
//<
editFields : function () {
    var pickerWindow = this.fieldPickerWindow;
    if (pickerWindow) pickerWindow.show();
    else {
        var windowProperties = this.fieldPickerWindowProperties||{},
            pickerProperties = windowProperties.fieldPickerProperties||{};

        this.fieldPickerWindow = this.createAutoChild("fieldPickerWindow", {
            fieldPickerProperties: isc.addProperties(pickerProperties, {
                dataBoundComponent: this,
                canEditTitles:this.canEditTitles
            })
        });

        this.fieldPickerWindow.show();
    }
},

//> @classMethod dataBoundComponent.requestsArePending()
// Returns whether there are any pending +link{DSRequest}s initiated by this
// +link{dataBoundComponent}.  May not include any requests sent by directly calling the
// +link{DataSource} APIs (rather than the DataBoundComponent APIs).
// <P>
// @return (Boolean) true if one or more requests are pending, false otherwise.
// @visibility external
//<
_pendingRpcs: 0,
requestsArePending : function () {
    return this._pendingRpcs != 0;
}

});


// ------------------------------------------------------------------------------------------

//> @class MathFunction
// The definition of a function for use in the +link{FormulaBuilder}.  A function consists of
// a name (what the user actually types to use the function), a description (shown in help) and
// an actual JavaScript function that executes the calculation.
// <P>
// The built-in functions cover all static functionality on the JavaScript Math object:
// <ul>
// <li><b>max(val1,val2)</b>: Maximum of two values</li>
// <li><b>min(val1,val2)</b>: Minimum of two values</li>
// <li><b>round(value,decimalDigits)</b>: Round a value up or down, optionally providing
//     <i>decimalDigits</i> as the maximum number of decimal places to round to.  For fixed
//     or precision rounding, use <i>toFixed()</i> and <i>toPrecision()</i> respectively.
// </li>
// <li><b>ceil(value)</b>: Round a value up</li>
// <li><b>floor(value)</b>: Round a value down</li>
// <li><b>abs(value)</b>: Absolute value</li>
// <li><b>pow(value1,value2)</b>: value1 to the power of value2</li>
// <li><b>sqrt(value)</b>: Square root of a value</li>
// <li><b>dateAdd(value,interval,amount)</b>: Excel&trade;-compatible dataAdd function: adds
//     quantities of a time interval to a date value.  Also supports being passed interval
//     names, like "hour" or "week".
// </li>
// <li><b>toPrecision(value,precision)</b>: Format a number to a length of <i>precision</i> digits,
//     rounding or adding a decimal point and zero-padding as necessary.  Note that the
//     values 123, 12.3 and 1.23 have an equal precision of 3.  Returns a formatted string
//     and should be used as the outermost function call in a formula. For rounding, use
//     <i>round()</i>.
// </li>
// <li><b>toFixed(value,digits)</b>: Round or zero-pad a number to <i>digits</i> decimal places.
//     Returns a formatted string and should be used as the outermost function call in a
//     formula.  To round values or restrict precision, use <i>round()</i> and
//     <i>toPrecision()</i> respectively.
// </li>
// <li><b>sin(value)</b>: Sine of a value</li>
// <li><b>cos(value)</b>: Cosine of a value</li>
// <li><b>tan(value)</b>: Tangent of a value</li>
// <li><b>ln(value)</b>: natural logarithm of a value</li>
// <li><b>log(base,value)</b>: logarithm of a value with the specified <i>base</i></li>
// <li><b>asin(value)</b>: Arcsine of a value</li>
// <li><b>acos(value)</b>: Arccosine of a value</li>
// <li><b>atan(value)</b>: Arctangent of a value (-PI/2 to PI/2 radians)</li>
// <li><b>atan2(value1,value2)</b>: Angle theta of a point (-PI to PI radians)</li>
// <li><b>exp(value)</b>: The value of E<sup>value</sup></li>
// <li><b>random()</b>: Random number between 0 and 1</li>
// </ul>
//
// @treeLocation Client Reference/Data Binding/FormulaBuilder
// @group formulaFields
// @visibility external
//<
isc.ClassFactory.defineClass("MathFunction", "Class");

// static properties and methods
isc.MathFunction.addClassProperties({


    _functions : {}                 // internal array to hold the list of registered functions
});


isc.MathFunction.addClassMethods({

//> @classMethod MathFunction.registerFunction()
// Registers a new math function for use with FormulaFields. Mixed-case names are allowed,
// and as a convenience, the following aliases are also available:<ul>
// <li> name in all lowercase
// <li> name in all uppercase
// <li> name with first letter uppercase, and the rest unchanged</ul>
//
// Note: The aliases are shallow copies of each other, so be aware that if +link{jsFunction}
// depends on instance state, objects accessed by instance properties will be shared by all
// copies.
//
// @param newFunction (MathFunction)
//
// @group formulaFields
// @visibility external
//<
registerFunction : function (newFunction) {
    if (!this._functions[newFunction.name]) {
        this._functions[newFunction.name] = newFunction;
    }
    // the following lines will add the math function with all lowercase name
    var newFunctionLowerCase = newFunction._copy();
    newFunctionLowerCase.name = newFunction.name.toLowerCase();
    newFunctionLowerCase.defaultSortPosition = -1;
    if (!this._functions[newFunctionLowerCase.name]) {
        this._functions[newFunctionLowerCase.name] = newFunctionLowerCase;
    }
    // the following lines will add the math function with all uppercase name
    var newFunctionUpperCase = newFunction._copy();
    newFunctionUpperCase.name = newFunction.name.toUpperCase();
    newFunctionUpperCase.defaultSortPosition = -1;
    if (!this._functions[newFunctionUpperCase.name]) {
        this._functions[newFunctionUpperCase.name] = newFunctionUpperCase;
    }
    // the following lines will add the math function with initial uppercase name
    var newFunctionInitialUpperCase = newFunction._copy();
    newFunctionInitialUpperCase.name = (newFunction.name.substr(0, 1).toUpperCase() +
                                        newFunction.name.substr(1));
    newFunctionInitialUpperCase.defaultSortPosition = -1;
    if (!this._functions[newFunctionInitialUpperCase.name]) {
        this._functions[newFunctionInitialUpperCase.name] = newFunctionInitialUpperCase;
    }
},

// Returns a list of all registered function-names
getRegisteredFunctionNames : function () {
    return isc.getKeys(this._functions);
},

// Returns a list of default function-names, sorted by defaultSortPosition
getDefaultFunctionNames : function () {
    var funcs = this.getDefaultFunctions(),
        index = funcs.makeIndex("name", false);
    return isc.getKeys(index);
},

// Returns a list of all registered functions
getRegisteredFunctions : function () {
    return isc.getValues(this._functions);
},

// Returns a list of default functions, order by defaultSortPosition
getDefaultFunctions : function () {
    var allFuncs = this.getRegisteredFunctions(),
        nonDefaults = allFuncs.findAll("defaultSortPosition", -1) || []
    ;

    for (var i=0; i<nonDefaults.length; i++) {
        var item = nonDefaults[i];
        allFuncs.remove(item);
    }

    allFuncs.sortByProperties(["defaultSortPosition"], ["true"]);
    return allFuncs;
},


//> @classMethod MathFunction.getRegisteredFunctionIndex()
// Returns an index of all registered functions by name
//
// @return (Index)
// @group formulaFields
// @visibility external
//<
getRegisteredFunctionIndex : function () {
    var x = this.getRegisteredFunctions();
    var xIndex = x.makeIndex("name", false);
    return xIndex;
},

//> @classMethod MathFunction.getDefaultFunctionIndex()
// Returns an index of all default registered functions by name, ordered by
// +link{mathFunction.defaultSortPosition}.  (Also includes those user-registered
// functions with non-default (&gt;= 0) values for that property.)
//
// @return (Index)
//
// @see Array.makeIndex
// @see defaultSortPosition
// @group formulaFields
// @visibility external
//<
getDefaultFunctionIndex : function () {
    return this.getDefaultFunctions().makeIndex("name", false);
},

// Returns true if the named function is registered, false otherwise
isRegistered : function (name) {
    if (this._functions[name]) return true;
    return false;
}


});

isc.MathFunction.addProperties({
// attributes
//> @attr mathFunction.name (identifier : null : IR)
// Name of the function (what the user actually types).  For example, a name of "min" would
// indicate that the user types "min(someValue)" to use this function.
// <P>
// Mixed-case names may be used.  As a convenience, a few aliases are registered by
// +link{registerFunction} (see that method for details).
//
// @see registerFunction
// @group formulaFields
// @visibility external
//<

//> @attr mathFunction.description (String : null : IR)
// A short description of this function
//
// @group formulaFields
// @visibility external
//<

//> @attr mathFunction.jsFunction (Function : null : IR)
// Javascript method to perform the calculation associated with this function
//
// @group formulaFields
// @visibility external
//<

//> @attr mathFunction.defaultSortPosition (integer : -1 : IR)
// Indicates the sort-order of this +link{MathFunction} in an index returned from static method
// +link{MathFunction.getDefaultFunctionIndex()}.  A lower value (&gt;= 0) will cause a function
// to appear before a +link{MathFunction} with a higher value of the property.  The default
// of -1 means to exclude the MathFunction from the index entirely.
//
// @group formulaFields
// @see classMethod:MathFunction.getDefaultFunctionIndex()
// @visibility external
//<
defaultSortPosition: -1,

// copy a MathFunction instance

_copy : function (newProperties) {
    var instanceProperties = {};
    for (var property in this) {
        if (this.hasOwnProperty(property)) {
            instanceProperties[property] = this[property];
        }
    }
    return this.getClass().create(instanceProperties, newProperties);
}

});

// register some built in functions
// This first bunch are default ones that appear in the help list in FormulaBuilders
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "max",
        description: "Maximum of two values",
        usage: "max(value1, value2)",
        defaultSortPosition: 1,
        jsFunction: function (value1, value2) {
            return Math.max(value1, value2);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "min",
        description: "Minimum of two values",
        usage: "min(value1, value2)",
        defaultSortPosition: 2,
        jsFunction: function (value1, value2) {
            return Math.min(value1, value2);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "clamp",
        description: "Value clamped to range specified",
        usage: "clamp(value1, value2)",
        defaultSortPosition: 3,
        jsFunction: function (value, min, max) {
            return isc.Math.clamp(value, min, max);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "round",
        description: "Round a value up or down, optionally providing <i>decimalDigits</i> " +
            "as the maximum number of decimal places to round to.  For fixed or precision " +
            "rounding, use <i>toFixed()</i> and <i>toPrecision()</i> respectively.",
        usage: "round(value,decimalDigits)",
        defaultSortPosition: 4,
        jsFunction: function (value, decimalDigits) {
            if (decimalDigits) {
                var multiplier = Math.pow(10, decimalDigits),
                    result = Math.round(value * multiplier) / multiplier;

                return result;
            }
            return Math.round(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "ceil",
        description: "Round a value up",
        usage: "ceil(value)",
        defaultSortPosition: 5,
        jsFunction: function (value) {
            return Math.ceil(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "floor",
        description: "Round a value down",
        usage: "floor(value)",
        defaultSortPosition: 6,
        jsFunction: function (value) {
            return Math.floor(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "abs",
        description: "Absolute value",
        usage: "abs(value)",
        defaultSortPosition: 7,
        jsFunction: function (value) {
            return Math.abs(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "pow",
        description: "Value1 to the power of Value2",
        usage: "pow(value1, value2)",
        defaultSortPosition: 8,
        jsFunction: function (value1, value2) {
            return Math.pow(value1, value2);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "sqrt",
        description: "Square root of a value",
        usage: "sqrt(value)",
        defaultSortPosition: 9,
        jsFunction: function (value) {
            return Math.sqrt(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "dateAdd",
        description: "Excel&trade;-compatible dataAdd function: adds a specified time interval to a date value",
        usage: "dateAdd(Date value, TimeUnit interval, number amount)",
        defaultSortPosition: 10,
        jsFunction: function (value, interval, amount) {
            if (value == null || !isc.isA.Date(value)) return null;
            // DateUtil.dateAdd is mutable but the MathFunction dateAdd should not be
            var localValue = value.duplicate();
            isc.DateUtil.dateAdd(localValue, interval, amount, 1, value.logicalDate);
            return localValue;
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "toPrecision",
        description: "Format a number to a length of <i>precision</i> digits, rounding or " +
            "adding a decimal point and zero-padding as necessary.  Note that the values " +
            "123, 12.3 and 1.23 have an equal precision of 3.  Returns a formatted " +
            "string and should be used as the outermost function call in a formula. " +
            "For rounding, use <i>round()</i>.",
        usage: "toPrecision(value,precision)",
        defaultSortPosition: 11,
        jsFunction: function (value, precision) {
            var localValue=value;
            if (isc.isA.String(localValue)) localValue = parseFloat(localValue);
            if (isNaN(localValue)) return value;
            return localValue.toPrecision(precision);
        }
    })
);

isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "toFixed",
        description: "Round or zero-pad a number to <i>digits</i> decimal places.  Returns " +
            "a formatted string and should be used as the outermost function call in a " +
            "formula.  To round values or restrict precision, use <i>round()</i> and " +
            "<i>toPrecision()</i> respectively.",
        usage: "toFixed(value,digits)",
        defaultSortPosition: 12,
        jsFunction: function (value, digits) {
            var localValue=value;
            if (isc.isA.String(localValue)) localValue = parseFloat(localValue);
            if (isNaN(localValue)) return value;
            return localValue.toFixed(digits);
        }
    })
);

isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "sin",
        description: "Sine of a value",
        usage: "sin(value)",
        defaultSortPosition: 13,
        jsFunction: function (value) {
            return Math.sin(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "cos",
        description: "Cosine of a value",
        usage: "cos(value)",
        defaultSortPosition: 14,
        jsFunction: function (value) {
            return Math.cos(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "tan",
        description: "Tangent of a value",
        usage: "tan(value)",
        defaultSortPosition: 15,
        jsFunction: function (value) {
            return Math.tan(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "ln",
        description: "Natural logarithm of a value",
        usage: "ln(value)",
        defaultSortPosition: 16,
        jsFunction: function (value) {
            return Math.log(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "log",
        description: "logarithm of a value with the specified <i>base</i>",
        usage: "log(base, value)",
        defaultSortPosition: 17,
        jsFunction: function (base, value) {
            return Math.log(value) / Math.log(base);
        }
    })
);

// non-default functions (don't appear in the help list in FormulaBuilders)
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "asin",
        description: "Arcsine of a value",
        usage: "asin(value)",
        defaultSortPosition: 18,
        jsFunction: function (value) {
            return Math.asin(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "acos",
        description: "Arccosine of a value",
        usage: "acos(value)",
        defaultSortPosition: 19,
        jsFunction: function (value) {
            return Math.acos(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "atan",
        description: "Arctangent of a value (-PI/2 to PI/2 radians)",
        usage: "atan(value)",
        defaultSortPosition: 20,
        jsFunction: function (value) {
            return Math.atan(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "atan2",
        description: "Angle theta of a point (-PI to PI radians)",
        usage: "atan2(value1,value2)",
        defaultSortPosition: 21,
        jsFunction: function (value1, value2) {
            return Math.atan2(value1, value2);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "exp",
        description: "The value of E<sup>value</sup>",
        usage: "exp(value)",
        defaultSortPosition: 22,
        jsFunction: function (value) {
            return Math.exp(value);
        }
    })
);
isc.MathFunction.registerFunction(
    isc.MathFunction.create({
        name: "random",
        description: "Random number between 0 and 1",
        usage: "random()",
        defaultSortPosition: 23,
        jsFunction: function () {
            return Math.random();
        }
    })
);


//> @object TestFunctionResult
// A TestFunctionResult is an ordinary JavaScript Object with properties that indicate the
// status of an attempt to generate and execute a function for +link{FormulaBuilder} and
// it's subclasses.
// <P>
// Because TestFunctionResult is always an ordinary JavaScript Object, it supports the
// normal behaviors of JavaScript Objects, including accessing and assigning to properties
// via dot notation:
// <pre>
//     var propValue = testFunctionResult.<i>propName</i>;
//     testFunctionResult.<i>propName</i> = newValue;
// </pre>
// <P>
//
// @treeLocation Client Reference/Data Binding/FormulaBuilder
// @group formulaFields
// @visibility external
//<

//> @attr testFunctionResult.failedGeneration (boolean : false : IRW)
// Set to true if there is a syntax error in the formula or summary being checked.
// <P>
// When set to true, +link{testFunctionResult.errorText} contains the exception message.
//
// @group formulaFields
// @visibility external
//<

//> @attr testFunctionResult.failedExecution (boolean : false : IRW)
// Set to true if calling the formula or summary format resulted in a JavaScript Error.
// This would generally indicate a reference to non-existent data values.  See
// +link{testFunctionResult.failedGeneration} for other types of failure.
// <P>
// When set to true, +link{testFunctionResult.errorText} contains the exception message.
//
// @group formulaFields
// @visibility external
//<

//> @attr testFunctionResult.emptyTestValue (boolean : false : IRW)
// Set to true if the formula or summary definition passed in was empty.
//
// @group formulaFields
// @visibility external
//<

//> @attr testFunctionResult.errorText (string : null : IRW)
// If the formula or summary format caused a JavaScript error, this contains the JavaScript error text.
//
// @group formulaFields
// @visibility external
//<

//> @attr testFunctionResult.result (string : null : IRW)
// When a formula or summary format is valid, <i>result</i> contains the result returned by the
// generated function when it was executed.
//
// @group formulaFields
// @visibility external
//<

//> @attr testFunctionResult.record (Record : null : IRW)
// Set to the record that was used when testing the generated function.  This is the record
// selected by +link{formulaBuilder.getTestRecord()}.
//
// @group formulaFields
// @visibility external
//<

isc.Canvas.registerStringMethods({
    //> @method databoundComponent.userAddedField
    // Notification method fired when a user-generated field is added to this component via
    // +link{editFormulaField()} or +link{editSummaryField()}.
    // <P>
    // Returning false from this method will prevent the field being added at all. Note that
    // this also provides an opportunity to modify the generated field object - any changes
    // made to the field parameter will show up when the field is displayed in the ListGrid.
    //
    // @param    field       (ListGridField)    User generated summary or formula field
    // @return (boolean) Return false to cancel the addition of the field
    // @group formulaFields
    // @group summaryFields
    // @visibility external
    //<

    userAddedField:"field",

    //> @method dataBoundComponent.selectionUpdated()
    // Called when the selection changes. Note that this method fires exactly once for any given
    // change to the selection unlike the +link{ListGrid.selectionChanged,selectionChanged} event.
    // <P>
    // This event is fired once after selection/deselection has completed. The result is
    // one event per mouse-down event. For a drag selection there will be two events fired:
    // one when the first record is selected and one when the range is completed.
    // <P>
    // This event is also fired when selection is updated by a direct call to one of the
    // <code>DataBoundComponent</code> select/deselect methods. Calls on the +link{class:Selection}
    // object <b>do not</b> trigger this event.
    //
    // @param record        (object)                 first selected record in the selection, if any,
    // which may or may not be the first record in sort order if the <code>DataBoundComponent</code>
    // is sorted.  This parameter is typically used when only one record can be selected at a time.
    // @param recordList    (Array of Object)        List of records that are now selected
    // @group selection
    // @visibility external
    //<
    selectionUpdated : "record,recordList",

    //> @method dataBoundComponent.onFetchData()
    // Optional notification stringMethod fired on fetchData() or filterData()
    // the filter editor criteria.
    // @param criteria (Criteria) criteria passed to fetchData() / filterData()
    // @param requestProperties (DSRequest) request config passed to the filter/fetch request
    // @visibility sgwt
    //<

    onFetchData:"criteria,requestProperties"

});








//>    @class    EdgedCanvas
// EdgedCanvas acts as a decorative, image-based frame around another single Canvas.
//
// @treeLocation Client Reference/Foundation
// @group imageEdges
// @visibility roundCorners
//<
isc.defineClass("EdgedCanvas", "Canvas").addProperties({

    // we don't want to redraw for any automatic reasons
    redrawOnResize:false,
    _redrawWithParent:false,
    _redrawWithMaster:false,

    // we do our own sizing, based on the master's margins
    _resizeWithMaster:false,

    // we don't need the extra structure, and it causes problems in Safari
    useClipDiv:false,

    //disable snapping to alignment against this Canvas
    isSnapAlignCandidate: false,


    overflow:isc.Browser.isMoz ? isc.Canvas.VISIBLE : isc.Canvas.HIDDEN,
    _useMozScrollbarsNone:false,

    // calculated margins based on visible corners and settings
    _leftMargin : 0,
    _topMargin : 0,
    _rightMargin : 0,
    _bottomMargin : 0,
    // all edges in cell order
    _allEdges : ["TL", "T", "TR", "L", "center", "R", "BL", "B", "BR"],
    _leftEdges : {L:true, TL:true, BL:true},
    _rightEdges : {R:true, TR:true, BR:true},
    // In RTL browsers tables are reversed so we need to flip our media too
    _allEdgesRTL : ["TR", "T", "TL", "R", "center", "L", "BR", "B", "BL"],

    // Edge Media
    // ---------------------------------------------------------------------------------------

    //> @attr edgedCanvas.skinImgDir   (URL : "images/edges/" : IR)
    // Standard skin directory for edge images (sides and corners).
    //
    // @group imageEdges
    // @visibility roundCorners
    //<
    skinImgDir:"images/edges/",

    //> @attr edgedCanvas.edgeImage   (SCImgURL : "[SKIN]/rounded/frame/FFFFFF/6.png" : IR)
    // Base name of images for edges.  Extensions for each corner or edge piece will be added
    // to this image URL, before the extension.  For example, with the default base name of
    // "edge.gif", the top-left corner image will be "edge_TL.gif".
    // <P>
    // The full list of extensions is: "_TL", "_TR", "_BL", "_BR", "_T", "_L", "_B", "_R",
    // "_center".
    //
    // @group imageEdges
    // @visibility roundCorners
    //<
    edgeImage:"[SKIN]/rounded/frame/FFFFFF/6.png",

    //> @attr edgedCanvas.edgeColor (CSSColor : null : IR)
    // CSS color (WITHOUT "#") for the edges.  If specified, will be used as part of image
    // names.  Example: "edge_88FF88_TL.gif".
    // @group imageEdges
    // @visibility roundCorners
    //<

    // Shown Edges
    // ---------------------------------------------------------------------------------------
    //> @attr edgedCanvas.customEdges (Array of String : null : IR)
    // Array of side names ("T", "B", "L", "R") specifying which sides of the decorated
    // component should show edges.  For example: <pre>
    //      customEdges : ["T", "B"]
    // </pre>
    // .. would show edges only on the top and bottom of a component.
    // <P>
    // The default of <code>null</code> means edges will be shown on all sides.
    //
    // @group imageEdges
    // @visibility roundCorners
    //<

    //> @attr edgedCanvas.showCenter (Boolean : false : IR)
    // Whether to show media in the center section, that is, behind the decorated Canvas.
    //
    // @group imageEdges
    // @visibility roundCorners
    //<

    //> @attr edgedCanvas.shownEdges   (Object : [all edges] : IR)
    // The corners and edges which should appear outside the contained Canvas.
    // <P>
    // Any combination is permitted so long as every visible edge piece has two visible
    // adjacent corners.
    // <P>
    // Some examples:<ul>
    // <li>cap on top: TL, T, TR
    // <li>cap on top and bottom: TL, T, TR, BL, B, BR
    // <li>3 rounded corners: TR, R, BR, B, BL
    // <li>4 rounded corners, contained Canvas flush with bottom: TL, T, TR, L, R, BL, BR
    // </ul>
    //<
    // NOTE: not documented for now in favor of simpler customEdges interface


    shownEdges : {
            TL:true,
            T:true,
            TR:true,
            L:true,
            R:true,
            BL:true,
            B:true,
            BR:true
    },

    // Edge Sizing
    // ---------------------------------------------------------------------------------------

    //> @attr edgedCanvas.edgeSize (integer : 6 : IR)
    // Size in pixels for corners and edges
    // @group imageEdges
    // @visibility roundCorners
    //<
    edgeSize:6

    //> @attr edgedCanvas.edgeLeft     (integer : null : IR)
    // Height in pixels for left corners and edges.  Defaults to edgeSize when unset.
    // @group imageEdges
    // @visibility roundCorners
    //<

    //> @attr edgedCanvas.edgeRight    (integer : null : IR)
    // Height in pixels for right corners and edges.  Defaults to edgeSize when unset.
    // @group imageEdges
    // @visibility roundCorners
    //<

    //> @attr edgedCanvas.edgeTop      (integer : null : IR)
    // Height in pixels for top corners and edges.  Defaults to edgeSize when unset.
    // @group imageEdges
    // @visibility roundCorners
    //<

    //> @attr edgedCanvas.edgeBottom   (integer : null : IR)
    // Height in pixels for bottom corners and edges.  Defaults to edgeSize when unset.
    // @group imageEdges
    // @visibility roundCorners
    //<

    // Overlapping the Edges
    // ---------------------------------------------------------------------------------------

    //> @attr edgedCanvas.edgeOffset       (integer : null : [IRA])
    // Amount the contained Canvas should be offset.  Defaults to edgeSize; set to less than
    // edgeSize to allow the contained Canvas to overlap the edge and corner media.
    // @group imageEdges
    // @visibility roundCorners
    // @example edges
    //<

    //> @attr edgedCanvas.edgeOffsetTop    (integer : null : [IRA])
    // Amount the contained Canvas should be offset from the top.  Defaults to the size for
    // the top edge.  Set smaller to allow the contained Canvas to overlap the edge and
    // corner media.
    // @group imageEdges
    // @visibility roundCorners
    //<

    //> @attr edgedCanvas.edgeOffsetBottom (integer : null : [IRA])
    // Amount the contained Canvas should be offset from the bottom.  Defaults to the size for
    // the bottom edge.  Set smaller to allow the contained Canvas to overlap the edge and
    // corner media.
    // @group imageEdges
    // @visibility roundCorners
    //<

    //> @attr edgedCanvas.edgeOffsetLeft   (integer : null : [IRA])
    // Amount the contained Canvas should be offset from the left.  Defaults to the size for
    // the left edge.  Set smaller to allow the contained Canvas to overlap the edge and
    // corner media.
    // @group imageEdges
    // @visibility roundCorners
    //<

    //> @attr edgedCanvas.edgeOffsetRight  (integer : null : [IRA])
    // Amount the contained Canvas should be offset from the right.  Defaults to the size for
    // the right edge.  Set smaller to allow the contained Canvas to overlap the edge and
    // corner media.
    // @group imageEdges
    // @visibility roundCorners
    //<

    // ---------------------------------------------------------------------------------------

    //> @attr edgedCanvas.centerBackgroundColor (CSSColor : null : IR)
    // Background color for the center section only.  Can be used as a surrogate background
    // color for the decorated Canvas, if the Canvas is set to partially overlap the edges and
    // hence can't show a background color itself without occluding media.
    // @group imageEdges
    // @visibility roundCorners
    //<


});

isc.EdgedCanvas.addMethods({



initWidget : function () {
    this.invokeSuper(isc.EdgedCanvas, this._$initWidget);

    // NOTE: for simplicity, we always generate the same DOM structure.  The "shownEdges"
    // structure indicates which cells will have media, hence where margins have to be in order
    // to reveal the structure.

    // HACK 040913: friendlier public interface
    //    specify an array of sides to get the edge treatment
    //    reasons: shorter code, consistent with clippedCorners, avoids naming problem (ie that
    //    'edges' implies sides, not sides and corners), and enforces the current limitation that
    //    corners MUST be displayed for each side
    var customEdges = this.customEdges;
    if (customEdges) {
        var edges = this.shownEdges = {};
        if (customEdges.contains("T")) {
            edges.T = edges.TL = edges.TR = true;
        }
        if (customEdges.contains("B")) {
            edges.B = edges.BL = edges.BR = true;
        }
        if (customEdges.contains("L")) {
            edges.L = edges.TL = edges.BL = true;
        }
        if (customEdges.contains("R")) {
            edges.R = edges.TR = edges.BR = true;
        }
    }

    this.updateEdgeSizes();
},

updateEdgeSizes : function () {

    var edgeSize = this.edgeSize;

    this._leftEdge = this._firstNonNull(this.edgeLeft, edgeSize);
    this._rightEdge = this._firstNonNull(this.edgeRight, edgeSize);
    this._topEdge = this._firstNonNull(this.edgeTop, edgeSize);
    this._bottomEdge = this._firstNonNull(this.edgeBottom, edgeSize);

    // whether to show margin on side: rail with media on side always indicates a margin -
    // otherwise that rail could not possibly be shown.  Corner on side does not
    // necessarily indicate a margin, eg, in endcap case (tl t tr only), no right or left
    // margin.
    // Margins can be set independently of edges to allow the Canvas to overlap the edges.
    // NOTE: these margin settings are automatically picked up by the Canvas that owns us, and
    // added to its own margin settings to produce the native margin settings.
    var edges = this.shownEdges,
        marginSize = this.edgeOffset;
    if (edges.L) this._leftMargin =
        this._firstNonNull(this.edgeOffsetLeft, marginSize, this._leftEdge);
    if (edges.R) this._rightMargin =
        this._firstNonNull(this.edgeOffsetRight, marginSize, this._rightEdge);
    if (edges.T) this._topMargin =
        this._firstNonNull(this.edgeOffsetTop, marginSize, this._topEdge);
    if (edges.B) this._bottomMargin =
        this._firstNonNull(this.edgeOffsetBottom, marginSize, this._bottomEdge);

    this.markForRedraw(); // in case we're drawn
},

getInnerWidth : function (a,b,c) {
    var width = this.invokeSuper(isc.EdgedCanvas, "getInnerWidth", a,b,c);
    return width - this._leftMargin - this._rightMargin;
},

getInnerHeight : function (a,b,c) {
    var height = this.invokeSuper(isc.EdgedCanvas, "getInnerHeight", a,b,c);
    return height - this._topMargin - this._bottomMargin;
},

_emptyCellStart : "<TD class='",
_emptyCellEnd : "' ></TD>",

getInnerHTML : function () {

    // For minimum performance impact, we want to write HTML for the corners that
    // automatically reflows on resize.
    //
    // Most published methods of doing this rely on embedding content inside a containing
    // element with the borders arrayed around the edges, where the containing element
    // vertically stretches to accommodate content.  We can't feasibly use that approach
    // because abs pos content doesn't stretch the containing element, so we'd have to
    // force all Canvas children to be relatively positioned, so layout code would have to
    // take into account that each Canvas starts out offset by all previous Canvii - a
    // mess.
    //
    // So we need to write reflowable HTML that will simply fill its container.  This is
    // easy with a table; with CSS the only difficult aspect is writing the center pieces
    // so that they stretch.  Approaches:
    // - classic CSS 3 column layout: float or abs pos left and right pieces, put margins
    //   on center piece.
    //   - relies on the fact that a block-level element expands to fill horizontal space
    //     minus margins.  There is no analogous vertical technique; 100% height produces a
    //     DIV that's as tall as the container including margins
    // - use both a right and left coordinate, or top and bottom coordinate, to imply size
    //   - works in Moz.  IE6 respects right coordinate but not right with left (likewise
    //     bottom and top)
    //
    // A TABLE is the only way we know of to do this in IE6, with various workarounds the table
    // can be made to work on all platforms, and the HTML is much shorter.
    var output = isc.SB.create(),
        // image names
        baseURL = this.edgeImage,
        period = baseURL.lastIndexOf(isc.dot),
        name = baseURL.substring(0, period),
        extension = baseURL.substring(period),
        urlStart = this.getImgURL(name),
        cellStart = "<TD HEIGHT=",
        nonHeightStart = "<TD",
        mediaStart, mediaEnd,
        cellEnd;

    // setup cell HTML
    if (!isc.Browser.isIE10 &&

        !isc.Browser.isEdge &&

        !((isc.Browser.isStrict && isc.Browser.isIE && isc.Browser.version >= 8)
          || (isc.Browser.isMoz && isc.Browser.isUnix)
          )
        )
    {

    //if (isc.Browser.isSafari ||
    //    (isc.Canvas._fixPNG() && extension.toLowerCase() == ".png") || isc.Browser.isMoz) {
        // NOTE: on IE5.5+, calling imgHTML kicks in the PNG alpha loading workaround

        var imgProps = isc.EdgedCanvas._imgProps;
        if (!imgProps) {
            imgProps = isc.EdgedCanvas._imgProps = {
                width:"100%",
                height:"100%"
            };
            // Safari requires align != "texttop", otherwise each cell sizes to a minimum of a
            // text line height
            if (isc.Browser.isSafari) imgProps.align = "middle";
            // In Strict mode write images out as explicit display:block
            // This avoids a well documented issue where images inside table cells leave gaps
            // under them in strict mode
            if (isc.Browser.isStrict && !isc.Browser.isTransitional) {
                imgProps.extraCSSText = "display:block";
            }

            if (isc.Browser.isTouch) {
                imgProps.extraCSSText = ((imgProps.extraCSSText == null ? "" : imgProps.extraCSSText + ";") +
                                         "-webkit-touch-callout:none");
                imgProps.extraStuff = " oncontextmenu='javascript:return false;'";
            }
        }
        imgProps.src = baseURL;
        var imgHTML = this.imgHTML(imgProps);
        // In Safari (3.1.2 on Windows), 100% sized images will stretch correctly but will not
        // shrink below their native size -- enclose in a clip-div to handle this
        if (isc.Browser.isSafari) {
            imgHTML = "<DIV style='overflow:hidden;width:100%;height:100%'>" + imgHTML + "</DIV>";
        }
        var dotIndex = imgHTML.lastIndexOf(isc.dot);
        mediaStart = this._$rightAngle + imgHTML.substring(0, dotIndex);
        mediaEnd = imgHTML.substring(dotIndex);
        cellEnd = "</TD>";

        // NOTE: IE native drawing problems using PNG alpha filter directly on table cell:
        // HTML is correct, reported and visible sizes for cells are correct, but some cells,
        // at random, stretch PNG only partway across cell.  Meaningless native changes, like
        // setting a cell border to "" when it is already "", will correct some cells but not
        // others.
        //cellStart = "<TD STYLE='filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\""
        //    + urlStart + "_";
        //cellEnd = extension + "\",sizingMethod=\"scale\");'></TD>";
    } else {


        mediaStart = " STYLE='background:url(" + urlStart;
        mediaEnd = extension + ");"
        cellEnd = "'></TD>";
    }

    // incorporate edgeColor into image name if specified
    if (this.edgeColor) mediaStart += isc._underscore + this.edgeColor;

    var edges = this.shownEdges;


    var isRTL = this.isRTL(),
        leftEdge = isRTL ? this._rightEdge : this._leftEdge,
        rightEdge = isRTL ? this._leftEdge : this._rightEdge;
    output.append(this._$edgeTableStart,
                  leftEdge, this._$edgeColMid, rightEdge, this._$rightAngle,
                  "<TR HEIGHT=", this._topEdge, this._$rightAngle);

    this._writeEdgeCells(cellStart, this._topEdge, isc.px, mediaStart, mediaEnd, cellEnd, 0, 2, edges, output);

    var middleRowHeight = this.getHeight() - this._topEdge - this._bottomEdge;
    if (isc.Browser.isStrict && (isc.Browser.isIE || isc.Browser.isOpera)) {
        // write explicit size for IE strict, which will be updated on resize
        output.append("</TR><TR HEIGHT=", middleRowHeight, ">");
    } else {
        output.append("</TR><TR>");
    }

    if (isc.Browser.isMoz || isc.Browser.isWebKit) {
        this._writeEdgeCells(cellStart, middleRowHeight, isc.px, mediaStart, mediaEnd, cellEnd, 3, 5, edges, output);
    } else {
        this._writeEdgeCells(cellStart, null, isc.px, mediaStart, mediaEnd, cellEnd, 3, 5, edges, output);
    }

    output.append("</TR><TR HEIGHT=", this._bottomEdge, ">");

    this._writeEdgeCells(cellStart, this._bottomEdge, isc.px, mediaStart, mediaEnd, cellEnd, 6, 8, edges, output);

    output.append("</TR></TABLE>");

//    this.logWarn("output: " + output.toString());

    return output.release(false);
},

_$edgeTableStart : "<TABLE role='presentation' CELLPADDING='0' CELLSPACING='0' "
                        + "STYLE='height:100%;width:100%;table-layout:fixed'>"
                        + "<COL WIDTH=",
_$edgeColMid : "><COL><COL WIDTH=",
_$bgSizeArr:["background-size:", , ," ", , ,";"],

// params:
// cellStart/cellEnd: HTML for non-empty cells; edgeName will be inserted between
// start/end: range of edge names to output, inclusive
// edges: map of edges that will actually be output (otherwise, empty cell used)
// output: StringBuffer to append to
_$classEquals:" class=",
_writeEdgeCells : function (cellStart, height, heightUnit, mediaStart, mediaEnd, cellEnd, start, end, edges, output) {

    var allEdges = this.isRTL() ? this._allEdgesRTL : this._allEdges;


    var sizeBackgroundImage = isc.Browser.isIE9 || isc.Browser.isEdge;

    for (var i = start; i <= end; i++) {
        var edgeName = allEdges[i],
            backgroundSizingCSS  = null;
        if (sizeBackgroundImage && height != null) {
            if (this._leftEdges[edgeName]) {
                this._$bgSizeArr[1] = this._leftEdge;
                this._$bgSizeArr[2] = isc.px;
                this._$bgSizeArr[4] = height;
                this._$bgSizeArr[5] = heightUnit;
                backgroundSizingCSS = this._$bgSizeArr.join(isc.emptyString);
            } else if (this._rightEdges[edgeName]) {
                this._$bgSizeArr[1] = this._rightEdge;
                this._$bgSizeArr[2] = isc.px;
                this._$bgSizeArr[4] = height;
                this._$bgSizeArr[5] = heightUnit;
                backgroundSizingCSS = this._$bgSizeArr.join(isc.emptyString);
            } else if (edgeName != isc.Canvas.CENTER) {
                this._$bgSizeArr[1] = 100;
                this._$bgSizeArr[2] = this._$percent;
                this._$bgSizeArr[4] = height;
                this._$bgSizeArr[5] = heightUnit;
                backgroundSizingCSS = this._$bgSizeArr.join(isc.emptyString);
            }
        }

        var styleName = this.getEdgeStyleName(edgeName),
            classEquals = styleName ? this._$classEquals : null;

        if (edges[edgeName] || (this.showCenter && edgeName == isc.Canvas.CENTER)) {
            if (height != null) {
                output.append(cellStart, height, heightUnit);
            } else {
                output.append(cellStart, "''");
            }
            if (isc.Browser.isOpera) {

                if (edgeName == "TL" || edgeName == "L" || edgeName == "BL") {
                    output.append(" width=", this._leftEdge);
                } else if (edgeName == "TR" || edgeName == "R" || edgeName == "BR") {
                    output.append(" width=", this._rightEdge);
                }
            }
            output.append(classEquals, styleName,
                          mediaStart, this.getEdgePrefix(edgeName),
                          isc._underscore, edgeName,
                          // mediaEnd / backgroundSizingCSS will be null if not
                          // required.
                          mediaEnd, backgroundSizingCSS,
                          cellEnd);
        } else {
            if (this.centerBackgroundColor && edgeName == isc.Canvas.CENTER) {
                output.append("<TD ", classEquals, styleName, " style='background-color:",
                             this.centerBackgroundColor, "'></TD>");
            } else {
                output.append(this._emptyCellStart, classEquals, styleName,
                              this._emptyCellEnd);
            }
        }
    }
},


//> @attr EdgedCanvas.edgeStyleName (CSSStyleName : null : IRW)
// Optional property specifying the CSS ClassName to apply to the various parts of this edged canvas
// (top, bottom, corners, sides and center). To
// apply separate styles for each part, use +link{EdgedCanvas.addEdgeStyleSuffix}.
// @group imageEdgeStyles
// @group imageEdges
// @visibility external
//<

//> @attr EdgedCanvas.addEdgeStyleSuffix (Boolean : false : IRW)
// If specified, the +link{EdgedCanvas.edgeStyleName} will be treated as a base style name and
// appended with following suffixes to support separate styling per cell:
// <P>
// <code>_TL</code> (top left cell)<br>
// <code>_T</code> (top center cell)<br>
// <code>_TR</code> (top right cell)<br>
// <code>_L</code> (middle left cell)<br>
// <code>_C</code> (center cell)<br>
// <code>_R</code> (middle right cell)<br>
// <code>_BL</code> (bottom left cell)<br>
// <code>_B</code> (bottom center cell)<br>
// <code>_BR</code> (bottom right cell)
// @group imageEdgeStyles
// @group imageEdges
// @visibility external
//<
addEdgeStyleSuffix:false,


getEdgeStyleName : function (edge) {
    if (this.edgeStyleName == null) return;
    if (!this.addEdgeStyleSuffix) return this.edgeStyleName;

    if (!this._$edgeCellStyleMap || this._$edgeCellStyleMap.base != this.edgeStyleName) {
        var baseStyle = this.edgeStyleName;
        this._$edgeCellStyleMap = {
            base:baseStyle,
            TL:baseStyle + "_TL",
            T :baseStyle + "_T",
            TR:baseStyle + "_TR",
            L: baseStyle + "_L",
            C: baseStyle + "_C",
            R: baseStyle + "_R",
            BL:baseStyle + "_BL",
            B: baseStyle + "_B",
            BR:baseStyle + "_BR"
        }
    }
    return this._$edgeCellStyleMap[edge];
},

// this is essentially here to allow "depth" to be inserted by dropShadows, so not documented
// for now
getEdgePrefix : function (edgeName) { },

_handleResized : function () {

    if (!this.isDrawn() || this._suppressReactToResize) return;

    // HACK: very odd - without this, the bottom edge gets chopped off in Opera.  Using the IE
    // strict path below fixes initial rendering of overflowing edged canvases, but if the
    // canvas is subsequently resized, the bottom edge gets chopped off.
    if (isc.Browser.isOpera) {
        this.masterElement.bringToFront();
        return;
    }

    // update middle row for IE strict

    if (isc.Browser.isIE && isc.Browser.isStrict) {
        var middleRow = this.getHandle().firstChild.rows[1];
        this._assignSize(middleRow.style, this._$height,
                         this.getHeight() - this._topEdge - this._bottomEdge);
        return;
    }


    if (isc.Browser.isWebKit) {
        var middleRow = this.getHandle().firstChild.rows[1];
        var rowHeight = Math.max(0,this.getHeight() - this._topEdge - this._bottomEdge);
        for (var i = 0; i < middleRow.cells.length; i++) {
            //this.logWarn("assigning size to cell: " +
            //    (this.getHeight() - this._topEdge - this._bottomEdge) +
            //    " to: " + this.echoDOM(middleRow.cells[i]));
            this._assignSize(middleRow.cells[i].style, this._$height,
                             rowHeight);
        }
        return;
    }

    if (!isc.Browser.isMoz) return;

    // NOTE: Moz issues: even after being coddled with the unnecessary overflow:visible setting it
    // likes, and some redundant size specifications that avoid it borking itself on move, Moz
    // still needs one final smack to the head to get the size right: if there's media in the
    // central cell, Moz won't allow the table to get shorter than it is wide (wider than it is
    // tall is OK).  Setting a height on the central cell fixes this.  This needs to be done
    // after draw, redraw or resize.
    var middleCell = this.getHandle().firstChild.rows[1].cells[1],
        height = this.getHeight() - this._topEdge - this._bottomEdge;
    // don't assign to negative size - moz just ignores this
    if (height < 0) height = 0;
    //this.logWarn("assigning: " + height +
    //             " to " + this.echoLeaf(middleCell));
    this._assignSize(middleCell.style, this._$height, height);

    if (this.forceMozRowHeight) {
        var cells = middleCell.parentNode.cells;
        this._assignSize(cells[0].style, this._$height, height);
        this._assignSize(cells[2].style, this._$height, height);
    }

},
forceMozRowHeight:true,

layoutChildren : function (a,b,c) {
    var children = this.children;
    if (!children) return;


    isc.Canvas._instancePrototype.layoutChildren.call(this, a,b,c);
    //this.Super("layoutChildren", arguments);

    if (children.length == 0) return;

    var child = children[0];
    child.setRect(this._leftMargin, this._topMargin,
                  this.getInnerWidth(),
                  this.getInnerHeight());
},

addChild : function (a,b,c) {

    isc.Canvas._instancePrototype.addChild.call(this, a,b,c);
    //this.Super("addChild", arguments);
    this.layoutChildren("addChild");
},

draw : function (a,b,c,d) {

    if (!this.readyToDraw()) return this;
    // if we're acting as a peer, size now, since our master has drawn and sizes are available
    if (this.masterElement) {
        // if we, or one of our ancestors is relatively positioned, and the page
        // is not loaded, we likely have a native DOM ancestor that is not yet complete
        // (EG an open table cell tag).
        // This makes our reported sizing be incorrect. Catch this case and explicitly
        // call fitToMaster() on page load
        var me = this.masterElement,
            hasRelativeParent = false;
        while (me) {
            if (me.position == this._$relative) {
                hasRelativeParent = true;
                break;
            }
            me = me.parentElement;
        }
        if (!hasRelativeParent || isc.Page.isLoaded()) this.fitToMaster();
        else isc.Page.setEvent("load", this, isc.Page.FIRE_ONCE, "fitToMaster");
    }

    this.invokeSuper(isc.EdgedCanvas, "draw", a,b,c,d);
    this._handleResized(); // for Moz
    return this;
},


fitToMaster : function () {

    if (this.destroyed) return;

    var master = this.masterElement;

    // We want to ensure the master element's size is fully up to date.
    // If we're pending the initial adjustOverflow because the handle isn't fully rendered,
    // wait for it to complete and re-run this method.
    if (master._delayedAdjustOverflow) {
        isc.Timer.setTimeout({target:this, methodName:"fitToMaster"}, 200);
        return;
    // Otherwise if markForAdjustOverflow() was called, just adjustOverflow now.
    } else if (master._overflowQueued) {
        master.adjustOverflow();
    }

    var margins = master._getSpecifiedMargins();

    this.setRect( master.getOffsetLeft() + margins.left,
                  master.getOffsetTop() + margins.top,
                  Math.max(1, (master.getVisibleWidth() - margins.left - margins.right)),
                  Math.max(1, (master.getVisibleHeight() - margins.top - margins.bottom))
    );

},

redraw : function () {
    this.Super("redraw", arguments);
    this._handleResized(); // for Moz
    return this;
},

// when the master resizes, resize the edgedCanvas to fit the interior of this widgets *specified*
// margins
masterResized : function () {
    var master = this.masterElement;
    //>Animation If the master is animated show-ing / hide-ing, bail. We handle this case
    // specially in animated show/hide.
    if (this.masterElement.isAnimating([this._$show, this._$hide])) return;
    //<Animation


    var delay = isc.Browser.isSafari;

    if (delay) {
        this.delayCall("_sizeToMaster", [master]);
    } else {
        this._sizeToMaster(master);
    }
},

_sizeToMaster : function (master) {
    if (this.destroyed || master != this.masterElement) return;

    var margins = master._getSpecifiedMargins();

    this.resizeTo(Math.max(1, master.getVisibleWidth() - margins.left - margins.right),
                  Math.max(1, master.getVisibleHeight() - margins.top - margins.bottom));
},

// ---------------------------------------------------------------------------------------
setEdgeImage : function (edgeImage) {
    if (this.edgeImage == edgeImage) return;
    this.edgeImage = edgeImage;
    this.markForRedraw("setEdgeImage");
}

});

isc.defineClass("DropShadow", "EdgedCanvas").addProperties({
    _cosmetic: true,

    skinImgDir:"images/shared/shadows/",
    edgeImage:"[SKIN]ds.png",

    // never occlude anything in terms of events
    isMouseTransparent:true,

    // this is a bit redundant, but we can't simply flip on edges.center without affecting the
    // superclass structure
    shownEdges : {
            center:true,
            TL:true,
            T:true,
            TR:true,
            L:true,
            R:true,
            BL:true,
            B:true,
            BR:true
    },

    depth:4,

    initWidget : function () {
        this.setDepth(this.depth);
        this.Super(this._$initWidget);
    },

    setDepth : function (depth) {
        if (depth != null) this.depth = depth;

        var newSoftness = (this.softness || this.depth),
            softnessChange = this._softness != newSoftness;

        // auto-derive softness and offset from depth if not specified.  Use separate
        // properties so depth can be changed later and we won't think the properties were
        // developer-set
        this._softness = newSoftness;
        this.edgeSize = 2*this._softness;

        var defaultOffset = this._firstNonNull(this.offset, Math.round(this.depth/2));
        this._offsetX = this._firstNonNull(this.offsetX, defaultOffset);
        this._offsetY = this._firstNonNull(this.offsetY, defaultOffset);

        // XXX we need to call this to take into account new margin settings, but currently
        // this *always* marks for redraw
        this.updateEdgeSizes();

        // depth change implies a move, resize, and redraw
        if (this.isDrawn()) {
            this.masterMoved();
            // softness change means new media, so redraw

            if (softnessChange || this.isDirty()) this.redraw();
            this.masterResized();
        }
    },

    // add a center segment, which doesn't use the "depth" as a prefix
    getEdgePrefix : function (edgeName) {
        if (edgeName != isc.Canvas.CENTER) return this._softness;
    },

    // NOTE: fires on draw, and whenever the master moves
    masterMoved : function () {
        var hidden = this.visibility == isc.Canvas.HIDDEN,
            master = this.masterElement,
            left = master.getOffsetLeft(),
            top = master.getOffsetTop();
        if (!hidden) {
            left += this._offsetX - this._softness;
            top += this._offsetY - this._softness;
        }
        this.moveTo(left, top);
    },

    // NOTE: fires on draw, and whenever the master resizes
    masterResized : function () {

        // when we're hidden, we're always rendered at size 1x1 so we don't take up any space
        if (this.visibility == isc.Canvas.HIDDEN) return;

        var master = this.masterElement;
        //this.logWarn("masterResized called, master size: " +
        //             [master.getVisibleWidth(), master.getVisibleHeight()]
                     // + this.getStackTrace()
        //             );
        this.resizeTo(master.getVisibleWidth() + 2*this._softness,
                      master.getVisibleHeight() + 2*this._softness);
    },

    // Make 'fitToMaster' fall through to masterMoved(); masterResized()

    fitToMaster : function () {
        this.masterMoved();
        this.masterResized();
    },

    // Ensure that when hidden the shadow doesn't take up any space
    // Use setVisibility rather than show()/hide() as this method may be called directly
    setVisibility : function (vis, a,b,c,d) {
        var changed = (vis != this.visibility);
        this.invokeSuper(isc.DropShadow, "setVisibility", vis,a,b,c,d);

        if (changed) {
            if (vis == isc.Canvas.HIDDEN) {
                this.resizeTo(1,1);
                var master = this.masterElement;
                this.moveTo(master.getOffsetLeft(), master.getOffsetTop());
            } else {
                this.fitToMaster();
            }
        }
    },

    // dragResizeFromShadow behavior: dynamically set canDragResize based on the master's
    // canDragResize setting.
    getCurrentCursor : function (a,b,c,d) {
        var master = this.masterElement;
        if (master && master.dragResizeFromShadow) this.canDragResize = master.canDragResize;
        return this.invokeSuper(isc.DropShadow, "getCurrentCursor", a,b,c,d);
    },
    prepareForDragging : function (a,b,c,d) {
        var master = this.masterElement;
        if (master && master.dragResizeFromShadow) this.canDragResize = master.canDragResize;
        return this.invokeSuper(isc.DropShadow, "prepareForDragging", a,b,c,d);
    },

    // Avoid recursive shadows
    showShadow:false

});





//>    @class    Hover
// The Hover class handles showing a simple SmartClient canvas containing arbitrary HTML, or
// triggering some other action in response to a user holding the mouse-pointer (or hovering)
// over a specific widget.
//  @treeLocation Client Reference/Control
//  @visibility external
//<

// singleton that implements
//    -- hover timing
//    -- hover window display
//
// Hover.show() / Hover.hide() and some appearance management properties exposed to allow
// displaying / customizing content of hovers.
// Other Hover APIs exist at the widget level, enabling custom actions in response to hover
// events.


isc.ClassFactory.defineClass("Hover");


isc.Hover.addClassProperties({
    // This delay is a default - may be overridden via the optional delay param passed to
    // setAction()

    delay:500,
    //timer:null,

    //action:null,
    //actionArgs:null,
    //actionTarget:null,

    //isActive:false,

    //>@classAttr Hover.moveWithMouse (boolean : false : RWA)
    // When the Hover canvas is shown by default, should it move as the user moves the
    // mouse pointer?<br>
    // May be overridden by including a <code>moveWithMouse</code> attribute on the
    // properties block passed to +link{Hover.show()}
    // @visibility external
    //<
    //moveWithMouse:false,

    //>@classAttr Hover.leftOffset (number : 15 : RW)
    // When positioning the hover canvas, this will be the default left offset from the
    // mousepointer, if no explicit position was passed to the +link{Hover.show()} method
    // @visibility external
    //<
    leftOffset:15,

    //>@classAttr Hover.topOffset (number : 15 : RW)
    // When positioning the hover canvas, this will be the default top offset from the
    // mousepointer, if no explicit position was passed to the +link{Hover.show()} method
    // @visibility external
    //<
    topOffset:15,

    //>    @classAttr    canvas.hoverCanvas        (Canvas : null : RA)
    // Reference to the hoverCanvas currently visible.  Null if none.
    //<

    //hoverCanvas:null,

    //>    @classAttr    Hover.hoverCanvasDefaults   (object: {...} : IRW)
    // Defaults to apply to the Hover canvas shown when the user hovers over some widget.
    // By default this property is set to this object:<br><pre>
    //       { defaultWidth:100,
    //         defaultHeight:1,
    //         baseStyle:"canvasHover",
    //         align:"left",
    //         valign:"top",
    //         opacity:null
    //        }
    // </pre><br>
    // Note that these properties can be overridden by individual widgets showing hovers, by
    // modifying +link{canvas.hoverWidth}, +link{canvas.hoverHeight},
    // +link{canvas.hoverStyle}, +link{canvas.hoverAlign}, +link{canvas.hoverVAlign},
    // +link{canvas.hoverOpacity}, and +link{canvas.hoverWrap}.
    // @visibility external
    //<
    hoverCanvasDefaults:{
        defaultWidth:100,
        defaultHeight:1,

        baseStyle:"canvasHover",
        align:isc.Canvas.LEFT,
        valign:isc.Canvas.TOP,
        wrap:true,

        autoDraw:false

    }
});


isc.Hover.addClassMethods({

//>    @classMethod Hover.show()
// Displays a standard Hover canvas containing the specified HTML content.<br>
// This method may also be called to modify the content of the hover if it is already showing.
// Call +link{Hover.hide()} to hide the canvas again.<br>
// A common use case for calling this method is to asynchronously fetch detail data from the
// server about some component, and display it in the Hover canvas when the data is returned.
// Note that in this case you will typically need to verify that the user is still hovering
// over the component in question before calling Hover.show() - if the user has moved the mouse
// off the component, the information will not apply to whatever is now under the mouse.
// Suggested approaches for handling this are to either use a +link{Canvas.mouseOut()} handler
// to track when the user moves off the component, or checking +link{EventHandler.getTarget()}
// as part of the asynchronous callback
// <p>
// The default Hover canvas position will be based on the mouse pointer position, adjusted by
// +link{Hover.leftOffset} and +link{Hover.topOffset}. If this position would render the
// Hover canvas partially clipped, it will be automatically modified to ensure the Hover
// is entirely visible.
// @param contents (HTMLString | Canvas) contents for the hover
// @param properties (Label Properties) object containing attributes for managing the hover canvas'
//  appearance. Valid properties include:<ul>
//  <li>left, top, width, height
//  <li>baseStyle
//  <li>opacity
//  <li>wrap
//  <li>moveWithMouse [overrides +link{Hover.moveWithMouse}]
// </ul>
//
// @visibility external
//<
// @param rect (object) boundary rectangle along which the hoverCanvas should be drawn; if
//     left and top are specified in properties, this parameter is ignored
// @param [targetCanvas] (Canvas) Passed in by canvas.showHover() - allows us to track which canvas
//     showed the hover and handle cases such as that canvas being destroyed etc.
show : function (contents, properties, rect, targetCanvas) {

    if (isc.isA.Canvas(contents)) {
        // we've been passed a Canvas as content for the hover - this will now become the
        // hoverCanvas, rather than being the content for a newly created hoverCanvas
        this.showingHoverComponent = true;
        this.hoverCanvas = contents;
        this.hoverCanvas.hide = function () {
            this.Super("hide", arguments);
            isc.Hover.hoverCanvasHidden();
        };
        if (targetCanvas != null) {
            targetCanvas.hoverCanvas = contents;
        }
    }

    // position and show hoverCanvas with contents & properties
    if (!this.hoverCanvas) this._makeHoverCanvas();

    var hoverCanvas = this.hoverCanvas;

    // check parameters
    if (contents == null || contents == "") {
        hoverCanvas.hide();
        return;
    }

    if (this._hideOnMouseDownEvent) {
        isc.Page.clearEvent("mouseDown", this._hideOnMouseDownEvent);
    }
    if (targetCanvas && targetCanvas.hideHoverOnMouseDown) {
        this._hideOnMouseDownEvent = isc.Page.setEvent(
            "mouseDown",
            this,
            "once",
            "hideHoverOnMouseDown"
        );
    }

    // remember which target showed the canvas
    // (Cleared on hoverCanvas.hide())
    this.lastHoverCanvas = targetCanvas;

    // set the hover to display the new contents
    if (!this.showingHoverComponent) hoverCanvas.setContents(contents);
    if (properties == null) properties = {};

    // Apply the properties to the hoverCanvas (except for positioning props)

    var defaults = this.hoverCanvasDefaults;
    if (hoverCanvas.setAlign) hoverCanvas.setAlign(properties.align || defaults.align);
    if (hoverCanvas.setVAlign) hoverCanvas.setVAlign(properties.valign || defaults.valign);
    if (hoverCanvas.setBaseStyle) hoverCanvas.setBaseStyle(properties.baseStyle || defaults.baseStyle);
    if (hoverCanvas.setOpacity) hoverCanvas.setOpacity(properties.opacity || defaults.opacity);
    if (hoverCanvas.setWrap) hoverCanvas.setWrap(properties.wrap != null ? properties.wrap : defaults.wrap);

    // Should we move the hover canvas around with the mouse
    if (properties.moveWithMouse != null) this._shouldMoveWithMouse = properties.moveWithMouse
    else this._shouldMoveWithMouse = this.moveWithMouse;

    // set properties of new hoverCanvas.
    // placement: by default, offset from mouse (no occlusion by mouse), and on-screen (if
    //            possible).  Can be modified by the caller with attributes of the properties
    //            parameter.
    // note that all properties set here (aside from left/top) must be set back to defaults in
    // Hover.hide()
    var lastX = isc.EH.getX(),
        lastY = isc.EH.getY(),
        left = properties.left,
        top = properties.top,
        // NOTE: boolean check OK because width and height can't validly be zero
        width = properties.width || (this.showingHoverComponent ? hoverCanvas.width : defaults.defaultWidth),
        height = properties.height || (this.showingHoverComponent ? hoverCanvas.height : defaults.defaultHeight);

    // If either left or top is specified in the arguments to Hover.show(), respect them and don't
    // use Canvas._placeRect to adjust the position of the hover
    if (left != null || top != null) {
        // default left and top if they weren't specified in the properties argument
        left = left ? left : lastX + this.leftOffset;
        top = top ? top : lastY + this.topOffset;
    } else {

        //this.logWarn("sizing hover to: " + [width, height]);
        hoverCanvas.setRect(null, -9999, width, height);
        if (!hoverCanvas.isDrawn()) hoverCanvas.draw();
        // Has to be visible as when we hide a shadow we shift it so it sits UNDER the widget.
        if (!hoverCanvas.isVisible()) hoverCanvas.show();
        else hoverCanvas.redrawIfDirty("placing hover");
        // Use '_placeRect' to position the hover next to a boundary rectangle with the mouse
        // pointer as its center, a width of 2 * this.leftOffset and a height of 2*
        // this.topOffset
        var avoidRect = rect ? rect : [lastX - this.leftOffset, lastY - this.topOffset,
                                       2 * this.leftOffset, 2 * this.topOffset];
        // call getPeerRect() to take into account dropShadow.  NOTE: technically if the hover
        // had peers to the left/top expanding the peer rect, we would need to place the hover
        // itself to the right/bottom of the position returned by placeRect()
        var hoverRect = hoverCanvas.getPeerRect();
        var pos = isc.Canvas._placeRect(hoverRect[2], hoverRect[3], avoidRect,
            "bottom", false, "outside-right"
        );
        left = pos[0];
        top = pos[1];
    }
    hoverCanvas.setRect(left, top, width, height);
    hoverCanvas.bringToFront();

    // show the hoverCanvas
    if (!hoverCanvas.isDrawn() || !hoverCanvas.isVisible()) hoverCanvas.show();

    // set a page-level mouseMove handler to move the hoverCanvas
    if (this._shouldMoveWithMouse) {
        this._mouseMoveHandler =
            isc.Page.setEvent("mouseMove", function () { isc.Hover._moveWithMouse() });
    }

    return;
},

hideHoverOnMouseDown : function () {
    delete this._hideOnMouseDownEvent;
    this.hide();
},

// notification fired from the hover canvas on hide
hoverCanvasHidden : function () {
    var lhc = this.lastHoverCanvas;
    delete this.lastHoverCanvas;
    if (lhc != null) {
        // call an internal method so we can auto-destroy hover components with
        // hoverAutoDestroy: true before calling the generic notification method
        lhc._hoverHidden();
    }
    if (this._hideOnMouseDownEvent) {
        isc.Page.clearEvent("mouseDown", this._hideOnMouseDownEvent);
        delete this._hideOnMouseDownEvent;
    }
},


//> @classMethod Hover.hide()
// Hide hover hover Canvas shown via +link{Hover.show()}
// @visibility external
//<
hide : function () {
    var hoverCanvas = isc.Hover.hoverCanvas;
    if (hoverCanvas != null) {

        // clear the page-level mouseMove handler that moves the hoverCanvas
        if (this._mouseMoveHandler) {
            isc.Page.clearEvent("mouseMove", this._mouseMoveHandler);
            delete this._mouseMoveHandler;
        }

        // hide the hoverCanvas - if the canvas was flagged with hoverAutoDestroy: true, it
        // is destroyed by the owning canvas at this point
        hoverCanvas.hide();

        if (this.showingHoverComponent) {
            if (!hoverCanvas) return;
            delete this.hoverCanvas;
            this.showingHoverComponent = false;
        } else {

            // move the hover offscreen to prevent page-level scrollbars if the hover extends out
            // of the page.
            var defaults = this.hoverCanvasDefaults;
            hoverCanvas.setRect(0, -1000);
        }
    }
},


_makeHoverCanvas : function () {

    var defaults = isc.addProperties({
        hide : function () {
            this.Super("hide", arguments);
            isc.Hover.hoverCanvasHidden();
        }
    }, this.hoverCanvasDefaults);

    this.hoverCanvas = isc.Label.create(defaults);

},

_moveWithMouse : function () {
    // call getPeerRect to take into account dropShadow
    var hoverRect = this.hoverCanvas.getPeerRect();
    var pos = isc.Canvas._placeRect(
        hoverRect[2], hoverRect[3],
        this.getMousePointerRect(), "bottom", false, "outside-right"
    );
    this.hoverCanvas.moveTo(pos[0], pos[1]);
},

// Return a rectangle suitable for use as the bounding rectangle along which the hover should
// be drawn.
//
// Center point of the rectangle is the pointer location, and it extends in each direction a
// length equal to the offset along the axis (so the height = 2 * topOffset,
// width = 2 * leftOffset)
getMousePointerRect : function () {
    return [
        isc.EH.getX() - this.leftOffset,
        isc.EH.getY() - this.topOffset,
        2 * this.leftOffset,
        2 * this.topOffset
    ];
},

//>    @classMethod Hover.setAction()
//        sets the action to be executed by the hover window
//
//        @param target (object) object to which action belongs (defaults to Hover).
//        @param action (method) action to be executed when timer has elapsed.
//        @param actionArgs (array) arguments for action method.
//      @param [delay] (number) optional ms delay to apply to the hover action
//<
setAction : function (target, action, actionArgs, delay) {
    if (delay == null) delay = this.delay;
    // if already active or no delay, apply action immediately
    if (this.isActive || delay == 0) {
        // see note below about IE JS errors with empty args
        action.apply((target ? target : this), actionArgs ? actionArgs : []);
        this.isActive = true;
    }
    // otherwise set up a delayed action
    else {
        if (this.timer != null) this.timer = isc.Timer.clear(this.timer);
        this.actionTarget = (target ? target : this);
        this.action = action;

        this.actionArgs = actionArgs ? actionArgs : [];
        // maybe check actionTime in _doAction()
        // this.actionTime = timeStamp() + this.delay;
        this.timer = isc.Timer.setTimeout({target:isc.Hover, methodName:"_doAction"}, delay);
    }
},


_doAction : function () {
    if (this.action && !this.actionTarget.destroyed) {
        this.action.apply(this.actionTarget, this.actionArgs);
    }
    this.actionTarget = this.action = this.actionArgs = null;
    this.isActive = true;
},

//> @classMethod Hover.clear()
// If the hover canvas is currently showing, hides it via +link{Hover.hide()}
// If a hover action was set up via +link{Hover.setAction()}, clear this pending action now.
//<
clear : function () {
    this.hide();
    if (this.timer != null) this.timer = isc.Timer.clear(this.timer);
    this.actionTarget = this.action = this.actionArgs = null;
    this.isActive = false;
}


});







//
//    Comm.serialize() methods for the comm package
//

// XXX this package must not be dependant on the Comm package, because serialization is a useful
// feature completely apart from Comm.  Unfortunately, the methods are currently expected to be on
// the Comm class, so if the Comm class doesn't exist we need to define it.
if (!isc.Comm) isc.ClassFactory.defineClass("Comm");

isc.Comm.addClassProperties( {
    //>    @classAttr    Comm._simpleIdentifierRE (regex : /^[\$_a-zA-Z][\$\w]*$/ : IR)
    //            Regular expression to match legal identifier names so we can
    //             avoid unnecessary quotes when serializing.
    //        @group    serialization
    //<
    _simpleIdentifierRE :     /^[\$_a-zA-Z][\$\w]*$/,

    //>    @classAttr    Comm.BACKREF_PREFIX (string : "$$BACKREF$$:" : IR)
    //            Prefix for back-references in serialized object references.
    //        @group    serialization
    //<
    BACKREF_PREFIX : "$$BACKREF$$:",

    indent : "    "


});


isc.Comm.addClassMethods({

//>    @classMethod    Comm.serialize()
// Serialize an object of any type into a string, in a form that
// can be simply eval'd to rebuild the original object.
//
//        @group    serialization
//
//        @param    object        (any)        object to be serialized
//        @param    [indent]    (boolean)    should output be formatted with line breaks and indenting
//                                      for readability? If unspecified, indenting occurs if
//                                      +link{JSONEncoder.prettyPrint} is true.
//        @return                (string)    serialized form of the object
//<

serialize : function (object, indent) {
    var props = { strictQuoting:false, dateFormat:"logicalDateConstructor"};

    // if indent was explicitly specified, respect it
    if (indent != null) props.prettyPrint = indent;
    return isc.JSON.encode(object, props);
}

});    // END isc.addMethods(isc.Comm, {})

//> @class JSON
// Utilities for working with JSON data.
//
// @treeLocation Client Reference/Data Binding
// @visibility external
//<
isc.ClassFactory.defineClass("JSON", null, null, true);
isc.JSON.addClassProperties({
//> @classMethod JSON.encode()
// Serialize an object as a JSON string by creating a +link{JSONEncoder} and calling
// +link{JSONEncoder.encode()}.
// <P>
// Note that using the String produced by this API with +link{JSON.decode()} <b>will not
// successfully preserve dates</b>.  Use +link{JSONEncoder.dateFormat} "dateConstructor" or
// "logicalDateConstructor" to have dates round-trip properly.
//
// @param object (any) object to serialize
// @param [settings] (JSONEncoder Properties) optional settings for encoding
// @return (String) object encoded as a JSON String
// @visibility external
//<
encode : function (object, settings) {
    return isc.JSONEncoder.create(settings).encode(object);
},

//> @classMethod JSON.decode()
// De-serialize an object from JSON.  Currently, this is simply a JavaScript eval() and should
// be used for trusted data only.
//
// @param jsonString (String) JSON data to be de-serialized
// @return (Object) object derived from JSON String
// @visibility external
//<
decode : function (jsonString) {
    //!OBFUSCATEOK
    // Add parens to the JSON to avoid
    // an issue where eval() gets confused and believes it is dealing with a block
    return eval("(" + jsonString + ")");
}
});

//> @class JSONEncoder
// Class for encoding objects as JSON strings.
// @treeLocation Client Reference/Data Binding
// @visibility external
//<
isc.ClassFactory.defineClass("JSONEncoder");
isc.JSONEncoder.addClassProperties({

//>    @classMethod    JSONEncoder._serialize_remember()    (A)
//            Remember an object that has just been serialized it, so we don't
//             attempt to serialize it again (and thus get into an endless loop).
//        @group    serialization
//
//        @param    objRefs    (object[])    array of objects that have been serialized already so
//        @param    object    (any)        object o serialize
//        @param    path    (string)    global variable path to this object, for serializing object references
//<
// helper function to remember that we've already output a particular object in this serialize pass
_serialize_remember : function (objRefs, object, path) {
    if (objRefs && objRefs.obj && objRefs.obj.add) objRefs.obj.add(object);
    if (objRefs && objRefs.path && objRefs.path.add) objRefs.path.add(path);
},

// If this object is a Tree node, automatically clean off properties that the Tree adds to the
// node that should not be saved.

_serialize_cleanNode : function (object) {
    var treeId = object["_isc_tree"];
    if (treeId != null) {
        var theTree = window[treeId];
        if (theTree && theTree.parentProperty && object[theTree.parentProperty]) {
            object = theTree.getCleanNodeData(object);
        }
    }
    return object;
},

// Have we already output a particular object in this serialize pass? If so, return the path to
// that object.
_serialize_alreadyReferenced : function (objRefs, object) {
    var rowNum = objRefs.obj.fastIndexOf(object);
    if (rowNum == -1) return null;
    return objRefs.path[rowNum];
},

// Add a new identifier to an object path, used to build the path passed in to _serialize() above.
_serialize_addToPath : function (objPath, newIdentifier) {
    if (isc.isA.Number(newIdentifier)) {
        return objPath + "[" + newIdentifier + "]";
    } else if (! isc.Comm._simpleIdentifierRE.test(newIdentifier)) {
        return objPath + '["' + newIdentifier + '"]';
    } else {
        return objPath + "." + newIdentifier;
    }
}
});

isc.JSONEncoder.addProperties({
//> @method JSONEncoder.encode()
// Serialize an object as a JSON string.
// <P>
// Automatically handles circular references - see +link{JSONEncoder.circularReferenceMode}.
// <smartgwt>
// <P>
// Because GWT does not support Java reflection, JSON encoding cannot discover the properties
// of an arbitrary Java POJO.  The following objects are supported:
// <ul>
// <li> any primitive type (String, Date, Number, Boolean)
// <li> any Map or Collection in any level of nesting
// <li> DataClass (Record's superclass) and RecordList
// <li> any widget (see +link{JSONEncoder.serializeInstances})
// <li> JavaScriptObject
// <li> an Array containing any of the above
// </ul>
// </smartgwt>
// <P>
// Note that using the String produced by this API with +link{JSON.decode()} <b>will not
// successfully preserve dates</b>.  Use +link{JSONEncoder.dateFormat} "dateConstructor" or
// "logicalDateConstructor" to have dates round-trip properly.
//
// @param object (any) object to serialize
// @return (String) object encoded as a JSON String
// @visibility external
//<
encode : function (object) {
    this.objRefs = {obj:[],path:[]};
    var retVal = this._serialize(object, this.prettyPrint ? this.leadingIndent || "" : null , null);
    this.objRefs = null;
    return retVal
},

//> @type JSONDateFormat
// Format for encoding dates in JSON.  Note you can override +link{JSONEncoder.encodeDate()}
// for a custom format.
//
// @value "xmlSchema" dates are is encoded as a String in <a target=_blank
//        href="http://www.w3.org/TR/xmlschema-2/#dateTime">XML Schema date format</a> in UTC,
//        for example, "2005-08-02" for logical date fields or "2005-08-01T21:35:48.350"
//        for <code>datetime</code> fields. See +link{group:dateFormatAndStorage,Date format and
//        storage} for more information.
// @value "dateConstructor" dates are encoded as raw JavaScript code for creating a Date object,
//        that is:
//        <pre>
//        new Date(1238792738633)
//        </pre>
//        This is not strictly valid JSON, but if eval()d, will result in an identical date object,
//        regardless of timezone.  However, it does not preserve the distinction between
//        logical dates vs full datetime values - use "logicalDateConstructor" mode for that.
// @value "logicalDateConstructor" serializes Date instances in a way that preserves the
//        distinction between logical dates, logical times, and full datetime values, as
//        explained +link{group:dateFormatAndStorage,here}.  Like 'dateConstructor' mode, this
//        does not produce strictly valid JSON, and instead embeds JavaScript calls.
//        <p>
//        In addition, unlike 'dateConstructor' mode, using eval() to reconstruct the original
//        JavaScript objects will only work in the presence of SmartClient, and not just in a
//        generic JavaScript interpreter.
//
// @visibility external
//<



//> @type JSONInstanceSerializationMode
// Controls the output of the JSONEncoder when instances of SmartClient classes (eg a ListGrid)
// are included in the data to be serialized.
//
// @value "long" instances will be shown as a specially formatted JSON listing the most
//               relevant properties of the instance. Result is not expected to
//               decode()/eval() successfully if instances are included.
// @value "short" instances will be shown in a shorter format via a call to +link{isc.echoLeaf()}.
//                Result is not expected to decode()/eval() successfully if instances are
//                included.
// @value "skip" no output will be shown for instances (as though they were not present in the
//               data).  Result should decode()/eval() successfully (depending on other
//               settings)
//
// @visibility external
//<


//> @attr JSONEncoder.serializeInstances (JSONInstanceSerializationMode : "long" : IR)
// Controls the output of the JSONEncoder when instances of SmartClient classes (eg a ListGrid)
// are included in the data to be serialized.  See +link{JSONInstanceSerializationMode}.
// <P>
// Note that the JSONEncoder does not support a format that will recreate the instance if
// passed to decode() or eval().
//
// @visibility external
//<
serializeInstances: "long",

//> @attr JSONEncoder.skipInternalProperties    (Boolean : false : IR)
// If true, don't show SmartClient internal properties when encoding and object.
// @visibility external
//<

//> @attr JSONEncoder.showDebugOutput (Boolean : false : IR)
// If objects that cannot be serialized to JSON are encountered during serialization, show a
// placeholder rather than just omitting them.
// <P>
// The resulting String will not be valid JSON and so cannot be decoded/eval()'d
// @visibility external
//<


//> @attr JSONEncoder.dateFormat (JSONDateFormat : "xmlSchema" : IR)
// Format for encoding JavaScript Date values in JSON.  See +link{type:JSONDateFormat} for
// valid options, or override +link{JSONEncoder.encodeDate()} to do something custom.
// @visibility external
//<
dateFormat: "xmlSchema",

//> @method JSONEncoder.encodeDate()
// Encode a JavaScript Date value.
// <P>
// By default, follows the +link{JSONEncoder.dateFormat} setting.  <smartclient>Override to do
// custom encoding.</smartclient><smartgwt>To override the date format, all Dates should be
// converted to Strings beforehand.</smartgwt>
//
// @param theDate (Date) JavaScript date object to be serialized
// @return (String) value to be included in result.  <b>If this value is intended to appear
//                  as a String it should include quotes (")</b>
//
// @visibility external
//<
encodeDate : function (date) {
    // If we were handed a date from some other window without our extensions on it,
    // duplicate it.
    if (!date.toSchemaDate) {
        var newDate = new Date(date.getTime());
        // Unlikely to be set for a date picked up from another frame, but respect logical
        // date/time flags if present.
        newDate.logicalDate = this.logicalDate;
        newDate.logicalTime = this.logicalTime;
        date = newDate;
    }
    if (this.dateFormat == "dateConstructor") {
        return date._serialize();
    } else if (this.dateFormat == "logicalDateConstructor") {
        // SC-dependent - uses createLogicalDate/createLogicalTime
        if (date.logicalTime) {
            return "isc.Time.createLogicalTime(" + date.getHours() + ", " +
                date.getMinutes() + ", " + date.getSeconds() + ", " + date.getMilliseconds() +
                ")";
        } else if (date.logicalDate) {
            return "isc.DateUtil.createLogicalDate(" + date.getFullYear() + ", " +
                date.getMonth() + ", " + date.getDate() + ")";
        } else {
            return date._serialize();
        }
    } else { // quotes for xml schema
        return '"' + date.toSchemaDate(null, this.trimMilliseconds) + '"';
    }
},

//> @attr JSONEncoder.escapeNonPrintable (Boolean : true : IRW)
// By default, obscure non-printable characters such as DC3 (Device Control 3, U+0013 hexadecimal)
// will be escaped according to JSON standards. ECMA-404 / The JSON Data Interchange Format
// requires the quotation mark (U+0022), reverse solidus (U+005C), and control characters (U+0000
// through U+001F) to be escaped.
// <p>
// These characters are very rarely used in JSON data in web applications.  If you know that
// your application does not use such characters in JSON data, there can be a performance
// advantage to setting <code>escapeNonPrintable</code> to false in order to disable the
// logic for escaping these characters.  This is a detectable difference only when dealing
// with very large JSON structures on older browsers that do not provide native support (for
// example, Internet Explorer 8).
// @visibility external
//<
escapeNonPrintable: true,

//> @attr JSONEncoder.strictQuoting (Boolean : true : IR)
// Whether all property names should be quoted, or only those property names that are not valid
// identifiers or are JavaScript reserved words (such as "true").
// <P>
// Encoding only where required produces slightly shorter, more readable output which is still
// compatible with JavaScript's eval():
// <pre>
// {
//     someProp : "someValue",
//     "true" : "otherValue",
//     otherProp : "otherValue"
// }
// </pre>
// .. but is not understood by many server-side JSON parser implementations.
// @visibility external
//<
strictQuoting: true,

//> @type JSONCircularReferenceMode
// What the +link{JSONEncoder} should do when it encounters a circular reference in an object
// structure.
// @value "omit" circular references in Arrays will be represented as a null entry, and objects
//               will have a property with a null value
// @value "marker" leave a string marker, the +link{jsonEncoder.circularReferenceMarker},
//                 wherever a circular reference is found
// @value "path" leave a string marker <i>followed by</i> the path to the first occurrence of
//               the circular reference from the top of the object tree that was serialized.
//               This potentially allows the original object graph to be reconstructed.
// @visibility external
//<

//> @attr JSONEncoder.circularReferenceMode (JSONCircularReferenceMode : "path" : IR)
// What the JSONEncoder should do if it encounters a circular reference.
//
// @visibility external
//<
circularReferenceMode: "path",

//> @attr JSONEncoder.circularReferenceMarker (String : "$$BACKREF$$" : IR)
// The string marker used to represent circular references.  See +link{circularReferenceMode}.
//
// @visibility external
//<
circularReferenceMarker: "$$BACKREF$$",

//> @attr JSONEncoder.prettyPrint (Boolean : true : IR)
// Whether to add indentation to the returned JSON string.  This makes the returned JSON much
// easier to read but adds size.  Note that when delivering JSON responses compressed, the size
// difference between prettyPrinted JSON and normal JSON is negligible.
// @visibility external
//<
prettyPrint: true,

//>    @method    JSONEncoder._serialize()    (A)
//        Internal routine that actually does the serialization.
//        @group    serialization
//
//        @param    object    (any)        object to serialize
//        @param    prefix    (string)    string to put before each line of serialization output
//        @param    context (object)    context that tracks previously encountered objects and
//                                  settings
//
//        @return    (string)            serialized object as a string
//<
_serialize : function (object, prefix, objPath) {

    // Avoid attempting to manipulate SGWT Java objects
    if (isc.Browser.isSGWT && window.SmartGWT.isNativeJavaObject(object)){

        if (object == null) object = null;
        // If the global flag has been set to warn when we hit an unconvertible
        // object, do this.
        else {
            if (window.SmartGWT.warnOnSerializeError) {
                window.SmartGWT.throwUnconvertibleObjectException(
                    object, window.SmartGWT.serializeErrorMessage
                );
            }
            object = String.asSource(object + "");
        }
        return object;
    }

    //if (this.autoDupMethods) this.duplicateMethod("_serialize");

    if (!objPath) {
        if (object && isc.isA.Function(object.getID)) objPath = object.getID();
        else objPath = "";
    }

    if (object == null) return null;

    // handle simple types
    // call the static version of the same method if this happens.
    if (isc.isA.String(object)) {
        if (this.escapeNonPrintable) {
            return String.asJSONString(object);

        // In Safari a cross-frame scripting bug means that the 'asSource' method may not always be
        // available as an instance method.
        } else {
            return object.asSource != null ? object.asSource() : String.asSource(object);
        }
    }
    if (isc.isA.Function(object)) return null;
    if (isc.isA.Number(object) || isc.isA.SpecialNumber(object)) return object;
    if (isc.isA.Boolean(object)) return object;
    if (isc.isA.Date(object)) return this.encodeDate(object);

    // handle instances (and class objects)
    if (isc.isAn.Instance(object) || isc.isA.Class(object)) {
        if (this.serializeInstances == "skip") return null;
        else if (this.serializeInstances == "short") return isc.echoLeaf(object);
        // else "long".. fall through to logic below to have properties output
    }

    // for complex types:
    // detect infinite loops by checking if we've seen this object before.
    // To disambiguate between true loops vs the same leaf object being encountered twice
    // (such as a simple Array containing two Strings which appears in two spots).  Only
    // consider this a loop if the preceding occurrence of the object was some parent of
    // ours.
    var prevPath = isc.JSONEncoder._serialize_alreadyReferenced(this.objRefs, object);

    if (prevPath != null && objPath.contains(prevPath)) {

        // Note: check that the first char after "prevPath" is a path separator char in order
        // to avoid false loop detection with "prop" and "prop2" having the same non-looping
        // object (since "prop2" contains "prop").
        var nextChar = objPath.substring(prevPath.length, prevPath.length+1);
        //this.logWarn("backref: prevPath: " + prevPath + ", current: " + context.objPath +
        //             ", char after prevPath: " + nextChar);
        if (nextChar == "." || nextChar == "[" || nextChar == "]") {
            var mode = this.circularReferenceMode;
            if (mode == "marker") {
                return "'" + this.circularReferenceMarker + "'";
            } else if (mode == "path") {
                return  "'" + this.circularReferenceMarker + ":" + prevPath + "'";
            } else {
                return null;
            }
        }
    }

    if (object == window) {
        this.logWarn("Serializer encountered the window object at path: " + objPath
                    +" - returning null for this slot.");
        return null;
    }

    // add the object to the list of objRefs so we can avoid an endless loop, only if it is
    // not already there
    if (prevPath == null) isc.JSONEncoder._serialize_remember(this.objRefs, object, objPath);

    // if there is a serialize method associated with this object, call that
    if (isc.isA.Function(object._serialize)) return object._serialize(prefix, this.objRefs, objPath, prefix);

    // handle arrays as a special case
    if (isc.isAn.Array(object))    return this._serializeArray(object, objPath, this.objRefs, prefix);

    var data;
    // if the object has a getSerializeableFields, use whatever it returns, otherwise just use the object
    if (object.getSerializeableFields) {

        data = object.getSerializeableFields([], []);
    } else {
        data = object;
    }
    // and return anything else as a simple object
    return this._serializeObject(data, objPath, this.objRefs, prefix);
},

//>    @method    JSONEncoder._serializeArray()    (A)
//            Internal routine to serialize an array.
//        @group    serialization
//
//        @param    object    (any)        object o serialize
//        @param    objPath    (string)    global variable path to this object, for serializing object references
//        @param    objRefs    (object[])    array of objects that have been serialized already so
//                                     we don't get into endless loops
//        @param    prefix    (string)    string to put before each line of serialization output
//
//        @return    (string)            serialized object as a string
//<
_serializeArray : function (object, objPath, objRefs, prefix) {
    // add the start array marker
    var output = isc.SB.create();
    output.append("[");
    // for each element in the array
    for (var i = 0, len = object.length; i < len; i++) {
        var value = object[i];
        // output that element
        if (prefix != null) output.append("\n", prefix, isc.Comm.indent);

        var valueObjPath = isc.JSONEncoder._serialize_addToPath(objPath, i);
        var serializedValue =
            this._serialize(value,
                                (prefix != null ? prefix + isc.Comm.indent : null),
                                valueObjPath);
        // NOTE: need to concat serializedValue to have null/undef properly handled, normally
        // skipped by StringBuffers
        output.append(serializedValue + ",");
        if (prefix != null) output.append(" ");
    }
    // get rid of the trailing comma, if any
    output = output.release(false);
    var commaChar = output.lastIndexOf(",");
    if (commaChar > -1) output = output.substring(0, commaChar);

    // add the end array marker
    if (prefix != null) output += "\n" + prefix;
    output += "]";

    // and return the output
    return output;
},

//>    @method    JSONEncoder._serializeObject()    (A)
//            Internal routine to serialize an object.
//        @group    serialization
//
//        @param    object    (any)        object o serialize
//        @param    prefix    (string)    string to put before each line of serialization output
//        @param    objRefs    (object[])    array of objects that have been serialized already so
//                                     we don't get into endless loops
//        @param    objPath    (string)    global variable path to this object, for serializing object references
//
//        @return    (string)            serialized object as a string
//<
_serializeObject : function (object, objPath, objRefs, prefix) {
    // add the start object marker
    var output = isc.SB.create(),
        undef;

    object = isc.JSONEncoder._serialize_cleanNode(object);

    try {

        for (var key in object) break;
    } catch (e) {
        if (this.showDebugOutput) {
            if (isc.isAn.XMLNode(object)) return isc.echoLeaf(object);

            var message;
            if (e.message) {
                message = (e.message.asSource != null ? e.message.asSource()
                                                      : String.asSource(e.message));
                return "{ cantEchoObject: " + message + "}";
            } else {
                return "{ cantEchoObject: 'unspecified error' }";
            }
        } else return null;
    }

    output.append("{");
    // for each key in the object
    for (var key in object) {
        // skip null keys
        if (key == null) continue;
        // skip internal properties, if the flag is set
        if (this.skipInternalProperties && (isc.startsWith(key, isc._underscore) || isc.startsWith(key, isc._dollar))) continue;
        var value = object[key];

        // if the value is a function, skip it
        if (isc.isA.Function(value)) continue;

        // we don't want to access attributes of the object if it's a Java object
        var isJavaObj = isc.Browser.isSGWT ? window.SmartGWT.isNativeJavaObject(value) : false;
        // omit instances entirely if so configured

        if (key != isc.gwtRef && !isJavaObj && isc.isAn.Instance(value) && this.serializeInstances == "skip") continue;

        // otherwise return the key:value pair

        // convert the key to a string
        var keyStr = key.toString();
        // and if it isn't a simple identifier, quote it
        if (this.strictQuoting || !isc.Comm._simpleIdentifierRE.test(keyStr)) {
            if (keyStr.contains('"')) {
                if (keyStr.contains("'")) {
                    keyStr = '"' + this.convertToEncodedQuotes(keyStr) + '"';
                } else {
                    keyStr = "'" + keyStr + "'";
                }
            } else {
                keyStr = '"' + keyStr + '"';
            }
        }

        var otherObjPath = isc.JSONEncoder._serialize_addToPath(objPath, key);
        var serializedValue;

        if (key == isc.gwtRef) {
            // don't try to serialize references to GWT Java objects
            if (!this.showDebugOutput) continue;
            // show a marker if asked for debug output

            serializedValue = String.asSource("{GWT Java Obj}");
        // We could return the string value via an implicit toString using "" + value
        // but this won't eval successfully
        } else if (key == isc.gwtModule) {
            if (!this.showDebugOutput) continue;
            serializedValue = String.asSource("{GWT Module}");
        } else if (isJavaObj) {
            serializedValue = (value == null ? null : String.asSource(value + ""));

        } else {
            serializedValue =
                this._serialize(value,
                                    (prefix != null ? prefix + isc.Comm.indent : null),
                                    otherObjPath);
        }

        // skip values that resolve to undefined
        //if (serializedValue === undef) {
        //    continue;
        //}

        // now output the key : value pair
        if (prefix != null) output.append("\n", prefix, isc.Comm.indent);

        // NOTE: need to concat serializedValue to have null/undef properly handled, normally
        // skipped by StringBuffers
        output.append(keyStr, ":" + serializedValue, ",");

        if (prefix != null) output.append(" ");
    }
    // get rid of the trailing comma, if any
    output = output.release(false);
    var commaChar = output.lastIndexOf(",");
    if (commaChar > -1) output = output.substring(0, commaChar);

    // add the end object marker
    if (prefix != null) output += "\n" + prefix;
    output += "}";

    // and return the output
    return output;
},

// Converts a string so that embedded ' and " characters are converted to the HTML encodings
// &apos; and &quot;  Only used if a key string contains both ' and " (otherwise, we just
// quote it using the symbol that isn't contained in the key name)
convertToEncodedQuotes : function (string) {
    return string.replace(String._doubleQuoteRegex, "&quot;").
                  replace(String._singleQuoteRegex, "&apos;");
},
convertFromEncodedQuotes : function (string) {
    return string.replace(new RegExp("&quot;", "g"), '"').
                  replace(new RegExp("&apos;", "g"), "'");
}
});







//
//
//    clone() methods for the comm package
//

isc.addGlobal("clone", function (object, objPath) { return isc.Comm._clone(object); });
isc.addGlobal("shallowClone", function (object) { return isc.Comm._shallowClone(object); });

isc.Comm.addClassMethods({

//>    @classMethod isc.clone()
// Create a deep clone of an object that can be edited without affecting the original
// <P>
// All mutable types, including Objects, Arrays and Dates, are copied.  All immutable types
// (Number, String, etc) are just preserved by reference.
// <P>
// Only JavaScript built-in types may be cloned.  SmartClient UI widgets do not support
// cloning, instead, use +link{Class.create()} to make a new component with similar
// configuration.
// <P>
// Does not handle looping references (will infinite loop).
//
// @visibility external
//
//        @group    serialization
//        @param    object        (object)    object to clone
//        @return                (object)    cloned object
//<
clone : isc.clone,

_clone : function (object) {


    // preserve undef vs null (eg slot values)
    var undef;
    if (object === undef) return undef;
    if (object == null) return null;

    // just return immutable types
    if (isc.isA.String(object) || isc.isA.Boolean(object) ||
        isc.isA.Number(object) || isc.isA.Function(object)) return object;

    // do not attempt to clone GWT Java Object references; a crash will likely result
    if (isc.Browser.isSGWT && window.SmartGWT.isNativeJavaObject(object)) return object;

    // copy mutable types
    if (isc.isA.Date(object)) return object.duplicate();

    if (isc.isAn.Array(object)) return isc.Comm._cloneArray(object);
    // allow a clone() function to be implemented
    if (isc.isA.Function(object.clone)) {

        if (isc.isA.Class(object)) return isc.echoLeaf(object);
        return object.clone();
    }
    return isc.Comm._cloneObject(object);
},

_cloneArray : function (object) {
    var output = [];
    for (var i = 0, len = object.length; i < len; i++) {
        output[i] = isc.Comm._clone(object[i]);
    }
    return output;
},

_cloneObject : function (object) {
    var output = {};
    for (var key in object) {
        var value = object[key];

        if (key == isc.gwtRef || key == isc.gwtModule) continue;
        output[key] = isc.Comm._clone(value);
    }
    return output;
},

//> @classMethod isc.shallowClone()
// Creates a shallow copy of the passed-in Object or Array of Objects, that is, copies all
// properties of an Object to a new Object, so that the clone now has exactly the same property
// values as the original Object.
// <P>
// If <code>shallowClone()</code> is passed an immutable type such as String and Number, it is returned
// unchanged.  Dates are copied via <code>new Date(originalDate.getTime())</code>.
// <P>
// Note that if an Array is passed, all members of the Array will be cloned.  For a copy of an
// Array that contains exactly the same members (not copies), use Array.duplicate().
// <P>
// Only an Array directly passed to <code>shallowClone()</code> is copied.  Arrays contained
// within Arrays will not be copied.
//
// @param object (Object or Array of Object) object to be cloned
// @return (Object or Array of Object) a shallow copy of the passed-in data
// @visibility external
//<
shallowClone : isc.shallowClone,

_shallowClone : function (object) {

    // preserve undef vs null (eg slot values)
    var undef;
    if (object === undef) return undef;
    if (object == null) return null;

    // Avoid attempting to manipulate SGWT Java objects
    if (isc.Browser.isSGWT && window.SmartGWT.isNativeJavaObject(object)) return object;

    // just return immutable types
    if (isc.isA.String(object) || isc.isA.Boolean(object) ||
        isc.isA.Number(object) || isc.isA.Function(object)) return object;

    // copy mutable types
    if (isc.isA.Date(object)) return object.duplicate();

    if (isc.isAn.Array(object)) return isc.Comm._shallowCloneArray(object);

    // make a shallow clone of the object
    return isc.addProperties({}, object);
},

_shallowCloneArray : function (object) {
    var output = [];
    for (var i = 0, len = object.length; i < len; i++) {
        // don't copy arrays, just return them directly
        if (isc.isAn.Array(object[i])) output[i] = object[i];
        else output[i] = isc.Comm._shallowClone(object[i]);
    }
    return output;
}

});    // END isc.addMethods(isc.Comm, {})

//> @groupDef jUnitSeleniumRC
//
// <div style="width:600px">
//
// Let's take a look at some JUnit code designed to test a standalone version of the
// <smartclient>
// +externalLink{http://localhost:8080/isomorphic/system/reference/SmartClient_Explorer.html#treesEditing, SmartClient Showcase: Trees &gt;&gt; Editing}
// </smartclient>
// <smartgwt>
// +externalLink{http://localhost:8080/index.html#tree_editing, SmartClient Showcase: Trees &gt;&gt; Editing}
// </smartgwt>
// example.  The overall test class, TreeTest, contains a test, testTree1, targeted at the TreeGrid in the
//  example, and a test, testTree2, targeted at the SearchForm/ListGrid.  As recommended by the official
// +externalLink{http://seleniumhq.org/docs/08_user_extensions.html, Selenium documentation},  we create
// the <code>HttpCommandProcessor</code> separately from <code>DefaultSelenium</code> to provide a way to
// invoke the new user extension command <code>waitForElementClickable()</code> which SmartClient defines.
// (See our Selenium User Guide described in +link{automatedTesting}.)
// <P>
// The test class TreeTest was initially generated by exporting the Selenium script for testTree1 in JUnit 4
// format, but it was modified by hand as mentioned above to support the <code>waitForElementClickable()</code>.
//
// Below we look at the two test cases testTree1 and testTree2.  Note that in each case, we maximize
// the Selenium browser window in accordance with the best practices mentioned in the User Guide.
// <P>
// If you'd like to experiment with making changes to the sample JUnit code, one improvement that simplifies
// things is to add a myClick() function that handles both the <code>waitForElementClickable()</code> and
// the <code>click</code> on a supplied locator.  Even just assigning each unique locator to a local Java
// variable so it can be reused for multiple calls will make the code simpler to follow and maintain.
//
// <pre>
// import com.thoughtworks.selenium.*;
// import org.junit.After;
// import org.junit.Before;
// import org.junit.Test;
// import java.util.regex.Pattern;
//
// public class TreeTest extends SeleneseTestCase {
//
//     HttpCommandProcessor proc;
//
//     void waitForElementClickable(String locator) {
//         String[] locatorArg = {locator};
//         proc.doCommand("waitForElementClickable", locatorArg);
//     }
//
//     &#64;Before
//     public void setUp() throws Exception {
//         proc = new HttpCommandProcessor("localhost", 4444, "*chrome",
//             "http://localhost:8080/");
//         selenium = new DefaultSelenium(proc);
//         selenium.start();
//     }
//
//     &#64;Test
//     public void testTree1() throws Exception {
//         selenium.open("treeEdit.html");
//         selenium.windowMaximize();
//
//         waitForElementClickable("scLocator=//TreeGrid[ID=\"employeeTree\"]/body/row[EmployeeId=4||Name=Charles%20Madigen||0]/col[fieldName=Name||0]/open");
//         selenium.click("scLocator=//TreeGrid[ID=\"employeeTree\"]/body/row[EmployeeId=4||Name=Charles%20Madigen||0]/col[fieldName=Name||0]/open");
//         waitForElementClickable("scLocator=//TreeGrid[ID=\"employeeTree\"]/body/row[EmployeeId=189||Name=Gene%20Porter||8]/col[fieldName=Name||0]/open");
//         selenium.click("scLocator=//TreeGrid[ID=\"employeeTree\"]/body/row[EmployeeId=189||Name=Gene%20Porter||8]/col[fieldName=Name||0]/open");
//         waitForElementClickable("scLocator=//TreeGrid[ID=\"employeeTree\"]/body/row[EmployeeId=264||Name=Cheryl%20Pearson||Salary=5650||10]/col[fieldName=Salary||2]");
//         verifyEquals("5650", selenium.getText("scLocator=//TreeGrid[ID=\"employeeTree\"]/body/row[EmployeeId=264||Name=Cheryl%20Pearson||Salary=5650||10]/col[fieldName=Salary||2]"));
//
//         checkForVerificationErrors();
//     }
// </pre>
//
// In test testTree1, the idea is to:
// <ul>
//     <li> Open the node for the top level employee, Charles Madigen,
//     <li> Open the node for his report, Gene Porter, and
//     <li> Verify that the Salary of Cheryl Pearson, who reports to Gene, is 5650
// </ul>
// For this test, the locators were generated by Selenium IDE for us but we did modify the code
// to make use of the function <code>waitForElementClickable()</code>.
// <P>
//      Note that though the locator for Cheryl includes the salary, it will match based on the first
// field, EmployeeId, which is the primary key, so the test will correctly compare the contents
// of Cheryl's salary against the value 5650 and fail if it doesn't match.  If for some reason
// your test requires matching a specific field rather than the default fields and ordering
// generated automatically, you can hand edit the locator.
//
// <pre>
//
//     public void testTree2() throws Exception {
//         selenium.open("treeEdit.html");
//         selenium.windowMaximize();
//
//         // Steps 1-3: Load the ListGrid with Joan's Reports
//         waitForElementClickable("scLocator=//SearchForm[ID="employeeSearchForm"]/item[index=0||Class=PickTreeItem]/button/");
//         selenium.click("scLocator=//SearchForm[ID="employeeSearchForm"]/item[index=0||Class=PickTreeItem]/button/");
//
//         waitForElementClickable("scLocator=//autoID[Class=SelectionTreeMenu||index=8||length=14||classIndex=0||classLength=2||roleIndex=0||roleLength=2||scRole=menu]/body/row[Name=Charles%20Madigen]/col[fieldName=title||0]");
//         selenium.mouseMove("scLocator=//autoID[Class=SelectionTreeMenu||index=8||length=14||classIndex=0||classLength=2||roleIndex=0||roleLength=2||scRole=menu]/body/row[Name=Charles%20Madigen]/col[fieldName=title||0]");
//
//         waitForElementClickable("scLocator=//SelectionTreeMenu[ID=\"isc_SelectionTreeMenu_0_childrenSubMenu_0\"]/body/row[EmployeeId=183]/col[fieldName=title||1]");
//         selenium.click("scLocator=//SelectionTreeMenu[ID=\"isc_SelectionTreeMenu_0_childrenSubMenu_0\"]/body/row[EmployeeId=183]/col[fieldName=title||1]");
//
//         // Step 4: Sort by salary, descending, and wait for ListGrid to be redrawn with final result
//         waitForElementClickable("scLocator=//ListGrid[ID=\"employeeGrid\"]/header/headerButton[fieldName=Salary]/");
//         selenium.click("scLocator=//ListGrid[ID=\"employeeGrid\"]/header/headerButton[fieldName=Salary]/");
//         waitForElementClickable("scLocator=//ListGrid[ID=\"employeeGrid\"]/header/headerButton[fieldName=Salary]/");
//         selenium.click("scLocator=//ListGrid[ID=\"employeeGrid\"]/header/headerButton[fieldName=Salary]/");
//
//         selenium.waitForGridDone("scLocator=//ListGrid[ID='employeeGrid']");
//
//         // Step 5: Verify the top salary
//         waitForElementClickable("scLocator=//ListGrid[ID=\"employeeGrid\"]/body/row[0]/col[fieldName=Salary||2]");
//         verifyEquals("9400", selenium.getText("scLocator=//ListGrid[ID=\"employeeGrid\"]/body/row[0]/col[fieldName=Salary||2]"));
//
//         checkForVerificationErrors();
//     }
// </pre>
//
// In test testTree2, the idea is to:
// <P>
// 1. Click on the SearchForm button, revealing a Charles Madigen popup,<BR>
// 2. Issue a MouseMove on the Charles Madigen popup, revealing a list of his reports,<BR>
// 3. Click on his report Joan Little, filling the ListGrid with her reports,<BR>
// 4. Click on the salary column header twice, sorting by descending salary, and<BR>
// 5. Verify the salary in the top row (top salary) is 9400<BR>
// <P>
// This test required more hand modification than the previous one.  In particular three modifications were made:
// <ul>
//    <li> A mouseMove command was manually added to the Selenium IDE script,
//    <li> A call to <code>waitForGridDone()</code> was added to assure the sorting was done before we ran verifyText, and
//    <li> We manually removed all but row qualifier from the automatically generated scLocator for step &#35;5.
// </ul>
//
// The first modification is required because our user extensions don't record mouseMove
// events, and the second is needed to ensure the sorts are complete before verifyText runs--for
// details see the User Guide (described in +link{automatedTesting}).  The final modification is
// just a reflection of what our intent is in step &#35;5; we want to operate on the top row,
// regardless of its contents, so we don't want our locator matching based on the EmployeeId or
// Name fields of the records.  (Matching by EmployeeId in the locator as automatically
// generated would make the test verify that Kelly Fetterman's salary is 9400 rather than that 9400
// is the highest salary.)
//
// <pre>
//     &#64;After
//     public void tearDown() throws Exception {
//         selenium.stop();
//     }
// }
// </pre>
// </div>
// @title JUnit + Selenium RC
// @visibility external
//<




//> @groupDef automatedTesting
// SmartClient supports automated testing with a variety of tools.
// <P>
// <h3>Selenium</h3>
// <P>
// SmartClient includes a free, custom Selenium extension for robust record and playback of tests,
// including the ability to record on one browser and play back on others, support for Selenium
// Remote Control allowing tests to be written in a variety of programming languages and run as
// scripts, as well as SmartClient-specific enhancements to the Selenium IDE.
// <P>
// These extensions can be found in the
// <smartclient><code>smartclientSDK/tools/selenium/</code></smartclient>
// <smartgwt><code>selenium/</code></smartgwt>
// directory and a user guide can be found +link{group:usingSelenium,here}.
// <P>
// Selenium supports writing test code in any programming language via
// +externalLink{http://seleniumhq.org/projects/remote-control/,Seleniun RC}.  By writing
// Selenium RC test cases in Java, you can drive them from JUnit, hence creating automated
// tests that can be run from the command line or via Continuous Integration servers such as
// Hudson, allowing for running tests on checkins to source control or in overnight batch runs.
// <P>
// Services such as +externalLink{http://saucelabs.com/ondemand,SauceLabs OnDemand} allow you
// to run the actual browsers in the cloud, tunneling back to a private network via an
// encrypted channel, so that you do not need to set up Selenium RC servers with appropriate
// browsers installed.
// <P>
// For apps requiring load testing, also take a look at
// +externalLink{http://browsermob.com,BrowserMob}, which allows you to run Selenium tests with
// thousands of browsers at once against a test deployment.
// <P>
// <b>JUnit + Selenium RC</b>
// <P>
// Explore +link{jUnitSeleniumRC,JUnit + Selenium RC}, where we walk through a JUnit test built
// using Selenium IDE and targeting a SmartClient Showcase example.
// <P>
// <h3>TestRunner</h3>
// <P>
// +link{group:testRunner,TestRunner} is a system for automatically running a suite of Selenium
// tests, commiting the results to a database, and reporting any regressions (or fixes) via email.
// <P>
// <h3>SOASTA</h3>
// <P>
// SOASTA's CloudTest product includes special support for SmartClient with capabilities
// similar to our Selenium extensions, with special emphasis on load testing.  Find out more at
// +externalLink{http://soasta.com}.
// <P>
// <smartgwt>
// <h3>GwtTestCase</h3>
// <P>
// GWT includes a way to run a GWT application under JUnit, running your GWT application in a
// "headless" browser.  This is a very limited testing approach appropriate for certain unit
// tests only - it cannot replace events such as clicks, because by default it doesn't run in
// actual browser (instead it runs in a simulator called HtmlUnit).
// <p>
// Note that running tests under HtmlUnit can lead to false failures in a variety of areas,
// including network communication and XML processing, where HtmlUnit's behaviors do not
// correspond to any real browser.  Note that, if you find that a test fails under HtmlUnit but
// would not fail in a real browser, this will not be regarded as a SmartGWT bug.
// <p>
// If you use GwtTestCase at all, Isomorphic recommends that the majority of your tests are
// executed using the
// +externalLink{http://www.gwtproject.org/doc/latest/DevGuideTestingRemoteTesting.html,runStyle option}
// that allows GwtTestCase to run under a real browser via Selenium.
// <P>
// Also note, GwtTestCase has a bug where it does not run onModuleLoad() for included GWT
// modules.  To make sure SmartGWT's onModuleLoad() runs, add a <code>gwtSetUp()</code>
// implementation like so:
// <P>
// <pre>
//   public class SgwtTest extends GWTTestCase {
//         public void gwtSetUp() {
//             new SmartGwtEntryPoint().onModuleLoad();
//         }
//      ...
// </pre>
// <P>
// You may need to add similar manual calls for other GWT modules you inherit which expect to
// have their <code>onModuleLoad()</code> method called normally.
// </smartgwt>
// <P>
// <h3>WebDriver / "Selenium 2"</h3>
// <P>
// WebDriver, which is now part of Selenium 2, uses a different basic architecture in which
// extensions are added to each browser in order to drive tests, instead of doing so from
// JavaScript.
// <P>
// Support for WebDriver-based testing for SmartClient is now available with the same custom
// locator strategies and custom commands as we provide for Selenium 1.0.  However, we continue
// to recommend Selenium 1.0 rather than WebDriver-based Selenium 2, because:
// <P>
// <ol>
// <li> <b>WebDriver is more complex to install</b>: WebDriver requires installing support for
// each browser where you want to run tests, and in some cases multiple WebDriver plugins for
// multiple versions of the browser
// <li> <b>WebDriver has version / browser support issues</b>: Selenium 1.0 generally works
// with any standards-compliant browser.  Because WebDriver requires deeper integration with
// the browser, new browser releases require updated WebDriver extensions.  This is a
// particular issue with the rapid pace of new releases of Firefox, where the WebDriver
// extension becomes disabled by an update of Firefox, but WebDriver test will still run in a
// "non-native" mode that behaves erratically.  Unfortunately, there is <b>no way we can
// detect and warn users about this</b>; this is a general issue with WebDriver and
// Firefox, not specific to SmartClient.
// <li> <b>Mobile testing issues</b>: Mobile testing is supported only for certain devices,
// requires that an application be installed on the devices, doesn't run a normal browser
// (rather an embedded browser window inside an application), which can introduce spurious
// issues during playback.  In contrast, while Selenium RC doesn't support mobile, with
// Selenium 1.0 you can use Selenium Core to test any mobile device that supports JavaScript
// without installation of an app.  Both situations have drawbacks but we feel that Selenium
// 1.0 has an overall advantage over WebDriver here.
// <li> <b>Java skills required</b>: Tests created in Selenium IDE and stored in Selenese can
// be executed by a variety of tools without requiring Java skills, including our own
// +link{group:testRunner}.  Most ways of running WebDriver tests involve Java coding
// skills or at least the ability to work with a Java IDE.  This tends to mean that all QA
// personnel must either have Java skills or drain the time of Java developers on repetitive
// tasks.
// </ol>
// <P>
// Ultimately, our current recommendation is to use Selenium 1.0 and Selenium RC exclusively or
// at least primarily.  If there are critically important tests that you can only build via
// WebDriver (rare: the most common such case is testing file upload - see below), use WebDriver for
// those tests only, or use manual testing for those tests.
// <P>
// <b>WebDriver Usage</b>
// <P>
// When using WebDriver, we recommend using Selenum IDE to record tests, and storing tests in
// Selenese (as with Selenium RC / 1.0).  WebDriver is not normally able to execute Selenese
// tests, but we provide a Java class <code>SeleneseRunner</code> that can be used to:
// <ul>
// <li> execute Selenese directly from the command line
// <li> execute Selenese from inside a Java program (eg, as part of a JUnit test)
// <li> convert a Selenese test to Java code (as a JUnit test)
// </ul>
// See the server-side JavaDoc for com.isomorphic.webdriver.SeleneseRunner for more information
// on how to use these features.
// <p>
// <b>NOTE:</b> Selenium IDE has an option to export tests as WebDriver-compatible code.  <b>Do
// not use</b> this feature, it exports useless code that doesn't understand custom commands,
// custom locators, or other key features of Selenium IDE.  Use SeleneseRunner instead.
// <p>
// <b>WebDriver Classes overview</b>
// <p>
// Storing and executing Selenese tests recorded in the Selenium IDE is recommended as the
// primary approach for using WebDriver.  However, for certain rare tests it can make sense to
// use WebDriver Java support directly.
// <p>
// SmartClient support for WebDriver is based around 3 different Java classes:
// <P>
// <ol>
// <li> <b>ByScLocator</b>: This implements the ability to find WebElements or WebDriver "By"
// objects using SmartClient Locator strings.  See +link{group:usingSelenium} for more
// background on Locator strings and how to obtain them.  Given a locator String, example usage is:
// <pre>
// ByScLocator.scLocator("//ListGrid[ID=\"countryList\"]/body/row[countryCode=US||0]/col[fieldName=countryCode||0]")
// </pre>
// <li> <b>SmartClientWebDriver</b>: This is an abstract class which provides a number of
// different methods for interacting with the browser, such as:
// <ul>
// <li> open a browser at a particular URL
// <li> find the element or elements which match a given "By" object (either ByScLocator, or a
//      standard WebDriver locator)
// <li> perform events and operations (click, drag, select etc)
// <li> perform custom SmartClient validations / state checks, such as whether a grid has
//      loaded data
// </ul>
// Three concrete implementations of SmartClientWebDriver are provided: SmartClientFireFoxDriver,
// SmartClientChromeDriver and SmartClientIEDriver. There is also a SmartClientRemoteWebdriver class
// which allows the injection of a manually configured RemoteWebDriver instance. This might be
// necessary, for example, for use with Selenium Grid.
// <li> <b>ScAction</b>: a SmartClient-specific version of the standard WebDriver
// "Action" class, providing a builder pattern to create a sequence of operations which can
// then be perform()ed.
// </ol>
// <P>
// These classes are packaged in the library isomorphic_webriver.jar, which can be found
// in WEB-INF/lib-WebDriverSupport (along with several 3rd-party supporting libraries).
// <P>
// General information regarding WebDriver can be found
// +externalLink{http://docs.seleniumhq.org/docs/03_webdriver.jsp#introducing-webdriver, here}. Setup for
// WebDriver is more complex than for classic Selenium: The basic Java package includes drivers
// for FireFox (subject to important version limitations as described above), but additional drivers must
// be downloaded for +externalLink{http://code.google.com/p/chromium/downloads/list, Google Chrome} and
// +externalLink{http://code.google.com/p/selenium/downloads/list, Internet Explorer}.
// <P>
// <b>File Upload Example Test</b>
// <P>
// As discussed above, one advantage which WebDriver does have over Classic Selenium is the ability
// to test file upload. It is still limited in that if a click is triggered on the file selection button
// an OS native file selection dialog will be triggered in which case the test will be suspended until the
// file is manually selected. To avoid this, the sendKeys() method can be used to enter the file location.
// Two examples of this are given below - one for the SmartClient showcase, and one for SmartGWT:
// <p>
// <pre>
//    &#47;**
//     * The following test runs against localhost and requires a small (< 5mb) image to be in /tmp/image.jpg
//     *&#47;
//    public void fileUploadSC() throws Exception {
//        SmartClientFirefoxDriver driver = new SmartClientFirefoxDriver();
//        driver.setBaseUrl("http://localhost:8080/");
//        driver.get("isomorphic/system/reference/SmartClient_Explorer.html#upload");
//        driver.manage().window().maximize();
//
//        final int origSize = driver.findElements(ByScLocator.scLocator("//TileGrid[ID=\"mediaTileGrid\"]/tile")).size();
//
//        By titleInput = ByScLocator.scLocator("//DynamicForm[ID=\"uploadForm\"]/item[name=title||title=Title||index=0|"
//                                             +"|Class=TextItem]/element");
//        driver.click(titleInput);
//        driver.sendKeys(titleInput, "test image: " + origSize);
//
//        By uploadForm = ByScLocator.scLocator("//DynamicForm[ID=\"uploadForm\"]/");
//        WebElement form = driver.findElement(uploadForm);
//        WebElement findElement = form.findElement(By.xpath("//input[@type='FILE']"));
//        &#47;*
//         * The following causes a native dialog to be created which prevents further progress. Do NOT uncomment!
//         * We just have to sendKeys() to it
//         *&#47;
//        //findElement.click();
//
//        findElement.sendKeys("/tmp/image.jpg"); // A local file. Please change accordingly
//
//        By saveButton = ByScLocator.scLocator(
//                             "//DynamicForm[ID=\"uploadForm\"]/item[title=Save||index=2||Class=ButtonItem]/button/");
//        driver.waitForElementClickable(saveButton);
//        driver.click(saveButton);
//        &#47;*
//         * Note the following fails once the grid contains more than 3 rows of data
//         * as the index becomes inconsistent as tiles scrolled out of site are removed
//         * and the indices change
//         *&#47;
//        By tile = ByScLocator.scLocator("//TileGrid[ID=\"mediaTileGrid\"]/tile[Class=SimpleTile||index="
//                         +(origSize)+"||length="+(origSize+1)+"||classIndex="+(origSize)+"||classLength="+(origSize+1)+"]/");
//        driver.waitForElementClickable(tile);
//        WebElement tile1 = driver.findElement(tile);
//        assertEquals("test image: " + origSize, tile1.getText());
//        assertEquals(origSize + 1, driver.findElements(ByScLocator.scLocator("//TileGrid[ID=\"mediaTileGrid\"]/tile")).size());
//        driver.close();
//        driver.quit();
//    }
//
//    &#47;**
//     * The following test runs against localhost and requires a small (< 5mb) image to be in /tmp/image.jpg
//     *&#47;
//    public void fileUploadGWT() throws Exception {
//        final String basePath = "//VLayout[ID=\"isc_Showcase_1_0\"]/member[Class=HLayout||index=0||length=2|"
//                               +"|classIndex=0||classLength=1]/member[Class=HLayout||index=0||length=2||classIndex=0|"
//                               +"|classLength=1]/member[Class=Canvas||index=1||length=2||classIndex=0||classLength=1]"
//                               +"/child[Class=TabSet||index=0||length=1||classIndex=0||classLength=1]/paneContainer/"
//                               +"member[Class=VLayout||index=1||length=2||classIndex=0||classLength=1]/"
//                               +"member[Class=VLayout||index=1||length=2||classIndex=0||classLength=1]/"
//                               +"member[Class=HLayout||index=1||length=2||classIndex=0||classLength=1]/"
//                               +"member[Class=HLayout||index=0||length=1||classIndex=0||classLength=1]/";
//        final String formPath = basePath + "member[Class=DynamicForm||index=0||length=3||classIndex=0||classLength=1]";
//        final String tilesPath = basePath + "member[Class=VLayout||index=2||length=3||classIndex=0||classLength=1]/"
//                                          + "member[Class=TileGrid||index=2||length=4||classIndex=0||classLength=1]/tile";
//        SmartClientFirefoxDriver driver = new SmartClientFirefoxDriver();
//        driver.setBaseUrl("http://localhost:8888/");
//        driver.get("index.html#upload_sql");
//        driver.manage().window().maximize();
//
//        final int origSize = driver.findElements(ByScLocator.scLocator(tilesPath)).size();
//        By uploadForm = ByScLocator.scLocator(formPath);
//        WebElement form = driver.findElement(uploadForm);
//
//        By titleInput = ByScLocator.scLocator(formPath + "/item[name=title||title=Title||index=0||Class=TextItem]/element");
//        driver.click(titleInput);
//        driver.sendKeys(titleInput, "test image: " + origSize);
//
//        WebElement findElement = form.findElement(By.xpath("//input[@type='FILE']"));
//        &#47;*
//         * The following causes a native dialog to be created which prevents further progress. Do NOT uncomment!
//         * We just have to sendKeys() to it
//         *&#47;
//        //findElement.click();
//
//        findElement.sendKeys("/tmp/image.jpg"); // A local file. Please change accordingly
//
//        By saveButton = ByScLocator.scLocator(formPath + "/item[title=Save||index=2||Class=ButtonItem]/button/");
//        driver.waitForElementClickable(saveButton);
//        driver.click(saveButton);
//        &#47;*
//         * Note the following fails once the grid contains more than 3 rows of data as the index becomes inconsistent
//         * as tiles scrolled out of site are removed and the indices change
//         *&#47;
//        By tile = ByScLocator.scLocator(tilesPath + "[Class=SimpleTile||index="+(origSize)+"||length="+(origSize+1)
//                                                      + "||classIndex="+(origSize)+"||classLength="+(origSize+1)+"]/");
//        driver.waitForElementClickable(tile);
//        WebElement tile1 = driver.findElement(tile);
//        assertEquals("test image: " + origSize, tile1.getText());
//        assertEquals(origSize + 1, driver.findElements(ByScLocator.scLocator(tilesPath)).size());
//        driver.close();
//        driver.quit();
//    }
// </pre>
// <P>
// <b>WebDriver Troubleshooting</b>
// <P>
// There is a known issue that
// +externalLink{https://code.google.com/p/selenium/issues/detail?id=4403,native events do not work with IE in Windows 8/8.1}
// that may manifest in WebDriver as clicks having no effect.  One potential workaround is to
// disable native events:
// <pre>
//    DesiredCapabilities caps = DesiredCapabilities.internetExplorer();
//    caps.setCapability("nativeEvents",false);
//    SmartClientWebDriver driver = new SmartClientIEDriver(caps);</pre>
// It's also been reported that changing the second line above to:
// <pre>
//    caps.setCapability("requireWindowFocus", true);</pre>
// also resolves the issue, with the side effect that WebDriver then moves the mouse cursor.
// <P>
// <b>Other tools</b>
// <P>
// SmartClient supports a special JavaScript API to allow other test tools to integrate in the
// same manner as Selenium, WebDriver and SOASTA.  This API allows the test tool to record an abstract
// "locator" string representing the logical name for an interactive DOM element, and then
// during test playback, retrieve a DOM element given a locator.
// <P>
// This is critical because, like many modern Ajax systems, SmartClient generates different DOM
// elements in different browsers, in different skins, and in different versions of SmartClient.
// Testing tools that try to directly record the generated SmartClient DOM produce extremely
// brittle tests because they are effectively recording undocumented internals.
// <P>
// Using the "locator" API allows you to record or write tests that will run in any browser
// supported by SmartClient, in any version of SmartClient, and in any skin.  It also makes
// tests more readable and easier to understand and maintain.
// <P>
// Different testing tools vary in how easily they can be configured to use the locator API,
// and in some older tools it can be a large effort.  We highly recommend using our Selenium
// extensions - it often makes sense to use them even if you have to use them in parallel with
// another, older testing tool.  If you are forced to use another tool exclusively:
// <ul>
// <smartclient>
// <li> Read the +link{class:AutoTest,documentation for the locator system}
// </smartclient>
// <smartgwt>
// <li> Refer to the &#83;martClient documentation for the AutoTest class (because it's a
// JavaScript API).  It can be found
// +externalLink{http://www.smartclient.com/product/documentation.jsp,here}
// </smartgwt>
// <li> Read over the source code of our Selenium extensions to get a clear understanding of
// how the Selenium integration works, because this will be analogous to the work you'll need
// to do
// <li> Search the +externalLink{http://forums.smartclient.com/, forums} for other developers
// who are trying to use the same test tool with SmartClient, and share efforts
// </ul>
//
// @treeLocation Concepts
// @title Automated Testing
// @visibility external
//<



//> @groupDef usingSelenium
// +externalLink{http://seleniumhq.org/,Selenium} is a powerful and popular tool which can be used
// to test your SmartClient applications.
// Selenium executes tests against your running application in a browser emulating user interaction
// and asserting various conditions. Selenium provides a record/playback tool for authoring tests without
// learning a test scripting language. You must be familiar with +externalLink{http://seleniumhq.org/,Selenium}
// and use of +externalLink{http://seleniumhq.org/projects/ide/,Selenium IDE} before proceeding.
// Refer to the documentation on the Selenium site.
// <P>
// Selenium supports the concept of +externalLink{http://seleniumhq.org/docs/02_selenium_ide.html#locating-elements,Locators}
// in order to specify the element you'd like a given Selenium command to target. For example Selenium supports XPath based
// locators and DOM ID based locators. XPath based locators are extremely fragile due to complexity of certain
// highly nested DOM elements you need access to combined with the fact that XPath support varies across browsers and
// so your tests might not work across different browsers.
// <P>
// Use of Selenium with SmartClient applications is no different than using Selenium to write and run test cases with
// any other application with the exception of one caveat: SmartClient occasionally renders a different DOM structure
// depending on the browser for performance or rendering the UI such that it appears identical across various browsers.
// As a result using DOM ID or DOM XPath based locators with SmartClient applications is not advisable.
// <P>
// Instead SmartClient supports a new Selenium locator which is an XPath-like string used by Selenium to robustly identify
// DOM elements within a SmartClient application. SmartClient locators for Selenium are prefixed by "scLocator=" and have a
// readable XPath-like value even for cells in ListGrid's or TreeGrids. Typically these locators will not be hand-written and
// are generated by +externalLink{http://seleniumhq.org/projects/ide/,Selenium IDE}, Selenium's test recording tool. One primary
// locator is based on the ID of the SmartClient widget and has the syntax <b>ID=&lt;Canvas ID&gt;</b>. This simplifies the task of
// writing tests if you know the ID of the Canvas. For reference, the scLocator syntax for ListGrid cells and DynamicForm
// FormItems can be found at the end of this document.
// <P>
// <b>You can automate the process of running Selenium tests and saving or reporting results
// using +link{group:testRunner,TestRunner}.</b>
// <P>
// <b>Setup Instructions</b>
// <P>
// SmartClient ships with two Selenium user extension Javascript files:
// <P>
// <ul>
// <li> user-extensions.js
// <li> user-entensions-ide.js
// </ul>
// <P>
// These extensions (found in the
// <smartclient><code>smartclientSDK/tools/selenium/</code></smartclient>
// <smartgwt><code>selenium/</code></smartgwt>
// directory) augment the Selenium tools to support SmartClient locators. To integrate these extensions with Selenium,
// follow the steps below:
// <P>
// <ul>
// <li> Confirm that the Selenium IDE has been installed.
// <li> Copy the user extension files listed above to a common location on your test client machine.
// <li> Open the Selenium IDE and click the Options ==&gt; Options... menu item. On the General tab enter the path to these extension
// files in the corresponding fields: Selenium Core extensions and Selenium IDE extensions. Refer to the Selenium Documention
// on +externalLink{http://seleniumhq.org/docs/08_user_extensions.html#using-user-extensions-with-selenium-ide,user extensions}
// for more information.
// <li> Go to the WebDriver tab and ensure that the "Enable WebDriver Playback" checkbox is unchecked.
// <li> Close and restart Selenium IDE to load the new extensions.
// </ul>
// <P>
// That's it, we're done configuring the environment.
// <P>
// Note: Tests recorded using Selenium IDE can be played back using
// +externalLink{http://seleniumhq.org/projects/remote-control/,Selenium Remote Control}.
// The <code>user-extensions-ide.js</code> file is not required for playback of SmartClient-aware tests using Selenium RC, but the
// <code>user-extensions.js</code> is. Instructions for using <code>user-extensions.js</code> with Selenium RC can be found
// +externalLink{http://seleniumhq.org/docs/08_user_extensions.html#using-user-extensions-with-selenium-rc,here}.
// <P>
// <b>Recording Selenium tests with Selenium IDE</b>
// <P>
// Once you have your application running in Firefox, open Selenium IDE from the Tools ==&gt; Selenium IDE menu option. If the Selenium IDE
// is in record mode, then clicking or carrying out other operations like typing in a text field with automatically record the
// appropriate Selenium commands with the SmartClient locator. In most cases there's no need for you to manually enter the locator,
// the recorder does this for you! In fact, not only do the provided user extension files record your clicks, drag operations, and
// typing in the browser--they also try to ensure that your script executes each operation only when the SmartClient widgets it depends
// upon exist and are ready to be interacted with.  This ensures that when the test script is executed, then even if one or more triggered
// operations are asynchronous (delayed), it behaves as expected.
// <P>
// In the screenshot below, note the <b>waitForElementClickable()</b> operation above the click operation; it was added automatically by our
// user extensions as the click itself was recorded:
// <P>
// <img src="skin/user-guide-images-selenium/selenium-ide-example.png" width="1017px" height="853px">
// <P>
// Sometimes users may also want finer grain control of what Selenium command is created instead of having the Selenium IDE recorder
// do this automatically. For example if you want to verify the value of a particular cell in a ListGrid. Instead of typing in the
// command "verifyTable" and manually enter the SmartClient Locator (scLocator), you can simply right click on the table cell or any
// other SmartClient widget and the most suitable Selenium commands will appear in the context menu along with the scLocator path for
// the clicked element. See image below.
// <P>
// <img src="skin/user-guide-images-selenium/selenium-ide-example-verifyText.png" width="1211px" height="737px">
// <P>
// <b>Solving Ordering Issues in Selenium Scripts</b>
// <P>
// Fundamentally, the reason we add <b>waitForElementClickable()</b> calls before each click is to deal with asynchronous SmartClient
// operations. Many operations on widgets or the network are asynchronous, and a correctly coded test should wait for such operations to
// complete as opposed to inserting an arbitrary delay or using Selenium's <b>setSpeed()</b> function. Using such delays runs the risk of
// the test failing if replay occurs on a loaded machine or slow network, and also makes the test run slower than needed.
// <P>
// Asynchronous operations include:
// <P>
// <ul>
// <li> any actual network operation,
// <li> any DataSource operation (even for a clientOnly DataSource),
// <li> any situation where a widget can be marked "dirty" (see notes at <b>Canvas.isDirty()</b>), and then asynchronously
// redraw itself - this includes API calls like <b>ListGrid.setData()</b>, <b>Canvas.setContents()</b> as well as user interactions like
// ListGrid sort or filter, regardless of whether the data is already present,
// <li> re-layout that occurs as a result of a size change or new member being added to a Layout or subclass of Layout (eg SectionStack, Window)
// </ul>
// <P>
// The following operations are synchronous and don't require waiting:
// <P>
// <ul>
// <li>draw()ing any widget that has no parent - but note adding a widget to an already-drawn Layout is asynchronous, as above
// </ul>
// <P>
// You may encounter cases where you have to manually insert a <b>waitForElementClickable()</b> or <b>waitForElementNotPresent()</b>
// to get a script to behave properly.  Looking at the SmartClient Showcase Example (Grids / Filtering / Advanced Filter), suppose
// we wanted to filter by country names containing "Za" and wait for the filter step to complete before proceeding.  Since the
// ListGrid initially contains many entries and Zaire is not among them, it is not visible and thus we can solve the original
// problem by manually adding a <b>waitForElementClickable()</b> on the locator for Zaire's ListGrid entry:
// <P>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>scLocator=//ListGrid[ID="filterGrid"]/body/row[pk=216||countryCode=CG||215]/col[fieldName=countryCode||0]</b>
// <P>
// Before the filter operation is issued, the locator is not clickable because the record is not visible:
// <P>
// <img src="skin/user-guide-images-selenium/manual-wait-clickable-before.png" width="767px" height="327px">
// <P>
// When the filter operation completes, Zaire and the other search results become visible and the <b>waitForElementClickable()</b>
// returns successfully allowing the next script command to execute:
// <P>
// <img src="skin/user-guide-images-selenium/manual-wait-clickable-after.png" width="763px" height="328px">
// <P>
// Finally, suppose you wanted to do another filter operation to look only at countries (from the previous search results) with
// populations under 30 million.   Since Zaire is above this limit, it will be missing from the search results and you could
// wait for the filter operation to complete by adding a <b>waitForElementNotPresent()</b> on same locator that we previously used
// for <b>waitForElementClickable()</b>. It will return true and allow the script to proceed when the filter operation completes:
// <P>
// <img src="skin/user-guide-images-selenium/manual-wait-not-present.png" width="762px" height="317px">
// <P>
// <b>Waiting on Pending ListGrid Operations</b>
// <P>
// There are cases where <b>waitForElementClickable()/waitForElementNotPresent()</b> will not work--for example if you're performing
// a sort that's rearranging existing elements on the screen, or if you're performing a filter operation where you're not sure of
// the results and thus cannot use the approach from the previous section.  In such a situation, you may need to add a
// <b>waitForGridDone()</b> command into your script to ensure the pending operations are complete before you hit the next command.
// <P>
// The <b>waitForGridDone()</b> command guarantees it will not complete successfully unless all of the following potential pending
// operations on the widget are complete:
// <P>
// <ul>
// <li> any fetch or filter operation (the result of applying criteria),
// <li> any sort operation (the result of apply sort specifiers),
// <li> the flush of pending FilterEditor criteria to the parent ListGrid, and
// <li> the saving of any newly edited rows.
// </ul>
// <P>
// This command should be able to block a Selenium script until the ListGrid specified in the locator reaches a stable drawn state with
// no pending activity.  So for a ListGrid names 'filterGrid', all you'd need to add to ensure all pending operations on it have
// completed is the command:
// <P>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>waitForGridDone("//ListGrid[ID='filterGrid']");</b>
// <P>
// <P>
// <b>Waiting on All Pending Network Operations</b>
// <P>
// Because of the <b>waitForElementClickable</b> commands which are automatically inserted during recording, your scripts will
// automatically wait for the completion of any network operations that block interactivity (via showPrompt, which is enabled by
// default). However in some cases you may want to wait for all pending network operations to complete, even if they don't block
// user interactivity.
// <P>
// To do this, use <b>RPCManager.requestsArePending()</b> in combination with <b>waitForCondition()</b>.
// So, the JavaScript in your <b>waitForCondition()</b> operation would be:
// <P>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>!selenium.browserbot.getCurrentWindow().isc.RPCManager.requestsArePending()</b>
// <P>
// When the call returns, you'd know that any previously initiated network operations--such as filter/sort operations on DataSources--are
// complete.
// <P>
// <b>Automatically Waiting on All Pending Network Operations</b>
// <P>
// If you need the functionality from the section above to wait on all pending network operations, but don't want to add extra calls to
// <b>waitForCondition()</b>, you may switch on automatic enforcement of the condition that <b>isc.RPCManager.requestsArePending()</b>
// is false.  There are two ways to do this:
// <P>
// <ul>
// <li> Set the property <b>isc.AutoTest.implicitNetworkWait</b> to true on the page under test after the ISC modules are loaded, or
// <li> Add the Selenium command <b>setImplicitNetworkWait(true)</b> to your selenium script in Selenium IDE.
// </ul>
// <P>
// Like other Selenium IDE commands with a single argument, you'll want to use <b>setImplicitNetworkWait()</b> by passing <b>true</b>
// (or <b>false</b>) in the Target field of the Selenium IDE GUI (right under command). Without any modifications, the default value
// for <b>isc.AutoTest.implicitNetworkWait</b> of <b>false</b> will prevail.
// <P>
// <b>Keystroke Capturing</b>
// <P>
// Our Selenium Extensions will automatically record the following type of keyboard activity
// in SmartClient widgets, on a keystroke-by-keystroke basis:<ul>
// <li>typing at widgets other than text items (e.g. ListGrids), including normal printing
// characters, navigation keys (up, right, etc.), or modifier sequences (e.g. Ctrl-V)
// <li>typing of printing characters in masked text items</ul>
// Unmasked text items are handled differently - we don't record individual keystokes, but
// instead record the complete text as a "type" command when we get a "change" event for the
// element.  This event is normally sent when you exit a text item by clicking elsewhere or
// tabbing into the next form item.  However, in certain situations the event may not be sent -
// one is when the text item is a managed +link{group:autoChildUsage,auto child} of another
// form item (e.g. +link{MultiComboBoxItem}).  In this case, you can tap Alt (Option on Mac) to
// manually insert a "type" command with the right value.
// <P>
// <b>Recording Movement-Driven Interactions</b>
// <P>
// Our Selenium Extensions provide the capability to automatically record click-based
// interactions with the target page, and keystrokes (under certain circumstances).  However,
// we don't automatically capture interactions based solely on movement, such as when a nested
// menu flyout is triggered by moving the mouse over the menu item of an existing menu.
//
// To avoid problems:<ul>
// <li>If you're trying to record interactions with menus or submenus of a ListGrid, the
// recommended approach is to use a right mouse click (i.e. "context menu" command) interaction
// to record the opening of the initial menu, rather than clicking on the HeaderMenuButton
// that's shown on the header buttons. For the submenus, it's recommended to click on the
// appropriate (parent) menu item to properly record what's needed, even though the child menu
// is already visible from your mouse movement.
// <li>To manually record a "mouse move" operation over the current element, you can simply
// press the Alt key (Option on Mac).  (See also "KeyStroke Capturing" above for behavior over
// text items.)
// <li>If you find yourself often having to add commands manually (other than through the above
// mechanism), you may be approaching the situation incorrectly.  In that case check the
// +externalLink{http://forums.smartclient.com,forums} to see if it's a common problem.
// </ul>
// <P>
// <b>Capturing Logs</b>
// <P>
// Capturing of client and server-side logs can be switched on by providing appropriate options to +link{testRunner},
// but a few Selenium commands are provided to provide direct control over logging on a per-script basis.  If
// server logging has been configured as "some," then server logs won't be captured for a given script unless you
// add the captureServerLogs() Selenium command after the open command; switching the mode to "all" will force
// server logs to be collected for all Selenium scripts, and no captureServerLogs() command is then required.
// <P>
// To configure logging levels, you can use the commands <b>setClientLogLevel(category, level)</b>, or
// <b>setServerLogLevel(category, level)</b>.  For example:
// <ul>
// <li><b>setClientLogLevel("AutoTest","ERROR")</b>, or
// <li><b>setServerLogLevel("com.isomorphic.rpc.RPCManager", "INFO")</b>
// </ul>
// Note that when entering the above examples into Selenium IDE, you need neither parentheses nor quotes,
// as everything is considered a string and there are fixed slots for each.
// <P>
// <b>Disabling the Selenium SmartClient URL Query String</b>
// <P>
// By default, our user extensions automatically add a special URL variable, <b>sc_selenium</b>, to open command urls to allow
// JavaScript to detect it's being driven by Selenium in case special logic should be used.  In the unlikely event that this causes a
// problem with your code or page loading and you don't need the feature, you may eliminate this special URL variable by changing
// <b>Selenium.prototype.use_url_query_sc_selenium</b> from <b>true</b> to <b>false</b> in user-extensions.js.
// <P>
// <hr>
// <P>
// <b><u>Common scLocator syntax</u></b>
// <P>
// For more information on how locators are formed and how to influence them, see the +link{AutoTest,AutoTest} class in
// the SmartClient Reference.
// <P>
// <b><u>List Grid cells</u></b>
// <P>
// <b>//ListGrid[ID="itemList"]/body/row[itemID=1996||itemName=Sugar White 1KG||SKU=85201400||1]/col[fieldName=SKU||1]</b>
// <P>
// <ul>
// <li> This assumes the ListGrid has an explicit ID
// <li> the 'body' part might be 'frozenBody' if the field in question was frozen
// <li> row[......] identifies the row (record)
// <li> itemID= - that's the primary key field from the dataSource the grid is bound to
// <li> itemName= - that's the title field value for the record
// <li> SKU=... - that's the cell the user clicked's value
// <li> 1 - that's the index of the row (rowNum)
// <li> col[.....] - identifies the column in the grid
// <li> fieldName=... - field name for the field the user clicked
// <li> 1 - that's the index of the column
// </ul>
// <P>
// <b><u>Form Items</u></b>
// <P>
// <b>//DynamicForm[ID="autoTestForm"]/item[name=textField||title=textField||value=test||index=0||Class=TextItem]/element</b>
// <P>
// This example is the data element (text entry box) for a text field
// <P>
// <ul>
// <li> this form has an explicit ID
// <li> item[...] identifies the item
// <li> name (field name, if set)
// <li> title (title, if set)
// <li> value (current value if set)
// <li> index (index in the form items array)
// <li> Class (SC class of the item - in this case TextItem) after the "/" we identify the part of the item in question options here include:
// <li> "element" - the data element
// <li> "canvas" - for CanvasItems - points to the canvas embedded in the item
// <li> in this case the xpath might continue to contain, for example children of the canvas or elements within it (cells in a listGrid, etc)
// <li> "textbox" - the "text box" - this is the area where content is written out for items without a 'data element' - like header items
// <li> "[icon=&lt;...&gt;]" - the icon element -- "&lt;...&gt;" would contain the "name" of the icon
// </ul>
// <P>
// <hr>
// <P>
// <b><u>Best Practices</u></b>
// <P>
// <ul>
// <li> <b>Maximize the test browser window to avoid offscreen widgets</b>: Some browsers will not respond to events on widgets
// that are not visible in the browser pane (scrolled out of view or clipped off). To avoid having to manually add script commands to
// scroll such widgets into view, it's recommended to use Selenium's <b>windowMaximize()</b> command which will force the browser to
// occupy the entire screen.
// <P>
// Note that currently some browsers will respond to events on offscreen widgets (IE will, Firefox will not) however, web standards
// are unclear on whether this should be allowed and the behavior may change in the future, so best practice is to maximize for all
// browsers.
// <P>
// <li> <b>Use setID() judiciously to ensure stable locators run-to-run</b>: When setID() is not used to supply a unique component ID,
// locators will sometimes incorporate automatically generated IDs which have a sequence number (eg isc_Object_355). If your test
// has unpredictable execution order (for example, two simultaneous network operations take place and either may complete first,
// and both generate UI components on completion) then these IDs will not be stable from run-to-run. They will likewise not be stable
// if you test part of an app and then embed it in a larger app and try to use the same script.
// <P>
// Use setID() selectively to avoid this problem. Generally, it makes sense to use setID() on all top-level (parentless) widgets - at
// this point, locators for children that do not have a unique ID will be based on the parent's ID plus a relative path. This relative
// path will not incorporate auto-generated IDs and will generally continue to work even if the interior layout of the parent is
// significantly rearranged (such as adding a new intervening container widget).
// </ul>
// <P>
// <hr>
// <P>
// <b><u>Known Limitations</u></b>
// <ul>
// <li> Selenium intermittently fails to generate an scLocator with the "type" command on some FormItems. If this occurs, you can
// manually enter an scLocator into the target field, or use the drop down to select an alternative locator strategy (such as locating
//  a text input element by name).
// <li> Support for multi-select for SelectItems with selection mode "grid" (non-default)
// </ul>
// <P>
// @treeLocation Concepts/Automated Testing
// @title Using Selenium
// @visibility external
//<

//> @groupDef testRunner
// The SmartClient TestRunner is a system for running a suite of Selenium tests on a periodic
// basis, comparing the results to previous results, and generating email alerts reporting on
// new test failures or fixes to tests that were previously failing.
// <P>
// TestRunner is a key piece of implementing the <i>Continuous Integration</i> methodology,
// whereby continuous testing is applied so that regressions are caught immediately.  This
// allows a product or application to be kept continuously at a very high level of quality,
// allowing for more frequent and predictable releases.
// <P>
// <h3>Database Setup</h3>
// <P>
// Each time TestRunner executes it by default stores results to a SQL database via two
// SQLDataSources:
// <ul>
// <li><b>batchRun.ds.xml</b>: stores global information about the run as a whole: an ID for
//    the run, when it started and ended, and optional data to be used in emails generated by
//    the system.
// <li><b>testResult.ds.xml</b>: stores the result of each individual test, including when it
//    started and ended, and information about errors that occurred, if any
// </ul>
// These DataSources are present in the
// <smartclient><code>smartclientSDK/tools/selenium/</code></smartclient>
// <smartgwt><code>selenium/</code></smartgwt>
// directory of your SDK.  If you choose to move them elsewhere, simply update the DataSources
// location (configured by <code>project.datasources</code> in
// +link{server_properties,server.properties}).
// <P>
// These DataSources behave just like other SQLDataSources:
// <ul>
// <li> they are compatible with all the database types that SmartClient supports
// <li> they will use the default database configured for your project, or you can set
//      +link{dataSource.dbName} in the .ds.xml file to use a second database instead
// <li> you can setup the database connection and generate SQL tables using the
//      +link{adminConsole}
// <li> you can build your own UI for viewing test results, by loading the
//      <code>batchRun</code> and <code>testResult</code> DataSources like any other
//      SQLDataSource and binding components such as ListGrids to them.
// <li> if you deploy an application that includes these DataSources, third-party tools can
//      access these DataSources via the RESTHandler servlet
// </ul>
// <P>
// If needed, the IDs of these DataSources can be configured via the
// +link{server_properties,server.properties} settings
// <code>autotest.batchRunDS</code> and <code>autotest.testResultDS</code>.
// <P>
// Note: If you use the default server.properties shipped with the SDK, TestRunner and the
// SDK web server will share a common SQL database, so that the web server and TestRunner
// cannot both run at once.  This means that you must point TestRunner at the web server of
// a separate SDK installation - on a separate matchine or in a separate filesystem location.
// <P>
// <h3>Adding Test Files</H3>
// <P>
// TestRunner currently supports tests written in Selenese, Selenium's HTML-based format for
// recording automated tests.  The Selenium IDE can be used to record tests and save them in
// Selenese format.  For more background on the Selenium IDE, SmartClient's extensions, and
// the use of WebDriver / Selenium 2, see the
// +link{group:automatedTesting,Automated Testing Overview}.
// <P>
// Test files should be saved with the extension .rctest.html.  They should all appear under
// a common root directory (called <code>testRoot</code>), but any level of nesting is allowed,
// and any other files that appear under <code>testRoot</code> will be ignored; only
// .rctest.html files will be processed.
// <P>
// The <code>testRoot</code> directory is passed to TestRunner when you execute it.  In the
// database and in emails, test are identified by their directory path relative to
// <code>testRoot</code>.
// <P>
// Adding a test to the test suite is as simple as placing the .rctest.html file somewhere under
// the <code>testRoot</code> directory; on the next TestRunner execution, TestRunner will
// notice the new test and start reporting results for it (including reporting it as a failure
// if it fails in its very first run).
// <P>
// The included test result viewing application (see below) also provides an interface to
// upload tests if you prefer not to allow direct filesystem access to the machine where
// TestRunner executes.
// <P>
// <h3>Running Test Runner</h3>
// <P>
// TestRunner is an ordinary Java class - com.isomorphic.autotest.TestRunner - and can be run
// from the command line in the usual fashion, or run programmatically from within a Java
// application using the wrapper class com.isomorphic.autotest.TestRunnerDriver.  We also
// provide convenience scripts to run the TestRunner Java class in the SDK root directory.
// <P>
// Minimally, TestRunner needs to know the base directory of a set of test files.  All files
// saved anywhere under this base directory which end in the extension .rctest.html will be
// assumed to be Selenese test files and executed.
// <P>
// As is standard for Selenese test files, the first command in the file is typically an "open"
// command with the URL of the application which should be opened in a browser so that
// subsequent commands can be run.
// <P>
// The assumption is that the application that will be tested is already deployed by the time
// TestRunner is run; how to automate building and deployment of applications is outside of the
// scope of this document, however, the recommendation is that a Revision-Control System (such
// as SVN, git or CVS) is used, and that every time a developer "checks in" or "commits"
// changes, the application being tested is built and deployed to a test server, then TestRunner
// is run.  Continuous Build Servers (such as Hudson, Bamboo or CruiseControl) may help
// automate the step of building from source control and deploying to a test server, then such
// a Build Server can typically be configured to trigger TestRunner.
// <P>
// TestRunner requires several resources to be in expected default locations from the current
// directory unless you provide overrides via the command line or +link{server_properties,server.properties}.
// Some of
// the required resources are:
// <ul>
//    <li> the batch report email template, by default at mailTemplats/batchReport.template
//    <li> the selenium test template, user extensions, and batchRun/testResult dataSource
//         XML files, by default in tools/selenium
//    <li> the dataSource XML schema files, by default in isomorphic/system/schema
// </ul>
// <P>
// <h4>Command-line Examples</h4>
// <P>
// The following command-line would run TestRunner, execute all tests under the default
// testRoot directory "tests", and commit the results:
// <pre>
// java com.isomorphic.autotest.TestRunner</pre>
// This assumes your classpath environment has been set to include the isomorphic SDK JARs;
// you may invoke the convenience script test_runner.sh/.bat/.command in the SDK root directory
// to run the TestRunner Java class without having to set the classpath.
// <P>
// The following command-line would execute TestRunner as above, but run all tests under the
// directory "foo/bar" relative to the current directory, and email a report of the results:
// <pre>
// java com.isomorphic.autotest.TestRunner -tr foo/bar -e user@company.com</pre>
//
// To do the same, but only run a particular test, you can use the files option (-f):
// <pre>
// java com.isomorphic.autotest.TestRunner -tr foo/bar -c -f test1.rctest.html -e user@company.com</pre>
// Note that when a file is specified, the default is not to commit the results unless
// requested via the commit option (-c).
// <P>
// <h4>Java API</h4>
// <P>
// The following Java code would do the same as the last command-line example:
// <pre>
//     TestRunnerDriver driver = new TestRunnerDriver();
//     driver.setTestRoot("foo/bar");
//     driver.setBatchCommit(true);
//     driver.setFiles(new String[] { "test1.rctest.html" });
//     driver.setAlertEmail("user@company.com");
//     driver.run();
// </pre>
// <P>
// <h4>TestRunner Configuration</h4>
// <P>
// TestRunner supports several more command-line options, or equivalent settings that can be
// applied via Java.  The following table summarizes the command-line options, equivalent Java
// Setter in the DriverConfiguration interface, and it's behavior (including default behavior).
// <P>
// <table border="1">
//  <thead>
//    <tr><th>Command-line Option</th><th>Java Setter</th>
//    <th>+link{server_properties,server.properties} Name</th><th>Behavior</th></tr>
//  <thead>
//  <tbody>
//     <tr><td>-b &lt;browser&gt;</td><td>setBrowser</td><td>N/A</td>
//     <td>Specifies the browser string passed to Selenium. Default is <b>*firefox</b>
//     See +link{usingSelenium}</td></tr>
//     <tr><td>-br &lt;branch&gt;</td><td>setBranch</td><td>autotest.branch</td>
//     <td>Specifies a branch for the batch, used in the batch run record and email
//     notification.  Default is <b>MAIN</b>.Test result comparison occurs per branch.</td></tr>
//     <tr><td>-c/-nc</td><td>setBatchCommit</td><td>N/A</td>
//     <td>This pair of argumentless options allows you to force the batch results to
//     be committed (-c) or not committed (-nc).  This is useful to override the default
//     of committing (or of not committing if the -f option has been passed).</td></tr>
//     <tr><td>-cs</td><td>setCaptureScreenshot</td><td>N/A</td><td>
//     Configures TestRunner to capture a PNG screenshot of the browser if a
//     Selenium test fails, adding the image to the test result record.</td></tr>
//     <tr><td>-f &lt;files&gt;</td><td>setFiles</td><td>N/A</td><td>Specifies a file or list
//     of files to run. This option can restrict which Selenium scripts under testRoot get run.
//     Relative paths from the testRoot or bare filenames may be provided. When present,
//     this option also disables the default behavior of committing test results.</td></tr>
//     <tr><td>-fr &lt;path&gt;</td><td>setFileRoot</td><td>N/A</td><td>Sets the root directory
//     for all other file system paths.  If not set, defaults to current working directory where
//     Java was launched, or the web server root if TestRunner is run in a servlet.</td></tr>
//     <tr><td>-h</td><td>N/A</td><td>N/A</td><td>Lists available command-line options.</td></tr>
//     <tr><td>-hp &lt;port&gt;</td><td>setHttpPort</td><td>N/A</td>
//     <td>Sets the web server port Selenium should use to run the tests.
//     Default is <b>8080</b></td></tr>
//     <tr><td>-ht &lt;host/IP&gt;</td><td>setHttpTarget</td><td>N/A</td>
//     <td>Sets the target web server Selenium should use to run the tests.
//     Default is <b>localhost</b></td></tr>
//     <tr><td>-lg &lt;message&gt;</td><td>setBatchLog</td><td>N/A</td><td>Provides a
//     log message to include in the record for this batch run. (No Default)</td></tr>
//     <tr><td>-lp</td><td>N/A</td><td>N/A</td>
//     <td>Informs TestRunner that a message or file has been piped to STDIN as the
//     batch log message.</td></tr>
//     <tr><td>-sm</td><td>setSaveMessages</td><td>N/A</td>
//     <td>Configures TestRunner to save the client log messages for each test to the
//     associated test record if the test fails.</td></tr>
//     <tr><td>-sr &lt;path&gt;</td><td>setServerFileRoot</td><td>N/A</td>
//     <td>Sets the serverFileRoot directory. Default is <b>/</b>. Selenium scripts executing
//     open() commands on the httpTarget server will by use this default path.</td></tr>
//     <tr><td>-t &lt;timestamp&gt;</td><td>setTimestamp</td><td>N/A</td>
//     <td>Forces comparison of the batch results to be against the batch run with a
//     timestamp closest to that provided, rather than the most recent batch run.  Format
//     is "2012-12-31 23:59:59" in the local time zone.</td></tr>
//     <tr><td>-tr &lt;path&gt;</td><td>setTestRoot</td><td>autotest.testRoot</td>
//     <td>Sets the testRoot directory relative to the current directory. By default, its
//     value is <b>tests</b>, and all Selenium scripts under the testRoot will be executed
//     by TestRunner.</td><tr>
//     <tr><td>-un &lt;userName&gt;</td><td>setUserName</td><td>autotest.userName</td>
//     <td>Specifies a user name for the batch run record. (No Default)</td></tr>
//     <tr><td>-vm &lt;mode&gt;</td><td>setServerLogMode</td><td>N/A</td>
//     <td>Configures TestRunner to collect the server log messages for each test if
//     it fails.  Legal modes are "none", "some", or "all".  Default is <b>some</b>.</td></tr>
//     <tr><td>-vo &lt;out&gt;</td><td>setServerLogOutputMethod</td><td>N/A</td>
//     <td>Configures the output method that TestRunner will use to report or persist
//     any server log messages; only has an effect for server log modes of "some" or "all".
//     Legal values are "email", "datasource", or "both".  Default is <b>email</b>.</td></tr>
//     <tr><td>-x/-nx</td><td>setMaximizeBrowser</td><td>N/A</td>
//     <td>Sets whether to maximize the browser for Selenium tests.  If not explicitly
//     set via this call, the browser will be maximized if and only if screenshots
//     are being taken.</td></tr>
//  </tbody>
// </table>
// <P>
// <h3>Email Notifications</h3>
// <P>
// At completion of the batch of tests, TestRunner can automatically send out an email
// notification summarizing the results of the test run, including error messages for
// any newly failing tests.  A velocity template file is used to control its format; see
// +link{group:velocitySupport, Velocity Support}.
// The following velocity variables are available:
// <P>
// <ul>
//     <li><b>$firstBatchFound</b>. Whether baseline batch was found with which to compare</li>
//     <li><b>$fixed</b>. A list of the test results for tests fixed in this batch run</li>
//     <li><b>$regression</b>. A list of the test results for tests broken in this batch run</li>
//     <li><b>$totalTestFiles</b>. The total number of tests run in this batch run</li>
//     <li><b>$passedTestFiles</b>. The number of tests that passed  in this batch run</li>
//     <li><b>$batchStartTime</b>. Timestamp associated with start of this batch run</li>
//     <li><b>$batchLog</b>. Log message, if any was provided for this batch run</li>
// </ul>
// A sample/default template is provided as the file <b>mailTemplates/batchReport.template</b>.
// <P>
// The following options govern the Email Notifications:
// <table border="1">
//  <thead>
//    <tr><th>Command-line Option</th><th>Java Setter</th>
//    <th>+link{server_properties,server.properties} Name</th><th>Behavior</th></tr>
//  <thead>
//  <tbody>
//     <tr><td>-cc &lt;recipient&gt;</td><td>setCcEmail</td><td>autotest.ccEmail</td>
//     <td>Sets the recipient email address for batch report email.  This recipient will
//     always be cc'd a copy of the batch report email, regardless of whether fixes or
//     regressions are present. (No Default)</td></tr>
//     <tr><td>-e &lt;recipient&gt;</td><td>setAlertEmail</td><td>autotest.alertEmail</td>
//     <td>Sets the recipient email address for batch report email.  If the "repeat email"
//     recipient address has also been set via -re, this address will only be sent "alert
//     email" reports where fixes or regressions are present.  Otherwise, it will receive all
//     batch report email.  (No Default)</td></tr>
//     <tr><td>-m &lt;mailHost&gt;</td><td>setMailHost</td><td>autotest.mailHost</td>
//     <td>Specifies what mail host to use to send mail.  If not provided, your mail
//     software will decide what host to use.</td></tr>
//     <tr><td>-ms &lt;subject&gt;</td><td>setMailSubject</td><td>autotest.mailSubject</td>
//     <td>Sets subject line base to use when sending the email reporting batch results.
//     Regressions and fixes info will be appended to the provided subject content.</td></tr>
//     <tr><td>-mt &lt;file&gt;</td><td>setMailTemplate</td><td>autotest.mailTemplate</td>
//     <td>Specifies what velocity template file to use when generating the batch report
//     email for this batch run. Default is <b>mailTemplates/batchReport.template</b></td></tr>
//     <tr><td>-ne</td><td>setNoEmail</td><td>N/A</td><td>Disables sending any email for
//     the batch run. If recipient email addresses have not been set through the
//     command line, Java setters, or server.properties, it's not needed.  However, it
//     may be useful in suppressing email in cases where they have been set.</td></tr>
//     <tr><td>-re &lt;recipient&gt;</td><td>setRepeatEmail</td><td>autotest.repeatEmail</td>
//     <td>Sets the recipient email address for batch report email.  If the "alert email"
//     recipient address has also been set via -e, this address will only be sent "repeat
//     email" reports where no fixes or regressions are present.  Otherwise, it will receive
//     all batch report email.  (No Default)</td></tr>
//     <tr><td>-se &lt;sender&gt;</td><td>setSenderEmail</td><td>autotest.senderEmail</td>
//     <td>Sets the sender email address for batch report email.  Only needed if there is
//     a problem sending email using the sender address generated by default.</td></tr>
//  </tbody>
// </table>
// <P>
// Note: If you choose not to have any email sent upon completion of a batch run, and decide
// not to commit the results to the DataSources, the results of each batch run can still be
// determined by examing the Java console log, which captures the output of each RC test script.
// <P>
// <h3>Result Viewer</h3>
// <P>
// TestRunner comes with a very very simple application for interactively viewing and searching
// test results, implemented in &#83;martClient technology.  This application is meant as a
// starting point for building your own application for interactive viewing of test results, if
// you prefer to go beyond email notifications.
// <P>
// The source code for this application is just a single testResultViewer.jsp file in the "selenium"
// directory in the SDK; copy it anywhere under <code>webroot</code> in a project that includes
// the SmartClient Server and it will function.
// <P>
// The result viewing application also includes the ability to upload new test files to
// <code>testRoot</code> as an alternative to providing testers with direct access to the
// filesystem for the machine where TestRunner executes.
// <P>
// <h3>Getting Started FAQ</h3>
// <P>
// <smartclient>
// Q: When I run TestRunner, I want to target the SmartClient server, but TestRunner fails
// due to HSQLDB reporting a locked database.<BR>
// A: You must stop the SC server running from the same SDK installation as TestRunner before
// running TestRunner.  Another copy of the SDK may be installed elsewhere on the same machine,
// or TestRunner may be pointed at a different machine using the -ht comand-line option.
// </smartclient>
// <smartgwt>
// Q: When I run TestRunner, I want to target the SGWT showcase, but TestRunner fails due to
// HSQLDB reporting a locked database.<BR>
// A: By default, TestRunner uses the HSQLDB associated with the SGWT showcase when run from
// the SGWT ZIP root directory.  Therefore, if samples/showcase/war has been deployed to a
// webserver, you must stop it before running TestRunner.  One simple alternative is to deploy
// the file showcase.war from the SGWT ZIP root, which has a separate copy of the HSQLDB.  You
// may also simply install another copy of the SGWT ZIP in a different location on the same
// machine, or point TestRunner at a different machine using the -ht command-line option.
// </smartgwt>
// <P>
// Q: When I run TestRunner, TestRunner fails reporting that DataSource BatchRun or TestResult
// cannot be found.<BR>
// A: These DataSources must be imported into the default HSQLDB before TestRunner can be used.
// <smartclient>
// Use the "import" option of tools/adminConsole.jsp under the SDK installation root directory
// </smartclient>
// <smartgwt>
// Use the "import" option of showcase/tools/adminConsole.jsp under the deployed SGWT showcase
// </smartgwt>
// to select and import the BatchRun and TestResult DataSources prior to running TestRunner.
//
// @treeLocation Concepts/Automated Testing
// @title TestRunner
// @visibility external
//<

//> @class AutoTest
// Standalone class providing a general interface for integration with Automated Testing Tools
// <p>
// <smartclient>
// For automated testing tools we need a way to create string identifiers for DOM elements such that
// when a page is reloaded, we can retrieve a functionally equivalent DOM element. We call these
// +link{AutoTestLocator,autoTestLocators}.
// <p>
// This allows automated testing tools to set up or record user generated events on DOM elements
// then play them back on page reload and have our components react correctly.
// <P>
// The primary APIs for the AutoTest subsystem are +link{AutoTest.getLocator()} and
// +link{AutoTest.getElement()}.
// <P>
// Implementation considerations:
// <ul>
// <li> Some components react to the structure of DOM elements embedded within them - for example
//   GridRenderer cells have meaning to the grid. So in some cases we need to identify elements
//   within a component, while in others we can just return a pointer to a handle (A simple
//   canvas click handler doesn't care about what native DOM element within the  handle received
//   the click).
//
// <li>When a DOM element is contained by a component, it is not sufficient to store the component
//   ID. Most SmartClient components are auto-generated by their parents, and rather than
//   attempting to store a specific component identifier we should instead store the
//   "logical function" of the component.<br>
//   For example a listGrid header button may have a different auto-generated ID across page
//   reloads due to various timing-related issues (which can change the order of of widget
//   creation), loading a new skin, or otherwise trivial changes to an application.<br>
//   Rather than storing the header button ID therefore, we want to store this as
//   a string meaning "The header button representing field X within this list grid".
//
// <li>fallback strategies: In some cases a component or DOM element can be identified in
//   several ways. For example a cell in a ListGrid can be identified by simple row and
//   column index, but also by fieldName and record primary key value. In these cases we
//   attempt to record information for multiple locator strategies and then when parsing
//   stored values we can provide APIs to govern which strategy is preferred. See the
//   +link{type:LocatorStrategy} documentation for more on this.
// </ul>
//
// In order to address these concerns the AutoTest locator pattern is similar to an
// XPath type structure, containing a root component identifier, followed by
// details of sub-components and then potentially details used to identify an element within
// the components handle in the DOM.
// <br>
// The actual implementation covers a large number of common cases, including (but not limited to)
// the following. Note that for cases where an element is being identified from a pool of
// possible candidates, such as the +link{canvas.children} array, we usually will use
// +link{LocatorStrategy,fallback locator paths} rather than simply relying on index:
// <ul><li>Root level components identified by explicit ID</li>
//     <li>Any +link{autoChild,autoChildren}</li>
//     <li>Standard component parts such as scrollbars, edges, shadows, etc</li>
//     <li>Section stack items and headers</li>
//     <li>Window items</li>
//     <li>ListGrid headers and cells</li>
//     <li>TreeGrid headers and cells, including interactive open icon, checkbox icons</li>
//     <li>DynamicForm form items, including details of elements within those items</li>
// </ul>
// </smartclient>
//
// @treeLocation Concepts/Automated Testing
// @visibility external
// @group autoTest
//<

//> @type AutoTestLocator
// An autoTestLocator is an xpath-like string used by the AutoTest subsystem to robustly
// identify DOM elements within a SmartClient application.
// <P>
// Typically AutoTestLocators will not be hand-written - they should be retrieved by a
// call to +link{AutoTest.getLocator()}. Note also that the +link{group:debugging,Developer Console}
// has built-in functionality to create and display autoTestLocators for a live app.
//
// @group autoTest
// @visibility external
//<

// Document AutoTestObjectLocator as a separate type. As currently implemented it is always a
// valid standard Locator string, but that's an implementation detail and may not always be the case.
//> @type AutoTestObjectLocator
// A string that uses similar syntax to an +link{type:AutoTestLocator}, but is expected to
// resolve to a live SmartClient object such as a +link{Canvas}, or +link{FormItem} rather than
// some element within the DOM. These are created via +link{AutoTest.getObjectLocator()} and
// +link{AutoTest.getRelativeObjectLocator()}
// @group autoTest
// @visibility rules
//<




isc.defineClass("AutoTest");


isc.AutoTest.addClassMethods({

    locatorsEqual : function (locator1, locator2) {
        if (locator1 && locator2) {
            locator1 = locator1.replace(/^[^\/]*(\/\/.*?)[\/]*$/, "$1");
            locator2 = locator2.replace(/^[^\/]*(\/\/.*?)[\/]*$/, "$1");
        }
        return locator1 == locator2;
    },

    //> @classMethod AutoTest.getLocator()
    // Returns the +link{type:AutoTestLocator} associated with some DOM element in a SmartClient
    // application page.  If coords, representing the page position, is passed in, the locator
    // may be generated with a specific trailing "target area" identifer that will map back to
    // the appropriate, potentially different, physical coordinates, even if the widget is
    // moved.  The coords argument will only have an effect in cases where the mouse position
    // over the target could potentially change behavior.
    // @param DOMElement (DOMElement) DOM element within in the page. If null the locator for
    //  the last mouse event target will be generated
    // @param [checkForNativeHandling] (boolean) If this parameter is passed in, check whether
    //  the target element responds to native browser events directly rather than going through
    //  the SmartClient widget/event handling model. If we detect this case, return null rather
    //  than a live locator.  This allows us to differentiate between (for example) an event on
    //  a Canvas handle, and an event occurring directly on a simple
    //  <code>&lt;a href=...&gt;</code> tag written inside a Canvas handle.
    // @param [coords] (array) X, Y page position
    // @return (AutoTestLocator) Locator string allowing the AutoTest subsystem to find
    //   an equivalent DOM element on subsequent page loads.
    // @visibility external
    // @group autoTest
    //<
    getLocator : function (DOMElement, checkForNativeHandling, coords) {
        var lastEvent = isc.EH.lastEvent, fromEvent;
        if (lastEvent) {
            if (DOMElement == null) {
                DOMElement = lastEvent.nativeTarget;
                fromEvent = true;
            }
            if (coords == null) {
                coords = [isc.EH.getX(), isc.EH.getY()];
            }
        }
        var canvas;
        if (isc.isA.Canvas(DOMElement)) {
            canvas = DOMElement;
            DOMElement = canvas.getHandle();
        } else {
            canvas = isc.AutoTest.locateCanvasFromDOMElement(DOMElement);
        }
        var locator = canvas ? canvas.getLocator(DOMElement, fromEvent, coords) : "";
        if (checkForNativeHandling && locator && locator != "" &&
            canvas.checkLocatorForNativeElement(locator, DOMElement))
        {
            locator = "";
        }
        return locator;

    },

    //> @classMethod AutoTest.getObjectLocator()
    // Method to derive a locator string for identifying a SmartClient object. This is
    // a SmartClient component, a FormItem, or SectionStackSection.
    // <P>
    // Use +link{AutoTest.getObject()} to resolve an object locator to a live object.
    //
    // @param target (Canvas or FormItem or SectionStackSection) target for the locator.
    // @return (AutoTestObjectLocator) generated locator
    // @visibility rules
    //<

    getObjectLocator : function (target) {

        // We can be passed
        // - a FormItem.
        // - a SectionStackSection.
        // - a Canvas.
        // _getCanvasForSCObject will resolve to the nearest "canvas" which will be
        // capable of generating a locator for the actual object.
        var targetCanvas = this._getCanvasForSCObject(target);
        var canvasLocator = targetCanvas.getLocator();

        if (targetCanvas == target) {
            return canvasLocator;
        }

        // The 'interiorLocator' will be the xpath to the target object, plus an "objectType" flag
        // we can parse back later.
        var interiorLocator = targetCanvas.getObjectLocator(target);
        if (interiorLocator != null) canvasLocator += "/" + interiorLocator;
        return canvasLocator;
    },

    //> @classMethod AutoTest.getFormItemIconLocator()
    // Method to derive a locator string for identifying a SmartClient FormItemIcon object.
    // <P>
    // Use +link{AutoTest.getObject()} to resolve an object locator to a live object.
    //
    // @param formItem (FormItem) parent FormItem for the target icon.
    // @param icon (FormItemIcon) target for the locator.
    // @return (AutoTestObjectLocator) generated locator
    // @visibility rules
    //<
    getFormItemIconLocator : function (formItem, icon) {

        var targetCanvas = formItem;
        var canvasLocator = targetCanvas.getLocator();

        // The 'interiorLocator' will be the xpath to the target object, plus an "objectType" flag
        // we can parse back later.
        var interiorLocator = targetCanvas.getObjectLocator(icon);
        if (interiorLocator != null) canvasLocator += "/" + interiorLocator;
        return canvasLocator;
    },

    //> @classMethod AutoTest.getMenuItemLocator()
    // Method to derive a locator string for identifying a SmartClient MenuItem object.
    // <P>
    // Use +link{AutoTest.getObject()} to resolve an object locator to a live object.
    //
    // @param menu (Menu) parent Menu for the target record.
    // @param record (Record) target for the locator.
    // @return (AutoTestObjectLocator) generated locator
    // @visibility rules
    //<
    getMenuItemLocator : function (menu, record) {

        var targetCanvas = menu;
        var canvasLocator = targetCanvas.getLocator();

        // The 'interiorLocator' will be the xpath to the target object, plus an "objectType" flag
        // we can parse back later.
        var interiorLocator = targetCanvas.getObjectLocator(record);
        if (interiorLocator != null) canvasLocator += "/" + interiorLocator;
        return canvasLocator;
    },

    // Helper - extract the "object type" from a locator string.

    getLocatorObjectType : function (locator) {
        var objectTypeInfo = locator.substring(locator.lastIndexOf("/")+1);
        if (objectTypeInfo && objectTypeInfo.startsWith("objectType=")) {
            return objectTypeInfo.substring(11);
        }
        return "Canvas";
    },


    //> @classMethod AutoTest.locateCanvasFromDOMElement()
    // Given an element in the DOM, returns the canvas containing this element, or null if
    // the element is not contained in any canvas handle.
    // @param element (DOMElement) DOM element within in the page
    // @visibility external
    // @group autoTest
    //<
    locateCanvasFromDOMElement : function (element) {
        return isc.EH.getEventTargetCanvas(null, element);
    },

    // helper similar to locateCanvasFromDOMElement() above;
    // element must be a DynamicForm or DOM element - not a locator
    locateFormItemFromDOMElement : function (element) {
        var form = isc.isA.Canvas(element) ? element :
             this.locateCanvasFromDOMElement(element);
        if (!isc.isA.DynamicForm(form)) return null;

        var itemInfo = isc.DynamicForm._getItemInfoFromElement(element, form);
        return itemInfo ? itemInfo.item : null;
    },

    //> @classMethod AutoTest.getRelativeLocator()
    // Method to derive a relative locator string for identifying a DOMElement ultimately nested
    // within some baseComponent.
    // <P>
    // This is useful for cases where a standard pattern of components may be reused within
    // an application - for example multiple Windows containing the same UI within them.
    // In this case the developer can get a 'relative locator' from the base compoent (the Window)
    // to some nested DOM element (may be nested within a number of intervening canvaes),
    // and reuse the locator for other base components (in our example,
    // other Windows) with the same structure of descendents.
    // <P>
    // Use +link{AutoTest.resolveRelativeLocator()} to resolve a relativeLocator plus
    // baseComponent SmartClient object.
    //
    // @param baseComponent (Canvas) base component for the relative locator
    // @param target (DOMElement) target for the relative locator.
    // @return (AutoTestLocator) generated locator
    // @visibility rules
    //<
    getRelativeLocator : function (baseComponent, target) {
        // normal behavior if passed a DOM element:
        var targetCanvas = this.locateCanvasFromDOMElement(target),
            locator = this.getRelativeCanvasLocator(baseComponent, targetCanvas) + "/"
                        + targetCanvas.getInteriorLocator(target);
        return locator;
    },

    // helper to test whether some locator is relative or absolute
    isRelativeLocator : function (locator) {
        return (!locator.startsWith("//"));
    },

    getRelativeCanvasLocator : function (baseComponent, targetCanvas) {
        if (baseComponent == targetCanvas) return "";
        // Build the path (needs a loop)
        var currentCanvas = targetCanvas,
            locators = [];
        while (currentCanvas != baseComponent) {
            var parentCanvas = currentCanvas.getLocatorParent();
            // If we don't find a relationship between the base and the child
            // there's not a lot we can do...
            if (parentCanvas == null) {
                this.logWarn("Unexpected error: attempting to get relative locator from baseComponent:"
                    + baseComponent + " and target:"+ targetCanvas + ". Unable to determine "
                    + "relationship between these objects.");
                return "";
            }
            var canvasLocator = parentCanvas.getChildLocator(currentCanvas);
            if (canvasLocator != null) locators.add(canvasLocator);
            currentCanvas = parentCanvas;
        }
        // Locators array is backwards since we iterated up the hierarchy! flip and join
        var locatorString = "";
        for (var i = locators.length-1; i >=0; i--) {
            locatorString += locators[i];
            if (i != 0) locatorString += "/";
        }

        return locatorString;
    },

    //> @classMethod AutoTest.getRelativeObjectLocator()
    // Method to derive a relative locator string for identifying a or SmartClient object within
    // some baseComponent.
    // <P>
    // This is useful for cases where a standard pattern of components may be reused within
    // an application - for example multiple Windows containing the same UI within them.
    // In this case the developer can get a 'relative locator' from the base compoent (the Window)
    // to some nested sub object, and reuse the locator for other base components (in our example,
    // other Windows) with the same structure of descendents.
    // <P>
    // Use +link{AutoTest.resolveRelativeObjectLocator()} to resolve a relativeLocator plus
    // baseComponent SmartClient object.
    // <P>
    // <b>Note:</b> For working with relativeLocators and DOM elements directly, use
    // +link{AutoTest.getRelativeLocator()} and +link{AutoTest.resolveRelativeLocator()}.
    //
    // @param baseComponent (Canvas) base component for the relative locator
    // @param target (Canvas or FormItem or SectionStackSection) target for the relative locator.
    // @return (AutoTestObjectLocator) generated locator
    // @visibility rules
    //<


    getRelativeObjectLocator : function (baseComponent, target) {

        // We can be passed
        // - a FormItem.
        // - a SectionStackSection.
        // - a Canvas.
        // _getCanvasForSCObject will resolve to the nearest "canvas" which will be
        // capable of generating a locator for the actual object.
        var targetCanvas = this._getCanvasForSCObject(target);
        var canvasLocator = this.getRelativeCanvasLocator(baseComponent, targetCanvas);

        if (targetCanvas == target) {
            return canvasLocator;
        }

        var interiorLocator = targetCanvas.getObjectLocator(target);
        if (interiorLocator != null) canvasLocator += "/" + interiorLocator;
        return canvasLocator;

    },
    _getCanvasForSCObject : function (target) {
        // Existing AutoTest APIs (getChildLocator etc) can't handle FormItem etc since
        // there's no property pointing to the containing widget (EG DynamicForm) which would
        // have an understanding of the object passed in.
        // We'll have to resolve these explicitly here looking at properties on the object
        // passed in.


        // SectionStackSection: We create a SectionHeader for each section (even if it isn't shown)
        // Grab this widget and use 'parentElement' to get a pointer to the stack
        if (target._sectionHeader != null) target = target._sectionHeader;
        if (target.isSectionHeader) {
            return target.parentElement;
        }

        // If passed a form item, use item.form
        if (isc.FormItem && isc.isA.FormItem(target)) return target.form;

        if (isc.isA.Canvas(target)) return target;

        this.logWarn("getRelativeLocatorObject() passed target object:" + this.echo(target) +
            " This is not a recognized supported SmartClient object - expected to be a " +
            "Canvas, FormItem or SectionStackSection only");
        return null;

    },

    // ------------------------------
    // Retrieving elements from the DOM based on locator string

    //> @classMethod AutoTest.getElement()
    // @param locator (AutoTestLocator) Locator String previously returned by
    //       +link{AutoTest.getLocator()}
    // @return (DOMElement) DOM element this locator refers to in the running application, or
    // null if not found
    // @visibility external
    // @group autoTest
    //<

    getElement : function (locator) {
        return this.getAttribute(locator, isc.Canvas._$Element);
    },

    //> @classMethod AutoTest.getObject()
    // Given an +link{AutoTestLocator}, return the live SmartClient object it refers to, if any.
    // @param locator (AutoTestLocator) Locator String previously returned by
    //       +link{AutoTest.getLocator()}
    // @return (Canvas or FormItem or SectionStackSection) target object, or null if
    //  unable to resolve the locator to a live object.
    // @visibility external
    // @group autoTest
    //<
    getObject : function (locator) {
        return this.getAttribute(locator, isc.Canvas._$Object);
    },


    getObjectContext : function (locator) {
        var targetObject = isc.AutoTest.getObject(locator);
        if (targetObject == null) return null;

        return this._getObjectContext(targetObject, locator);
    },

    getRelativeObjectContext : function (baseComponent, locator) {
        var targetObject = isc.AutoTest.resolveRelativeObjectLocator(baseComponent, locator);
        if (targetObject == null) return null;

        return this._getObjectContext(targetObject, locator);
    },

    _getObjectContext : function (targetObject, locator) {
        var context = {
            locator: locator,
            object: targetObject
        }


        if (isc.isA.FormItem(targetObject)) {
            context.objectType = "FormItem";
            context.container = targetObject.containerWidget;
        } else if (targetObject.isSectionHeader) {
            context.objectType = "Section";
            // targetObject will probably be the Canvas but in case
            // we ever get a pointer to the actual config object, resolve it:
            if (targetObject.getSectionHeader) {
                context.object = targetObject.getSectionHeader();
            }

            context.container = targetObject.parentElement;
        } else if (isc.isA.Canvas(targetObject)) {
            context.objectType = "Canvas";
            // no 'container' - we'll just hide the canvas.
        } else {
            // Target objects that are not class instances like FormItemIcon, MenuItem, etc.
            var locatorType = isc.AutoTest.getLocatorObjectType(locator);
            if (locatorType == "FormItemIcon") {
                context.objectType = locatorType;
                context.container = isc.AutoTest.getLocatorFormItem(locator);
            } else if (locatorType == "MenuItem") {
                context.objectType = locatorType;
                context.container = isc.AutoTest.getLocatorCanvas(locator);
            }
        }

        return context;
    },

    //> @classMethod AutoTest.getValue()
    // Given an +link{AutoTestLocator} that refers to a live SmartClient object or a logical
    // subcomponent of that object, return the associated meaningful JS value, if any.
    // <P>
    // For example:
    // <ul>
    //     <li> For a locator to a ListGrid/CubeGrid cell, return the cell's value
    //     <li> For a locator to a FormItem, return the FormItem's value
    //     <li> For a locator to a ListGrid field header, return the checkbox/sorting state
    //     <li> For a locator to a Calendar EventCanvas header or body, return the text
    // </ul>
    // @param locator (AutoTestLocator) Locator String previously returned by
    //       +link{AutoTest.getLocator()}
    // @return (Object) value associated with SC object if any, otherwise undefined
    // @visibility external
    // @group autoTest
    //<
    getValue : function (locator) {
        return this.getAttribute(locator, isc.Canvas._$Value);
    },

    isSelected : function (locator) {
        return this.getAttribute(locator, isc.Canvas._$Selected);
    },

    getAttribute : function (locator, attribute) {
        if (!locator) return null;


        locator = locator.replace(/^(scLocator|ScID)=/i, "");

        // trim off quote chars from the start/end of the string

        if (locator.startsWith("'") || locator.startsWith('"')) locator = locator.substring(1);
        if (locator.endsWith("'") || locator.endsWith('"')) locator = locator.substring(0,locator.length-1);

        if (!locator.startsWith("//")) {
            // assume either just an ID or "ID=[ID]"
            if (locator.startsWith("ID=") || locator.startsWith("id=")) {
                locator = locator.substring(3);
            }
            locator = '//*any*[ID="' + locator + '"]';
        }

        // remove leading and trailing slashes before splitting
        var locatorArray = locator.trim("/").split("/"),
            component;

        var baseComponentID = locatorArray[0];
        if (!baseComponentID) return null;

        // knock off the baseComponent
        locatorArray = locatorArray.slice(1);

        var configuration = {attribute: attribute},
            baseComponent = this.getBaseComponentFromLocatorSubstring(baseComponentID,
                                                                      configuration);
        if (!baseComponent) return null;

        return baseComponent.getAttributeFromSplitLocator(locatorArray, configuration);
    },

    //> @classMethod AutoTest.resolveRelativeLocator()
    // Given a relative locator (retrieved from +link{AutoTest.getRelativeLocator()}) and a
    // base component, resolve it to the target element in the DOM.
    // @param baseComponent (Canvas) base component to resolve the relative locator from
    // @param relativeLocator (AutoTestLocator) relative locator retrieved from
    //  +link{AutoTest.getRelativeLocator()}
    // @return (DOMElement) target DOM element, or null if unable to resolve the relative path.
    //
    // @visibility rules
    //<
    resolveRelativeLocator : function (baseComponent, relativeLocator) {
        var splitLocatorArray = relativeLocator.split("/");
        return baseComponent.getAttributeFromSplitLocator(splitLocatorArray,
                                                          {attribute: isc.Canvas._$Element});
    },

    //> @classMethod AutoTest.resolveRelativeObjectLocator()
    // Given a relative locator (retrieved from +link{AutoTest.getRelativeObjectLocator()}) and a
    // base component, resolve it to the target SmartClient object. The SmartClient object may
    // be one of:
    // <ul>
    // <li>A Canvas</li>
    // <li>A FormItem</li>
    // <li>A SectionStackSection</li>
    // </ul>
    // @param baseComponent (Canvas) base component to resolve the relative locator from
    // @param relativeLocator (AutoTestObjectLocator) relative locator retrieved from
    //  +link{AutoTest.getRelativeObjectLocator()}
    // @return (Canvas or FormItem or SectionStackSection) target object, or null if
    //  unable to resolve the relative path.
    //
    // @visibility rules
    //<
    resolveRelativeObjectLocator : function (baseComponent, relativeLocator) {
        var splitLocator = isc.isAn.Array(relativeLocator) ? relativeLocator :
                                                             relativeLocator.split("/");
        return baseComponent.getAttributeFromSplitLocator(splitLocator,
                                                          {attribute:isc.Canvas._$Object});
    },

    //> @classMethod AutoTest.getPageCoords()
    // Returns the page-level coordinates corresponding to the supplied locator.  Note: The
    // physical position might change due to app redesign, but these coordinates would still
    // reflect the same logical part of the DOM element for components where event position
    // matters.
    // @param locator (AutoTestLocator) Locator String previously returned by
    //       +link{AutoTest.getLocator()}
    // @return (array) X, Y page position
    // @visibility external
    // @group autoTest
    //<
    getPageCoords : function (locator) {
        var element = this.getElement(locator);
        if (element == null) return;

        var canvas = this.locateCanvasFromDOMElement(element);
        return canvas ? canvas.getAutoTestLocatorCoords(locator, element) : null;
    },


    // getBaseComponentFromLocatorSubstring: This actually gets the *base* component from
    // a locator substring.
    // 2 possibilities:
    // - explicit ID (respect that)
    // - part of the array of top-level canvii
    getBaseComponentFromLocatorSubstring : function (substring, configuration) {
        var IDMatches = substring.match("(.*)\\[");
        var IDType = IDMatches ? IDMatches[1] : null;

        switch (IDType) {
            // if the recorded canvas had an auto-generated ID, try to find it by looking in the
            // top level (no parent) canvas array.
            // We'll look by name, title, then index by class, scClass and role!
        case "autoID":

            var config = isc.AutoTest.parseLocatorFallbackPath(substring),
                widgetConfig = config.config,
                strategy = "name",
                typeStrategy = "Class";

            var canvas = isc.Canvas.getCanvasFromFallbackLocator(
                substring, widgetConfig, isc.Canvas._topCanvii, strategy, typeStrategy);
            if (canvas == null) {
                this.setLogFailureText(true, "there's no top level Canvas identifiable " +
                    "by name or Class from fallback locator '" + substring + "' for locator");
            }
            return canvas;

        case "testRoot":

            var IDMatches = substring.match("testRoot\\[(.*)?\\]"),
                configSettings = IDMatches ? IDMatches[1] : null;

            // install any declared property bindings into the configuration
            if (configSettings) this.installLocatorConfiguration(configSettings, configuration);

            if (this.testRoot == null) {
                this.logWarn("Unable to process scLocators starting with " + this._$testRoot +
                             "... when no test root canvas has been configured");
                return null;
            }
            return this.testRoot;

        case "Menu":

            if (!isc.Menu) {
                this.setLogFailureText(true, "the Menu module is required " +
                                       "to resolve locator");
                return null;
            }

            var levelMatches = substring.match(/Menu\[level=(.*)(,.*)?\]/i),
                level = levelMatches ? levelMatches[1] : null;
            if (level != null) {
                var menu = isc.Menu.getMenuAtLevel(level);
                if (menu == null) {
                    this.setLogFailureText(true, "there is no Menu corresponding " +
                                           "to level '" + level + "' for locator");
                }
                return menu;
            }

            // fall through to allow legacy Menu locators to work!!!

        default:

            var className = IDType,
                IDMatches = substring.match('\\[ID=[\\"\'](.*)[\'\\"](,.*)?\\]'),
                ID = IDMatches ? IDMatches[1] : null;

            if (ID == null) {
                this.setLogFailureText(true, "there appears to be a " +
                                       "problem with the syntax for locator");
                return null;
            }

            // install any declared property bindings into the configuration
            if (IDMatches[2]) this.installLocatorConfiguration(IDMatches[2], configuration);

            var baseComponent = window[ID];
            if (!baseComponent) {
                this.setLogFailureText(true, "there is no " + className +
                                       "with ID '" + ID + "' for locator");
                return null;
            }

            if (baseComponent && className != "*any*" &&
                (!isc.isA[className] || !isc.isA[className](baseComponent)))
            {
                this.logWarn("AutoTest.getElement(): Component:"+ baseComponent +
                            " expected to be of class:" + className);
            }
            return baseComponent;
        }
    },

    //> @classMethod AutoTest.installLocatorConfiguration()
    // Inserts property bindings declared on scLocator into configuration object.
    // @param (String) bindings declaration from scLocator
    // @param (Object) configuration of this scLocator lookup
    //<
    installLocatorConfiguration : function (declaration, configuration) {
        if (!declaration) return;
        var bindings = declaration.split(",");
        for (var i = 0; i < bindings.length; i++) {
            var binding = bindings[i].trim().match("([^=]*)=([^=]*)");
            if (binding) configuration[binding[1]] = binding[2];
        }
    },

     // Retrieving SC objects from locator string
    //> @classMethod AutoTest.getLocatorCanvas()
    // Returns the Canvas for some previously generated locator string.
    // @param (AutoTestLocator) Locator String previously returned by +link{AutoTest.getLocator()}
    // @return (Canvas) Canvas associated with this locator
    // @visibility internal
    // @group autoTest
    //<

    getLocatorCanvas : function (locator) {


        // Simply get the DOM element and pick up the Canvas from it.
        // XXX this will not work if the Canvas is currently undrawn.
        /*
        var DOMElement = this.getElement(locator);
        if (DOMElement != null) {
            return this.locateCanvasFromDOMElement(DOMElement);
        }
        return null;
        */

        if (locator == null || isc.isAn.emptyString(locator)) return null;
        var locatorArray = locator.split("/"),
            component;

        // bail if the array isn't prefixed with expected '//' (scLocator is an xpath type identifier)
        if (locatorArray == null || locatorArray.length < 3) return null;

        //this.logWarn("locatorArray" + locatorArray);
        // account for the 2 slashes
        var baseComponentID = locatorArray[2];

        // knock off the first 3 slots
        var length = locatorArray.length;
        for (var i = 3; i < length; i++) {
            locatorArray[i-3] = locatorArray[i];
        }

        locatorArray.length = length-3;
        if (!baseComponentID) return null;

        var baseComponent = this.getBaseComponentFromLocatorSubstring(baseComponentID);
        if (baseComponent) {
            var i = 0,
                child = baseComponent.getChildFromLocatorSubstring(locatorArray[i], i, locatorArray);

            while (child != null) {
                i++;
                baseComponent = child;
                child = baseComponent.getChildFromLocatorSubstring(locatorArray[i], i, locatorArray);
            }
            return baseComponent;
        }
        return null;
    },

    //> @classMethod AutoTest.getLocatorFormItem()
    // Returns the FormItem for some previously generated locator string, or null if no
    // matching FormItem can be found.
    // @param (Locator) Locator String previously returned by +link{AutoTest.getLocator()}
    // @return (Canvas) Canvas associated with this locator
    // @visibility autoTest
    //<
    getLocatorFormItem : function (locator) {
        // Simply get the DOM element and pick up the DynamicForm/ FormItem from it.
        // XXX this will not work if the Canvas is currently undrawn.
        /*
        var DOMElement = this.getElement(locator);
        if (DOMElement != null) {
            var form = this.locateCanvasFromDOMElement(DOMElement);
            if (isc.isA.DynamicForm(form)) {
                var itemInfo = isc.DynamicForm._getItemInfoFromElement(DOMElement,form);
                if (itemInfo) return itemInfo.item;
            }
        }
        return null;
        */

        if (locator == null || isc.isAn.emptyString(locator)) return null;
        var locatorArray = locator.split("/"),
            component;

        // If it's not prefixed with "//", this isn't an SC-locator
        if (locatorArray == null || locatorArray.length < 3) return null;

        // account for the 2 slashes
        var baseComponentID = locatorArray[2];

        // knock off the first 3 slots
        var length = locatorArray.length;
        for (var i = 3; i < length; i++) {
            locatorArray[i-3] = locatorArray[i];
        }

        locatorArray.length = length-3;
        if (!baseComponentID) return null;

        var baseComponent = this.getBaseComponentFromLocatorSubstring(baseComponentID);
        if (baseComponent) {

            var child = baseComponent.getChildFromLocatorSubstring(locatorArray[0], 0, locatorArray);
            while (child != null) {
                locatorArray.removeAt(0);
                baseComponent = child;
                child = baseComponent.getChildFromLocatorSubstring(locatorArray[0], 0, locatorArray);
            }
        }
        if (isc.isA.DynamicForm(baseComponent)) {
            return baseComponent.getItemFromSplitLocator(locatorArray);
        }
        return null;
    },

    // Fallback locator subsystem:
    // For cases where there is more than one possible way to identify a component or element
    // we generate a string similar to this:
    // "row[a=b||b=c||7]"

    // createLocatorFallbackPath()
    // Takes a locator name and an object of the format:
    //   {fieldName:value, fieldName:value}
    // and returns a string in the format
    //   name[fieldName=value||fieldName=value...]
    // standalone values (with no "=" may also be included -- to do this set the "fallback_valueOnlyField"
    // property on the object passed in
    // For example:
    //   var identifier = {a:"b"};
    //   identifier[isc.AutoTest.fallback_valueOnlyField] = "c";
    //   isc.AutoTest.createLocatorFallbackPath("test", identifier);
    // would give back:
    //   "test[a:b||c]"

    fallback_valueOnlyField:"_$_standaloneProperty",

    fallback_startMarker:"[",
    fallback_endMarker:"]",
    fallback_separator:"||",
    fallback_equalMarker:"=",

    // If a property name contains the "/" character we can't store it as we use
    // simple string.split to break up based on this char.
    // Fix this by just sub-ing in a customizable marker when generating locators.

    slashMarker:"$fs$",

    createLocatorFallbackPath : function (name, config) {

        var locator = [];

        for (var field in config) {
            var fieldVal = config[field];

            // If a string contains "[", "||", etc we can get very confused
            // use 'escape' to HTML encode the string -- we'll unescape when parsing
            // We have to escape actual slashes too as this will break our logic to
            // break up stored locators.
            // use a regex to just replace them with a customizeable marker
            if (isc.isA.String(fieldVal)) {
                fieldVal = fieldVal.replaceAll("/",this.slashMarker);
                fieldVal = escape(fieldVal);
            }

            // Not worrying about other data types for now
            // Numbers / bools will convert automatically
            // If it becomes necessary we could encode dates, arr's, objects etc
            // and unencode on the way back

            if (field == this.fallback_valueOnlyField) {
                locator.add(fieldVal);
            } else {
                locator.add(field + this.fallback_equalMarker + fieldVal);
            }
        }
        return name + this.fallback_startMarker + locator.join(this.fallback_separator) +
                    this.fallback_endMarker;
    },

    _compareLocatorFallbackConfigValues : function (a, b) {
        if (isc.isA.Number(a) || isc.isA.Boolean(a)) a = a.toString();
        if (isc.isA.Number(b) || isc.isA.Boolean(b)) b = b.toString();
        return a == b;
    },

    // This method will take a generated locatorFallbackPath string and return a
    // standard config object as described above - property/field values will be unmapped
    // and any standalone value will be stored under the special
    // isc.AutoTest.fallback_valueOnlyField attribute name.
    parseLocatorFallbackPath : function (path) {
        var pathArr = path.split(this.fallback_startMarker);

        // don't crash if we were passed something we don't understand...
        if (pathArr == null || pathArr.length < 2) return;

        var name = pathArr[0],
            path = pathArr[1].substring(0, pathArr[1].length-this.fallback_endMarker.length);

        var configArr = path.split(this.fallback_separator),
            configObj = {};
        for (var i = 0; i < configArr.length; i++) {
            var string = configArr[i],
                equalsIndex = string.indexOf(this.fallback_equalMarker),
                fieldName;

            if (equalsIndex == -1) {
                fieldName = this.fallback_valueOnlyField;
            } else {
                fieldName = string.substring(0,equalsIndex);
                string = string.substring(equalsIndex+1);
            }

            // always unescape
            string = unescape(string);
            string = string.replaceAll(this.slashMarker, "/");
            configObj[fieldName] = string;

        }

        // BackCompat: Standard locator format (pre March 2010) was always of the format
        // item[1][Class="Canvas"]
        // This is still used where we don't run through the fallback-path subsystem but is
        // being incrementally replaced.
        // If we're passed a string of that format, pull the class out of the string passed in
        // and attach it to the config object.
        // This means that for any old auto-test recordings with the previous identifier format
        // if they end up running through this subsystem we should still have predictable results
        if (pathArr[2] != null) {
            var string = pathArr[2].substring(0, pathArr[2].length-this.fallback_endMarker.length),
                equalsIndex = string.indexOf(this.fallback_equalMarker),

                key = string.substring(0,equalsIndex),
                val = string.substring(equalsIndex+1);
            // if the string was quoted, eat the quotes!
            if (val.startsWith("\"")) val = val.substring(1, val.length-1);

            configObj[key] = val;
        }

        return {name:name, config:configObj};
    },



    // Generate a standard object "locator fallback path" identifier from an object,
    // similar to:
    //  member[title="foo"||index=1||Class="ImgButton"]
    //
    // Parameters:
    // - name attribute specifies the identifier type (in this example "member")
    // - canvas is the object to get an identifier for
    // - properties is an object specifying some default identifier properties to use which
    //   cannot be directly retrieved from the object. Typically used to specify the
    //   index of the object in the named array.
    // - mask is an object or array specifying properties to include in the locator string.
    //   If an array of strings, for each element store the same-named attribute from the object
    //   on the locator string
    //   If an object, for each entry, pick up the value field from the object and store it
    //   under the key on the locator string
    // * When getting properties from the object, use getters if present
    // * if AutoTest.fallback_valueOnlyField is included this will be included in the
    //   locator string with no key - for example
    //   member[1]
    //

    getObjectLocatorFallbackPath : function (name, object, properties, mask) {

        if (properties == null) properties = {};

        if (mask == null) mask = {
            title:"title",
            // we do this because widget.getClass() gives us the class object whereas
            // widget.getClassName gives us the name of the smartclient class...
            Class:"ClassName"
        };

        if (isc.isAn.Array(mask)) {

            for (var i = 0; i < mask.length; i++) {
                var value = object.getProperty ? object.getProperty(mask[i]) : object[mask[i]];
                if (value != null && !isc.isAn.emptyString(value)) properties[mask[i]] = value;
            }
        } else {
            for (var field in mask) {
                var value = object.getProperty ? object.getProperty(mask[field]) : object[mask[field]];
                if (value != null && !isc.isAn.emptyString(value)) properties[field] = value;
            }
        }

        // This will turn that config object into a standard locator type string.
        return isc.AutoTest.createLocatorFallbackPath(name, properties);
    },


    // Auto Test locators use various strategies to attempt to locate widgets. In some cases
    // we return a "best guess" type locator string -- for example an index in the members array
    // of a layout -- this is prone to return the wrong element if the page is restructured.
    // When actually retrieving elements from the DOM, we have some hints as to the fact that
    // our locator may be returning the wrong thing -- number of matching elements has changed
    // might be one of them, or the role / class of the widget we think matches is different
    // from what we recorded.
    // In these cases we'll log a warning.
    // This is a generic warning text which we can append to these warnings about how to
    // make identifying more robust in the future
    robustLocatorWarning:"If you are seeing unexpected results in recorded tests, it is likely" +
    " that the application has been modified since the test was recorded. We would recommend re-recording" +
    " your test script with the latest version of your application. Note that you may be able to" +
    " avoid seeing this message in future by using the AutoChild subsystem or providing explicit" +
    " global IDs to components whose function within the page is unlikely to change.",
    logRobustLocatorWarning : function () {
        if (this._loggedWarning) return;
        this.logWarn(this.robustLocatorWarning, "AutoTest");
        this._loggedWarning = true;
    },

    // This call provides a standard way to create a special DetailViewer instance
    // containing a set of test results (from .test file, Feature Explorer example, etc.)
    createDetailViewerForTestResults : function (canvas, results) {

        var seleniumPresent = isc.Browser.seleniumPresent;

        return isc.DetailViewer.create({
            ID:"isc_AutoTest_DetailViewer",
            left:canvas.getWidth() - 300,
            canDragReposition:true,
            width:280,
            showEmptyField:false,
            blockSeparator:"<BR>",
            autoDraw:true,
            fields: [{name:"result",
                         valueMap:{
                             failure:  "<font style='color:red;'>failure</font>",
                             disabled: "<font style='color:blue;'>disabled</font>"
                         }
                     },
                     {name:"description", escapeHTML:true,
                         formatCellValue : function (value, record) {

                             value = value.replace(/\s+/g, " ");
                             value = value.replace(/\<P\>/gi, "   ");
                             var showID = !seleniumPresent || !record._autoAssignedID;
                             if (record.ID && showID) value = record.ID + ": " + value;
                             if (value.length > 250) value = value.substring(0, 250) + "...";
                             return value;
                         }
                     },
                     {name:"detail", escapeHTML:true}],
            data : results
        });
    },

    setLogFailureForReturnValue : function (canvas, locatorArray, value, attribute) {
        var undef,
            clause = canvas.emptyLocatorArray(locatorArray) ? "directly with" :
                      "with the locator suffix '" + locatorArray.join("/") + "' of";
        canvas.setLogFailureText(true, "there is no " + attribute + " associated " +
                                 clause);
        return value;
    },

    getAttributeDefault : function (canvas, attribute) {
        switch (attribute) {
        case isc.Canvas._$Element: return canvas ? canvas._getHandleAndLogFailure() : null;
        case isc.Canvas._$Object:  return canvas ? canvas                           : null;

        // no return value by default
        case isc.Canvas._$Value:
        case isc.Canvas._$Selected: return;
        }
    }

});

isc.ApplyAutoTestMethods = function () {




isc.Canvas.addClassMethods({

    // attributes that can queried from Canvas.getAttributeFromSplitLocator()
    _$Element:  "element",
    _$Object:   "object",
    _$Value:    "value",
    _$Selected: "selected",

    getFallbackPropertyMatch : function (propertyName, config, candidates,
                                         substring, typeStrategy)
    {
        var role = config.scRole,
            className = config.Class,
            // scClass will not have been recorded separately if the
            // recorded class is already a core class.
            scClassName = config.scClass || config.Class,
            propertyValue = config[propertyName];

        if (propertyValue == null) return;

        var propertyMatches = candidates.findAll(propertyName, propertyValue) || [];
        propertyMatches = propertyMatches.filter(this.isValidFallbackLocatorCandidate);

        if (propertyMatches.length == 0) return;

        var propertyMatch;

        switch (typeStrategy) {

        case "Class": // scClass // role // none
            if (className) {
                var innerMatches = propertyMatches.findAll("Class", className);
                if (innerMatches != null) {
                    propertyMatch = innerMatches[0];
                    if (innerMatches.length == 1 && propertyMatch) {
                        if (this.logIsDebugEnabled("AutoTest")) {
                            this.logDebug("Locator string:" + substring +
                                          " - returning widget with matching " +
                                          propertyName + " and ClassName:" +
                                          propertyMatch, "AutoTest");
                        }
                        return propertyMatch;
                    }
                }
            }
        case "scClass":
            if (scClassName) {
                var innerMatches = propertyMatches.findAll("_scClass", scClassName);
                if (innerMatches != null) {
                    if (innerMatches.length == 1 || propertyMatch == null)
                        propertyMatch = innerMatches[0];

                    if (innerMatches.length == 1 && propertyMatch) {

                        if (this.logIsDebugEnabled("AutoTest")) {
                            this.logDebug("Locator string:" + substring +
                                          " - returning widget with matching " +
                                          propertyName + " and scClassName:" +
                                          propertyMatch, "AutoTest");
                        }
                        return propertyMatch;
                    }
                }
            }
        case "role":
            if (role) {
                var innerMatches = propertyMatches.findAll("ariaRole", role);
                if (innerMatches != null) {
                    if (innerMatches.length == 1 || propertyMatch == null)
                        propertyMatch = innerMatches[0];

                    if (innerMatches.length == 1 && propertyMatch) {

                        if (this.logIsDebugEnabled("AutoTest")) {
                            this.logDebug("Locator string:" + substring +
                                          " - returning widget with matching " +
                                          propertyName + "  and role:" +
                                          propertyMatch, "AutoTest");
                        }
                        return propertyMatch;
                    }
                }
            }

        default:
            // In this case we've got a matching property value but we can't match
            // it to class or role.  Log the "unreliable locator" one time warning
            // -- the fact that we couldn't find a match by class as well as
            // property value implies things must have changed since the recording
            // was made...
            //
            // Return the match if it's unique, otherwise ignore it and move on to
            // matching by index.

            if (propertyMatches.length == 1) {

                if (typeStrategy != "none") {
                    isc.AutoTest.logRobustLocatorWarning();

                    this.logWarn ("Locator string:" + substring + ". Returning " +
                                  "closest match:" + propertyMatches[0] + ". This has " +
                                  "the same " + propertyName + " as the recorded " +
                                  "component but does not match class or role.", "AutoTest");
                } else {
                    if (this.logIsDebugEnabled("AutoTest")) {
                        this.logDebug("Locator string:" + substring +
                                      " - returning widget with matching " + propertyName +
                                      ":" + propertyMatch, "AutoTest");
                    }
                }
                return propertyMatches[0];
            } else {
                this.logWarn("Locator string:" + substring + ", attempt to match " +
                             "by " + propertyName + " failed -- multiple candidate " +
                             "components have this same " + propertyName + ". Attempting " +
                             "to match by index instead.", "AutoTest");
            }
        } // end of switch
    },

    // substring param really just used for logging
    getCanvasFromFallbackLocator : function
    Canvas_getCanvasFromFallbackLocator (substring, config, candidates, strategy, typeStrategy)
    {
        // Given an array of possible candidates attempt to match as follows:

        // - if a 'name' was recorded,
        //  - match by name and class name
        //  - otherwise by name and scClassName
        //  - otherwise by name and scRole
        // - if a title was recorded
        //  - match by title  and class name
        //  - title / scClassName
        //  - title / role
        //
        // Otherwise back off to matching by index:
        //  - try to match by class name / index (of candidates with that className)
        //  - then by scClassName / index
        //  - then by role / index
        //  - then by raw index

        // Robustness:
        // We have a big one-time warning to log when we think what we're returning is
        // likely unreliable (see AutoTest.logRobustLocatorWarning())
        // We do this:
        //  - if we find a match by name but it doesn't match class, scclass or role
        //  - if we find a match by title but it doesn't match class scclass or role
        //      (If there is more than one match by title we ignore this strategy and back
        //       off to index with a different warning)
        //  - if, when attempting to find a match by index (by class scClass or role, or by
        //    raw index), we find the array length has changed (meaning the array has
        //    changed, so the index is probably worthless).
        //
        // We also log a less "things are broken" warning everytime we return
        // by raw index as this is very fragile.
        var name = config.name;

        // Some common things we're always going to try:
        var className = config.Class,
            // scClass will not have been recorded separately if the recorded class
            // is already a core class.
            scClassName = config.scClass || config.Class,
            role = config.scRole;

        var match;

        switch (strategy) {

        case "name":
            match = this.getFallbackPropertyMatch("name", config, candidates,
                                                  substring, typeStrategy);
            if (match) return match;

        case "title":
            match = this.getFallbackPropertyMatch("title", config, candidates,
                                                  substring, typeStrategy);
            if (match) return match;

        // either strategy is "index" or we didn't find a title/name match
        default:

            // back off to index
            // We captured index per class name, per scClass and per role as well as the
            // raw index in the array.
            // Test them in that order.
            // Note that if the lengths have changed this is likely wrong!
             var classIndexMatch,
                scClassIndexMatch,
                roleIndexMatch;

             switch (typeStrategy) {
             case "Class": // scClass // role // none


                if (className && config.classIndex) {
                    var classMatches = candidates.findAll("Class", className);
                    if (classMatches && classMatches.length > 0) {

                        classIndexMatch = classMatches[parseInt(config.classIndex)];

                        if (classMatches.length == parseInt(config.classLength)) {

                            if (this.logIsInfoEnabled("AutoTest")) {
                                this.logInfo("Locator string:" + substring +
                                        " - returning widget with matching ClassName / index by ClassName:" +
                                        classIndexMatch, "AutoTest");
                            }
                            return classIndexMatch;
                        }
                        // If the lengths didn't match, the index is very likely unreliable
                        // Hang onto it to return it if we can't match by scClassName or role more
                        // reliably
                    }
                }

            case "scClass":

                if (scClassName && config.scClassIndex) {

                    var scClassMatches = candidates.findAll("_scClass", scClassName);
                    if (scClassMatches && scClassMatches.length > 0) {

                        scClassIndexMatch = scClassMatches[parseInt(config.scClassIndex)];

                        if (scClassMatches.length == parseInt(config.scClassLength)) {

                            if (this.logIsInfoEnabled("AutoTest")) {
                                this.logInfo("Locator string:" + substring + " - returning " +
                                    "widget with matching SmartClient superclass / index by " +
                                    "ClassName:" + scClassIndexMatch, "AutoTest");
                            }
                            return scClassIndexMatch;
                        }
                        // If the lengths didn't match, the index is very likely unreliable
                        // Try roles before using this
                    }
                }

            case "role":

                if (role && config.roleIndex) {

                    var roleMatches = candidates.findAll("ariaRole", role);
                    if (roleMatches && roleMatches.length > 0) {

                        roleIndexMatch = roleMatches[parseInt(config.roleIndex)];

                        if (roleMatches.length == parseInt(config.roleLength)) {

                            if (this.logIsInfoEnabled("AutoTest")) {
                                this.logInfo("Locator string:" + substring +
                                        " - returning widget with matching role / index by role:" +
                                        roleIndexMatch, "AutoTest");
                            }
                            return roleIndexMatch;
                        }
                    }
                }

            default:

                // At this point if we had class/scClass or role, we know the lengths have changed
                // so index is very unreliable.
                // In this case, or if the overall length has changed, log the robustLocatorWarning
                //
                // Then return our best guess
                if ((typeStrategy != "none" && (className || scClassName || role)) ||
                    (config.length != null && (parseInt(config.length) != candidates.length)))
                {
                    isc.AutoTest.logRobustLocatorWarning();
                }

                var match = classIndexMatch || scClassIndexMatch || roleIndexMatch;
                if (match == null) {
                    var index = config[isc.AutoTest.fallback_valueOnlyField];
                    if (index == null) index = config.index;
                    index = parseInt(index);

                    match = candidates[index];
                }

                if (match) {
                    this.logWarn("Locator string:" + substring +
                        " matching by index gave " + match +
                        ". Reliability cannot be guaranteed for matching by index if the underlying " +
                        "application undergoes any changes.", "AutoTest");
                    return match;
                }

            } // closes inner switch statement
        } // closes outer switch statement

        // if we're here, we didn't find any candidates, or didn't find a child within them.
        // This doesn't necessarily indicate any kind of failure: We use fallback locators
        // for elements within some components - EG list grid cells
        this.logDebug("AutoTest.getElement(): locator substring:" + substring +
            " parsed to fallback locator name:" + name +
            ", unable to find relevant child - may refer to inner element.", "AutoTest");
    },

    // Reject "bad" candidates such as those that are
    // - marked as destroyed
    // - not visible
    // - not drawn
    isValidFallbackLocatorCandidate : function
    Canvas_isValidFallbackLocatorCandidate (candidate) {
       return candidate && !candidate.destroyed && candidate.isVisible() && candidate.isDrawn();
    }
});

// methods applied to Class are generally needed for both Canvas and FormItem
isc.Class.addClassMethods({

    // use fallback strategies to get at the right object from a stored path.
    getCanvasLocatorFallbackPath : function Class_getCanvasLocatorFallbackPath (name,
                                               canvas, sourceArray, properties, mask)
    {
       if (properties == null) properties = {};

        if (mask == null) mask = {};
        else if (isc.isAn.Array(mask)) {
            var maskObj = {};
            for (var i = 0; i <mask.length; i++) {
                maskObj[mask[i]] = mask[i];
            }
            mask = maskObj;
        }

        // Always pick up the following attributes directly from the widget, if present
        if (mask.title == null) mask.title = "title";
        if (mask.scRole == null) mask.scRole = "ariaRole";
        if (mask.name == null) mask.name = "name";

        // ClassName / scClassName - this is more complex than just looking at attributes on
        // the widget:
        // We need to pick up the class name, and if that's not a core smartclient class, also
        // pick up the core superclass of that class so we can look at both
        var objectClass     = canvas.getClass(),
            objectClassName = canvas.getClassName();

        properties.Class = objectClassName;

        var scClassName;
        if (!objectClass.isFrameworkClass) {
            scClassName = objectClass._scClassName;
        }
        if (scClassName != null) properties.scClass = scClassName;

        // We also want to pick up index-based locators from the source array
        // Record both the index and the current length
        // Locating by index is always imperfect: If a developer changes the orders of
        // members (for example), it'll break.
        // However if the length is different when a recorded locator is parsed, we have
        // a really good indication that the index based locator is probably unreliable.
        if (sourceArray != null && sourceArray.indexOf(canvas) >= 0) {

            // Raw position in the array
            properties.index = sourceArray.indexOf(canvas);
            properties.length = sourceArray.length;

            // position within widgets of this class in the array
            // Use case: the developer adds something like a 'status label' at the top
            // of an array of buttons
            var matchingClass = sourceArray.findAll("Class", objectClassName);
            properties.classIndex = matchingClass.indexOf(canvas);
            properties.classLength = matchingClass.length;

            // position within widgets of this SmartClient class in the array
            // Use case: The developer subclasses a SmartClient component as the app matures
            // but the application layout stays the same, so an array of buttons becomes
            // an array of custom button subclasses
            if (scClassName != null) {
                var matchingSCClass = sourceArray.findAll("_scClass", scClassName);
                properties.scClassIndex = matchingSCClass.indexOf(canvas);
                properties.scClassLength = matchingSCClass.length;
            }

            // Position within widgets with this role in the warray
            // Use case: The smart client class changes due to (say) reskinning (moving from
            // a button to a stretchImgButton), but the role is unchanged
            if (canvas.ariaRole != null) {
                var matchingRoles = sourceArray.findAll("ariaRole", canvas.ariaRole);
                properties.roleIndex = matchingRoles.indexOf(canvas);
                properties.roleLength = matchingRoles.length;
            }
        }

        return isc.AutoTest.getObjectLocatorFallbackPath(name, canvas, properties, mask);
    }

});

isc.Class.addMethods({

    // given a childType -- for example "peers"
    // figure out the specified child locator strategy.
    // Works by looking for this.locate[pluralName]By -- EG
    // locatePeersBy
    getChildLocatorStrategy : function class_getChildLocatorStrategy (childType) {
        if (isc.AutoTest.locStrategyNames == null) {
            isc.AutoTest.locStrategyNames = {};
        }

        var attrName = isc.AutoTest.locStrategyNames[childType];
        if (attrName == null) {
            var pluralName = childType;
            if (isc.isA.String(this._locatorChildren[childType])) {
                pluralName = this._locatorChildren[childType];
            }
            attrName = isc.AutoTest.locStrategyNames[childType] =
                        "locate" +
                        pluralName.substring(0,1).toUpperCase() + pluralName.substring(1) +
                        "By";
        }

        return this[attrName];
    },

    // Same type of logic for type-identifiers
    // checks for this.locate[pluralName]Type -- EG: locatePeersType
    getChildLocatorTypeStrategy : function class_getChildLocatorTypeStrategy (childType) {

        if (isc.AutoTest.locStrategyTypes == null) {
            isc.AutoTest.locStrategyTypes = {};
        }

        var attrName = isc.AutoTest.locStrategyTypes[childType];
        if (attrName == null) {
            var pluralName = childType;
            if (isc.isA.String(this._locatorChildren[childType])) {
                pluralName = this._locatorChildren[childType];
            }
            attrName = isc.AutoTest.locStrategyTypes[childType] =
                        "locate" +
                        pluralName.substring(0,1).toUpperCase() + pluralName.substring(1) +
                        "Type";
        }

        return this[attrName];
    },


    getAutoChildLocator : function class_getAutoChildLocator (instance) {

        if (this._createdAutoChildren) {
            var ID = instance.getID();
            for (var childName in this._createdAutoChildren) {
                var children = this._createdAutoChildren[childName];
                if (children.contains(ID)) {
                    // common case this.header etc
                    if (instance == this[childName]) return childName;
                    else {
                        // create an array of the *live* auto children (not just their IDs)
                        // this allows us to figure out our index in that array as well as
                        // our index based on role!
                        var liveChildren = [];
                        for (var i = 0; i < children.length; i++) {
                            liveChildren[i] = window[children[i]];
                        }
                        return this.getCanvasLocatorFallbackPath(childName, instance,
                                                                 liveChildren);
                    }
                }
            }
        }
        return null;
    },

    getCanvasFromFallbackLocator : function
    class_getCanvasFromFallbackLocator (substring, config, candidates, strategy, typeStrategy)
    {
        return isc.Canvas.getCanvasFromFallbackLocator(substring, config, candidates,
                                                       strategy, typeStrategy);
    },

    // substring param really just used for logging
    getChildFromFallbackLocator : function class_getChildFromFallbackLocator (substring,
                                                                  fallbackLocatorConfig)
    {
        var type = fallbackLocatorConfig.name,
            config = fallbackLocatorConfig.config;


        if (this == isc.AutoTest.testRoot && this.getScClassName() == "Canvas") {
             if (type == "member") type = "child";
        }

        // default logic:
        // we use the "name" to find candidate widgets, then use the config to
        // figure out which candidate we actually want
        var candidates = this.getFallbackLocatorCandidates(type);
        if (candidates && candidates.length > 0) {
            var strategy = this.getChildLocatorStrategy(type);
            if (strategy == null) strategy = "name";
            var typeStrategy = this.getChildLocatorTypeStrategy(type);
            if (typeStrategy == null) typeStrategy = "Class";

            var match = this.getCanvasFromFallbackLocator(substring, config, candidates,
                                                          strategy, typeStrategy);
            if (match != null) return match;
        }

        // if we're here, we didn't find any candidates, or didn't find a child within them.
        // This doesn't necessarily indicate any kind of failure: We use fallback locators
        // for elements within some components - EG list grid cells
        this.logDebug("AutoTest.getElement(): locator substring:" + substring +
            " parsed to fallback locator name:" + type +
            ", unable to find relevant child - may refer to inner element.", "AutoTest");
    },

    getFallbackLocatorCandidates : function class_getFallbackLocatorCandidates (name) {

        var candidates;

        // check _createdAutoChildren for autoChildren by autoChild name
        if (this._createdAutoChildren != null && this._createdAutoChildren[name] != null) {
            var IDs = this._createdAutoChildren[name];
            candidates = [];
            for (var i = 0; i < IDs.length; i++) {
                candidates[i] = window[IDs[i]];
            }

        // _locatorChildren object: This specifies a mapping between known cases where
        // we have an attribute on this widget containing an array of candidates
        // (EG the children array) and a known 'locator' childType name (EG "child")

        } else if (isc.isA.String(this._locatorChildren[name])) {
            candidates = this[this._locatorChildren[name]];

        // Also support the 'name' pointing directly to an attribute on this widget
        // containing an array of candidate objects (So could store "children" directly
        // rather than using the remapping above).
        } else if (this[name] && isc.isAn.Array(this[name])) {
            candidates = this[name];
        }
        return candidates;
    },

    // getCanvasLocatorFallbackPath
    // generates a standard 'fallback path' to locate a widget from within a pool of widgets.
    // Used for locating mutliple auto children with the same name, members, peers, children
    // and so on.
    // The concept is that this'll capture as much information as possible so we can
    // use fallback strategies to get at the right object from a stored path.
    getCanvasLocatorFallbackPath : function class_getCanvasLocatorFallbackpath
                         (name, canvas, sourceArray, properties, mask) {
        return isc.Canvas.getCanvasLocatorFallbackPath(name, canvas, sourceArray,
                                                       properties, mask);
    },

    setLogFailureText : function class_setLogFailureText (locator, start, finish) {

        var callerFunc = isc.Class.getPrototype().setLogFailureText.caller || arguments.callee.caller,
            callerName = callerFunc.name || isc.Func.getName(callerFunc, true),
            logSlot = callerName.replace(/^.*[_]+([^_]+)/, "\137$1" ) + "Log";
        if (isc.AutoTest[logSlot]) return; // initial reporter has primacy
        isc.AutoTest[logSlot] = this._getLogFailureText(locator, start, finish);
    },

    _getDescription : function class__getDescription (locator) {
        var original = false,
            stable = this.hasStableID(),
            description = this.getScClassName();

        // locator true means to add on the original locator
        if (locator == true) {
            locator = false;
            original = true;
        }
        // if the ID is not stable, define the current locator
        if (stable) description += " with ID " + this.ID;
        else if (!isc.isA.String(locator)) locator = this.getLocator();

        // now if either just defined or passed it, set current locator
        if (locator) description += " identified by " + locator;

        // the original locator is now added at the end if required
        if (original) description += isc.AutoTest._createLocatorMarker(locator);

        return description;
    },

    _getLogFailureText : function class__getLogFailureText (locator, start, finish) {
        var description = "the " + this._getDescription(locator);

        if (finish && !finish.match(/^[.,;:\\s]/)) finish = " " + finish;

        if (start)  description  = start + " " + description;
        if (finish) description += finish;

        return description;
    },

    // Should this widget's ID be used during scLocator generation?

    hasStableID : function class_hasStableID () {
        if (this._autoAssignedID) return false;


        var idPrefixParent = this.creator || this.locatorParent;
        if (idPrefixParent != null) return idPrefixParent.hasStableID();

        return true;
    },
    hasStableLocalID : function class_hasStableLocalID () {
        if (this._localId) return true;
        return this.hasStableID();
    }

});

isc.Canvas.addMethods({

    //> @method canvas.getLocator()
    // Get an abstract Locator String for an element contained within this Canvas
    // @param (DOMElement) DOM element contained within this Canvas
    // @return (Locator) abstract Locator String
    // @visibility autoTest
    //<
    // No apparent need to expose this directly, unless we are ready to support developers
    // writing their own locator logic in addition to the defaults
    ///
    // Additional 'fromEvent' param tells us we're actually retriving the target for the
    // current mouse event
    // In some cases we can use this to get additional info that isn't available from the
    // actual target element (EG target cell in a GR when showing a floating embedded componet)
    getLocator : function canvas_getLocator (element, fromEvent, coords) {
        var baseLocator = this.getLocatorInternal();
        if (!element) return  baseLocator;
        return [baseLocator, this.getInteriorLocator(element, fromEvent, coords)].join("/");
    },

    // internal logic to return normal or testRoot-based locator
    getLocatorInternal : function canvas_getLocatorInternal (ignoreTestRoot,
                                                             skipAbsoluteLocator)
    {
        var parent, absoluteLocator;


        var testRoot = ignoreTestRoot ? null : isc.AutoTest.testRoot;
        if (testRoot != this) {


            if (this._generated || this.locatorParent || this.creator || !this.hasStableID()) {
                parent = this.getLocatorParent();
            }


            if (testRoot != null && parent == null) {
                if (!skipAbsoluteLocator) {
                    skipAbsoluteLocator = true;
                    absoluteLocator = this.getLocatorInternal(true);
                }
                parent = this.getLocatorParent();
            }
        }

        var baseLocator;
        if (parent == null) {
            baseLocator = this.getLocatorRoot();
        } else {
            baseLocator = parent.getLocatorInternal(false, skipAbsoluteLocator);
            var childLocator = parent.getChildLocator(this);
            if (childLocator != null) baseLocator += "/" + childLocator;
        }

        return absoluteLocator != null && !baseLocator.startsWith(isc.AutoTest._$testRoot) ?
            absoluteLocator : baseLocator;
    },

    // We support generating locators for logical SmartClient objects that aren't necessarily
    // canvii such as FormItems and SectionStackSections

    // This method is called to get the locator for some logical object nested within this canvas.
    // Return null to indicate no locator (or object not understood, etc).
    // Subclasses such as DynamicForm will override with concrete implementations.
    getObjectLocator : function canvas_getObjectLocator (target) {
     },

    _locatorRootTemplate: [
    "//",
    ,   // classname
    '[ID="',
    ,   // global ID
    '"]'
    ],
    getLocatorRoot : function canvas_getLocatorRoot () {

        if (!this.locatorRoot) {
            // If this widget is the test root, return a special locator based on that.
            // If the widget has an explicitly specified ID always use it above all else!
            // Otherwise we'll use the "fallbackLocator" pattern to find it
            if (this == isc.AutoTest.testRoot) {
                this.locatorRoot = isc.AutoTest._$testRoot;
            } else if (!this.hasStableID() && this.parentElement == null) {
                this.locatorRoot = "//" +
                    isc.Canvas.getCanvasLocatorFallbackPath("autoID", this, isc.Canvas._topCanvii);
            } else {
                this._locatorRootTemplate[1] = this.getClassName();
                this._locatorRootTemplate[3] = this.getID();
                this.locatorRoot = this._locatorRootTemplate.join(isc.emptyString);
            }
        }
        return this.locatorRoot;
    },

    containsLocatorChild : function canvas_containsLocatorChild (canvas) {
        if (this.namedLocatorChildren != null) {
            for (var i = 0; i < this.namedLocatorChildren.length; i++) {
                var name = this.namedLocatorChildren[i];
                if (isc.isAn.Object(name)) name = name.attribute;
                if (canvas == this[name]) {
                    return true;
                }
            }
        }
        return false;
    },

    getLocatorParent : function canvas_getLocatorParent () {
        // locatorParent -- this is a generic entry point allowing special locator parent/child
        // behavior.
        // To make use of this a widget could set itself as the locatorParent of some other
        // widget, and implement custom 'containsLocatorChild()' / 'getChildLocator()'
        if (this.locatorParent && this.locatorParent.containsLocatorChild &&
            this.locatorParent.containsLocatorChild(this))
        {
            return this.locatorParent;
        }
        // Canvas and FormItem both support 'getAutoChildLocator'
        if (this.creator && (isc.isA.Canvas(this.creator) || isc.isA.FormItem(this.creator))) {
            var autoChildName = this.creator.getAutoChildLocator(this);
            if (autoChildName == null) {
                // failed to find the child - most likely created via 'createAutoChild' but
                // never ran through addAutoChild() which would make it detectable in the
                // getAutoChildLocator() method
                // This is likely to happen if we are using the auto-child system to create
                // numerous auto-children with common properties, so it's not really a
                // failure.
                // Allow this to continue through the standard master-peer / parent-child
                // logic.
                this.logInfo("Locator code failed to find relationship between parent:"+
                            this.creator.getID() + " and autoChild:"+ this.getID(), "AutoTest");
            } else {
                return this.creator;
            }
        }
        return this.masterElement || this.parentElement;
    },


    //> @method canvas.getChildLocator()
    // Get the abstract Locator string for finding a child canvas within its parent element
    // @param (Canvas)
    // @return (Locator) abstract Locator String for finding this child
    //<
    // Leave this internal - developers would call getLocator() directly
    _childLocatorTemplate:[
        ,   // "child" or "peer"
        "[",
        ,   // index of child/peer
        '][Class="',
        ,   // className of child/peer
        '"]'
    ],


    getChildLocator : function canvas_getChildLocator (canvas) {
        // special case scrollbars
        if (canvas == this.hscrollbar) {
            return "hscrollbar";
        }
        if (canvas == this.vscrollbar) {
            return "vscrollbar";
        }

        // More general behavior split into 2 parts for easy overriding - autoChildren are pretty
        // much always respected over other locators such as children / members array
        if (canvas.creator == this) {
            var autoChildID = this.getAutoChildLocator(canvas);
            if (autoChildID) return autoChildID;
        }

        return this.getStandardChildLocator(canvas);
    },

    // Called when AutoTest.getLocator() is called with the checkNativeElement parameter.
    // This method tests for the case where we have an element that natively
    // "has meaning" in terms of events (IE eventHandledNatively is true) and our generated
    // SC-locator won't get back to that element.
    // Example case: A link written into a canvas handle -- the locator will likely point to
    // the canvas, while the link itself is the element that should be recorded.
    // In this case testing tools such as selenium may be able to get a better identifier
    // based on (EG) ID of the link element.
    //
    // We do have cases where a widget writes out a live element which will handle native events
    // but we already handle generating a full locator to get at them (rather than just the
    // canvas handle). Example case: link elements within the month view of a calendar widget.
    //
    // We test for this case by doing a round-trip test - if the locator already directly
    // points to the element (via AutoTest.getElement()), we use the locator.
    //

    // Implemented at the Canvas level so we can override this in subclasses if appropriate.
    checkLocatorForNativeElement : function canvas_checkLocatorForNativeElement (locator, element) {
        if (element == null || locator == null) return false;

        return (isc.EventHandler.eventHandledNatively("mousedown", element, true) &&
                (isc.AutoTest.getElement(locator) != element));
    },

    getNamedLocatorChildString : function canvas_getNamedLocatorChildString (canvas) {

        // Fairly common pattern - this.<someAttribute> is set directly to the canvas
        // but for whatever reason it didn't go through the addAutoChild() subsystem.
        // We can handle this explicitly by:
        // - setting locatorParent on the child to point to this widget
        // - adding an entry to the "namedLocatorChildren" array with the attribute name
        if (canvas.locatorParent == this && this.namedLocatorChildren) {
            for (var i = 0; i < this.namedLocatorChildren.length; i++) {
                var name = this.namedLocatorChildren[i],
                    attrName = name;

                // support an object of the format {name:"name", attribute:"attributeName"}
                // This allows us to defeat changing obfuscated names like "_editRowForm"
                if (isc.isA.Object(name)) {
                    attrName = name.attribute,
                    name = name.name;
                }
                if (canvas == this[attrName]) {
                    return name;
                }
            }
        }
    },

    getStandardChildLocator : function canvas_getStandardChildLocator (canvas) {
        var nlcs = this.getNamedLocatorChildString(canvas);
        if (nlcs) return nlcs;


        if (canvas.getMasterCanvas() == this) {
            return this.getCanvasLocatorFallbackPath("peer", canvas, this.peers);

        } else if (canvas.getParentCanvas() == this) {
            return this.getCanvasLocatorFallbackPath("child", canvas, this.children);
        } else {
            // Not clear what would cause this - we already catch the autoChild case,
            // so this is really a sanity check only
            this.logWarn("unexpected error - failed to find relationship between parent:"+
                        this.getID() + " and child:"+ canvas.getID());
            // return the standard root ID for the canvas - when parsing the strings back
            // we will have to explicitly catch this case?
            return canvas.getLocatorRoot();
        }
    },

    //> @method canvas.getInteriorLocator()
    // Get a relative Locator for an element contained within this Canvas
    // @param (DOMElement) DOM element contained within this Canvas
    // @return (Locator) abstract Locator String
    //<
    // Overridden to provide standard "meaningful locations" for ListGrids, DynamicForm, etc
    getInteriorLocator : function canvas_getInteriorLocator (element, fromEvent, coords) {
        if (element && this.useEventParts) {
            var partObj = this.getElementPart(element);
            if (partObj != null && partObj.part != null) {
                // This will be of the format "partType_partID"
                return (partObj.partID && partObj.partID != isc.emptyString) ?
                                        partObj.part + "_" +  partObj.partID : partObj.part;
            }
        }
        if (coords && this.canDragResize) {
            var edgeLocator = this.getEventEdge(null, coords);
            if (edgeLocator) return edgeLocator;
        }
        return isc.emptyString;
    },

    // -------------------------
    // Retrieving dom elements from locator strings
    //> @method canvas.getAttributeFromSplitLocator()
    // Given a locator string split into an array, return specified attribute.
    // @param (Locator Array) array of strings
    // @param (object) configuration for request
    // @return (Object) requested attribute
    // @visibility internal
    //<
    // Internal - the parameter format does not match the Locator format returned by
    // canvas.getLocator -- developers should call AutoTest.getElement() rather than directly
    // accessing this method
    getAttributeFromSplitLocator : function canvas_getAttributeFromSplitLocator (locatorArray,
                                                                                 configuration)
    {
        var attribute = configuration.attribute,
            child = this.getChildFromLocatorSubstring(locatorArray[0], 0, locatorArray,
                                                      configuration);

        // return value if requested and it was set when the child was located
        if (configuration.value != null) return configuration.value;

        if (child) {
            locatorArray.removeAt(0);
            var result = child.getAttributeFromSplitLocator(locatorArray, configuration);
            if (result != null || result === null &&
                (isc.Canvas._$Value == attribute || isc.Canvas._$Selected == attribute))
            {
                return result;
            }
            if (configuration.locatorMatching != "permissive") {
                child.setLogFailureText(true, "the trailing locator suffix '" +
                    locatorArray.join("/") + "' does not identify any valid attribute of",
                                        "and permissive mode is not active");
                return result;
            }
        }

        // stop searching for an object and return this Canvas unless it's a DynamicForm
        if (attribute == isc.Canvas._$Object && !isc.isA.DynamicForm(this)) return this;

        // split finding attribute within our handle to a separate method for simpler override
        return this.getInnerAttributeFromSplitLocator(locatorArray, configuration);
    },

    // Given a substring extracted from a split locator array, return the child widget
    // that matches the specified substring.
    // If there is no matching child, return null - we'll then treat this widget as the
    // innermost child widget treat any remaining locator info as an interior locator

    getChildFromLocatorSubstring : function canvas_getChildFromLocatorSubstring (substring,
                                                                                 index,
                                                                                 locatorArray)
    {
        if (substring == null || substring == "") return null;

        // Standard formats:
        //
        // Attribute pointing directly to widget:
        // EG:
        // - vscrollbar/hscrollbar
        // - named autoChild
        // - things in the "namedLocatorChildren" array

        if (isc.isA.Canvas(this[substring])) {
            return this[substring];
        }

        // - standard attribute<-->name mappings in the namedLocatorChildren array:
        if (this.namedLocatorChildren != null) {
            var rename = this.namedLocatorChildren.find("name", substring);
            if (rename != null) {
                var canvas = this[rename.attribute];
                if (isc.isA.Canvas(canvas)) return canvas;
                this.logWarn("Locator substring:" + substring
                    + " remaps to attribute:" + rename.attribute +
                    " but no canvas exists under that attribute name.", "AutoTest");
                // this is probably a failure - could return null here or keep going
                // - keep going in case some other strategy finds the component?
            }
        }

        // Fallback locators ([childType][fallback locator for specific child])
        // EG:
        // - autoChildName[<fallback locator within auto children>]
        // - children[<fallback locator>]
        // - members[<fallback locator>]
        var fallbackLocatorConfig =  isc.AutoTest.parseLocatorFallbackPath(substring);
        if (fallbackLocatorConfig != null) {
            var child = this.getChildFromFallbackLocator(substring, fallbackLocatorConfig);
            if (child == null) {
                this.setLogFailureText(true, null, "has no child identifiable " +
                                       "by the fallback locator '" + substring + "'");
            }
            return child;
        }

        // if we're here, we didn't find any candidates, or didn't find a child within them.
        // No need to warn here -- this is likely to happen if the remaining identifier is
        // an inner element locator
        return null;

    },

    //> @type LocatorStrategy
    // The AutoTest subsystem relies on generating and parsing identifier strings to identify
    // components on the page. A very common pattern is identifying a specific component
    // within a list of possible candidates. There are many many cases where this pattern
    // is used, for example - members in a layout,tabs in a tabset, sections in a section stack.
    // <P>
    // In order to make these identifiers as robust as possible across minor
    // changes to an application, (such as skin changes, minor layout changes, etc) the
    // system will store multiple pieces of information about a component when generating
    // an identification string to retrieve it from a list of candidates.
    // The system has a default strategy for choosing the order in which to look at these
    // pieces of information but in some cases this can be overridden by setting
    // a <code>LocatorStrategy</code>.
    // <p>
    // By default we use the following strategies in order to identify a component from a list of
    // candidates:
    // <UL><li><code>name</code>: Does not apply in all cases but in cases where a specified
    //   <code>name</code> attribute has meaning we will use it - for example for
    //  +link{SectionStackSection.name,sections in a section stack}.</li>
    // <li><code>title</code>: If a title is specified for the component this may be used
    //   as a legitimate identifier if it is unique within the component - for example
    //   differently titled tabs within a tabset.</li>
    // <li><code>index</code>: Locating by index is typically less robust than by name or
    //   title as it is likely to be effected by layout changes on the page.</li>
    // </UL>
    // If an explicit strategy is specified, that will be used to locate the component if
    // possible. If no matching component is found using that strategy, we will continue to
    // try the remaining strategies in order as described above. In other words setting
    // a locatorStrategy to "title" will skip attempting to find a component by name, and
    // instead attempt to find by title - or failing that by index.
    // <P>
    // Note that we also support matching by type (see +link{type:LocatorTypeStrategy}).
    // Matching by type is used if we were unable to match by name or title or to disambiguate
    // between multiple components with a matching title.
    //
    // @value "name" Match by name if possible.
    // @value "title" Match by title if possible.
    // @value "index" Match by index
    // @visibility external
    // @group autoTest
    //<

    //> @type LocatorTypeStrategy
    // When attempting to identify a component from within a list of possible candidates
    // as described +link{type:LocatorStrategy,here}, if we are unable to find a unique match
    // by name or title, we will use the recorded "type" of the component to verify
    // an apparent match.
    // <P>
    // By default we check the following properties in order:
    // <ul><li>Does the Class match?</li>
    //     <li>If this is not a +link{Class.isFrameworkClass,framework class}, does the
    //         core framework superclass match?</li>
    //     <li>Does the <code>role</code> match?</li>
    // </ul>
    // In some cases an explicit locatorTypeStrategy can be specified to modify this
    // behavior. As with +link{type:LocatorStrategy}, if we are unable to match using the
    // specified type strategy we continue to test against the remaining strategies in order -
    // so if a type strategy of "scClass" was specified but we were unable to find a match
    // with the appropriate core superclass, we will attempt to match by role.
    // Possible values are:
    // @value "Class" Match by class if possible
    // @value "scClass" Ignore specific class and match by the SmartClient framework superclass.
    // @value "role" Ignore class altogether and attempt to match by role
    // @value "none" Don't attempt to compare type in any way
    // @visibility external
    // @group autoTest
    //<

    //> @attr Canvas.locateChildrenBy (LocatorStrategy : null : IRWA)
    // Strategy to use when locating children in this canvas from an autoTest locator string.
    //
    // @visibility external
    // @group autoTest
    //<

    //> @attr Canvas.locateChildrenType (LocatorTypeStrategy : null : IRWA)
    // +link{type:LocatorTypeStrategy} to use when finding children within this canvas.
    // @visibility external
    // @group autoTest
    //<

    //> @attr Canvas.locatePeersBy (LocatorStrategy : null : IRWA)
    // Strategy to use when locating peers of this canvas from an autoTest locator string.
    //
    // @visibility external
    // @group autoTest
    //<

    //> @attr Canvas.locatePeersType (LocatorTypeStrategy : null : IRWA)
    // +link{type:LocatorTypeStrategy} to use when finding peers of this canvas.
    // @visibility external
    // @group autoTest
    //<

    _locatorChildren:{
        peer:"peers",
        child:"children"
    },

    emptyLocatorArray : function canvas_emptyLocatorArray (locatorArray) {
        return locatorArray == null || locatorArray.length == 0 ||
                (locatorArray.length == 1 && locatorArray[0] == "");
    },

    _getEventPartElement : function (locatorArray) {
        var parts = locatorArray[0].split("_"),
            part = {
            part:   parts[0],
            partID: parts[1]
        };
        var element = this.getPartElement(part);
        if (element) return element;

        // return correct edge rather than center if locator has edge part
        if (this._isValidEdge(part.part)) return this._getHandleAndLogFailure();
    },

    getInnerAttributeFromSplitLocator : function canvas_getInnerAttributeFromSplitLocator (
        locatorArray, configuration)
    {
        if (configuration.attribute == isc.Canvas._$Value ||
            configuration.attribute == isc.Canvas._$Selected)
        {


            if (isc.Label && isc.isA.Label(this) ||
                (isc.HTMLFlow    && isc.isA.HTMLFlow(this)) &&
                (isc.EventWindow && isc.isA.EventWindow(this.parentElement)))
            {
                var contents = this.getContents();
                if (contents) return contents;
            }
            this.setLogFailureText(true, "the trailing locator suffix '" +
                                   locatorArray.join("/") + "' does not identify any " +
                                   "meaningful part of");
            return;
        }

        if (!this.emptyLocatorArray(locatorArray)) {
            // support event-parts in all canvii
            if (locatorArray.length == 1) {
                var undef, element = this._getEventPartElement(locatorArray);
                if (undef !== element) return element;
            }


            if (configuration.locatorMatching != "permissive") {
                this.setLogFailureText(true, "the trailing locator suffix '" +
                                       locatorArray.join("/") + "' does not identify any AutoChild " +
                                       "or Event Part of", "and permissive mode is not active");
                return null;
            }
        }

        return isc.AutoTest.getAttributeDefault(this, configuration.attribute);
    },

    // Retrieving coordinates based on element / locator string
    getAutoTestLocatorCoords : function canvas_getAutoTestLocatorCoords (locator, element) {

        // we assume both are present for now
        if (locator == null || element == null) return null;

        // If we're writing out double-divs, and the element passed in is our
        // content-handle, look at the position of the clip-handle rather than the
        // content handle.
        // This is required to avoid potentially returning a coordinate outside the
        // visible widget space if we're overflow:"hidden" and the content handle is clipped
        if (this.getHandle() == element) element = this.getClipHandle();

        var rect = isc.Element.getElementRect(element);
        // return the center of the element

        var left   = rect[0],
            width  = rect[2];
        var top    = rect[1],
            height = rect[3];

        // return correct edge rather than center if locator has edge part
        var partLocator = locator.split("/").last(),
            isValidEdge = this._isValidEdge(partLocator);

        if      ( isValidEdge &&  partLocator.contains("B")) top += height;
        else if (!isValidEdge || !partLocator.contains("T")) top += Math.floor(height/2);

        if      ( isValidEdge &&  partLocator.contains("R")) left += width;
        else if (!isValidEdge || !partLocator.contains("L")) left += Math.floor(width/2);

        return [left,top];
    },

    _getHandleAndLogFailure : function canvas__getHandleAndLogFailure() {
        var handle = this.getHandle();
        if (handle != null) return handle;

        var start = "null", finish;
        if (!this.isDrawn()) finish = "which is not drawn";
        else if (!this.handleDrawn()) start = "not drawn";

        start = "the DOM element handle is " + start + " for";
        this.setLogFailureText(true, start, finish);

        return null;
    },

    _isSelected : function (rowNum, colNum, record) {
        var totalRows = this.getTotalRows(),
            totalCols = this.fields.length;
        if (rowNum < 0 || rowNum >= totalRows ||
            colNum < 0 || colNum >= totalCols) return;

        var selection = this.selection;
        if (!selection) return;

        if (selection.cellIsSelected) {
            return selection.cellIsSelected(rowNum, colNum);
        } else if (record) {
            return selection.isSelected(record);
        }
    },

    _isValidEdge : function canvas__isValidEdge (edgePart) {
        var map = this.edgeCursorMap;
        return edgePart && map != null && map[edgePart] != null;
    },

    _isProcessingDone : function canvas__isProcessingDone (strictMode) {
        if (strictMode && !this.isDrawn()) return true;
        return isc.AutoTest.isCanvasDone(this) != false;
    }

});

// -----------------------------------------------------------------
// Override getPartElement() for special cases
if (isc.Scrollbar) {
    isc.Scrollbar.addMethods({
        getPartElement : function scrollbar_getPartElement(partObj) {
            if (partObj.part == "start") {
                return this.getImage(this.startImg.name);
            } else if (partObj.part == "end") {
                return this.getImage(this.endImg.name);
            }
            return this.Super("getPartElement", arguments);
        }
    });
}

// -----------------------------------------------------------------
// Override getChildLocator() for special cases

if (isc.Layout) {
    isc.Layout.addProperties({

        //> @attr Layout.locateMembersBy (LocatorStrategy : null : IRWA)
        // Part of the +link{group:automatedTesting} system, strategy to use when generated
        // locators for members from within this Layout's members array.
        //
        // @visibility external
        // @group autoTest
        //<

        //> @attr Layout.locateMembersType (LocatorTypeStrategy : null : IRWA)
        // +link{type:LocatorTypeStrategy} to use when finding members within this layout.
        // @visibility external
        // @group autoTest
        //<


        getStandardChildLocator : function canvas_getStandardChildLocator (canvas) {
            var nlcs = this.getNamedLocatorChildString(canvas);
            if (nlcs) return nlcs;

            if (this.members.contains(canvas)) {
                return this.getCanvasLocatorFallbackPath("member", canvas, this.members);
            }

            return this.Super("getStandardChildLocator", arguments);
        },


        _locatorChildren:{
            member:"members",
            peer:"peers",
            child:"children"
        }
    });
}

if (isc.Window) {
    isc.Window.addProperties({
        // Code in Window.js sets up Windows as the 'locatorParent' of their items
        containsLocatorChild : function window_containsLocatorChild (canvas) {
            if (this.items && this.items.contains(canvas)) return true;
            return this.Super("containsLocatorChild", arguments);
        },
        getStandardChildLocator : function window_getStandardChildLocator (canvas) {

            if (this.items && this.items.contains(canvas)) {
                var template = this._childLocatorTemplate;
                template[0] = "item";
                template[2] = this.items.indexOf(canvas);
                template[4] = canvas.getClassName();

                return template.join(isc.emptyString);
            }

            return this.invokeSuper(isc.Window, "getStandardChildLocator", canvas);
        },

        _locatorChildren:{
            item:"items",
            member:"members",
            peer:"peers",
            child:"children"
        }
    });
}

if (isc.Dialog) {
    isc.Dialog.addProperties({
        _getDescription : function dialog__getDescription (locator) {
            var title   = this.title   || "",
                message = this.message || "",
                description = this.Super("_getDescription", arguments);
            if (title   != "") description = "'" + title + "' " + description;
            if (this.isModal)  description = "modal " + description;
            if (message != "") description += " with message \"" + message + "\"";
            return description;
        }
    });
}

if (isc.SectionStack) {

    // add the _locatorChildren for SectionHeader / ImgSectionHeader - this will
    // allow them to parse the item[fallbacklocator] generated by the
    // sectionStack standard child locator override below
    isc.ImgSectionHeader.changeDefaults("_locatorChildren", {item:"items"});
    isc.SectionHeader.changeDefaults("_locatorChildren", {item:"items"});


    // add sections to locatorChildren for SectionStack - allows it to parse the
    // section[fallbackLocator] we create below
    isc.SectionStack.changeDefaults("_locatorChildren", {section:"sections"});

    isc.SectionStack.addProperties({

        // Override getObjectLocator to handle being passed a SectionStackSection
        getObjectLocator : function sectionStack_getObjectLocator (object) {
            if (object.getSectionHeader) object = object.getSectionHeader();

            // getStandardChildLocator should already handle returning section[name="foo"]
            if (object.isSectionHeader) {
                var sectionLocator = this.getStandardChildLocator(object);
                // hang an 'objectType' flag on the object locator so we can easily figure out
                // what this thing actually is
                sectionLocator += "/objectType=Section";
                return sectionLocator;
            }
            return this.Super("getObjectLocator", arguments);
        },


        // override getStandardChildLocator - for sections return
        //  section[name="name"||title="title"||3]
        // for items, append
        //  item[0]
        getStandardChildLocator : function sectionStack_getStandardChildLocator (canvas) {
            var sections = this.sections || [],
                locatorString;
            for (var i = 0; i < sections.length; i++) {

                var items = sections[i].items,
                    section, item;
                if (canvas == sections[i]) {
                    section = canvas;

                } else if (items && items.contains(canvas)) {

                    section = sections[i];
                    item = canvas;
                }

                if (section != null) {

                    // This will pick up name by default, then title, index, etc
                    locatorString = this.getCanvasLocatorFallbackPath("section", section,
                                                                      this.sections);
                }

                if (item != null) {
                    locatorString += "/" + this.getCanvasLocatorFallbackPath("item", item,
                                                                             section.items);
                }
                if (locatorString != null) return locatorString;
            }

            return this.Super("getStandardChildLocator", arguments);
        }

        //> @attr SectionStack.locateSectionsBy (LocatorStrategy : null : IRWA)
        // When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
        // +link{isc.AutoTest.getLocator()}, how should sections within this stack be
        // identified?  By default if a section has a specified
        // +link{SectionStackSection.name,Section.name} this will always be used.  For
        // sections with no name, the following options are available:
        // <ul>
        // <li><code>"title"</code> use the title as an identifier</li>
        // <li><code>"index"</code> use the index of the section in the sections array as an identifier</li>
        // </ul>
        //
        // If unset, and the section has no specified name, default behavior is to
        // identify by title (if available), otherwise by index.
        // @visibility external
        // @group autoTest
        //<

        //> @attr SectionStack.locateSectionsType (LocatorTypeStrategy : null : IRWA)
        // +link{type:LocatorTypeStrategy} to use when finding Sections within this section Stack.
        // @visibility external
        // @group autoTest
        //<


        // This will be picked up automatically based on the _locatorChildren object and
        // the standard "getLocatorStrategy()" logic


    });

    isc.SectionHeader.addProperties({
        // ensure backcompat with SC 8.2, which contains /background/ in SectionHeader locators
        getAttributeFromSplitLocator : function sectionHeader_getAttributeFromSplitLocator
        (locatorArray, configuration)
        {
            if (!this.emptyLocatorArray(locatorArray) && locatorArray[0] == "background") {
                locatorArray.removeAt(0);
            }
            return this.Super("getAttributeFromSplitLocator", arguments);
        }
    });

}

// --------------------------------------------------
// Interior locators

if (isc.StretchImg) {
isc.StretchImg.addProperties({
    getInteriorLocator : function stretchImg_getInteriorLocator (element, fromEvent) {
        // We don't use the useEventParts flag in StretchImgs but in some cases we need to tell the
        // difference between events on different items
        // (EG a track-click and a button click)
        var origElement = element,
            handle = this.getHandle(), canvasName = this.getCanvasName();

        while (element && element != handle && element.getAttribute) {
            // check the "name" property for the open-icon
            var ID = element.getAttribute("name");
            if (ID && ID.startsWith(canvasName)) {
                return ID.substring(canvasName.length);
            }
            element = element.parentNode;
        }
        return this.Super("getInteriorLocator", [origElement,fromEvent]);
    },

    getInnerAttributeFromSplitLocator : function stretchImg_getInnerAttributeFromSplitLocator (
        locatorArray, configuration)
    {
        if (configuration.attribute == isc.Canvas._$Element) {
            // check for "name" - used for parts
            if (!this.emptyLocatorArray(locatorArray) && locatorArray.length == 1) {
                var image = this.getImage(locatorArray[0]);
                if (image) return image;
            }
        }
        return this.Super("getInnerAttributeFromSplitLocator", arguments);
    }

});
}

if (isc.Slider) {
    isc.Slider.addMethods({

        getInteriorLocator : function slider_getInteriorLocator (element, fromEvent, coords) {
            var locator = this.Super("getInteriorLocator", element, fromEvent);
            if (locator == isc.emptyString && coords != null) {
                var value = this._getValueFromCoords(false, coords);
                if (value) locator = "targetValue[" + value + "]";
            }
            return locator;
        },

        getInnerAttributeFromSplitLocator : function slider_getInnerAttributeFromSplitLocator (
            locatorArray, configuration)
        {
            switch (configuration.attribute) {
            case isc.Canvas._$Element:
                if (locatorArray.length == 1 ||
                    locatorArray.length == 2 && locatorArray[0].startsWith("track[")) {
                    if (locatorArray[locatorArray.length - 1].startsWith("targetValue[")) {
                        return this._getHandleAndLogFailure();
                    }
                }
                break;
            case isc.Canvas._$Value:
                return this.getValue();
            }
            return this.Super("getInnerAttributeFromSplitLocator", arguments);
        },

        getAutoTestLocatorCoords : function slider_getAutoTestLocatorCoords (locator, element) {
            if (locator == null || element == null) return null;

            var valueLocator = locator.split("/").last();
            if (valueLocator.startsWith("targetValue[")) {

                var targetValue = parseFloat(valueLocator.replace(/.*\[([\d-+.eE]+)\]$/, "$1"));
                if (isc.isA.Number(targetValue)) {
                    var thumbPosition = this._getThumbPositionFromValue(targetValue);
                    if (this.getHandle() == element) element = this.getClipHandle();
                    var rect = isc.Element.getElementRect(element);

                    var left   = rect[0],
                        width  = rect[2];
                    var top    = rect[1],
                        height = rect[3];

                    if (this.vertical) {
                        return [left + Math.floor(width/2),
                                top  + Math.min(thumbPosition, height)];
                    } else {
                        return [left + Math.min(thumbPosition, width),
                                top  + Math.floor(height/2)];
                    }
                }
            }
            return this.Super("getAutoTestLocatorCoords", arguments);
        },

        getChildFromLocatorSubstring : function (substring, index, locatorArray, configuration) {
            if (substring == null) return null;
            var attribute = configuration.attribute;

            if ((substring.startsWith("thumb[") && attribute == isc.Canvas._$Value) ||
                substring.startsWith("track["))
            {
                // If a targetValue[ was recorded (recent locator format),
                // redirect track element to slider, and value requests for
                // track or thumb to slider
                // If no targetValue[... was recorded, delegate to the track etc
                // autoChild as we always have.
                if (locatorArray.length > index+1 &&
                   locatorArray[index+1].startsWith("targetValue["))
                {
                    return null;
                }
            }
            return this.Super("getChildFromLocatorSubstring", arguments);
        }

    });

    // Note this is for back-compat only: Recently recorded locators will include a
    // targetValue attribute in addition to the "track" child locator and when interpreting
    // them we have the Slider (rather than the track autoChild) resolve to an element
    isc.Slider.changeDefaults("trackDefaults", {
        getInnerAttributeFromSplitLocator : function sliderTrack_getInnerAttributeFromSplitLocator (
            locatorArray, configuration)
        {
            // Slider: In 8.3 the track was a StretchImg by default. In 9.0 its a
            // StatefulCanvas [though may still be a StretchImg depending on the skin].
            // If we have a recorded locator which includes a StretchImg part-name from the track but
            // the Slider track isn't a StretchImg, trim this off so we return the track's handle
            if (!isc.isA.StretchImg(this) && locatorArray.length > 0 &&
                    (locatorArray[0] == "stretch" || locatorArray[0] == "start" ||
                        locatorArray[0] == "end"))
            {
                locatorArray = [];
            }
            return this.Super("getInnerAttributeFromSplitLocator",
                             [locatorArray, configuration], arguments);
        }
    });

}


// label.icon already handled via standard canvas 'eventPart' handling

if (isc.DynamicForm) {
    isc.DynamicForm.addProperties({

        getInteriorLocator : function dynamicForm_getInteriorLocator (element) {
            var itemInfo = isc.DynamicForm._getItemInfoFromElement(element, this);
            // itemInfo format:
            // {item:item, overElement:boolean, overTitle:boolean, overTextBox:boolean,
            //  overControlTable:boolean, overIcon:string}
            if (!itemInfo.item) return this.Super("getInteriorLocator", arguments);
            var item = itemInfo.item,
                locator = [this.getItemLocator(item), '/'];
            if      (itemInfo.overElement)      locator[locator.length] = "element";
            else if (itemInfo.overValueIcon) locator[locator.length] = "valueicon";
            else if (itemInfo.overTitle)        locator[locator.length] = "title";
            else if (itemInfo.overTextBox)      locator[locator.length] = "textbox";
            else if (itemInfo.overControlTable) locator[locator.length] = "controltable";
            else if (itemInfo.overInlineError)  locator[locator.length] = "inlineerror";
            else if (itemInfo.overIcon)         locator[locator.length] = "[icon=\"" +
                     itemInfo.overIcon + "\"]";

            return locator.join(isc.emptyString);
        },

        getItemLocator : function dynamicForm_getItemLocator (item) {

            // containerItems contain sub items, which point back up to them via the
            // parentItem attribute
            // If we hit a sub-item of a container item, call getItemLocator on that so
            // the item is located within the containerItem's items array
            // This method is copied from DF to containerItems below
            // the check for item.parentItem != this is required - if this is running
            // on a container item and we contain an item in our items array we need to
            // allow standard identifier construction to continue or we'd have an infinite loop
            if (item.parentItem && (item.parentItem != this)) {
                return this.getItemLocator(item.parentItem) + "/" +
                            item.parentItem.getItemLocator(item);
            }

            var itemIdentifiers = {};


            if (item.name != null && !item._autoAssignedName) itemIdentifiers.name = item.name;

            // Title - default strategy if no name
            var title = item.getTitle();
            if (title != null) itemIdentifiers.title = title;

            // Value - useful for things like header items where value is pretty much
            // a valid identifier
            var value = item.getValue();
            if (value != null) itemIdentifiers.value = value;

            // Index - cruder identifier
            itemIdentifiers.index = this.getItems().indexOf(item);

            // ClassName: Not used by default
            itemIdentifiers.Class = item.getClassName();

            var IDString = isc.AutoTest.createLocatorFallbackPath("item", itemIdentifiers);
            return IDString;
        },

        // Override getObjectLocator to handle being passed form items
        getObjectLocator : function dynamicForm_getObjectLocator (target) {
            if (isc.isA.FormItem(target)) {
                var itemLocator = this.getItemLocator(target);
                itemLocator += "/objectType=FormItem";
                return itemLocator;
            }
            return this.Super("getObjectLocator", arguments);
        },

        containsLocatorChild : function dynamicForm_containsLocatorChild (canvas) {
            if (isc.isA.DateChooser(canvas) && canvas.callingForm == this) return true;
            return this.Super("containsLocatorChild", arguments);
        },
        getChildLocator : function dynamicForm_getChildLocator (canvas) {
            if (canvas.canvasItem) {
                var item = canvas.canvasItem;
                return this.getItemLocator(item) + "/canvas";
            }
            if (isc.isA.PickListMenu(canvas)) {
                var item = canvas.formItem;
                return this.getItemLocator(item) + "/pickList";
            }
            if (isc.isA.DateChooser(canvas)) {
                var item = canvas.callingFormItem;
                return this.getItemLocator(item) + "/picker";
            }

            return this.Super("getChildLocator", arguments);
        },

        getItemFromSplitLocator : function dynamicForm_getItemFromSplitLocator (locatorArray) {
            var fullItemID = locatorArray[0],
                className;

            // BackCompat note: Old format for identifying form items was
            //   item[name="foo"][Class="TextItem"]
            // new format is
            //   item[name=foo||title=moo||index=2||Class=TextItem]
            // Handle the old format for backCompat
            if (fullItemID.contains("[Class=")) {
                var split = fullItemID.match(
                    "item\\[(.+)'\\]\\[Class=\"(.+)\"\\]"
                );
                className = split[1].substring(6, split[1].length-2);
                fullItemID = split[0];
            }
            var itemConfig = isc.AutoTest.parseLocatorFallbackPath(fullItemID);

            if (itemConfig && itemConfig.name == "item" && itemConfig.config != null) {
                var config = itemConfig.config;

                // className is stored even if we don't identify by it.
                className = config.Class;

                // if we have a valid name, always have it take precedence
                var item;
                if (config.name != null) {
                    //this.logWarn("locating by name" + config.name);
                    item = this.getItem(config.name);
                } else {
                    //this.logWarn("item locator:" +fullItemID + " has no name - checking for " +
                    //    " title etc.");

                    // no name - check for the item 'locateItemBy' setting
                    // Options are by title or by value
                    for (var i = 0; i < this.items.length; i++) {
                        var testItem = this.items[i],
                            locateItemBy = testItem.locateItemBy;
                        if (locateItemBy == null) locateItemBy = "title";
                        //this.logWarn("item:" + testItem + ", locate by:" + locateItemBy +
                        //    "config[locateBy:" + config[locateItemBy]);
                        if (locateItemBy == "title" && config.title != null &&
                            testItem.title == config.title)
                        {
                            item = testItem;
                        } else if (locateItemBy == "value" && config.value != null &&
                                    testItem.getValue() == config.value)
                        {
                            item = testItem;
                        }
                    }

                    // If we couldn't find the item by title or value (or locateItemBy was
                    // specified explicitly as index) - locate by index
                    if (item == null) {
                        var index = config.index;
                        if (isc.isA.String(index)) {
                            if (index.startsWith("'") ||
                                index.startsWith('"'))
                            {
                                index = index.substring(1);
                            }
                            index = parseInt(index);
                        }
                        item = this.items[index];
                    }
                }
                if (!item) {
                    this.logWarn("AutoTest.getElement(): Unable to find item from " +
                        "locator string:" + fullItemID);
                    return null;
                }
                if (!isc.isA[className] || !isc.isA[className](item)) {
                    this.logWarn("AutoTest.getElement(): identifier:"+ fullItemID +
                                " returned an item of class:"+ item.getClassName());
                }
                return item;
            }

            return null;
        },

        getInnerAttributeFromSplitLocator : function
        dynamicForm_getInnerAttributeFromSplitLocator (locatorArray, configuration)
        {
            if (!this.emptyLocatorArray(locatorArray)) {
                var item = this.getItemFromSplitLocator(locatorArray);
                if (item != null) {
                    locatorArray.removeAt(0);
                    return item.getAttributeFromSplitLocator(locatorArray, configuration);
                }
                // support event-parts in all canvii
                if (locatorArray.length == 1) {
                    var undef, element = this._getEventPartElement(locatorArray);
                    if (undef !== element) return element;
                }

                if (configuration.locatorMatching != "permissive") {
                    this.setLogFailureText(true, "the trailing locator suffix '" +
                        locatorArray.join("/") + "' does not identify any FormItem in",
                                           "and permissive mode is not active");
                    return null;
                }
            }
            return isc.AutoTest.getAttributeDefault(this, configuration.attribute);
        },

        _isProcessingDone : function dynamicForm__isProcessingDone (strictMode) {
            if (strictMode && !this.isDrawn()) return true;
            return isc.AutoTest.isFormDone(this) != false;
        }
    });

    // containerItems contain sub items
    // copy methods across to them to form locators for sub items and
    // identify sub items from split locators
    isc.ContainerItem.addProperties({
        // getItemLocator -- called directly by DynamicForm.getItemLocator if
        // an item has a parentItem specified
        getItemLocator:isc.DynamicForm.getPrototype().getItemLocator,
        getItemFromSplitLocator:isc.DynamicForm.getPrototype().getItemFromSplitLocator,

        // getInnerAttributeFromSplitLocator - override to check for the presence of items
        getInnerAttributeFromSplitLocator : function
        containerItem_getInnerAttributeFromSplitLocator (locatorArray, configuration)
        {
            if (!this.emptyLocatorArray(locatorArray)) {
                var subItem = this.getItemFromSplitLocator(locatorArray);
                if (subItem != null) {
                    locatorArray.removeAt(0);
                    return subItem.getAttributeFromSplitLocator(locatorArray, configuration);
                }
            }
            return this.Super("getInnerAttributeFromSplitLocator", arguments);
        }
    });


    isc.FormItem.addProperties({

        //> @attr FormItem.locateItemBy (string : null : IRWA)
        // When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
        // +link{isc.AutoTest.getLocator()} for this form item, should the item be identified?
        // By default if the item has a name this will always be used, however for items with
        // no name, the following options are available:
        // <ul>
        // <li><code>"title"</code> use the title as an identifier within this form</li>
        // <li><code>"value"</code> use the value of the item to identify it (often used
        //  for items with a static defaultValue such as HeaderItems</li>
        // <li><code>"index"</code> use the index within the form's items array.
        // </ul>
        //
        // If unset, and the item has no specified name, default behavior is to
        // identify by title (if available), otherwise by index.
        // @visibility external
        // @group autoTest
        //<

        // Some form items will use the autoChild subsystem to refer to some auto child, like the
        // miniDateRangeItem's date range dialog.
        // In this case, we can use the standard autoChild behavior to pick up this form item
        // as the locator parent (handled in getLocatorParent()) and we'll need to
        // support getChildLocator()
        getChildLocator : function formItem_getChildLocator (target) {

            // More general behavior split into 2 parts for easy overriding - autoChildren are pretty
            // much always respected over other locators such as children / members array
            if (target.creator == this) {
                var autoChildID = this.getAutoChildLocator(target);
                if (autoChildID) return autoChildID;
            }
        },

        // getLocator on a form item. May be called directly if this was picked up as the
        // "parent locator" of an autoChild.
        getLocator : function formItem_getLocator () {
            // Ignore the "element" part - assume this will only be run in the 'autoChild' pattern.
            return this.getLocatorInternal();
        },

        // Override getObjectLocator to handle being passed form item icons
        getObjectLocator : function formItem_getObjectLocator (target) {
            var iconLocator = this.getIconLocator(target),
                locator = iconLocator + "/objectType=FormItemIcon"
            ;
            return locator;
        },

        getIconLocator : function formItem_getIconLocator (icon) {
            var iconIdentifiers = {};

            // Name
            if (icon.name != null) iconIdentifiers.name = icon.name;

            // Index - cruder identifier
            iconIdentifiers.index = this.icons.indexOf(icon);

            var IDString = isc.AutoTest.createLocatorFallbackPath("icon", iconIdentifiers);
            return IDString;
        },

        getLocatorInternal : function formItem_getLocatorInternal (ignoreTestRoot,
                                                                   skipAbsoluteLocator)
        {
            var form = this.form;
            return form.getLocatorInternal(ignoreTestRoot, skipAbsoluteLocator) + "/" +
                form.getItemLocator(this);
        },

        // Implement getAttributeFromSplitLocator at the FormItem level. This means if a developer
        // assigns an actual ID to a FormItem and calls isc.AutoTest.getElement() passing in that
        // ID (for example //TextItem[ID='foo']) we can find it.
        getAttributeFromSplitLocator : function formItem_getAttributeFromSplitLocator (locatorArray,
                                                                                       configuration) {
            // split finding attribute within our handle to a separate method for simpler override
            return this.getInnerAttributeFromSplitLocator(locatorArray, configuration);
        },

        getInnerAttributeFromSplitLocator : function formItem_getInnerAttributeFromSplitLocator (
            locatorArray, configuration)
        {
            var undef,
                attribute = configuration.attribute;

            if (!this.emptyLocatorArray(locatorArray)) {
                var part = locatorArray[0];

                // canvasItems
                if (part == "canvas" && this.canvas) {
                    locatorArray.removeAt(0);
                    var result = this.canvas.getAttributeFromSplitLocator(locatorArray,
                                                                          configuration);
                    // if no attribute could be found in canvas, use formItem's attribute
                    if (result !== undef || attribute == isc.Canvas._$Element) return result;
                }

                // picker (EG date picker)
                if (part == "picker") {
                    if (this.picker) {
                        locatorArray.removeAt(0);
                        return this.picker.getAttributeFromSplitLocator(locatorArray,
                                                                        configuration);
                    }
                }

                // pickList
                if (part == "pickList") {
                    if (!this.pickList) this.makePickList(false);
                    locatorArray.removeAt(0);
                    return this.pickList.getAttributeFromSplitLocator(locatorArray,
                                                                      configuration);
                }

                // icon
                if (part.substring(0,4) == "icon") {
                    var iconConfig = isc.AutoTest.parseLocatorFallbackPath(part);

                    if (iconConfig && iconConfig.name == "icon" && iconConfig.config != null) {
                        var config = iconConfig.config;

                        // if we have a valid name, always have it take precedence
                        var icon;
                        if (config.name != null) {
                            //this.logWarn("locating by name" + part.name);
                            icon = this.getIcon(config.name);
                        } else {
                            var index = config.index;
                            if (isc.isA.String(index)) {
                                if (index.startsWith("'") ||
                                    index.startsWith('"'))
                                {
                                    index = index.substring(1);
                                }
                                index = parseInt(index);
                            }
                            icon = this.icons[index];
                        }
                        if (!icon) {
                            this.logWarn("AutoTest.getElement(): Unable to find form item from " +
                                "locator string:" + part);
                            return null;
                        }
                        return icon;
                    }
                }

                if (attribute == isc.Canvas._$Element) {

                    if (part == "element") return this.getDataElement();
                    if (part == "title") return this.form.getTitleCell(this);
                    if (part == "textbox") return this._getTextBoxElement();
                    if (part == "controltable") return this._getControlTabelElement();
                    if (part == "inlineerror") return this.getInlineErrorHandle();

                    if (part == "valueicon") {
                        var cell = this.getOuterElement();
                        if (cell) {
                            // querySelectorAll is supported in all browsers since IE8
                            if (cell.querySelectorAll) {
                                var candidates = cell.querySelectorAll("[eventpart=valueicon]");
                                if (candidates.length == 1) return candidates[0];
                            }
                        }
                        this.logWarn("Locator specified click event on value icon but " +
                            "unable to find valueIcon element for this item - " +
                            "recorded test may be invalid.", "AutoTest");
                    }

                    // If passed an icon, return a pointer to the img element
                    // Event if there is a link element, it'll be above that in the DOM
                    // Handle single or double-quotes around the icon name
                    var iconSplit = part.match("\\[icon='(.+)'\\]");
                    if (iconSplit == null) iconSplit = part.match('\\[icon="(.+)"\\]');
                    var iconID = iconSplit ? iconSplit[1] : null;

                    if (iconID) {
                        var imgElement = this._getIconImgElement(iconID);
                        if (imgElement == null) this.setLogFailureText(true,
                            "there is no Icon Image Element associated with " + iconID +
                            " and locator '" + locatorArray.join("/") + "' for");
                        return imgElement;
                    }
                }

                // Could be a named autoChild...
                if (this._createdAutoChildren) {
                    var autoChild = this._getNamedAutoChild(part);
                    if (autoChild) {
                        locatorArray.removeAt(0);
                        return autoChild.getAttributeFromSplitLocator(locatorArray, configuration);
                    }
                }

                if (attribute == isc.Canvas._$Element) {
                    this.setLogFailureText(true, "the trailing locator suffix '" +
                                   locatorArray.join("/") + "' does not identify any " +
                                   "Event Part of");
                    return;
                }
            }

            // default values
            switch (attribute) {
            case isc.Canvas._$Object:
                return this;
            case isc.Canvas._$Value:
                return this.getValue();
            case isc.Canvas._$Selected:
                return;
            }

            // If we weren't passed any details, default to the focus
            // element if there is one otherwise the text box element
            var element = this.getFocusElement();
            if (element == null) element = this._getTextBoxElement();
            if (element == null) {
                this.setLogFailureText(true, null, "has no focus or textbox elements");
            }
            return element;
        },

        _getNamedAutoChild : function (name) {
            var createdAutoChildren = this._createdAutoChildren;
            if (!createdAutoChildren) return;

            var children = createdAutoChildren[name];
            if (children && children.length > 0) {
                if (this[name] != null) return this[name];
            } else {
                var fallbackLocatorConfig = isc.AutoTest.parseLocatorFallbackPath(name);
                if (fallbackLocatorConfig != null) {
                    return this.getChildFromFallbackLocator(name, fallbackLocatorConfig);
                }
            }
        },

        _locatorChildren: { button: "buttons" },

        // copy the 'emptyLocatorArray()' helper function across
        emptyLocatorArray:isc.Canvas.getPrototype().emptyLocatorArray
    });

    isc.HeaderItem.addProperties({
        //> @attr HeaderItem.locateItemBy (string : "value" : IRWA)
        // Default to locating header items by value
        // @visibility autoTest
        //<
        locateItemBy: "value"
    });

    if (isc.PickListMenu) {
        isc.PickListMenu.addProperties({
            getLocatorParent : function pickListMenu_getLocatorParent () {
                if (this.formItem) return this.formItem.form;
                return this.Super("getLocatorParent", arguments);
            }
        });
    }
}


if (isc.GridRenderer) {

    isc.GridRenderer.addProperties({
        // generate some helpful text indicating the GridRenderer's valid row and column ranges
        _getValidIndicesText : function gridRenderer__getValidIndices (includeColumns) {
            var result = "; valid row indices are [0, " + this.getTotalRows() + "]";
            if (includeColumns) {
                result += " and valid column indices for the " + this.getScClassName() +
                    " are [0, " + this.fields.length + "]";
            }
            return result;
        },

        // wrap getTableElement() to log any case where a null DOM element is returned
        _getTableElementAndLogFailure : function gridRenderer__getTableElementAndLogFailure
        (locatorArray, rowNum, colNum)
        {
            var element = this.getTableElement(rowNum, colNum);
            if (element != null) return element;

            var undef, content, name;
            if (colNum !== undef) {
                content = "(" + rowNum + ", " +  colNum + ")";
                name = "position";
            } else {
                content = rowNum;
                name = "row";
            }

            var guidance = this._getValidIndicesText(colNum !== undef);

            // if the indices are not literals from the locator, display the locatorArrray
            if (rowNum < 0 || colNum < 0) {
                content += ", derived from the locator suffix '" + locatorArray.join("/") + "',";
                if (colNum < 0) {
                    guidance = "; a negative colNum may indicate a field could not be found";
                } else {
                    guidance = "; a negative rowNum may indicate the targeted record is " +
                               "not present, perhaps not yet loaded";
                }
            }

            this.setLogFailureText(true, content + " does not represent a valid " + name +
                                   " within", guidance);
            if (this.grid) this.grid._testReplayDumpRows();

            return null;
        },

        // report that the row/column locator suffix could not be parsed properly
        _reportInvalidCellLocator : function gridRenderer__reportInvalidCellLocator
        (locatorArray, rowNum, colNum)
        {
            var undef, finish,
                start = "the locator suffix '" + locatorArray.join("/") +"' could not be " +
                        "resolved to a numerical";

            if (colNum !== undef) {
                start += " row and column position within";
                finish = "; only able to resolve to (" + rowNum + ", " + colNum + ")";
            } else {
                start += " row position within";
                finish = "; detected row as " + rowNum;
            }
            this.setLogFailureText(true, start, finish);
            if (this.grid) this.grid._testReplayDumpRows();
        },

        getInteriorLocator : function gridRenderer_getInteriorLocator (element, fromEvent) {
            var cell = this.getCellFromDomElement(element);
            if (cell == null) return this.Super("getInteriorLocator", [element, fromEvent]);

            var rowNum = cell[0], colNum = cell[1],
                locator = this.getCellLocator(rowNum, colNum);
            // attach a drop position to the end of the locator to specify where to drop
            if (locator != null && this.grid != null) {
                if (this == isc.EH.dropTarget) {
                    var dropPosition = this.grid.getRecordDropPosition(rowNum);
                    if (dropPosition != null) locator += "/" + dropPosition;
                } else {
                    var isValueIcon = false;
                    var parentNode = element.parentNode;
                    while (parentNode && element != cell) {
                        if (element.getAttribute &&
                            (element.getAttribute("eventpart") == "valueicon"))
                        {
                            isValueIcon = true;
                            break;
                        }
                        element = parentNode;
                        parentNode = parentNode.parentNode;
                    }
                    if (isValueIcon) {
                        locator += "/valueicon";
                    }
                }
            }
            return locator;
        },

        //> @method gridRenderer.getCellFromDomElement() [A]
        // Given a pointer to an element in the DOM, this method will check whether this
        // element is contained within a cell of the gridRenderer, and if so return a
        // 2 element array denoting the <code>[rowNum,colNum]</code> of the element
        // in question.
        // @param element (DOM element) DOM element to test
        // @return (Array) 2 element array containing rowNum and colNum, or null if the
        //   element is not contained in any cell in this gridRenderer
        // @group autoTest
        // @visibility external
        //<
        getCellFromDomElement : function gridRenderer_getCellFromDomElement (element) {
            var handle = this.getHandle(),
                table = this.getTableElement();

            if (!table) return null;

            var rows = table.rows,
                tagName,
                row, cell,
                tr = "tr", TR = "TR",
                td = "td", TD = "TD";

            while (element && element != table && element != handle) {

                tagName = element.tagName;
                // document whether it's upper / lower case by default
                if (tagName == td || tagName == TD) {
                    cell = element;
                }

                // document whether it's upper / lower case by default
                if (tagName == tr || tagName == TR) {
                    row = element;
                }
                // keep going in case there are nested tables, etc
                element = element.parentNode;
            }
            if (!row || !cell) return null;

            var rows = table.rows, rowNum, logicalRowNum;
            for (var i = 0; i < rows.length; i++) {
                if (rows[i] == row) {
                    rowNum = i;
                    break;
                }
            }
            var cells = row.cells, colNum, logicalColNum;
            for (var i = 0; i < cells.length; i++) {
                if (cells[i] == cell) {
                    colNum = i;
                    break;
                }
            }

            if (rows[0] != row) colNum += rows[0].cells.length - cells.length;

            logicalRowNum = rowNum + (this._firstDrawnRow || 0);
            logicalColNum = colNum + (this._firstDrawnCol || 0);

            return [logicalRowNum,logicalColNum];
        },

        getCellLocator : function gridRenderer_getCellLocator (rowNum, colNum) {
            return "row[" + rowNum + "]/col[" + colNum + "]";
        },

        getInnerAttributeFromSplitLocator : function
        gridRenderer_getInnerAttributeFromSplitLocator (locatorArray, configuration)
        {
            var attribute = configuration.attribute;
            if (attribute == isc.Canvas._$Element || attribute == isc.Canvas._$Selected) {

                if (this.emptyLocatorArray(locatorArray)) {
                    return isc.AutoTest.getAttributeDefault(this, attribute);
                }

                // Format should be [row[index], col[index]]
                if (locatorArray.length == 2) {
                    var cell = this.getCellFromLocator(locatorArray[0], locatorArray[1]),
                        rowNum = cell[0], colNum = cell[1];

                    if (isc.isA.Number(rowNum) && isc.isA.Number(colNum)) {
                        // check selection state of cell
                        if (attribute == isc.Canvas._$Selected) {
                            return this._isSelected(rowNum, colNum);
                        }
                        // We suppress all events on row/cols during row animation
                        // in this case suppress the element entirely so auto-test engines
                        // don't attempt to fire events on them.

                        if (this._suppressEventHandling()) {
                            this.setLogFailureText(true, null, "is being animated");
                            return null;
                        }
                        return this._getTableElementAndLogFailure(locatorArray, rowNum, colNum);
                    } else {
                        this._reportInvalidCellLocator(locatorArray, rowNum, colNum);
                    }
                }
            }
            return this.Super("getInnerAttributeFromSplitLocator", arguments);
        },

        // assumes rowLocator is row[rowNum]
        // colLocator is col[colNum]
        getCellFromLocator : function gridRenderer_getCellFromLocator (rowLocator, colLocator) {
            // This is a straight parse - to support being passed a fuller format and
            // just extracting the index, if present, we'd want to have
            // AutoTest.parseFallbackLocator run and then extract the standalone field value
            // knowing that's an index.
            var rowString = rowLocator.replace(/^row.*(?:\|\||\[)([0-9]+)\]$/, "$1"),
                colString = colLocator.replace(/^col.*(?:\|\||\[)([0-9]+)\]$/, "$1");
            return [parseInt(rowString), parseInt(colString)];
        },

        _isProcessingDone : function gridRenderer__isProcessingDone (strictMode, noEdits) {
            var checkGrid = this.grid && !strictMode;
            if (checkGrid) return this.grid._isProcessingDone(false, noEdits);
            else return this.Super("_isProcessingDone", arguments);
        }
    });

}
if (isc.ListGrid) {
    isc.ListGrid.addProperties({
        //> @attr listGrid.remapOverRecordPositionAs (RecordDropAppearance : isc.ListGrid.AFTER : [IRW])
        // If during Selenium playback, we encounter an "over" drop position, but
        // this is not allowed based on +link{listGrid.recordDropAppearance}, then what
        // drop position should it be remapped to?
        //<
        remapOverRecordPositionAs: isc.ListGrid.AFTER,

        // we explicitly set up the locatorParent pointers on these widgets
        // in ListGrid.js
        namedLocatorChildren:[
            "header", "frozenHeader", "body", "frozenBody",
            {attribute:"_editRowForm", name:"editRowForm"},
            "filterEditor"
        ]
    });


    // We want to handle identifying cells by fieldName, record primary key etc as well
    // as simple rowNum / colNum.
    // We also need to handle the fact that with the option to freeze fields we can end up
    // with a logical cell that was in one sub-component (the frozen body, say)
    // is now in another (the standard body).

    // Implementation:
    // - when generating the Locator string include 'body' / 'frozenBody' as normal but
    //   have getCellLocator overridden in gridBody to record information about the fieldName etc
    //   as well as simple rowNum / colNum
    // - when parsing Locator strings, have the listGrid catch the case where we'd usually
    //   pass through to the body and handle it directly - figuring out which body the
    //   cell is in, and calling 'getTableElement()' on that

    isc.GridBody.addProperties({

        // override 'getInteriorLocator()' -- if an event occurred over an embedded component such
        // as a rollOverCanvas with eventProxy pointing back to us, we can't rely on the
        // DOM element
        // In the case where we're getting a locator from the event actually handle this by getting
        // coordinates from the event

        getInteriorLocator : function gridBody_getInteriorLocator (element, fromEvent) {
            if (fromEvent) {
                var children = this.children;
                if (children != null && children.length > 0) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child && child.eventProxy == this) {
                            var handle = child.getHandle();
                            if (handle != null) {
                                var testElement = element;
                                while (testElement != this.getHandle() && testElement != null)
                                {
                                    if (testElement == handle) {
                                        var rowNum = this.getEventRow(),
                                            colNum = this.getEventColumn();
                                        return this.getCellLocator(rowNum,colNum);

                                    }
                                    testElement = testElement.parentNode;
                                }
                            }
                        }
                    }
                }
            }
            return this.Super("getInteriorLocator", arguments);
        },

        getAutoTestLocatorCoords : function gridBody_getAutoTestLocatorCoords (locator, element)
        {
            var coords = this.Super("getAutoTestLocatorCoords", arguments);
            if (coords == null) return null;

            var grid = this.grid,
                locatorArray = locator.split("/").slice(-3),
                dropPosition = locatorArray[2];

            if (grid._isValidDropPosition(dropPosition)) {
                var rowNum = grid.getRowNumFromLocator(locatorArray, 0);

                if (isc.isA.Number(rowNum)) {


                    if (dropPosition == isc.ListGrid.OVER &&
                        grid.recordDropAppearance != isc.ListGrid.OVER &&
                        grid.recordDropAppearance != isc.ListGrid.BOTH)
                    {
                        var newPosition = grid.remapOverRecordPositionAs,
                            remap = grid._isValidDropPosition(newPosition);
                        if (isc.TreeGrid && isc.isA.TreeGrid(grid)) {
                            var node = grid.getRecord(rowNum);
                            if (grid.canDropOnLeaves || grid.data.isFolder(node)) {
                                remap = false;
                            }
                        }
                        if (remap) dropPosition = newPosition;
                    }

                    var recordTop    = this.getRowTop(rowNum),
                        recordHeight = this.getRowSize(rowNum);

                    switch(dropPosition) {
                    case isc.ListGrid.BEFORE:
                        coords[1] -= recordHeight/2;
                        break;
                    case isc.ListGrid.AFTER:
                        coords[1] += 3*recordHeight/8;
                        break;
                    }
                }
            }
            return coords;
        },

        getCellLocator : function gridBody_getCellLocator (rowNum, colNum) {
            var grid = this.grid;
            if (grid == null) return this.Super("getCellLocator", arguments);
            return grid.getCellLocator(this, rowNum, colNum);
        }

    });

    isc.ListGrid.addProperties({



        testReplayLoggedRows: 50,
        _testReplayDumpRows : function listGrid__testReplayDumpRows () {
            if (!isc.Log.logIsDebugEnabled("testReplay") || !isc.JSON) return;

            var nRows = Math.min(this.testReplayLoggedRows, this.getTotalRows()),
                result = "The first " + nRows + " rows of " + this._getDescription() +
                         " are: \n";

            for (var i = 0; i < nRows; i++) {
                result += "#" + (i + 1) + ": " + isc.JSON.encode(this.getRecord(i)) + "\n";
            }
            isc.AutoTest.logDebug(result.trim(), "testReplay");
        },

        // getCellLocator -- called by the grid body to generate the identifier
        getCellLocator : function listGrid_getCellLocator (body, rowNum, colNum) {
            var rowLocatorOptions = this.getRowLocatorOptions(body, rowNum, colNum),
                colLocatorOptions = this.getColLocatorOptions(body, rowNum, colNum);
            return isc.AutoTest.createLocatorFallbackPath("row", rowLocatorOptions) +
                    "/" + isc.AutoTest.createLocatorFallbackPath("col", colLocatorOptions);
        },

        // builds a config type object that we'll pass to createLocatorFallbackPath
        getRowLocatorOptions : function listGrid_getRowLocatorOptions (body, rowNum, colNum) {

            var locatorOptions = {},
                gridColNum = this.getFieldNumFromLocal(colNum, body),
                record = this.getEditedRecord(rowNum, gridColNum),
                ds = this.getDataSource(true);

            if (record != null) {
                if (ds != null) {
                    var pks = ds.getPrimaryKeyFieldNames();
                    for (var i = 0; i < pks.length; i++) {
                        var pk = pks[i];
                        if (record[pk] != null) {
                            locatorOptions[pk] = record[pk];
                        }
                    }
                }

                var titleField = this.getTitleField();
                if (titleField != null && record[titleField] != null) {
                    locatorOptions[titleField] = record[titleField];
                } else if (isc.isA.Tree(this.data)) {
                    var title = record[this.data.titleProperty];
                    if (title != null) locatorOptions[this.data.titleProperty] = title;
                }
                var fieldName = this.getFieldName(gridColNum);
                if (fieldName != null && record[fieldName] != null) {
                    locatorOptions[fieldName] = record[fieldName];
                }
            }
            // also store the rowNum
            locatorOptions[isc.AutoTest.fallback_valueOnlyField] = rowNum;
            return locatorOptions;
        },

        getColLocatorOptions : function listGrid_getColLocatorOptions (body, rowNum, colNum) {
            var locatorOptions = {},
                gridColNum = this.getFieldNumFromLocal(colNum, body);
            var field = this.getField(gridColNum);
            if (this.isCheckboxField(field)) {
                locatorOptions.isCheckboxField = true;
            } else {
                var fieldName = this.getFieldName(gridColNum);
                if (fieldName != null) locatorOptions.fieldName = fieldName;
            }
            locatorOptions[isc.AutoTest.fallback_valueOnlyField] = colNum;
            return locatorOptions;

        },


        // if the child substring is "frozenBody' / "body", return null - we'll handle
        // finding the element at the ListGrid level
        getChildFromLocatorSubstring : function
        listGrid_getChildFromLocatorSubstring (substring, index, locatorArray)
        {
            if (substring == "frozenBody" || substring == "body") {
                // use a switch statement with fall through to validate all locator pieces
                switch (locatorArray.length - index) {
                case 4:
                    if (locatorArray[index+3] != "valueicon" &&
                        !this._isValidDropPosition(locatorArray[index + 3])) break;
                case 3:
                    if (!locatorArray[index + 2].startsWith("col[")) break;
                case 2:
                    if (!locatorArray[index + 1].startsWith("row[")) break;
                    return null;
                }
            }
            return this.Super("getChildFromLocatorSubstring", arguments);
        },

        getRowNumFromLocator : function listGrid_getRowNumFromLocator (locatorArray, index) {
            // We're looking for an individual row
            var rowLocatorConfig = isc.AutoTest.parseLocatorFallbackPath(locatorArray[index]);
            if (rowLocatorConfig.name != "row") {
                this.logWarn("Error parsing locator: " + locatorArray.join("/") +
                             "; unable to resolve the row");
                return null;
            }
            return this.getRowNumFromLocatorConfig(rowLocatorConfig.config);
        },

        // Override getInnerAttributeFromSplitLocator to handle cells in the body/frozenBody
        getInnerAttributeFromSplitLocator : function listGrid_getInnerAttributeFromSplitLocator (
            locatorArray, configuration)
        {
            var attribute = configuration.attribute,
                emptyValue   = isc.AutoTest.getAttributeDefault(null, attribute),
                defaultValue = isc.AutoTest.getAttributeDefault(this, attribute);

            if (this.emptyLocatorArray(locatorArray)) {
                return isc.AutoTest.setLogFailureForReturnValue(this, locatorArray,
                                                                defaultValue, attribute);
            }

            // expected format: "frozenBody", row[...], col[...]"
            var body = locatorArray[0];
            if (body == "body" || body == "frozenBody") {
                var suffix = locatorArray[3],
                    dropPosition;
                var isValueIcon = false;
                if (suffix == "valueicon") isValueIcon = true;
                else dropPosition = suffix;
                if (locatorArray.length == 2 && attribute == isc.Canvas._$Element) {

                    var rowNum = this.getRowNumFromLocator(locatorArray, 1);
                    if (rowNum == null) return defaultValue;

                    if (isc.isA.Number(rowNum)) {
                        // We suppress all events on row/cols during row animation
                        // in this case suppress the element entirely so auto-test engines
                        // don't attempt to fire events on them.

                        if (this.body._suppressEventHandling()) {
                            this.body.setLogFailureText(true, null, "is being animated");
                            return emptyValue;
                        }
                        return this.body._getTableElementAndLogFailure(locatorArray, rowNum);
                    }

                } else if (locatorArray.length == 3 ||
                           (locatorArray.length == 4 &&
                            (isValueIcon || this._isValidDropPosition(dropPosition))))
                {
                    // Start with the field!
                    var colLocator = locatorArray[2],
                        colLocatorConfig = isc.AutoTest.parseLocatorFallbackPath(colLocator);

                    // colLocatorConfig will have name:"col", config:{config object}
                    // The 'getChildFromLocatorSubstring() method already checks for this but
                    // as a sanity check verify the name of the col locator
                    if (colLocatorConfig.name != "col") {
                        if (attribute == isc.Canvas._$Element) this.setLogFailureText(true,
                            "could not parse column locator '" + colLocator + "' for");
                        this.logWarn("Error parsing locator:" + locatorArray.join("") +
                            " returning ListGrid handle");
                        return defaultValue;
                    }

                    var field = this.getFieldFromColLocatorConfig(colLocatorConfig.config),
                        localColNum;
                    // If no fieldName stored, use the previous colNum instead
                    // [we stored the colNum relative to the body in question]
                    if (field == null) {
                        localColNum = parseInt(colLocatorConfig.
                                               config[isc.AutoTest.fallback_valueOnlyField]);
                        if (body == "frozenBody" && this.frozenBody == null) {
                            this.setLogFailureText(true, "the column locator '" + colLocator +
                            "' is specified on a frozen body but", "has none");
                            return emptyValue; // locator is not valid
                        }
                        // convert to string to a pointer to the widget
                        body = this[body];
                    } else {
                        localColNum = this.getLocalFieldNum(this.getFieldNum(field));

                        if (this.fieldIsFrozen(field)) body = this.frozenBody;
                        else                           body = this.body;
                    }
                    // Bail if we haven't created the right body for some reason

                    if (body == null) {
                        this.setLogFailureText(true, "there was a problem locating the " +
                            "correct GridBody for field " + field.name + " using column " +
                            "locator '" + colLocator + "' within", ", this field seems " +
                            "to be" + (this.fieldIsFrozen(field) ? " " : " not ") + "frozen");
                        return emptyValue;
                    }

                    // At this point we know what body it's in and what the colNum is within that
                    // body.
                    // Now find the row

                    var rowNum = this.getRowNumFromLocator(locatorArray, 1);
                    if (rowNum == null) {
                        if (attribute == isc.Canvas._$Element) this.setLogFailureText(true,
                            "locator suffix  '" + locatorArray.join("/") + "' does not " +
                            "identify a valid row within");
                        return defaultValue;
                    }

                    var bodyName = body == this.frozenBody ? "frozen GridBody" : "GridBody";

                    if (isc.isA.Number(rowNum) && isc.isA.Number(localColNum)) {
                        // We suppress all events on row/cols during row animation
                        // in this case suppress the element entirely so auto-test engines
                        // don't attempt to fire events on them.

                        if (body._suppressEventHandling()) {
                            body.setLogFailureText(true, null, "is being animated");
                            return emptyValue;
                        }

                        switch (attribute) {
                        case isc.Canvas._$Element:
                            var cell = body._getTableElementAndLogFailure(locatorArray,
                                                                      rowNum, localColNum);
                            if (cell && isValueIcon) {
                                // querySelectorAll is supported in all browsers since IE8
                                if (cell.querySelectorAll) {
                                    var candidates = cell.querySelectorAll("[eventpart=valueicon]");
                                    if (candidates.length == 1) return candidates[0];
                                }
                                this.logWarn("Locator specified click event on value icon but " +
                                    "unable to find valueIcon element for this cell - " +
                                    "recorded test may be invalid.", "AutoTest");
                            }
                            return cell;
                        case isc.Canvas._$Value:
                        case isc.Canvas._$Selected:
                            var fieldNum = this.getFieldNumFromLocal(localColNum, body),
                                field = this.getField(fieldNum);
                            if (field != null) {
                                var record = this.getEditedRecord(rowNum, fieldNum);
                                if (record == null) {
                                    this.setLogFailureText(true, "no record could be found " +
                                                       "for field " + field.name + " and row " +
                                                       rowNum + " in");
                                    break;
                                }
                                // check selection state of record or cell
                                if (attribute == isc.Canvas._$Selected) {
                                    return this._isSelected(rowNum, fieldNum, record);
                                }
                                if (field._isCheckboxField) return this.isSelected(record);

                                if (field._standardMenuIconField === true) {
                                    return !!record.checked;
                                }

                                return this.getRawCellValue(record, rowNum, fieldNum);
                            } else {
                                this.setLogFailureText(true, "no field could be found for " +
                                    "column " + localColNum + " within the " + bodyName + " of");
                            }
                        }
                    } else {
                        body._reportInvalidCellLocator(locatorArray, rowNum, localColNum);
                    }
                }
            }
            return this.Super("getInnerAttributeFromSplitLocator", arguments);
        },

        // helper to pick up field based on 'checkboxField' status and name
        // If neither work, we will use field num instead
        getFieldFromColLocatorConfig : function listGrid_getFieldFromColLocatorConfig (colConfig) {
            //this.logWarn("colConfig:" + this.echo(colConfig));
            if (colConfig.isCheckboxField != null) {

                for (var i = 0; i < this.fields.length; i++) {
                    if (this.isCheckboxField(this.fields[i])) {
                        return this.fields[i];
                    }
                    // In this case we didn't find a checkbox field - test is probably
                    // invalid
                    this.logWarn("AutoTest stored a locator for interaction with " +
                            "checkbox field - but this grid is not showing a checkbox field - " +
                            "recorded test may be invalid.", "AutoTest");
                    // returning -1 here - this causes use to not return some other random
                    // unrelated cell (typically the first column in the grid)
                    return -1;
                }
            } else {

                var locateColsBy = this.locateColumnsBy;
                //locateColsBy will be one of ("fieldName", "index")

                if (locateColsBy == "fieldName" || locateColsBy == null) {
                    var fieldName = colConfig.fieldName;
                    if (fieldName != null) {
                        return this.getField(fieldName);
                    }
                }
            }
        },

        getRowNumFromLocatorConfig : function listGrid_getRowNumFromLocatorConfig (rowConfig) {
            //this.logWarn("rowConfig:" + this.echo(rowConfig));
            var locateRowsBy = this.locateRowsBy;

            if (locateRowsBy == null) locateRowsBy = "primaryKey";
            var data = this.data,
                bestGuess;
            switch(locateRowsBy) {
                case "primaryKey":
                    this.logDebug("Trying to locate row by pk", "autotest");
                    //this.logWarn("rowConfig: " + isc.Comm.serialize(rowConfig));
                    var ds = this.getDataSource();
                    if (ds != null) {
                        var pkFields = ds.getPrimaryKeyFieldNames(),
                            allKeys = pkFields.length > 0;
                        for (var i = 0; i < pkFields.length; i++) {
                            if (rowConfig[pkFields[i]] == null) {
                                allKeys = false;
                                break;
                            }
                        }
                        if (allKeys) {
                            var rowNum = this.findRowNum(rowConfig);
                            if (rowNum != -1) {
                                this.logDebug("Located row " + rowNum + " by pk", "autotest");
                                return rowNum;
                            }
                        }
                    }
                    this.logDebug("Failed to locate row by pk.  Config: " +
                                  isc.echoAll(rowConfig), "autotest");
                    // don't break - if we were unable to use PK, fall back through
                    // titleField / cell value before index

                    // NOTE: The skipFallback property is an internal flag to ensure that the
                    // row is located by primary key, or not at all.  The primary motivation
                    // for adding it is to enable automated testing of the PK functionality;
                    // for that, we have to be certain that the element was located by
                    // primaryKey and not some fallback strategy
                    if (isc.AutoTest.skipFallback) return -1;

                case "titleField":
                    //this.logWarn("trying to locate by title field");
                    var titleField = this.getTitleField();
                    if (titleField != null && rowConfig[titleField] != null) {
                        var matches = data.findAllIndices(titleField, rowConfig[titleField]);
                        if (matches.length == 0) return -1;
                        if (matches.length == 1) return matches[0];
                        // Ambiguous - fall through to fallback mechanisms, but first
                        // "sparse-up" the data array so we limit to valid matches!
                        var sparseData = [];
                        for (var i = 0; i < matches.length; i++) {
                            sparseData[matches[i]] = data.get(matches[i]);
                        }
                        bestGuess = matches[0];
                        data = sparseData;
                    }

                case "targetCellValue":
                    //this.logWarn("trying to locate by target");
                    // Assertion: In this case, there was no titleField or primary key
                    // on the config object.
                    // This relies on the fact that we wouldn't store "null"s on that object
                    // when creating the locator options.
                    // All that's left is the original index under the fallback_valueOnlyField
                    // array and the target row cell value
                    for (var fieldName in rowConfig) {
                        if (fieldName == isc.AutoTest.fallback_valueOnlyField) continue;

                        if (rowConfig[fieldName] != null) {
                            var matches = data.findAllIndices(fieldName, rowConfig[fieldName],
                                              isc.AutoTest._compareLocatorFallbackConfigValues);
                            if (matches.length == 0) return -1;
                            if (matches.length == 1) return matches[0];
                            var sparseData = [];
                            for (var i = 0; i < matches.length; i++) {
                                sparseData[matches[i]] = data.get(matches[i]);
                            }
                            bestGuess = matches[0];
                            data = sparseData;
                        }
                    }
                default:
                    //this.logWarn("locate by rowNum");
                    // Final fallback option- original rowNum as stored
                    // Technically this is locateRowsBy "index"
                    // however if titleField / targetCellValue was ambiguous, this may also
                    // be hit with a sparse array of possible matches.
                    var rowNum = parseInt(rowConfig[isc.AutoTest.fallback_valueOnlyField]);
                    var undef;
                    if (bestGuess == null || data[rowNum] !== undef) return rowNum;

                    else return bestGuess;
            }
        },

        _isValidDropPosition : function listGrid__isValidDropPosition (dropPosition) {
            switch (dropPosition) {
            case isc.ListGrid.BEFORE:
            case isc.ListGrid.AFTER:
            case isc.ListGrid.OVER:
                return true;
            }
            return false;
        },

        _isProcessingDone : function listGrid__isProcessingDone (strictMode, noEdits) {

            var allowEdits = !noEdits || isc.RecordEditor && isc.isA.RecordEditor(this);
            if (isc.AutoTest.isGridDone(this, allowEdits) == false) return false;
            return this.Super("_isProcessingDone", arguments);
        }
    });
}
if (isc.Menu) {

isc.Menu.addClassMethods({


getMenuAtLevel : function (level) {
    var openMenus = isc.Menu._openMenus || [],
        menuAtLevel = openMenus.find("_parentMenu", null);
    if (menuAtLevel == null) return null;

    for (var i = 0; i < level; i++) {
        menuAtLevel = menuAtLevel._open_submenu;
        if (menuAtLevel == null) {
            this.logInfo("Unable to locate active menu at level " + level +
                         " - returning null");
            return null;
        }
    }
    return menuAtLevel;
}

});

isc.Menu.addMethods({

_menuLocatorTemplate: [
"//Menu[level=",
,   // menu level
"]"
],
getLocatorRoot : function menu_getLocatorRoot() {
    // where a stable ID is present, give that preference for simplicity
    if (this.hasStableID()) return this.Super("getLocatorRoot", arguments);
    // otherwise, create a level-based locator since only one menu hierarchy can be open
    if (!this.locatorRoot) {
        var level = 0;
        for (var menu = this; menu && menu._parentMenu; menu = menu._parentMenu) level++;
        this._menuLocatorTemplate[1] = level;
        this.locatorRoot = this._menuLocatorTemplate.join(isc.emptyString);
    }
    return this.locatorRoot;
},

// Override getObjectLocator to handle being passed a menuItem
getObjectLocator : function menu_getObjectLocator (target) {
    if (isc.isAn.Object(target)) {
        var rowNum = this.getRecordIndex(target);
        if (rowNum != null) {
            var rowLocatorOptions = this.getRowLocatorOptions(this.body, rowNum),
                rowLocator = isc.AutoTest.createLocatorFallbackPath("row", rowLocatorOptions) +
                    "/objectType=MenuItem";
            ;
            return rowLocator;
        }
    }
    return this.Super("getObjectLocator", arguments);
},

getAttributeFromSplitLocator : function menu_getAttributeFromSplitLocator (locatorArray,
        configuration)
{
    var attribute = configuration.attribute;

    if (isc.Canvas._$Object == attribute && locatorArray[locatorArray.length-1] == "objectType=MenuItem") {
        var rowConfig = isc.AutoTest.parseLocatorFallbackPath(locatorArray[0]);
        if (rowConfig && rowConfig.name == "row" && rowConfig.config != null) {
            var config = rowConfig.config,
                rowNum = this.getRowNumFromLocatorConfig(config)
            ;
            if (rowNum != null) {
                return this.getRecord(rowNum);
            }
        }
    }

    return this.Super("getAttributeFromSplitLocator", arguments);
}

});

}
if (isc.TreeGrid) {
    isc.TreeGridBody.addProperties({
        getOpenAreaWidth : function treeGridBody_getOpenAreaWidth (rowNum, colNum) {
            var grid = this.grid,
                data = grid.data,
                node = grid.getRecord(rowNum);

            // remap colNum relative to TreeGrid's fields
            colNum = grid.getFieldNumFromLocal(colNum, this);

            // fail if field is not the tree field, or we can't determine whether it's a folder
            if (grid.getTreeFieldNum() != colNum || data == null || !data.isFolder(node)) {
                return null;
            }
            return grid.getOpenAreaWidth(node);
        },

        getInteriorLocator : function treeGridBody_getInteriorLocator (element, fromEvent,
                                                                       coords)
        {
            var origElement = element;

            var grid = this.grid,
                handle = this.getHandle(),
                tableElement = this.getTableElement();

            if (!element || !handle || !tableElement) return isc.emptyString;
            var openAreaPrefix = grid.getCanvasName() + grid._openIconIDPrefix,
                rowNum, colNum;

            // The checkbox icon shows in the "extra icon" slot so
            // we'll have one or the other (not both) and can just store "extraIcon" as an
            // identifier
            var extraIconPrefix = grid.getCanvasName() + grid._extraIconIDPrefix;

            // optimization - we could duplicate the logic from GR here and avoid
            // double-iterating through the DOM if we're NOT in the open area of the TG.
            while (element != this.tableElement && element != handle && element.getAttribute) {
                // check the "name"/"id" property for the open-icon
                var ID = element.getAttribute(isc.Canvas._generateSpanForBlankImgHTML ?
                                              "id" : "name");
                if (ID) {
                    if (ID.startsWith(extraIconPrefix)) {
                        rowNum =  parseInt(ID.substring(extraIconPrefix.length));
                        colNum = grid.getLocalFieldNum(grid.getTreeFieldNum());
                        return this.getCellLocator(rowNum,colNum) + "/extra";
                    }
                }
                element = element.parentNode;
            }


            var cell = this.getCellFromDomElement(origElement);
            if (cell) {
                var openAreaWidth = this.getOpenAreaWidth(cell[0], cell[1]);
                if (openAreaWidth != null) {
                    var rect = this.getCellPageRect(cell[0], cell[1]),
                        x = coords[0] - rect[0];
                    if (x >= 0 && x < openAreaWidth) {
                        return this.getCellLocator(cell[0], cell[1]) + "/open";
                    }
                }
            }


            return this.Super("getInteriorLocator", [origElement, fromEvent, coords]);
        },

        getInnerAttributeFromSplitLocator : function
        treeGridBody_getInnerAttributeFromSplitLocator (locatorArray, configuration)
        {
            var grid = this.grid,
                attribute = configuration.attribute,
                emptyValue   = isc.AutoTest.getAttributeDefault(null, attribute),
                defaultValue = isc.AutoTest.getAttributeDefault(this, attribute);

            if (this.emptyLocatorArray(locatorArray)) {
                return isc.AutoTest.setLogFailureForReturnValue(this, locatorArray,
                                                                defaultValue, attribute);
            }

            // Additional Format is: [row[index], col[index], open]
            if (locatorArray.length == 3 && attribute != isc.Canvas._$Selected) {
                if (locatorArray[2] == "open") {
                    // We suppress all events on row/cols during row animation
                    // Also suppress toggleFolder event target in this case.

                    if (this._suppressEventHandling()) {
                        this.setLogFailureText(true, null, "is being animated");
                        return emptyValue;
                    }

                    var rowLocator = locatorArray[0];
                    var rowNum;

                    //   old format was row3
                    // new format is a standard row locator like
                    //   row[pkFieldValue=foo|3]
                    // Test for old format explicitly since parseLocatorFallbackPath doesn't
                    // handle it.
                    if (rowLocator.charAt(3) != "[") {
                        rowNum = parseInt(rowLocator.substring(3));
                    } else {
                        var rowLocatorConfig = isc.AutoTest.parseLocatorFallbackPath(rowLocator);
                        if (rowLocatorConfig == null || rowLocatorConfig.name != "row") {
                            this.setLogFailureText(true, "the row locator '" +
                                                   rowLocator + "' for", "could not be parsed");
                        }
                        rowNum = grid.getRowNumFromLocatorConfig(rowLocatorConfig.config);
                    }
                    if (attribute == isc.Canvas._$Value) {
                        var data = grid.data,
                            record = grid.getRecord(rowNum);
                        if (record == null || !data) {
                            this.setLogFailureText(true, "no record could be found " +
                                                   "for row " + rowNum + " of");
                            return;
                        }
                        return data.isOpen(record);
                    } else {
                        var colNum = grid.getLocalFieldNum(grid.getTreeFieldNum());
                        if (isc.isA.Number(rowNum) && isc.isA.Number(colNum)) {
                            return this._getTableElementAndLogFailure(locatorArray,
                                                                      rowNum, colNum);
                        } else {
                            this._reportInvalidCellLocator(locatorArray, rowNum, colNum);
                            return null;
                        }
                    }

                // exactly the same logic for the "extraIcon", which is also used for
                // the checkbox icon when doing checkbox / cascading selection
                } else if (locatorArray[2] == "extra") {
                    if (this._suppressEventHandling()) {
                        this.setLogFailureText(true, null, "is being animated");
                        return emptyValue;
                    }

                    var rowLocator = locatorArray[0];
                    var rowNum;

                    //   old format was row3
                    // new format is a standard row locator like
                    //   row[pkFieldValue=foo|3]
                    // Test for old format explicitly since parseLocatorFallbackPath doesn't
                    // handle it.
                    if (rowLocator.charAt(3) != "[") {
                        rowNum = parseInt(rowLocator.substring(3));
                    } else {
                        var rowLocatorConfig = isc.AutoTest.parseLocatorFallbackPath(rowLocator);
                        if (rowLocatorConfig == null || rowLocatorConfig.name != "row") {
                            this.setLogFailureText(true, "the row locator '" +
                                                   rowLocator + "' for", "could not be parsed");

                        }
                        rowNum = grid.getRowNumFromLocatorConfig(rowLocatorConfig.config);
                    }
                    // we recorded the colNum but we don't need it!
                    //var colNum = grid.getTreeFieldNum();

                    if (attribute == isc.Canvas._$Value) {
                        var selection = grid.selection,
                            record = grid.getRecord(rowNum);

                        if (record == null) {
                            this.setLogFailureText(true, "no record could be found " +
                                                   "for row " + rowNum + " of");
                            return;
                        }
                        if (selection == null) {
                            this.setLogFailureText(true, "no selection object could be found " +
                                                   "for");
                            return;
                        }

                        var isSel = selection.isSelected(record);
                        if (!isSel || !grid.showPartialSelection) return isSel;
                        return selection.isPartiallySelected(record) ? "partial" : isSel;
                    } else {
                        // use getImage since we write a name into the opener icon.
                        var openerID = grid._extraIconIDPrefix + rowNum,
                        image = grid.getImage(openerID, isc.Canvas._generateSpanForBlankImgHTML);
                        if (image) return image;
                        else {
                            this.setLogFailureText(true, "no opener image could be found for " +
                                                   "row " + row + " of");
                            return null;
                        }
                    }
                }
            }
            return this.Super("getInnerAttributeFromSplitLocator", arguments);
        },

        getAutoTestLocatorCoords : function treeGridBody_getAutoTestLocatorCoords (locator,
                                                                                   element)
        {
            var coords = this.Super("getAutoTestLocatorCoords", arguments);
            if (coords == null) return coords;

            var tg = this.grid;
            // if we're picking up other icon coords will be position of icon so return it
            if (tg == null || locator.endsWith("/extra")) return coords;

            var offsetY = coords[1] - this.getPageTop()  + this.getScrollTop(),
                offsetX = coords[0] - this.getPageLeft() + this.getScrollLeft();

            var rowNum = this.getEventRow   (offsetY),
                colNum = this.getEventColumn(offsetX),
                openAreaWidth = this.getOpenAreaWidth(rowNum, colNum);
            if (openAreaWidth != null) {
                var rect = isc.Element.getElementRect(element),
                    left  = rect[0],
                    width = rect[2];

                if (locator.endsWith("/open")) {
                    coords[0] = left + Math.floor(openAreaWidth/2);
                } else {
                    left  += openAreaWidth;
                    width -= openAreaWidth;
                    coords[0] = left + Math.floor(width/2);
                }
            }
            return coords;
        }
    });
}


if (isc.TileGrid) {
    isc.TileGrid.addMethods({
        _isProcessingDone : function tileGrid__isProcessingDone (strictMode) {
            if (strictMode && !this.isDrawn()) return true;
            return isc.AutoTest.isTileGridDone(this) != false;
        },

        getCanvasFromFallbackLocator : function
        tileGrid_getCanvasFromFallbackLocator (substring, config, candidates,
                                               strategy, typeStrategy)
        {
            if (typeStrategy == "Class" && config.Class == "SimpleTile") {
                var data = this.data,
                    dataIndex = parseInt(config.classIndex);

                if (this.recycleTiles) dataIndex += this.getDrawnStartIndex();

                var tileID = this.getTileID(data.get(dataIndex));
                if (tileID && window[tileID]) {
                    config.classIndex = this.tiles.indexOf(window[tileID]);
                }
            }
            return this.Super("getCanvasFromFallbackLocator", arguments);
        },
        getCanvasLocatorFallbackPath : function
        tileGrid_getCanvasLocatorFallbackPath (childName, instance, liveChildren) {
            var liveIndex = instance.tileNum;
            if (this.recycleTiles) liveIndex -= this.getDrawnStartIndex();
            instance = liveChildren[liveIndex];
            return this.Super("getCanvasLocatorFallbackPath", arguments);
        }
});
}
if (isc.TileLayout) {
    isc.TileLayout.addMethods({
        _isProcessingDone : function tileLayout__isProcessingDone (strictMode) {
            if (strictMode && !this.isDrawn()) return true;
            return isc.AutoTest.isTileLayoutDone(this) != false;
        }
});
}

//  DrawPane
if (isc.DrawPane) {
    isc.DrawPane.addMethods({
        _isProcessingDone : function drawPane__isProcessingDone (strictMode) {
            if (strictMode && !this.isDrawn()) return true;
            return isc.AutoTest.isDrawPaneDone(this) != false;
        }
});
}

// TabSets:
// We want to be able to locate tabs by ID or title rather than just index so if the order
// changes they continue to be accessable
if (isc.TabSet) {
    isc.TabSet.addProperties({

        // Relevant logic outside this file:
        //
        // In TabSet: tabBarControls layout has locatorParent / namedLocatorChildren set such that
        // the tabset will point directly to that auto-child by name.


        // In TabBar we have logic in makeButton to set 'locatorParent' on tabs to point
        // straight to the TabSet

        // Need to update containsLocatorChild / getStandardChildLocator / ... ? _locatorChildren??
        containsLocatorChild : function tabSet_containsLocatorChild (canvas) {
            if (this.Super("containsLocatorChild", arguments)) return true;

            if (this.getTabNumber(canvas) != -1) return true;
            return false;
        },

        getChildLocator : function (canvas) {
            // Instead of the standard "paneContainer" child locator for this TabSet's paneContainer,
            // we want to just skip the paneContainer when building up an scLocator. This is
            // because we want to use a "tabPane[]" locator instead; i.e. instead of this:
            //     .../paneContainer/member[...]/...
            // .. we want:
            //     .../tabPane[...]/...
            if (canvas === this.paneContainer) {
                return null;
            }
            return this.Super("getChildLocator", arguments);
        },

        _getTabObjLocatorConfig : function (tabObj, tabNum) {
            var locatorConfig = {};
            // locate by name, ID, title or index
            if (tabObj.name != null) locatorConfig.name = tabObj.name;
            if (tabObj.title != null) locatorConfig.title = tabObj.title;
            if (tabObj.ID != null && !tabObj._autoAssignedID) locatorConfig.ID = tabObj.ID;
            locatorConfig.index = tabNum;
            return locatorConfig;
        },

        getStandardChildLocator : function tabSet_getStandardChildLocator (canvas) {
            var tabNum = this.getTabNumber(canvas);
            if (tabNum != -1) {
                var tabObj = this.getTabObject(tabNum);

                var locatorConfig = this._getTabObjLocatorConfig(tabObj, tabNum);
                return isc.AutoTest.createLocatorFallbackPath("tab", locatorConfig);
            }
            return this.Super("getStandardChildLocator", arguments);
        },

        //> @attr TabSet.locateTabsBy (string : null : IRWA)
        // When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
        // +link{isc.AutoTest.getLocator()}, how should tabs within this tabset be identified?
        // By default if tab has a specified +link{Tab.ID} this will always be used.
        // For tabs with no ID, the following options are available:
        // <ul>
        // <li><code>"title"</code> use the title as an identifier</li>
        // <li><code>"index"</code> use the index of the tab in the tabset as an identifier</li>
        // </ul>
        //
        // If unset, and the tab has no specified ID, default behavior is to
        // identify by title (if available), otherwise by index.
        // @visibility external
        // @group autoTest
        //<
        getChildFromLocatorSubstring : function tabSet_getChildFromLocatorSubstring (substring) {
            var isTabLocator,
                isTabPaneLocator;
            // this startsWith("tab[") is a bit of a hack we will probably just pass the
            // substring to AutoTest.parseLocatorFallbackPath directly and look at the returned
            // 'name' property -- however not sure if it'll handle all formats right now.
            if (substring != null &&
                ((isTabLocator = substring.startsWith("tab[")) ||
                 (isTabPaneLocator = substring.startsWith("tabPane["))))
            {
                var fallbackConfig = isc.AutoTest.parseLocatorFallbackPath(substring),
                    config = fallbackConfig.config,
                    tab;

                // if ID or name is present, always respect it:
                if (config.ID != null) {
                    tab = config.ID;
                } else if (config.name != null) {
                    tab = config.name;
                } else {
                    var locateTabsBy = this.locateTabsBy;
                    if (locateTabsBy == null) locateTabsBy = "title";

                    if (config.title && locateTabsBy == "title") {
                        tab = this.tabs.findIndex("title", config.title);
                    // last case -- we want to use the raw tab index.
                    } else {
                        tab = parseInt(config.index);
                    }
                }

                if (isTabLocator) {
                    return this.getTab(tab);
                } else {

                    return this.getTabPane(tab);
                }
            }

            return this.Super("getChildFromLocatorSubstring", arguments);
        }

    });

    var extraPaneContainerProperties = {
        // Override getChildLocator() for a TabSet's paneContainer to generate a "tabPane[]"
        // locator rather than a "paneContainer/member[]" locator.
        getChildLocator : function (canvas) {
            var tabSet = this.creator,
                tabs = tabSet && tabSet.tabs;
            if (tabs != null) {
                var tabNum = tabs.findIndex("pane", canvas);
                if (tabNum >= 0) {
                    var tabObj = tabs[tabNum];

                    var locatorConfig = tabSet._getTabObjLocatorConfig(tabObj, tabNum);
                    return isc.AutoTest.createLocatorFallbackPath("tabPane", locatorConfig);
                }
            }
            return this.Super("getChildLocator", arguments);
        },

        getFallbackLocatorCandidates : function (name) {
            if (name === "member") {
                if (!isc.TabSet._loggedPaneContainerMemberChildLocatorWarning) {
                    this.logWarn("scLocators involving selection of a member of a TabSet's " +
                                 "paneContainer are deprecated. Instead, use a \"tabPane[]\" " +
                                 "locator. Note: A \"tabPane[]\" locator will be generated " +
                                 "automatically if the test script is re-recorded.");
                        isc.TabSet._loggedPaneContainerMemberChildLocatorWarning = true;
                    }
                    return this.creator && this.creator.tabs && this.creator.tabs.getProperty("pane");
                }
            return this.Super("getFallbackLocatorCandidates", arguments);
        }
    };
    isc.TabSet.changeDefaults("paneContainerDefaults", extraPaneContainerProperties);
    if (isc.PaneContainer) isc.PaneContainer.addProperties(extraPaneContainerProperties);

}

// ----------------------------------------------
// Returning element from interior locator

if (isc.StatefulCanvas) {
    isc.StatefulCanvas.addProperties({

        getInteriorLocator : function statefulCanvas_getInteriorLocator (element, fromEvent,
                                                                         coords)
        {
            // special case; handle track from a slider to generate targetValue for coords
            if (isc.Slider && isc.isA.Slider(this.creator) && this.creator._track == this) {
                return this.creator.getInteriorLocator(element, fromEvent, coords);
            }
            return this.Super("getInteriorLocator", arguments);
        },

        getInnerAttributeFromSplitLocator : function statefulCanvas_getInnerAttributeFromSplitLocator (
            locatorArray, configuration)
        {
            // label floats over statefulCanvas - if we have a specified part, assume it occurred
            // in the label since that's where we write out our icon, etc.
            if (!this.emptyLocatorArray(locatorArray) && this.label) {
                return this.label.getInnerAttributeFromSplitLocator(locatorArray, configuration);
            }
            // provide access to (Img)Button state
            var attribute = configuration.attribute;
            if ((isc.Canvas._$Value == attribute || isc.Canvas._$Selected == attribute) &&
                isc.isA.Function(this.isSelected))
            {
                return this.isSelected();
            }
            return this.Super("getInnerAttributeFromSplitLocator", arguments);
        },

        getAutoTestLocatorCoords : function statefulCanvas_getAutoTestLocatorCoords (locator,
                                                                                     element)
        {
            // special case; get coords associated with targetValue from the slider
            if (isc.Slider && isc.isA.Slider(this.creator) && this.creator._track == this) {
                return this.creator.getAutoTestLocatorCoords(locator, element);
            }
            return this.Super("getAutoTestLocatorCoords", arguments);
        }
    });
}

if (isc.Menu) {
    isc.Menu.addProperties({
        // Should this widget's ID be used during scLocator generation?
        hasStableID : function menu_hasStableID () {

            var rootMenu = this._rootMenu;
            if (rootMenu != null && this.ID.startsWith(rootMenu.ID)) {
                return rootMenu.hasStableID();
            }
            return this.Super("hasStableID", arguments);
        }
    });
}

// DateChooser

if (isc.DateChooser) {


    isc.DateChooser.addMethods({

        getInteriorLocator : function dateChooser_getInteriorLocator (element) {

            // We don't write any kind of unique DOM IDs or attrs to our buttons which
            // would simplify determining the purpose of the buttons except our click handler.

            // 2 possible approaches:
            // 1) Crudely look at the current cell position in whichever table its in - likely to
            //    break if we rework ... wait a sec

            // Ok so playback / record type stuff
            //
            // Lets say we store this as prevYear, prevMo, moLauncher, nextMo, nextYear and
            // dateCell[rowNum,colNum] and today, cancel

            // we can then get back the appropriate button when rerun
            // however if the default date has changed (which it likely will, tests are unlikely
            // to work unless the user changes to a specific month first....


            // Alternative would be to remember dateCell[datestamp] - then we simply won't find
            // the element if the date changes. Ok that seems better - won't get WRONG behavior

            // If we have a header, the event may have occurred in it
            var handle = this.getHandle();
            if (!handle || !element) return "";

            var cachedString = element._cachedLocatorString;
            if (cachedString != null && cachedString != "") return cachedString;

            return element._cachedLocatorString = this._getInteriorLocator(element, handle);
        },

        _getInteriorLocator : function dateChooser__getInteriorLocator (element, handle) {
            var targetCell = element;
            while (targetCell && targetCell != null) {
                if (targetCell == handle) {
                    targetCell = null;
                    break;
                }
                if (targetCell.tagName && targetCell.tagName.toLowerCase() == "td") {
                    break;
                }
                targetCell = targetCell.parentElement;
            }
            if (targetCell == null || targetCell.getAttribute == null) return "";

            var eventPart = targetCell.getAttribute(isc.EH._$eventPartAttributeName);
            if (!eventPart) return "";

            var childNodes = handle.childNodes,
                tables = [];
            for (var i = 0; i < childNodes.length; i++) {
                if (!childNodes[i].tagName || childNodes[i].tagName.toLowerCase() != "table") {
                    continue;
                }
                tables[tables.length] = childNodes[i];
            }

            var headerTable = tables.length == 2 ? tables[0] : null,
                bodyTable = tables.length == 2 ? tables[1] : tables[0];

            if (headerTable != null && targetCell.offsetParent == headerTable) {
                // could look at position within rows array -- but then we'd have to also
                // look at the various 'showMonthChooser' etc configurations -- instead
                // lets look directly at the eventpart attribute

                switch (eventPart) {
                    case "showPrevYear":  return "prevYearButton";
                    case "showPrevMonth": return "prevMonthButton";
                    case "showMonthMenu": return "monthMenuButton";
                    case "showYearMenu":  return "yearMenuButton";
                    case "showNextMonth": return "nextMonthButton";
                    case "showNextYear":  return "nextYearButton";
                }
                return "";

            } else if (bodyTable != null && targetCell.offsetParent == bodyTable) {
                // If the event was in the body, return the appropriate date identifier

                switch (eventPart) {
                    case "cancel": return "cancelButton";
                    case "today":  return "todayButton";
                    default:
                    var eventId = targetCell.id;
                    if (eventId) {
                        var dateId = eventId.split("_");
                        if (dateId && dateId.length >= 3) {
                            dateId = dateId.slice(dateId.length - 3);
                        }
                        return dateId.join("/");
                    }
                }
            }
            return "";
        },


        getInnerAttributeFromSplitLocator : function
        dateChooser_getInnerAttributeFromSplitLocator (locatorArray, configuration)
        {
            if (configuration.attribute != isc.Canvas._$Element) {
                this.setLogFailureText(true, "getValue() is not supported for");
                return;
            }

            var handle = this._getHandleAndLogFailure();
            if (handle == null || this.emptyLocatorArray(locatorArray)) return handle;

            var isDateButton = (locatorArray.length == 3);
            if (!isDateButton) {

                var locatorString = locatorArray[0];
                if (locatorString == "") return handle;

                var isTodayButton = (locatorString == "todayButton"),
                    isCancelButton = !isTodayButton ? (locatorString == "cancelButton") : false;

                var childNodes = handle.childNodes;

                // today / cancel button show up in the "body" table
                if (isTodayButton || isCancelButton) {

                    if (isTodayButton && !this.showTodayButton) {
                        this.logWarn("DateChooser attempting to locate element for " +
                            "'todayButton' but showTodayButton is false. Returning handle.",
                            "AutoTest");
                        return handle;
                    }
                    if (isCancelButton && !this.showCancelButton) {
                        this.logWarn("DateChooser attempting to locate element for " +
                            "'cancelButton' but showCancelButton is false. Returning handle.",
                            "AutoTest");
                        return handle;
                    }

                    var bodyTable;
                    // we show two tables if the header is showing, or just one if not.
                    // Either way the table we want is the last table in the handle.
                    for (var i = childNodes.length-1; i >= 0; i--) {
                        if (childNodes[i].tagName &&
                            childNodes[i].tagName.toLowerCase() == "table")
                        {
                            bodyTable = childNodes[i];
                            break;
                        }
                    }

                    // today/cancel button cells are in the last row of the table
                    var lastRow = bodyTable.rows[bodyTable.rows.length-1],
                        cells = lastRow.cells;
                    for (var i = 0; i < cells.length; i++) {
                        if (this.getInteriorLocator(cells[i]) == locatorString) {
                            return cells[i];
                        }
                    }

                } else {

                    // Other buttons show up in the header table
                    if (!this.showHeader) {
                        this.logWarn("DateChooser attempting to locate element for " + locatorArray +
                          " but this.showHeader is false so this element will not be present. " +
                          "Returning handle.", "AutoTest");
                        return handle;
                    }

                    var headerTable;
                    // we show two tables if the header is showing, so grab the first table in the
                    // childNodes array
                    for (var i = 0; i < childNodes.length; i++) {
                        if (childNodes[i].tagName &&
                            childNodes[i].tagName.toLowerCase() == "table")
                        {
                            headerTable = childNodes[i];
                            break;
                        }
                    }
                    if (headerTable) {
                        // controls show up in the first row of cells
                        var row = headerTable.rows[0],
                            cells = row.cells;
                        for (var i = 0; i < cells.length; i++) {
                            if (this.getInteriorLocator(cells[i]) == locatorString) {
                                return cells[i];
                            }
                        }
                    }
                }

            // Date Buttons. Only releveant if we're showing the date in question!
            } else {
                // If we're showing a different year, obviously we're not showing the date button
                var year = locatorArray[0],
                    month = locatorArray[1],
                    date = locatorArray[2];
                // month may differ but only for the few 'spillover' days at the beginning/end
                // of the week - so if the month is off by more than one we're not showing the
                // button
                if ((year == this.year) &&
                        (this.month == month || this.month == month+1 || this.month == month-1))
                {
                    // We could iterate through all the visible buttons looking at locators and
                    // see if they match, or we could figure out the rowNum/colNum in which
                    // the date will be showing (if it is) and pick the cell that way.
                    // We'll take the second approach
                    var buttonDate = Date.createLogicalDate(year,month,date),
                        buttonDay = buttonDate.getDay(),
                        cell = this.dateGrid.getDateCell(buttonDate)
                    ;

                    if (cell) {
                        return this.dateGrid.body._getTableElementAndLogFailure(locatorArray,
                                                                                cell.rowNum,
                                                                                cell.colNum);
                    }

                } else {
                    this.logInfo("DateChooser passed ID for the wrong year or month - passed:" +
                        locatorArray + ", showing:" + [this.year,this.month], "AutoTest");
                }

                this.logWarn("DateChooser - passed inner locator for date (" +
                            locatorArray.join("/") + ") -- not currently showing this date.",
                            "AutoTest");
            }

            this.logWarn("DateChooser, unable to find element for inner locator:"+
                locatorArray + " returning handle");
            return handle;
        }
    });
}

};


// We want to respond to interaction with calendar events based on event name and
// potentially date /title.
// Cases to handle:
// - interacting with cells in the 3 standard ListGrid views (day, week, month)
// - interacting with event links within cells in the month view
// - interacting with eventWindow auto-children associated with existing events

// Note we also need to handle interaction with various auto-children -- the date picker,
// prev/next buttons, etc. These should be handled by the standard "single auto child"
// subsystem rather than needing any special logic.

// Putting this into a method (customizeCalendar()) means we can call this at the end
// of Calendar.js rather than having to worry about whether the module has been loaded or not.
isc.AutoTest.customizeCalendar = function () {


    // locateCellsBy
    //  - date
    //      - implies date AND time
    //  - index
    //      - rowNum/colNum


    // locateEventsBy
    //  - name
    //  - title
    //  ? event type
    //  - startDate
    isc._commonCalenderViewFunctions = {

        // Override the method to set up the 'rowLocator' - this should store
        // date and time and use that for preference over other locators
        // Note: we're leaving the columns alone here: for the day view we show only
        // two columns -- the label and the day column -- we'll already identify the correct
        // one based on field name

        // builds a config type object that we'll pass to createLocatorFallbackPath
        getRowLocatorOptions : function calendarView_getRowLocatorOptions (body, rowNum, colNum) {

            // Pick up standard options - this will get the rowNum for us
            // (Other options, such as primary key don't have much use here)
            var options = this.Super("getRowLocatorOptions", arguments);

            var date = this.creator.chosenDate;
            options.date = date.toSchemaDate("date");

            // time always starts at 12am
            // We show 2 rows per hour.
            // so just count rows to get time
            options.minutes = rowNum * 30;
            return options;

        },


        // parse a stored locator configuration back to the appropriate cell
        // If we're identifying by date, use the stored date / minutes
        // otherwise just use index
        getRowNumFromLocatorConfig : function calendarView_getRowNumFromLocatorConfig (rowConfig) {
            var locateCellsBy = this.creator.locateCellsBy;
            if ((locateCellsBy == "date" || locateCellsBy == null) &&
                rowConfig.date != null)
            {
                var date = isc.Date.parseSchemaDate(rowConfig.date);
                if (!this.showingDate(date)) {
                    this.logWarn("Locator for cell in this calendar day-view grid has date " +
                        "stored as:" + date.toUSShortDate() + ", but we're currently showing " +
                        this.creator.chosenDate.toUSShortDate() +
                        ". The stored date doesn't map to a visible cell so not returning a cell " +
                        "- if this is not the intended behavior in this test case you may need to " +
                        "set calendar.locateCellsBy to 'index'.", "AutoTest");
                    return -1;
                }
                // map the stored minutes to the appropriate rowNum

                return parseInt(rowConfig.minutes) / 30;
            }
            this.locateRowsBy = "index";
            return this.Super("getRowNumFromLocatorConfig", arguments);
        },

        showingDate : function calendarView_showingDate (date) {
            return (isc.Date.compareLogicalDates(date, this.creator.chosenDate) == 0);
        }
    };
    isc.DaySchedule.addProperties(isc._commonCalenderViewFunctions);

    // WeekView - has fields for each day of the week (plus the label field)
    // field names are arbitrary ("day1", "day2" etc, not mapping to days of week).
    // However field objects have year, month, day stored as _yearNum, _dateNum, _monthNum
    // so we don't need to calculate based on location, etc
    isc.WeekSchedule.addProperties(isc._commonCalenderViewFunctions,{

        // override 'showingDate' -- we show a range of dates (a week's worth)
        // we could look at this.creator.chosenDate again but seems like it'd be easier just
        // to check the date values already stored on each visible field
        showingDate : function weekSchedule_showingDate (date) {
            for (var i = 0; i < this.fields.length; i++) {
                var field = this.fields[i];
                if (field._yearNum == null) continue;
                if (Date.compareLogicalDates(
                        Date.createLogicalDate(field._yearNum, field._monthNum, field._dateNum),
                        date
                    ) == 0)
                {
                    this.logWarn("does contain date" + date.toShortDate());
                    return true;
                }
                this.logWarn("date passed in:" + date.toShortDate() +
                    "compared with:" + Date.createLogicalDate(field._yearNum, field._monthNum,
                                                              field._dateNum).toShortDate());
            }

            this.logWarn("doesn't contain date:" + date);
            return false;
        },


        // Month view has meaningful fields - each column is one day
        // Store date information on our column locators and use it when
        // retrieving columns
        getColLocatorOptions : function weekSchedule_getColLocatorOptions (body, rowNum, colNum) {

            var locatorOptions = this.Super("getColLocatorOptions", arguments),
                gridColNum = this.getFieldNumFromLocal(colNum, body),
                field = this.getField(gridColNum);
            // the label field has no associated date, of course
            if (field && field._dateNum != null) {
                // the month is zero based - add one to it so it looks like the schema date
                // not really necessary but that way the date on the rowNum (derived from
                // this.chosenDate, using getSchemaDate()) will match the
                // date on the colNum in the locator string!
                locatorOptions.date = [field._yearNum, (field._monthNum+1), field._dateNum].join("-");
            }

            return locatorOptions;
        },

        // helper to pick up field based on 'checkboxField' status and name
        // If neither work, we will use field num instead
        getFieldFromColLocatorConfig : function weekSchedule_getFieldFromColLocatorConfig (colConfig) {

            if ((this.locateCellsBy == "date" || this.locateCellsBy == null) &&
                (colConfig.date != null))
            {
                var dateArr = colConfig.date.split("-");
                // we can ignore the month and year - if the chosen date wasn't already in
                // the range, rowNum will be -1 anyway so we won't return a cell.
                return this.getFields().find("_dateNum", dateArr[2]);

            }

            return this.Super("getFieldFromColLocatorConfig", arguments);
        }
    });

    // Month view:
    // MonthSchedule is a subclass of ListGrid as well - it shows one column per day of the
    // week, and 2 rows per week -- one row is the header containing date values
    // second row is the actual events
    // Events are embedded in the cells as link elements
    // We'll need to react to
    //  - click on header rows (goes to day view)
    //  - click on empty cells (shows window to add an event)
    //  - click on stored event links (shows window to edit event)
    // Once again we'll use locateCellsBy "date" to find cells
    // If set to index we'll just set locateRowsByIndex and let standard handling occur
    // for the month

    // each field is named 'day1' [, 'day2', ...]
    // Each record has a 'day1' value which matches that of the field header, and a
    //  date1 value which actually specifies the date the row represents
    // The "1", "2", etc is specified by looking at field._dayIndex
    //
    // So the 'date1' value in the first row (a header row) matches the 'date1' value in the
    // second row (an 'event' row), and is the date we're showing in the 'day1' column (the
    // first column) and so on...

    // rows that are actual dates have an events array attached to them -- usually empty
    // rows that are not actual dates (so header rows) have no events array

    // Events within Month cells:
    // We record info about the event rather than the cell (essentially the date) it's located
    // in for event-links within month cells.
    // When we attempt to find the event links we can therefore have the Calendar find the
    // event and then try to find the link associated with that event in our view.

    // Event links call 'monthViewEventClick(rowNum,colNum,index)' on the calendar, so we
    // will parse this href string to determine which event is being interacted with...

    isc.MonthSchedule.addProperties({

        getRowLocatorOptions : function monthSchedule_getRowLocatorOptions (body, rowNum, colNum) {

            // Pick up standard options - this will get the rowNum for us
            // (Other options, such as primary key don't have much use here)
            var options = this.Super("getRowLocatorOptions", arguments);
            var record = this.getRecord(rowNum);
            if (!record) return options; // sanity check only

            var field = this.getField(colNum);

            var dayIndex = field._dayIndex;
            options.dayIndex = dayIndex;
            var date = record["date" + dayIndex];
            options.date = date.toSchemaDate("date");

            var events = record["event" + dayIndex];
            if (events == null) {
                options.isHeaderRow = true;
            } else {
                options.isHeaderRow = false;
            }
            return options;
        },

        getRowNumFromLocatorConfig : function monthSchedule_getRowNumFromLocatorConfig (rowConfig) {

            var locateCellsBy = this.creator.locateCellsBy;
            if ((locateCellsBy == "date" || locateCellsBy == null) &&
                rowConfig.date != null)
            {
                var date = isc.Date.parseSchemaDate(rowConfig.date),
                    headerRow = (rowConfig.isHeaderRow == "true"),
                    dateField = "date" + rowConfig.dayIndex,
                    eventField = "event" + rowConfig.dayIndex;
                for (var i = 0; i < this.data.length; i++) {
                    var isHeader = (this.data[i][eventField] == null);
                    if (isHeader == headerRow) {
                        if (Date.compareLogicalDates(this.data[i][dateField], date) == 0) {
                            return i;
                        }
                    }
                }
                // no matching record (by date)
                return -1;
            }
            this.locateRowsBy = "index";
            return this.Super("getRowNumFromLocatorConfig", arguments);
        },

        getColLocatorOptions : function monthSchedule_getColLocatorOptions (body, rowNum, colNum) {
            var options = this.Super("getColLocatorOptions", arguments);
            // if we just record the dayIndex we can use that to find the column.
            // If the configuration changes such that (for example) the date isn't showing,
            // we'll just fail to find the cell so return -1 from getRowNumFromLocatorConfig
            options.dayIndex = this.getField(colNum)._dayIndex;
            return options;
        },

        getColNumFromLocatorConfig : function monthSchedule_getColNumFromLocatorConfig (colConfig) {
            var locateCellsBy = this.locateCellsBy;
            if (locateCellsBy == null || locateCellsBy == "date") {
                return this.fields.findIndex("_dayIndex", parseInt(colConfig.dayIndex));
            }

            this.locateColsBy = "index";
            return this.Super("getColNumFromLocatorConfig", arguments);
        }

    });


    isc.MonthScheduleBody.addProperties({

        // override getInterior locator to actually identify event link locators
        // (based on event rather than cell location)
        getInteriorLocator : function monthScheduleBody_getInteriorLocator (element) {
            if (element.tagName.toLowerCase() == "a") {
                var href = element.href;
                if (href != null) {
                    // We're using the href -- this is pretty hokey but no
                    // other info is written into the DOM element...
                    // It should be robust across page reloades etc since the
                    // stored locator is based on the event directly -- not on the
                    // href directly -- we just use that to find the event (and then to
                    // find tha ppropriate link from the event when parsing locators)

                    // double escaping necessary -- first is eaten by quotes
                    var match = href.match("javascript:.*monthViewEventClick\\((\\d+),(\\d+),(\\d+)\\);");
                    //this.logWarn("match!:" + match);
                    if (match) {
                        var row = parseInt(match[1]),
                            col = parseInt(match[2]),
                            index = parseInt(match[3]);
                        var events = this.grid.getEvents(row,col),
                            event = events[index];

                        if (event == null) {
                            this.logWarn("Unable to determine event associated with apparent event " +
                                "link element -- returning cell");
                            return this.Super("getInteriorLocator", arguments);
                        }

                        var calendar = this.grid.creator,
                            config = calendar.getEventLocatorConfig(event);
                        var string = isc.AutoTest.createLocatorFallbackPath("eventLink", config);
                        //this.logWarn("string:" + string);
                        return string;
                    }
                }
            }

            return this.Super("getInteriorLocator", arguments);
        },

        getInnerAttributeFromSplitLocator : function
        monthScheduleBody_getInnerAttributeFromSplitLocator (locatorArray, configuration)
        {
            if (configuration.attribute != isc.Canvas._$Element) {
                this.setLogFailureText(true, "getValue() is not supported for");
                return;
            }

            if (this.emptyLocatorArray(locatorArray)) return this._getHandleAndLogFailure();

            // if it starts with "eventLink" - get the relevant event from the Calendar
            // and then find it in our body if possible
            if (locatorArray.length == 1 && locatorArray[0].startsWith("eventLink")) {
                var fullConfig = isc.AutoTest.parseLocatorFallbackPath(locatorArray[0]);

                var calendar = this.grid.creator;
                var event = calendar.getEventFromLocatorConfig(fullConfig.config);

                var cell = this.grid.getEventCell(event);

                if (cell != null) {
                    var data = this.grid.data,
                        rowNum = cell[0],
                        colNum = cell[1],
                        dayIndex = this.grid.getField(colNum)._dayIndex;

                    var cellElement = this.getTableElement(rowNum,colNum),
                        links = cellElement.getElementsByTagName("A");
                    if (links != null) {
                        for (var iii = 0; iii < links.length; iii++) {
                            var href = links[iii].href;
                            if (href != null) {
                                // double escaping necessary -- first is eaten by quotes
                                var match = href.match("javascript:.*monthViewEventClick" +
                                                       "\\((\\d+),(\\d+),(\\d+)\\);");
                                if (match && data[rowNum]["event"+dayIndex][parseInt(match[3])]
                                    == event)
                                {
                                    return links[iii];
                                }
                            }
                        }
                    }
                }
                return this.Super("getInnerAttributeFromSplitLocator", arguments);
            }
         }

    });

    // Events:
    // Calendars are dataBound components where this.data is a set of events to show
    // (May come from a dataSource).
    // In Day and Week views, events show up as windows floating over the grid body
    // In Month view events are embedded directly in the cells
    // Modify the standard row locator / parsing logic to store / retrieve events
    // and find the appropriate windows (or link elements in the month view)
    isc.Calendar.addProperties({

        // this method gets called automatically for autoChildren.
        // Pick up eventWindows and store information based on the event they represent
        getCanvasLocatorFallbackPath : function calendar_getCanvasLocatorFallbackPath (name,
                                                      canvas, sourceArray, properties, mask)
        {
            if (name == "eventWindow" || name == "eventCanvas") {
                var options = this.getEventLocatorConfig(canvas.event);
                return isc.AutoTest.createLocatorFallbackPath(name, options);
            }
            return this.Super("getCanvasLocatorFallbackPath", arguments);
        },

        getEventLocatorConfig : function calendar_getEventLocatorConfig (event) {
            this.logWarn("In getEventLocatorConfig().  event:" + this.echo(event));
            var config = {};
            if (this.dataSource) {
                var pkFields = this.getDataSource().getPrimaryKeyFieldNames();
                for (var i = 0; i < pkFields.length; i++) {
                    config[pkFields[i]] = event[pkFields[i]];
                }
            }

            var nameField = this.nameField;
            config[nameField] = event[nameField];

            var startField = this.startDateField;
            var startTime = event[startField];
            config[startField] = startTime.toSchemaDate();

            var endField = this.endDateField;
            var endTime = event[endField];
            config[endField] = endTime.toSchemaDate();

            config.index = this.data.indexOf(event);
            //this.logWarn("event config: " + this.echo(config));
            return config;
        },

        // substring param really just used for logging
        getChildFromFallbackLocator : function calendar_getChildFromFallbackLocator (substring,
                                                                         fallbackLocatorConfig)
        {
            var type = fallbackLocatorConfig.name,
                config = fallbackLocatorConfig.config;

            if (type == "eventWindow" || type == "eventCanvas") {
                var viewName = this.mainView.getSelectedTab().viewName;
                if (viewName == "day") {
                    var children = this.dayView.body.children;
                } else if (viewName == "week") {
                    var children = this.weekView.body.children;
                }

                if (children != null) {
                    var event = this.getEventFromLocatorConfig(config),
                        eWindow = children.find("event", event);
                    return eWindow;
                }
                this.logWarn("unable to find event window associated with event:" + this.echo(event) +
                    " based on locator string:" + substring +
                    ". It's possible that this event is not visible in the current view of " +
                    "this Calendar", "AutoTest");
                return null;
            }

            return this.Super("getChildFromFallbackLocator", arguments);
        },

        // we need date support.
        // So we need to be able to customize fields to record

        getEventFromLocatorConfig : function calendar_getEventFromLocatorConfig (config) {
            var locateBy = this.locateEventsBy;
            if (locateBy == null) locateBy = "primaryKey";

            switch (locateBy) {
            case "primaryKey":
                this.logDebug("Trying to locate event by pk", "autotest");
                var ds = this.getDataSource();
                if (ds) {
                    var pkFields = ds.getPrimaryKeyFieldNames(),
                        allKeys = pkFields.length > 0,
                        keyVals = {};
                    for (var i = 0; i < pkFields.length; i++) {
                        if (config[pkFields[i]] == null) {
                            allKeys = false;
                            break;
                        } else {
                            keyVals[pkFields[i]] = config[pkFields[i]];
                        }
                    }
                    if (allKeys) {
                        this.logDebug("All key fields present: " + isc.echoAll(keyVals), "autotest");
                        var record = ds.findByKeys(config, this.data);
                        if (record != null && record != -1) {
                            this.logDebug("Successfully located event by pk.  Record: " +
                                            isc.echoAll(this.data.get(record)), "autotest");
                            return this.data.get(record);
                        }
                    } else {
                        this.logDebug("PK values missing. Config: " + isc.echoAll(config),
                                            "autotest");
                    }
                }

                this.logDebug("Failed to locate event by pk.  Config: " + isc.echoAll(config),
                              "autotest");

                // The missing break statement here is intentional - we want to fall through
                // to the next case


                // NOTE: The skipFallback property is an internal flag to ensure that the
                // row is located by primary key, or not at all.  The primary motivation
                // for adding it is to enable automated testing of the PK functionality;
                // for that, we have to be certain that the element was located by
                // primaryKey and not some fallback strategy
                if (isc.AutoTest.skipFallback) return null;

            case "name":
                var name = config[this.nameField];
                if (name != null) return this.data.find(this.nameField, name);


            case "date":
                // we could convert these to dates, and then compare via compareDate but
                // that could trip up on millisecond differences, etc -- this seems a
                // safer approach.
                var startTime = config[this.startDateField],
                    endTime = config[this.endDateField];

                // we're going to have to find all dates where start AND end time match
                // we could get more sophisticated and match start / end separately too
                // but that seems like an odd use case
                for (var i = 0; i < this.data.length; i++) {
                    var testEvent = this.data.get(i);
                    if (testEvent == null) continue;

                    if (testEvent[this.startDateField].toSchemaDate() == startTime &&
                        testEvent[this.endDateField].toSchemaDate() == endTime)
                    {
                        return testEvent;
                    }
                    this.logWarn("attempt to match calendar event by startDate / endDate " +
                        "unable to locate any events. Backing off to index within data array");
                }

            // back off to locating by index within this.data
            default:
                var index = parseInt(config.index);
                return this.data.get(index);


            }
        }

    });

    // support SC 9.1 and earlier Calendar EventWindow header/body locators (backcompat)
    if (isc.EventCanvas) isc.EventCanvas.addProperties ({
        getInnerAttributeFromSplitLocator : function
        eventCanvas_getInnerAttributeFromSplitLocator (locatorArray, configuration) {
            var attribute     = configuration.attribute,
                returnValue   = attribute == isc.Canvas._$Value,
                returnElement = attribute == isc.Canvas._$Element;
            if ((returnValue || returnElement) && locatorArray.length == 1) {
                switch (locatorArray[0]) {
                case "body":
                    return returnValue ? this.getBodyHTML() : this._getHandleAndLogFailure();
                case "headerLabel":
                    return returnValue ? this.getHeaderHTML() : this._getHandleAndLogFailure();
                }
            }
            return this.Super("getInnerAttributeFromSplitLocator", arguments);
        },
        // restore capability to distinguish header and body with current widget hierarchy
        getInteriorLocator : function eventCanvas_getInteriorLocator (element) {
            var partIdentifier = this.getElementPart(element);
            if (partIdentifier) {
                var part = partIdentifier.part;
                if (part == "headerLabel" || part == "body") return part;
            }
            return this.Super("getInteriorLocator", arguments);
        }
    });

};
if (isc.Calendar) isc.AutoTest.customizeCalendar();


// Hold off applying the AutoTest interface methods to widget classes until the page is done
// loading.  This ensures we don't depend on module load order.
//

if (!isc.Page.isLoaded()) {
    isc.Page.setEvent("load", "isc.ApplyAutoTestMethods()");
} else {
    isc.ApplyAutoTestMethods();
}

isc.AutoTest.addClassMethods({

    //>    @classAttr AutoTest.implicitNetworkWait (boolean : false : [IRW])
    // Controls whether certain AutoTest APIs wait for network operations to complete
    // before returning true.  When value is true, +link{AutoTest.isElementClickable}
    // will return false until all network operations have completed.
    // @visibility external
    // @group autoTest
    //<
    implicitNetworkWait: false,

    //>    @classAttr AutoTest.testRoot (Canvas : null : [IRW])
    // Sets the implicit root canvas available in scLocators starting "//testRoot[]".
    // Setting this property may enable one to use the same script to test identical
    // widget hierarchies that are rooted under different base widgets.
    // @visibility external
    // @group autoTest
    //<

    _$testRoot: "//testRoot[]",
    testRoot: null,

    // helper also used in the user extendion files
    _isTextBased : function (element) {
         var tagName = element.tagName;
        if (!element.tagName) return false;
        tagName = tagName.toLowerCase();
        return tagName == "textarea" || tagName == "input" &&
            (element.type == "text" || element.type == "password" || element.type == "file");
    },

    //> @classMethod AutoTest.setTestRoot()
    // Sets the implicit root canvas available in scLocators starting "//testRoot[]".
    // Setting this property may enable one to use the same script to test identical
    // widget hierarchies that are rooted under different base widgets.
    // @param canvas (Canvas) the implicit root
    // @visibility external
    // @group autoTest
    //<
    setTestRoot : function (canvas) {
        this.testRoot = canvas;
        if (canvas != null) {
            this.logInfo("setting testRoot to canvas " + canvas.ID + ", so scLocators " +
                "starting " + this._$testRoot + "... will now be seen as rooted there");
        } else {
            this.logInfo("clearing the testRoot canvas, so scLocators " +
                "starting " + this._$testRoot + "... may no longer be used");
        }
    },

    // provides access to the canvas capable of scrolling the test root canvas
    getTestRootScrollCanvas : function () {
        if (this.testRoot == null) {
            this.logWarn("Unable to locate the scroll canvas containing the test root " +
                         "when no test root canvas has been configured");
            return null;
        }

        var explorer = window.featureExplorer;
        if (explorer != null) return explorer.exampleViewer.viewPane;

        for (var pane = this.testRoot; !isc.isA.PaneContainer(pane); pane = pane.parentElement);
        return pane;
    },

    //> @classMethod AutoTest.isCanvasDone()
    // Returns whether the canvas <smartclient>associated with the given DOM element
    // </smartclient>is in a consistent state with no pending operations.  Returns null
    // if the <smartclient>argument is not valid or isn't associated with an element
    // representing</smartclient><smartgwt>supplied argument is not</smartgwt> a valid canvas.
    // Otherwise, returns true or false according as the conditions below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> canvas is drawn
    //     <li> canvas isn't dirty
    //     <li> canvas has no queued overflow operations
    //     <li> canvas is not animating
    // </ul>
    // @param element (Canvas | DOMElement | AutoTestLocator) <smartclient> DOM element to test
    // (element obtained from canvas or SmartClient locator if provided)</smartclient>
    // <smartgwt>canvas to test</smartgwt>
    // @return (Boolean) whether <smartclient>element</smartclient>
    // <smartgwt>canvas</smartgwt> is 'done' as described above
    // @visibility external
    // @group autoTest
    //<
    isCanvasDone : function (element) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isCanvasDoneLog = "the page is not loaded";
            return false;
        }
        // bail out with null value if element not valid
        if (element == null) {
            this._isCanvasDoneLog = "the element is null";
            return null;
        }

        // support passing a locator to the element in lieu of the element itself'
        if (isc.isA.String(element)) element = this.getElement(element);

        // allow a canvas to be passed in as the element
        var canvas = isc.isA.Canvas(element) ? element :
            this.locateCanvasFromDOMElement(element);

        // if canvas not valid, report to alert the user and return false
        if (canvas == null) {
            this._isCanvasDone = "there's no Canvas identified by " + this.getLocator(element);
            return null;
        }

        // if canvas isn't drawn or is dirty, report as 'not done'
        if (!canvas.isDrawn()) {
            canvas.setLogFailureText(true, null, "isn't drawn");
            return false;
        }
        if (canvas.isDirty()) {
            canvas.setLogFailureText(true, null, "is dirty");
            return false;
        }

        // if canvas has pending overflow operations, report as 'not done'
        if (canvas._overflowQueued) {
            canvas.setLogFailureText(true, null, "has pending overflow operations");
            return false;
        }
        // if canvas is animating, report as 'not done'
        if (canvas.isAnimating && canvas.isAnimating() ||
            canvas._animating || canvas._pendingAnimationCallbacks > 0)
        {
            canvas.setLogFailureText(true,  null, "is currently animating");
            return false;
        }

        // if canvas has a pending scroll, report as 'not done'
        if (canvas._scrollTimeout != null) {
            canvas.setLogFailureText(true,  null, "currently has pending scroll events");
            return false;
        }


        if (isc.SplitPaneSidePanel && isc.isA.SplitPaneSidePanel(canvas) && !canvas.onScreen) {
            canvas.setLogFailureText(true, null, "has not yet set onSCreen: true");
            return false;
        }

        return true;
    },

    //> @classMethod AutoTest.isTileLayoutDone()
    // Returns whether the TileLayout <smartclient>associated with the given DOM element
    // </smartclient>is in a consistent state with no pending operations.  Returns null if the
    // <smartclient>argument is not valid or isn't associated with an element representing
    // </smartclient><smartgwt>supplied canvas is not</smartgwt> a valid TileLayout.
    // Otherwise, returns true or false according as the conditions below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> the TileLayout (as a canvas) satisfies +link{isCanvasDone()}
    //     <li> the TileLayout is not currently animating any layout operations
    // </ul>
    // @param element (Canvas | DOMElement | AutoTestLocator) <smartclient> DOM element to test
    // (element obtained from canvas or SmartClient locator if provided)</smartclient>
    // <smartgwt>TileLayout to test</smartgwt>
    // @return (Boolean) whether <smartclient>element</smartclient>
    // <smartgwt>TileLayout</smartgwt> is 'done' as described above
    // @visibility external
    // @group autoTest
    //<
    isTileLayoutDone : function (element) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isTileLayoutDoneLog = "the page is not loaded";
            return false;
        }
        // bail out with null value if element not valid
        if (element == null) {
            this._isTileLayoutDoneLog = "the element is null";
            return null;
        }

        // support passing a locator to the element in lieu of the element itself
        if (isc.isA.String(element)) element = this.getElement(element);

        // allow a canvas to be passed in as the element
        var tileLayout = isc.isA.Canvas(element) ? element :
            this.locateCanvasFromDOMElement(element);

        // if canvas not valid, report to alert the user and return false
        if (tileLayout == null || !isc.isA.TileLayout(tileLayout)) {
            this._isTileLayoutDoneLog = this.getLocator(element) +
                " does not correspond to a valid TileLayout!";
            return null;
        }

        // fail if underlying canvas is not reporting done
        if (!this.isCanvasDone(tileLayout)) return false;

        // fail if pending layout animation operations or currently animating
        if (tileLayout.isAnimatingTileLayout()) {
            tileLayout.setLogFailureText(true, null, "is currently animating");
            return false;
        }

        // fail if a layoutAfterScroll has been scheduled
        if (tileLayout._layoutEventId != null) {
            tileLayout.setLogFailureText(true, null, "has a layout after scroll scheduled");
            return false;
        }

        return true;
    },

    //> @classMethod AutoTest.isTileGridDone()
    // Returns whether the TileGrid <smartclient>associated with the given DOM element
    // </smartclient>is in a consistent state with no pending operations.  Returns null if the
    // <smartclient>argument is not valid or isn't associated with an element representing
    // </smartclient><smartgwt>supplied canvas is not</smartgwt> a valid TileGrid.
    // Otherwise, returns true or false according as the conditions below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> the TileGrid (as a tileLayout) satisfies +link{isTileLayoutDone()}
    //     <li> the TileGrid has no pending layout animation operations queued
    // </ul>
    // @param element (Canvas | DOMElement | AutoTestLocator) <smartclient> DOM element to test
    // (element obtained from canvas or SmartClient locator if provided)</smartclient>
    // <smartgwt>TileGrid to test</smartgwt>
    // @return (Boolean) whether <smartclient>element</smartclient>
    // <smartgwt>TileGrid</smartgwt> is 'done' as described above
    // @visibility external
    // @group autoTest
    //<
    isTileGridDone : function (element) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isTileGridDoneLog = "the page is not loaded";
            return false;
        }
        // bail out with null value if element not valid
        if (element == null) {
            this._isTileGridDoneLog = "the element is null";
            return null;
        }

        // support passing a locator to the element in lieu of the element itself
        if (isc.isA.String(element)) element = this.getElement(element);

        // allow a canvas to be passed in as the element
        var tileGrid = isc.isA.Canvas(element) ? element :
            this.locateCanvasFromDOMElement(element);

        // if canvas not valid, report to alert the user and return false
        if (tileGrid == null || !isc.isA.TileGrid(tileGrid)) {
            this._isTileGridDoneLog = this.getLocator(element) +
                " does not correspond to a valid TileGrid!";
            return null;
        }

        // fail if underlying canvas is not reporting done
        if (!this.isTileLayoutDone(tileGrid)) return false;

        // fail if pending layout animation operations or currently animating
        if (tileGrid.pendingActionOnPause("tileGridAnimate")) {
            tileGrid.setLogFailureText(true, "there is a pending animation for");
            return false;
        }

        // check for pending network operations if user has requested implicit waits
        if (this.implicitNetworkWait && tileGrid.requestsArePending()) {
            tileGrid.setLogFailureText(true, "there are DSRequests pending for");
            return false;
        }

        return true;
    },

    //> @classMethod AutoTest.isFormDone()
    // Returns whether the DynamicForm <smartclient>associated with the given DOM element
    // </smartclient>is in a consistent state with no pending operations.  Returns null
    // if the <smartclient>argument is not valid or isn't associated with an element
    // representing</smartclient><smartgwt>supplied argument is not</smartgwt> a valid
    // +link{DynamicForm}.  Otherwise, returns true or false according as the conditions
    // below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> form has no pending delayed "set values" or "set values focus" operations
    //     <li> all contained items satisfy +link{isItemDone()}
    // </ul>
    // @param element (Canvas | DOMElement | AutoTestLocator) <smartclient> DOM element to test
    // (element obtained from canvas or SmartClient locator if provided)</smartclient>
    // <smartgwt>canvas to test</smartgwt>
    // @return (Boolean) whether <smartclient>element</smartclient>
    // <smartgwt>canvas</smartgwt> is 'done' as described above
    // @visibility external
    // @group autoTest
    //<
    isFormDone : function (element) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isFormDoneLog = "the page is not loaded";
            return false;
        }
        // bail out with null value if element not valid
        if (element == null) {
            this._isFormDoneLog = "the element is null";
            return null;
        }

        // support passing a locator to the element in lieu of the element itself
        if (isc.isA.String(element)) element = this.getElement(element);

        // if a DOM element has been passed, resolve it into a DynamicForm and FormItem
        var form = element, item;
        if (!isc.isA.Class(element)) {
            form = this.locateCanvasFromDOMElement(element);
            item = this.locateFormItemFromDOMElement(form);
        }

        // bail out if not a DynamicForm, or if invalid FormItem found
        if (!isc.isA.DynamicForm(form)) {
            this._isFormDoneLog = element + " does not correspond to a valid DynamicForm!";
            return null;
        }
        if (item != null && !isc.isA.FormItem(item)) {
            this._isFormDoneLog = "invalid FormItem passed"
            return null;
        }

        // we're not "done" if there's a pending _delayedSetValues()/_delayedSetValuesFocus()
        if (form._setValuesPending) {
            form.setLogFailureText(true, "a delayedSetValues(Focus)() call is pending for");
            return false;
        }


        var checkOnlyIfDrawn = true;

        // fail if any FormItems (or the one passed) are not done
        var itemsToCheck = item ? [item] : form.items;
        for (var i = 0; i < itemsToCheck.length; i++) {
            var item = itemsToCheck[i];
            if (item.containerWidget == form) checkOnlyIfDrawn = false;

            var itemDone = this.isItemDone(item);
            if (itemDone != true) return itemDone;
        }

        // if we're not in "strict mode" or form is drawn, it must satisy isCanvasDone()
        if ((!checkOnlyIfDrawn || form.isDrawn()) && !this.isCanvasDone(form)) return false;

        return true;
    },

    //> @classMethod AutoTest.isItemDone()
    // Returns whether the FormItem <smartclient>associated with the given DOM element
    // </smartclient>is in a consistent state with no pending operations.  Returns null
    // if the <smartclient>argument is not valid or isn't associated with an element
    // representing</smartclient><smartgwt>supplied argument is not</smartgwt> a valid
    // +link{FormItem}.  Otherwise, returns true or false according as the conditions
    // below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> if the container widget of the item isn't the parent DynamicForm,
    //          then the container widget must satisfy +link{isCanvasDone()}
    //     <li> the item cannot have any fetches in progress for missing
    //          display/value field values
    //     <li> picklists (+link{selectItem} or +link{comboBoxItem}) cannot have
    //          any pending row fetches
    // </ul>
    // @param element (FormItem | DOMElement | AutoTestLocator) <smartclient> DOM element to
    // test (element obtained from canvas or SmartClient locator if provided)</smartclient>
    // <smartgwt>canvas to test</smartgwt>
    // @return (Boolean) whether <smartclient>element</smartclient>
    // <smartgwt>item</smartgwt> is 'done' as described above
    // @visibility external
    // @group autoTest
    //<
    isItemDone : function (element) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isItemDoneLog = "the page is not loaded";
            return false;
        }
        // bail out with null value if element not valid
        if (element == null) {
            this._isItemDoneLog = "the element is null";
            return null;
        }

        // support passing a locator to the element in lieu of the element itself
        if (isc.isA.String(element)) element = this.getElement(element);

        // if a DOM element has been passed, resolve it into a DynamicForm and FormItem
        var item = element;
        if (!isc.isA.FormItem(element)) {
            item = this.locateFormItemFromDOMElement(element);
        }

        // bail out if not resolved to a FormItem
        if (!isc.isA.FormItem(item)) {
            this._isItemDoneLog = element + " does not correspond to a valid FormItem!";
            return null;
        }

        // check that any container widget is "done"
        var form = item.form,
            containerWidget = item.containerWidget;
        if (containerWidget && containerWidget != form && !containerWidget._isProcessingDone())
        {
            item.setLogFailureText(true, "the container canvas of", "reports " +
                                   this.getLogFailureText(true));
            return false;
        }

        // formItems cannot have any fetches in progress for display or value field values
        if (item._fetchMissingValueInProgress(true)) {
            item.setLogFailureText(true, "display/value field values are being fetched for");
            return false;
        }

        // textItems cannot have any pending delayed select operations
        if (isc.isA.TextItem(item) && item._delayedSelect) {
            item.setLogFailureText(true, "a delayed select operation " +
                                   "is pending for");
            return false;
        }

        // selectItems/comboBoxItems cannot have pending fetches
        if (isc.PickList && isc.isA.PickList(item)) {
            if (item.pendingActionOnPause("fetch")) {
                item.setLogFailureText(true, "a delayed fetch is queued for");
                return false;
            }
            if (item._fetchingPickListData) {
                item.setLogFailureText(true, null, "has a fetch oustanding");
                return false;
            }
        }

        return true;
    },

    // internal helper only called by isGridDone()
    _isGridBodyDone : function (gridBody) {
        if (gridBody == null) return true;

        var text = "body",
            grid = gridBody.grid;

        if (grid.body != gridBody) text = "frozen " + text;

        // if we need to redraw (e.g. pending sort) we're not done
        if (gridBody.isDirty() && gridBody.isDrawn()) {
            grid.setLogFailureText(true, "the " + text + " of", "is dirty");
            return false;
        }
        // if a scroll is in progress, we're not done
        if (gridBody.pendingActionOnPause("scrollRedraw")) {
            grid.setLogFailureText(true, null, "is scrolling");
            return false;
        }

        return true;
    },

    //> @classMethod AutoTest.isGridDone()
    // Returns whether the ListGrid <smartclient>associated with or contained by the given
    // DOM element</smartclient><smartgwt>supplied or containing the supplied canvas</smartgwt>
    // is in a consistent state with no pending operations.  Returns null if the <smartclient>
    // argument is not valid or isn't associated with an element inside a valid ListGrid.
    // </smartclient><smartgwt>supplied canvas is not a ListGrid or contained in a ListGrid.
    // </smartgwt>
    // Otherwise, returns true or false according as the conditions below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> no pending scroll operations
    //     <li> no pending filter editor operations
    //     <li> no unsaved edits to the grid records
    //     <li> no asynchronous regrouping operations are in progress
    //     <li> no outstanding fetch/filter operations are present for the ResultSet
    //     <li> no outstanding sort operations are present that will update the ListGrid
    // </ul>
    // @param element (Canvas | DOMElement | AutoTestLocator) <smartclient> DOM element to test
    // (element obtained from canvas or SmartClient locator if provided)</smartclient>
    // <smartgwt>canvas to test</smartgwt>
    // @return (Boolean) whether <smartclient>element</smartclient>
    // <smartgwt>canvas</smartgwt> is 'done' as described above
    // @visibility external
    // @group autoTest
    //<
    isGridDone : function (element, allowEdits) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isGridDoneLog = "the page is not loaded";
            return false;
        }
        // bail out with null value if element not valid
        if (element == null) {
            this._isGridDoneLog = "the element is null";
            return null;
        }

        // support passing a locator to the element in lieu of the element itself
        if (isc.isA.String(element)) element = this.getElement(element);

        // allow a canvas to be passed in as the element
        var grid = isc.isA.Canvas(element) ? element :
             this.locateCanvasFromDOMElement(element);

        // element may point to interior widget; search up to find owning ListGrid
        while (grid != null && !isc.isA.ListGrid(grid)) grid = grid.parentElement;

        // if owning ListGrid not found, report to alert the user and return false
        if (grid == null) {
            this._isGridDone = "there's no ListGrid containing locator " +
                this.getLocator(element);
            return null;
        }

        // if the grid has a summary row child grid, verify that it's done as well
        if (grid.summaryRow && !isc.AutoTest.isGridDone(grid.summaryRow, allowEdits)) {
            // log from nested call should be reported by the testReplay logger
            return false;
        }

        // check for pending network operations if user has requested implicit waits
        if (this.implicitNetworkWait && grid.requestsArePending()) {
            grid.setLogFailureText(true, "there are DSRequests pending for");
            return false;
        }

        var filterEditor = grid.filterEditor;

        // if the grid's filter editor has pending criteria, we cannot proceed
        if (filterEditor && filterEditor.pendingActionOnPause("performFilter")) {
            grid.setLogFailureText(true, "there is a pending " +
                                   "filter operation for the FilterEditor of");
            return false;
        }

        // if pending edits are present, grid is not done
        if (!allowEdits && grid.hasChanges()) {
            grid.setLogFailureText(true, null, "has unsaved edits");
            return false;
        }

        // if an asynchronous regroup is in progress we're not done
        if (grid._asyncRegroupInProgress) {
            grid.setLogFailureText(true, null, "is regrouping asynchronously");
            return false;
        }

        // check the ResultSet to make sure there's no outstanding fetch/filter operation
        if (grid.data != null && isc.isA.ResultSet(grid.data)) {
            if (!grid.data.lengthIsKnown()) {
                grid.setLogFailureText(true, "the length of the ResultSet " +
                                       "associated with", "is not yet known");
                return false;
            }
            if (grid.data.fetchIsPending()) {
                grid.setLogFailureText(true, "has a pending fetch");
                return false;
            }
        }

        // in useHighPerformanceGridTimings mode, there is no modal prompt, but the grid sets
        // this internal flag for when data is being fetched
        if (grid.loadingData) return false;

        // at this point we're done iff the body and frozen body (if any) are done
        return this._isGridBodyDone(grid.body) && this._isGridBodyDone(grid.frozenBody);
    },

    //> @classMethod AutoTest.isDrawPaneDone()
    // Returns whether the DrawPane <smartclient>associated with the given DOM element
    // </smartclient>is in a consistent state with no pending operations.  Returns null if the
    // <smartclient>argument is not valid or isn't associated with an element representing
    // </smartclient><smartgwt>supplied canvas is not</smartgwt> a valid DrawPane.
    // Otherwise, returns true or false according as the conditions below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> the DrawPane (as a canvas) satisfies +link{isCanvasDone()}
    //     <li> the DrawPane has no pending +link{DrawItem} (re)draws
    // </ul>
    // @param element (Canvas | DOMElement | AutoTestLocator) <smartclient> DOM element to test
    // (element obtained from canvas or SmartClient locator if provided)</smartclient>
    // <smartgwt>DrawPane to test</smartgwt>
    // @return (Boolean) whether <smartclient>element</smartclient>
    // <smartgwt>DrawPane</smartgwt> is 'done' as described above
    // @group autoTest
    //<
    isDrawPaneDone : function (element) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isTileGridDoneLog = "the page is not loaded";
            return false;
        }
        // bail out with null value if element not valid
        if (element == null) {
            this._isDrawPaneDoneLog = "the element is null";
            return null;
        }

        // support passing a locator to the element in lieu of the element itself
        if (isc.isA.String(element)) element = this.getElement(element);

        // allow a canvas to be passed in as the element
        var drawPane = isc.isA.Canvas(element) ? element :
            this.locateCanvasFromDOMElement(element);

        // if canvas not valid, report to alert the user and return false
        if (drawPane == null || !isc.isA.DrawPane(drawPane)) {
            this._isDrawPaneDoneLog = this.getLocator(element) +
                " does not correspond to a valid DrawPane!";
            return null;
        }

        // fail if underlying canvas is not reporting done
        if (!this.isCanvasDone(drawPane)) return false;

        // fail if there are pending DrawItem (re)draws
        if (drawPane._redrawPending || drawPane._redrawingDelayedDrawItems) {
            drawPane.setLogFailureText(true, null,
                "currently has DrawItem(s) waiting to be (re)drawn");
            return false;
        }

        return true;
    },

    //> @classMethod AutoTest.isElementClickable()
    // Returns whether the <smartclient>DOM element</smartclient><smartgwt>instance</smartgwt>
    // is ready to be clicked on by a Selenium test.  Returns null if the
    // <smartclient>argument is not valid or isn't associated with an element representing
    // </smartclient><smartgwt>supplied instance is not</smartgwt> a valid canvas or form item.
    // Otherwise, returns true or false according as the conditions below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> no network operations are outstanding (configurable,
    //          see +link{AutoTest.implicitNetworkWait})
    //     <li> canvas is visible, enabled, and not masked,
    //     <li> canvas satisfies +link{isCanvasDone()}
    //     <li> if canvas is a TileGrid, it satisfies +link{isTileGridDone()}
    //     <li> if canvas is a TileLayout, it satisfies +link{isTileLayoutDone()}
    //     <li> if canvas is a ListGrid or body of a ListGrid, it satisfies +link{isGridDone()}
    //     <li> if canvas is a DynamicForm, it satisfies +link{isFormDone()}
    // </ul>
    // Note that for a form item in a DynamicForm, the DynamicForm must satisfy the third
    // condition above, while the container widget of the element must satisfy the remaining
    // conditions.
    //
    // @param element (Canvas | FormItem | DOMElement | AutoTestLocator)
    // <smartclient> DOM element to test (element obtained from
    // canvas, form item, or SmartClient locator if provided)</smartclient>
    // <smartgwt>instance to test</smartgwt>
    // @return (Boolean) whether <smartclient>element</smartclient>
    // <smartgwt>instance</smartgwt> is 'clickable' as described above
    // @visibility external
    // @group autoTest
    //<
    isElementClickable : function (element) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isElementClickableLog = "the page is not loaded";
            return false;
        }
        // bail out with null value if element not valid
        if (element == null) {
            this._isElementClickableLog = "the element is null";
            return null;
        }

        // if a Canvas or FormItem has been passed, try to resolve it to element
        if (isc.isA.Canvas(element) || isc.isA.FormItem(element)) {
            element = element.getHandle();
        }

        // support passing a locator as the element in lieu of the element itself
        if (isc.isA.String(element)) element = this.getElement(element);

        // if locator is valid, but Canvas is not valid (null), something is wrong;
        // report the locator as not clickable and log a warning to the console
        var canvas = this.locateCanvasFromDOMElement(element);
        if (canvas == null) {
            this._isElementClickableLog = "there's no Canvas identified by " +
                element.getLocator();
            return null;
        }
        // check for pending network operations if user has requested implicit waits
        if (this.implicitNetworkWait && isc.RPCManager.requestsArePending()) {
            canvas.setLogFailureText(true, "RPCManager.requestsArePending() for");
            return false;
        }

        // always allow clicking on test root canvas
        if (canvas == this.testRoot) return true;

        // invisible canvas
        if (!canvas.isVisible()) {
            canvas.setLogFailureText(true, null, "isn't visible");
            return false;
        }

        // disabled canvas
        if (canvas.isDisabled()) {
            canvas.setLogFailureText(true, null, "is disabled");
            return false;
        }

        // masked target

        if (isc.EH.targetIsMasked(canvas, null, true)) {
            var mask = isc.EH.clickMaskRegistry.last() || {},
                instance = window[mask.ID];
            if (isc.isAn.Instance(instance)) {
                instance.setLogFailureText(false, null, "is blocking clicks at " +
                                           canvas._getDescription(true));
            } else {
                var blocker = mask.ID ? "click mask " + mask.ID : "an unknown click mask";
                canvas.setLogFailureText(true, null, "is blocked by " + blocker);
            }
            return false;
        }

        // verify that the associated canvas is done
        return canvas._isProcessingDone();
    },

    //> @classMethod AutoTest.isElementReadyForKeyPresses()
    // Given a DOM element, returns whether the associated SmartClient Canvas or FormItem is
    // ready to receive keyPress events from a Selenium test.  Returns null if the locator is
    // not valid or doesn't represent a valid Canvas or FormItem.  Otherwise, returns true or
    // false  according as the conditions below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> if a +link{textItem}, +link{fileItem}, or +link{textAreaItem},
    //          it has native focus,
    //     <li> the element satisfies +link{isElementClickable}
    // </ul>
    // @param element (Canvas | FormItem | DOMElement | AutoTestLocator) DOM element to test
    //     (element obtained from canvas, form item, or SmartClient locator if provided)
    // @return (Boolean) whether element is 'ready' as described above
    // @visibility external
    // @group autoTest
    //<
    isElementReadyForKeyPresses : function (element) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isElementReadyForKeyPressesLog = "the page is not loaded";
            return false;
        }
        // bail out with null value if element not valid
        if (element == null) {
            this._isElementReadyForKeyPressesLog = "the element is null";
            return null;
        }

        // if an Canvas or FormItem has been passed, try to resolve it to element
        if (isc.isA.Canvas(element) || isc.isA.FormItem(element)) {
            element = element.getHandle();
        }

        // support passing a locator to the element in lieu of the element itself
        if (isc.isA.String(element)) element = this.getElement(element);

        // if locator is valid, but Canvas is not valid (null), something is wrong;
        // report the locator as not clickable and log a warning to the console
        var canvas = this.locateCanvasFromDOMElement(element);
        if (canvas == null) {
            this._isElementReadyForKeyPressesLog = "there's no Canvas identified by " +
                element.getLocator();
            return null;
        }

        // text-based elements must have focus to accept keyPresses
        if (this._isTextBased(element) && element != document.activeElement) {
            canvas.setLogFailureText(true, "the text field in",
                                   "is not the active DOM element");
            return false;
        }

        return this.isElementClickable(element);
    },

    //> @classMethod AutoTest.isSystemDone()
    // Returns whether the loaded page is in a consistent state with no pending operations.
    // Specifically, returns true of false according as the conditions below are all satisfied:
    // <ul>
    //     <li> page has finished loading
    //     <li> all ListGrids (as defined by isc.isA.ListGrid) satisfy +link{isGridDone()}
    //     <li> all TileGrids that are drawn satisfy +link{isTileGridDone()}
    //     <li> all TileLayouts that are drawn satisfy +link{isTileLayoutDone()}
    //     <li> all DynamicForms that are drawn satisfy +link{isFormDone()}
    //     <li> all Canvii that are drawn satisfy +link{isCanvasDone()}
    //     <li> no network operations are outstanding (configurable,
    //          see +link{implicitNetworkWait})
    //     <li> there are no pending Canvas redraws (if includeRedraws parameter is true)
    // </ul>
    // Note: In a situation where messaging is being used to periodically refresh components,
    // or if the application contains a label updated every second to show the current time,
    // it's possible that this call might always return false if includeRedraws is true.
    // @param [includeRedraws] (boolean) whether to check for pending Canvas redraws
    // @param [allowEdits] (boolean) whether to allow unsaved edits for ListGrids
    // @return (boolean) whether loaded page is 'done' as described above
    // @visibility external
    // @group autoTest
    //<
    isSystemDone : function (includeRedraws, allowEdits) {

        // parts of AutoTest.js aren't present until page is loaded
        if (!isc.Page.isLoaded()) {
            this._isSystemDoneLog = "the page is not loaded";
            return false;
        }

        // check for pending network operations if user has requested implicit waits
        if (this.implicitNetworkWait && isc.RPCManager && isc.RPCManager.requestsArePending()) {
            this._isSystemDoneLog = "RPCManager.requestsArePending() is true";
            return false;
        }

        // check for pending redraws if requested
        var redrawQueue = isc.Canvas._redrawQeuue;
        if (includeRedraws && isc.isAn.Array(redrawQueue) && redrawQueue.length > 0) {
            this._isSystemDoneLog = "there are " + redrawQueue.length + " pending redraws";
            return false;
        }

        // check each canvas in the global list for being "done""
        for (var i = 0; i < isc.Canvas._canvasList.length; i++) {
            var canvas = isc.Canvas._canvasList[i];
            if (!canvas._isProcessingDone(true, !allowEdits)) {
                this._isSystemDoneLog = "Canvas " + canvas.ID + " is not done processing";
                return false;
            }
        }
        delete this._isSystemDoneLog;

        return true;
    },

    //////////////////////////////////// TestReplay Logging ////////////////////////////////////



    _loggedFunctions : [
        "isCanvasDone", "isItemDone", "isFormDone",
        "isTileLayoutDone", "isTileGridDone",
        "isGridBodyDone", "isGridDone", "isSystemDone",
        "isElementClickable", "isElementReadyForKeyPreses",
        "getTableElementAndLogFailure", "getHandleAndLogFailure", "reportInvalidCellLocator",
        "getInnerAttributeFromSplitLocator", "getAttributeFromSplitLocator",
        "getBaseComponentFromLocatorSubstring"
    ],

    _$startLocatorMarker : "!$originalLocator{",
    _$finishLocatorMarker : "}$!",

    _createLocatorMarker : function (locator) {
        if (!locator) locator = "";
        return this._$startLocatorMarker + locator + this._$finishLocatorMarker;
    },
    _replaceLocatorMarker : function (content, locator) {
        return content.replace(/!\$originalLocator\{.*\}\$!/, locator);
    },
    _populateLocatorMarker : function (content, clearMarker) {
        var fillText = "",
            originalLocator = this._originalLocator,
            markerMatch = content.match(/^.*!\$originalLocator\{(.*)\}\$!.*$/);

        if (originalLocator && markerMatch && !clearMarker) {
            var canvasLocator = markerMatch[0].replace(/!\$originalLocator\{(.*)\}\$!/, "$1");
            if (canvasLocator == "" || !this.locatorsEqual(canvasLocator, originalLocator)) {
                fillText = " and corresponding to original locator " + originalLocator;
            }
        }
        return this._replaceLocatorMarker(content, fillText);
    },

    applyFuncToLogSlots : function (slotFunc) {
        var functions = this._loggedFunctions;
        for (var i =0; i < functions.length; i++) {
            var logSlot = "_" + functions[i] + "Log",
                result = slotFunc(logSlot);
            if (result != null) return result;
        }
        return null;
    },
    setLogFailureText : function (locator, start, finish) {
        var callerFunc = isc.AutoTest.setLogFailureText.caller || arguments.callee.caller,
            callerName = callerFunc.name || isc.Func.getName(callerFunc, true),
            logSlot = callerName.replace(/^.*[_]+([^_]+)/, "\137$1" ) + "Log";
        if (this[logSlot]) return; // initial reporter has primacy
        this[logSlot] = this._getLogFailureText(locator, start, finish);
     },
    _getLogFailureText : function (locator, start) {
        var text;
        if (locator == true) text = this._originalLocator;
        else if (isc.isA.String(locator)) text = locator;
        return text ? start + " " + text : start;
    },
    getLogFailureText : function (clearMarker) {
        var autotest = this,
            log = this.applyFuncToLogSlots(function (logSlot) {
            var text = autotest[logSlot];
            if (text != null) autotest[logSlot] = null;
            return text;
        });
        return log ? this._populateLocatorMarker(log, clearMarker) : log;
    },
    clearAllLogSlots : function () {
        var autotest = this;
        return this.applyFuncToLogSlots(function (logSlot) {
            autotest[logSlot] = null;
        });
    },

    // Selenium API with implicit logging of all failures
    seleniumExecute : function (command, element, locator, argument) {

        this.clearAllLogSlots();
        this._originalLocator = locator || element;

        // run the command and return normally if successful
        var undef, result = this[command](element, argument);


        switch (command) {
        case "getElement":
            if (isc.isAn.Object(result)) return result;
            break;
        case "getValue":
            if (result !== undef) return result;
            break;
        default:
            if (result) return result;
        }

        // elevate testReplay priority to INFO for Selenium
        var oldPriority = isc.Log.getPriority("testReplay");
        if (oldPriority == null || oldPriority < isc.Log.INFO) {
            isc.Log.setPriority("testReplay", isc.Log.INFO);
        }

        var failureReport = this.getLogFailureText();
        if (failureReport) this.logInfo(command + "() returned " + result + " because " +
                                        failureReport, "testReplay");

        // restore previous testReplay logging level
        if      (oldPriority == null)        isc.Log.clearPriority("testReplay");
        else if (oldPriority < isc.Log.INFO) isc.Log.setPriority  ("testReplay", oldPriority);

        return result;
    }
});
 


//>DEBUG
isc.Page.logInfo("SmartClient Core ("+isc.version+" "+isc.buildDate+") initialized: " +
                 (isc.timeStamp() - isc._start) + "ms");
//<DEBUG

isc.Page.logInfo("document.compatMode: " + document.compatMode);

if (isc.Log.hasFireBug()) {
    isc.Log.logWarn("NOTE: Firebug is enabled. Firebug greatly slows the performance of " +
        "applications that make heavy use of JavaScript. Isomorphic highly recommends Firebug " +
        "for troubleshooting, but Firebug and other development tools should be disabled when " +
        "assessing the real-world performance of SmartClient applications.");
}

isc._debugModules = (isc._debugModules != null ? isc._debugModules : []);isc._debugModules.push('Core');isc.checkForDebugAndNonDebugModules();isc._moduleEnd=isc._Core_end=(isc.timestamp?isc.timestamp():new Date().getTime());if(isc.Log&&isc.Log.logIsInfoEnabled('loadTime'))isc.Log.logInfo('Core module init time: ' + (isc._moduleEnd-isc._moduleStart) + 'ms','loadTime');delete isc.definingFramework;if (isc.Page) isc.Page.handleEvent(null, "moduleLoaded", { moduleName: 'Core', loadTime: (isc._moduleEnd-isc._moduleStart)});}else{if(window.isc && isc.Log && isc.Log.logWarn)isc.Log.logWarn("Duplicate load of module 'Core'.");}

/*

  SmartClient Ajax RIA system
  Version v11.0p_2016-03-31/LGPL Deployment (2016-03-31)

  Copyright 2000 and beyond Isomorphic Software, Inc. All rights reserved.
  "SmartClient" is a trademark of Isomorphic Software, Inc.

  LICENSE NOTICE
     INSTALLATION OR USE OF THIS SOFTWARE INDICATES YOUR ACCEPTANCE OF
     ISOMORPHIC SOFTWARE LICENSE TERMS. If you have received this file
     without an accompanying Isomorphic Software license file, please
     contact licensing@isomorphic.com for details. Unauthorized copying and
     use of this software is a violation of international copyright law.

  DEVELOPMENT ONLY - DO NOT DEPLOY
     This software is provided for evaluation, training, and development
     purposes only. It may include supplementary components that are not
     licensed for deployment. The separate DEPLOY package for this release
     contains SmartClient components that are licensed for deployment.

  PROPRIETARY & PROTECTED MATERIAL
     This software contains proprietary materials that are protected by
     contract and intellectual property law. You are expressly prohibited
     from attempting to reverse engineer this software or modify this
     software for human readability.

  CONTACT ISOMORPHIC
     For more information regarding license rights and restrictions, or to
     report possible license violations, please contact Isomorphic Software
     by email (licensing@isomorphic.com) or web (www.isomorphic.com).

*/

